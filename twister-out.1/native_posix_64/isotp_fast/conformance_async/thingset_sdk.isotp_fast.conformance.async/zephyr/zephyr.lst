
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section .init:

0000000000401138 <_init>:
  401138:	d503201f 	nop
  40113c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  401140:	910003fd 	mov	x29, sp
  401144:	940003db 	bl	4020b0 <call_weak_fn>
  401148:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40114c:	d65f03c0 	ret

Disassembly of section .plt:

0000000000401150 <.plt>:
  401150:	a9bf7bf0 	stp	x16, x30, [sp, #-16]!
  401154:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401158:	f9461211 	ldr	x17, [x16, #3104]
  40115c:	91308210 	add	x16, x16, #0xc20
  401160:	d61f0220 	br	x17
  401164:	d503201f 	nop
  401168:	d503201f 	nop
  40116c:	d503201f 	nop

0000000000401170 <memcpy@plt>:
  401170:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401174:	f9461611 	ldr	x17, [x16, #3112]
  401178:	9130a210 	add	x16, x16, #0xc28
  40117c:	d61f0220 	br	x17

0000000000401180 <getcwd@plt>:
  401180:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401184:	f9461a11 	ldr	x17, [x16, #3120]
  401188:	9130c210 	add	x16, x16, #0xc30
  40118c:	d61f0220 	br	x17

0000000000401190 <strtoul@plt>:
  401190:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401194:	f9461e11 	ldr	x17, [x16, #3128]
  401198:	9130e210 	add	x16, x16, #0xc38
  40119c:	d61f0220 	br	x17

00000000004011a0 <strlen@plt>:
  4011a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4011a4:	f9462211 	ldr	x17, [x16, #3136]
  4011a8:	91310210 	add	x16, x16, #0xc40
  4011ac:	d61f0220 	br	x17

00000000004011b0 <exit@plt>:
  4011b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4011b4:	f9462611 	ldr	x17, [x16, #3144]
  4011b8:	91312210 	add	x16, x16, #0xc48
  4011bc:	d61f0220 	br	x17

00000000004011c0 <__libc_start_main@plt>:
  4011c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4011c4:	f9462a11 	ldr	x17, [x16, #3152]
  4011c8:	91314210 	add	x16, x16, #0xc50
  4011cc:	d61f0220 	br	x17

00000000004011d0 <strtoll@plt>:
  4011d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4011d4:	f9462e11 	ldr	x17, [x16, #3160]
  4011d8:	91316210 	add	x16, x16, #0xc58
  4011dc:	d61f0220 	br	x17

00000000004011e0 <strnlen@plt>:
  4011e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4011e4:	f9463211 	ldr	x17, [x16, #3168]
  4011e8:	91318210 	add	x16, x16, #0xc60
  4011ec:	d61f0220 	br	x17

00000000004011f0 <strtod@plt>:
  4011f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4011f4:	f9463611 	ldr	x17, [x16, #3176]
  4011f8:	9131a210 	add	x16, x16, #0xc68
  4011fc:	d61f0220 	br	x17

0000000000401200 <__sigsetjmp@plt>:
  401200:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401204:	f9463a11 	ldr	x17, [x16, #3184]
  401208:	9131c210 	add	x16, x16, #0xc70
  40120c:	d61f0220 	br	x17

0000000000401210 <__cxa_finalize@plt>:
  401210:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401214:	f9463e11 	ldr	x17, [x16, #3192]
  401218:	9131e210 	add	x16, x16, #0xc78
  40121c:	d61f0220 	br	x17

0000000000401220 <clock_gettime@plt>:
  401220:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401224:	f9464211 	ldr	x17, [x16, #3200]
  401228:	91320210 	add	x16, x16, #0xc80
  40122c:	d61f0220 	br	x17

0000000000401230 <setvbuf@plt>:
  401230:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401234:	f9464611 	ldr	x17, [x16, #3208]
  401238:	91322210 	add	x16, x16, #0xc88
  40123c:	d61f0220 	br	x17

0000000000401240 <snprintf@plt>:
  401240:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401244:	f9464a11 	ldr	x17, [x16, #3216]
  401248:	91324210 	add	x16, x16, #0xc90
  40124c:	d61f0220 	br	x17

0000000000401250 <__memcpy_chk@plt>:
  401250:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401254:	f9464e11 	ldr	x17, [x16, #3224]
  401258:	91326210 	add	x16, x16, #0xc98
  40125c:	d61f0220 	br	x17

0000000000401260 <__snprintf_chk@plt>:
  401260:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401264:	f9465211 	ldr	x17, [x16, #3232]
  401268:	91328210 	add	x16, x16, #0xca0
  40126c:	d61f0220 	br	x17

0000000000401270 <strtok_r@plt>:
  401270:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401274:	f9465611 	ldr	x17, [x16, #3240]
  401278:	9132a210 	add	x16, x16, #0xca8
  40127c:	d61f0220 	br	x17

0000000000401280 <sigemptyset@plt>:
  401280:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401284:	f9465a11 	ldr	x17, [x16, #3248]
  401288:	9132c210 	add	x16, x16, #0xcb0
  40128c:	d61f0220 	br	x17

0000000000401290 <strncmp@plt>:
  401290:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401294:	f9465e11 	ldr	x17, [x16, #3256]
  401298:	9132e210 	add	x16, x16, #0xcb8
  40129c:	d61f0220 	br	x17

00000000004012a0 <memset@plt>:
  4012a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4012a4:	f9466211 	ldr	x17, [x16, #3264]
  4012a8:	91330210 	add	x16, x16, #0xcc0
  4012ac:	d61f0220 	br	x17

00000000004012b0 <sleep@plt>:
  4012b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4012b4:	f9466611 	ldr	x17, [x16, #3272]
  4012b8:	91332210 	add	x16, x16, #0xcc8
  4012bc:	d61f0220 	br	x17

00000000004012c0 <__vfprintf_chk@plt>:
  4012c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4012c4:	f9466a11 	ldr	x17, [x16, #3280]
  4012c8:	91334210 	add	x16, x16, #0xcd0
  4012cc:	d61f0220 	br	x17

00000000004012d0 <calloc@plt>:
  4012d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4012d4:	f9466e11 	ldr	x17, [x16, #3288]
  4012d8:	91336210 	add	x16, x16, #0xcd8
  4012dc:	d61f0220 	br	x17

00000000004012e0 <pthread_cond_broadcast@plt>:
  4012e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4012e4:	f9467211 	ldr	x17, [x16, #3296]
  4012e8:	91338210 	add	x16, x16, #0xce0
  4012ec:	d61f0220 	br	x17

00000000004012f0 <strcasecmp@plt>:
  4012f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4012f4:	f9467611 	ldr	x17, [x16, #3304]
  4012f8:	9133a210 	add	x16, x16, #0xce8
  4012fc:	d61f0220 	br	x17

0000000000401300 <realloc@plt>:
  401300:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401304:	f9467a11 	ldr	x17, [x16, #3312]
  401308:	9133c210 	add	x16, x16, #0xcf0
  40130c:	d61f0220 	br	x17

0000000000401310 <strdup@plt>:
  401310:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401314:	f9467e11 	ldr	x17, [x16, #3320]
  401318:	9133e210 	add	x16, x16, #0xcf8
  40131c:	d61f0220 	br	x17

0000000000401320 <__stack_chk_fail@plt>:
  401320:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401324:	f9468211 	ldr	x17, [x16, #3328]
  401328:	91340210 	add	x16, x16, #0xd00
  40132c:	d61f0220 	br	x17

0000000000401330 <sigaction@plt>:
  401330:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401334:	f9468611 	ldr	x17, [x16, #3336]
  401338:	91342210 	add	x16, x16, #0xd08
  40133c:	d61f0220 	br	x17

0000000000401340 <__gmon_start__@plt>:
  401340:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401344:	f9468a11 	ldr	x17, [x16, #3344]
  401348:	91344210 	add	x16, x16, #0xd10
  40134c:	d61f0220 	br	x17

0000000000401350 <__getauxval@plt>:
  401350:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401354:	f9468e11 	ldr	x17, [x16, #3352]
  401358:	91346210 	add	x16, x16, #0xd18
  40135c:	d61f0220 	br	x17

0000000000401360 <abort@plt>:
  401360:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401364:	f9469211 	ldr	x17, [x16, #3360]
  401368:	91348210 	add	x16, x16, #0xd20
  40136c:	d61f0220 	br	x17

0000000000401370 <pthread_exit@plt>:
  401370:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401374:	f9469611 	ldr	x17, [x16, #3368]
  401378:	9134a210 	add	x16, x16, #0xd28
  40137c:	d61f0220 	br	x17

0000000000401380 <memcmp@plt>:
  401380:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401384:	f9469a11 	ldr	x17, [x16, #3376]
  401388:	9134c210 	add	x16, x16, #0xd30
  40138c:	d61f0220 	br	x17

0000000000401390 <__fprintf_chk@plt>:
  401390:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401394:	f9469e11 	ldr	x17, [x16, #3384]
  401398:	9134e210 	add	x16, x16, #0xd38
  40139c:	d61f0220 	br	x17

00000000004013a0 <strcmp@plt>:
  4013a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4013a4:	f946a211 	ldr	x17, [x16, #3392]
  4013a8:	91350210 	add	x16, x16, #0xd40
  4013ac:	d61f0220 	br	x17

00000000004013b0 <__ctype_b_loc@plt>:
  4013b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4013b4:	f946a611 	ldr	x17, [x16, #3400]
  4013b8:	91352210 	add	x16, x16, #0xd48
  4013bc:	d61f0220 	br	x17

00000000004013c0 <pthread_detach@plt>:
  4013c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4013c4:	f946aa11 	ldr	x17, [x16, #3408]
  4013c8:	91354210 	add	x16, x16, #0xd50
  4013cc:	d61f0220 	br	x17

00000000004013d0 <strtol@plt>:
  4013d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4013d4:	f946ae11 	ldr	x17, [x16, #3416]
  4013d8:	91356210 	add	x16, x16, #0xd58
  4013dc:	d61f0220 	br	x17

00000000004013e0 <free@plt>:
  4013e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4013e4:	f946b211 	ldr	x17, [x16, #3424]
  4013e8:	91358210 	add	x16, x16, #0xd60
  4013ec:	d61f0220 	br	x17

00000000004013f0 <pthread_cond_wait@plt>:
  4013f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4013f4:	f946b611 	ldr	x17, [x16, #3432]
  4013f8:	9135a210 	add	x16, x16, #0xd68
  4013fc:	d61f0220 	br	x17

0000000000401400 <nanosleep@plt>:
  401400:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401404:	f946ba11 	ldr	x17, [x16, #3440]
  401408:	9135c210 	add	x16, x16, #0xd70
  40140c:	d61f0220 	br	x17

0000000000401410 <__pthread_unwind_next@plt>:
  401410:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401414:	f946be11 	ldr	x17, [x16, #3448]
  401418:	9135e210 	add	x16, x16, #0xd78
  40141c:	d61f0220 	br	x17

0000000000401420 <strtoull@plt>:
  401420:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401424:	f946c211 	ldr	x17, [x16, #3456]
  401428:	91360210 	add	x16, x16, #0xd80
  40142c:	d61f0220 	br	x17

0000000000401430 <pthread_create@plt>:
  401430:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401434:	f946c611 	ldr	x17, [x16, #3464]
  401438:	91362210 	add	x16, x16, #0xd88
  40143c:	d61f0220 	br	x17

0000000000401440 <isatty@plt>:
  401440:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401444:	f946ca11 	ldr	x17, [x16, #3472]
  401448:	91364210 	add	x16, x16, #0xd90
  40144c:	d61f0220 	br	x17

0000000000401450 <strncpy@plt>:
  401450:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401454:	f946ce11 	ldr	x17, [x16, #3480]
  401458:	91366210 	add	x16, x16, #0xd98
  40145c:	d61f0220 	br	x17

0000000000401460 <__pthread_register_cancel@plt>:
  401460:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401464:	f946d211 	ldr	x17, [x16, #3488]
  401468:	91368210 	add	x16, x16, #0xda0
  40146c:	d61f0220 	br	x17

0000000000401470 <pthread_self@plt>:
  401470:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401474:	f946d611 	ldr	x17, [x16, #3496]
  401478:	9136a210 	add	x16, x16, #0xda8
  40147c:	d61f0220 	br	x17

0000000000401480 <pthread_cancel@plt>:
  401480:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401484:	f946da11 	ldr	x17, [x16, #3504]
  401488:	9136c210 	add	x16, x16, #0xdb0
  40148c:	d61f0220 	br	x17

0000000000401490 <pthread_mutex_lock@plt>:
  401490:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  401494:	f946de11 	ldr	x17, [x16, #3512]
  401498:	9136e210 	add	x16, x16, #0xdb8
  40149c:	d61f0220 	br	x17

00000000004014a0 <pthread_mutex_unlock@plt>:
  4014a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xff4c>
  4014a4:	f946e211 	ldr	x17, [x16, #3520]
  4014a8:	91370210 	add	x16, x16, #0xdc0
  4014ac:	d61f0220 	br	x17

Disassembly of section .text:

00000000004014c0 <init_have_lse_atomics>:
  4014c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4014c4:	d2800200 	mov	x0, #0x10                  	// #16
  4014c8:	910003fd 	mov	x29, sp
  4014cc:	97ffffa1 	bl	401350 <__getauxval@plt>
  4014d0:	53082000 	ubfx	w0, w0, #8, #1
  4014d4:	b0000161 	adrp	x1, 42e000 <irq_prio+0xf>
  4014d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4014dc:	39046420 	strb	w0, [x1, #281]
  4014e0:	d65f03c0 	ret
  4014e4:	d503201f 	nop
  4014e8:	d503201f 	nop
  4014ec:	d503201f 	nop
  4014f0:	d503201f 	nop
  4014f4:	d503201f 	nop
  4014f8:	d503201f 	nop
  4014fc:	d503201f 	nop

0000000000401500 <_start>:
  401500:	d503201f 	nop
  401504:	d280001d 	mov	x29, #0x0                   	// #0
  401508:	d280001e 	mov	x30, #0x0                   	// #0
  40150c:	aa0003e5 	mov	x5, x0
  401510:	f94003e1 	ldr	x1, [sp]
  401514:	910023e2 	add	x2, sp, #0x8
  401518:	910003e6 	mov	x6, sp
  40151c:	d0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  401520:	f947a400 	ldr	x0, [x0, #3912]
  401524:	d2800003 	mov	x3, #0x0                   	// #0
  401528:	d2800004 	mov	x4, #0x0                   	// #0
  40152c:	97ffff25 	bl	4011c0 <__libc_start_main@plt>
  401530:	97ffff8c 	bl	401360 <abort@plt>
  401534:	d503201f 	nop
  401538:	d503201f 	nop
  40153c:	d503201f 	nop

0000000000401540 <deregister_tm_clones>:
  401540:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  401544:	91106000 	add	x0, x0, #0x418
  401548:	f0000141 	adrp	x1, 42c000 <__dso_handle>
  40154c:	91106021 	add	x1, x1, #0x418
  401550:	eb00003f 	cmp	x1, x0
  401554:	540000c0 	b.eq	40156c <deregister_tm_clones+0x2c>  // b.none
  401558:	d0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40155c:	f946ec21 	ldr	x1, [x1, #3544]
  401560:	b4000061 	cbz	x1, 40156c <deregister_tm_clones+0x2c>
  401564:	aa0103f0 	mov	x16, x1
  401568:	d61f0200 	br	x16
  40156c:	d65f03c0 	ret

0000000000401570 <register_tm_clones>:
  401570:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  401574:	91106000 	add	x0, x0, #0x418
  401578:	f0000141 	adrp	x1, 42c000 <__dso_handle>
  40157c:	91106021 	add	x1, x1, #0x418
  401580:	cb000021 	sub	x1, x1, x0
  401584:	d37ffc22 	lsr	x2, x1, #63
  401588:	8b810c41 	add	x1, x2, x1, asr #3
  40158c:	9341fc21 	asr	x1, x1, #1
  401590:	b40000c1 	cbz	x1, 4015a8 <register_tm_clones+0x38>
  401594:	d0000142 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  401598:	f947dc42 	ldr	x2, [x2, #4024]
  40159c:	b4000062 	cbz	x2, 4015a8 <register_tm_clones+0x38>
  4015a0:	aa0203f0 	mov	x16, x2
  4015a4:	d61f0200 	br	x16
  4015a8:	d65f03c0 	ret
  4015ac:	d503201f 	nop

00000000004015b0 <__do_global_dtors_aux>:
  4015b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4015b4:	910003fd 	mov	x29, sp
  4015b8:	f9000bf3 	str	x19, [sp, #16]
  4015bc:	90000173 	adrp	x19, 42d000 <args_struct>
  4015c0:	39705260 	ldrb	w0, [x19, #3092]
  4015c4:	35000140 	cbnz	w0, 4015ec <__do_global_dtors_aux+0x3c>
  4015c8:	d0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4015cc:	f9470800 	ldr	x0, [x0, #3600]
  4015d0:	b4000080 	cbz	x0, 4015e0 <__do_global_dtors_aux+0x30>
  4015d4:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  4015d8:	f9400000 	ldr	x0, [x0]
  4015dc:	97ffff0d 	bl	401210 <__cxa_finalize@plt>
  4015e0:	97ffffd8 	bl	401540 <deregister_tm_clones>
  4015e4:	52800020 	mov	w0, #0x1                   	// #1
  4015e8:	39305260 	strb	w0, [x19, #3092]
  4015ec:	f9400bf3 	ldr	x19, [sp, #16]
  4015f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4015f4:	d65f03c0 	ret
  4015f8:	d503201f 	nop
  4015fc:	d503201f 	nop

0000000000401600 <frame_dummy>:
  401600:	17ffffdc 	b	401570 <register_tm_clones>
  401604:	d503201f 	nop
  401608:	d503201f 	nop
  40160c:	d503201f 	nop

0000000000401610 <__aarch64_ldadd8_acq_rel>:
  401610:	d503245f 	bti	c
  401614:	b0000170 	adrp	x16, 42e000 <irq_prio+0xf>
  401618:	39446610 	ldrb	w16, [x16, #281]
  40161c:	34000070 	cbz	w16, 401628 <__aarch64_ldadd8_acq_rel+0x18>
  401620:	f8e00020 	ldaddal	x0, x0, [x1]
  401624:	d65f03c0 	ret
  401628:	aa0003f0 	mov	x16, x0
  40162c:	c85ffc20 	ldaxr	x0, [x1]
  401630:	8b100011 	add	x17, x0, x16
  401634:	c80ffc31 	stlxr	w15, x17, [x1]
  401638:	35ffffaf 	cbnz	w15, 40162c <__aarch64_ldadd8_acq_rel+0x1c>
  40163c:	d65f03c0 	ret

0000000000401640 <__divtf3>:
  401640:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  401644:	910003fd 	mov	x29, sp
  401648:	3d8007e0 	str	q0, [sp, #16]
  40164c:	3d800be1 	str	q1, [sp, #32]
  401650:	a94103e1 	ldp	x1, x0, [sp, #16]
  401654:	a9420fe6 	ldp	x6, x3, [sp, #32]
  401658:	d53b440c 	mrs	x12, fpcr
  40165c:	d37ffc04 	lsr	x4, x0, #63
  401660:	d340bc02 	ubfx	x2, x0, #0, #48
  401664:	12001c8d 	and	w13, w4, #0xff
  401668:	aa0403ea 	mov	x10, x4
  40166c:	d370f808 	ubfx	x8, x0, #48, #15
  401670:	34001ee8 	cbz	w8, 401a4c <__divtf3+0x40c>
  401674:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401678:	6b04011f 	cmp	w8, w4
  40167c:	540020c0 	b.eq	401a94 <__divtf3+0x454>  // b.none
  401680:	92403d08 	and	x8, x8, #0xffff
  401684:	93c1f442 	extr	x2, x2, x1, #61
  401688:	9287ffce 	mov	x14, #0xffffffffffffc001    	// #-16383
  40168c:	d37df021 	lsl	x1, x1, #3
  401690:	8b0e0108 	add	x8, x8, x14
  401694:	b24d0045 	orr	x5, x2, #0x8000000000000
  401698:	d2800010 	mov	x16, #0x0                   	// #0
  40169c:	d2800002 	mov	x2, #0x0                   	// #0
  4016a0:	52800000 	mov	w0, #0x0                   	// #0
  4016a4:	d37ffc64 	lsr	x4, x3, #63
  4016a8:	d340bc67 	ubfx	x7, x3, #0, #48
  4016ac:	12001c8f 	and	w15, w4, #0xff
  4016b0:	aa0403e9 	mov	x9, x4
  4016b4:	d370f864 	ubfx	x4, x3, #48, #15
  4016b8:	34001a04 	cbz	w4, 4019f8 <__divtf3+0x3b8>
  4016bc:	528fffeb 	mov	w11, #0x7fff                	// #32767
  4016c0:	6b0b009f 	cmp	w4, w11
  4016c4:	54001f80 	b.eq	401ab4 <__divtf3+0x474>  // b.none
  4016c8:	9287ffcb 	mov	x11, #0xffffffffffffc001    	// #-16383
  4016cc:	92403c84 	and	x4, x4, #0xffff
  4016d0:	8b0b0084 	add	x4, x4, x11
  4016d4:	93c6f4e7 	extr	x7, x7, x6, #61
  4016d8:	4a0f01ab 	eor	w11, w13, w15
  4016dc:	b24d00e7 	orr	x7, x7, #0x8000000000000
  4016e0:	cb040108 	sub	x8, x8, x4
  4016e4:	d37df0c6 	lsl	x6, x6, #3
  4016e8:	92401d6e 	and	x14, x11, #0xff
  4016ec:	d2800003 	mov	x3, #0x0                   	// #0
  4016f0:	f100245f 	cmp	x2, #0x9
  4016f4:	5400046c 	b.gt	401780 <__divtf3+0x140>
  4016f8:	f1001c5f 	cmp	x2, #0x7
  4016fc:	54002bcc 	b.gt	401c74 <__divtf3+0x634>
  401700:	f1000c5f 	cmp	x2, #0x3
  401704:	540000e0 	b.eq	401720 <__divtf3+0xe0>  // b.none
  401708:	5400050d 	b.le	4017a8 <__divtf3+0x168>
  40170c:	f100145f 	cmp	x2, #0x5
  401710:	54000400 	b.eq	401790 <__divtf3+0x150>  // b.none
  401714:	5400080d 	b.le	401814 <__divtf3+0x1d4>
  401718:	f100185f 	cmp	x2, #0x6
  40171c:	54000640 	b.eq	4017e4 <__divtf3+0x1a4>  // b.none
  401720:	f100047f 	cmp	x3, #0x1
  401724:	54002780 	b.eq	401c14 <__divtf3+0x5d4>  // b.none
  401728:	b40000a3 	cbz	x3, 40173c <__divtf3+0xfc>
  40172c:	f100087f 	cmp	x3, #0x2
  401730:	54003260 	b.eq	401d7c <__divtf3+0x73c>  // b.none
  401734:	f1000c7f 	cmp	x3, #0x3
  401738:	54003160 	b.eq	401d64 <__divtf3+0x724>  // b.none
  40173c:	d287ffe1 	mov	x1, #0x3fff                	// #16383
  401740:	8b010104 	add	x4, x8, x1
  401744:	f100009f 	cmp	x4, #0x0
  401748:	5400222d 	b.le	401b8c <__divtf3+0x54c>
  40174c:	f24008df 	tst	x6, #0x7
  401750:	540026c1 	b.ne	401c28 <__divtf3+0x5e8>  // b.any
  401754:	1200012b 	and	w11, w9, #0x1
  401758:	b6a00067 	tbz	x7, #52, 401764 <__divtf3+0x124>
  40175c:	924bf8e7 	and	x7, x7, #0xffefffffffffffff
  401760:	91401104 	add	x4, x8, #0x4, lsl #12
  401764:	d28fffc2 	mov	x2, #0x7ffe                	// #32766
  401768:	eb02009f 	cmp	x4, x2
  40176c:	54002cec 	b.gt	401d08 <__divtf3+0x6c8>
  401770:	d343c8e5 	ubfx	x5, x7, #3, #48
  401774:	93c60ce1 	extr	x1, x7, x6, #3
  401778:	12003884 	and	w4, w4, #0x7fff
  40177c:	1400001d 	b	4017f0 <__divtf3+0x1b0>
  401780:	f1002c5f 	cmp	x2, #0xb
  401784:	54001c4c 	b.gt	401b0c <__divtf3+0x4cc>
  401788:	f100285f 	cmp	x2, #0xa
  40178c:	54fffca1 	b.ne	401720 <__divtf3+0xe0>  // b.any
  401790:	5280000b 	mov	w11, #0x0                   	// #0
  401794:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401798:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40179c:	52800020 	mov	w0, #0x1                   	// #1
  4017a0:	528fffe4 	mov	w4, #0x7fff                	// #32767
  4017a4:	14000013 	b	4017f0 <__divtf3+0x1b0>
  4017a8:	f100045f 	cmp	x2, #0x1
  4017ac:	54000181 	b.ne	4017dc <__divtf3+0x19c>  // b.any
  4017b0:	d2800002 	mov	x2, #0x0                   	// #0
  4017b4:	9e670040 	fmov	d0, x2
  4017b8:	d34101ce 	lsl	x14, x14, #63
  4017bc:	321f0000 	orr	w0, w0, #0x2
  4017c0:	b25039c3 	orr	x3, x14, #0x7fff000000000000
  4017c4:	9eaf0060 	fmov	v0.d[1], x3
  4017c8:	3d8007e0 	str	q0, [sp, #16]
  4017cc:	9400021d 	bl	402040 <__sfp_handle_exceptions>
  4017d0:	3dc007e0 	ldr	q0, [sp, #16]
  4017d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4017d8:	d65f03c0 	ret
  4017dc:	f100085f 	cmp	x2, #0x2
  4017e0:	540001e1 	b.ne	40181c <__divtf3+0x1dc>  // b.any
  4017e4:	52800004 	mov	w4, #0x0                   	// #0
  4017e8:	d2800005 	mov	x5, #0x0                   	// #0
  4017ec:	d2800001 	mov	x1, #0x0                   	// #0
  4017f0:	d2800003 	mov	x3, #0x0                   	// #0
  4017f4:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  4017f8:	b340bca3 	bfxil	x3, x5, #0, #48
  4017fc:	9e670020 	fmov	d0, x1
  401800:	b3503c83 	bfi	x3, x4, #48, #16
  401804:	9eaf0060 	fmov	v0.d[1], x3
  401808:	35fffe00 	cbnz	w0, 4017c8 <__divtf3+0x188>
  40180c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  401810:	d65f03c0 	ret
  401814:	f100105f 	cmp	x2, #0x4
  401818:	54fffe60 	b.eq	4017e4 <__divtf3+0x1a4>  // b.none
  40181c:	eb0700bf 	cmp	x5, x7
  401820:	54000068 	b.hi	40182c <__divtf3+0x1ec>  // b.pmore
  401824:	fa4100c2 	ccmp	x6, x1, #0x2, eq  // eq = none
  401828:	54002da8 	b.hi	401ddc <__divtf3+0x79c>  // b.pmore
  40182c:	d341fca3 	lsr	x3, x5, #1
  401830:	93c104a2 	extr	x2, x5, x1, #1
  401834:	d3410021 	lsl	x1, x1, #63
  401838:	d354cce9 	ubfx	x9, x7, #20, #32
  40183c:	93c6d0e4 	extr	x4, x7, x6, #52
  401840:	92407c8a 	and	x10, x4, #0xffffffff
  401844:	d374ccc5 	lsl	x5, x6, #12
  401848:	9ac90867 	udiv	x7, x3, x9
  40184c:	9b098ce3 	msub	x3, x7, x9, x3
  401850:	9b077d46 	mul	x6, x10, x7
  401854:	93c28063 	extr	x3, x3, x2, #32
  401858:	eb0300df 	cmp	x6, x3
  40185c:	540000c9 	b.ls	401874 <__divtf3+0x234>  // b.plast
  401860:	ab030083 	adds	x3, x4, x3
  401864:	d10004ed 	sub	x13, x7, #0x1
  401868:	fa4330c0 	ccmp	x6, x3, #0x0, cc  // cc = lo, ul, last
  40186c:	54003088 	b.hi	401e7c <__divtf3+0x83c>  // b.pmore
  401870:	aa0d03e7 	mov	x7, x13
  401874:	cb060063 	sub	x3, x3, x6
  401878:	9ac90866 	udiv	x6, x3, x9
  40187c:	9b098cc3 	msub	x3, x6, x9, x3
  401880:	9b067d50 	mul	x16, x10, x6
  401884:	b3607c62 	bfi	x2, x3, #32, #32
  401888:	eb02021f 	cmp	x16, x2
  40188c:	540000c9 	b.ls	4018a4 <__divtf3+0x264>  // b.plast
  401890:	ab020082 	adds	x2, x4, x2
  401894:	d10004c3 	sub	x3, x6, #0x1
  401898:	fa423200 	ccmp	x16, x2, #0x0, cc  // cc = lo, ul, last
  40189c:	54002ea8 	b.hi	401e70 <__divtf3+0x830>  // b.pmore
  4018a0:	aa0303e6 	mov	x6, x3
  4018a4:	aa0780d1 	orr	x17, x6, x7, lsl #32
  4018a8:	92407caf 	and	x15, x5, #0xffffffff
  4018ac:	92407e27 	and	x7, x17, #0xffffffff
  4018b0:	d360fcad 	lsr	x13, x5, #32
  4018b4:	d360fe26 	lsr	x6, x17, #32
  4018b8:	cb100042 	sub	x2, x2, x16
  4018bc:	d2c00032 	mov	x18, #0x100000000           	// #4294967296
  4018c0:	9b0f7ce3 	mul	x3, x7, x15
  4018c4:	9b0f7cde 	mul	x30, x6, x15
  4018c8:	9b0779a7 	madd	x7, x13, x7, x30
  4018cc:	92407c70 	and	x16, x3, #0xffffffff
  4018d0:	9b0d7cc6 	mul	x6, x6, x13
  4018d4:	8b4380e3 	add	x3, x7, x3, lsr #32
  4018d8:	8b1200c7 	add	x7, x6, x18
  4018dc:	eb0303df 	cmp	x30, x3
  4018e0:	9a8680e6 	csel	x6, x7, x6, hi  // hi = pmore
  4018e4:	8b038210 	add	x16, x16, x3, lsl #32
  4018e8:	8b4380c3 	add	x3, x6, x3, lsr #32
  4018ec:	eb03005f 	cmp	x2, x3
  4018f0:	54001ca3 	b.cc	401c84 <__divtf3+0x644>  // b.lo, b.ul, b.last
  4018f4:	fa500022 	ccmp	x1, x16, #0x2, eq  // eq = none
  4018f8:	aa1103e7 	mov	x7, x17
  4018fc:	54001c43 	b.cc	401c84 <__divtf3+0x644>  // b.lo, b.ul, b.last
  401900:	eb100021 	subs	x1, x1, x16
  401904:	da030042 	sbc	x2, x2, x3
  401908:	eb02009f 	cmp	x4, x2
  40190c:	54002be0 	b.eq	401e88 <__divtf3+0x848>  // b.none
  401910:	9ac90846 	udiv	x6, x2, x9
  401914:	9b0988c2 	msub	x2, x6, x9, x2
  401918:	9b067d43 	mul	x3, x10, x6
  40191c:	93c18042 	extr	x2, x2, x1, #32
  401920:	eb02007f 	cmp	x3, x2
  401924:	540000c9 	b.ls	40193c <__divtf3+0x2fc>  // b.plast
  401928:	ab020082 	adds	x2, x4, x2
  40192c:	d10004cb 	sub	x11, x6, #0x1
  401930:	fa423060 	ccmp	x3, x2, #0x0, cc  // cc = lo, ul, last
  401934:	540030e8 	b.hi	401f50 <__divtf3+0x910>  // b.pmore
  401938:	aa0b03e6 	mov	x6, x11
  40193c:	cb030042 	sub	x2, x2, x3
  401940:	9ac90843 	udiv	x3, x2, x9
  401944:	9b098869 	msub	x9, x3, x9, x2
  401948:	9b037d4a 	mul	x10, x10, x3
  40194c:	b3607d21 	bfi	x1, x9, #32, #32
  401950:	eb01015f 	cmp	x10, x1
  401954:	540000c9 	b.ls	40196c <__divtf3+0x32c>  // b.plast
  401958:	ab010081 	adds	x1, x4, x1
  40195c:	d1000462 	sub	x2, x3, #0x1
  401960:	fa413140 	ccmp	x10, x1, #0x0, cc  // cc = lo, ul, last
  401964:	54002f08 	b.hi	401f44 <__divtf3+0x904>  // b.pmore
  401968:	aa0203e3 	mov	x3, x2
  40196c:	aa068066 	orr	x6, x3, x6, lsl #32
  401970:	cb0a0021 	sub	x1, x1, x10
  401974:	92407cc3 	and	x3, x6, #0xffffffff
  401978:	d2c0002b 	mov	x11, #0x100000000           	// #4294967296
  40197c:	d360fcca 	lsr	x10, x6, #32
  401980:	9b037de2 	mul	x2, x15, x3
  401984:	9b0f7d4f 	mul	x15, x10, x15
  401988:	9b033da3 	madd	x3, x13, x3, x15
  40198c:	92407c49 	and	x9, x2, #0xffffffff
  401990:	9b0a7dad 	mul	x13, x13, x10
  401994:	8b428062 	add	x2, x3, x2, lsr #32
  401998:	8b0b01a3 	add	x3, x13, x11
  40199c:	eb0201ff 	cmp	x15, x2
  4019a0:	9a8d806d 	csel	x13, x3, x13, hi  // hi = pmore
  4019a4:	8b028123 	add	x3, x9, x2, lsl #32
  4019a8:	8b4281a2 	add	x2, x13, x2, lsr #32
  4019ac:	eb02003f 	cmp	x1, x2
  4019b0:	54002042 	b.cs	401db8 <__divtf3+0x778>  // b.hs, b.nlast
  4019b4:	ab010089 	adds	x9, x4, x1
  4019b8:	d10004ca 	sub	x10, x6, #0x1
  4019bc:	aa0903e1 	mov	x1, x9
  4019c0:	540000a2 	b.cs	4019d4 <__divtf3+0x394>  // b.hs, b.nlast
  4019c4:	eb02013f 	cmp	x9, x2
  4019c8:	54002823 	b.cc	401ecc <__divtf3+0x88c>  // b.lo, b.ul, b.last
  4019cc:	fa4300a2 	ccmp	x5, x3, #0x2, eq  // eq = none
  4019d0:	540027e3 	b.cc	401ecc <__divtf3+0x88c>  // b.lo, b.ul, b.last
  4019d4:	eb0300bf 	cmp	x5, x3
  4019d8:	aa0a03e6 	mov	x6, x10
  4019dc:	1a9f07e9 	cset	w9, ne  // ne = any
  4019e0:	7100013f 	cmp	w9, #0x0
  4019e4:	aa0e03e9 	mov	x9, x14
  4019e8:	fa420020 	ccmp	x1, x2, #0x0, eq  // eq = none
  4019ec:	b24000c1 	orr	x1, x6, #0x1
  4019f0:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  4019f4:	17ffff52 	b	40173c <__divtf3+0xfc>
  4019f8:	aa0700c3 	orr	x3, x6, x7
  4019fc:	b4000b63 	cbz	x3, 401b68 <__divtf3+0x528>
  401a00:	b4001707 	cbz	x7, 401ce0 <__divtf3+0x6a0>
  401a04:	dac010e3 	clz	x3, x7
  401a08:	d1003c64 	sub	x4, x3, #0xf
  401a0c:	11000c8e 	add	w14, w4, #0x3
  401a10:	528007ab 	mov	w11, #0x3d                  	// #61
  401a14:	4b040164 	sub	w4, w11, w4
  401a18:	9ace20e7 	lsl	x7, x7, x14
  401a1c:	9ac424c4 	lsr	x4, x6, x4
  401a20:	aa070087 	orr	x7, x4, x7
  401a24:	9ace20c6 	lsl	x6, x6, x14
  401a28:	8b080064 	add	x4, x3, x8
  401a2c:	4a0f01ab 	eor	w11, w13, w15
  401a30:	d287fde8 	mov	x8, #0x3fef                	// #16367
  401a34:	92401d6e 	and	x14, x11, #0xff
  401a38:	8b080088 	add	x8, x4, x8
  401a3c:	d2800003 	mov	x3, #0x0                   	// #0
  401a40:	f100245f 	cmp	x2, #0x9
  401a44:	54ffe5ad 	b.le	4016f8 <__divtf3+0xb8>
  401a48:	17ffff4e 	b	401780 <__divtf3+0x140>
  401a4c:	aa020025 	orr	x5, x1, x2
  401a50:	b4000805 	cbz	x5, 401b50 <__divtf3+0x510>
  401a54:	b4001342 	cbz	x2, 401cbc <__divtf3+0x67c>
  401a58:	dac01040 	clz	x0, x2
  401a5c:	d1003c05 	sub	x5, x0, #0xf
  401a60:	11000ca7 	add	w7, w5, #0x3
  401a64:	528007a4 	mov	w4, #0x3d                  	// #61
  401a68:	4b050084 	sub	w4, w4, w5
  401a6c:	9ac72042 	lsl	x2, x2, x7
  401a70:	9ac42424 	lsr	x4, x1, x4
  401a74:	aa020085 	orr	x5, x4, x2
  401a78:	9ac72021 	lsl	x1, x1, x7
  401a7c:	9287fdc8 	mov	x8, #0xffffffffffffc011    	// #-16367
  401a80:	d2800002 	mov	x2, #0x0                   	// #0
  401a84:	cb000108 	sub	x8, x8, x0
  401a88:	d2800010 	mov	x16, #0x0                   	// #0
  401a8c:	52800000 	mov	w0, #0x0                   	// #0
  401a90:	17ffff05 	b	4016a4 <__divtf3+0x64>
  401a94:	aa020025 	orr	x5, x1, x2
  401a98:	b50004e5 	cbnz	x5, 401b34 <__divtf3+0x4f4>
  401a9c:	d2800001 	mov	x1, #0x0                   	// #0
  401aa0:	d2800102 	mov	x2, #0x8                   	// #8
  401aa4:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401aa8:	d2800050 	mov	x16, #0x2                   	// #2
  401aac:	52800000 	mov	w0, #0x0                   	// #0
  401ab0:	17fffefd 	b	4016a4 <__divtf3+0x64>
  401ab4:	928fffc3 	mov	x3, #0xffffffffffff8001    	// #-32767
  401ab8:	8b030108 	add	x8, x8, x3
  401abc:	aa0700c3 	orr	x3, x6, x7
  401ac0:	b4000303 	cbz	x3, 401b20 <__divtf3+0x4e0>
  401ac4:	f25100ff 	tst	x7, #0x800000000000
  401ac8:	b2400442 	orr	x2, x2, #0x3
  401acc:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
  401ad0:	d2800063 	mov	x3, #0x3                   	// #3
  401ad4:	4a0f01ab 	eor	w11, w13, w15
  401ad8:	92401d6e 	and	x14, x11, #0xff
  401adc:	f100245f 	cmp	x2, #0x9
  401ae0:	54ffe0cd 	b.le	4016f8 <__divtf3+0xb8>
  401ae4:	f1003c5f 	cmp	x2, #0xf
  401ae8:	54ffe4c1 	b.ne	401780 <__divtf3+0x140>  // b.any
  401aec:	b6780ba5 	tbz	x5, #47, 401c60 <__divtf3+0x620>
  401af0:	b7780b87 	tbnz	x7, #47, 401c60 <__divtf3+0x620>
  401af4:	b25100e5 	orr	x5, x7, #0x800000000000
  401af8:	2a0f03eb 	mov	w11, w15
  401afc:	9240bca5 	and	x5, x5, #0xffffffffffff
  401b00:	aa0603e1 	mov	x1, x6
  401b04:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401b08:	17ffff3a 	b	4017f0 <__divtf3+0x1b0>
  401b0c:	aa0503e7 	mov	x7, x5
  401b10:	aa0103e6 	mov	x6, x1
  401b14:	aa0a03e9 	mov	x9, x10
  401b18:	aa1003e3 	mov	x3, x16
  401b1c:	17ffff01 	b	401720 <__divtf3+0xe0>
  401b20:	b27f0042 	orr	x2, x2, #0x2
  401b24:	d2800007 	mov	x7, #0x0                   	// #0
  401b28:	d2800006 	mov	x6, #0x0                   	// #0
  401b2c:	d2800043 	mov	x3, #0x2                   	// #2
  401b30:	17ffffe9 	b	401ad4 <__divtf3+0x494>
  401b34:	d36ffc40 	lsr	x0, x2, #47
  401b38:	aa0203e5 	mov	x5, x2
  401b3c:	52000000 	eor	w0, w0, #0x1
  401b40:	d2800182 	mov	x2, #0xc                   	// #12
  401b44:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401b48:	d2800070 	mov	x16, #0x3                   	// #3
  401b4c:	17fffed6 	b	4016a4 <__divtf3+0x64>
  401b50:	d2800001 	mov	x1, #0x0                   	// #0
  401b54:	d2800082 	mov	x2, #0x4                   	// #4
  401b58:	d2800008 	mov	x8, #0x0                   	// #0
  401b5c:	d2800030 	mov	x16, #0x1                   	// #1
  401b60:	52800000 	mov	w0, #0x0                   	// #0
  401b64:	17fffed0 	b	4016a4 <__divtf3+0x64>
  401b68:	4a0f01ab 	eor	w11, w13, w15
  401b6c:	b2400042 	orr	x2, x2, #0x1
  401b70:	92401d6e 	and	x14, x11, #0xff
  401b74:	d2800007 	mov	x7, #0x0                   	// #0
  401b78:	d2800006 	mov	x6, #0x0                   	// #0
  401b7c:	d2800023 	mov	x3, #0x1                   	// #1
  401b80:	f100245f 	cmp	x2, #0x9
  401b84:	54ffdbad 	b.le	4016f8 <__divtf3+0xb8>
  401b88:	17fffefe 	b	401780 <__divtf3+0x140>
  401b8c:	d2800021 	mov	x1, #0x1                   	// #1
  401b90:	cb040024 	sub	x4, x1, x4
  401b94:	1200012b 	and	w11, w9, #0x1
  401b98:	f101d09f 	cmp	x4, #0x74
  401b9c:	5400102c 	b.gt	401da0 <__divtf3+0x760>
  401ba0:	f100fc9f 	cmp	x4, #0x3f
  401ba4:	5400126d 	b.le	401df0 <__divtf3+0x7b0>
  401ba8:	52801001 	mov	w1, #0x80                  	// #128
  401bac:	4b040021 	sub	w1, w1, w4
  401bb0:	f101009f 	cmp	x4, #0x40
  401bb4:	51010084 	sub	w4, w4, #0x40
  401bb8:	9ac120e1 	lsl	x1, x7, x1
  401bbc:	aa0100c1 	orr	x1, x6, x1
  401bc0:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  401bc4:	9ac424e1 	lsr	x1, x7, x4
  401bc8:	f10000df 	cmp	x6, #0x0
  401bcc:	9a9f07e2 	cset	x2, ne  // ne = any
  401bd0:	aa010041 	orr	x1, x2, x1
  401bd4:	f2400825 	ands	x5, x1, #0x7
  401bd8:	54001260 	b.eq	401e24 <__divtf3+0x7e4>  // b.none
  401bdc:	d2800005 	mov	x5, #0x0                   	// #0
  401be0:	926a058c 	and	x12, x12, #0xc00000
  401be4:	321c0000 	orr	w0, w0, #0x10
  401be8:	f150019f 	cmp	x12, #0x400, lsl #12
  401bec:	54001800 	b.eq	401eec <__divtf3+0x8ac>  // b.none
  401bf0:	f160019f 	cmp	x12, #0x800, lsl #12
  401bf4:	54001c80 	b.eq	401f84 <__divtf3+0x944>  // b.none
  401bf8:	b4001b8c 	cbz	x12, 401f68 <__divtf3+0x928>
  401bfc:	b7981805 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401c00:	321d0000 	orr	w0, w0, #0x8
  401c04:	93c10ca1 	extr	x1, x5, x1, #3
  401c08:	52800004 	mov	w4, #0x0                   	// #0
  401c0c:	d343c8a5 	ubfx	x5, x5, #3, #48
  401c10:	1400004b 	b	401d3c <__divtf3+0x6fc>
  401c14:	1200012b 	and	w11, w9, #0x1
  401c18:	52800004 	mov	w4, #0x0                   	// #0
  401c1c:	d2800005 	mov	x5, #0x0                   	// #0
  401c20:	d2800001 	mov	x1, #0x0                   	// #0
  401c24:	17fffef3 	b	4017f0 <__divtf3+0x1b0>
  401c28:	926a0581 	and	x1, x12, #0xc00000
  401c2c:	321c0000 	orr	w0, w0, #0x10
  401c30:	f150003f 	cmp	x1, #0x400, lsl #12
  401c34:	540017c0 	b.eq	401f2c <__divtf3+0x8ec>  // b.none
  401c38:	f160003f 	cmp	x1, #0x800, lsl #12
  401c3c:	540010e0 	b.eq	401e58 <__divtf3+0x818>  // b.none
  401c40:	b5ffd8a1 	cbnz	x1, 401754 <__divtf3+0x114>
  401c44:	92400cc1 	and	x1, x6, #0xf
  401c48:	1200012b 	and	w11, w9, #0x1
  401c4c:	f100103f 	cmp	x1, #0x4
  401c50:	54ffd840 	b.eq	401758 <__divtf3+0x118>  // b.none
  401c54:	b10010c6 	adds	x6, x6, #0x4
  401c58:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401c5c:	17fffebf 	b	401758 <__divtf3+0x118>
  401c60:	b25100a5 	orr	x5, x5, #0x800000000000
  401c64:	2a0d03eb 	mov	w11, w13
  401c68:	9240bca5 	and	x5, x5, #0xffffffffffff
  401c6c:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401c70:	17fffee0 	b	4017f0 <__divtf3+0x1b0>
  401c74:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401c78:	d2800005 	mov	x5, #0x0                   	// #0
  401c7c:	d2800001 	mov	x1, #0x0                   	// #0
  401c80:	17fffedc 	b	4017f0 <__divtf3+0x1b0>
  401c84:	ab050026 	adds	x6, x1, x5
  401c88:	d1000627 	sub	x7, x17, #0x1
  401c8c:	9a040042 	adc	x2, x2, x4
  401c90:	9a9f37f2 	cset	x18, cs  // cs = hs, nlast
  401c94:	aa0603e1 	mov	x1, x6
  401c98:	eb02009f 	cmp	x4, x2
  401c9c:	540007a2 	b.cs	401d90 <__divtf3+0x750>  // b.hs, b.nlast
  401ca0:	eb02007f 	cmp	x3, x2
  401ca4:	54000969 	b.ls	401dd0 <__divtf3+0x790>  // b.plast
  401ca8:	ab0600a6 	adds	x6, x5, x6
  401cac:	d1000a27 	sub	x7, x17, #0x2
  401cb0:	aa0603e1 	mov	x1, x6
  401cb4:	9a040042 	adc	x2, x2, x4
  401cb8:	17ffff12 	b	401900 <__divtf3+0x2c0>
  401cbc:	dac01020 	clz	x0, x1
  401cc0:	9100c405 	add	x5, x0, #0x31
  401cc4:	91010000 	add	x0, x0, #0x40
  401cc8:	f100f0bf 	cmp	x5, #0x3c
  401ccc:	54ffecad 	b.le	401a60 <__divtf3+0x420>
  401cd0:	5100f4a5 	sub	w5, w5, #0x3d
  401cd4:	9ac52025 	lsl	x5, x1, x5
  401cd8:	d2800001 	mov	x1, #0x0                   	// #0
  401cdc:	17ffff68 	b	401a7c <__divtf3+0x43c>
  401ce0:	dac010c3 	clz	x3, x6
  401ce4:	9100c464 	add	x4, x3, #0x31
  401ce8:	91010063 	add	x3, x3, #0x40
  401cec:	f100f09f 	cmp	x4, #0x3c
  401cf0:	54ffe8ed 	b.le	401a0c <__divtf3+0x3cc>
  401cf4:	5100f484 	sub	w4, w4, #0x3d
  401cf8:	9ac420c4 	lsl	x4, x6, x4
  401cfc:	d2800006 	mov	x6, #0x0                   	// #0
  401d00:	aa0403e7 	mov	x7, x4
  401d04:	17ffff49 	b	401a28 <__divtf3+0x3e8>
  401d08:	926a0581 	and	x1, x12, #0xc00000
  401d0c:	f150003f 	cmp	x1, #0x400, lsl #12
  401d10:	54001000 	b.eq	401f10 <__divtf3+0x8d0>  // b.none
  401d14:	f160003f 	cmp	x1, #0x800, lsl #12
  401d18:	54000920 	b.eq	401e3c <__divtf3+0x7fc>  // b.none
  401d1c:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d20:	d2800005 	mov	x5, #0x0                   	// #0
  401d24:	b4000081 	cbz	x1, 401d34 <__divtf3+0x6f4>
  401d28:	2a0203e4 	mov	w4, w2
  401d2c:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401d30:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  401d34:	52800282 	mov	w2, #0x14                  	// #20
  401d38:	2a020000 	orr	w0, w0, w2
  401d3c:	d2800003 	mov	x3, #0x0                   	// #0
  401d40:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  401d44:	b340bca3 	bfxil	x3, x5, #0, #48
  401d48:	9e670020 	fmov	d0, x1
  401d4c:	b3503c83 	bfi	x3, x4, #48, #16
  401d50:	9eaf0060 	fmov	v0.d[1], x3
  401d54:	3d8007e0 	str	q0, [sp, #16]
  401d58:	940000ba 	bl	402040 <__sfp_handle_exceptions>
  401d5c:	3dc007e0 	ldr	q0, [sp, #16]
  401d60:	17fffe9d 	b	4017d4 <__divtf3+0x194>
  401d64:	b25100e5 	orr	x5, x7, #0x800000000000
  401d68:	1200012b 	and	w11, w9, #0x1
  401d6c:	9240bca5 	and	x5, x5, #0xffffffffffff
  401d70:	aa0603e1 	mov	x1, x6
  401d74:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d78:	17fffe9e 	b	4017f0 <__divtf3+0x1b0>
  401d7c:	1200012b 	and	w11, w9, #0x1
  401d80:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d84:	d2800005 	mov	x5, #0x0                   	// #0
  401d88:	d2800001 	mov	x1, #0x0                   	// #0
  401d8c:	17fffe99 	b	4017f0 <__divtf3+0x1b0>
  401d90:	f100025f 	cmp	x18, #0x0
  401d94:	fa420080 	ccmp	x4, x2, #0x0, eq  // eq = none
  401d98:	54ffdb41 	b.ne	401900 <__divtf3+0x2c0>  // b.any
  401d9c:	17ffffc1 	b	401ca0 <__divtf3+0x660>
  401da0:	aa0700c1 	orr	x1, x6, x7
  401da4:	b5000861 	cbnz	x1, 401eb0 <__divtf3+0x870>
  401da8:	321d0000 	orr	w0, w0, #0x8
  401dac:	52800004 	mov	w4, #0x0                   	// #0
  401db0:	d2800005 	mov	x5, #0x0                   	// #0
  401db4:	17ffffe2 	b	401d3c <__divtf3+0x6fc>
  401db8:	f100007f 	cmp	x3, #0x0
  401dbc:	1a9f07e9 	cset	w9, ne  // ne = any
  401dc0:	7100013f 	cmp	w9, #0x0
  401dc4:	fa421020 	ccmp	x1, x2, #0x0, ne  // ne = any
  401dc8:	54ffe0c1 	b.ne	4019e0 <__divtf3+0x3a0>  // b.any
  401dcc:	17fffefa 	b	4019b4 <__divtf3+0x374>
  401dd0:	fa460200 	ccmp	x16, x6, #0x0, eq  // eq = none
  401dd4:	54ffd969 	b.ls	401900 <__divtf3+0x2c0>  // b.plast
  401dd8:	17ffffb4 	b	401ca8 <__divtf3+0x668>
  401ddc:	aa0103e2 	mov	x2, x1
  401de0:	d1000508 	sub	x8, x8, #0x1
  401de4:	aa0503e3 	mov	x3, x5
  401de8:	d2800001 	mov	x1, #0x0                   	// #0
  401dec:	17fffe93 	b	401838 <__divtf3+0x1f8>
  401df0:	52800801 	mov	w1, #0x40                  	// #64
  401df4:	4b040021 	sub	w1, w1, w4
  401df8:	9ac424c3 	lsr	x3, x6, x4
  401dfc:	9ac120c6 	lsl	x6, x6, x1
  401e00:	f10000df 	cmp	x6, #0x0
  401e04:	9a9f07e2 	cset	x2, ne  // ne = any
  401e08:	9ac120e1 	lsl	x1, x7, x1
  401e0c:	aa030021 	orr	x1, x1, x3
  401e10:	9ac424e5 	lsr	x5, x7, x4
  401e14:	aa020021 	orr	x1, x1, x2
  401e18:	f240083f 	tst	x1, #0x7
  401e1c:	54ffee21 	b.ne	401be0 <__divtf3+0x5a0>  // b.any
  401e20:	b7980b85 	tbnz	x5, #51, 401f90 <__divtf3+0x950>
  401e24:	52800004 	mov	w4, #0x0                   	// #0
  401e28:	93c10ca1 	extr	x1, x5, x1, #3
  401e2c:	d343c8a5 	ubfx	x5, x5, #3, #48
  401e30:	365fce0c 	tbz	w12, #11, 4017f0 <__divtf3+0x1b0>
  401e34:	321d0000 	orr	w0, w0, #0x8
  401e38:	17ffffc1 	b	401d3c <__divtf3+0x6fc>
  401e3c:	f100013f 	cmp	x9, #0x0
  401e40:	528fffe1 	mov	w1, #0x7fff                	// #32767
  401e44:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401e48:	1a810044 	csel	w4, w2, w1, eq  // eq = none
  401e4c:	9a9f00a5 	csel	x5, x5, xzr, eq  // eq = none
  401e50:	da9f13e1 	csetm	x1, eq  // eq = none
  401e54:	17ffffb8 	b	401d34 <__divtf3+0x6f4>
  401e58:	5280000b 	mov	w11, #0x0                   	// #0
  401e5c:	b4ffc7e9 	cbz	x9, 401758 <__divtf3+0x118>
  401e60:	b10020c6 	adds	x6, x6, #0x8
  401e64:	5280002b 	mov	w11, #0x1                   	// #1
  401e68:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401e6c:	17fffe3b 	b	401758 <__divtf3+0x118>
  401e70:	d10008c6 	sub	x6, x6, #0x2
  401e74:	8b040042 	add	x2, x2, x4
  401e78:	17fffe8b 	b	4018a4 <__divtf3+0x264>
  401e7c:	d10008e7 	sub	x7, x7, #0x2
  401e80:	8b040063 	add	x3, x3, x4
  401e84:	17fffe7c 	b	401874 <__divtf3+0x234>
  401e88:	d287ffe2 	mov	x2, #0x3fff                	// #16383
  401e8c:	8b020104 	add	x4, x8, x2
  401e90:	aa0e03e9 	mov	x9, x14
  401e94:	92800006 	mov	x6, #0xffffffffffffffff    	// #-1
  401e98:	f100009f 	cmp	x4, #0x0
  401e9c:	54ffec6c 	b.gt	401c28 <__divtf3+0x5e8>
  401ea0:	d2800021 	mov	x1, #0x1                   	// #1
  401ea4:	cb040024 	sub	x4, x1, x4
  401ea8:	f101d09f 	cmp	x4, #0x74
  401eac:	54ffe7ad 	b.le	401ba0 <__divtf3+0x560>
  401eb0:	926a058c 	and	x12, x12, #0xc00000
  401eb4:	321c0000 	orr	w0, w0, #0x10
  401eb8:	f150019f 	cmp	x12, #0x400, lsl #12
  401ebc:	54000500 	b.eq	401f5c <__divtf3+0x91c>  // b.none
  401ec0:	f160019f 	cmp	x12, #0x800, lsl #12
  401ec4:	9a9f0121 	csel	x1, x9, xzr, eq  // eq = none
  401ec8:	17ffffb8 	b	401da8 <__divtf3+0x768>
  401ecc:	d37ff8aa 	lsl	x10, x5, #1
  401ed0:	d10008c6 	sub	x6, x6, #0x2
  401ed4:	eb0a00bf 	cmp	x5, x10
  401ed8:	9a849481 	cinc	x1, x4, hi  // hi = pmore
  401edc:	eb0a007f 	cmp	x3, x10
  401ee0:	8b010121 	add	x1, x9, x1
  401ee4:	1a9f07e9 	cset	w9, ne  // ne = any
  401ee8:	17fffebe 	b	4019e0 <__divtf3+0x3a0>
  401eec:	b5000069 	cbnz	x9, 401ef8 <__divtf3+0x8b8>
  401ef0:	b1002021 	adds	x1, x1, #0x8
  401ef4:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  401ef8:	b69fe845 	tbz	x5, #51, 401c00 <__divtf3+0x5c0>
  401efc:	321d0000 	orr	w0, w0, #0x8
  401f00:	52800024 	mov	w4, #0x1                   	// #1
  401f04:	d2800005 	mov	x5, #0x0                   	// #0
  401f08:	d2800001 	mov	x1, #0x0                   	// #0
  401f0c:	17ffff8c 	b	401d3c <__divtf3+0x6fc>
  401f10:	f100013f 	cmp	x9, #0x0
  401f14:	528fffe1 	mov	w1, #0x7fff                	// #32767
  401f18:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401f1c:	1a811044 	csel	w4, w2, w1, ne  // ne = any
  401f20:	9a9f10a5 	csel	x5, x5, xzr, ne  // ne = any
  401f24:	da9f03e1 	csetm	x1, ne  // ne = any
  401f28:	17ffff83 	b	401d34 <__divtf3+0x6f4>
  401f2c:	5280002b 	mov	w11, #0x1                   	// #1
  401f30:	b5ffc149 	cbnz	x9, 401758 <__divtf3+0x118>
  401f34:	b10020c6 	adds	x6, x6, #0x8
  401f38:	5280000b 	mov	w11, #0x0                   	// #0
  401f3c:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401f40:	17fffe06 	b	401758 <__divtf3+0x118>
  401f44:	d1000863 	sub	x3, x3, #0x2
  401f48:	8b040021 	add	x1, x1, x4
  401f4c:	17fffe88 	b	40196c <__divtf3+0x32c>
  401f50:	d10008c6 	sub	x6, x6, #0x2
  401f54:	8b040042 	add	x2, x2, x4
  401f58:	17fffe79 	b	40193c <__divtf3+0x2fc>
  401f5c:	d2800021 	mov	x1, #0x1                   	// #1
  401f60:	cb090021 	sub	x1, x1, x9
  401f64:	17ffff91 	b	401da8 <__divtf3+0x768>
  401f68:	92400c22 	and	x2, x1, #0xf
  401f6c:	f100105f 	cmp	x2, #0x4
  401f70:	54fffc40 	b.eq	401ef8 <__divtf3+0x8b8>  // b.none
  401f74:	b1001021 	adds	x1, x1, #0x4
  401f78:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  401f7c:	b79ffc05 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401f80:	17ffff20 	b	401c00 <__divtf3+0x5c0>
  401f84:	b5fffb69 	cbnz	x9, 401ef0 <__divtf3+0x8b0>
  401f88:	b79ffba5 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401f8c:	17ffff1d 	b	401c00 <__divtf3+0x5c0>
  401f90:	321c0000 	orr	w0, w0, #0x10
  401f94:	17ffffda 	b	401efc <__divtf3+0x8bc>
  401f98:	d503201f 	nop
  401f9c:	d503201f 	nop

0000000000401fa0 <__floatunditf>:
  401fa0:	b40002a0 	cbz	x0, 401ff4 <__floatunditf+0x54>
  401fa4:	dac01001 	clz	x1, x0
  401fa8:	528807c2 	mov	w2, #0x403e                	// #16446
  401fac:	4b010042 	sub	w2, w2, w1
  401fb0:	d2880de3 	mov	x3, #0x406f                	// #16495
  401fb4:	12003844 	and	w4, w2, #0x7fff
  401fb8:	cb22c062 	sub	x2, x3, w2, sxtw
  401fbc:	f100fc5f 	cmp	x2, #0x3f
  401fc0:	540002ac 	b.gt	402014 <__floatunditf+0x74>
  401fc4:	1100c423 	add	w3, w1, #0x31
  401fc8:	528001e2 	mov	w2, #0xf                   	// #15
  401fcc:	4b010041 	sub	w1, w2, w1
  401fd0:	9ac12401 	lsr	x1, x0, x1
  401fd4:	9240bc21 	and	x1, x1, #0xffffffffffff
  401fd8:	9ac32000 	lsl	x0, x0, x3
  401fdc:	d2800003 	mov	x3, #0x0                   	// #0
  401fe0:	b340bc23 	bfxil	x3, x1, #0, #48
  401fe4:	9e670000 	fmov	d0, x0
  401fe8:	b3503c83 	bfi	x3, x4, #48, #16
  401fec:	9eaf0060 	fmov	v0.d[1], x3
  401ff0:	d65f03c0 	ret
  401ff4:	d2800001 	mov	x1, #0x0                   	// #0
  401ff8:	d2800003 	mov	x3, #0x0                   	// #0
  401ffc:	b340bc23 	bfxil	x3, x1, #0, #48
  402000:	9e670000 	fmov	d0, x0
  402004:	52800004 	mov	w4, #0x0                   	// #0
  402008:	b3503c83 	bfi	x3, x4, #48, #16
  40200c:	9eaf0060 	fmov	v0.d[1], x3
  402010:	d65f03c0 	ret
  402014:	51003c21 	sub	w1, w1, #0xf
  402018:	d2800003 	mov	x3, #0x0                   	// #0
  40201c:	9ac12001 	lsl	x1, x0, x1
  402020:	9240bc21 	and	x1, x1, #0xffffffffffff
  402024:	d2800000 	mov	x0, #0x0                   	// #0
  402028:	9e670000 	fmov	d0, x0
  40202c:	b340bc23 	bfxil	x3, x1, #0, #48
  402030:	b3503c83 	bfi	x3, x4, #48, #16
  402034:	9eaf0060 	fmov	v0.d[1], x3
  402038:	d65f03c0 	ret
  40203c:	d503201f 	nop

0000000000402040 <__sfp_handle_exceptions>:
  402040:	36000080 	tbz	w0, #0, 402050 <__sfp_handle_exceptions+0x10>
  402044:	0f000401 	movi	v1.2s, #0x0
  402048:	1e211820 	fdiv	s0, s1, s1
  40204c:	d53b4421 	mrs	x1, fpsr
  402050:	360800a0 	tbz	w0, #1, 402064 <__sfp_handle_exceptions+0x24>
  402054:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
  402058:	0f000402 	movi	v2.2s, #0x0
  40205c:	1e221820 	fdiv	s0, s1, s2
  402060:	d53b4421 	mrs	x1, fpsr
  402064:	36100100 	tbz	w0, #2, 402084 <__sfp_handle_exceptions+0x44>
  402068:	5298b5c2 	mov	w2, #0xc5ae                	// #50606
  40206c:	12b01001 	mov	w1, #0x7f7fffff            	// #2139095039
  402070:	72ae93a2 	movk	w2, #0x749d, lsl #16
  402074:	1e270021 	fmov	s1, w1
  402078:	1e270042 	fmov	s2, w2
  40207c:	1e222820 	fadd	s0, s1, s2
  402080:	d53b4421 	mrs	x1, fpsr
  402084:	36180080 	tbz	w0, #3, 402094 <__sfp_handle_exceptions+0x54>
  402088:	0f044401 	movi	v1.2s, #0x80, lsl #16
  40208c:	1e210820 	fmul	s0, s1, s1
  402090:	d53b4421 	mrs	x1, fpsr
  402094:	362000c0 	tbz	w0, #4, 4020ac <__sfp_handle_exceptions+0x6c>
  402098:	12b01000 	mov	w0, #0x7f7fffff            	// #2139095039
  40209c:	1e2e1002 	fmov	s2, #1.000000000000000000e+00
  4020a0:	1e270001 	fmov	s1, w0
  4020a4:	1e223820 	fsub	s0, s1, s2
  4020a8:	d53b4420 	mrs	x0, fpsr
  4020ac:	d65f03c0 	ret

00000000004020b0 <call_weak_fn>:
  4020b0:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4020b4:	f9476400 	ldr	x0, [x0, #3784]
  4020b8:	b4000040 	cbz	x0, 4020c0 <call_weak_fn+0x10>
  4020bc:	17fffca1 	b	401340 <__gmon_start__@plt>
  4020c0:	d65f03c0 	ret

00000000004020c4 <_OffsetAbsSyms>:
#include <zephyr/kernel.h>
#include <kernel_arch_data.h>
#include <gen_offset.h>
#include <kernel_offsets.h>

GEN_ABS_SYM_END
  4020c4:	d65f03c0 	ret

00000000004020c8 <k_timer_stop>:
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_TIMER_STOP);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_stop(timer);
  4020c8:	14004488 	b	4132e8 <z_impl_k_timer_stop>

00000000004020cc <send_can_tx_callback>:
        receive_can_rx(rctx, frame);
    }
}

static void send_can_tx_callback(const struct device *dev, int error, void *arg)
{
  4020cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4020d0:	910003fd 	mov	x29, sp
    struct isotp_fast_send_ctx *sctx = arg;

    ARG_UNUSED(dev);

    sctx->backlog--;
  4020d4:	39434c40 	ldrb	w0, [x2, #211]
{
  4020d8:	f9000bf3 	str	x19, [sp, #16]
  4020dc:	aa0203f3 	mov	x19, x2
    sctx->backlog--;
  4020e0:	51000400 	sub	w0, w0, #0x1
  4020e4:	39034c40 	strb	w0, [x2, #211]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
  4020e8:	91024040 	add	x0, x2, #0x90
  4020ec:	94003572 	bl	40f6b4 <z_impl_k_sem_give>
    k_sem_give(&sctx->sem);

    if (sctx->state == ISOTP_TX_WAIT_BACKLOG) {
  4020f0:	f9406260 	ldr	x0, [x19, #192]
  4020f4:	530c4c00 	ubfx	w0, w0, #12, #8
  4020f8:	7100181f 	cmp	w0, #0x6
  4020fc:	54000181 	b.ne	40212c <send_can_tx_callback+0x60>  // b.any
        if (sctx->backlog > 0) {
  402100:	39434e60 	ldrb	w0, [x19, #211]
  402104:	350001c0 	cbnz	w0, 40213c <send_can_tx_callback+0x70>
            return;
        }

        sctx->state = ISOTP_TX_WAIT_FIN;
  402108:	79418260 	ldrh	w0, [x19, #192]
  40210c:	91030261 	add	x1, x19, #0xc0
  402110:	12002c00 	and	w0, w0, #0xfff
  402114:	32140800 	orr	w0, w0, #0x7000
  402118:	79018260 	strh	w0, [x19, #192]
  40211c:	aa0103e0 	mov	x0, x1
  402120:	39400821 	ldrb	w1, [x1, #2]
  402124:	121c6c21 	and	w1, w1, #0xfffffff0
  402128:	39000801 	strb	w1, [x0, #2]
    }

    k_work_submit(&sctx->work);
  40212c:	91006260 	add	x0, x19, #0x18
}
  402130:	f9400bf3 	ldr	x19, [sp, #16]
  402134:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&sctx->work);
  402138:	140037e1 	b	4100bc <k_work_submit>
}
  40213c:	f9400bf3 	ldr	x19, [sp, #16]
  402140:	a8c27bfd 	ldp	x29, x30, [sp], #32
  402144:	d65f03c0 	ret

0000000000402148 <can_bytes_to_dlc>:
	       num_bytes <= 20 ? 11 :
	       num_bytes <= 24 ? 12 :
	       num_bytes <= 32 ? 13 :
	       num_bytes <= 48 ? 14 :
	       15;
}
  402148:	d65f03c0 	ret

000000000040214c <z_log_msg_runtime_create.constprop.0>:
 *
 * @param fmt String.
 *
 * @param ... String arguments.
 */
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40214c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  402150:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  402154:	12001c42 	and	w2, w2, #0xff
  402158:	910003fd 	mov	x29, sp
  40215c:	f9476800 	ldr	x0, [x0, #3792]
  402160:	3d8023e0 	str	q0, [sp, #128]
  402164:	3d8027e1 	str	q1, [sp, #144]
  402168:	3d802be2 	str	q2, [sp, #160]
  40216c:	3d802fe3 	str	q3, [sp, #176]
  402170:	3d8033e4 	str	q4, [sp, #192]
  402174:	3d8037e5 	str	q5, [sp, #208]
  402178:	3d803be6 	str	q6, [sp, #224]
  40217c:	3d803fe7 	str	q7, [sp, #240]
  402180:	f90087e7 	str	x7, [sp, #264]
  402184:	f9400003 	ldr	x3, [x0]
  402188:	f9003fe3 	str	x3, [sp, #120]
  40218c:	d2800003 	mov	x3, #0x0                   	// #0
					     size_t dlen, uint32_t package_flags,
					     const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
  402190:	910443e0 	add	x0, sp, #0x110
  402194:	a90383e0 	stp	x0, x0, [sp, #56]
  402198:	910403e0 	add	x0, sp, #0x100
  40219c:	9100e3e3 	add	x3, sp, #0x38
  4021a0:	f90027e0 	str	x0, [sp, #72]
  4021a4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  4021a8:	b90053e0 	str	w0, [sp, #80]
  4021ac:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  4021b0:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  4021b4:	910163e0 	add	x0, sp, #0x58
  4021b8:	ad400460 	ldp	q0, q1, [x3]
  4021bc:	ad000400 	stp	q0, q1, [x0]
		va_end(parm7.val);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_runtime_vcreate(domain_id, source, level, data, dlen, package_flags, fmt, ap);
  4021c0:	ad400400 	ldp	q0, q1, [x0]
  4021c4:	910043e7 	add	x7, sp, #0x10
  4021c8:	52800000 	mov	w0, #0x0                   	// #0
  4021cc:	52800005 	mov	w5, #0x0                   	// #0
  4021d0:	d2800004 	mov	x4, #0x0                   	// #0
  4021d4:	d2800003 	mov	x3, #0x0                   	// #0
  4021d8:	ad0004e0 	stp	q0, q1, [x7]
  4021dc:	9400184d 	bl	408310 <z_impl_z_log_msg_runtime_vcreate>
				   data, dlen, package_flags, fmt, ap);
	va_end(ap);
}
  4021e0:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4021e4:	f9476800 	ldr	x0, [x0, #3792]
  4021e8:	f9403fe2 	ldr	x2, [sp, #120]
  4021ec:	f9400001 	ldr	x1, [x0]
  4021f0:	eb010042 	subs	x2, x2, x1
  4021f4:	d2800001 	mov	x1, #0x0                   	// #0
  4021f8:	54000040 	b.eq	402200 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  4021fc:	97fffc49 	bl	401320 <__stack_chk_fail@plt>
  402200:	a8d17bfd 	ldp	x29, x30, [sp], #272
  402204:	d65f03c0 	ret

0000000000402208 <send_timeout_handler>:

    send_state_machine(sctx);
}

static void send_timeout_handler(struct k_timer *timer)
{
  402208:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40220c:	910003fd 	mov	x29, sp
  402210:	f9000bf3 	str	x19, [sp, #16]
  402214:	aa0003f3 	mov	x19, x0
    struct isotp_fast_send_ctx *sctx = CONTAINER_OF(timer, struct isotp_fast_send_ctx, timer);

    if (sctx->state != ISOTP_TX_SEND_CF) {
  402218:	f9404400 	ldr	x0, [x0, #136]
  40221c:	530c4c00 	ubfx	w0, w0, #12, #8
  402220:	7100101f 	cmp	w0, #0x4
  402224:	54000240 	b.eq	40226c <send_timeout_handler+0x64>  // b.none
        LOG_ERR("Timed out waiting for FC frame");
  402228:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40222c:	52800000 	mov	w0, #0x0                   	// #0
  402230:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  402234:	52800005 	mov	w5, #0x0                   	// #0
  402238:	f9478821 	ldr	x1, [x1, #3856]
  40223c:	911a94c6 	add	x6, x6, #0x6a5
  402240:	d2800004 	mov	x4, #0x0                   	// #0
  402244:	d2800003 	mov	x3, #0x0                   	// #0
  402248:	52800022 	mov	w2, #0x1                   	// #1
  40224c:	97ffffc0 	bl	40214c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  402250:	b9408a61 	ldr	w1, [x19, #136]
  402254:	52900000 	mov	w0, #0x8000                	// #32768
  402258:	72bfc000 	movk	w0, #0xfe00, lsl #16
  40225c:	12005c21 	and	w1, w1, #0xffffff
  402260:	120c5c21 	and	w1, w1, #0xfff00fff
  402264:	2a000021 	orr	w1, w1, w0
  402268:	b9008a61 	str	w1, [x19, #136]
        send_report_error(sctx, ISOTP_N_TIMEOUT_BS);
    }

    k_work_submit(&sctx->work);
  40226c:	d1008260 	sub	x0, x19, #0x20
}
  402270:	f9400bf3 	ldr	x19, [sp, #16]
  402274:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&sctx->work);
  402278:	14003791 	b	4100bc <k_work_submit>

000000000040227c <receive_can_tx>:
    if (error != 0) {
  40227c:	34000361 	cbz	w1, 4022e8 <receive_can_tx+0x6c>
{
  402280:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402284:	2a0103e7 	mov	w7, w1
        LOG_ERR("Error sending FC frame (%d)", error);
  402288:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
{
  40228c:	910003fd 	mov	x29, sp
        LOG_ERR("Error sending FC frame (%d)", error);
  402290:	f9478821 	ldr	x1, [x1, #3856]
{
  402294:	f9000bf3 	str	x19, [sp, #16]
  402298:	aa0203f3 	mov	x19, x2
        LOG_ERR("Error sending FC frame (%d)", error);
  40229c:	52800005 	mov	w5, #0x0                   	// #0
  4022a0:	d2800004 	mov	x4, #0x0                   	// #0
  4022a4:	d2800003 	mov	x3, #0x0                   	// #0
  4022a8:	52800000 	mov	w0, #0x0                   	// #0
  4022ac:	52800022 	mov	w2, #0x1                   	// #1
  4022b0:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  4022b4:	911b10c6 	add	x6, x6, #0x6c4
  4022b8:	97ffffa5 	bl	40214c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  4022bc:	b9424a61 	ldr	w1, [x19, #584]
  4022c0:	528e0000 	mov	w0, #0x7000                	// #28672
  4022c4:	72bee000 	movk	w0, #0xf700, lsl #16
  4022c8:	12005c21 	and	w1, w1, #0xffffff
  4022cc:	120c5c21 	and	w1, w1, #0xfff00fff
  4022d0:	2a000021 	orr	w1, w1, w0
  4022d4:	b9024a61 	str	w1, [x19, #584]
        k_work_submit(&rctx->work);
  4022d8:	91006260 	add	x0, x19, #0x18
}
  4022dc:	f9400bf3 	ldr	x19, [sp, #16]
  4022e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
        k_work_submit(&rctx->work);
  4022e4:	14003776 	b	4100bc <k_work_submit>
  4022e8:	d65f03c0 	ret

00000000004022ec <receive_timeout_handler>:
{
  4022ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4022f0:	910003fd 	mov	x29, sp
  4022f4:	f9000bf3 	str	x19, [sp, #16]
  4022f8:	aa0003f3 	mov	x19, x0
    switch (rctx->state) {
  4022fc:	f9410800 	ldr	x0, [x0, #528]
  402300:	530c4c00 	ubfx	w0, w0, #12, #8
  402304:	71000c1f 	cmp	w0, #0x3
  402308:	54000300 	b.eq	402368 <receive_timeout_handler+0x7c>  // b.none
  40230c:	7100141f 	cmp	w0, #0x5
  402310:	54000241 	b.ne	402358 <receive_timeout_handler+0x6c>  // b.any
            LOG_ERR("Timeout while waiting for CF");
  402314:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  402318:	52800000 	mov	w0, #0x0                   	// #0
  40231c:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  402320:	52800005 	mov	w5, #0x0                   	// #0
  402324:	f9478821 	ldr	x1, [x1, #3856]
  402328:	911b80c6 	add	x6, x6, #0x6e0
  40232c:	d2800004 	mov	x4, #0x0                   	// #0
  402330:	d2800003 	mov	x3, #0x0                   	// #0
  402334:	52800022 	mov	w2, #0x1                   	// #1
  402338:	97ffff85 	bl	40214c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  40233c:	b9421260 	ldr	w0, [x19, #528]
  402340:	528e0001 	mov	w1, #0x7000                	// #28672
  402344:	72bfa001 	movk	w1, #0xfd00, lsl #16
  402348:	12005c00 	and	w0, w0, #0xffffff
  40234c:	120c5c00 	and	w0, w0, #0xfff00fff
  402350:	2a010000 	orr	w0, w0, w1
  402354:	b9021260 	str	w0, [x19, #528]
    k_work_submit(&rctx->work);
  402358:	d1008260 	sub	x0, x19, #0x20
}
  40235c:	f9400bf3 	ldr	x19, [sp, #16]
  402360:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&rctx->work);
  402364:	14003756 	b	4100bc <k_work_submit>
            rctx->state = ISOTP_RX_STATE_SEND_WAIT;
  402368:	79442260 	ldrh	w0, [x19, #528]
  40236c:	91084261 	add	x1, x19, #0x210
  402370:	12002c00 	and	w0, w0, #0xfff
  402374:	32130400 	orr	w0, w0, #0x6000
  402378:	79042260 	strh	w0, [x19, #528]
  40237c:	aa0103e0 	mov	x0, x1
  402380:	39400821 	ldrb	w1, [x1, #2]
  402384:	121c6c21 	and	w1, w1, #0xfffffff0
  402388:	39000801 	strb	w1, [x0, #2]
            break;
  40238c:	17fffff3 	b	402358 <receive_timeout_handler+0x6c>

0000000000402390 <sys_slist_find_and_remove.isra.0>:
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  402390:	f9400002 	ldr	x2, [x0]
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  402394:	d2800003 	mov	x3, #0x0                   	// #0
  402398:	b4000162 	cbz	x2, 4023c4 <sys_slist_find_and_remove.isra.0+0x34>
  40239c:	eb01005f 	cmp	x2, x1
  4023a0:	54000201 	b.ne	4023e0 <sys_slist_find_and_remove.isra.0+0x50>  // b.any
	return node->next;
  4023a4:	f9400022 	ldr	x2, [x1]
Z_GENLIST_REMOVE(slist, snode)
  4023a8:	b5000103 	cbnz	x3, 4023c8 <sys_slist_find_and_remove.isra.0+0x38>
  4023ac:	f9400403 	ldr	x3, [x0, #8]
	list->head = node;
  4023b0:	f9000002 	str	x2, [x0]
Z_GENLIST_REMOVE(slist, snode)
  4023b4:	eb03003f 	cmp	x1, x3
  4023b8:	54000041 	b.ne	4023c0 <sys_slist_find_and_remove.isra.0+0x30>  // b.any
	list->tail = node;
  4023bc:	f9000402 	str	x2, [x0, #8]
	parent->next = child;
  4023c0:	f900003f 	str	xzr, [x1]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  4023c4:	d65f03c0 	ret
	parent->next = child;
  4023c8:	f9000062 	str	x2, [x3]
Z_GENLIST_REMOVE(slist, snode)
  4023cc:	f9400402 	ldr	x2, [x0, #8]
  4023d0:	eb02003f 	cmp	x1, x2
  4023d4:	54ffff61 	b.ne	4023c0 <sys_slist_find_and_remove.isra.0+0x30>  // b.any
	list->tail = node;
  4023d8:	f9000403 	str	x3, [x0, #8]
}
  4023dc:	17fffff9 	b	4023c0 <sys_slist_find_and_remove.isra.0+0x30>
	return node->next;
  4023e0:	aa0203e3 	mov	x3, x2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  4023e4:	f9400042 	ldr	x2, [x2]
  4023e8:	17ffffec 	b	402398 <sys_slist_find_and_remove.isra.0+0x8>

00000000004023ec <free_recv_ctx>:
{
  4023ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4023f0:	910003fd 	mov	x29, sp
  4023f4:	f9000bf3 	str	x19, [sp, #16]
  4023f8:	aa0003f3 	mov	x19, x0
    k_timer_stop(&(*rctx)->timer);
  4023fc:	f9400000 	ldr	x0, [x0]
  402400:	9100e000 	add	x0, x0, #0x38
  402404:	97ffff31 	bl	4020c8 <k_timer_stop>
    sys_slist_find_and_remove(&isotp_recv_ctx_list, &(*rctx)->node);
  402408:	f9400261 	ldr	x1, [x19]
  40240c:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  402410:	912ba000 	add	x0, x0, #0xae8
  402414:	97ffffdf 	bl	402390 <sys_slist_find_and_remove.isra.0>
    net_buf_unref((*rctx)->buffer);
  402418:	f9400260 	ldr	x0, [x19]
  40241c:	f9404800 	ldr	x0, [x0, #144]
  402420:	940028e3 	bl	40c7ac <net_buf_unref>
    k_msgq_purge(&(*rctx)->recv_queue);
  402424:	f9400260 	ldr	x0, [x19]
  402428:	91028000 	add	x0, x0, #0xa0
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MSGQ_PURGE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_msgq_purge(msgq);
  40242c:	94003236 	bl	40ed04 <z_impl_k_msgq_purge>
    k_msgq_cleanup(&(*rctx)->recv_queue);
  402430:	f9400260 	ldr	x0, [x19]
  402434:	91028000 	add	x0, x0, #0xa0
  402438:	940030cb 	bl	40e764 <k_msgq_cleanup>
    k_mem_slab_free(&isotp_recv_ctx_slab, (void **)rctx);
  40243c:	aa1303e1 	mov	x1, x19
  402440:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
}
  402444:	f9400bf3 	ldr	x19, [sp, #16]
  402448:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_recv_ctx_slab, (void **)rctx);
  40244c:	f947a000 	ldr	x0, [x0, #3904]
  402450:	14002f1a 	b	40e0b8 <k_mem_slab_free>

0000000000402454 <free_send_ctx>:
{
  402454:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402458:	910003fd 	mov	x29, sp
  40245c:	f9000bf3 	str	x19, [sp, #16]
  402460:	aa0003f3 	mov	x19, x0
    k_timer_stop(&(*ctx)->timer);
  402464:	f9400000 	ldr	x0, [x0]
  402468:	9100e000 	add	x0, x0, #0x38
  40246c:	97ffff17 	bl	4020c8 <k_timer_stop>
    sys_slist_find_and_remove(&isotp_send_ctx_list, &(*ctx)->node);
  402470:	f9400261 	ldr	x1, [x19]
  402474:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  402478:	912be000 	add	x0, x0, #0xaf8
  40247c:	97ffffc5 	bl	402390 <sys_slist_find_and_remove.isra.0>
    k_mem_slab_free(&isotp_send_ctx_slab, (void **)ctx);
  402480:	aa1303e1 	mov	x1, x19
  402484:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
}
  402488:	f9400bf3 	ldr	x19, [sp, #16]
  40248c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_send_ctx_slab, (void **)ctx);
  402490:	f947f000 	ldr	x0, [x0, #4064]
  402494:	14002f09 	b	40e0b8 <k_mem_slab_free>

0000000000402498 <get_send_ctx>:
{
  402498:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40249c:	910003fd 	mov	x29, sp
  4024a0:	f9001bf7 	str	x23, [sp, #48]
  4024a4:	aa0003f7 	mov	x23, x0
  4024a8:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4024ac:	a9025bf5 	stp	x21, x22, [sp, #32]
	return list->head;
  4024b0:	d0000156 	adrp	x22, 42c000 <__dso_handle>
  4024b4:	f9476800 	ldr	x0, [x0, #3792]
  4024b8:	a90153f3 	stp	x19, x20, [sp, #16]
  4024bc:	2a0103f4 	mov	w20, w1
  4024c0:	f9457ec3 	ldr	x3, [x22, #2808]
  4024c4:	f9400001 	ldr	x1, [x0]
  4024c8:	f90027e1 	str	x1, [sp, #72]
  4024cc:	d2800001 	mov	x1, #0x0                   	// #0
  4024d0:	aa0203f5 	mov	x21, x2
    return (isotp_fast_node_id)(frame->id & ISOTP_FIXED_ADDR_SA_MASK);
}

static inline isotp_fast_node_id isotp_fast_get_addr_recipient(isotp_fast_msg_id addr)
{
    return (isotp_fast_node_id)((addr & ISOTP_FIXED_ADDR_TA_MASK) >> ISOTP_FIXED_ADDR_TA_POS);
  4024d4:	d3483e80 	ubfx	x0, x20, #8, #8
    SYS_SLIST_FOR_EACH_CONTAINER(&isotp_send_ctx_list, context, node)
  4024d8:	f90023e3 	str	x3, [sp, #64]
  4024dc:	b50003e3 	cbnz	x3, 402558 <get_send_ctx+0xc0>
    int err = k_mem_slab_alloc(&isotp_send_ctx_slab, (void **)&context, K_NO_WAIT);
  4024e0:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4024e4:	910103e1 	add	x1, sp, #0x40
  4024e8:	d2800002 	mov	x2, #0x0                   	// #0
  4024ec:	f947f000 	ldr	x0, [x0, #4064]
  4024f0:	94002e94 	bl	40df40 <k_mem_slab_alloc>
  4024f4:	2a0003f3 	mov	w19, w0
    if (err != 0) {
  4024f8:	35000540 	cbnz	w0, 4025a0 <get_send_ctx+0x108>
    *sctx = context;
  4024fc:	f94023e0 	ldr	x0, [sp, #64]
  402500:	f90002a0 	str	x0, [x21]
    k_work_init(&context->work, receive_work_handler);
  402504:	b0000001 	adrp	x1, 403000 <send_work_handler+0x2e0>
  402508:	91167021 	add	x1, x1, #0x59c
  40250c:	91006000 	add	x0, x0, #0x18
    context->ctx = ctx;
  402510:	f81f0017 	stur	x23, [x0, #-16]
    context->recipient_addr = recipient_addr;
  402514:	b81f8014 	stur	w20, [x0, #-8]
    context->error = 0;
  402518:	3902ac1f 	strb	wzr, [x0, #171]
    k_work_init(&context->work, receive_work_handler);
  40251c:	9400365b 	bl	40fe88 <k_work_init>
    k_timer_init(&context->timer, receive_timeout_handler, NULL);
  402520:	f94023e0 	ldr	x0, [sp, #64]
  402524:	d2800002 	mov	x2, #0x0                   	// #0
  402528:	90000001 	adrp	x1, 402000 <__floatunditf+0x60>
  40252c:	910bb021 	add	x1, x1, #0x2ec
  402530:	9100e000 	add	x0, x0, #0x38
  402534:	9400434b 	bl	413260 <k_timer_init>
    sys_slist_append(&isotp_send_ctx_list, &context->node);
  402538:	f94023e0 	ldr	x0, [sp, #64]
	return list->tail;
  40253c:	912be2c1 	add	x1, x22, #0xaf8
	parent->next = child;
  402540:	f900001f 	str	xzr, [x0]
	return list->tail;
  402544:	f9400422 	ldr	x2, [x1, #8]
Z_GENLIST_APPEND(slist, snode)
  402548:	b5000262 	cbnz	x2, 402594 <get_send_ctx+0xfc>
	list->head = node;
  40254c:	f9057ec0 	str	x0, [x22, #2808]
	list->tail = node;
  402550:	f9000420 	str	x0, [x1, #8]
}
  402554:	14000006 	b	40256c <get_send_ctx+0xd4>
        if (isotp_fast_get_addr_recipient(context->recipient_addr) == recipient_id) {
  402558:	39404461 	ldrb	w1, [x3, #17]
  40255c:	6b00003f 	cmp	w1, w0
  402560:	54000161 	b.ne	40258c <get_send_ctx+0xf4>  // b.any
            return 0;
  402564:	52800013 	mov	w19, #0x0                   	// #0
            *sctx = context;
  402568:	f90002a3 	str	x3, [x21]
}
  40256c:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  402570:	f9476800 	ldr	x0, [x0, #3792]
  402574:	f94027e2 	ldr	x2, [sp, #72]
  402578:	f9400001 	ldr	x1, [x0]
  40257c:	eb010042 	subs	x2, x2, x1
  402580:	d2800001 	mov	x1, #0x0                   	// #0
  402584:	54000120 	b.eq	4025a8 <get_send_ctx+0x110>  // b.none
  402588:	97fffb66 	bl	401320 <__stack_chk_fail@plt>
	return node->next;
  40258c:	f9400063 	ldr	x3, [x3]
  402590:	17ffffd2 	b	4024d8 <get_send_ctx+0x40>
	parent->next = child;
  402594:	f9000040 	str	x0, [x2]
	list->tail = node;
  402598:	f9000420 	str	x0, [x1, #8]
}
  40259c:	17fffff4 	b	40256c <get_send_ctx+0xd4>
        return ISOTP_NO_CTX_LEFT;
  4025a0:	12800193 	mov	w19, #0xfffffff3            	// #-13
  4025a4:	17fffff2 	b	40256c <get_send_ctx+0xd4>
}
  4025a8:	2a1303e0 	mov	w0, w19
  4025ac:	a94153f3 	ldp	x19, x20, [sp, #16]
  4025b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4025b4:	f9401bf7 	ldr	x23, [sp, #48]
  4025b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4025bc:	d65f03c0 	ret

00000000004025c0 <can_rx_callback>:
{
  4025c0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  4025c4:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4025c8:	910003fd 	mov	x29, sp
  4025cc:	a90153f3 	stp	x19, x20, [sp, #16]
  4025d0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4025d4:	aa0103f5 	mov	x21, x1
  4025d8:	aa0203f6 	mov	x22, x2
  4025dc:	a90363f7 	stp	x23, x24, [sp, #48]
  4025e0:	f9476800 	ldr	x0, [x0, #3792]
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  4025e4:	b9400033 	ldr	w19, [x1]
{
  4025e8:	f90023f9 	str	x25, [sp, #64]
  4025ec:	f9400001 	ldr	x1, [x0]
  4025f0:	f90037e1 	str	x1, [sp, #104]
  4025f4:	d2800001 	mov	x1, #0x0                   	// #0
    if ((frame->data[index++] & ISOTP_PCI_TYPE_MASK) == ISOTP_PCI_TYPE_FC) {
  4025f8:	394022a0 	ldrb	w0, [x21, #8]
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  4025fc:	d3407273 	ubfx	x19, x19, #0, #29
    if ((frame->data[index++] & ISOTP_PCI_TYPE_MASK) == ISOTP_PCI_TYPE_FC) {
  402600:	121c0c00 	and	w0, w0, #0xf0
  402604:	7100c01f 	cmp	w0, #0x30
  402608:	54001061 	b.ne	402814 <can_rx_callback+0x254>  // b.any
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  40260c:	53181e60 	ubfiz	w0, w19, #8, #8
  402610:	d3483e61 	ubfx	x1, x19, #8, #8
    isotp_fast_msg_id sender_id =
  402614:	2a000021 	orr	w1, w1, w0
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402618:	12103e73 	and	w19, w19, #0xffff0000
        if (get_send_ctx(ctx, sender_id, &sctx) != 0) {
  40261c:	910183e2 	add	x2, sp, #0x60
  402620:	2a130021 	orr	w1, w1, w19
  402624:	aa1603e0 	mov	x0, x22
  402628:	97ffff9c 	bl	402498 <get_send_ctx>
  40262c:	35001680 	cbnz	w0, 4028fc <can_rx_callback+0x33c>
        send_can_rx(sctx, frame);
  402630:	f94033f3 	ldr	x19, [sp, #96]
    if (sctx->state == ISOTP_TX_WAIT_FC) {
  402634:	f9406260 	ldr	x0, [x19, #192]
  402638:	530c4c00 	ubfx	w0, w0, #12, #8
  40263c:	71000c1f 	cmp	w0, #0x3
  402640:	54000d61 	b.ne	4027ec <can_rx_callback+0x22c>  // b.any
        k_timer_stop(&sctx->timer);
  402644:	9100e274 	add	x20, x19, #0x38
  402648:	aa1403e0 	mov	x0, x20
  40264c:	97fffe9f 	bl	4020c8 <k_timer_stop>
    if ((*data & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_FC) {
  402650:	394022a1 	ldrb	w1, [x21, #8]
  402654:	121c0c20 	and	w0, w1, #0xf0
  402658:	7100c01f 	cmp	w0, #0x30
  40265c:	54000220 	b.eq	4026a0 <can_rx_callback+0xe0>  // b.none
        LOG_ERR("Got unexpected PDU expected FC");
  402660:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  402664:	911bf4c6 	add	x6, x6, #0x6fd
        LOG_ERR("Got unexpected PDU");
  402668:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40266c:	52800000 	mov	w0, #0x0                   	// #0
  402670:	52800005 	mov	w5, #0x0                   	// #0
  402674:	d2800004 	mov	x4, #0x0                   	// #0
  402678:	f9478821 	ldr	x1, [x1, #3856]
  40267c:	d2800003 	mov	x3, #0x0                   	// #0
  402680:	52800022 	mov	w2, #0x1                   	// #1
  402684:	97fffeb2 	bl	40214c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  402688:	b940c260 	ldr	w0, [x19, #192]
  40268c:	52900001 	mov	w1, #0x8000                	// #32768
  402690:	72bf4001 	movk	w1, #0xfa00, lsl #16
  402694:	12005c00 	and	w0, w0, #0xffffff
  402698:	120c5c00 	and	w0, w0, #0xfff00fff
  40269c:	1400004b 	b	4027c8 <can_rx_callback+0x208>
    switch (*data++ & ISOTP_PCI_FS_MASK) {
  4026a0:	12000c21 	and	w1, w1, #0xf
  4026a4:	7100043f 	cmp	w1, #0x1
  4026a8:	540003a0 	b.eq	40271c <can_rx_callback+0x15c>  // b.none
  4026ac:	7100083f 	cmp	w1, #0x2
  4026b0:	540006e0 	b.eq	40278c <can_rx_callback+0x1cc>  // b.none
  4026b4:	35000901 	cbnz	w1, 4027d4 <can_rx_callback+0x214>
            sctx->state = ISOTP_TX_SEND_CF;
  4026b8:	79418260 	ldrh	w0, [x19, #192]
  4026bc:	91030261 	add	x1, x19, #0xc0
  4026c0:	12002c00 	and	w0, w0, #0xfff
  4026c4:	32120000 	orr	w0, w0, #0x4000
  4026c8:	79018260 	strh	w0, [x19, #192]
  4026cc:	aa0103e0 	mov	x0, x1
  4026d0:	39400821 	ldrb	w1, [x1, #2]
  4026d4:	121c6c21 	and	w1, w1, #0xfffffff0
  4026d8:	39000801 	strb	w1, [x0, #2]
            sctx->wft = 0;
  4026dc:	3903427f 	strb	wzr, [x19, #208]
            sctx->backlog = 0;
  4026e0:	39034e7f 	strb	wzr, [x19, #211]
	z_impl_k_sem_reset(sem);
  4026e4:	91024260 	add	x0, x19, #0x90
  4026e8:	9400349b 	bl	40f954 <z_impl_k_sem_reset>
            sctx->bs = *data++;
  4026ec:	394026a0 	ldrb	w0, [x21, #9]
  4026f0:	39034660 	strb	w0, [x19, #209]
            sctx->stmin = *data++;
  4026f4:	39402aa0 	ldrb	w0, [x21, #10]
  4026f8:	39035260 	strb	w0, [x19, #212]
    k_work_submit(&sctx->work);
  4026fc:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  402700:	f9476800 	ldr	x0, [x0, #3792]
  402704:	f94037e2 	ldr	x2, [sp, #104]
  402708:	f9400001 	ldr	x1, [x0]
  40270c:	eb010042 	subs	x2, x2, x1
  402710:	d2800001 	mov	x1, #0x0                   	// #0
  402714:	54000720 	b.eq	4027f8 <can_rx_callback+0x238>  // b.none
}
  402718:	97fffb02 	bl	401320 <__stack_chk_fail@plt>
	z_impl_k_timer_start(timer, duration, period);
  40271c:	d2800002 	mov	x2, #0x0                   	// #0
  402720:	aa1403e0 	mov	x0, x20
  402724:	d2800c81 	mov	x1, #0x64                  	// #100
  402728:	940042d5 	bl	41327c <z_impl_k_timer_start>
            if (sctx->wft >= CONFIG_ISOTP_WFTMAX) {
  40272c:	39434260 	ldrb	w0, [x19, #208]
  402730:	7100241f 	cmp	w0, #0x9
  402734:	54000249 	b.ls	40277c <can_rx_callback+0x1bc>  // b.plast
                LOG_WRN("Got too many wait frames");
  402738:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40273c:	52800000 	mov	w0, #0x0                   	// #0
  402740:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  402744:	52800005 	mov	w5, #0x0                   	// #0
  402748:	f9478821 	ldr	x1, [x1, #3856]
  40274c:	911c70c6 	add	x6, x6, #0x71c
  402750:	d2800004 	mov	x4, #0x0                   	// #0
  402754:	d2800003 	mov	x3, #0x0                   	// #0
  402758:	52800042 	mov	w2, #0x2                   	// #2
  40275c:	97fffe7c 	bl	40214c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  402760:	b940c260 	ldr	w0, [x19, #192]
  402764:	52900001 	mov	w1, #0x8000                	// #32768
  402768:	72bf2001 	movk	w1, #0xf900, lsl #16
  40276c:	12005c00 	and	w0, w0, #0xffffff
  402770:	120c5c00 	and	w0, w0, #0xfff00fff
  402774:	2a010000 	orr	w0, w0, w1
  402778:	b900c260 	str	w0, [x19, #192]
            sctx->wft++;
  40277c:	39434260 	ldrb	w0, [x19, #208]
  402780:	11000400 	add	w0, w0, #0x1
  402784:	39034260 	strb	w0, [x19, #208]
            break;
  402788:	17ffffdd 	b	4026fc <can_rx_callback+0x13c>
            LOG_ERR("Got overflow FC frame");
  40278c:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  402790:	52800000 	mov	w0, #0x0                   	// #0
  402794:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  402798:	52800005 	mov	w5, #0x0                   	// #0
  40279c:	f9478821 	ldr	x1, [x1, #3856]
  4027a0:	911cd4c6 	add	x6, x6, #0x735
  4027a4:	d2800004 	mov	x4, #0x0                   	// #0
  4027a8:	d2800003 	mov	x3, #0x0                   	// #0
  4027ac:	52800022 	mov	w2, #0x1                   	// #1
  4027b0:	97fffe67 	bl	40214c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  4027b4:	b940c260 	ldr	w0, [x19, #192]
  4027b8:	52900001 	mov	w1, #0x8000                	// #32768
  4027bc:	72bf0001 	movk	w1, #0xf800, lsl #16
  4027c0:	12005c00 	and	w0, w0, #0xffffff
  4027c4:	120c5c00 	and	w0, w0, #0xfff00fff
  4027c8:	2a010000 	orr	w0, w0, w1
  4027cc:	b900c260 	str	w0, [x19, #192]
}
  4027d0:	17ffffcb 	b	4026fc <can_rx_callback+0x13c>
    sctx->state = ISOTP_TX_ERR;
  4027d4:	b940c260 	ldr	w0, [x19, #192]
  4027d8:	52900001 	mov	w1, #0x8000                	// #32768
  4027dc:	72bf6001 	movk	w1, #0xfb00, lsl #16
  4027e0:	12005c00 	and	w0, w0, #0xffffff
  4027e4:	120c5c00 	and	w0, w0, #0xfff00fff
  4027e8:	17fffff8 	b	4027c8 <can_rx_callback+0x208>
        LOG_ERR("Got unexpected PDU");
  4027ec:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  4027f0:	911d2cc6 	add	x6, x6, #0x74b
  4027f4:	17ffff9d 	b	402668 <can_rx_callback+0xa8>
    k_work_submit(&sctx->work);
  4027f8:	91006260 	add	x0, x19, #0x18
}
  4027fc:	a94153f3 	ldp	x19, x20, [sp, #16]
  402800:	a9425bf5 	ldp	x21, x22, [sp, #32]
  402804:	a94363f7 	ldp	x23, x24, [sp, #48]
  402808:	f94023f9 	ldr	x25, [sp, #64]
  40280c:	a8c77bfd 	ldp	x29, x30, [sp], #112
    k_work_submit(&sctx->work);
  402810:	1400362b 	b	4100bc <k_work_submit>
	return list->head;
  402814:	d0000157 	adrp	x23, 42c000 <__dso_handle>
    return (isotp_fast_node_id)(addr & ISOTP_FIXED_ADDR_SA_MASK);
  402818:	12001e60 	and	w0, w19, #0xff
  40281c:	f94576f4 	ldr	x20, [x23, #2792]
    SYS_SLIST_FOR_EACH_CONTAINER(&isotp_recv_ctx_list, context, node)
  402820:	f90033f4 	str	x20, [sp, #96]
  402824:	b50002b4 	cbnz	x20, 402878 <can_rx_callback+0x2b8>
    int err = k_mem_slab_alloc(&isotp_recv_ctx_slab, (void **)&context, K_NO_WAIT);
  402828:	b0000154 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  40282c:	910183f8 	add	x24, sp, #0x60
  402830:	aa1803e1 	mov	x1, x24
  402834:	d2800002 	mov	x2, #0x0                   	// #0
  402838:	f947a294 	ldr	x20, [x20, #3904]
  40283c:	aa1403e0 	mov	x0, x20
  402840:	94002dc0 	bl	40df40 <k_mem_slab_alloc>
  402844:	2a0003e7 	mov	w7, w0
    if (err != 0) {
  402848:	34000780 	cbz	w0, 402938 <can_rx_callback+0x378>
        LOG_ERR("No space for receive context - error %d.", err);
  40284c:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  402850:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  402854:	52800005 	mov	w5, #0x0                   	// #0
  402858:	911db8c6 	add	x6, x6, #0x76e
  40285c:	f9478821 	ldr	x1, [x1, #3856]
  402860:	d2800004 	mov	x4, #0x0                   	// #0
  402864:	d2800003 	mov	x3, #0x0                   	// #0
  402868:	52800022 	mov	w2, #0x1                   	// #1
  40286c:	52800000 	mov	w0, #0x0                   	// #0
  402870:	97fffe37 	bl	40214c <z_log_msg_runtime_create.constprop.0>
        return ISOTP_NO_CTX_LEFT;
  402874:	14000018 	b	4028d4 <can_rx_callback+0x314>
        if (isotp_fast_get_addr_sender(context->sender_addr) == sender_id) {
  402878:	39404281 	ldrb	w1, [x20, #16]
  40287c:	6b01001f 	cmp	w0, w1
  402880:	54000581 	b.ne	402930 <can_rx_callback+0x370>  // b.any
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf * __must_check net_buf_alloc(struct net_buf_pool *pool,
							  k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
  402884:	d2800001 	mov	x1, #0x0                   	// #0
  402888:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  40288c:	91254000 	add	x0, x0, #0x950
            *rctx = context;
  402890:	f9002ff4 	str	x20, [sp, #88]
  402894:	940027c1 	bl	40c798 <net_buf_alloc_fixed>
            context->frag = net_buf_alloc(&isotp_rx_pool, K_NO_WAIT);
  402898:	f9004e80 	str	x0, [x20, #152]
            if (context->frag == NULL) {
  40289c:	f94033e0 	ldr	x0, [sp, #96]
  4028a0:	f9404c00 	ldr	x0, [x0, #152]
  4028a4:	b5000b60 	cbnz	x0, 402a10 <can_rx_callback+0x450>
                LOG_ERR("No free buffers");
  4028a8:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4028ac:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  4028b0:	911d78c6 	add	x6, x6, #0x75e
  4028b4:	52800005 	mov	w5, #0x0                   	// #0
  4028b8:	f9478821 	ldr	x1, [x1, #3856]
  4028bc:	d2800004 	mov	x4, #0x0                   	// #0
  4028c0:	d2800003 	mov	x3, #0x0                   	// #0
  4028c4:	52800022 	mov	w2, #0x1                   	// #1
  4028c8:	97fffe21 	bl	40214c <z_log_msg_runtime_create.constprop.0>
                free_recv_ctx(rctx);
  4028cc:	910163e0 	add	x0, sp, #0x58
  4028d0:	97fffec7 	bl	4023ec <free_recv_ctx>
            LOG_ERR("RX buffer full");
  4028d4:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4028d8:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  4028dc:	52800005 	mov	w5, #0x0                   	// #0
  4028e0:	911e90c6 	add	x6, x6, #0x7a4
  4028e4:	f9478821 	ldr	x1, [x1, #3856]
  4028e8:	d2800004 	mov	x4, #0x0                   	// #0
  4028ec:	d2800003 	mov	x3, #0x0                   	// #0
  4028f0:	52800022 	mov	w2, #0x1                   	// #1
  4028f4:	52800000 	mov	w0, #0x0                   	// #0
  4028f8:	97fffe15 	bl	40214c <z_log_msg_runtime_create.constprop.0>
}
  4028fc:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  402900:	f9476800 	ldr	x0, [x0, #3792]
  402904:	f94037e2 	ldr	x2, [sp, #104]
  402908:	f9400001 	ldr	x1, [x0]
  40290c:	eb010042 	subs	x2, x2, x1
  402910:	d2800001 	mov	x1, #0x0                   	// #0
  402914:	54fff021 	b.ne	402718 <can_rx_callback+0x158>  // b.any
  402918:	a94153f3 	ldp	x19, x20, [sp, #16]
  40291c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  402920:	a94363f7 	ldp	x23, x24, [sp, #48]
  402924:	f94023f9 	ldr	x25, [sp, #64]
  402928:	a8c77bfd 	ldp	x29, x30, [sp], #112
  40292c:	d65f03c0 	ret
	return node->next;
  402930:	f9400294 	ldr	x20, [x20]
  402934:	17ffffbb 	b	402820 <can_rx_callback+0x260>
    context->buffer = net_buf_alloc(&isotp_rx_pool, K_NO_WAIT);
  402938:	f94033f9 	ldr	x25, [sp, #96]
  40293c:	d2800001 	mov	x1, #0x0                   	// #0
  402940:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  402944:	91254000 	add	x0, x0, #0x950
  402948:	94002794 	bl	40c798 <net_buf_alloc_fixed>
  40294c:	f9004b20 	str	x0, [x25, #144]
    if (!context->buffer) {
  402950:	f94033e0 	ldr	x0, [sp, #96]
  402954:	f9404801 	ldr	x1, [x0, #144]
  402958:	b50001e1 	cbnz	x1, 402994 <can_rx_callback+0x3d4>
        k_mem_slab_free(&isotp_recv_ctx_slab, (void **)&context);
  40295c:	aa1803e1 	mov	x1, x24
  402960:	aa1403e0 	mov	x0, x20
  402964:	94002dd5 	bl	40e0b8 <k_mem_slab_free>
        LOG_ERR("No net bufs.");
  402968:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40296c:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  402970:	52800005 	mov	w5, #0x0                   	// #0
  402974:	911e5cc6 	add	x6, x6, #0x797
  402978:	f9478821 	ldr	x1, [x1, #3856]
  40297c:	d2800004 	mov	x4, #0x0                   	// #0
  402980:	d2800003 	mov	x3, #0x0                   	// #0
  402984:	52800022 	mov	w2, #0x1                   	// #1
  402988:	52800000 	mov	w0, #0x0                   	// #0
  40298c:	97fffdf0 	bl	40214c <z_log_msg_runtime_create.constprop.0>
        return ISOTP_NO_NET_BUF_LEFT;
  402990:	17ffffd1 	b	4028d4 <can_rx_callback+0x314>
    context->frag = context->buffer;
  402994:	f9004c01 	str	x1, [x0, #152]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  402998:	52800503 	mov	w3, #0x28                  	// #40
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  40299c:	b9424801 	ldr	w1, [x0, #584]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  4029a0:	d2800102 	mov	x2, #0x8                   	// #8
    context->ctx = ctx;
  4029a4:	f9000416 	str	x22, [x0, #8]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  4029a8:	12005c21 	and	w1, w1, #0xffffff
    context->sender_addr = sender_addr;
  4029ac:	b9001013 	str	w19, [x0, #16]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  4029b0:	120c5c21 	and	w1, w1, #0xfff00fff
  4029b4:	b9024801 	str	w1, [x0, #584]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  4029b8:	91042001 	add	x1, x0, #0x108
    *rctx = context;
  4029bc:	f9002fe0 	str	x0, [sp, #88]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  4029c0:	91028000 	add	x0, x0, #0xa0
  4029c4:	94002f5b 	bl	40e730 <k_msgq_init>
    k_work_init(&context->work, receive_work_handler);
  4029c8:	f94033e0 	ldr	x0, [sp, #96]
  4029cc:	b0000001 	adrp	x1, 403000 <send_work_handler+0x2e0>
  4029d0:	91167021 	add	x1, x1, #0x59c
  4029d4:	91006000 	add	x0, x0, #0x18
  4029d8:	9400352c 	bl	40fe88 <k_work_init>
    k_timer_init(&context->timer, receive_timeout_handler, NULL);
  4029dc:	f94033e0 	ldr	x0, [sp, #96]
  4029e0:	d2800002 	mov	x2, #0x0                   	// #0
  4029e4:	90000001 	adrp	x1, 402000 <__floatunditf+0x60>
  4029e8:	910bb021 	add	x1, x1, #0x2ec
  4029ec:	9100e000 	add	x0, x0, #0x38
  4029f0:	9400421c 	bl	413260 <k_timer_init>
    sys_slist_append(&isotp_recv_ctx_list, &context->node);
  4029f4:	f94033e0 	ldr	x0, [sp, #96]
	return list->tail;
  4029f8:	912ba2e1 	add	x1, x23, #0xae8
	parent->next = child;
  4029fc:	f900001f 	str	xzr, [x0]
	return list->tail;
  402a00:	f9400422 	ldr	x2, [x1, #8]
Z_GENLIST_APPEND(slist, snode)
  402a04:	b50001a2 	cbnz	x2, 402a38 <can_rx_callback+0x478>
	list->head = node;
  402a08:	f90576e0 	str	x0, [x23, #2792]
	list->tail = node;
  402a0c:	f9000420 	str	x0, [x1, #8]
        receive_can_rx(rctx, frame);
  402a10:	f9402ff3 	ldr	x19, [sp, #88]
    switch (rctx->state) {
  402a14:	f9412660 	ldr	x0, [x19, #584]
  402a18:	530c4c01 	ubfx	w1, w0, #12, #8
  402a1c:	72141c1f 	tst	w0, #0xff000
  402a20:	54000120 	b.eq	402a44 <can_rx_callback+0x484>  // b.none
  402a24:	7100143f 	cmp	w1, #0x5
  402a28:	54000a00 	b.eq	402b68 <can_rx_callback+0x5a8>  // b.none
    k_work_submit(&rctx->work);
  402a2c:	91006260 	add	x0, x19, #0x18
  402a30:	940035a3 	bl	4100bc <k_work_submit>
  402a34:	17ffffb2 	b	4028fc <can_rx_callback+0x33c>
	parent->next = child;
  402a38:	f9000040 	str	x0, [x2]
	list->tail = node;
  402a3c:	f9000420 	str	x0, [x1, #8]
  402a40:	17fffff4 	b	402a10 <can_rx_callback+0x450>
    switch (frame->data[index] & ISOTP_PCI_TYPE_MASK) {
  402a44:	394022a0 	ldrb	w0, [x21, #8]
  402a48:	721c0c01 	ands	w1, w0, #0xf0
  402a4c:	540005a0 	b.eq	402b00 <can_rx_callback+0x540>  // b.none
  402a50:	7100403f 	cmp	w1, #0x10
  402a54:	54fffec1 	b.ne	402a2c <can_rx_callback+0x46c>  // b.any
            if (frame->dlc != ISOTP_FF_DL_MIN) {
  402a58:	394012a1 	ldrb	w1, [x21, #4]
  402a5c:	7100203f 	cmp	w1, #0x8
  402a60:	54fffe61 	b.ne	402a2c <can_rx_callback+0x46c>  // b.any
    len = ((pci & ISOTP_PCI_FF_DL_UPPER_MASK) << 8) | data[1];
  402a64:	394026a1 	ldrb	w1, [x21, #9]
  402a68:	53180c00 	ubfiz	w0, w0, #8, #4
  402a6c:	2a010000 	orr	w0, w0, w1
    if (!len) {
  402a70:	35000060 	cbnz	w0, 402a7c <can_rx_callback+0x4bc>
        len = UNALIGNED_GET((uint32_t *)data);
  402a74:	b9400aa0 	ldr	w0, [x21, #8]
  402a78:	5ac00800 	rev	w0, w0
            rctx->state = ISOTP_RX_STATE_PROCESS_FF;
  402a7c:	91092261 	add	x1, x19, #0x248
  402a80:	12002c00 	and	w0, w0, #0xfff
  402a84:	32130000 	orr	w0, w0, #0x2000
  402a88:	79049260 	strh	w0, [x19, #584]
  402a8c:	aa0103e0 	mov	x0, x1
            payload_len = CAN_MAX_DLEN - index;
  402a90:	528000d4 	mov	w20, #0x6                   	// #6
            rctx->state = ISOTP_RX_STATE_PROCESS_FF;
  402a94:	39400821 	ldrb	w1, [x1, #2]
  402a98:	121c6c21 	and	w1, w1, #0xfffffff0
  402a9c:	39000801 	strb	w1, [x0, #2]
            rctx->sn_expected = 1;
  402aa0:	52800021 	mov	w1, #0x1                   	// #1
  402aa4:	39493a60 	ldrb	w0, [x19, #590]
  402aa8:	33000c20 	bfxil	w0, w1, #0, #4
            index += 2;
  402aac:	52800041 	mov	w1, #0x2                   	// #2
            rctx->sn_expected = 1;
  402ab0:	39093a60 	strb	w0, [x19, #590]
 * @return The original tail of the buffer.
 */
static inline void *net_buf_add_mem(struct net_buf *buf, const void *mem,
				    size_t len)
{
	return net_buf_simple_add_mem(&buf->b, mem, len);
  402ab4:	f9404e60 	ldr	x0, [x19, #152]
    net_buf_add_mem(rctx->frag, &frame->data[index], payload_len);
  402ab8:	11002021 	add	w1, w1, #0x8
  402abc:	92401e82 	and	x2, x20, #0xff
  402ac0:	8b21c2a1 	add	x1, x21, w1, sxtw
  402ac4:	91006000 	add	x0, x0, #0x18
  402ac8:	940027a8 	bl	40c968 <net_buf_simple_add_mem>
    rctx->rem_len -= payload_len;
  402acc:	f9412660 	ldr	x0, [x19, #584]
  402ad0:	79449261 	ldrh	w1, [x19, #584]
  402ad4:	4b140000 	sub	w0, w0, w20
  402ad8:	12002c00 	and	w0, w0, #0xfff
  402adc:	33002c01 	bfxil	w1, w0, #0, #12
  402ae0:	79049261 	strh	w1, [x19, #584]
    int *p_rem_len = net_buf_user_data(rctx->frag);
  402ae4:	aa1303e1 	mov	x1, x19
  402ae8:	f8498c22 	ldr	x2, [x1, #152]!
    *p_rem_len = rctx->rem_len;
  402aec:	b9003040 	str	w0, [x2, #48]
	return z_impl_k_msgq_put(msgq, data, timeout);
  402af0:	d2800002 	mov	x2, #0x0                   	// #0
  402af4:	91028260 	add	x0, x19, #0xa0
  402af8:	94002f30 	bl	40e7b8 <z_impl_k_msgq_put>
    LOG_DBG("Enqueued item; remaining length %d, queue size %d", *p_rem_len,
  402afc:	17ffffcc 	b	402a2c <can_rx_callback+0x46c>
            rctx->rem_len = receive_get_sf_length(frame->data, &index);
  402b00:	79449261 	ldrh	w1, [x19, #584]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402b04:	71001c1f 	cmp	w0, #0x7
            rctx->rem_len = receive_get_sf_length(frame->data, &index);
  402b08:	33002c01 	bfxil	w1, w0, #0, #12
  402b0c:	79049261 	strh	w1, [x19, #584]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402b10:	528000e1 	mov	w1, #0x7                   	// #7
  402b14:	1a819000 	csel	w0, w0, w1, ls  // ls = plast
            if (payload_len > can_dlc_to_bytes(frame->dlc)) {
  402b18:	394012a1 	ldrb	w1, [x21, #4]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402b1c:	12001c14 	and	w20, w0, #0xff
	return dlc > 0x0F ? 64 : dlc_table[dlc];
  402b20:	71003c3f 	cmp	w1, #0xf
  402b24:	540000c8 	b.hi	402b3c <can_rx_callback+0x57c>  // b.pmore
            if (payload_len > can_dlc_to_bytes(frame->dlc)) {
  402b28:	b0000080 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  402b2c:	9121cc00 	add	x0, x0, #0x873
  402b30:	3861c800 	ldrb	w0, [x0, w1, sxtw]
  402b34:	6b14001f 	cmp	w0, w20
  402b38:	54fff7a3 	b.cc	402a2c <can_rx_callback+0x46c>  // b.lo, b.ul, b.last
            rctx->state = ISOTP_RX_STATE_PROCESS_SF;
  402b3c:	79449260 	ldrh	w0, [x19, #584]
  402b40:	91092261 	add	x1, x19, #0x248
  402b44:	12002c00 	and	w0, w0, #0xfff
  402b48:	32140000 	orr	w0, w0, #0x1000
  402b4c:	79049260 	strh	w0, [x19, #584]
  402b50:	aa0103e0 	mov	x0, x1
  402b54:	39400821 	ldrb	w1, [x1, #2]
  402b58:	121c6c21 	and	w1, w1, #0xfffffff0
  402b5c:	39000801 	strb	w1, [x0, #2]
    (*index)++;
  402b60:	52800021 	mov	w1, #0x1                   	// #1
            break;
  402b64:	17ffffd4 	b	402ab4 <can_rx_callback+0x4f4>
    if ((frame->data[index] & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_CF) {
  402b68:	394022a0 	ldrb	w0, [x21, #8]
  402b6c:	121c0c00 	and	w0, w0, #0xf0
  402b70:	7100801f 	cmp	w0, #0x20
  402b74:	540001e0 	b.eq	402bb0 <can_rx_callback+0x5f0>  // b.none
    rctx->state = ISOTP_RX_STATE_ERR;
  402b78:	b9424a60 	ldr	w0, [x19, #584]
  402b7c:	528e0001 	mov	w1, #0x7000                	// #28672
  402b80:	72bf4001 	movk	w1, #0xfa00, lsl #16
  402b84:	12005c00 	and	w0, w0, #0xffffff
  402b88:	120c5c00 	and	w0, w0, #0xfff00fff
  402b8c:	2a010000 	orr	w0, w0, w1
  402b90:	b9024a60 	str	w0, [x19, #584]
        k_work_submit(&rctx->work); // to dispatch complete message
  402b94:	91006260 	add	x0, x19, #0x18
  402b98:	94003549 	bl	4100bc <k_work_submit>
            if (rctx->state == ISOTP_RX_STATE_WAIT_CF) {
  402b9c:	f9412660 	ldr	x0, [x19, #584]
  402ba0:	530c4c00 	ubfx	w0, w0, #12, #8
  402ba4:	7100141f 	cmp	w0, #0x5
  402ba8:	54fff421 	b.ne	402a2c <can_rx_callback+0x46c>  // b.any
  402bac:	17ffff54 	b	4028fc <can_rx_callback+0x33c>
	z_impl_k_timer_start(timer, duration, period);
  402bb0:	d2800002 	mov	x2, #0x0                   	// #0
  402bb4:	9100e260 	add	x0, x19, #0x38
  402bb8:	d2800c81 	mov	x1, #0x64                  	// #100
  402bbc:	940041b0 	bl	41327c <z_impl_k_timer_start>
    if ((frame->data[index++] & ISOTP_PCI_SN_MASK) != rctx->sn_expected++) {
  402bc0:	f9412660 	ldr	x0, [x19, #584]
  402bc4:	39493a62 	ldrb	w2, [x19, #590]
  402bc8:	394022a1 	ldrb	w1, [x21, #8]
  402bcc:	d370cc00 	ubfx	x0, x0, #48, #4
  402bd0:	11000403 	add	w3, w0, #0x1
  402bd4:	12000c21 	and	w1, w1, #0xf
  402bd8:	33000c62 	bfxil	w2, w3, #0, #4
  402bdc:	39093a62 	strb	w2, [x19, #590]
  402be0:	6b00003f 	cmp	w1, w0
  402be4:	54000220 	b.eq	402c28 <can_rx_callback+0x668>  // b.none
        LOG_ERR("Sequence number mismatch");
  402be8:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  402bec:	52800000 	mov	w0, #0x0                   	// #0
  402bf0:	b0000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  402bf4:	52800005 	mov	w5, #0x0                   	// #0
  402bf8:	f9478821 	ldr	x1, [x1, #3856]
  402bfc:	911eccc6 	add	x6, x6, #0x7b3
  402c00:	d2800004 	mov	x4, #0x0                   	// #0
  402c04:	d2800003 	mov	x3, #0x0                   	// #0
  402c08:	52800022 	mov	w2, #0x1                   	// #1
  402c0c:	97fffd50 	bl	40214c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  402c10:	b9424a60 	ldr	w0, [x19, #584]
  402c14:	528e0001 	mov	w1, #0x7000                	// #28672
  402c18:	72bf8001 	movk	w1, #0xfc00, lsl #16
  402c1c:	12005c00 	and	w0, w0, #0xffffff
  402c20:	120c5c00 	and	w0, w0, #0xfff00fff
  402c24:	17ffffda 	b	402b8c <can_rx_callback+0x5cc>
    data_len = MIN(rctx->rem_len, can_dlc_to_bytes(frame->dlc) - index);
  402c28:	f9412662 	ldr	x2, [x19, #584]
  402c2c:	394012a1 	ldrb	w1, [x21, #4]
  402c30:	12002c42 	and	w2, w2, #0xfff
  402c34:	71003c3f 	cmp	w1, #0xf
  402c38:	54000488 	b.hi	402cc8 <can_rx_callback+0x708>  // b.pmore
  402c3c:	b0000080 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  402c40:	9121cc00 	add	x0, x0, #0x873
  402c44:	3861c801 	ldrb	w1, [x0, w1, sxtw]
  402c48:	51000421 	sub	w1, w1, #0x1
  402c4c:	6b01005f 	cmp	w2, w1
  402c50:	f9404e60 	ldr	x0, [x19, #152]
  402c54:	1a82a034 	csel	w20, w1, w2, ge  // ge = tcont
  402c58:	1a82a022 	csel	w2, w1, w2, ge  // ge = tcont
  402c5c:	910026a1 	add	x1, x21, #0x9
  402c60:	91006000 	add	x0, x0, #0x18
  402c64:	94002741 	bl	40c968 <net_buf_simple_add_mem>
    rctx->rem_len -= data_len;
  402c68:	f9412660 	ldr	x0, [x19, #584]
  402c6c:	79449261 	ldrh	w1, [x19, #584]
  402c70:	4b140000 	sub	w0, w0, w20
  402c74:	12002c00 	and	w0, w0, #0xfff
  402c78:	33002c01 	bfxil	w1, w0, #0, #12
  402c7c:	79049261 	strh	w1, [x19, #584]
    int *p_rem_len = net_buf_user_data(rctx->frag);
  402c80:	aa1303e1 	mov	x1, x19
  402c84:	f8498c22 	ldr	x2, [x1, #152]!
    *p_rem_len = rctx->rem_len;
  402c88:	b9003040 	str	w0, [x2, #48]
	return z_impl_k_msgq_put(msgq, data, timeout);
  402c8c:	d2800002 	mov	x2, #0x0                   	// #0
  402c90:	91028260 	add	x0, x19, #0xa0
  402c94:	94002ec9 	bl	40e7b8 <z_impl_k_msgq_put>
    if (rctx->rem_len == 0) {
  402c98:	79449261 	ldrh	w1, [x19, #584]
  402c9c:	12002c20 	and	w0, w1, #0xfff
  402ca0:	f2402c3f 	tst	x1, #0xfff
  402ca4:	54000161 	b.ne	402cd0 <can_rx_callback+0x710>  // b.any
        rctx->state = ISOTP_RX_STATE_RECYCLE;
  402ca8:	91092261 	add	x1, x19, #0x248
  402cac:	32114000 	orr	w0, w0, #0xffff8000
  402cb0:	79049260 	strh	w0, [x19, #584]
  402cb4:	aa0103e0 	mov	x0, x1
  402cb8:	39400821 	ldrb	w1, [x1, #2]
  402cbc:	121c6c21 	and	w1, w1, #0xfffffff0
  402cc0:	39000801 	strb	w1, [x0, #2]
  402cc4:	17ffffb4 	b	402b94 <can_rx_callback+0x5d4>
  402cc8:	52800801 	mov	w1, #0x40                  	// #64
  402ccc:	17ffffdf 	b	402c48 <can_rx_callback+0x688>
    if (rctx->ctx->opts->bs && !--rctx->bs) {
  402cd0:	f9400662 	ldr	x2, [x19, #8]
  402cd4:	f9400841 	ldr	x1, [x2, #16]
  402cd8:	39400021 	ldrb	w1, [x1]
  402cdc:	34fff601 	cbz	w1, 402b9c <can_rx_callback+0x5dc>
  402ce0:	39493661 	ldrb	w1, [x19, #589]
  402ce4:	51000421 	sub	w1, w1, #0x1
  402ce8:	12001c21 	and	w1, w1, #0xff
  402cec:	39093661 	strb	w1, [x19, #589]
  402cf0:	35fff561 	cbnz	w1, 402b9c <can_rx_callback+0x5dc>
        rctx->bs = rctx->ctx->opts->bs;
  402cf4:	f9400841 	ldr	x1, [x2, #16]
        rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402cf8:	32140400 	orr	w0, w0, #0x3000
        rctx->bs = rctx->ctx->opts->bs;
  402cfc:	39400021 	ldrb	w1, [x1]
  402d00:	39093661 	strb	w1, [x19, #589]
        rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402d04:	91092261 	add	x1, x19, #0x248
  402d08:	79049260 	strh	w0, [x19, #584]
  402d0c:	aa0103e0 	mov	x0, x1
  402d10:	39400821 	ldrb	w1, [x1, #2]
  402d14:	121c6c21 	and	w1, w1, #0xfffffff0
  402d18:	39000801 	strb	w1, [x0, #2]
            if (rctx->state == ISOTP_RX_STATE_WAIT_CF) {
  402d1c:	17ffff44 	b	402a2c <can_rx_callback+0x46c>

0000000000402d20 <send_work_handler>:
{
  402d20:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  402d24:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  402d28:	910003fd 	mov	x29, sp
  402d2c:	f9476821 	ldr	x1, [x1, #3792]
  402d30:	a90153f3 	stp	x19, x20, [sp, #16]
    struct isotp_fast_send_ctx *sctx = CONTAINER_OF(work, struct isotp_fast_send_ctx, work);
  402d34:	d1006013 	sub	x19, x0, #0x18
{
  402d38:	a9025bf5 	stp	x21, x22, [sp, #32]
  402d3c:	a90363f7 	stp	x23, x24, [sp, #48]
  402d40:	a9046bf9 	stp	x25, x26, [sp, #64]
  402d44:	a90573fb 	stp	x27, x28, [sp, #80]
  402d48:	f9400022 	ldr	x2, [x1]
  402d4c:	f9003fe2 	str	x2, [sp, #120]
  402d50:	d2800002 	mov	x2, #0x0                   	// #0
    send_state_machine(sctx);
  402d54:	f90033f3 	str	x19, [sp, #96]
    switch (sctx->state) {
  402d58:	f9406261 	ldr	x1, [x19, #192]
  402d5c:	530c4c21 	ubfx	w1, w1, #12, #8
  402d60:	51000821 	sub	w1, w1, #0x2
  402d64:	7100183f 	cmp	w1, #0x6
  402d68:	54001de8 	b.hi	403124 <send_work_handler+0x404>  // b.pmore
  402d6c:	b0000082 	adrp	x2, 413000 <z_impl_k_uptime_ticks>
  402d70:	91184042 	add	x2, x2, #0x610
  402d74:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  402d78:	10000061 	adr	x1, 402d84 <send_work_handler+0x64>
  402d7c:	8b22a822 	add	x2, x1, w2, sxth #2
  402d80:	d61f0040 	br	x2
    frame->id = addr;
  402d84:	b9401262 	ldr	w2, [x19, #16]
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402d88:	52800119 	mov	w25, #0x8                   	// #8
    frame->id = addr;
  402d8c:	b9406be1 	ldr	w1, [sp, #104]

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len,
  402d90:	d28000c3 	mov	x3, #0x6                   	// #6
    prepare_frame(&frame, sctx->ctx, sctx->recipient_addr);
  402d94:	f9400678 	ldr	x24, [x19, #8]
    frame->id = addr;
  402d98:	33007041 	bfxil	w1, w2, #0, #29
  402d9c:	b9006be1 	str	w1, [sp, #104]
    uint16_t len = sctx->rem_len;
  402da0:	a94b8276 	ldp	x22, x0, [x19, #184]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402da4:	f9400b01 	ldr	x1, [x24, #16]
  402da8:	39400821 	ldrb	w1, [x1, #2]
    uint16_t len = sctx->rem_len;
  402dac:	12002c14 	and	w20, w0, #0xfff
  402db0:	d3402c15 	ubfx	x21, x0, #0, #12
        frame.data[index++] = ISOTP_PCI_TYPE_FF | (len >> 8);
  402db4:	53082c00 	ubfx	w0, w0, #8, #4
  402db8:	321c0000 	orr	w0, w0, #0x10
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402dbc:	7100229f 	cmp	w20, #0x8
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402dc0:	d341fc21 	lsr	x1, x1, #1
        frame.data[index++] = ISOTP_PCI_TYPE_FF | (len >> 8);
  402dc4:	3901c3e0 	strb	w0, [sp, #112]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402dc8:	121e0021 	and	w1, w1, #0x4
    sctx->sn = 1;
  402dcc:	39434a60 	ldrb	w0, [x19, #210]
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402dd0:	1a9992b5 	csel	w21, w21, w25, ls  // ls = plast
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402dd4:	32000021 	orr	w1, w1, #0x1
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402dd8:	12003eb5 	and	w21, w21, #0xffff
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402ddc:	3901b7e1 	strb	w1, [sp, #109]
    sctx->sn = 1;
  402de0:	52800021 	mov	w1, #0x1                   	// #1
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402de4:	51000ab7 	sub	w23, w21, #0x2
    sctx->sn = 1;
  402de8:	33000c20 	bfxil	w0, w1, #0, #4
  402dec:	39034a60 	strb	w0, [x19, #210]
    memcpy(&frame.data[index], sctx->data, size);
  402df0:	92403ef7 	and	x23, x23, #0xffff
  402df4:	aa1603e1 	mov	x1, x22
  402df8:	aa1703e2 	mov	x2, x23
  402dfc:	9101cbe0 	add	x0, sp, #0x72
        frame.data[index++] = len & 0xFF;
  402e00:	3901c7f4 	strb	w20, [sp, #113]
  402e04:	97fff913 	bl	401250 <__memcpy_chk@plt>
    sctx->rem_len -= size;
  402e08:	79418260 	ldrh	w0, [x19, #192]
  402e0c:	11000a94 	add	w20, w20, #0x2
  402e10:	4b150294 	sub	w20, w20, w21
    sctx->data += size;
  402e14:	8b1702d6 	add	x22, x22, x23
    frame.dlc = can_bytes_to_dlc(CAN_MAX_DLEN);
  402e18:	3901b3f9 	strb	w25, [sp, #108]
    sctx->rem_len -= size;
  402e1c:	33002e80 	bfxil	w0, w20, #0, #12
    sctx->data += size;
  402e20:	f9005e76 	str	x22, [x19, #184]
    sctx->rem_len -= size;
  402e24:	79018260 	strh	w0, [x19, #192]
    ret = can_send(sctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), send_can_tx_callback,
  402e28:	f9400300 	ldr	x0, [x24]
		union { uintptr_t x; void * val; } parm4 = { .val = user_data };
		return (int) arch_syscall_invoke5(parm0.x, parm1.x, parm2.x, parm3.x, parm4.x, K_SYSCALL_CAN_SEND);
	}
#endif
	compiler_barrier();
	return z_impl_can_send(dev, frame, timeout, callback, user_data);
  402e2c:	d2800c82 	mov	x2, #0x64                  	// #100
  402e30:	aa1303e4 	mov	x4, x19
  402e34:	9101a3e1 	add	x1, sp, #0x68
  402e38:	90000003 	adrp	x3, 402000 <__floatunditf+0x60>
  402e3c:	91033063 	add	x3, x3, #0xcc
  402e40:	94002738 	bl	40cb20 <z_impl_can_send>
            k_timer_start(&sctx->timer, K_MSEC(ISOTP_BS_TIMEOUT_MS), K_NO_WAIT);
  402e44:	f94033e0 	ldr	x0, [sp, #96]
  402e48:	9100e000 	add	x0, x0, #0x38
	z_impl_k_timer_start(timer, duration, period);
  402e4c:	d2800002 	mov	x2, #0x0                   	// #0
  402e50:	d2800c81 	mov	x1, #0x64                  	// #100
  402e54:	9400410a 	bl	41327c <z_impl_k_timer_start>
                    sctx->state = ISOTP_TX_WAIT_FC;
  402e58:	f94033e1 	ldr	x1, [sp, #96]
  402e5c:	79418020 	ldrh	w0, [x1, #192]
  402e60:	12002c00 	and	w0, w0, #0xfff
  402e64:	32140400 	orr	w0, w0, #0x3000
  402e68:	14000047 	b	402f84 <send_work_handler+0x264>
  402e6c:	90000015 	adrp	x21, 402000 <__floatunditf+0x60>
  402e70:	9101a3f7 	add	x23, sp, #0x68
  402e74:	9101c7f8 	add	x24, sp, #0x71
  402e78:	910332b5 	add	x21, x21, #0xcc
    len = MIN(sctx->rem_len, CAN_MAX_DLEN - index);
  402e7c:	528000f6 	mov	w22, #0x7                   	// #7
            k_timer_stop(&sctx->timer);
  402e80:	91008000 	add	x0, x0, #0x20
  402e84:	97fffc91 	bl	4020c8 <k_timer_stop>
                ret = send_cf(sctx);
  402e88:	f94033f3 	ldr	x19, [sp, #96]
  402e8c:	d28000e3 	mov	x3, #0x7                   	// #7
    frame->id = addr;
  402e90:	b9406be0 	ldr	w0, [sp, #104]
  402e94:	b9401261 	ldr	w1, [x19, #16]
    prepare_frame(&frame, sctx->ctx, sctx->recipient_addr);
  402e98:	f940067b 	ldr	x27, [x19, #8]
    frame->id = addr;
  402e9c:	33007020 	bfxil	w0, w1, #0, #29
  402ea0:	b9006be0 	str	w0, [sp, #104]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402ea4:	f9400b60 	ldr	x0, [x27, #16]
  402ea8:	39400800 	ldrb	w0, [x0, #2]
  402eac:	d341fc00 	lsr	x0, x0, #1
  402eb0:	121e0000 	and	w0, w0, #0x4
  402eb4:	32000000 	orr	w0, w0, #0x1
  402eb8:	3901b7e0 	strb	w0, [sp, #109]
    frame.data[index++] = ISOTP_PCI_TYPE_CF | sctx->sn;
  402ebc:	f9406a60 	ldr	x0, [x19, #208]
  402ec0:	d3504c00 	ubfx	x0, x0, #16, #4
  402ec4:	321b0000 	orr	w0, w0, #0x20
  402ec8:	3901c3e0 	strb	w0, [sp, #112]
  402ecc:	aa1803e0 	mov	x0, x24
    len = MIN(sctx->rem_len, CAN_MAX_DLEN - index);
  402ed0:	a94bd27a 	ldp	x26, x20, [x19, #184]
  402ed4:	12002e94 	and	w20, w20, #0xfff
  402ed8:	aa1a03e1 	mov	x1, x26
  402edc:	71001e9f 	cmp	w20, #0x7
  402ee0:	1a969299 	csel	w25, w20, w22, ls  // ls = plast
    memcpy(&frame.data[index], sctx->data, len);
  402ee4:	2a1903fc 	mov	w28, w25
    sctx->rem_len -= len;
  402ee8:	4b190294 	sub	w20, w20, w25
  402eec:	aa1c03e2 	mov	x2, x28
  402ef0:	97fff8d8 	bl	401250 <__memcpy_chk@plt>
  402ef4:	79418260 	ldrh	w0, [x19, #192]
    sctx->data += len;
  402ef8:	8b1c035a 	add	x26, x26, x28
  402efc:	f9005e7a 	str	x26, [x19, #184]
    sctx->rem_len -= len;
  402f00:	33002e80 	bfxil	w0, w20, #0, #12
  402f04:	79018260 	strh	w0, [x19, #192]
    frame.dlc = can_bytes_to_dlc(len + index);
  402f08:	11000720 	add	w0, w25, #0x1
  402f0c:	97fffc8f 	bl	402148 <can_bytes_to_dlc>
  402f10:	3901b3e0 	strb	w0, [sp, #108]
    ret = can_send(sctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), send_can_tx_callback,
  402f14:	f9400360 	ldr	x0, [x27]
  402f18:	d2800c82 	mov	x2, #0x64                  	// #100
  402f1c:	aa1303e4 	mov	x4, x19
  402f20:	aa1503e3 	mov	x3, x21
  402f24:	aa1703e1 	mov	x1, x23
  402f28:	940026fe 	bl	40cb20 <z_impl_can_send>
  402f2c:	2a0003f4 	mov	w20, w0
    if (ret == 0) {
  402f30:	7100001f 	cmp	w0, #0x0
  402f34:	35000ca0 	cbnz	w0, 4030c8 <send_work_handler+0x3a8>
        sctx->sn++;
  402f38:	f9406a60 	ldr	x0, [x19, #208]
  402f3c:	39434a61 	ldrb	w1, [x19, #210]
  402f40:	d3504c00 	ubfx	x0, x0, #16, #4
  402f44:	11000400 	add	w0, w0, #0x1
  402f48:	33000c01 	bfxil	w1, w0, #0, #4
        sctx->bs--;
  402f4c:	39434660 	ldrb	w0, [x19, #209]
        sctx->sn++;
  402f50:	39034a61 	strb	w1, [x19, #210]
        sctx->bs--;
  402f54:	51000400 	sub	w0, w0, #0x1
  402f58:	39034660 	strb	w0, [x19, #209]
        sctx->backlog++;
  402f5c:	39434e60 	ldrb	w0, [x19, #211]
  402f60:	11000400 	add	w0, w0, #0x1
  402f64:	39034e60 	strb	w0, [x19, #211]
    ret = ret ? ret : sctx->rem_len;
  402f68:	f9406260 	ldr	x0, [x19, #192]
                if (!ret) {
  402f6c:	f2402c1f 	tst	x0, #0xfff
  402f70:	54000141 	b.ne	402f98 <send_work_handler+0x278>  // b.any
                    sctx->state = ISOTP_TX_WAIT_BACKLOG;
  402f74:	f94033e1 	ldr	x1, [sp, #96]
  402f78:	79418020 	ldrh	w0, [x1, #192]
  402f7c:	12002c00 	and	w0, w0, #0xfff
  402f80:	32130400 	orr	w0, w0, #0x6000
            sctx->state = ISOTP_TX_SEND_CF;
  402f84:	79018020 	strh	w0, [x1, #192]
  402f88:	39430820 	ldrb	w0, [x1, #194]
  402f8c:	121c6c00 	and	w0, w0, #0xfffffff0
  402f90:	39030820 	strb	w0, [x1, #194]
            break;
  402f94:	14000064 	b	403124 <send_work_handler+0x404>
                if (sctx->ctx->opts->bs && !sctx->bs) {
  402f98:	f94033e0 	ldr	x0, [sp, #96]
  402f9c:	f9400401 	ldr	x1, [x0, #8]
  402fa0:	f9400821 	ldr	x1, [x1, #16]
  402fa4:	39400021 	ldrb	w1, [x1]
  402fa8:	340000e1 	cbz	w1, 402fc4 <send_work_handler+0x2a4>
  402fac:	39434401 	ldrb	w1, [x0, #209]
  402fb0:	350000a1 	cbnz	w1, 402fc4 <send_work_handler+0x2a4>
  402fb4:	d2800002 	mov	x2, #0x0                   	// #0
  402fb8:	9100e000 	add	x0, x0, #0x38
  402fbc:	d2800c81 	mov	x1, #0x64                  	// #100
  402fc0:	17ffffa5 	b	402e54 <send_work_handler+0x134>
                else if (sctx->stmin) {
  402fc4:	39435001 	ldrb	w1, [x0, #212]
  402fc8:	34000161 	cbz	w1, 402ff4 <send_work_handler+0x2d4>
                    sctx->state = ISOTP_TX_WAIT_ST;
  402fcc:	79418001 	ldrh	w1, [x0, #192]
  402fd0:	91030002 	add	x2, x0, #0xc0
  402fd4:	528a0003 	mov	w3, #0x5000                	// #20480
  402fd8:	12002c21 	and	w1, w1, #0xfff
  402fdc:	2a030021 	orr	w1, w1, w3
  402fe0:	79018001 	strh	w1, [x0, #192]
  402fe4:	39430800 	ldrb	w0, [x0, #194]
  402fe8:	121c6c00 	and	w0, w0, #0xfffffff0
  402fec:	39000840 	strb	w0, [x2, #2]
                    break;
  402ff0:	1400004d 	b	403124 <send_work_handler+0x404>
	return z_impl_k_sem_take(sem, timeout);
  402ff4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  402ff8:	91024000 	add	x0, x0, #0x90
  402ffc:	940031e5 	bl	40f790 <z_impl_k_sem_take>
            } while (ret > 0);
  403000:	17ffffa2 	b	402e88 <send_work_handler+0x168>
            k_timer_start(&sctx->timer, stmin_to_timeout(sctx->stmin), K_NO_WAIT);
  403004:	39435261 	ldrb	w1, [x19, #212]
  403008:	91008000 	add	x0, x0, #0x20
    if (stmin > ISOTP_STMIN_MAX || (stmin > ISOTP_STMIN_MS_MAX && stmin < ISOTP_STMIN_US_BEGIN)) {
  40300c:	51020022 	sub	w2, w1, #0x80
  403010:	12001c42 	and	w2, w2, #0xff
  403014:	7101c05f 	cmp	w2, #0x70
  403018:	52801f42 	mov	w2, #0xfa                  	// #250
  40301c:	7a428022 	ccmp	w1, w2, #0x2, hi  // hi = pmore
  403020:	540001c8 	b.hi	403058 <send_work_handler+0x338>  // b.pmore
    if (stmin >= ISOTP_STMIN_US_BEGIN) {
  403024:	7103c03f 	cmp	w1, #0xf0
  403028:	540001c8 	b.hi	403060 <send_work_handler+0x340>  // b.pmore
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
  40302c:	11002421 	add	w1, w1, #0x9
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
  403030:	d2800142 	mov	x2, #0xa                   	// #10
		t += off;
  403034:	92401c21 	and	x1, x1, #0xff
			return t / ((uint64_t)from_hz / to_hz);
  403038:	9ac20821 	udiv	x1, x1, x2
	z_impl_k_timer_start(timer, duration, period);
  40303c:	d2800002 	mov	x2, #0x0                   	// #0
  403040:	9400408f 	bl	41327c <z_impl_k_timer_start>
            sctx->state = ISOTP_TX_SEND_CF;
  403044:	f94033e1 	ldr	x1, [sp, #96]
  403048:	79418020 	ldrh	w0, [x1, #192]
  40304c:	12002c00 	and	w0, w0, #0xfff
  403050:	32120000 	orr	w0, w0, #0x4000
  403054:	17ffffcc 	b	402f84 <send_work_handler+0x264>
        return K_MSEC(ISOTP_STMIN_MS_MAX);
  403058:	d28001a1 	mov	x1, #0xd                   	// #13
  40305c:	17fffff8 	b	40303c <send_work_handler+0x31c>
        return K_USEC((stmin + 1 - ISOTP_STMIN_US_BEGIN) * 100U);
  403060:	d2800021 	mov	x1, #0x1                   	// #1
  403064:	17fffff6 	b	40303c <send_work_handler+0x31c>
            sctx->ctx->sent_callback(sctx->error, sctx->cb_arg);
  403068:	f9400660 	ldr	x0, [x19, #8]
  40306c:	f9406661 	ldr	x1, [x19, #200]
  403070:	f9401802 	ldr	x2, [x0, #48]
  403074:	39c30e60 	ldrsb	w0, [x19, #195]
            sctx->ctx->sent_callback(ISOTP_N_OK, sctx->cb_arg);
  403078:	d63f0040 	blr	x2
            sctx->state = ISOTP_TX_STATE_RESET;
  40307c:	f94033e0 	ldr	x0, [sp, #96]
  403080:	91030002 	add	x2, x0, #0xc0
  403084:	79418001 	ldrh	w1, [x0, #192]
  403088:	12002c21 	and	w1, w1, #0xfff
  40308c:	79018001 	strh	w1, [x0, #192]
  403090:	39430800 	ldrb	w0, [x0, #194]
  403094:	121c6c00 	and	w0, w0, #0xfffffff0
  403098:	39000840 	strb	w0, [x2, #2]
            free_send_ctx(&sctx);
  40309c:	910183e0 	add	x0, sp, #0x60
  4030a0:	97fffced 	bl	402454 <free_send_ctx>
}
  4030a4:	14000020 	b	403124 <send_work_handler+0x404>
            k_timer_stop(&sctx->timer);
  4030a8:	91008000 	add	x0, x0, #0x20
  4030ac:	97fffc07 	bl	4020c8 <k_timer_stop>
            sctx->ctx->sent_callback(ISOTP_N_OK, sctx->cb_arg);
  4030b0:	f94033e0 	ldr	x0, [sp, #96]
  4030b4:	f9400401 	ldr	x1, [x0, #8]
  4030b8:	f9401822 	ldr	x2, [x1, #48]
  4030bc:	f9406401 	ldr	x1, [x0, #200]
  4030c0:	52800000 	mov	w0, #0x0                   	// #0
  4030c4:	17ffffed 	b	403078 <send_work_handler+0x358>
                if (ret < 0) {
  4030c8:	54fff68a 	b.ge	402f98 <send_work_handler+0x278>  // b.tcont
                    LOG_ERR("Failed to send CF");
  4030cc:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4030d0:	52800022 	mov	w2, #0x1                   	// #1
  4030d4:	52800000 	mov	w0, #0x0                   	// #0
  4030d8:	90000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  4030dc:	f9478821 	ldr	x1, [x1, #3856]
  4030e0:	911f30c6 	add	x6, x6, #0x7cc
  4030e4:	52800005 	mov	w5, #0x0                   	// #0
  4030e8:	d2800004 	mov	x4, #0x0                   	// #0
  4030ec:	d2800003 	mov	x3, #0x0                   	// #0
  4030f0:	97fffc17 	bl	40214c <z_log_msg_runtime_create.constprop.0>
                    send_report_error(sctx, ret == -EAGAIN ? ISOTP_N_TIMEOUT_A : ISOTP_N_ERROR);
  4030f4:	f94033e1 	ldr	x1, [sp, #96]
  4030f8:	31002e9f 	cmn	w20, #0xb
  4030fc:	12800102 	mov	w2, #0xfffffff7            	// #-9
  403100:	5a9f1042 	csinv	w2, w2, wzr, ne  // ne = any
    sctx->state = ISOTP_TX_ERR;
  403104:	79418020 	ldrh	w0, [x1, #192]
    sctx->error = err;
  403108:	39030c22 	strb	w2, [x1, #195]
    sctx->state = ISOTP_TX_ERR;
  40310c:	12002c00 	and	w0, w0, #0xfff
  403110:	32114000 	orr	w0, w0, #0xffff8000
  403114:	79018020 	strh	w0, [x1, #192]
  403118:	39430820 	ldrb	w0, [x1, #194]
  40311c:	121c6c00 	and	w0, w0, #0xfffffff0
  403120:	39030820 	strb	w0, [x1, #194]
}
  403124:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403128:	f9476800 	ldr	x0, [x0, #3792]
  40312c:	f9403fe2 	ldr	x2, [sp, #120]
  403130:	f9400001 	ldr	x1, [x0]
  403134:	eb010042 	subs	x2, x2, x1
  403138:	d2800001 	mov	x1, #0x0                   	// #0
  40313c:	54000040 	b.eq	403144 <send_work_handler+0x424>  // b.none
  403140:	97fff878 	bl	401320 <__stack_chk_fail@plt>
  403144:	a94153f3 	ldp	x19, x20, [sp, #16]
  403148:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40314c:	a94363f7 	ldp	x23, x24, [sp, #48]
  403150:	a9446bf9 	ldp	x25, x26, [sp, #64]
  403154:	a94573fb 	ldp	x27, x28, [sp, #80]
  403158:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40315c:	d65f03c0 	ret

0000000000403160 <receive_state_machine>:
{
  403160:	d10143ff 	sub	sp, sp, #0x50
  403164:	a9017bfd 	stp	x29, x30, [sp, #16]
  403168:	910043fd 	add	x29, sp, #0x10
  40316c:	f9001fe0 	str	x0, [sp, #56]
  403170:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403174:	f90013f3 	str	x19, [sp, #32]
	return z_impl_k_msgq_get(msgq, data, timeout);
  403178:	910103f3 	add	x19, sp, #0x40
  40317c:	f9476800 	ldr	x0, [x0, #3792]
  403180:	f9400001 	ldr	x1, [x0]
  403184:	f90027e1 	str	x1, [sp, #72]
  403188:	d2800001 	mov	x1, #0x0                   	// #0
    while (k_msgq_get(&rctx->recv_queue, &frag, K_NO_WAIT) == 0) {
  40318c:	f9401fe0 	ldr	x0, [sp, #56]
  403190:	91028000 	add	x0, x0, #0xa0
  403194:	d2800002 	mov	x2, #0x0                   	// #0
  403198:	aa1303e1 	mov	x1, x19
  40319c:	94002e2d 	bl	40ea50 <z_impl_k_msgq_get>
  4031a0:	2a0003e1 	mov	w1, w0
  4031a4:	f9401fe0 	ldr	x0, [sp, #56]
  4031a8:	34000181 	cbz	w1, 4031d8 <receive_state_machine+0x78>
    switch (rctx->state) {
  4031ac:	f9412407 	ldr	x7, [x0, #584]
  4031b0:	530c4ce1 	ubfx	w1, w7, #12, #8
  4031b4:	51000421 	sub	w1, w1, #0x1
  4031b8:	71001c3f 	cmp	w1, #0x7
  4031bc:	540002e8 	b.hi	403218 <receive_state_machine+0xb8>  // b.pmore
  4031c0:	90000082 	adrp	x2, 413000 <z_impl_k_uptime_ticks>
  4031c4:	91188042 	add	x2, x2, #0x620
  4031c8:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  4031cc:	10000061 	adr	x1, 4031d8 <receive_state_machine+0x78>
  4031d0:	8b22a822 	add	x2, x1, w2, sxth #2
  4031d4:	d61f0040 	br	x2
        rctx->ctx->recv_callback(frag, *p_rem_len, rctx->sender_addr, rctx->ctx->recv_cb_arg);
  4031d8:	f9400401 	ldr	x1, [x0, #8]
        int *p_rem_len = net_buf_user_data(frag);
  4031dc:	f94023e4 	ldr	x4, [sp, #64]
        rctx->ctx->recv_callback(frag, *p_rem_len, rctx->sender_addr, rctx->ctx->recv_cb_arg);
  4031e0:	a9418c25 	ldp	x5, x3, [x1, #24]
  4031e4:	b9401002 	ldr	w2, [x0, #16]
  4031e8:	aa0403e0 	mov	x0, x4
  4031ec:	b9403081 	ldr	w1, [x4, #48]
  4031f0:	d63f00a0 	blr	x5
        net_buf_unref(frag);
  4031f4:	f94023e0 	ldr	x0, [sp, #64]
  4031f8:	9400256d 	bl	40c7ac <net_buf_unref>
  4031fc:	17ffffe4 	b	40318c <receive_state_machine+0x2c>
            rctx->state = ISOTP_RX_STATE_RECYCLE;
  403200:	128fffe1 	mov	w1, #0xffff8000            	// #-32768
  403204:	79049001 	strh	w1, [x0, #584]
  403208:	39492801 	ldrb	w1, [x0, #586]
  40320c:	121c6c21 	and	w1, w1, #0xfffffff0
  403210:	39092801 	strb	w1, [x0, #586]
                receive_state_machine(rctx);
  403214:	97ffffd3 	bl	403160 <receive_state_machine>
}
  403218:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40321c:	f9476800 	ldr	x0, [x0, #3792]
  403220:	f94027e2 	ldr	x2, [sp, #72]
  403224:	f9400001 	ldr	x1, [x0]
  403228:	eb010042 	subs	x2, x2, x1
  40322c:	d2800001 	mov	x1, #0x0                   	// #0
  403230:	540011c0 	b.eq	403468 <receive_state_machine+0x308>  // b.none
  403234:	97fff83b 	bl	401320 <__stack_chk_fail@plt>
            if (rctx->ctx->opts->bs == 0
  403238:	f9400401 	ldr	x1, [x0, #8]
  40323c:	f9400821 	ldr	x1, [x1, #16]
  403240:	39400021 	ldrb	w1, [x1]
  403244:	35000321 	cbnz	w1, 4032a8 <receive_state_machine+0x148>
                && rctx->rem_len > CONFIG_ISOTP_FAST_RX_MAX_PACKET_COUNT * (CAN_MAX_DLEN - 1))
  403248:	12002ce7 	and	w7, w7, #0xfff
  40324c:	710460ff 	cmp	w7, #0x118
  403250:	540002e9 	b.ls	4032ac <receive_state_machine+0x14c>  // b.plast
                LOG_ERR("Pkt length is %d but buffer has only %d bytes", rctx->rem_len,
  403254:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  403258:	52802300 	mov	w0, #0x118                 	// #280
  40325c:	b90003e0 	str	w0, [sp]
  403260:	52800022 	mov	w2, #0x1                   	// #1
  403264:	f9478821 	ldr	x1, [x1, #3856]
  403268:	52800000 	mov	w0, #0x0                   	// #0
  40326c:	90000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  403270:	52800005 	mov	w5, #0x0                   	// #0
  403274:	911f78c6 	add	x6, x6, #0x7de
  403278:	d2800004 	mov	x4, #0x0                   	// #0
  40327c:	d2800003 	mov	x3, #0x0                   	// #0
  403280:	97fffbb3 	bl	40214c <z_log_msg_runtime_create.constprop.0>
                receive_report_error(rctx, ISOTP_N_BUFFER_OVERFLW);
  403284:	f9401fe0 	ldr	x0, [sp, #56]
    rctx->state = ISOTP_RX_STATE_ERR;
  403288:	528e0002 	mov	w2, #0x7000                	// #28672
  40328c:	72bf0002 	movk	w2, #0xf800, lsl #16
  403290:	b9424801 	ldr	w1, [x0, #584]
  403294:	12005c21 	and	w1, w1, #0xffffff
  403298:	120c5c21 	and	w1, w1, #0xfff00fff
  40329c:	2a020021 	orr	w1, w1, w2
  4032a0:	b9024801 	str	w1, [x0, #584]
  4032a4:	17ffffdc 	b	403214 <receive_state_machine+0xb4>
                rctx->bs = rctx->ctx->opts->bs;
  4032a8:	39093401 	strb	w1, [x0, #589]
            rctx->wft = ISOTP_WFT_FIRST;
  4032ac:	12800001 	mov	w1, #0xffffffff            	// #-1
  4032b0:	39093001 	strb	w1, [x0, #588]
            rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  4032b4:	79449001 	ldrh	w1, [x0, #584]
  4032b8:	91092002 	add	x2, x0, #0x248
  4032bc:	12002c21 	and	w1, w1, #0xfff
  4032c0:	32140421 	orr	w1, w1, #0x3000
  4032c4:	79049001 	strh	w1, [x0, #584]
  4032c8:	aa0203e1 	mov	x1, x2
  4032cc:	39400842 	ldrb	w2, [x2, #2]
  4032d0:	121c6c42 	and	w2, w2, #0xfffffff0
  4032d4:	39000822 	strb	w2, [x1, #2]
            k_timer_stop(&rctx->timer);
  4032d8:	9100e000 	add	x0, x0, #0x38
  4032dc:	97fffb7b 	bl	4020c8 <k_timer_stop>
            rctx->state = ISOTP_RX_STATE_SEND_FC;
  4032e0:	f9401fe1 	ldr	x1, [sp, #56]
  4032e4:	79449020 	ldrh	w0, [x1, #584]
  4032e8:	12002c00 	and	w0, w0, #0xfff
  4032ec:	32120000 	orr	w0, w0, #0x4000
  4032f0:	79049020 	strh	w0, [x1, #584]
  4032f4:	39492820 	ldrb	w0, [x1, #586]
  4032f8:	121c6c00 	and	w0, w0, #0xfffffff0
  4032fc:	39092820 	strb	w0, [x1, #586]
            receive_send_fc(rctx, ISOTP_PCI_FS_CTS);
  403300:	f9401fe0 	ldr	x0, [sp, #56]
  403304:	52800001 	mov	w1, #0x0                   	// #0
  403308:	9400005c 	bl	403478 <receive_send_fc>
            k_timer_start(&rctx->timer, K_MSEC(ISOTP_CR_TIMEOUT_MS), K_NO_WAIT);
  40330c:	f9401fe0 	ldr	x0, [sp, #56]
  403310:	9100e000 	add	x0, x0, #0x38
	z_impl_k_timer_start(timer, duration, period);
  403314:	d2800c81 	mov	x1, #0x64                  	// #100
  403318:	d2800002 	mov	x2, #0x0                   	// #0
  40331c:	94003fd8 	bl	41327c <z_impl_k_timer_start>
            rctx->state = ISOTP_RX_STATE_WAIT_CF;
  403320:	f9401fe1 	ldr	x1, [sp, #56]
  403324:	528a0003 	mov	w3, #0x5000                	// #20480
  403328:	79449020 	ldrh	w0, [x1, #584]
  40332c:	12002c00 	and	w0, w0, #0xfff
  403330:	2a030000 	orr	w0, w0, w3
                rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  403334:	79049020 	strh	w0, [x1, #584]
  403338:	39492820 	ldrb	w0, [x1, #586]
  40333c:	121c6c00 	and	w0, w0, #0xfffffff0
  403340:	39092820 	strb	w0, [x1, #586]
                break;
  403344:	17ffffb5 	b	403218 <receive_state_machine+0xb8>
            if (++rctx->wft < CONFIG_ISOTP_WFTMAX) {
  403348:	39493007 	ldrb	w7, [x0, #588]
  40334c:	110004e7 	add	w7, w7, #0x1
  403350:	12001ce7 	and	w7, w7, #0xff
  403354:	39093007 	strb	w7, [x0, #588]
  403358:	710024ff 	cmp	w7, #0x9
  40335c:	540001a8 	b.hi	403390 <receive_state_machine+0x230>  // b.pmore
                receive_send_fc(rctx, ISOTP_PCI_FS_WAIT);
  403360:	52800021 	mov	w1, #0x1                   	// #1
  403364:	94000045 	bl	403478 <receive_send_fc>
                k_timer_start(&rctx->timer, K_MSEC(ISOTP_ALLOC_TIMEOUT_MS), K_NO_WAIT);
  403368:	f9401fe0 	ldr	x0, [sp, #56]
  40336c:	9100e000 	add	x0, x0, #0x38
  403370:	d2800b41 	mov	x1, #0x5a                  	// #90
  403374:	d2800002 	mov	x2, #0x0                   	// #0
  403378:	94003fc1 	bl	41327c <z_impl_k_timer_start>
                rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  40337c:	f9401fe1 	ldr	x1, [sp, #56]
  403380:	79449020 	ldrh	w0, [x1, #584]
  403384:	12002c00 	and	w0, w0, #0xfff
  403388:	32140400 	orr	w0, w0, #0x3000
  40338c:	17ffffea 	b	403334 <receive_state_machine+0x1d4>
            LOG_ERR("Sent %d wait frames. Giving up to alloc now", rctx->wft);
  403390:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  403394:	52800022 	mov	w2, #0x1                   	// #1
  403398:	52800000 	mov	w0, #0x0                   	// #0
  40339c:	90000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  4033a0:	f9478821 	ldr	x1, [x1, #3856]
  4033a4:	912030c6 	add	x6, x6, #0x80c
  4033a8:	52800005 	mov	w5, #0x0                   	// #0
  4033ac:	d2800004 	mov	x4, #0x0                   	// #0
  4033b0:	d2800003 	mov	x3, #0x0                   	// #0
  4033b4:	97fffb66 	bl	40214c <z_log_msg_runtime_create.constprop.0>
            receive_report_error(rctx, ISOTP_N_BUFFER_OVERFLW);
  4033b8:	f9401fe1 	ldr	x1, [sp, #56]
    rctx->state = ISOTP_RX_STATE_ERR;
  4033bc:	528e0002 	mov	w2, #0x7000                	// #28672
  4033c0:	72bf0002 	movk	w2, #0xf800, lsl #16
  4033c4:	b9424820 	ldr	w0, [x1, #584]
  4033c8:	12005c00 	and	w0, w0, #0xffffff
  4033cc:	120c5c00 	and	w0, w0, #0xfff00fff
  4033d0:	2a020000 	orr	w0, w0, w2
  4033d4:	b9024820 	str	w0, [x1, #584]
            k_timer_stop(&rctx->timer);
  4033d8:	f9401fe0 	ldr	x0, [sp, #56]
  4033dc:	9100e000 	add	x0, x0, #0x38
  4033e0:	97fffb3a 	bl	4020c8 <k_timer_stop>
            if (rctx->ctx->recv_error_callback) {
  4033e4:	f9401fe0 	ldr	x0, [sp, #56]
  4033e8:	f9400401 	ldr	x1, [x0, #8]
  4033ec:	f9401423 	ldr	x3, [x1, #40]
  4033f0:	b40000a3 	cbz	x3, 403404 <receive_state_machine+0x2a4>
                rctx->ctx->recv_error_callback(rctx->error, rctx->sender_addr,
  4033f4:	f9401022 	ldr	x2, [x1, #32]
  4033f8:	b9401001 	ldr	w1, [x0, #16]
  4033fc:	39492c00 	ldrb	w0, [x0, #587]
  403400:	d63f0060 	blr	x3
            if (rctx->error == ISOTP_N_BUFFER_OVERFLW) {
  403404:	f9401fe0 	ldr	x0, [sp, #56]
  403408:	39c92c01 	ldrsb	w1, [x0, #587]
  40340c:	3100203f 	cmn	w1, #0x8
  403410:	54000061 	b.ne	40341c <receive_state_machine+0x2bc>  // b.any
                receive_send_fc(rctx, ISOTP_PCI_FS_OVFLW);
  403414:	52800041 	mov	w1, #0x2                   	// #2
  403418:	94000018 	bl	403478 <receive_send_fc>
    if ((*rctx)->pending) {
  40341c:	f9401fe0 	ldr	x0, [sp, #56]
  403420:	39493c00 	ldrb	w0, [x0, #591]
  403424:	35000060 	cbnz	w0, 403430 <receive_state_machine+0x2d0>
    free_recv_ctx(rctx);
  403428:	9100e3e0 	add	x0, sp, #0x38
  40342c:	97fffbf0 	bl	4023ec <free_recv_ctx>
            rctx->state = ISOTP_RX_STATE_UNBOUND;
  403430:	f9401fe1 	ldr	x1, [sp, #56]
  403434:	128dffe3 	mov	w3, #0xffff9000            	// #-28672
  403438:	79449020 	ldrh	w0, [x1, #584]
  40343c:	12002c00 	and	w0, w0, #0xfff
  403440:	2a030000 	orr	w0, w0, w3
  403444:	79049020 	strh	w0, [x1, #584]
  403448:	39492820 	ldrb	w0, [x1, #586]
  40344c:	121c6c00 	and	w0, w0, #0xfffffff0
  403450:	39092820 	strb	w0, [x1, #586]
    if ((*rctx)->pending) {
  403454:	39493c20 	ldrb	w0, [x1, #591]
  403458:	35ffee00 	cbnz	w0, 403218 <receive_state_machine+0xb8>
    free_recv_ctx(rctx);
  40345c:	9100e3e0 	add	x0, sp, #0x38
  403460:	97fffbe3 	bl	4023ec <free_recv_ctx>
}
  403464:	17ffff6d 	b	403218 <receive_state_machine+0xb8>
  403468:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40346c:	f94013f3 	ldr	x19, [sp, #32]
  403470:	910143ff 	add	sp, sp, #0x50
  403474:	d65f03c0 	ret

0000000000403478 <receive_send_fc>:
{
  403478:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    *data++ = ISOTP_PCI_TYPE_FC | fs;
  40347c:	321c0421 	orr	w1, w1, #0x30
{
  403480:	910003fd 	mov	x29, sp
  403484:	f9000bf3 	str	x19, [sp, #16]
  403488:	aa0003f3 	mov	x19, x0
  40348c:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403490:	f9476800 	ldr	x0, [x0, #3792]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  403494:	f9400663 	ldr	x3, [x19, #8]
{
  403498:	f9400002 	ldr	x2, [x0]
  40349c:	f9001fe2 	str	x2, [sp, #56]
  4034a0:	d2800002 	mov	x2, #0x0                   	// #0
              | ((rctx->sender_addr & 0xFF) << 8)
  4034a4:	79402262 	ldrh	w2, [x19, #16]
        .id = (rctx->sender_addr & 0xFFFF0000) | ((rctx->sender_addr & 0xFF00) >> 8)
  4034a8:	b9401260 	ldr	w0, [x19, #16]
              | ((rctx->sender_addr & 0xFF) << 8)
  4034ac:	5ac00442 	rev16	w2, w2
    struct can_frame frame = {
  4034b0:	a902ffff 	stp	xzr, xzr, [sp, #40]
              | ((rctx->sender_addr & 0xFF) << 8)
  4034b4:	12003c42 	and	w2, w2, #0xffff
        .id = (rctx->sender_addr & 0xFFFF0000) | ((rctx->sender_addr & 0xFF00) >> 8)
  4034b8:	12103c00 	and	w0, w0, #0xffff0000
              | ((rctx->sender_addr & 0xFF) << 8)
  4034bc:	2a020000 	orr	w0, w0, w2
    struct can_frame frame = {
  4034c0:	52800002 	mov	w2, #0x0                   	// #0
  4034c4:	33007002 	bfxil	w2, w0, #0, #29
  4034c8:	b9002be2 	str	w2, [sp, #40]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  4034cc:	f9400862 	ldr	x2, [x3, #16]
  4034d0:	39400840 	ldrb	w0, [x2, #2]
    *data++ = ISOTP_PCI_TYPE_FC | fs;
  4034d4:	3900c3e1 	strb	w1, [sp, #48]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  4034d8:	d341fc00 	lsr	x0, x0, #1
  4034dc:	121e0000 	and	w0, w0, #0x4
  4034e0:	32000000 	orr	w0, w0, #0x1
    struct can_frame frame = {
  4034e4:	3900b7e0 	strb	w0, [sp, #45]
    *data++ = rctx->ctx->opts->bs;
  4034e8:	39400040 	ldrb	w0, [x2]
  4034ec:	3900c7e0 	strb	w0, [sp, #49]
    *data++ = rctx->ctx->opts->stmin;
  4034f0:	39400440 	ldrb	w0, [x2, #1]
  4034f4:	3900cbe0 	strb	w0, [sp, #50]
    frame.dlc = can_bytes_to_dlc(payload_len);
  4034f8:	52800060 	mov	w0, #0x3                   	// #3
  4034fc:	3900b3e0 	strb	w0, [sp, #44]
    ret = can_send(rctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), receive_can_tx, rctx);
  403500:	f9400060 	ldr	x0, [x3]
  403504:	f0ffffe3 	adrp	x3, 402000 <__floatunditf+0x60>
  403508:	aa1303e4 	mov	x4, x19
  40350c:	9109f063 	add	x3, x3, #0x27c
  403510:	9100a3e1 	add	x1, sp, #0x28
  403514:	d2800c82 	mov	x2, #0x64                  	// #100
  403518:	94002582 	bl	40cb20 <z_impl_can_send>
    if (ret) {
  40351c:	340002a0 	cbz	w0, 403570 <receive_send_fc+0xf8>
        LOG_ERR("Can't send FC, (%d)", ret);
  403520:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  403524:	2a0003e7 	mov	w7, w0
  403528:	90000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  40352c:	52800000 	mov	w0, #0x0                   	// #0
  403530:	f9478821 	ldr	x1, [x1, #3856]
  403534:	9120e0c6 	add	x6, x6, #0x838
  403538:	52800005 	mov	w5, #0x0                   	// #0
  40353c:	d2800004 	mov	x4, #0x0                   	// #0
  403540:	d2800003 	mov	x3, #0x0                   	// #0
  403544:	52800022 	mov	w2, #0x1                   	// #1
  403548:	97fffb01 	bl	40214c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  40354c:	b9424a60 	ldr	w0, [x19, #584]
  403550:	528e0001 	mov	w1, #0x7000                	// #28672
  403554:	72bfe001 	movk	w1, #0xff00, lsl #16
  403558:	12005c00 	and	w0, w0, #0xffffff
  40355c:	120c5c00 	and	w0, w0, #0xfff00fff
  403560:	2a010000 	orr	w0, w0, w1
  403564:	b9024a60 	str	w0, [x19, #584]
        receive_state_machine(rctx);
  403568:	aa1303e0 	mov	x0, x19
  40356c:	97fffefd 	bl	403160 <receive_state_machine>
}
  403570:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403574:	f9476800 	ldr	x0, [x0, #3792]
  403578:	f9401fe2 	ldr	x2, [sp, #56]
  40357c:	f9400001 	ldr	x1, [x0]
  403580:	eb010042 	subs	x2, x2, x1
  403584:	d2800001 	mov	x1, #0x0                   	// #0
  403588:	54000040 	b.eq	403590 <receive_send_fc+0x118>  // b.none
  40358c:	97fff765 	bl	401320 <__stack_chk_fail@plt>
  403590:	f9400bf3 	ldr	x19, [sp, #16]
  403594:	a8c47bfd 	ldp	x29, x30, [sp], #64
  403598:	d65f03c0 	ret

000000000040359c <receive_work_handler>:
    receive_state_machine(rctx);
  40359c:	d1006000 	sub	x0, x0, #0x18
  4035a0:	17fffef0 	b	403160 <receive_state_machine>

00000000004035a4 <isotp_fast_bind>:
int isotp_fast_bind(struct isotp_fast_ctx *ctx, const struct device *can_dev,
                    const isotp_fast_msg_id my_addr, const struct isotp_fast_opts *opts,
                    isotp_fast_recv_callback_t recv_callback, void *recv_cb_arg,
                    isotp_fast_recv_error_callback_t recv_error_callback,
                    isotp_fast_send_callback_t sent_callback)
{
  4035a4:	d10143ff 	sub	sp, sp, #0x50
  4035a8:	a9017bfd 	stp	x29, x30, [sp, #16]
  4035ac:	910043fd 	add	x29, sp, #0x10
  4035b0:	f90013f3 	str	x19, [sp, #32]
  4035b4:	aa0003f3 	mov	x19, x0
  4035b8:	aa0103e0 	mov	x0, x1
  4035bc:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4035c0:	f9476821 	ldr	x1, [x1, #3792]
  4035c4:	f9400028 	ldr	x8, [x1]
  4035c8:	f90027e8 	str	x8, [sp, #72]
  4035cc:	d2800008 	mov	x8, #0x0                   	// #0
	list->head = NULL;
  4035d0:	b0000141 	adrp	x1, 42c000 <__dso_handle>
  4035d4:	912be028 	add	x8, x1, #0xaf8
    sys_slist_init(&ctx->wait_recv_list);
#endif

    ctx->can_dev = can_dev;
    ctx->opts = opts;
    ctx->recv_callback = recv_callback;
  4035d8:	a9011263 	stp	x3, x4, [x19, #16]
  4035dc:	f9057c3f 	str	xzr, [x1, #2808]
  4035e0:	b0000141 	adrp	x1, 42c000 <__dso_handle>
	list->tail = NULL;
  4035e4:	f900051f 	str	xzr, [x8, #8]
	list->head = NULL;
  4035e8:	912ba028 	add	x8, x1, #0xae8
  4035ec:	f905743f 	str	xzr, [x1, #2792]
    filter->id = my_addr;
  4035f0:	f9401fe1 	ldr	x1, [sp, #56]
	list->tail = NULL;
  4035f4:	f900051f 	str	xzr, [x8, #8]
    ctx->can_dev = can_dev;
  4035f8:	f9000260 	str	x0, [x19]
    ctx->recv_cb_arg = recv_cb_arg;
    ctx->recv_error_callback = recv_error_callback;
  4035fc:	a9021a65 	stp	x5, x6, [x19, #32]
    filter->id = my_addr;
  403600:	92030821 	and	x1, x1, #0xe0000000e0000000
    ctx->sent_callback = sent_callback;
  403604:	f9001a67 	str	x7, [x19, #48]
    ctx->my_addr = my_addr;
  403608:	b9003a62 	str	w2, [x19, #56]
    filter->id = my_addr;
  40360c:	92407042 	and	x2, x2, #0x1fffffff
  403610:	b2584442 	orr	x2, x2, #0x3ffff0000000000
  403614:	aa010042 	orr	x2, x2, x1
                    | ((opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FILTER_FDF : 0);
  403618:	39400861 	ldrb	w1, [x3, #2]
    filter->id = my_addr;
  40361c:	f9001fe2 	str	x2, [sp, #56]
                    | ((opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FILTER_FDF : 0);
  403620:	528000a2 	mov	w2, #0x5                   	// #5
  403624:	121d0021 	and	w1, w1, #0x8
	return api->add_rx_filter(dev, callback, user_data, filter);
  403628:	9100e3e3 	add	x3, sp, #0x38
  40362c:	2a020021 	orr	w1, w1, w2
    filter->flags = CAN_FILTER_DATA | CAN_FILTER_IDE
  403630:	390103e1 	strb	w1, [sp, #64]
  403634:	f9400801 	ldr	x1, [x0, #16]
  403638:	aa1303e2 	mov	x2, x19
  40363c:	f9401824 	ldr	x4, [x1, #48]
  403640:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  403644:	91170021 	add	x1, x1, #0x5c0
  403648:	d63f0080 	blr	x4

    struct can_filter filter;
    prepare_filter(&filter, my_addr, opts);
    ctx->filter_id = can_add_rx_filter(ctx->can_dev, can_rx_callback, ctx, &filter);
  40364c:	b9000a60 	str	w0, [x19, #8]

    LOG_INF("Successfully bound to %x:%x", filter.id, filter.mask);
  403650:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  403654:	52800062 	mov	w2, #0x3                   	// #3
  403658:	f9401fe7 	ldr	x7, [sp, #56]
  40365c:	90000086 	adrp	x6, 413000 <z_impl_k_uptime_ticks>
  403660:	f9478821 	ldr	x1, [x1, #3856]
  403664:	912130c6 	add	x6, x6, #0x84c
  403668:	d360f0e0 	ubfx	x0, x7, #32, #29
  40366c:	b90003e0 	str	w0, [sp]
  403670:	120070e7 	and	w7, w7, #0x1fffffff
  403674:	52800000 	mov	w0, #0x0                   	// #0
  403678:	52800005 	mov	w5, #0x0                   	// #0
  40367c:	d2800004 	mov	x4, #0x0                   	// #0
  403680:	d2800003 	mov	x3, #0x0                   	// #0
  403684:	97fffab2 	bl	40214c <z_log_msg_runtime_create.constprop.0>

    return ISOTP_N_OK;
}
  403688:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40368c:	f9476800 	ldr	x0, [x0, #3792]
  403690:	f94027e2 	ldr	x2, [sp, #72]
  403694:	f9400001 	ldr	x1, [x0]
  403698:	eb010042 	subs	x2, x2, x1
  40369c:	d2800001 	mov	x1, #0x0                   	// #0
  4036a0:	54000040 	b.eq	4036a8 <isotp_fast_bind+0x104>  // b.none
  4036a4:	97fff71f 	bl	401320 <__stack_chk_fail@plt>
  4036a8:	52800000 	mov	w0, #0x0                   	// #0
  4036ac:	a9417bfd 	ldp	x29, x30, [sp, #16]
  4036b0:	f94013f3 	ldr	x19, [sp, #32]
  4036b4:	910143ff 	add	sp, sp, #0x50
  4036b8:	d65f03c0 	ret

00000000004036bc <isotp_fast_unbind>:
}
#endif

int isotp_fast_unbind(struct isotp_fast_ctx *ctx)
{
    if (ctx->filter_id >= 0 && ctx->can_dev) {
  4036bc:	b9400801 	ldr	w1, [x0, #8]
  4036c0:	37f80161 	tbnz	w1, #31, 4036ec <isotp_fast_unbind+0x30>
  4036c4:	f9400000 	ldr	x0, [x0]
  4036c8:	b4000120 	cbz	x0, 4036ec <isotp_fast_unbind+0x30>
{
  4036cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4036d0:	910003fd 	mov	x29, sp
	return api->remove_rx_filter(dev, filter_id);
  4036d4:	f9400802 	ldr	x2, [x0, #16]
  4036d8:	f9401c42 	ldr	x2, [x2, #56]
  4036dc:	d63f0040 	blr	x2
    {
        free_recv_await_ctx(ctx, &actx);
    }
#endif
    return ISOTP_N_OK;
}
  4036e0:	52800000 	mov	w0, #0x0                   	// #0
  4036e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4036e8:	d65f03c0 	ret
  4036ec:	52800000 	mov	w0, #0x0                   	// #0
  4036f0:	d65f03c0 	ret

00000000004036f4 <isotp_fast_send>:
}
#endif /* CONFIG_ISOTP_FAST_BLOCKING_RECEIVE */

int isotp_fast_send(struct isotp_fast_ctx *ctx, const uint8_t *data, size_t len,
                    const isotp_fast_node_id their_id, void *cb_arg)
{
  4036f4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    const isotp_fast_msg_id recipient_addr = (ctx->my_addr & 0xFFFF0000)
                                             | (isotp_fast_get_addr_recipient(ctx->my_addr))
                                             | (their_id << ISOTP_FIXED_ADDR_TA_POS);
  4036f8:	53181c63 	ubfiz	w3, w3, #8, #8
{
  4036fc:	910003fd 	mov	x29, sp
  403700:	a90363f7 	stp	x23, x24, [sp, #48]
  403704:	aa0403f7 	mov	x23, x4
  403708:	90000144 	adrp	x4, 42b000 <__FRAME_END__+0xff4c>
  40370c:	a90153f3 	stp	x19, x20, [sp, #16]
  403710:	aa0203f3 	mov	x19, x2
  403714:	f9476884 	ldr	x4, [x4, #3792]
  403718:	a9025bf5 	stp	x21, x22, [sp, #32]
  40371c:	f90023f9 	str	x25, [sp, #64]
  403720:	aa0003f9 	mov	x25, x0
  403724:	f9400085 	ldr	x5, [x4]
  403728:	f90037e5 	str	x5, [sp, #104]
  40372c:	d2800005 	mov	x5, #0x0                   	// #0
    const isotp_fast_msg_id recipient_addr = (ctx->my_addr & 0xFFFF0000)
  403730:	b9403804 	ldr	w4, [x0, #56]
  403734:	12103c96 	and	w22, w4, #0xffff0000
  403738:	2a0302d6 	orr	w22, w22, w3
  40373c:	d3483c84 	ubfx	x4, x4, #8, #8
  403740:	2a0402d6 	orr	w22, w22, w4
    if (len <= (CAN_MAX_DLEN - ISOTP_FAST_SF_LEN_BYTE)) {
  403744:	f1001c5f 	cmp	x2, #0x7
  403748:	540004a8 	b.hi	4037dc <isotp_fast_send+0xe8>  // b.pmore
        struct can_frame frame = {
  40374c:	52800000 	mov	w0, #0x0                   	// #0
            .dlc = can_bytes_to_dlc(len + ISOTP_FAST_SF_LEN_BYTE),
  403750:	12001c53 	and	w19, w2, #0xff
        struct can_frame frame = {
  403754:	330072c0 	bfxil	w0, w22, #0, #29
  403758:	a905ffff 	stp	xzr, xzr, [sp, #88]
  40375c:	b9005be0 	str	w0, [sp, #88]
            .dlc = can_bytes_to_dlc(len + ISOTP_FAST_SF_LEN_BYTE),
  403760:	11000660 	add	w0, w19, #0x1
  403764:	97fffa79 	bl	402148 <can_bytes_to_dlc>
        struct can_frame frame = {
  403768:	390173e0 	strb	w0, [sp, #92]
            .id = recipient_addr,
            .flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  40376c:	f9400b20 	ldr	x0, [x25, #16]
  403770:	39400803 	ldrb	w3, [x0, #2]
  403774:	910187e0 	add	x0, sp, #0x61
        }
        else {
            frame.data[0] = (uint8_t)len;
        }
#else
        frame.data[0] = (uint8_t)len;
  403778:	390183f3 	strb	w19, [sp, #96]
            .flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  40377c:	d341fc63 	lsr	x3, x3, #1
  403780:	121e0063 	and	w3, w3, #0x4
  403784:	32000063 	orr	w3, w3, #0x1
        struct can_frame frame = {
  403788:	390177e3 	strb	w3, [sp, #93]
  40378c:	d28000e3 	mov	x3, #0x7                   	// #7
  403790:	97fff6b0 	bl	401250 <__memcpy_chk@plt>
#endif
        memcpy(&frame.data[index], data, len);
        int ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), NULL, NULL);
  403794:	f9400320 	ldr	x0, [x25]
  403798:	d2800c82 	mov	x2, #0x64                  	// #100
  40379c:	910163e1 	add	x1, sp, #0x58
  4037a0:	d2800004 	mov	x4, #0x0                   	// #0
  4037a4:	d2800003 	mov	x3, #0x0                   	// #0
  4037a8:	940024de 	bl	40cb20 <z_impl_can_send>
        ctx->sent_callback(ret, cb_arg);
        return ISOTP_N_OK;
  4037ac:	52800015 	mov	w21, #0x0                   	// #0
        ctx->sent_callback(ret, cb_arg);
  4037b0:	f9401b22 	ldr	x2, [x25, #48]
  4037b4:	aa1703e1 	mov	x1, x23
  4037b8:	d63f0040 	blr	x2
        k_timer_init(&context->timer, send_timeout_handler, NULL);

        k_work_submit(&context->work);
    }
    return ISOTP_N_OK;
  4037bc:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4037c0:	f9476800 	ldr	x0, [x0, #3792]
  4037c4:	f94037e2 	ldr	x2, [sp, #104]
  4037c8:	f9400001 	ldr	x1, [x0]
  4037cc:	eb010042 	subs	x2, x2, x1
  4037d0:	d2800001 	mov	x1, #0x0                   	// #0
  4037d4:	54000640 	b.eq	40389c <isotp_fast_send+0x1a8>  // b.none
  4037d8:	97fff6d2 	bl	401320 <__stack_chk_fail@plt>
        if (len > ISOTP_FAST_MAX_LEN) {
  4037dc:	f13ffc5f 	cmp	x2, #0xfff
  4037e0:	54000568 	b.hi	40388c <isotp_fast_send+0x198>  // b.pmore
  4037e4:	aa0103f8 	mov	x24, x1
        int ret = get_send_ctx(ctx, recipient_addr, &context);
  4037e8:	910143e2 	add	x2, sp, #0x50
  4037ec:	2a1603e1 	mov	w1, w22
  4037f0:	97fffb2a 	bl	402498 <get_send_ctx>
  4037f4:	2a0003f5 	mov	w21, w0
        if (ret) {
  4037f8:	350004e0 	cbnz	w0, 403894 <isotp_fast_send+0x1a0>
        context->ctx = ctx;
  4037fc:	f9402bf4 	ldr	x20, [sp, #80]
        context->state = ISOTP_TX_SEND_FF;
  403800:	12002e73 	and	w19, w19, #0xfff
  403804:	32130273 	orr	w19, w19, #0x2000
        context->ctx = ctx;
  403808:	f9000699 	str	x25, [x20, #8]
        context->recipient_addr = recipient_addr;
  40380c:	b9001296 	str	w22, [x20, #16]
        context->data = data;
  403810:	f9005e98 	str	x24, [x20, #184]
        context->bs = ctx->opts->bs;
  403814:	f9400b20 	ldr	x0, [x25, #16]
  403818:	39400000 	ldrb	w0, [x0]
  40381c:	39034680 	strb	w0, [x20, #209]
        context->stmin = ctx->opts->stmin;
  403820:	f9400b20 	ldr	x0, [x25, #16]
  403824:	39400400 	ldrb	w0, [x0, #1]
  403828:	39035280 	strb	w0, [x20, #212]
        context->rem_len = len;
  40382c:	aa1403e0 	mov	x0, x20
  403830:	784c0c01 	ldrh	w1, [x0, #192]!
        context->state = ISOTP_TX_SEND_FF;
  403834:	79018293 	strh	w19, [x20, #192]
  403838:	39400801 	ldrb	w1, [x0, #2]
  40383c:	121c6c21 	and	w1, w1, #0xfffffff0
  403840:	39000801 	strb	w1, [x0, #2]
        context->cb_arg = cb_arg;
  403844:	f9006697 	str	x23, [x20, #200]
	return z_impl_k_sem_init(sem, initial_count, limit);
  403848:	52800022 	mov	w2, #0x1                   	// #1
        k_work_init(&context->work, send_work_handler);
  40384c:	91006293 	add	x19, x20, #0x18
  403850:	91024280 	add	x0, x20, #0x90
  403854:	52800001 	mov	w1, #0x0                   	// #0
  403858:	94002f8c 	bl	40f688 <z_impl_k_sem_init>
  40385c:	aa1303e0 	mov	x0, x19
  403860:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  403864:	91348021 	add	x1, x1, #0xd20
  403868:	94003188 	bl	40fe88 <k_work_init>
        k_timer_init(&context->timer, send_timeout_handler, NULL);
  40386c:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  403870:	91082021 	add	x1, x1, #0x208
  403874:	d2800002 	mov	x2, #0x0                   	// #0
  403878:	9100e280 	add	x0, x20, #0x38
  40387c:	94003e79 	bl	413260 <k_timer_init>
        k_work_submit(&context->work);
  403880:	aa1303e0 	mov	x0, x19
  403884:	9400320e 	bl	4100bc <k_work_submit>
    return ISOTP_N_OK;
  403888:	17ffffcd 	b	4037bc <isotp_fast_send+0xc8>
            return ISOTP_N_BUFFER_OVERFLW;
  40388c:	128000f5 	mov	w21, #0xfffffff8            	// #-8
  403890:	17ffffcb 	b	4037bc <isotp_fast_send+0xc8>
            return ISOTP_NO_NET_BUF_LEFT;
  403894:	12800155 	mov	w21, #0xfffffff5            	// #-11
  403898:	17ffffc9 	b	4037bc <isotp_fast_send+0xc8>
  40389c:	2a1503e0 	mov	w0, w21
  4038a0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4038a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4038a8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4038ac:	f94023f9 	ldr	x25, [sp, #64]
  4038b0:	a8c77bfd 	ldp	x29, x30, [sp], #112
  4038b4:	d65f03c0 	ret

00000000004038b8 <isotp_fast_recv_error_handler>:
}

void isotp_fast_recv_error_handler(int8_t error, isotp_fast_msg_id sender_addr, void *arg)
{
    // printk("Error %d received\n", error);
    recv_last_error = error;
  4038b8:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4038bc:	f9474821 	ldr	x1, [x1, #3728]
  4038c0:	39000020 	strb	w0, [x1]
	z_impl_k_msgq_purge(msgq);
  4038c4:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4038c8:	f9479000 	ldr	x0, [x0, #3872]
  4038cc:	14002d0e 	b	40ed04 <z_impl_k_msgq_purge>

00000000004038d0 <k_msgq_get>:
	return z_impl_k_msgq_get(msgq, data, timeout);
  4038d0:	14002c60 	b	40ea50 <z_impl_k_msgq_get>

00000000004038d4 <blocking_recv>:
{
  4038d4:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  4038d8:	910003fd 	mov	x29, sp
  4038dc:	a9025bf5 	stp	x21, x22, [sp, #32]
  4038e0:	aa0003f6 	mov	x22, x0
  4038e4:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4038e8:	90000155 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
  4038ec:	a9046bf9 	stp	x25, x26, [sp, #64]
    while ((ret = k_msgq_get(&recv_msgq, &msg, timeout)) == 0) {
  4038f0:	90000159 	adrp	x25, 42b000 <__FRAME_END__+0xff4c>
{
  4038f4:	f9476800 	ldr	x0, [x0, #3792]
  4038f8:	a90153f3 	stp	x19, x20, [sp, #16]
  4038fc:	aa0203fa 	mov	x26, x2
  403900:	a90363f7 	stp	x23, x24, [sp, #48]
  403904:	aa0103f8 	mov	x24, x1
    int rx_len = 0;
  403908:	52800013 	mov	w19, #0x0                   	// #0
{
  40390c:	a90573fb 	stp	x27, x28, [sp, #80]
    while ((ret = k_msgq_get(&recv_msgq, &msg, timeout)) == 0) {
  403910:	9101a3fc 	add	x28, sp, #0x68
  403914:	f9479339 	ldr	x25, [x25, #3872]
{
  403918:	f9400001 	ldr	x1, [x0]
  40391c:	f9003fe1 	str	x1, [sp, #120]
  403920:	d2800001 	mov	x1, #0x0                   	// #0
        if (recv_last_error != 0) {
  403924:	f9474abb 	ldr	x27, [x21, #3728]
    while ((ret = k_msgq_get(&recv_msgq, &msg, timeout)) == 0) {
  403928:	aa1a03e2 	mov	x2, x26
  40392c:	aa1c03e1 	mov	x1, x28
  403930:	aa1903e0 	mov	x0, x25
  403934:	97ffffe7 	bl	4038d0 <k_msgq_get>
  403938:	2a0003f7 	mov	w23, w0
  40393c:	35000400 	cbnz	w0, 4039bc <blocking_recv+0xe8>
        if (recv_last_error != 0) {
  403940:	39c00360 	ldrsb	w0, [x27]
  403944:	34000160 	cbz	w0, 403970 <blocking_recv+0x9c>
            ret = recv_last_error;
  403948:	2a0003f3 	mov	w19, w0
            recv_last_error = 0;
  40394c:	3900037f 	strb	wzr, [x27]
}
  403950:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403954:	f9476800 	ldr	x0, [x0, #3792]
  403958:	f9403fe2 	ldr	x2, [sp, #120]
  40395c:	f9400001 	ldr	x1, [x0]
  403960:	eb010042 	subs	x2, x2, x1
  403964:	d2800001 	mov	x1, #0x0                   	// #0
  403968:	540003e0 	b.eq	4039e4 <blocking_recv+0x110>  // b.none
  40396c:	97fff66d 	bl	401320 <__stack_chk_fail@plt>
        if (msg.len < 0) {
  403970:	79c0e3e0 	ldrsh	w0, [sp, #112]
  403974:	36f80060 	tbz	w0, #31, 403980 <blocking_recv+0xac>
            return msg.len;
  403978:	2a0003f3 	mov	w19, w0
  40397c:	17fffff5 	b	403950 <blocking_recv+0x7c>
        int cp_len = MIN(msg.len, size - rx_len);
  403980:	cb33c314 	sub	x20, x24, w19, sxtw
  403984:	93403c01 	sxth	x1, w0
  403988:	eb20a29f 	cmp	x20, w0, sxth
  40398c:	aa1603e0 	mov	x0, x22
  403990:	9a819294 	csel	x20, x20, x1, ls  // ls = plast
  403994:	aa1c03e1 	mov	x1, x28
  403998:	aa1403e2 	mov	x2, x20
        rx_len += cp_len;
  40399c:	0b140273 	add	w19, w19, w20
  4039a0:	97fff5f4 	bl	401170 <memcpy@plt>
        buf += cp_len;
  4039a4:	8b1402d6 	add	x22, x22, x20
        if (msg.rem_len > (size - rx_len)) {
  4039a8:	b94077e0 	ldr	w0, [sp, #116]
  4039ac:	cb33c301 	sub	x1, x24, w19, sxtw
  4039b0:	eb20c03f 	cmp	x1, w0, sxtw
  4039b4:	54000043 	b.cc	4039bc <blocking_recv+0xe8>  // b.lo, b.ul, b.last
        if (msg.rem_len == 0) {
  4039b8:	35fffb80 	cbnz	w0, 403928 <blocking_recv+0x54>
    if (recv_last_error != 0) {
  4039bc:	f9474ab5 	ldr	x21, [x21, #3728]
  4039c0:	39c002a0 	ldrsb	w0, [x21]
  4039c4:	34000080 	cbz	w0, 4039d4 <blocking_recv+0x100>
        ret = recv_last_error;
  4039c8:	2a0003f3 	mov	w19, w0
        recv_last_error = 0;
  4039cc:	390002bf 	strb	wzr, [x21]
        return ret;
  4039d0:	17ffffe0 	b	403950 <blocking_recv+0x7c>
        return ISOTP_RECV_TIMEOUT;
  4039d4:	31002eff 	cmn	w23, #0xb
  4039d8:	128001a0 	mov	w0, #0xfffffff2            	// #-14
  4039dc:	1a801273 	csel	w19, w19, w0, ne  // ne = any
  4039e0:	17ffffdc 	b	403950 <blocking_recv+0x7c>
}
  4039e4:	2a1303e0 	mov	w0, w19
  4039e8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4039ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4039f0:	a94363f7 	ldp	x23, x24, [sp, #48]
  4039f4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4039f8:	a94573fb 	ldp	x27, x28, [sp, #80]
  4039fc:	a8c87bfd 	ldp	x29, x30, [sp], #128
  403a00:	d65f03c0 	ret

0000000000403a04 <k_uptime_get>:
 *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option.
 *
 * @return Current uptime in milliseconds.
 */
static inline int64_t k_uptime_get(void)
{
  403a04:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  403a08:	910003fd 	mov	x29, sp
	return z_impl_k_uptime_ticks();
  403a0c:	94003d7d 	bl	413000 <z_impl_k_uptime_ticks>
	return k_ticks_to_ms_floor64(k_uptime_ticks());
}
  403a10:	d2800141 	mov	x1, #0xa                   	// #10
  403a14:	a8c17bfd 	ldp	x29, x30, [sp], #16
  403a18:	9b017c00 	mul	x0, x0, x1
  403a1c:	d65f03c0 	ret

0000000000403a20 <can_bytes_to_dlc>:
{
  403a20:	12001c00 	and	w0, w0, #0xff
	return num_bytes <= 8  ? num_bytes :
  403a24:	7100201f 	cmp	w0, #0x8
  403a28:	540001c9 	b.ls	403a60 <can_bytes_to_dlc+0x40>  // b.plast
  403a2c:	7100301f 	cmp	w0, #0xc
  403a30:	540001a9 	b.ls	403a64 <can_bytes_to_dlc+0x44>  // b.plast
  403a34:	7100401f 	cmp	w0, #0x10
  403a38:	540001a9 	b.ls	403a6c <can_bytes_to_dlc+0x4c>  // b.plast
  403a3c:	7100501f 	cmp	w0, #0x14
  403a40:	540001a9 	b.ls	403a74 <can_bytes_to_dlc+0x54>  // b.plast
  403a44:	7100601f 	cmp	w0, #0x18
  403a48:	540001a9 	b.ls	403a7c <can_bytes_to_dlc+0x5c>  // b.plast
  403a4c:	7100801f 	cmp	w0, #0x20
  403a50:	540001a9 	b.ls	403a84 <can_bytes_to_dlc+0x64>  // b.plast
  403a54:	7100c01f 	cmp	w0, #0x30
  403a58:	1a9f97e0 	cset	w0, hi  // hi = pmore
  403a5c:	11003800 	add	w0, w0, #0xe
}
  403a60:	d65f03c0 	ret
	return num_bytes <= 8  ? num_bytes :
  403a64:	52800120 	mov	w0, #0x9                   	// #9
  403a68:	17fffffe 	b	403a60 <can_bytes_to_dlc+0x40>
  403a6c:	52800140 	mov	w0, #0xa                   	// #10
  403a70:	17fffffc 	b	403a60 <can_bytes_to_dlc+0x40>
  403a74:	52800160 	mov	w0, #0xb                   	// #11
  403a78:	17fffffa 	b	403a60 <can_bytes_to_dlc+0x40>
  403a7c:	52800180 	mov	w0, #0xc                   	// #12
  403a80:	17fffff8 	b	403a60 <can_bytes_to_dlc+0x40>
  403a84:	528001a0 	mov	w0, #0xd                   	// #13
  403a88:	17fffff6 	b	403a60 <can_bytes_to_dlc+0x40>

0000000000403a8c <prepare_cf_frames.constprop.0>:
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);

    return filter_id;
}

static void prepare_cf_frames(struct frame_desired *frames, size_t frames_cnt, const uint8_t *data,
  403a8c:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
                              size_t data_len)
{
    int i;
    const uint8_t *data_ptr = data;
  403a90:	b0000082 	adrp	x2, 414000 <dlc_table.0+0x78d>
  403a94:	910d7042 	add	x2, x2, #0x35c
static void prepare_cf_frames(struct frame_desired *frames, size_t frames_cnt, const uint8_t *data,
  403a98:	d2800023 	mov	x3, #0x1                   	// #1
  403a9c:	f947bc21 	ldr	x1, [x1, #3960]
    const uint8_t *data_ptr = data;
  403aa0:	91001842 	add	x2, x2, #0x6
    size_t remaining_length = data_len;

    for (i = 0; i < frames_cnt && remaining_length; i++) {
        frames[i].data[0] = CF_PCI_BYTE_1 | ((i + 1) & 0x0F);
        frames[i].length = CAN_DL;
  403aa4:	52800105 	mov	w5, #0x8                   	// #8
        frames[i].data[0] = CF_PCI_BYTE_1 | ((i + 1) & 0x0F);
  403aa8:	12000c64 	and	w4, w3, #0xf
        frames[i].length = CAN_DL;
  403aac:	39002025 	strb	w5, [x1, #8]
        frames[i].data[0] = CF_PCI_BYTE_1 | ((i + 1) & 0x0F);
  403ab0:	321b0084 	orr	w4, w4, #0x20
  403ab4:	39000024 	strb	w4, [x1]
  403ab8:	b9400044 	ldr	w4, [x2]
  403abc:	b8001024 	stur	w4, [x1, #1]
  403ac0:	b8403044 	ldur	w4, [x2, #3]
  403ac4:	b9000424 	str	w4, [x1, #4]
        memcpy(&des_frames[i].data[1], data_ptr, DATA_SIZE_CF);

        if (remaining_length < DATA_SIZE_CF) {
  403ac8:	f100181f 	cmp	x0, #0x6
  403acc:	54000088 	b.hi	403adc <prepare_cf_frames.constprop.0+0x50>  // b.pmore
            frames[i].length = remaining_length + 1;
  403ad0:	11000400 	add	w0, w0, #0x1
  403ad4:	39002020 	strb	w0, [x1, #8]
            remaining_length = 0;
  403ad8:	d2800000 	mov	x0, #0x0                   	// #0
        }

        remaining_length -= DATA_SIZE_CF;
  403adc:	91000463 	add	x3, x3, #0x1
  403ae0:	d1001c00 	sub	x0, x0, #0x7
        data_ptr += DATA_SIZE_CF;
  403ae4:	91001c42 	add	x2, x2, #0x7
    for (i = 0; i < frames_cnt && remaining_length; i++) {
  403ae8:	91002421 	add	x1, x1, #0x9
  403aec:	f1009c7f 	cmp	x3, #0x27
  403af0:	54000040 	b.eq	403af8 <prepare_cf_frames.constprop.0+0x6c>  // b.none
  403af4:	b5fffda0 	cbnz	x0, 403aa8 <prepare_cf_frames.constprop.0+0x1c>
    }
}
  403af8:	d65f03c0 	ret

0000000000403afc <z_zassert.constprop.0>:

#define z_zexpect(cond, default_msg, file, line, func, msg, ...) z_zexpect_(cond, file, line)

#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  403afc:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  403b00:	910003fd 	mov	x29, sp
  403b04:	a9025bf5 	stp	x21, x22, [sp, #32]
  403b08:	aa0103f6 	mov	x22, x1
  403b0c:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  403b10:	a90153f3 	stp	x19, x20, [sp, #16]
  403b14:	f9476821 	ldr	x1, [x1, #3792]
  403b18:	f9001bf7 	str	x23, [sp, #48]
  403b1c:	3d8027e0 	str	q0, [sp, #144]
			     const char *func, const char *msg, ...)
{
	if (cond == false) {
  403b20:	72001c17 	ands	w23, w0, #0xff
static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  403b24:	3d802be1 	str	q1, [sp, #160]
  403b28:	3d802fe2 	str	q2, [sp, #176]
  403b2c:	3d8033e3 	str	q3, [sp, #192]
  403b30:	3d8037e4 	str	q4, [sp, #208]
  403b34:	3d803be5 	str	q5, [sp, #224]
  403b38:	3d803fe6 	str	q6, [sp, #240]
  403b3c:	3d8043e7 	str	q7, [sp, #256]
  403b40:	a9111fe6 	stp	x6, x7, [sp, #272]
  403b44:	f9400022 	ldr	x2, [x1]
  403b48:	f90047e2 	str	x2, [sp, #136]
  403b4c:	d2800002 	mov	x2, #0x0                   	// #0
	if (cond == false) {
  403b50:	54000401 	b.ne	403bd0 <z_zassert.constprop.0+0xd4>  // b.any
		va_list vargs;

		va_start(vargs, msg);
  403b54:	910483e0 	add	x0, sp, #0x120
  403b58:	a90683e0 	stp	x0, x0, [sp, #104]
  403b5c:	910443e0 	add	x0, sp, #0x110
  403b60:	f9003fe0 	str	x0, [sp, #120]
  403b64:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  403b68:	b90083e0 	str	w0, [sp, #128]
  403b6c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  403b70:	aa0503f3 	mov	x19, x5
  403b74:	2a0303f4 	mov	w20, w3
  403b78:	aa0403f5 	mov	x21, x4
  403b7c:	b90087e0 	str	w0, [sp, #132]
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n", ztest_relative_filename(file),
  403b80:	90000080 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  403b84:	91220c00 	add	x0, x0, #0x883
  403b88:	94002147 	bl	40c0a4 <ztest_relative_filename>
  403b8c:	aa0003e1 	mov	x1, x0
  403b90:	aa1603e4 	mov	x4, x22
  403b94:	aa1503e3 	mov	x3, x21
  403b98:	2a1403e2 	mov	w2, w20
  403b9c:	90000080 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  403ba0:	9123ac00 	add	x0, x0, #0x8eb
  403ba4:	94000a3e 	bl	40649c <printk>
		      line, func, default_msg);
		vprintk(msg, vargs);
  403ba8:	9101a3e0 	add	x0, sp, #0x68
  403bac:	910103e1 	add	x1, sp, #0x40
  403bb0:	ad400400 	ldp	q0, q1, [x0]
  403bb4:	aa1303e0 	mov	x0, x19
  403bb8:	ad000420 	stp	q0, q1, [x1]
  403bbc:	94000a2f 	bl	406478 <vprintk>
		printk("\n");
  403bc0:	d0000080 	adrp	x0, 415000 <random_data+0xca4>
  403bc4:	9135a800 	add	x0, x0, #0xd6a
  403bc8:	94000a35 	bl	40649c <printk>
		va_end(vargs);
		ztest_test_fail();
  403bcc:	94001e15 	bl	40b420 <ztest_test_fail>
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n", ztest_relative_filename(file),
		      line, func);
	}
#endif
	return true;
}
  403bd0:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403bd4:	f9476800 	ldr	x0, [x0, #3792]
  403bd8:	f94047e2 	ldr	x2, [sp, #136]
  403bdc:	f9400001 	ldr	x1, [x0]
  403be0:	eb010042 	subs	x2, x2, x1
  403be4:	d2800001 	mov	x1, #0x0                   	// #0
  403be8:	54000040 	b.eq	403bf0 <z_zassert.constprop.0+0xf4>  // b.none
  403bec:	97fff5cd 	bl	401320 <__stack_chk_fail@plt>
  403bf0:	2a1703e0 	mov	w0, w23
  403bf4:	a94153f3 	ldp	x19, x20, [sp, #16]
  403bf8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403bfc:	f9401bf7 	ldr	x23, [sp, #48]
  403c00:	a8d27bfd 	ldp	x29, x30, [sp], #288
  403c04:	d65f03c0 	ret

0000000000403c08 <get_sf_ignore.constprop.0>:
static void get_sf_ignore(struct isotp_fast_ctx *recv_ctx)
  403c08:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403c0c:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403c10:	d2800282 	mov	x2, #0x14                  	// #20
static void get_sf_ignore(struct isotp_fast_ctx *recv_ctx)
  403c14:	910003fd 	mov	x29, sp
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403c18:	f9471000 	ldr	x0, [x0, #3616]
  403c1c:	d2801001 	mov	x1, #0x80                  	// #128
  403c20:	97ffff2d 	bl	4038d4 <blocking_recv>
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "recv returned %d", ret);
  403c24:	3100381f 	cmn	w0, #0xe
}
  403c28:	a8c17bfd 	ldp	x29, x30, [sp], #16
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403c2c:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "recv returned %d", ret);
  403c30:	90000085 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  403c34:	1a9f17e0 	cset	w0, eq  // eq = none
  403c38:	91244ca5 	add	x5, x5, #0x913
  403c3c:	b0000084 	adrp	x4, 414000 <dlc_table.0+0x78d>
  403c40:	528008e3 	mov	w3, #0x47                  	// #71
  403c44:	91052c84 	add	x4, x4, #0x14b
  403c48:	90000082 	adrp	x2, 413000 <z_impl_k_uptime_ticks>
  403c4c:	90000081 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  403c50:	91220c42 	add	x2, x2, #0x883
  403c54:	91249021 	add	x1, x1, #0x924
  403c58:	17ffffa9 	b	403afc <z_zassert.constprop.0>

0000000000403c5c <send_test_data.constprop.0>:
static void send_test_data(const uint8_t *data, size_t len)
  403c5c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403c60:	aa0003e2 	mov	x2, x0
  403c64:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
static void send_test_data(const uint8_t *data, size_t len)
  403c68:	910003fd 	mov	x29, sp
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403c6c:	f9470c00 	ldr	x0, [x0, #3608]
  403c70:	d2800004 	mov	x4, #0x0                   	// #0
  403c74:	52800023 	mov	w3, #0x1                   	// #1
  403c78:	b0000081 	adrp	x1, 414000 <dlc_table.0+0x78d>
  403c7c:	910d7021 	add	x1, x1, #0x35c
  403c80:	97fffe9d 	bl	4036f4 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  403c84:	7100001f 	cmp	w0, #0x0
}
  403c88:	a8c17bfd 	ldp	x29, x30, [sp], #16
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403c8c:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  403c90:	90000085 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  403c94:	1a9f17e0 	cset	w0, eq  // eq = none
  403c98:	912528a5 	add	x5, x5, #0x94a
  403c9c:	b0000084 	adrp	x4, 414000 <dlc_table.0+0x78d>
  403ca0:	528009e3 	mov	w3, #0x4f                  	// #79
  403ca4:	91038084 	add	x4, x4, #0xe0
  403ca8:	90000082 	adrp	x2, 413000 <z_impl_k_uptime_ticks>
  403cac:	90000081 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  403cb0:	91220c42 	add	x2, x2, #0x883
  403cb4:	91256c21 	add	x1, x1, #0x95b
  403cb8:	17ffff91 	b	403afc <z_zassert.constprop.0>

0000000000403cbc <add_rx_msgq.constprop.0>:
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403cbc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  403cc0:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403cc4:	92407000 	and	x0, x0, #0x1fffffff
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403cc8:	910003fd 	mov	x29, sp
  403ccc:	f9476821 	ldr	x1, [x1, #3792]
  403cd0:	a90153f3 	stp	x19, x20, [sp, #16]
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403cd4:	b2607000 	orr	x0, x0, #0x1fffffff00000000
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403cd8:	f90013f5 	str	x21, [sp, #32]
  403cdc:	f9400022 	ldr	x2, [x1]
  403ce0:	f90027e2 	str	x2, [sp, #72]
  403ce4:	d2800002 	mov	x2, #0x0                   	// #0
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403ce8:	b90043ff 	str	wzr, [sp, #64]
  403cec:	f9001fe0 	str	x0, [sp, #56]
  403cf0:	528000a0 	mov	w0, #0x5                   	// #5
  403cf4:	390103e0 	strb	w0, [sp, #64]
		union { uintptr_t x; const struct can_filter * val; } parm2 = { .val = filter };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_CAN_ADD_RX_FILTER_MSGQ);
	}
#endif
	compiler_barrier();
	return z_impl_can_add_rx_filter_msgq(dev, msgq, filter);
  403cf8:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  403cfc:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403d00:	9100e3e2 	add	x2, sp, #0x38
    zassert_not_equal(filter_id, -ENOSPC, "Filter full");
  403d04:	b0000095 	adrp	x21, 414000 <dlc_table.0+0x78d>
  403d08:	f947e021 	ldr	x1, [x1, #4032]
  403d0c:	910636b5 	add	x21, x21, #0x18d
  403d10:	f9472000 	ldr	x0, [x0, #3648]
  403d14:	90000094 	adrp	x20, 413000 <z_impl_k_uptime_ticks>
  403d18:	91220e94 	add	x20, x20, #0x883
  403d1c:	940023bc 	bl	40cc0c <z_impl_can_add_rx_filter_msgq>
  403d20:	3100701f 	cmn	w0, #0x1c
  403d24:	2a0003f3 	mov	w19, w0
  403d28:	aa1503e4 	mov	x4, x21
  403d2c:	1a9f07e0 	cset	w0, ne  // ne = any
  403d30:	aa1403e2 	mov	x2, x20
  403d34:	52801563 	mov	w3, #0xab                  	// #171
  403d38:	90000085 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  403d3c:	90000081 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  403d40:	9125c0a5 	add	x5, x5, #0x970
  403d44:	9125f021 	add	x1, x1, #0x97c
  403d48:	97ffff6d 	bl	403afc <z_zassert.constprop.0>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  403d4c:	2a3303e0 	mvn	w0, w19
  403d50:	aa1403e2 	mov	x2, x20
  403d54:	2a1303e6 	mov	w6, w19
  403d58:	aa1503e4 	mov	x4, x21
  403d5c:	531f7c00 	lsr	w0, w0, #31
  403d60:	90000085 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  403d64:	52801583 	mov	w3, #0xac                  	// #172
  403d68:	912664a5 	add	x5, x5, #0x999
  403d6c:	90000081 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  403d70:	9126d421 	add	x1, x1, #0x9b5
  403d74:	97ffff62 	bl	403afc <z_zassert.constprop.0>
}
  403d78:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403d7c:	f9476800 	ldr	x0, [x0, #3792]
  403d80:	f94027e2 	ldr	x2, [sp, #72]
  403d84:	f9400001 	ldr	x1, [x0]
  403d88:	eb010042 	subs	x2, x2, x1
  403d8c:	d2800001 	mov	x1, #0x0                   	// #0
  403d90:	54000040 	b.eq	403d98 <add_rx_msgq.constprop.0+0xdc>  // b.none
  403d94:	97fff563 	bl	401320 <__stack_chk_fail@plt>
  403d98:	2a1303e0 	mov	w0, w19
  403d9c:	a94153f3 	ldp	x19, x20, [sp, #16]
  403da0:	f94013f5 	ldr	x21, [sp, #32]
  403da4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  403da8:	d65f03c0 	ret

0000000000403dac <send_frame_series>:
{
  403dac:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  403db0:	910003fd 	mov	x29, sp
  403db4:	a90153f3 	stp	x19, x20, [sp, #16]
  403db8:	aa0003f3 	mov	x19, x0
  403dbc:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403dc0:	a9025bf5 	stp	x21, x22, [sp, #32]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403dc4:	90000096 	adrp	x22, 413000 <z_impl_k_uptime_ticks>
  403dc8:	2a0103f5 	mov	w21, w1
{
  403dcc:	f9476800 	ldr	x0, [x0, #3792]
  403dd0:	a90363f7 	stp	x23, x24, [sp, #48]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403dd4:	91256ed6 	add	x22, x22, #0x95b
{
  403dd8:	a9046bf9 	stp	x25, x26, [sp, #64]
	return z_impl_can_send(dev, frame, timeout, callback, user_data);
  403ddc:	9000015a 	adrp	x26, 42b000 <__FRAME_END__+0xff4c>
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403de0:	90000099 	adrp	x25, 413000 <z_impl_k_uptime_ticks>
{
  403de4:	f9400003 	ldr	x3, [x0]
  403de8:	f90037e3 	str	x3, [sp, #104]
  403dec:	d2800003 	mov	x3, #0x0                   	// #0
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403df0:	52800000 	mov	w0, #0x0                   	// #0
  403df4:	f947235a 	ldr	x26, [x26, #3648]
  403df8:	33007040 	bfxil	w0, w2, #0, #29
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403dfc:	b0000098 	adrp	x24, 414000 <dlc_table.0+0x78d>
  403e00:	90000097 	adrp	x23, 413000 <z_impl_k_uptime_ticks>
  403e04:	91274739 	add	x25, x25, #0x9d1
  403e08:	91056718 	add	x24, x24, #0x159
  403e0c:	91220ef7 	add	x23, x23, #0x883
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403e10:	a905ffff 	stp	xzr, xzr, [sp, #88]
    for (i = 0; i < length; i++) {
  403e14:	52800014 	mov	w20, #0x0                   	// #0
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403e18:	b9005be0 	str	w0, [sp, #88]
  403e1c:	52800020 	mov	w0, #0x1                   	// #1
  403e20:	390177e0 	strb	w0, [sp, #93]
        frame.dlc = can_bytes_to_dlc(desired->length);
  403e24:	39402262 	ldrb	w2, [x19, #8]
  403e28:	aa1303e1 	mov	x1, x19
  403e2c:	d2800103 	mov	x3, #0x8                   	// #8
  403e30:	2a0203e0 	mov	w0, w2
  403e34:	97fffefb 	bl	403a20 <can_bytes_to_dlc>
  403e38:	92401c42 	and	x2, x2, #0xff
  403e3c:	390173e0 	strb	w0, [sp, #92]
  403e40:	910183e0 	add	x0, sp, #0x60
  403e44:	97fff503 	bl	401250 <__memcpy_chk@plt>
  403e48:	d2800004 	mov	x4, #0x0                   	// #0
  403e4c:	910163e1 	add	x1, sp, #0x58
  403e50:	d2800003 	mov	x3, #0x0                   	// #0
  403e54:	d2800642 	mov	x2, #0x32                  	// #50
  403e58:	aa1a03e0 	mov	x0, x26
  403e5c:	94002331 	bl	40cb20 <z_impl_can_send>
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403e60:	7100001f 	cmp	w0, #0x0
  403e64:	2a0003e7 	mov	w7, w0
  403e68:	2a1403e6 	mov	w6, w20
  403e6c:	aa1903e5 	mov	x5, x25
  403e70:	aa1803e4 	mov	x4, x24
  403e74:	aa1703e2 	mov	x2, x23
  403e78:	aa1603e1 	mov	x1, x22
  403e7c:	1a9f17e0 	cset	w0, eq  // eq = none
  403e80:	52800fa3 	mov	w3, #0x7d                  	// #125
    for (i = 0; i < length; i++) {
  403e84:	11000694 	add	w20, w20, #0x1
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403e88:	97ffff1d 	bl	403afc <z_zassert.constprop.0>
        desired++;
  403e8c:	91002673 	add	x19, x19, #0x9
    for (i = 0; i < length; i++) {
  403e90:	6b1402bf 	cmp	w21, w20
  403e94:	54fffc81 	b.ne	403e24 <send_frame_series+0x78>  // b.any
}
  403e98:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  403e9c:	f9476800 	ldr	x0, [x0, #3792]
  403ea0:	f94037e2 	ldr	x2, [sp, #104]
  403ea4:	f9400001 	ldr	x1, [x0]
  403ea8:	eb010042 	subs	x2, x2, x1
  403eac:	d2800001 	mov	x1, #0x0                   	// #0
  403eb0:	54000040 	b.eq	403eb8 <send_frame_series+0x10c>  // b.none
  403eb4:	97fff51b 	bl	401320 <__stack_chk_fail@plt>
  403eb8:	a94153f3 	ldp	x19, x20, [sp, #16]
  403ebc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403ec0:	a94363f7 	ldp	x23, x24, [sp, #48]
  403ec4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  403ec8:	a8c77bfd 	ldp	x29, x30, [sp], #112
  403ecc:	d65f03c0 	ret

0000000000403ed0 <_isotp_fast_conformance_async_test_receive_timeouts_wrapper>:
    zassert_equal(ret, 0, "Timeout too late");
    time_diff = k_uptime_get_32() - start_time;
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
}

ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  403ed0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  403ed4:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
    ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
    memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
    ff_frame.length = DATA_SIZE_FF + 2;

    send_frame_series(&ff_frame, 1, rx_addr);
  403ed8:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  403edc:	910003fd 	mov	x29, sp
  403ee0:	f9476800 	ldr	x0, [x0, #3792]
  403ee4:	a90153f3 	stp	x19, x20, [sp, #16]
    send_frame_series(&ff_frame, 1, rx_addr);
  403ee8:	72a31b42 	movk	w2, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  403eec:	a9025bf5 	stp	x21, x22, [sp, #32]
    start_time = k_uptime_get_32();

    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  403ef0:	90000155 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  403ef4:	b0000094 	adrp	x20, 414000 <dlc_table.0+0x78d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  403ef8:	f9400001 	ldr	x1, [x0]
  403efc:	f90027e1 	str	x1, [sp, #72]
  403f00:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  403f04:	52820220 	mov	w0, #0x1011                	// #4113
  403f08:	790073e0 	strh	w0, [sp, #56]
  403f0c:	b0000080 	adrp	x0, 414000 <dlc_table.0+0x78d>
  403f10:	910d7000 	add	x0, x0, #0x35c
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  403f14:	9109ae94 	add	x20, x20, #0x26b
  403f18:	90000093 	adrp	x19, 413000 <z_impl_k_uptime_ticks>
  403f1c:	91220e73 	add	x19, x19, #0x883
  403f20:	b9400001 	ldr	w1, [x0]
  403f24:	79400800 	ldrh	w0, [x0, #4]
  403f28:	79007fe0 	strh	w0, [sp, #62]
    ff_frame.length = DATA_SIZE_FF + 2;
  403f2c:	52800100 	mov	w0, #0x8                   	// #8
  403f30:	390103e0 	strb	w0, [sp, #64]
    send_frame_series(&ff_frame, 1, rx_addr);
  403f34:	9100e3e0 	add	x0, sp, #0x38
  403f38:	b803a3e1 	stur	w1, [sp, #58]
  403f3c:	d2800021 	mov	x1, #0x1                   	// #1
  403f40:	97ffff9b 	bl	403dac <send_frame_series>
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline uint32_t k_uptime_get_32(void)
{
	return (uint32_t)k_uptime_get();
  403f44:	97fffeb0 	bl	403a04 <k_uptime_get>
  403f48:	aa0003f6 	mov	x22, x0
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  403f4c:	f94712b5 	ldr	x21, [x21, #3616]
  403f50:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  403f54:	d2801001 	mov	x1, #0x80                  	// #128
  403f58:	aa1503e0 	mov	x0, x21
  403f5c:	97fffe5e 	bl	4038d4 <blocking_recv>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  403f60:	7100181f 	cmp	w0, #0x6
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  403f64:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  403f68:	aa1403e4 	mov	x4, x20
  403f6c:	90000085 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  403f70:	9127cca5 	add	x5, x5, #0x9f3
  403f74:	528044a3 	mov	w3, #0x225                 	// #549
  403f78:	1a9f17e0 	cset	w0, eq  // eq = none
  403f7c:	aa1303e2 	mov	x2, x19
  403f80:	90000081 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  403f84:	91285821 	add	x1, x1, #0xa16
  403f88:	97fffedd 	bl	403afc <z_zassert.constprop.0>
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  403f8c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  403f90:	d2801001 	mov	x1, #0x80                  	// #128
  403f94:	aa1503e0 	mov	x0, x21
  403f98:	97fffe4f 	bl	4038d4 <blocking_recv>
    zassert_equal(ret, ISOTP_N_TIMEOUT_CR, "Expected timeout but got %d", ret);
  403f9c:	31000c1f 	cmn	w0, #0x3
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  403fa0:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_TIMEOUT_CR, "Expected timeout but got %d", ret);
  403fa4:	aa1403e4 	mov	x4, x20
  403fa8:	aa1303e2 	mov	x2, x19
  403fac:	90000085 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  403fb0:	90000081 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  403fb4:	9128d8a5 	add	x5, x5, #0xa36
  403fb8:	91294821 	add	x1, x1, #0xa52
  403fbc:	528044e3 	mov	w3, #0x227                 	// #551
  403fc0:	1a9f17e0 	cset	w0, eq  // eq = none
  403fc4:	97fffece 	bl	403afc <z_zassert.constprop.0>
  403fc8:	97fffe8f 	bl	403a04 <k_uptime_get>

    time_diff = k_uptime_get_32() - start_time;
  403fcc:	4b160016 	sub	w22, w0, w22
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  403fd0:	710f9edf 	cmp	w22, #0x3e7
  403fd4:	2a1603e6 	mov	w6, w22
  403fd8:	aa1403e4 	mov	x4, x20
  403fdc:	aa1303e2 	mov	x2, x19
  403fe0:	1a9f97e0 	cset	w0, hi  // hi = pmore
  403fe4:	52804543 	mov	w3, #0x22a                 	// #554
  403fe8:	90000085 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  403fec:	90000081 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  403ff0:	9129e0a5 	add	x5, x5, #0xa78
  403ff4:	912a4421 	add	x1, x1, #0xa91
  403ff8:	97fffec1 	bl	403afc <z_zassert.constprop.0>
    zassert_true(time_diff <= BS_TIMEOUT_UPPER_MS, "Timeout too slow (%dms)", time_diff);
  403ffc:	711132df 	cmp	w22, #0x44c
  404000:	aa1303e2 	mov	x2, x19
  404004:	1a9f87e0 	cset	w0, ls  // ls = plast
  404008:	2a1603e6 	mov	w6, w22
  40400c:	aa1403e4 	mov	x4, x20
  404010:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  404014:	52804563 	mov	w3, #0x22b                 	// #555
  404018:	912af4a5 	add	x5, x5, #0xabd
  40401c:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404020:	912b5421 	add	x1, x1, #0xad5
  404024:	97fffeb6 	bl	403afc <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  404028:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40402c:	f9476800 	ldr	x0, [x0, #3792]
  404030:	f94027e2 	ldr	x2, [sp, #72]
  404034:	f9400001 	ldr	x1, [x0]
  404038:	eb010042 	subs	x2, x2, x1
  40403c:	d2800001 	mov	x1, #0x0                   	// #0
  404040:	54000040 	b.eq	404048 <_isotp_fast_conformance_async_test_receive_timeouts_wrapper+0x178>  // b.none
  404044:	97fff4b7 	bl	401320 <__stack_chk_fail@plt>
  404048:	a94153f3 	ldp	x19, x20, [sp, #16]
  40404c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404050:	a8c57bfd 	ldp	x29, x30, [sp], #80
  404054:	d65f03c0 	ret

0000000000404058 <isotp_fast_sent_handler>:
    zassert_equal(result, expected_err_nr, "Unexpected error nr. expect: %d, got %d",
  404058:	6b00003f 	cmp	w1, w0
{
  40405c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  404060:	2a0003e7 	mov	w7, w0
  404064:	910003fd 	mov	x29, sp
  404068:	aa0103e6 	mov	x6, x1
    zassert_equal(result, expected_err_nr, "Unexpected error nr. expect: %d, got %d",
  40406c:	1a9f17e0 	cset	w0, eq  // eq = none
  404070:	52800323 	mov	w3, #0x19                  	// #25
  404074:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  404078:	90000084 	adrp	x4, 414000 <dlc_table.0+0x78d>
  40407c:	912c04a5 	add	x5, x5, #0xb01
  404080:	9107d884 	add	x4, x4, #0x1f6
  404084:	f0000062 	adrp	x2, 413000 <z_impl_k_uptime_ticks>
  404088:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  40408c:	91220c42 	add	x2, x2, #0x883
  404090:	912ca421 	add	x1, x1, #0xb29
  404094:	97fffe9a 	bl	403afc <z_zassert.constprop.0>
	z_impl_k_sem_give(sem);
  404098:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
}
  40409c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4040a0:	f947f800 	ldr	x0, [x0, #4080]
  4040a4:	14002d84 	b	40f6b4 <z_impl_k_sem_give>

00000000004040a8 <isotp_fast_conformance_setup>:
    ret = k_sem_take(&send_compl_sem, K_MSEC(200));
    zassert_equal(ret, 0, "Send complete callback not called");
}

void *isotp_fast_conformance_setup(void)
{
  4040a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    int ret;

    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  4040ac:	528059c3 	mov	w3, #0x2ce                 	// #718
  4040b0:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
{
  4040b4:	910003fd 	mov	x29, sp
  4040b8:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  4040bc:	90000094 	adrp	x20, 414000 <dlc_table.0+0x78d>
  4040c0:	f0000073 	adrp	x19, 413000 <z_impl_k_uptime_ticks>
  4040c4:	91030e94 	add	x20, x20, #0xc3
  4040c8:	91220e73 	add	x19, x19, #0x883
  4040cc:	912d3ca5 	add	x5, x5, #0xb4f
  4040d0:	aa1403e4 	mov	x4, x20
  4040d4:	aa1303e2 	mov	x2, x19
  4040d8:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  4040dc:	52800020 	mov	w0, #0x1                   	// #1
  4040e0:	912da021 	add	x1, x1, #0xb68
{
  4040e4:	f90013f5 	str	x21, [sp, #32]
    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  4040e8:	97fffe85 	bl	403afc <z_zassert.constprop.0>
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
  4040ec:	f0000135 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
  4040f0:	f94722b5 	ldr	x21, [x21, #3648]
  4040f4:	aa1503e0 	mov	x0, x21
  4040f8:	94002517 	bl	40d554 <z_device_is_ready>

    zassert_true(device_is_ready(can_dev), "CAN device not ready");
  4040fc:	aa1403e4 	mov	x4, x20
  404100:	aa1303e2 	mov	x2, x19
  404104:	52805a03 	mov	w3, #0x2d0                 	// #720
  404108:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  40410c:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404110:	912e90a5 	add	x5, x5, #0xba4
  404114:	912ee421 	add	x1, x1, #0xbb9
  404118:	97fffe79 	bl	403afc <z_zassert.constprop.0>
	return api->set_mode(dev, mode);
  40411c:	f9400aa0 	ldr	x0, [x21, #16]
  404120:	52800021 	mov	w1, #0x1                   	// #1
  404124:	f9400c02 	ldr	x2, [x0, #24]
  404128:	aa1503e0 	mov	x0, x21
  40412c:	d63f0040 	blr	x2
    can_mode_t can_mode = CAN_MODE_LOOPBACK;
#ifdef CONFIG_CAN_FD_MODE
    can_mode |= CAN_MODE_FD;
#endif
    ret = can_set_mode(can_dev, can_mode);
    zassert_equal(ret, 0, "Failed to set loopback mode [%d]", ret);
  404130:	7100001f 	cmp	w0, #0x0
  404134:	2a0003e6 	mov	w6, w0
  404138:	aa1403e4 	mov	x4, x20
  40413c:	aa1303e2 	mov	x2, x19
  404140:	1a9f17e0 	cset	w0, eq  // eq = none
  404144:	52805ae3 	mov	w3, #0x2d7                 	// #727
  404148:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  40414c:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404150:	912f74a5 	add	x5, x5, #0xbdd
  404154:	91256c21 	add	x1, x1, #0x95b
  404158:	97fffe69 	bl	403afc <z_zassert.constprop.0>
	return z_impl_k_sem_init(sem, initial_count, limit);
  40415c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404160:	52800022 	mov	w2, #0x1                   	// #1
  404164:	52800001 	mov	w1, #0x0                   	// #0
  404168:	f947f800 	ldr	x0, [x0, #4080]
  40416c:	94002d47 	bl	40f688 <z_impl_k_sem_init>

    k_sem_init(&send_compl_sem, 0, 1);

    return NULL;
}
  404170:	d2800000 	mov	x0, #0x0                   	// #0
  404174:	a94153f3 	ldp	x19, x20, [sp, #16]
  404178:	f94013f5 	ldr	x21, [sp, #32]
  40417c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  404180:	d65f03c0 	ret

0000000000404184 <isotp_fast_recv_handler>:
{
  404184:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  404188:	f0000122 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  40418c:	910003fd 	mov	x29, sp
  404190:	f9476842 	ldr	x2, [x2, #3792]
  404194:	910063e4 	add	x4, sp, #0x18
  404198:	f9400043 	ldr	x3, [x2]
  40419c:	f90017e3 	str	x3, [sp, #40]
  4041a0:	d2800003 	mov	x3, #0x0                   	// #0
        .len = buffer->len,
  4041a4:	79404002 	ldrh	w2, [x0, #32]
    struct recv_msg msg = {
  4041a8:	290407ff 	stp	wzr, w1, [sp, #32]
    memcpy(&msg.data, buffer->data, MIN(sizeof(msg.data), buffer->len));
  4041ac:	52800101 	mov	w1, #0x8                   	// #8
  4041b0:	7100205f 	cmp	w2, #0x8
    struct recv_msg msg = {
  4041b4:	790043e2 	strh	w2, [sp, #32]
    memcpy(&msg.data, buffer->data, MIN(sizeof(msg.data), buffer->len));
  4041b8:	1a819042 	csel	w2, w2, w1, ls  // ls = plast
  4041bc:	d2800203 	mov	x3, #0x10                  	// #16
  4041c0:	f9400c01 	ldr	x1, [x0, #24]
  4041c4:	92403c42 	and	x2, x2, #0xffff
  4041c8:	aa0403e0 	mov	x0, x4
    struct recv_msg msg = {
  4041cc:	f9000fff 	str	xzr, [sp, #24]
  4041d0:	97fff420 	bl	401250 <__memcpy_chk@plt>
	return z_impl_k_msgq_put(msgq, data, timeout);
  4041d4:	aa0003e1 	mov	x1, x0
  4041d8:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4041dc:	d2800002 	mov	x2, #0x0                   	// #0
  4041e0:	f9479000 	ldr	x0, [x0, #3872]
  4041e4:	94002975 	bl	40e7b8 <z_impl_k_msgq_put>
}
  4041e8:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4041ec:	f9476800 	ldr	x0, [x0, #3792]
  4041f0:	f94017e2 	ldr	x2, [sp, #40]
  4041f4:	f9400001 	ldr	x1, [x0]
  4041f8:	eb010042 	subs	x2, x2, x1
  4041fc:	d2800001 	mov	x1, #0x0                   	// #0
  404200:	54000040 	b.eq	404208 <isotp_fast_recv_handler+0x84>  // b.none
  404204:	97fff447 	bl	401320 <__stack_chk_fail@plt>
  404208:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40420c:	d65f03c0 	ret

0000000000404210 <_isotp_fast_conformance_async_test_send_timeouts_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_timeouts)
  404210:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  404214:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404218:	910003fd 	mov	x29, sp
  40421c:	f9476800 	ldr	x0, [x0, #3792]
  404220:	a90153f3 	stp	x19, x20, [sp, #16]
  404224:	a9025bf5 	stp	x21, x22, [sp, #32]
  404228:	a90363f7 	stp	x23, x24, [sp, #48]
  40422c:	a9046bf9 	stp	x25, x26, [sp, #64]
  404230:	a90573fb 	stp	x27, x28, [sp, #80]
  404234:	f9400001 	ldr	x1, [x0]
  404238:	f9004fe1 	str	x1, [sp, #152]
  40423c:	d2800001 	mov	x1, #0x0                   	// #0
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404240:	52810600 	mov	w0, #0x830                 	// #2096
  404244:	790113e0 	strh	w0, [sp, #136]
    fc_cts_frame.length = DATA_SIZE_FC;
  404248:	52800060 	mov	w0, #0x3                   	// #3
    fc_cts_frame.data[2] = FC_PCI_BYTE_3(0);
  40424c:	39022bff 	strb	wzr, [sp, #138]
    fc_cts_frame.length = DATA_SIZE_FC;
  404250:	390243e0 	strb	w0, [sp, #144]
	z_impl_k_sem_reset(sem);
  404254:	f0000135 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
    isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  404258:	f000013a 	adrp	x26, 42b000 <__FRAME_END__+0xff4c>
  40425c:	9000009b 	adrp	x27, 414000 <dlc_table.0+0x78d>
  404260:	910d737b 	add	x27, x27, #0x35c
  404264:	f947fab5 	ldr	x21, [x21, #4080]
  404268:	aa1503e0 	mov	x0, x21
  40426c:	94002dba 	bl	40f954 <z_impl_k_sem_reset>
  404270:	97fffde5 	bl	403a04 <k_uptime_get>
  404274:	aa0003fc 	mov	x28, x0
  404278:	f9470f5a 	ldr	x26, [x26, #3608]
  40427c:	aa1b03e1 	mov	x1, x27
  404280:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  404284:	52800023 	mov	w3, #0x1                   	// #1
  404288:	aa1a03e0 	mov	x0, x26
  40428c:	d2808002 	mov	x2, #0x400                 	// #1024
  404290:	97fffd19 	bl	4036f4 <isotp_fast_send>
	return z_impl_k_sem_take(sem, timeout);
  404294:	d2800dc1 	mov	x1, #0x6e                  	// #110
  404298:	aa1503e0 	mov	x0, x21
  40429c:	94002d3d 	bl	40f790 <z_impl_k_sem_take>
  4042a0:	2a0003f6 	mov	w22, w0
  4042a4:	97fffdd8 	bl	403a04 <k_uptime_get>
    zassert_equal(ret, 0, "Timeout too late");
  4042a8:	f0000079 	adrp	x25, 413000 <z_impl_k_uptime_ticks>
  4042ac:	710002df 	cmp	w22, #0x0
  4042b0:	912ffb39 	add	x25, x25, #0xbfe
  4042b4:	90000094 	adrp	x20, 414000 <dlc_table.0+0x78d>
  4042b8:	f0000073 	adrp	x19, 413000 <z_impl_k_uptime_ticks>
  4042bc:	910a7a94 	add	x20, x20, #0x29e
  4042c0:	91220e73 	add	x19, x19, #0x883
  4042c4:	f0000078 	adrp	x24, 413000 <z_impl_k_uptime_ticks>
  4042c8:	91256f18 	add	x24, x24, #0x95b
    time_diff = k_uptime_get_32() - start_time;
  4042cc:	4b1c001c 	sub	w28, w0, w28
    zassert_equal(ret, 0, "Timeout too late");
  4042d0:	aa1903e5 	mov	x5, x25
  4042d4:	aa1403e4 	mov	x4, x20
  4042d8:	aa1303e2 	mov	x2, x19
  4042dc:	aa1803e1 	mov	x1, x24
  4042e0:	1a9f17e0 	cset	w0, eq  // eq = none
  4042e4:	52803e23 	mov	w3, #0x1f1                 	// #497
  4042e8:	97fffe05 	bl	403afc <z_zassert.constprop.0>
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4042ec:	710f9f9f 	cmp	w28, #0x3e7
  4042f0:	f0000077 	adrp	x23, 413000 <z_impl_k_uptime_ticks>
  4042f4:	f0000076 	adrp	x22, 413000 <z_impl_k_uptime_ticks>
  4042f8:	9129e2f7 	add	x23, x23, #0xa78
  4042fc:	912a46d6 	add	x22, x22, #0xa91
  404300:	2a1c03e6 	mov	w6, w28
  404304:	aa1703e5 	mov	x5, x23
  404308:	aa1403e4 	mov	x4, x20
  40430c:	aa1303e2 	mov	x2, x19
  404310:	aa1603e1 	mov	x1, x22
  404314:	1a9f97e0 	cset	w0, hi  // hi = pmore
  404318:	52803e43 	mov	w3, #0x1f2                 	// #498
  40431c:	97fffdf8 	bl	403afc <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  404320:	aa1503e0 	mov	x0, x21
  404324:	94002d8c 	bl	40f954 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  404328:	aa1b03e1 	mov	x1, x27
  40432c:	aa1a03e0 	mov	x0, x26
  404330:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  404334:	52800023 	mov	w3, #0x1                   	// #1
  404338:	d2808002 	mov	x2, #0x400                 	// #1024
  40433c:	97fffcee 	bl	4036f4 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404340:	f0000068 	adrp	x8, 413000 <z_impl_k_uptime_ticks>
  404344:	7100001f 	cmp	w0, #0x0
  404348:	91252908 	add	x8, x8, #0x94a
  40434c:	f0000067 	adrp	x7, 413000 <z_impl_k_uptime_ticks>
  404350:	91303ce7 	add	x7, x7, #0xc0f
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  404354:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404358:	aa0703e1 	mov	x1, x7
  40435c:	aa0803e5 	mov	x5, x8
  404360:	aa1403e4 	mov	x4, x20
  404364:	1a9f17e0 	cset	w0, eq  // eq = none
  404368:	52803f03 	mov	w3, #0x1f8                 	// #504
  40436c:	aa1303e2 	mov	x2, x19
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  404370:	910223fc 	add	x28, sp, #0x88
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404374:	a90723e7 	stp	x7, x8, [sp, #112]
  404378:	97fffde1 	bl	403afc <z_zassert.constprop.0>
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  40437c:	aa1c03e0 	mov	x0, x28
  404380:	52804022 	mov	w2, #0x201                 	// #513
  404384:	72a31b42 	movk	w2, #0x18da, lsl #16
  404388:	d2800021 	mov	x1, #0x1                   	// #1
  40438c:	97fffe88 	bl	403dac <send_frame_series>
  404390:	97fffd9d 	bl	403a04 <k_uptime_get>
  404394:	f90037e0 	str	x0, [sp, #104]
	return z_impl_k_sem_take(sem, timeout);
  404398:	d2800dc1 	mov	x1, #0x6e                  	// #110
  40439c:	aa1503e0 	mov	x0, x21
  4043a0:	94002cfc 	bl	40f790 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Timeout too late");
  4043a4:	7100001f 	cmp	w0, #0x0
  4043a8:	aa1903e5 	mov	x5, x25
  4043ac:	aa1403e4 	mov	x4, x20
  4043b0:	aa1303e2 	mov	x2, x19
  4043b4:	aa1803e1 	mov	x1, x24
  4043b8:	52803fc3 	mov	w3, #0x1fe                 	// #510
  4043bc:	1a9f17e0 	cset	w0, eq  // eq = none
  4043c0:	97fffdcf 	bl	403afc <z_zassert.constprop.0>
  4043c4:	97fffd90 	bl	403a04 <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  4043c8:	f94037e6 	ldr	x6, [sp, #104]
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4043cc:	aa1703e5 	mov	x5, x23
  4043d0:	aa1403e4 	mov	x4, x20
  4043d4:	aa1303e2 	mov	x2, x19
    time_diff = k_uptime_get_32() - start_time;
  4043d8:	4b060006 	sub	w6, w0, w6
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4043dc:	aa1603e1 	mov	x1, x22
  4043e0:	710f9cdf 	cmp	w6, #0x3e7
  4043e4:	52804023 	mov	w3, #0x201                 	// #513
  4043e8:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4043ec:	97fffdc4 	bl	403afc <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  4043f0:	aa1503e0 	mov	x0, x21
  4043f4:	94002d58 	bl	40f954 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  4043f8:	aa1b03e1 	mov	x1, x27
  4043fc:	aa1a03e0 	mov	x0, x26
  404400:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  404404:	52800023 	mov	w3, #0x1                   	// #1
  404408:	d2808002 	mov	x2, #0x400                 	// #1024
  40440c:	97fffcba 	bl	4036f4 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404410:	a94723e7 	ldp	x7, x8, [sp, #112]
  404414:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  404418:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  40441c:	aa1403e4 	mov	x4, x20
  404420:	aa1303e2 	mov	x2, x19
  404424:	1a9f17e0 	cset	w0, eq  // eq = none
  404428:	528040e3 	mov	w3, #0x207                 	// #519
  40442c:	aa0803e5 	mov	x5, x8
  404430:	aa0703e1 	mov	x1, x7
  404434:	97fffdb2 	bl	403afc <z_zassert.constprop.0>
	return z_impl_k_sem_take(sem, timeout);
  404438:	d2800a01 	mov	x1, #0x50                  	// #80
  40443c:	aa1503e0 	mov	x0, x21
  404440:	94002cd4 	bl	40f790 <z_impl_k_sem_take>
    zassert_equal(ret, -EAGAIN, "Timeout too early");
  404444:	31002c1f 	cmn	w0, #0xb
  404448:	aa1403e4 	mov	x4, x20
  40444c:	1a9f17e0 	cset	w0, eq  // eq = none
  404450:	52804143 	mov	w3, #0x20a                 	// #522
  404454:	aa1303e2 	mov	x2, x19
  404458:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  40445c:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404460:	9130b4a5 	add	x5, x5, #0xc2d
  404464:	9130fc21 	add	x1, x1, #0xc3f
  404468:	97fffda5 	bl	403afc <z_zassert.constprop.0>
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  40446c:	52800600 	mov	w0, #0x30                  	// #48
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  404470:	52804022 	mov	w2, #0x201                 	// #513
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404474:	390223e0 	strb	w0, [sp, #136]
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  404478:	aa1c03e0 	mov	x0, x28
  40447c:	72a31b42 	movk	w2, #0x18da, lsl #16
  404480:	d2800021 	mov	x1, #0x1                   	// #1
  404484:	97fffe4a 	bl	403dac <send_frame_series>
  404488:	97fffd5f 	bl	403a04 <k_uptime_get>
  40448c:	aa0003fa 	mov	x26, x0
  404490:	d2800dc1 	mov	x1, #0x6e                  	// #110
  404494:	aa1503e0 	mov	x0, x21
  404498:	94002cbe 	bl	40f790 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Timeout too late");
  40449c:	7100001f 	cmp	w0, #0x0
  4044a0:	aa1903e5 	mov	x5, x25
  4044a4:	aa1403e4 	mov	x4, x20
  4044a8:	aa1303e2 	mov	x2, x19
  4044ac:	aa1803e1 	mov	x1, x24
  4044b0:	52804223 	mov	w3, #0x211                 	// #529
  4044b4:	1a9f17e0 	cset	w0, eq  // eq = none
  4044b8:	97fffd91 	bl	403afc <z_zassert.constprop.0>
  4044bc:	97fffd52 	bl	403a04 <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  4044c0:	4b1a0006 	sub	w6, w0, w26
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4044c4:	710f9cdf 	cmp	w6, #0x3e7
  4044c8:	aa1303e2 	mov	x2, x19
  4044cc:	aa1603e1 	mov	x1, x22
  4044d0:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4044d4:	aa1703e5 	mov	x5, x23
  4044d8:	aa1403e4 	mov	x4, x20
  4044dc:	52804263 	mov	w3, #0x213                 	// #531
  4044e0:	97fffd87 	bl	403afc <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_timeouts)
  4044e4:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4044e8:	f9476800 	ldr	x0, [x0, #3792]
  4044ec:	f9404fe2 	ldr	x2, [sp, #152]
  4044f0:	f9400001 	ldr	x1, [x0]
  4044f4:	eb010042 	subs	x2, x2, x1
  4044f8:	d2800001 	mov	x1, #0x0                   	// #0
  4044fc:	54000040 	b.eq	404504 <_isotp_fast_conformance_async_test_send_timeouts_wrapper+0x2f4>  // b.none
  404500:	97fff388 	bl	401320 <__stack_chk_fail@plt>
  404504:	a94153f3 	ldp	x19, x20, [sp, #16]
  404508:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40450c:	a94363f7 	ldp	x23, x24, [sp, #48]
  404510:	a9446bf9 	ldp	x25, x26, [sp, #64]
  404514:	a94573fb 	ldp	x27, x28, [sp, #80]
  404518:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  40451c:	d65f03c0 	ret

0000000000404520 <check_data>:
{
  404520:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  404524:	910003fd 	mov	x29, sp
  404528:	a90153f3 	stp	x19, x20, [sp, #16]
  40452c:	aa0003f4 	mov	x20, x0
  404530:	aa0203f3 	mov	x19, x2
  404534:	a9025bf5 	stp	x21, x22, [sp, #32]
  404538:	aa0103f5 	mov	x21, x1
  40453c:	a90363f7 	stp	x23, x24, [sp, #48]
    ret = memcmp(frame, desired, length);
  404540:	97fff390 	bl	401380 <memcmp@plt>
  404544:	2a0003f6 	mov	w22, w0
    if (ret) {
  404548:	340002a0 	cbz	w0, 40459c <check_data+0x7c>
int filter_id;

static void print_hex(const uint8_t *ptr, size_t len)
{
    while (len--) {
        printk("%02x ", *ptr++);
  40454c:	f0000077 	adrp	x23, 413000 <z_impl_k_uptime_ticks>
  404550:	8b1302b8 	add	x24, x21, x19
  404554:	9131aaf7 	add	x23, x23, #0xc6a
        printk("desired bytes:\n");
  404558:	f0000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  40455c:	91316800 	add	x0, x0, #0xc5a
  404560:	940007cf 	bl	40649c <printk>
    while (len--) {
  404564:	eb1802bf 	cmp	x21, x24
  404568:	54000261 	b.ne	4045b4 <check_data+0x94>  // b.any
        printk("\nreceived (%zu bytes):\n", length);
  40456c:	aa1303e1 	mov	x1, x19
        printk("%02x ", *ptr++);
  404570:	f0000075 	adrp	x21, 413000 <z_impl_k_uptime_ticks>
  404574:	8b130293 	add	x19, x20, x19
  404578:	9131aab5 	add	x21, x21, #0xc6a
  40457c:	f0000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  404580:	9131c000 	add	x0, x0, #0xc70
  404584:	940007c6 	bl	40649c <printk>
    while (len--) {
  404588:	eb13029f 	cmp	x20, x19
  40458c:	540001c1 	b.ne	4045c4 <check_data+0xa4>  // b.any
        printk("\n");
  404590:	b0000080 	adrp	x0, 415000 <random_data+0xca4>
  404594:	9135a800 	add	x0, x0, #0xd6a
  404598:	940007c1 	bl	40649c <printk>
}
  40459c:	2a1603e0 	mov	w0, w22
  4045a0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4045a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4045a8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4045ac:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4045b0:	d65f03c0 	ret
        printk("%02x ", *ptr++);
  4045b4:	384016a1 	ldrb	w1, [x21], #1
  4045b8:	aa1703e0 	mov	x0, x23
  4045bc:	940007b8 	bl	40649c <printk>
  4045c0:	17ffffe9 	b	404564 <check_data+0x44>
  4045c4:	38401681 	ldrb	w1, [x20], #1
  4045c8:	aa1503e0 	mov	x0, x21
  4045cc:	940007b4 	bl	40649c <printk>
  4045d0:	17ffffee 	b	404588 <check_data+0x68>

00000000004045d4 <check_frame_series.constprop.0>:
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  4045d4:	d10343ff 	sub	sp, sp, #0xd0
  4045d8:	a9047bfd 	stp	x29, x30, [sp, #64]
  4045dc:	910103fd 	add	x29, sp, #0x40
  4045e0:	a90553f3 	stp	x19, x20, [sp, #80]
  4045e4:	aa0003f3 	mov	x19, x0
  4045e8:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4045ec:	a9065bf5 	stp	x21, x22, [sp, #96]
  4045f0:	f9476800 	ldr	x0, [x0, #3792]
  4045f4:	a90763f7 	stp	x23, x24, [sp, #112]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  4045f8:	f0000078 	adrp	x24, 413000 <z_impl_k_uptime_ticks>
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  4045fc:	a9086bf9 	stp	x25, x26, [sp, #128]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404600:	91322318 	add	x24, x24, #0xc88
    for (i = 0; i < length; i++) {
  404604:	52800017 	mov	w23, #0x0                   	// #0
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  404608:	a90973fb 	stp	x27, x28, [sp, #144]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  40460c:	9000009b 	adrp	x27, 414000 <dlc_table.0+0x78d>
  404610:	f000007c 	adrp	x28, 413000 <z_impl_k_uptime_ticks>
        zassert_equal(can_dlc_to_bytes(frame.dlc),
  404614:	9105cb76 	add	x22, x27, #0x172
  404618:	91220f95 	add	x21, x28, #0x883
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  40461c:	f9400002 	ldr	x2, [x0]
  404620:	f90067e2 	str	x2, [sp, #200]
  404624:	d2800002 	mov	x2, #0x0                   	// #0
    for (i = 0; i < length; i++) {
  404628:	b900afe1 	str	w1, [sp, #172]
        ret = k_msgq_get(msgq, &frame, K_MSEC(500));
  40462c:	f0000134 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  404630:	9102e3f9 	add	x25, sp, #0xb8
  404634:	aa1903e1 	mov	x1, x25
  404638:	d2800642 	mov	x2, #0x32                  	// #50
  40463c:	f947e280 	ldr	x0, [x20, #4032]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404640:	f000007a 	adrp	x26, 413000 <z_impl_k_uptime_ticks>
        ret = k_msgq_get(msgq, &frame, K_MSEC(500));
  404644:	97fffca3 	bl	4038d0 <k_msgq_get>
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404648:	7100001f 	cmp	w0, #0x0
        ret = k_msgq_get(msgq, &frame, K_MSEC(500));
  40464c:	2a0003e7 	mov	w7, w0
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404650:	91256f41 	add	x1, x26, #0x95b
  404654:	2a1703e6 	mov	w6, w23
  404658:	aa1803e5 	mov	x5, x24
  40465c:	9105cb64 	add	x4, x27, #0x172
  404660:	91220f82 	add	x2, x28, #0x883
  404664:	1a9f17e0 	cset	w0, eq  // eq = none
  404668:	52801143 	mov	w3, #0x8a                  	// #138
  40466c:	97fffd24 	bl	403afc <z_zassert.constprop.0>
        zassert_equal(can_dlc_to_bytes(frame.dlc),
  404670:	3942f3e1 	ldrb	w1, [sp, #188]
	return dlc > 0x0F ? 64 : dlc_table[dlc];
  404674:	71003c3f 	cmp	w1, #0xf
  404678:	54000a28 	b.hi	4047bc <check_frame_series.constprop.0+0x1e8>  // b.pmore
  40467c:	90000080 	adrp	x0, 414000 <dlc_table.0+0x78d>
  404680:	910d2400 	add	x0, x0, #0x349
  404684:	3861c801 	ldrb	w1, [x0, w1, sxtw]
  404688:	39402267 	ldrb	w7, [x19, #8]
  40468c:	2a0703e0 	mov	w0, w7
  404690:	97fffce4 	bl	403a20 <can_bytes_to_dlc>
  404694:	12001c00 	and	w0, w0, #0xff
  404698:	71003c1f 	cmp	w0, #0xf
  40469c:	54000948 	b.hi	4047c4 <check_frame_series.constprop.0+0x1f0>  // b.pmore
  4046a0:	90000082 	adrp	x2, 414000 <dlc_table.0+0x78d>
  4046a4:	910d2442 	add	x2, x2, #0x349
  4046a8:	3860c840 	ldrb	w0, [x2, w0, sxtw]
  4046ac:	6b01001f 	cmp	w0, w1
  4046b0:	b90003e1 	str	w1, [sp]
  4046b4:	2a1703e6 	mov	w6, w23
  4046b8:	aa1603e4 	mov	x4, x22
  4046bc:	1a9f17e0 	cset	w0, eq  // eq = none
  4046c0:	528011e3 	mov	w3, #0x8f                  	// #143
  4046c4:	aa1503e2 	mov	x2, x21
  4046c8:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  4046cc:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  4046d0:	9132bca5 	add	x5, x5, #0xcaf
  4046d4:	91337c21 	add	x1, x1, #0xcdf
  4046d8:	97fffd09 	bl	403afc <z_zassert.constprop.0>
        ret = check_data(frame.data, desired->data, desired->length);
  4046dc:	39402262 	ldrb	w2, [x19, #8]
  4046e0:	aa1303e1 	mov	x1, x19
  4046e4:	910303e0 	add	x0, sp, #0xc0
    for (i = 0; i < length; i++) {
  4046e8:	110006f7 	add	w23, w23, #0x1
        desired++;
  4046ec:	91002673 	add	x19, x19, #0x9
        ret = check_data(frame.data, desired->data, desired->length);
  4046f0:	97ffff8c 	bl	404520 <check_data>
        zassert_equal(ret, 0, "Data differ");
  4046f4:	7100001f 	cmp	w0, #0x0
  4046f8:	aa1603e4 	mov	x4, x22
  4046fc:	aa1503e2 	mov	x2, x21
  404700:	91256f41 	add	x1, x26, #0x95b
  404704:	1a9f17e0 	cset	w0, eq  // eq = none
  404708:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  40470c:	528012a3 	mov	w3, #0x95                  	// #149
  404710:	9134f8a5 	add	x5, x5, #0xd3e
  404714:	97fffcfa 	bl	403afc <z_zassert.constprop.0>
    for (i = 0; i < length; i++) {
  404718:	b940afe0 	ldr	w0, [sp, #172]
  40471c:	6b0002ff 	cmp	w23, w0
  404720:	54fff861 	b.ne	40462c <check_frame_series.constprop.0+0x58>  // b.any
    ret = k_msgq_get(msgq, &frame, K_MSEC(200));
  404724:	f947e280 	ldr	x0, [x20, #4032]
  404728:	aa1903e1 	mov	x1, x25
  40472c:	d2800282 	mov	x2, #0x14                  	// #20
  404730:	97fffc68 	bl	4038d0 <k_msgq_get>
    zassert_equal(ret, -EAGAIN,
  404734:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(msgq, &frame, K_MSEC(200));
  404738:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN,
  40473c:	39431fe0 	ldrb	w0, [sp, #199]
  404740:	b90033e0 	str	w0, [sp, #48]
  404744:	aa1503e2 	mov	x2, x21
  404748:	39431be0 	ldrb	w0, [sp, #198]
  40474c:	aa1603e4 	mov	x4, x22
  404750:	b9002be0 	str	w0, [sp, #40]
  404754:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  404758:	394317e0 	ldrb	w0, [sp, #197]
  40475c:	913528a5 	add	x5, x5, #0xd4a
  404760:	b90023e0 	str	w0, [sp, #32]
  404764:	52801343 	mov	w3, #0x9a                  	// #154
  404768:	394313e0 	ldrb	w0, [sp, #196]
  40476c:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404770:	b9001be0 	str	w0, [sp, #24]
  404774:	9130fc21 	add	x1, x1, #0xc3f
  404778:	39430fe0 	ldrb	w0, [sp, #195]
  40477c:	394303e7 	ldrb	w7, [sp, #192]
  404780:	b90013e0 	str	w0, [sp, #16]
  404784:	39430be0 	ldrb	w0, [sp, #194]
  404788:	b9000be0 	str	w0, [sp, #8]
  40478c:	394307e0 	ldrb	w0, [sp, #193]
  404790:	b90003e0 	str	w0, [sp]
  404794:	1a9f17e0 	cset	w0, eq  // eq = none
  404798:	97fffcd9 	bl	403afc <z_zassert.constprop.0>
}
  40479c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4047a0:	f9476800 	ldr	x0, [x0, #3792]
  4047a4:	f94067e2 	ldr	x2, [sp, #200]
  4047a8:	f9400001 	ldr	x1, [x0]
  4047ac:	eb010042 	subs	x2, x2, x1
  4047b0:	d2800001 	mov	x1, #0x0                   	// #0
  4047b4:	540000c0 	b.eq	4047cc <check_frame_series.constprop.0+0x1f8>  // b.none
  4047b8:	97fff2da 	bl	401320 <__stack_chk_fail@plt>
  4047bc:	52800801 	mov	w1, #0x40                  	// #64
  4047c0:	17ffffb2 	b	404688 <check_frame_series.constprop.0+0xb4>
  4047c4:	52800800 	mov	w0, #0x40                  	// #64
  4047c8:	17ffffb9 	b	4046ac <check_frame_series.constprop.0+0xd8>
  4047cc:	a9447bfd 	ldp	x29, x30, [sp, #64]
  4047d0:	a94553f3 	ldp	x19, x20, [sp, #80]
  4047d4:	a9465bf5 	ldp	x21, x22, [sp, #96]
  4047d8:	a94763f7 	ldp	x23, x24, [sp, #112]
  4047dc:	a9486bf9 	ldp	x25, x26, [sp, #128]
  4047e0:	a94973fb 	ldp	x27, x28, [sp, #144]
  4047e4:	910343ff 	add	sp, sp, #0xd0
  4047e8:	d65f03c0 	ret

00000000004047ec <_isotp_fast_conformance_async_test_stmin_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  4047ec:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  4047f0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4047f4:	910003fd 	mov	x29, sp
  4047f8:	f9476800 	ldr	x0, [x0, #3792]
  4047fc:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404800:	90000094 	adrp	x20, 414000 <dlc_table.0+0x78d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404804:	a9025bf5 	stp	x21, x22, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404808:	91090e94 	add	x20, x20, #0x243
  40480c:	f0000073 	adrp	x19, 413000 <z_impl_k_uptime_ticks>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404810:	a90363f7 	stp	x23, x24, [sp, #48]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404814:	91220e73 	add	x19, x19, #0x883
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404818:	f0000136 	adrp	x22, 42b000 <__FRAME_END__+0xff4c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  40481c:	a9046bf9 	stp	x25, x26, [sp, #64]
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404820:	910223f7 	add	x23, sp, #0x88
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404824:	f000007a 	adrp	x26, 413000 <z_impl_k_uptime_ticks>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404828:	a90573fb 	stp	x27, x28, [sp, #80]
    send_frame_series(&fc_frame, 1, tx_addr);
  40482c:	9101a3fb 	add	x27, sp, #0x68
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404830:	9136575a 	add	x26, x26, #0xd95
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404834:	f9400001 	ldr	x1, [x0]
  404838:	f9004fe1 	str	x1, [sp, #152]
  40483c:	d2800001 	mov	x1, #0x0                   	// #0
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404840:	f0000075 	adrp	x21, 413000 <z_impl_k_uptime_ticks>
  404844:	91256eb5 	add	x21, x21, #0x95b
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  404848:	f0000079 	adrp	x25, 413000 <z_impl_k_uptime_ticks>
  40484c:	9136d739 	add	x25, x25, #0xdb5
        ztest_test_skip();
  404850:	94001b0f 	bl	40b48c <ztest_test_skip>
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SIZE_FF + DATA_SIZE_CF * 4);
  404854:	52844200 	mov	w0, #0x2210                	// #8720
  404858:	7900f3e0 	strh	w0, [sp, #120]
  40485c:	90000080 	adrp	x0, 414000 <dlc_table.0+0x78d>
  404860:	910d7000 	add	x0, x0, #0x35c
  404864:	b9400001 	ldr	w1, [x0]
  404868:	79400800 	ldrh	w0, [x0, #4]
  40486c:	7900ffe0 	strh	w0, [sp, #126]
    ff_frame.length = DATA_SIZE_FF + 2;
  404870:	52800100 	mov	w0, #0x8                   	// #8
  404874:	390203e0 	strb	w0, [sp, #128]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404878:	52804600 	mov	w0, #0x230                 	// #560
  40487c:	7900d3e0 	strh	w0, [sp, #104]
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_1);
  404880:	528000a0 	mov	w0, #0x5                   	// #5
  404884:	3901abe0 	strb	w0, [sp, #106]
    fc_frame.length = DATA_SIZE_FC;
  404888:	52800060 	mov	w0, #0x3                   	// #3
  40488c:	3901c3e0 	strb	w0, [sp, #112]
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  404890:	52804020 	mov	w0, #0x201                 	// #513
  404894:	b807a3e1 	stur	w1, [sp, #122]
  404898:	72a31b40 	movk	w0, #0x18da, lsl #16
  40489c:	97fffd08 	bl	403cbc <add_rx_msgq.constprop.0>
  4048a0:	2a0003e6 	mov	w6, w0
  4048a4:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4048a8:	aa1403e4 	mov	x4, x20
  4048ac:	aa1303e2 	mov	x2, x19
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  4048b0:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4048b4:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  4048b8:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  4048bc:	912664a5 	add	x5, x5, #0x999
  4048c0:	9126d421 	add	x1, x1, #0x9b5
  4048c4:	528048a3 	mov	w3, #0x245                 	// #581
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  4048c8:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4048cc:	2a2603e0 	mvn	w0, w6
  4048d0:	531f7c00 	lsr	w0, w0, #31
  4048d4:	97fffc8a 	bl	403afc <z_zassert.constprop.0>
    send_test_data(random_data, DATA_SIZE_FF + DATA_SIZE_CF * 4);
  4048d8:	d2800440 	mov	x0, #0x22                  	// #34
  4048dc:	97fffce0 	bl	403c5c <send_test_data.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  4048e0:	9101e3e0 	add	x0, sp, #0x78
  4048e4:	d2800021 	mov	x1, #0x1                   	// #1
  4048e8:	97ffff3b 	bl	4045d4 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, tx_addr);
  4048ec:	52802042 	mov	w2, #0x102                 	// #258
  4048f0:	aa1b03e0 	mov	x0, x27
  4048f4:	72a31b42 	movk	w2, #0x18da, lsl #16
  4048f8:	d2800021 	mov	x1, #0x1                   	// #1
  4048fc:	97fffd2c 	bl	403dac <send_frame_series>
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404900:	f947e2d6 	ldr	x22, [x22, #4032]
  404904:	aa1703e1 	mov	x1, x23
  404908:	d2800142 	mov	x2, #0xa                   	// #10
  40490c:	aa1603e0 	mov	x0, x22
  404910:	97fffbf0 	bl	4038d0 <k_msgq_get>
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404914:	7100001f 	cmp	w0, #0x0
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404918:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  40491c:	aa1a03e5 	mov	x5, x26
  404920:	aa1403e4 	mov	x4, x20
  404924:	aa1303e2 	mov	x2, x19
  404928:	aa1503e1 	mov	x1, x21
  40492c:	528049c3 	mov	w3, #0x24e                 	// #590
  404930:	1a9f17e0 	cset	w0, eq  // eq = none
  404934:	97fffc72 	bl	403afc <z_zassert.constprop.0>
  404938:	97fffc33 	bl	403a04 <k_uptime_get>
  40493c:	aa0003fc 	mov	x28, x0
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(STMIN_VAL_1 + STMIN_UPPER_TOLERANCE));
  404940:	aa1703e1 	mov	x1, x23
  404944:	d2800022 	mov	x2, #0x1                   	// #1
  404948:	aa1603e0 	mov	x0, x22
  40494c:	97fffbe1 	bl	4038d0 <k_msgq_get>
  404950:	2a0003f8 	mov	w24, w0
  404954:	97fffc2c 	bl	403a04 <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  404958:	4b1c001c 	sub	w28, w0, w28
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  40495c:	7100031f 	cmp	w24, #0x0
  404960:	2a1803e7 	mov	w7, w24
  404964:	aa1903e5 	mov	x5, x25
  404968:	aa1403e4 	mov	x4, x20
  40496c:	aa1303e2 	mov	x2, x19
  404970:	aa1503e1 	mov	x1, x21
  404974:	1a9f17e0 	cset	w0, eq  // eq = none
  404978:	52800146 	mov	w6, #0xa                   	// #10
  40497c:	52804a63 	mov	w3, #0x253                 	// #595
  404980:	97fffc5f 	bl	403afc <z_zassert.constprop.0>
    zassert_true(time_diff >= STMIN_VAL_1, "STmin too short (%dms)", time_diff);
  404984:	7100139f 	cmp	w28, #0x4
  404988:	f0000078 	adrp	x24, 413000 <z_impl_k_uptime_ticks>
  40498c:	91378718 	add	x24, x24, #0xde1
  404990:	2a1c03e6 	mov	w6, w28
  404994:	aa1803e5 	mov	x5, x24
  404998:	aa1403e4 	mov	x4, x20
  40499c:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4049a0:	52804aa3 	mov	w3, #0x255                 	// #597
  4049a4:	aa1303e2 	mov	x2, x19
  4049a8:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  4049ac:	9137e021 	add	x1, x1, #0xdf8
  4049b0:	97fffc53 	bl	403afc <z_zassert.constprop.0>
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_2);
  4049b4:	52800640 	mov	w0, #0x32                  	// #50
    send_frame_series(&fc_frame, 1, tx_addr);
  4049b8:	52802042 	mov	w2, #0x102                 	// #258
  4049bc:	72a31b42 	movk	w2, #0x18da, lsl #16
  4049c0:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_2);
  4049c4:	3901abe0 	strb	w0, [sp, #106]
    send_frame_series(&fc_frame, 1, tx_addr);
  4049c8:	aa1b03e0 	mov	x0, x27
  4049cc:	97fffcf8 	bl	403dac <send_frame_series>
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  4049d0:	aa1703e1 	mov	x1, x23
  4049d4:	d2800142 	mov	x2, #0xa                   	// #10
  4049d8:	aa1603e0 	mov	x0, x22
  4049dc:	97fffbbd 	bl	4038d0 <k_msgq_get>
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  4049e0:	7100001f 	cmp	w0, #0x0
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  4049e4:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  4049e8:	aa1a03e5 	mov	x5, x26
  4049ec:	aa1403e4 	mov	x4, x20
  4049f0:	aa1303e2 	mov	x2, x19
  4049f4:	aa1503e1 	mov	x1, x21
  4049f8:	52804b63 	mov	w3, #0x25b                 	// #603
  4049fc:	1a9f17e0 	cset	w0, eq  // eq = none
  404a00:	97fffc3f 	bl	403afc <z_zassert.constprop.0>
  404a04:	97fffc00 	bl	403a04 <k_uptime_get>
  404a08:	aa0003fa 	mov	x26, x0
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(STMIN_VAL_2 + STMIN_UPPER_TOLERANCE));
  404a0c:	aa1703e1 	mov	x1, x23
  404a10:	d28000c2 	mov	x2, #0x6                   	// #6
  404a14:	aa1603e0 	mov	x0, x22
  404a18:	97fffbae 	bl	4038d0 <k_msgq_get>
  404a1c:	2a0003f7 	mov	w23, w0
  404a20:	97fffbf9 	bl	403a04 <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  404a24:	4b1a001a 	sub	w26, w0, w26
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  404a28:	710002ff 	cmp	w23, #0x0
  404a2c:	2a1703e7 	mov	w7, w23
  404a30:	aa1903e5 	mov	x5, x25
  404a34:	aa1403e4 	mov	x4, x20
  404a38:	aa1303e2 	mov	x2, x19
  404a3c:	aa1503e1 	mov	x1, x21
  404a40:	1a9f17e0 	cset	w0, eq  // eq = none
  404a44:	528006e6 	mov	w6, #0x37                  	// #55
  404a48:	52804c03 	mov	w3, #0x260                 	// #608
  404a4c:	97fffc2c 	bl	403afc <z_zassert.constprop.0>
    zassert_true(time_diff >= STMIN_VAL_2, "STmin too short (%dms)", time_diff);
  404a50:	7100c75f 	cmp	w26, #0x31
  404a54:	aa1303e2 	mov	x2, x19
  404a58:	1a9f97e0 	cset	w0, hi  // hi = pmore
  404a5c:	2a1a03e6 	mov	w6, w26
  404a60:	aa1803e5 	mov	x5, x24
  404a64:	aa1403e4 	mov	x4, x20
  404a68:	52804c43 	mov	w3, #0x262                 	// #610
  404a6c:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404a70:	91387021 	add	x1, x1, #0xe1c
  404a74:	97fffc22 	bl	403afc <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404a78:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404a7c:	f9476800 	ldr	x0, [x0, #3792]
  404a80:	f9404fe2 	ldr	x2, [sp, #152]
  404a84:	f9400001 	ldr	x1, [x0]
  404a88:	eb010042 	subs	x2, x2, x1
  404a8c:	d2800001 	mov	x1, #0x0                   	// #0
  404a90:	54000040 	b.eq	404a98 <_isotp_fast_conformance_async_test_stmin_wrapper+0x2ac>  // b.none
  404a94:	97fff223 	bl	401320 <__stack_chk_fail@plt>
  404a98:	a94153f3 	ldp	x19, x20, [sp, #16]
  404a9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404aa0:	a94363f7 	ldp	x23, x24, [sp, #48]
  404aa4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  404aa8:	a94573fb 	ldp	x27, x28, [sp, #80]
  404aac:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  404ab0:	d65f03c0 	ret

0000000000404ab4 <_isotp_fast_conformance_async_test_sender_fc_errors_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  404ab4:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  404ab8:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404abc:	910003fd 	mov	x29, sp
  404ac0:	f9476800 	ldr	x0, [x0, #3792]
  404ac4:	a90153f3 	stp	x19, x20, [sp, #16]
  404ac8:	90000093 	adrp	x19, 414000 <dlc_table.0+0x78d>
  404acc:	910d7273 	add	x19, x19, #0x35c
  404ad0:	a9025bf5 	stp	x21, x22, [sp, #32]
  404ad4:	9101e3f5 	add	x21, sp, #0x78
  404ad8:	a90363f7 	stp	x23, x24, [sp, #48]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404adc:	f0000137 	adrp	x23, 42b000 <__FRAME_END__+0xff4c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  404ae0:	a9046bf9 	stp	x25, x26, [sp, #64]
  404ae4:	a90573fb 	stp	x27, x28, [sp, #80]
  404ae8:	f9400001 	ldr	x1, [x0]
  404aec:	f9004fe1 	str	x1, [sp, #152]
  404af0:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  404af4:	52820220 	mov	w0, #0x1011                	// #4113
  404af8:	7900f3e0 	strh	w0, [sp, #120]
  404afc:	b9400260 	ldr	w0, [x19]
  404b00:	b807a3e0 	stur	w0, [sp, #122]
  404b04:	79400a60 	ldrh	w0, [x19, #4]
  404b08:	7900ffe0 	strh	w0, [sp, #126]
    ff_frame.length = DATA_SIZE_FF + 2;
  404b0c:	52800100 	mov	w0, #0x8                   	// #8
  404b10:	390203e0 	strb	w0, [sp, #128]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404b14:	52802040 	mov	w0, #0x102                 	// #258
  404b18:	72a31b40 	movk	w0, #0x18da, lsl #16
  404b1c:	97fffc68 	bl	403cbc <add_rx_msgq.constprop.0>
  404b20:	f947b6f7 	ldr	x23, [x23, #3944]
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  404b24:	39022bff 	strb	wzr, [sp, #138]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404b28:	b90002e0 	str	w0, [x23]
    fc_frame.data[0] = FC_PCI_BYTE_1(3);
  404b2c:	52810660 	mov	w0, #0x833                 	// #2099
  404b30:	790113e0 	strh	w0, [sp, #136]
    fc_frame.length = DATA_SIZE_FC;
  404b34:	52800060 	mov	w0, #0x3                   	// #3
  404b38:	390243e0 	strb	w0, [sp, #144]
	z_impl_k_sem_reset(sem);
  404b3c:	f0000138 	adrp	x24, 42b000 <__FRAME_END__+0xff4c>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404b40:	f0000134 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
    send_frame_series(&fc_frame, 1, rx_addr);
  404b44:	910223f9 	add	x25, sp, #0x88
  404b48:	f947fb16 	ldr	x22, [x24, #4080]
  404b4c:	aa1603e0 	mov	x0, x22
  404b50:	94002b81 	bl	40f954 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404b54:	f9470e94 	ldr	x20, [x20, #3608]
  404b58:	aa1303e1 	mov	x1, x19
  404b5c:	92800084 	mov	x4, #0xfffffffffffffffb    	// #-5
  404b60:	52800023 	mov	w3, #0x1                   	// #1
  404b64:	aa1403e0 	mov	x0, x20
  404b68:	d2802202 	mov	x2, #0x110                 	// #272
  404b6c:	97fffae2 	bl	4036f4 <isotp_fast_send>
  404b70:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404b74:	90000080 	adrp	x0, 414000 <dlc_table.0+0x78d>
  404b78:	710000df 	cmp	w6, #0x0
  404b7c:	9106641b 	add	x27, x0, #0x199
  404b80:	f0000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  404b84:	91220c1a 	add	x26, x0, #0x883
  404b88:	aa1b03e4 	mov	x4, x27
  404b8c:	aa1a03e2 	mov	x2, x26
  404b90:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  404b94:	912528a5 	add	x5, x5, #0x94a
  404b98:	52805463 	mov	w3, #0x2a3                 	// #675
  404b9c:	1a9f17e0 	cset	w0, eq  // eq = none
  404ba0:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404ba4:	91303c21 	add	x1, x1, #0xc0f
  404ba8:	97fffbd5 	bl	403afc <z_zassert.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404bac:	aa1503e0 	mov	x0, x21
  404bb0:	d2800021 	mov	x1, #0x1                   	// #1
  404bb4:	97fffe88 	bl	4045d4 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  404bb8:	52804022 	mov	w2, #0x201                 	// #513
  404bbc:	aa1903e0 	mov	x0, x25
  404bc0:	72a31b42 	movk	w2, #0x18da, lsl #16
  404bc4:	d2800021 	mov	x1, #0x1                   	// #1
  404bc8:	97fffc79 	bl	403dac <send_frame_series>
	return z_impl_k_sem_take(sem, timeout);
  404bcc:	d2800281 	mov	x1, #0x14                  	// #20
  404bd0:	aa1603e0 	mov	x0, x22
  404bd4:	94002aef 	bl	40f790 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  404bd8:	f000007c 	adrp	x28, 413000 <z_impl_k_uptime_ticks>
  404bdc:	7100001f 	cmp	w0, #0x0
  404be0:	9139038b 	add	x11, x28, #0xe40
  404be4:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404be8:	91256c2a 	add	x10, x1, #0x95b
  404bec:	aa0a03e1 	mov	x1, x10
  404bf0:	aa0b03e5 	mov	x5, x11
  404bf4:	aa1b03e4 	mov	x4, x27
  404bf8:	aa1a03e2 	mov	x2, x26
  404bfc:	1a9f17e0 	cset	w0, eq  // eq = none
  404c00:	52805503 	mov	w3, #0x2a8                 	// #680
  404c04:	a9062fea 	stp	x10, x11, [sp, #96]
  404c08:	97fffbbd 	bl	403afc <z_zassert.constprop.0>
    can_remove_rx_filter(can_dev, filter_id);
  404c0c:	b94002e1 	ldr	w1, [x23]
	return api->remove_rx_filter(dev, filter_id);
  404c10:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404c14:	f9472000 	ldr	x0, [x0, #3648]
  404c18:	f9400802 	ldr	x2, [x0, #16]
  404c1c:	f9401c42 	ldr	x2, [x2, #56]
  404c20:	d63f0040 	blr	x2
    ret = isotp_fast_send(&ctx, random_data, 5 * 1024, rx_node_id, NULL);
  404c24:	aa1303e1 	mov	x1, x19
  404c28:	aa1403e0 	mov	x0, x20
  404c2c:	d2800004 	mov	x4, #0x0                   	// #0
  404c30:	52800023 	mov	w3, #0x1                   	// #1
  404c34:	d2828002 	mov	x2, #0x1400                	// #5120
  404c38:	97fffaaf 	bl	4036f4 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_BUFFER_OVERFLW, "Expected overflow but got %d", ret);
  404c3c:	3100201f 	cmn	w0, #0x8
    ret = isotp_fast_send(&ctx, random_data, 5 * 1024, rx_node_id, NULL);
  404c40:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_BUFFER_OVERFLW, "Expected overflow but got %d", ret);
  404c44:	aa1b03e4 	mov	x4, x27
  404c48:	aa1a03e2 	mov	x2, x26
  404c4c:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  404c50:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404c54:	913988a5 	add	x5, x5, #0xe62
  404c58:	9139fc21 	add	x1, x1, #0xe7f
  404c5c:	1a9f17e0 	cset	w0, eq  // eq = none
  404c60:	528055c3 	mov	w3, #0x2ae                 	// #686
  404c64:	97fffba6 	bl	403afc <z_zassert.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404c68:	52802040 	mov	w0, #0x102                 	// #258
  404c6c:	72a31b40 	movk	w0, #0x18da, lsl #16
  404c70:	97fffc13 	bl	403cbc <add_rx_msgq.constprop.0>
  404c74:	b90002e0 	str	w0, [x23]
	z_impl_k_sem_reset(sem);
  404c78:	aa1603e0 	mov	x0, x22
  404c7c:	94002b36 	bl	40f954 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404c80:	928000e4 	mov	x4, #0xfffffffffffffff8    	// #-8
  404c84:	52800023 	mov	w3, #0x1                   	// #1
  404c88:	d2802202 	mov	x2, #0x110                 	// #272
  404c8c:	aa1303e1 	mov	x1, x19
  404c90:	aa1403e0 	mov	x0, x20
  404c94:	97fffa98 	bl	4036f4 <isotp_fast_send>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404c98:	aa1503e0 	mov	x0, x21
  404c9c:	d2800021 	mov	x1, #0x1                   	// #1
  404ca0:	97fffe4d 	bl	4045d4 <check_frame_series.constprop.0>
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_OVFLW);
  404ca4:	52800640 	mov	w0, #0x32                  	// #50
    send_frame_series(&fc_frame, 1, rx_addr);
  404ca8:	52804022 	mov	w2, #0x201                 	// #513
  404cac:	72a31b42 	movk	w2, #0x18da, lsl #16
  404cb0:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_OVFLW);
  404cb4:	390223e0 	strb	w0, [sp, #136]
    send_frame_series(&fc_frame, 1, rx_addr);
  404cb8:	aa1903e0 	mov	x0, x25
  404cbc:	97fffc3c 	bl	403dac <send_frame_series>
	return z_impl_k_sem_take(sem, timeout);
  404cc0:	d2800281 	mov	x1, #0x14                  	// #20
  404cc4:	aa1603e0 	mov	x0, x22
  404cc8:	94002ab2 	bl	40f790 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  404ccc:	7100001f 	cmp	w0, #0x0
  404cd0:	a9462fea 	ldp	x10, x11, [sp, #96]
  404cd4:	aa1b03e4 	mov	x4, x27
  404cd8:	aa1a03e2 	mov	x2, x26
  404cdc:	1a9f17e0 	cset	w0, eq  // eq = none
  404ce0:	52805723 	mov	w3, #0x2b9                 	// #697
  404ce4:	aa0b03e5 	mov	x5, x11
  404ce8:	aa0a03e1 	mov	x1, x10
  404cec:	97fffb84 	bl	403afc <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  404cf0:	aa1603e0 	mov	x0, x22
  404cf4:	94002b18 	bl	40f954 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404cf8:	928000c4 	mov	x4, #0xfffffffffffffff9    	// #-7
  404cfc:	52800023 	mov	w3, #0x1                   	// #1
  404d00:	d2802202 	mov	x2, #0x110                 	// #272
  404d04:	aa1303e1 	mov	x1, x19
  404d08:	aa1403e0 	mov	x0, x20
  404d0c:	97fffa7a 	bl	4036f4 <isotp_fast_send>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404d10:	aa1503e0 	mov	x0, x21
  404d14:	d2800021 	mov	x1, #0x1                   	// #1
        send_frame_series(&fc_frame, 1, rx_addr);
  404d18:	52804034 	mov	w20, #0x201                 	// #513
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404d1c:	97fffe2e 	bl	4045d4 <check_frame_series.constprop.0>
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_WAIT);
  404d20:	52800620 	mov	w0, #0x31                  	// #49
  404d24:	52800173 	mov	w19, #0xb                   	// #11
        send_frame_series(&fc_frame, 1, rx_addr);
  404d28:	72a31b54 	movk	w20, #0x18da, lsl #16
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_WAIT);
  404d2c:	390223e0 	strb	w0, [sp, #136]
        send_frame_series(&fc_frame, 1, rx_addr);
  404d30:	2a1403e2 	mov	w2, w20
  404d34:	aa1903e0 	mov	x0, x25
  404d38:	d2800021 	mov	x1, #0x1                   	// #1
  404d3c:	97fffc1c 	bl	403dac <send_frame_series>
    for (i = 0; i < CONFIG_ISOTP_WFTMAX + 1; i++) {
  404d40:	71000673 	subs	w19, w19, #0x1
  404d44:	54ffff61 	b.ne	404d30 <_isotp_fast_conformance_async_test_sender_fc_errors_wrapper+0x27c>  // b.any
	return z_impl_k_sem_take(sem, timeout);
  404d48:	f947fb00 	ldr	x0, [x24, #4080]
  404d4c:	d2800281 	mov	x1, #0x14                  	// #20
  404d50:	94002a90 	bl	40f790 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  404d54:	7100001f 	cmp	w0, #0x0
  404d58:	90000080 	adrp	x0, 414000 <dlc_table.0+0x78d>
  404d5c:	91066404 	add	x4, x0, #0x199
  404d60:	f0000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  404d64:	91220c02 	add	x2, x0, #0x883
  404d68:	f0000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  404d6c:	91390385 	add	x5, x28, #0xe40
  404d70:	91256c01 	add	x1, x0, #0x95b
  404d74:	528058e3 	mov	w3, #0x2c7                 	// #711
  404d78:	1a9f17e0 	cset	w0, eq  // eq = none
  404d7c:	97fffb60 	bl	403afc <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  404d80:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404d84:	f9476800 	ldr	x0, [x0, #3792]
  404d88:	f9404fe2 	ldr	x2, [sp, #152]
  404d8c:	f9400001 	ldr	x1, [x0]
  404d90:	eb010042 	subs	x2, x2, x1
  404d94:	d2800001 	mov	x1, #0x0                   	// #0
  404d98:	54000040 	b.eq	404da0 <_isotp_fast_conformance_async_test_sender_fc_errors_wrapper+0x2ec>  // b.none
  404d9c:	97fff161 	bl	401320 <__stack_chk_fail@plt>
  404da0:	a94153f3 	ldp	x19, x20, [sp, #16]
  404da4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404da8:	a94363f7 	ldp	x23, x24, [sp, #48]
  404dac:	a9446bf9 	ldp	x25, x26, [sp, #64]
  404db0:	a94573fb 	ldp	x27, x28, [sp, #80]
  404db4:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  404db8:	d65f03c0 	ret

0000000000404dbc <_isotp_fast_conformance_async_test_receiver_fc_errors_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  404dbc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  404dc0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404dc4:	910003fd 	mov	x29, sp
  404dc8:	f9476800 	ldr	x0, [x0, #3792]
  404dcc:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404dd0:	90000094 	adrp	x20, 414000 <dlc_table.0+0x78d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  404dd4:	f9400001 	ldr	x1, [x0]
  404dd8:	f90027e1 	str	x1, [sp, #72]
  404ddc:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  404de0:	52820220 	mov	w0, #0x1011                	// #4113
  404de4:	790043e0 	strh	w0, [sp, #32]
  404de8:	90000080 	adrp	x0, 414000 <dlc_table.0+0x78d>
  404dec:	910d7000 	add	x0, x0, #0x35c
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  404df0:	3900cbff 	strb	wzr, [sp, #50]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404df4:	91083a94 	add	x20, x20, #0x20e
  404df8:	f0000073 	adrp	x19, 413000 <z_impl_k_uptime_ticks>
  404dfc:	91220e73 	add	x19, x19, #0x883
  404e00:	b9400001 	ldr	w1, [x0]
  404e04:	79400800 	ldrh	w0, [x0, #4]
  404e08:	79004fe0 	strh	w0, [sp, #38]
    ff_frame.length = DATA_SIZE_FF + 2;
  404e0c:	52800100 	mov	w0, #0x8                   	// #8
  404e10:	3900a3e0 	strb	w0, [sp, #40]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404e14:	52810600 	mov	w0, #0x830                 	// #2096
  404e18:	790063e0 	strh	w0, [sp, #48]
    fc_frame.length = DATA_SIZE_FC;
  404e1c:	52800060 	mov	w0, #0x3                   	// #3
  404e20:	3900e3e0 	strb	w0, [sp, #56]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404e24:	52802040 	mov	w0, #0x102                 	// #258
  404e28:	b80223e1 	stur	w1, [sp, #34]
  404e2c:	72a31b40 	movk	w0, #0x18da, lsl #16
  404e30:	97fffba3 	bl	403cbc <add_rx_msgq.constprop.0>
  404e34:	2a0003e6 	mov	w6, w0
  404e38:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404e3c:	aa1403e4 	mov	x4, x20
  404e40:	52804ea3 	mov	w3, #0x275                 	// #629
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404e44:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404e48:	aa1303e2 	mov	x2, x19
  404e4c:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  404e50:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404e54:	912664a5 	add	x5, x5, #0x999
  404e58:	9126d421 	add	x1, x1, #0x9b5
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404e5c:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404e60:	2a2603e0 	mvn	w0, w6
  404e64:	531f7c00 	lsr	w0, w0, #31
  404e68:	97fffb25 	bl	403afc <z_zassert.constprop.0>
    send_frame_series(&ff_frame, 1, rx_addr);
  404e6c:	52804022 	mov	w2, #0x201                 	// #513
  404e70:	910083e0 	add	x0, sp, #0x20
  404e74:	72a31b42 	movk	w2, #0x18da, lsl #16
  404e78:	d2800021 	mov	x1, #0x1                   	// #1
  404e7c:	97fffbcc 	bl	403dac <send_frame_series>
    check_frame_series(&fc_frame, 1, &frame_msgq);
  404e80:	9100c3e0 	add	x0, sp, #0x30
  404e84:	d2800021 	mov	x1, #0x1                   	// #1
  404e88:	97fffdd3 	bl	4045d4 <check_frame_series.constprop.0>
    ret = blocking_recv(tiny_buf, sizeof(tiny_buf), K_MSEC(200));
  404e8c:	d2800282 	mov	x2, #0x14                  	// #20
  404e90:	d2800101 	mov	x1, #0x8                   	// #8
  404e94:	910103e0 	add	x0, sp, #0x40
  404e98:	97fffa8f 	bl	4038d4 <blocking_recv>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  404e9c:	7100181f 	cmp	w0, #0x6
  404ea0:	aa1403e4 	mov	x4, x20
  404ea4:	aa1303e2 	mov	x2, x19
  404ea8:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  404eac:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404eb0:	9127cca5 	add	x5, x5, #0x9f3
  404eb4:	91285821 	add	x1, x1, #0xa16
  404eb8:	52805043 	mov	w3, #0x282                 	// #642
    ret = blocking_recv(tiny_buf, sizeof(tiny_buf), K_MSEC(200));
  404ebc:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  404ec0:	1a9f17e0 	cset	w0, eq  // eq = none
  404ec4:	97fffb0e 	bl	403afc <z_zassert.constprop.0>
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), random_data + DATA_SIZE_FF,
  404ec8:	d2807f40 	mov	x0, #0x3fa                 	// #1018
  404ecc:	97fffaf0 	bl	403a8c <prepare_cf_frames.constprop.0>
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  404ed0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404ed4:	52800461 	mov	w1, #0x23                  	// #35
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  404ed8:	52804022 	mov	w2, #0x201                 	// #513
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  404edc:	f947bc00 	ldr	x0, [x0, #3960]
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  404ee0:	72a31b42 	movk	w2, #0x18da, lsl #16
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  404ee4:	39002401 	strb	w1, [x0, #9]
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  404ee8:	d28004c1 	mov	x1, #0x26                  	// #38
  404eec:	97fffbb0 	bl	403dac <send_frame_series>
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  404ef0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404ef4:	d2800282 	mov	x2, #0x14                  	// #20
  404ef8:	d2801001 	mov	x1, #0x80                  	// #128
  404efc:	f9471000 	ldr	x0, [x0, #3616]
  404f00:	97fffa75 	bl	4038d4 <blocking_recv>
    zassert_equal(ret, ISOTP_N_WRONG_SN, "Expected wrong SN but got %d", ret);
  404f04:	3100101f 	cmn	w0, #0x4
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  404f08:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_WRONG_SN, "Expected wrong SN but got %d", ret);
  404f0c:	aa1303e2 	mov	x2, x19
  404f10:	1a9f17e0 	cset	w0, eq  // eq = none
  404f14:	aa1403e4 	mov	x4, x20
  404f18:	f0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  404f1c:	52805163 	mov	w3, #0x28b                 	// #651
  404f20:	913aa4a5 	add	x5, x5, #0xea9
  404f24:	f0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  404f28:	913b1821 	add	x1, x1, #0xec6
  404f2c:	97fffaf4 	bl	403afc <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  404f30:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404f34:	f9476800 	ldr	x0, [x0, #3792]
  404f38:	f94027e2 	ldr	x2, [sp, #72]
  404f3c:	f9400001 	ldr	x1, [x0]
  404f40:	eb010042 	subs	x2, x2, x1
  404f44:	d2800001 	mov	x1, #0x0                   	// #0
  404f48:	54000040 	b.eq	404f50 <_isotp_fast_conformance_async_test_receiver_fc_errors_wrapper+0x194>  // b.none
  404f4c:	97fff0f5 	bl	401320 <__stack_chk_fail@plt>
  404f50:	a94153f3 	ldp	x19, x20, [sp, #16]
  404f54:	a8c57bfd 	ldp	x29, x30, [sp], #80
  404f58:	d65f03c0 	ret

0000000000404f5c <_isotp_fast_conformance_async_test_send_data_blocks_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  404f5c:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  404f60:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  404f64:	910003fd 	mov	x29, sp
  404f68:	f9476800 	ldr	x0, [x0, #3792]
  404f6c:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404f70:	90000094 	adrp	x20, 414000 <dlc_table.0+0x78d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  404f74:	a9025bf5 	stp	x21, x22, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404f78:	910c5a94 	add	x20, x20, #0x316
  404f7c:	f0000073 	adrp	x19, 413000 <z_impl_k_uptime_ticks>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  404f80:	a90363f7 	stp	x23, x24, [sp, #48]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404f84:	91220e73 	add	x19, x19, #0x883
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  404f88:	f0000137 	adrp	x23, 42b000 <__FRAME_END__+0xff4c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  404f8c:	a9046bf9 	stp	x25, x26, [sp, #64]
    check_frame_series(data_frame_ptr, fc_opts.bs, &frame_msgq);
  404f90:	f0000139 	adrp	x25, 42b000 <__FRAME_END__+0xff4c>
    send_frame_series(&fc_frame, 1, rx_addr);
  404f94:	910163fa 	add	x26, sp, #0x58
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  404f98:	f9400001 	ldr	x1, [x0]
  404f9c:	f90047e1 	str	x1, [sp, #136]
  404fa0:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  404fa4:	52820220 	mov	w0, #0x1011                	// #4113
  404fa8:	7900d3e0 	strh	w0, [sp, #104]
  404fac:	90000080 	adrp	x0, 414000 <dlc_table.0+0x78d>
  404fb0:	910d7000 	add	x0, x0, #0x35c
    fc_frame.data[2] = FC_PCI_BYTE_3(0);
  404fb4:	39016bff 	strb	wzr, [sp, #90]
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  404fb8:	9101e3f8 	add	x24, sp, #0x78
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  404fbc:	f0000076 	adrp	x22, 413000 <z_impl_k_uptime_ticks>
  404fc0:	f0000075 	adrp	x21, 413000 <z_impl_k_uptime_ticks>
  404fc4:	9128dad6 	add	x22, x22, #0xa36
  404fc8:	b9400001 	ldr	w1, [x0]
  404fcc:	9130feb5 	add	x21, x21, #0xc3f
  404fd0:	79400800 	ldrh	w0, [x0, #4]
  404fd4:	7900dfe0 	strh	w0, [sp, #110]
    ff_frame.length = DATA_SIZE_FF + 2;
  404fd8:	52800100 	mov	w0, #0x8                   	// #8
  404fdc:	3901c3e0 	strb	w0, [sp, #112]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404fe0:	52810600 	mov	w0, #0x830                 	// #2096
  404fe4:	7900b3e0 	strh	w0, [sp, #88]
    fc_frame.length = DATA_SIZE_FC;
  404fe8:	52800060 	mov	w0, #0x3                   	// #3
  404fec:	390183e0 	strb	w0, [sp, #96]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  404ff0:	d2802140 	mov	x0, #0x10a                 	// #266
  404ff4:	b806a3e1 	stur	w1, [sp, #106]
  404ff8:	97fffaa5 	bl	403a8c <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404ffc:	52802040 	mov	w0, #0x102                 	// #258
  405000:	72a31b40 	movk	w0, #0x18da, lsl #16
  405004:	97fffb2e 	bl	403cbc <add_rx_msgq.constprop.0>
  405008:	2a0003e6 	mov	w6, w0
  40500c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405010:	aa1403e4 	mov	x4, x20
  405014:	aa1303e2 	mov	x2, x19
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405018:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40501c:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  405020:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  405024:	912664a5 	add	x5, x5, #0x999
  405028:	9126d421 	add	x1, x1, #0x9b5
  40502c:	52802ca3 	mov	w3, #0x165                 	// #357
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405030:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405034:	2a2603e0 	mvn	w0, w6
  405038:	531f7c00 	lsr	w0, w0, #31
  40503c:	97fffab0 	bl	403afc <z_zassert.constprop.0>
    send_test_data(random_data, DATA_SEND_LENGTH);
  405040:	d2802200 	mov	x0, #0x110                 	// #272
  405044:	97fffb06 	bl	403c5c <send_test_data.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  405048:	9101a3e0 	add	x0, sp, #0x68
  40504c:	d2800021 	mov	x1, #0x1                   	// #1
  405050:	97fffd61 	bl	4045d4 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  405054:	52804022 	mov	w2, #0x201                 	// #513
  405058:	aa1a03e0 	mov	x0, x26
  40505c:	72a31b42 	movk	w2, #0x18da, lsl #16
  405060:	d2800021 	mov	x1, #0x1                   	// #1
  405064:	97fffb52 	bl	403dac <send_frame_series>
    check_frame_series(data_frame_ptr, fc_opts.bs, &frame_msgq);
  405068:	f947bf39 	ldr	x25, [x25, #3960]
  40506c:	d2800101 	mov	x1, #0x8                   	// #8
  405070:	aa1903e0 	mov	x0, x25
  405074:	97fffd58 	bl	4045d4 <check_frame_series.constprop.0>
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405078:	f947e2f7 	ldr	x23, [x23, #4032]
  40507c:	aa1803e1 	mov	x1, x24
  405080:	d28000a2 	mov	x2, #0x5                   	// #5
  405084:	aa1703e0 	mov	x0, x23
  405088:	97fffa12 	bl	4038d0 <k_msgq_get>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  40508c:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405090:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405094:	aa1603e5 	mov	x5, x22
  405098:	aa1403e4 	mov	x4, x20
  40509c:	1a9f17e0 	cset	w0, eq  // eq = none
  4050a0:	52802e43 	mov	w3, #0x172                 	// #370
  4050a4:	aa1303e2 	mov	x2, x19
  4050a8:	aa1503e1 	mov	x1, x21
  4050ac:	97fffa94 	bl	403afc <z_zassert.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  4050b0:	52804022 	mov	w2, #0x201                 	// #513
    fc_frame.data[1] = FC_PCI_BYTE_2(2);
  4050b4:	52800040 	mov	w0, #0x2                   	// #2
    send_frame_series(&fc_frame, 1, rx_addr);
  4050b8:	72a31b42 	movk	w2, #0x18da, lsl #16
  4050bc:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[1] = FC_PCI_BYTE_2(2);
  4050c0:	390167e0 	strb	w0, [sp, #89]
    send_frame_series(&fc_frame, 1, rx_addr);
  4050c4:	aa1a03e0 	mov	x0, x26
  4050c8:	97fffb39 	bl	403dac <send_frame_series>
    check_frame_series(data_frame_ptr, 2, &frame_msgq);
  4050cc:	91012320 	add	x0, x25, #0x48
  4050d0:	d2800041 	mov	x1, #0x2                   	// #2
  4050d4:	97fffd40 	bl	4045d4 <check_frame_series.constprop.0>
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  4050d8:	aa1803e1 	mov	x1, x24
  4050dc:	d28000a2 	mov	x2, #0x5                   	// #5
  4050e0:	aa1703e0 	mov	x0, x23
  4050e4:	97fff9fb 	bl	4038d0 <k_msgq_get>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  4050e8:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  4050ec:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  4050f0:	aa1603e5 	mov	x5, x22
  4050f4:	aa1403e4 	mov	x4, x20
  4050f8:	1a9f17e0 	cset	w0, eq  // eq = none
  4050fc:	52802f83 	mov	w3, #0x17c                 	// #380
  405100:	aa1303e2 	mov	x2, x19
  405104:	aa1503e1 	mov	x1, x21
  405108:	97fffa7d 	bl	403afc <z_zassert.constprop.0>
    fc_frame.data[1] = FC_PCI_BYTE_2(0);
  40510c:	390167ff 	strb	wzr, [sp, #89]
    send_frame_series(&fc_frame, 1, rx_addr);
  405110:	52804022 	mov	w2, #0x201                 	// #513
  405114:	aa1a03e0 	mov	x0, x26
  405118:	72a31b42 	movk	w2, #0x18da, lsl #16
  40511c:	d2800021 	mov	x1, #0x1                   	// #1
  405120:	97fffb23 	bl	403dac <send_frame_series>
    check_frame_series(data_frame_ptr, DIV_ROUND_UP(remaining_length, DATA_SIZE_CF), &frame_msgq);
  405124:	91016b20 	add	x0, x25, #0x5a
  405128:	d2800381 	mov	x1, #0x1c                  	// #28
  40512c:	97fffd2a 	bl	4045d4 <check_frame_series.constprop.0>
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405130:	aa1803e1 	mov	x1, x24
  405134:	d28000a2 	mov	x2, #0x5                   	// #5
  405138:	aa1703e0 	mov	x0, x23
  40513c:	97fff9e5 	bl	4038d0 <k_msgq_get>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405140:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405144:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405148:	aa1303e2 	mov	x2, x19
  40514c:	aa1503e1 	mov	x1, x21
  405150:	1a9f17e0 	cset	w0, eq  // eq = none
  405154:	aa1603e5 	mov	x5, x22
  405158:	aa1403e4 	mov	x4, x20
  40515c:	52803083 	mov	w3, #0x184                 	// #388
  405160:	97fffa67 	bl	403afc <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  405164:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405168:	f9476800 	ldr	x0, [x0, #3792]
  40516c:	f94047e2 	ldr	x2, [sp, #136]
  405170:	f9400001 	ldr	x1, [x0]
  405174:	eb010042 	subs	x2, x2, x1
  405178:	d2800001 	mov	x1, #0x0                   	// #0
  40517c:	54000040 	b.eq	405184 <_isotp_fast_conformance_async_test_send_data_blocks_wrapper+0x228>  // b.none
  405180:	97fff068 	bl	401320 <__stack_chk_fail@plt>
  405184:	a94153f3 	ldp	x19, x20, [sp, #16]
  405188:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40518c:	a94363f7 	ldp	x23, x24, [sp, #48]
  405190:	a9446bf9 	ldp	x25, x26, [sp, #64]
  405194:	a8c97bfd 	ldp	x29, x30, [sp], #144
  405198:	d65f03c0 	ret

000000000040519c <_isotp_fast_conformance_async_test_send_data_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data)
  40519c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4051a0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4051a4:	910003fd 	mov	x29, sp
  4051a8:	f9476800 	ldr	x0, [x0, #3792]
  4051ac:	f9400001 	ldr	x1, [x0]
  4051b0:	f9001fe1 	str	x1, [sp, #56]
  4051b4:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  4051b8:	52820220 	mov	w0, #0x1011                	// #4113
  4051bc:	790053e0 	strh	w0, [sp, #40]
  4051c0:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4051c4:	910d7000 	add	x0, x0, #0x35c
    fc_frame.data[2] = FC_PCI_BYTE_3(0);
  4051c8:	39006bff 	strb	wzr, [sp, #26]
  4051cc:	b9400001 	ldr	w1, [x0]
  4051d0:	79400800 	ldrh	w0, [x0, #4]
  4051d4:	79005fe0 	strh	w0, [sp, #46]
    ff_frame.length = CAN_DL;
  4051d8:	52800100 	mov	w0, #0x8                   	// #8
  4051dc:	3900c3e0 	strb	w0, [sp, #48]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  4051e0:	52800600 	mov	w0, #0x30                  	// #48
  4051e4:	790033e0 	strh	w0, [sp, #24]
    fc_frame.length = DATA_SIZE_FC;
  4051e8:	52800060 	mov	w0, #0x3                   	// #3
  4051ec:	390083e0 	strb	w0, [sp, #32]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  4051f0:	d2802140 	mov	x0, #0x10a                 	// #266
  4051f4:	b802a3e1 	stur	w1, [sp, #42]
  4051f8:	97fffa25 	bl	403a8c <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4051fc:	52802040 	mov	w0, #0x102                 	// #258
  405200:	72a31b40 	movk	w0, #0x18da, lsl #16
  405204:	97fffaae 	bl	403cbc <add_rx_msgq.constprop.0>
  405208:	2a0003e6 	mov	w6, w0
  40520c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405210:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  405214:	f0000064 	adrp	x4, 414000 <dlc_table.0+0x78d>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405218:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40521c:	912664a5 	add	x5, x5, #0x999
  405220:	9103bc84 	add	x4, x4, #0xef
  405224:	d0000062 	adrp	x2, 413000 <z_impl_k_uptime_ticks>
  405228:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  40522c:	91220c42 	add	x2, x2, #0x883
  405230:	9126d421 	add	x1, x1, #0x9b5
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405234:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405238:	2a2603e0 	mvn	w0, w6
  40523c:	528027c3 	mov	w3, #0x13e                 	// #318
  405240:	531f7c00 	lsr	w0, w0, #31
  405244:	97fffa2e 	bl	403afc <z_zassert.constprop.0>
    send_test_data(random_data, DATA_SEND_LENGTH);
  405248:	d2802200 	mov	x0, #0x110                 	// #272
  40524c:	97fffa84 	bl	403c5c <send_test_data.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  405250:	9100a3e0 	add	x0, sp, #0x28
  405254:	d2800021 	mov	x1, #0x1                   	// #1
  405258:	97fffcdf 	bl	4045d4 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  40525c:	52804022 	mov	w2, #0x201                 	// #513
  405260:	910063e0 	add	x0, sp, #0x18
  405264:	72a31b42 	movk	w2, #0x18da, lsl #16
  405268:	d2800021 	mov	x1, #0x1                   	// #1
  40526c:	97fffad0 	bl	403dac <send_frame_series>
    check_frame_series(des_frames, ARRAY_SIZE(des_frames), &frame_msgq);
  405270:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405274:	d28004c1 	mov	x1, #0x26                  	// #38
  405278:	f947bc00 	ldr	x0, [x0, #3960]
  40527c:	97fffcd6 	bl	4045d4 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data)
  405280:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405284:	f9476800 	ldr	x0, [x0, #3792]
  405288:	f9401fe2 	ldr	x2, [sp, #56]
  40528c:	f9400001 	ldr	x1, [x0]
  405290:	eb010042 	subs	x2, x2, x1
  405294:	d2800001 	mov	x1, #0x0                   	// #0
  405298:	54000040 	b.eq	4052a0 <_isotp_fast_conformance_async_test_send_data_wrapper+0x104>  // b.none
  40529c:	97fff021 	bl	401320 <__stack_chk_fail@plt>
  4052a0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4052a4:	d65f03c0 	ret

00000000004052a8 <_isotp_fast_conformance_async_test_send_sf_fixed_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  4052a8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4052ac:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4052b0:	910003fd 	mov	x29, sp
  4052b4:	f9476800 	ldr	x0, [x0, #3792]
  4052b8:	a90153f3 	stp	x19, x20, [sp, #16]
  4052bc:	f0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  4052c0:	910d7273 	add	x19, x19, #0x35c
  4052c4:	f90013f5 	str	x21, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4052c8:	d0000074 	adrp	x20, 413000 <z_impl_k_uptime_ticks>
  4052cc:	f0000075 	adrp	x21, 414000 <dlc_table.0+0x78d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  4052d0:	f9400001 	ldr	x1, [x0]
  4052d4:	f90027e1 	str	x1, [sp, #72]
  4052d8:	d2800001 	mov	x1, #0x0                   	// #0
    des_frame.data[0] = SF_PCI_BYTE_1;
  4052dc:	528000e0 	mov	w0, #0x7                   	// #7
  4052e0:	3900e3e0 	strb	w0, [sp, #56]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4052e4:	91220e94 	add	x20, x20, #0x883
  4052e8:	b9400260 	ldr	w0, [x19]
  4052ec:	91046eb5 	add	x21, x21, #0x11b
  4052f0:	b80393e0 	stur	w0, [sp, #57]
  4052f4:	b8403260 	ldur	w0, [x19, #3]
  4052f8:	b9003fe0 	str	w0, [sp, #60]
    des_frame.length = CAN_MAX_DLEN;
  4052fc:	52800100 	mov	w0, #0x8                   	// #8
  405300:	390103e0 	strb	w0, [sp, #64]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405304:	52802040 	mov	w0, #0x102                 	// #258
  405308:	72a31b40 	movk	w0, #0x18da, lsl #16
  40530c:	97fffa6c 	bl	403cbc <add_rx_msgq.constprop.0>
  405310:	2a0003e6 	mov	w6, w0
  405314:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405318:	aa1503e4 	mov	x4, x21
  40531c:	aa1403e2 	mov	x2, x20
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405320:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405324:	52802063 	mov	w3, #0x103                 	// #259
  405328:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  40532c:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  405330:	912664a5 	add	x5, x5, #0x999
  405334:	9126d421 	add	x1, x1, #0x9b5
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405338:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40533c:	2a2603e0 	mvn	w0, w6
  405340:	531f7c00 	lsr	w0, w0, #31
  405344:	97fff9ee 	bl	403afc <z_zassert.constprop.0>
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  405348:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40534c:	aa1303e1 	mov	x1, x19
  405350:	d2800004 	mov	x4, #0x0                   	// #0
  405354:	52800023 	mov	w3, #0x1                   	// #1
  405358:	f9470c00 	ldr	x0, [x0, #3608]
  40535c:	d28000e2 	mov	x2, #0x7                   	// #7
  405360:	97fff8e5 	bl	4036f4 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  405364:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  405368:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  40536c:	aa1403e2 	mov	x2, x20
  405370:	aa1503e4 	mov	x4, x21
  405374:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  405378:	912528a5 	add	x5, x5, #0x94a
  40537c:	528020c3 	mov	w3, #0x106                 	// #262
  405380:	1a9f17e0 	cset	w0, eq  // eq = none
  405384:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  405388:	91256c21 	add	x1, x1, #0x95b
  40538c:	97fff9dc 	bl	403afc <z_zassert.constprop.0>
    check_frame_series(&des_frame, 1, &frame_msgq);
  405390:	9100e3e0 	add	x0, sp, #0x38
  405394:	d2800021 	mov	x1, #0x1                   	// #1
  405398:	97fffc8f 	bl	4045d4 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  40539c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4053a0:	f9476800 	ldr	x0, [x0, #3792]
  4053a4:	f94027e2 	ldr	x2, [sp, #72]
  4053a8:	f9400001 	ldr	x1, [x0]
  4053ac:	eb010042 	subs	x2, x2, x1
  4053b0:	d2800001 	mov	x1, #0x0                   	// #0
  4053b4:	54000040 	b.eq	4053bc <_isotp_fast_conformance_async_test_send_sf_fixed_wrapper+0x114>  // b.none
  4053b8:	97ffefda 	bl	401320 <__stack_chk_fail@plt>
  4053bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4053c0:	f94013f5 	ldr	x21, [sp, #32]
  4053c4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4053c8:	d65f03c0 	ret

00000000004053cc <_isotp_fast_conformance_async_test_send_sf_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf)
  4053cc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4053d0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4053d4:	910003fd 	mov	x29, sp
  4053d8:	f9476800 	ldr	x0, [x0, #3792]
  4053dc:	a90153f3 	stp	x19, x20, [sp, #16]
  4053e0:	f0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  4053e4:	910d7273 	add	x19, x19, #0x35c
  4053e8:	f9400001 	ldr	x1, [x0]
  4053ec:	f9001fe1 	str	x1, [sp, #56]
  4053f0:	d2800001 	mov	x1, #0x0                   	// #0
    des_frame.data[0] = SF_PCI_BYTE_1;
  4053f4:	528000e0 	mov	w0, #0x7                   	// #7
  4053f8:	3900a3e0 	strb	w0, [sp, #40]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4053fc:	d0000074 	adrp	x20, 413000 <z_impl_k_uptime_ticks>
  405400:	91220e94 	add	x20, x20, #0x883
  405404:	b9400260 	ldr	w0, [x19]
  405408:	b80293e0 	stur	w0, [sp, #41]
  40540c:	b8403260 	ldur	w0, [x19, #3]
  405410:	b9002fe0 	str	w0, [sp, #44]
    des_frame.length = CAN_MAX_DLEN;
  405414:	52800100 	mov	w0, #0x8                   	// #8
  405418:	3900c3e0 	strb	w0, [sp, #48]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  40541c:	52802040 	mov	w0, #0x102                 	// #258
  405420:	72a31b40 	movk	w0, #0x18da, lsl #16
  405424:	97fffa26 	bl	403cbc <add_rx_msgq.constprop.0>
  405428:	2a0003e6 	mov	w6, w0
  40542c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405430:	aa1403e2 	mov	x2, x20
  405434:	52801aa3 	mov	w3, #0xd5                  	// #213
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405438:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40543c:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  405440:	f0000064 	adrp	x4, 414000 <dlc_table.0+0x78d>
  405444:	912664a5 	add	x5, x5, #0x999
  405448:	91073084 	add	x4, x4, #0x1cc
  40544c:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405450:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405454:	2a2603e0 	mvn	w0, w6
  405458:	9126d421 	add	x1, x1, #0x9b5
  40545c:	531f7c00 	lsr	w0, w0, #31
  405460:	97fff9a7 	bl	403afc <z_zassert.constprop.0>
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, NULL);
  405464:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405468:	aa1303e1 	mov	x1, x19
  40546c:	d2800004 	mov	x4, #0x0                   	// #0
  405470:	52800023 	mov	w3, #0x1                   	// #1
  405474:	f9470c00 	ldr	x0, [x0, #3608]
  405478:	d28000e2 	mov	x2, #0x7                   	// #7
  40547c:	97fff89e 	bl	4036f4 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  405480:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, NULL);
  405484:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  405488:	aa1403e2 	mov	x2, x20
  40548c:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  405490:	f0000064 	adrp	x4, 414000 <dlc_table.0+0x78d>
  405494:	912528a5 	add	x5, x5, #0x94a
  405498:	91061484 	add	x4, x4, #0x185
  40549c:	52800663 	mov	w3, #0x33                  	// #51
  4054a0:	1a9f17e0 	cset	w0, eq  // eq = none
  4054a4:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  4054a8:	91256c21 	add	x1, x1, #0x95b
  4054ac:	97fff994 	bl	403afc <z_zassert.constprop.0>
    check_frame_series(&des_frame, 1, &frame_msgq);
  4054b0:	9100a3e0 	add	x0, sp, #0x28
  4054b4:	d2800021 	mov	x1, #0x1                   	// #1
  4054b8:	97fffc47 	bl	4045d4 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf)
  4054bc:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4054c0:	f9476800 	ldr	x0, [x0, #3792]
  4054c4:	f9401fe2 	ldr	x2, [sp, #56]
  4054c8:	f9400001 	ldr	x1, [x0]
  4054cc:	eb010042 	subs	x2, x2, x1
  4054d0:	d2800001 	mov	x1, #0x0                   	// #0
  4054d4:	54000040 	b.eq	4054dc <_isotp_fast_conformance_async_test_send_sf_wrapper+0x110>  // b.none
  4054d8:	97ffef92 	bl	401320 <__stack_chk_fail@plt>
  4054dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4054e0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4054e4:	d65f03c0 	ret

00000000004054e8 <receive_test_data.constprop.0>:
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4054e8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  4054ec:	910003fd 	mov	x29, sp
  4054f0:	a90153f3 	stp	x19, x20, [sp, #16]
   case no work is done at all.  We detect these problems by referring
   non-existing functions.  */
__fortify_function void *
__NTH (memset (void *__dest, int __ch, size_t __len))
{
  return __builtin___memset_chk (__dest, __ch, __len,
  4054f4:	d0000133 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  4054f8:	d0000074 	adrp	x20, 413000 <z_impl_k_uptime_ticks>
  4054fc:	f9471273 	ldr	x19, [x19, #3616]
  405500:	91220e94 	add	x20, x20, #0x883
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  405504:	a9025bf5 	stp	x21, x22, [sp, #32]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  405508:	f0000075 	adrp	x21, 414000 <dlc_table.0+0x78d>
  40550c:	910c12b5 	add	x21, x21, #0x304
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  405510:	a90363f7 	stp	x23, x24, [sp, #48]
    const uint8_t *data_ptr = data;
  405514:	f0000077 	adrp	x23, 414000 <dlc_table.0+0x78d>
  405518:	910d72f7 	add	x23, x23, #0x35c
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  40551c:	a9046bf9 	stp	x25, x26, [sp, #64]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  405520:	d000007a 	adrp	x26, 413000 <z_impl_k_uptime_ticks>
  405524:	913be75a 	add	x26, x26, #0xef9
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  405528:	f9002bfb 	str	x27, [sp, #80]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  40552c:	d000007b 	adrp	x27, 413000 <z_impl_k_uptime_ticks>
  405530:	913bab7b 	add	x27, x27, #0xeea
    size_t remaining_len = len;
  405534:	d2802219 	mov	x25, #0x110                 	// #272
  405538:	4f000400 	movi	v0.4s, #0x0
        recv_len = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  40553c:	d2800c82 	mov	x2, #0x64                  	// #100
  405540:	d2801001 	mov	x1, #0x80                  	// #128
  405544:	aa1303e0 	mov	x0, x19
  405548:	ad000260 	stp	q0, q0, [x19]
  40554c:	ad010260 	stp	q0, q0, [x19, #32]
  405550:	ad020260 	stp	q0, q0, [x19, #64]
  405554:	ad030260 	stp	q0, q0, [x19, #96]
  405558:	97fff8df 	bl	4038d4 <blocking_recv>
  40555c:	93407c18 	sxtw	x24, w0
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  405560:	2a3803e0 	mvn	w0, w24
  405564:	2a1803e6 	mov	w6, w24
  405568:	aa1b03e5 	mov	x5, x27
  40556c:	aa1503e4 	mov	x4, x21
  405570:	aa1403e2 	mov	x2, x20
  405574:	aa1a03e1 	mov	x1, x26
  405578:	52800b83 	mov	w3, #0x5c                  	// #92
  40557c:	531f7c00 	lsr	w0, w0, #31
  405580:	97fff95f 	bl	403afc <z_zassert.constprop.0>
        zassert_true(remaining_len >= recv_len, "More data than expected");
  405584:	eb38c33f 	cmp	x25, w24, sxtw
  405588:	aa1503e4 	mov	x4, x21
  40558c:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  405590:	913c48a5 	add	x5, x5, #0xf12
  405594:	52800bc3 	mov	w3, #0x5e                  	// #94
  405598:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
  40559c:	aa1403e2 	mov	x2, x20
  4055a0:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  4055a4:	913ca821 	add	x1, x1, #0xf2a
  4055a8:	97fff955 	bl	403afc <z_zassert.constprop.0>
        ret = check_data(data_buf, data_ptr, recv_len);
  4055ac:	aa1703e1 	mov	x1, x23
  4055b0:	aa1803e2 	mov	x2, x24
  4055b4:	aa1303e0 	mov	x0, x19
  4055b8:	97fffbda 	bl	404520 <check_data>
        zassert_equal(ret, 0, "Data differ");
  4055bc:	7100001f 	cmp	w0, #0x0
  4055c0:	aa1503e4 	mov	x4, x21
  4055c4:	1a9f17e0 	cset	w0, eq  // eq = none
  4055c8:	aa1403e2 	mov	x2, x20
  4055cc:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  4055d0:	52800c03 	mov	w3, #0x60                  	// #96
  4055d4:	9134f8a5 	add	x5, x5, #0xd3e
  4055d8:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  4055dc:	91256c21 	add	x1, x1, #0x95b
  4055e0:	97fff947 	bl	403afc <z_zassert.constprop.0>
        data_ptr += recv_len;
  4055e4:	8b1802f7 	add	x23, x23, x24
    } while (remaining_len);
  4055e8:	eb180339 	subs	x25, x25, x24
  4055ec:	54fffa61 	b.ne	405538 <receive_test_data.constprop.0+0x50>  // b.any
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(50));
  4055f0:	aa1303e0 	mov	x0, x19
  4055f4:	d28000a2 	mov	x2, #0x5                   	// #5
  4055f8:	d2801001 	mov	x1, #0x80                  	// #128
  4055fc:	97fff8b6 	bl	4038d4 <blocking_recv>
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  405600:	aa1503e4 	mov	x4, x21
  405604:	aa1403e2 	mov	x2, x20
}
  405608:	a94153f3 	ldp	x19, x20, [sp, #16]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  40560c:	3100381f 	cmn	w0, #0xe
}
  405610:	a9425bf5 	ldp	x21, x22, [sp, #32]
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(50));
  405614:	2a0003e6 	mov	w6, w0
}
  405618:	a94363f7 	ldp	x23, x24, [sp, #48]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  40561c:	1a9f17e0 	cset	w0, eq  // eq = none
}
  405620:	a9446bf9 	ldp	x25, x26, [sp, #64]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  405624:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
}
  405628:	f9402bfb 	ldr	x27, [sp, #80]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  40562c:	9128d8a5 	add	x5, x5, #0xa36
}
  405630:	a8c67bfd 	ldp	x29, x30, [sp], #96
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  405634:	52800d43 	mov	w3, #0x6a                  	// #106
  405638:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  40563c:	91249021 	add	x1, x1, #0x924
  405640:	17fff92f 	b	403afc <z_zassert.constprop.0>

0000000000405644 <_isotp_fast_conformance_async_test_receive_data_blocks_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405644:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  405648:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40564c:	910003fd 	mov	x29, sp
  405650:	f9476800 	ldr	x0, [x0, #3792]
  405654:	a90153f3 	stp	x19, x20, [sp, #16]
  405658:	d0000133 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  40565c:	a9025bf5 	stp	x21, x22, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405660:	f0000075 	adrp	x21, 414000 <dlc_table.0+0x78d>
  405664:	d0000076 	adrp	x22, 413000 <z_impl_k_uptime_ticks>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405668:	a90363f7 	stp	x23, x24, [sp, #48]
        check_frame_series(&fc_frame, 1, &frame_msgq);
  40566c:	910163f7 	add	x23, sp, #0x58
    while (remaining_frames) {
  405670:	d2800014 	mov	x20, #0x0                   	// #0
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405674:	f90023f9 	str	x25, [sp, #64]
            send_frame_series(data_frame_ptr, fc_opts.bs, rx_addr);
  405678:	52804039 	mov	w25, #0x201                 	// #513
  40567c:	72a31b59 	movk	w25, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405680:	f9400001 	ldr	x1, [x0]
  405684:	f90047e1 	str	x1, [sp, #136]
  405688:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  40568c:	52820220 	mov	w0, #0x1011                	// #4113
  405690:	7900d3e0 	strh	w0, [sp, #104]
  return __builtin___memcpy_chk (__dest, __src, __len,
  405694:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  405698:	910d7000 	add	x0, x0, #0x35c
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  40569c:	39016bff 	strb	wzr, [sp, #90]
  4056a0:	b9400001 	ldr	w1, [x0]
  4056a4:	79400800 	ldrh	w0, [x0, #4]
  4056a8:	7900dfe0 	strh	w0, [sp, #110]
    ff_frame.length = DATA_SIZE_FF + 2;
  4056ac:	52800100 	mov	w0, #0x8                   	// #8
  4056b0:	3901c3e0 	strb	w0, [sp, #112]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  4056b4:	52810600 	mov	w0, #0x830                 	// #2096
  4056b8:	7900b3e0 	strh	w0, [sp, #88]
    fc_frame.length = DATA_SIZE_FC;
  4056bc:	52800060 	mov	w0, #0x3                   	// #3
  4056c0:	390183e0 	strb	w0, [sp, #96]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  4056c4:	d2802140 	mov	x0, #0x10a                 	// #266
  4056c8:	b806a3e1 	stur	w1, [sp, #106]
  4056cc:	97fff8f0 	bl	403a8c <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4056d0:	52802040 	mov	w0, #0x102                 	// #258
  4056d4:	72a31b40 	movk	w0, #0x18da, lsl #16
  4056d8:	97fff979 	bl	403cbc <add_rx_msgq.constprop.0>
  4056dc:	2a0003e6 	mov	w6, w0
  4056e0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4056e4:	910b3aa4 	add	x4, x21, #0x2ce
  4056e8:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4056ec:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4056f0:	912664a5 	add	x5, x5, #0x999
  4056f4:	91220ec2 	add	x2, x22, #0x883
  4056f8:	52803863 	mov	w3, #0x1c3                 	// #451
  4056fc:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  405700:	9126d421 	add	x1, x1, #0x9b5
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405704:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405708:	2a2603e0 	mvn	w0, w6
  40570c:	531f7c00 	lsr	w0, w0, #31
  405710:	97fff8fb 	bl	403afc <z_zassert.constprop.0>
    send_frame_series(&ff_frame, 1, rx_addr);
  405714:	52804022 	mov	w2, #0x201                 	// #513
  405718:	9101a3e0 	add	x0, sp, #0x68
  40571c:	72a31b42 	movk	w2, #0x18da, lsl #16
  405720:	d2800021 	mov	x1, #0x1                   	// #1
  405724:	97fff9a2 	bl	403dac <send_frame_series>
    while (remaining_frames) {
  405728:	f947be73 	ldr	x19, [x19, #3960]
  40572c:	8b130298 	add	x24, x20, x19
        check_frame_series(&fc_frame, 1, &frame_msgq);
  405730:	aa1703e0 	mov	x0, x23
  405734:	d2800021 	mov	x1, #0x1                   	// #1
        if (remaining_frames >= fc_opts.bs) {
  405738:	91012294 	add	x20, x20, #0x48
        check_frame_series(&fc_frame, 1, &frame_msgq);
  40573c:	97fffba6 	bl	4045d4 <check_frame_series.constprop.0>
        if (remaining_frames >= fc_opts.bs) {
  405740:	f105a29f 	cmp	x20, #0x168
  405744:	540003e1 	b.ne	4057c0 <_isotp_fast_conformance_async_test_receive_data_blocks_wrapper+0x17c>  // b.any
            send_frame_series(data_frame_ptr, remaining_frames, rx_addr);
  405748:	91048260 	add	x0, x19, #0x120
  40574c:	52804022 	mov	w2, #0x201                 	// #513
  405750:	72a31b42 	movk	w2, #0x18da, lsl #16
  405754:	d28000c1 	mov	x1, #0x6                   	// #6
  405758:	97fff995 	bl	403dac <send_frame_series>
    receive_test_data(&ctx, random_data, DATA_SEND_LENGTH, 0);
  40575c:	97ffff63 	bl	4054e8 <receive_test_data.constprop.0>
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405760:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405764:	9101e3e1 	add	x1, sp, #0x78
  405768:	d28000a2 	mov	x2, #0x5                   	// #5
  40576c:	f947e000 	ldr	x0, [x0, #4032]
  405770:	97fff858 	bl	4038d0 <k_msgq_get>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405774:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405778:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  40577c:	91220ec2 	add	x2, x22, #0x883
  405780:	1a9f17e0 	cset	w0, eq  // eq = none
  405784:	910b3aa4 	add	x4, x21, #0x2ce
  405788:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  40578c:	52803b83 	mov	w3, #0x1dc                 	// #476
  405790:	9128d8a5 	add	x5, x5, #0xa36
  405794:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  405798:	9130fc21 	add	x1, x1, #0xc3f
  40579c:	97fff8d8 	bl	403afc <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  4057a0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4057a4:	f9476800 	ldr	x0, [x0, #3792]
  4057a8:	f94047e2 	ldr	x2, [sp, #136]
  4057ac:	f9400001 	ldr	x1, [x0]
  4057b0:	eb010042 	subs	x2, x2, x1
  4057b4:	d2800001 	mov	x1, #0x0                   	// #0
  4057b8:	540000e0 	b.eq	4057d4 <_isotp_fast_conformance_async_test_receive_data_blocks_wrapper+0x190>  // b.none
  4057bc:	97ffeed9 	bl	401320 <__stack_chk_fail@plt>
            send_frame_series(data_frame_ptr, fc_opts.bs, rx_addr);
  4057c0:	2a1903e2 	mov	w2, w25
  4057c4:	aa1803e0 	mov	x0, x24
  4057c8:	d2800101 	mov	x1, #0x8                   	// #8
  4057cc:	97fff978 	bl	403dac <send_frame_series>
            remaining_frames -= fc_opts.bs;
  4057d0:	17ffffd7 	b	40572c <_isotp_fast_conformance_async_test_receive_data_blocks_wrapper+0xe8>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  4057d4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4057d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4057dc:	a94363f7 	ldp	x23, x24, [sp, #48]
  4057e0:	f94023f9 	ldr	x25, [sp, #64]
  4057e4:	a8c97bfd 	ldp	x29, x30, [sp], #144
  4057e8:	d65f03c0 	ret

00000000004057ec <_isotp_fast_conformance_async_test_receive_data_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data)
  4057ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4057f0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4057f4:	910003fd 	mov	x29, sp
  4057f8:	f9476800 	ldr	x0, [x0, #3792]
  4057fc:	f9400001 	ldr	x1, [x0]
  405800:	f9001fe1 	str	x1, [sp, #56]
  405804:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  405808:	52820220 	mov	w0, #0x1011                	// #4113
  40580c:	790053e0 	strh	w0, [sp, #40]
  405810:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  405814:	910d7000 	add	x0, x0, #0x35c
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  405818:	39006bff 	strb	wzr, [sp, #26]
  40581c:	b9400001 	ldr	w1, [x0]
  405820:	79400800 	ldrh	w0, [x0, #4]
  405824:	79005fe0 	strh	w0, [sp, #46]
    ff_frame.length = CAN_DL;
  405828:	52800100 	mov	w0, #0x8                   	// #8
  40582c:	3900c3e0 	strb	w0, [sp, #48]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  405830:	52810600 	mov	w0, #0x830                 	// #2096
  405834:	790033e0 	strh	w0, [sp, #24]
    fc_frame.length = DATA_SIZE_FC;
  405838:	52800060 	mov	w0, #0x3                   	// #3
  40583c:	390083e0 	strb	w0, [sp, #32]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  405840:	d2802140 	mov	x0, #0x10a                 	// #266
  405844:	b802a3e1 	stur	w1, [sp, #42]
  405848:	97fff891 	bl	403a8c <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  40584c:	52802040 	mov	w0, #0x102                 	// #258
  405850:	72a31b40 	movk	w0, #0x18da, lsl #16
  405854:	97fff91a 	bl	403cbc <add_rx_msgq.constprop.0>
  405858:	d0000121 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
    send_frame_series(&ff_frame, 1, rx_addr);
  40585c:	52804022 	mov	w2, #0x201                 	// #513
  405860:	72a31b42 	movk	w2, #0x18da, lsl #16
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405864:	f947b421 	ldr	x1, [x1, #3944]
  405868:	b9000020 	str	w0, [x1]
    send_frame_series(&ff_frame, 1, rx_addr);
  40586c:	9100a3e0 	add	x0, sp, #0x28
  405870:	d2800021 	mov	x1, #0x1                   	// #1
  405874:	97fff94e 	bl	403dac <send_frame_series>
    check_frame_series(&fc_frame, 1, &frame_msgq);
  405878:	910063e0 	add	x0, sp, #0x18
  40587c:	d2800021 	mov	x1, #0x1                   	// #1
  405880:	97fffb55 	bl	4045d4 <check_frame_series.constprop.0>
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  405884:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405888:	52804022 	mov	w2, #0x201                 	// #513
  40588c:	72a31b42 	movk	w2, #0x18da, lsl #16
  405890:	d28004c1 	mov	x1, #0x26                  	// #38
  405894:	f947bc00 	ldr	x0, [x0, #3960]
  405898:	97fff945 	bl	403dac <send_frame_series>
    receive_test_data(&ctx, random_data, DATA_SEND_LENGTH, 0);
  40589c:	97ffff13 	bl	4054e8 <receive_test_data.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data)
  4058a0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4058a4:	f9476800 	ldr	x0, [x0, #3792]
  4058a8:	f9401fe2 	ldr	x2, [sp, #56]
  4058ac:	f9400001 	ldr	x1, [x0]
  4058b0:	eb010042 	subs	x2, x2, x1
  4058b4:	d2800001 	mov	x1, #0x0                   	// #0
  4058b8:	54000040 	b.eq	4058c0 <_isotp_fast_conformance_async_test_receive_data_wrapper+0xd4>  // b.none
  4058bc:	97ffee99 	bl	401320 <__stack_chk_fail@plt>
  4058c0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4058c4:	d65f03c0 	ret

00000000004058c8 <get_sf.constprop.0>:
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  4058c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  4058cc:	d2800c82 	mov	x2, #0x64                  	// #100
  4058d0:	d2801001 	mov	x1, #0x80                  	// #128
  return __builtin___memset_chk (__dest, __ch, __len,
  4058d4:	4f000400 	movi	v0.4s, #0x0
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  4058d8:	910003fd 	mov	x29, sp
  4058dc:	a90153f3 	stp	x19, x20, [sp, #16]
  4058e0:	d0000133 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
    zassert_equal(ret, data_size, "recv returned %d", ret);
  4058e4:	d0000074 	adrp	x20, 413000 <z_impl_k_uptime_ticks>
  4058e8:	f9471273 	ldr	x19, [x19, #3616]
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  4058ec:	f90013f5 	str	x21, [sp, #32]
    zassert_equal(ret, data_size, "recv returned %d", ret);
  4058f0:	f0000075 	adrp	x21, 414000 <dlc_table.0+0x78d>
  4058f4:	9105aeb5 	add	x21, x21, #0x16b
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  4058f8:	aa1303e0 	mov	x0, x19
    zassert_equal(ret, data_size, "recv returned %d", ret);
  4058fc:	91220e94 	add	x20, x20, #0x883
  405900:	ad000260 	stp	q0, q0, [x19]
  405904:	ad010260 	stp	q0, q0, [x19, #32]
  405908:	ad020260 	stp	q0, q0, [x19, #64]
  40590c:	ad030260 	stp	q0, q0, [x19, #96]
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  405910:	97fff7f1 	bl	4038d4 <blocking_recv>
    zassert_equal(ret, data_size, "recv returned %d", ret);
  405914:	71001c1f 	cmp	w0, #0x7
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  405918:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, data_size, "recv returned %d", ret);
  40591c:	aa1503e4 	mov	x4, x21
  405920:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  405924:	91244ca5 	add	x5, x5, #0x913
  405928:	52800783 	mov	w3, #0x3c                  	// #60
  40592c:	aa1403e2 	mov	x2, x20
  405930:	1a9f17e0 	cset	w0, eq  // eq = none
  405934:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  405938:	913d3c21 	add	x1, x1, #0xf4f
  40593c:	97fff870 	bl	403afc <z_zassert.constprop.0>
    ret = check_data(data_buf, random_data, data_size);
  405940:	aa1303e0 	mov	x0, x19
  405944:	d28000e2 	mov	x2, #0x7                   	// #7
  405948:	f0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  40594c:	910d7021 	add	x1, x1, #0x35c
  405950:	97fffaf4 	bl	404520 <check_data>
    zassert_equal(ret, 0, "Data differ");
  405954:	7100001f 	cmp	w0, #0x0
  405958:	aa1503e4 	mov	x4, x21
  40595c:	aa1403e2 	mov	x2, x20
}
  405960:	a94153f3 	ldp	x19, x20, [sp, #16]
    zassert_equal(ret, 0, "Data differ");
  405964:	1a9f17e0 	cset	w0, eq  // eq = none
}
  405968:	f94013f5 	ldr	x21, [sp, #32]
    zassert_equal(ret, 0, "Data differ");
  40596c:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
}
  405970:	a8c37bfd 	ldp	x29, x30, [sp], #48
    zassert_equal(ret, 0, "Data differ");
  405974:	9134f8a5 	add	x5, x5, #0xd3e
  405978:	528007e3 	mov	w3, #0x3f                  	// #63
  40597c:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  405980:	91256c21 	add	x1, x1, #0x95b
  405984:	17fff85e 	b	403afc <z_zassert.constprop.0>

0000000000405988 <_isotp_fast_conformance_async_test_receive_sf_fixed_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  405988:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40598c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    send_frame_series(&single_frame, 1, rx_addr);
  405990:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  405994:	910003fd 	mov	x29, sp
  405998:	f9476800 	ldr	x0, [x0, #3792]
  40599c:	f9000bf3 	str	x19, [sp, #16]
  return __builtin___memcpy_chk (__dest, __src, __len,
  4059a0:	9100a3f3 	add	x19, sp, #0x28
    send_frame_series(&single_frame, 1, rx_addr);
  4059a4:	72a31b42 	movk	w2, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  4059a8:	f9400001 	ldr	x1, [x0]
  4059ac:	f9001fe1 	str	x1, [sp, #56]
  4059b0:	d2800001 	mov	x1, #0x0                   	// #0
    single_frame.data[0] = SF_PCI_BYTE_1;
  4059b4:	528000e0 	mov	w0, #0x7                   	// #7
  4059b8:	3900a3e0 	strb	w0, [sp, #40]
  4059bc:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4059c0:	910d7000 	add	x0, x0, #0x35c
  4059c4:	b9400001 	ldr	w1, [x0]
  4059c8:	b8403000 	ldur	w0, [x0, #3]
  4059cc:	b80293e1 	stur	w1, [sp, #41]
    send_frame_series(&single_frame, 1, rx_addr);
  4059d0:	d2800021 	mov	x1, #0x1                   	// #1
  4059d4:	b9002fe0 	str	w0, [sp, #44]
    single_frame.length = CAN_MAX_DLEN;
  4059d8:	52800100 	mov	w0, #0x8                   	// #8
  4059dc:	3900c3e0 	strb	w0, [sp, #48]
    send_frame_series(&single_frame, 1, rx_addr);
  4059e0:	aa1303e0 	mov	x0, x19
  4059e4:	97fff8f2 	bl	403dac <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  4059e8:	97ffffb8 	bl	4058c8 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | 0xFF);
  4059ec:	aa1303e0 	mov	x0, x19
  4059f0:	52805fe2 	mov	w2, #0x2ff                 	// #767
  4059f4:	72a31b42 	movk	w2, #0x18da, lsl #16
  4059f8:	d2800021 	mov	x1, #0x1                   	// #1
  4059fc:	97fff8ec 	bl	403dac <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  405a00:	97ffffb2 	bl	4058c8 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | (7U << 26));
  405a04:	aa1303e0 	mov	x0, x19
  405a08:	52804022 	mov	w2, #0x201                 	// #513
  405a0c:	72a39b42 	movk	w2, #0x1cda, lsl #16
  405a10:	d2800021 	mov	x1, #0x1                   	// #1
  405a14:	97fff8e6 	bl	403dac <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  405a18:	97ffffac 	bl	4058c8 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | 0xFF00);
  405a1c:	aa1303e0 	mov	x0, x19
  405a20:	529fe022 	mov	w2, #0xff01                	// #65281
  405a24:	72a31b42 	movk	w2, #0x18da, lsl #16
  405a28:	d2800021 	mov	x1, #0x1                   	// #1
  405a2c:	97fff8e0 	bl	403dac <send_frame_series>
    get_sf_ignore(&ctx);
  405a30:	97fff876 	bl	403c08 <get_sf_ignore.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  405a34:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405a38:	f9476800 	ldr	x0, [x0, #3792]
  405a3c:	f9401fe2 	ldr	x2, [sp, #56]
  405a40:	f9400001 	ldr	x1, [x0]
  405a44:	eb010042 	subs	x2, x2, x1
  405a48:	d2800001 	mov	x1, #0x0                   	// #0
  405a4c:	54000040 	b.eq	405a54 <_isotp_fast_conformance_async_test_receive_sf_fixed_wrapper+0xcc>  // b.none
  405a50:	97ffee34 	bl	401320 <__stack_chk_fail@plt>
  405a54:	f9400bf3 	ldr	x19, [sp, #16]
  405a58:	a8c47bfd 	ldp	x29, x30, [sp], #64
  405a5c:	d65f03c0 	ret

0000000000405a60 <_isotp_fast_conformance_async_test_receive_sf_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  405a60:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  405a64:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
    send_frame_series(&single_frame, 1, rx_addr);
  405a68:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  405a6c:	910003fd 	mov	x29, sp
  405a70:	f9476800 	ldr	x0, [x0, #3792]
  405a74:	a90153f3 	stp	x19, x20, [sp, #16]
  405a78:	9100a3f3 	add	x19, sp, #0x28
  405a7c:	f9400001 	ldr	x1, [x0]
  405a80:	f9001fe1 	str	x1, [sp, #56]
  405a84:	d2800001 	mov	x1, #0x0                   	// #0
    single_frame.data[0] = SF_PCI_BYTE_1;
  405a88:	528000e0 	mov	w0, #0x7                   	// #7
  405a8c:	3900a3e0 	strb	w0, [sp, #40]
  405a90:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  405a94:	910d7000 	add	x0, x0, #0x35c
    send_frame_series(&single_frame, 1, rx_addr);
  405a98:	72a31b42 	movk	w2, #0x18da, lsl #16
    single_frame.length = CAN_MAX_DLEN;
  405a9c:	52800114 	mov	w20, #0x8                   	// #8
  405aa0:	3900c3f4 	strb	w20, [sp, #48]
  405aa4:	b9400001 	ldr	w1, [x0]
  405aa8:	b8403000 	ldur	w0, [x0, #3]
  405aac:	b80293e1 	stur	w1, [sp, #41]
    send_frame_series(&single_frame, 1, rx_addr);
  405ab0:	d2800021 	mov	x1, #0x1                   	// #1
  405ab4:	b9002fe0 	str	w0, [sp, #44]
  405ab8:	aa1303e0 	mov	x0, x19
  405abc:	97fff8bc 	bl	403dac <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  405ac0:	97ffff82 	bl	4058c8 <get_sf.constprop.0>
    single_frame.data[0] = SF_PCI_BYTE_LEN_8;
  405ac4:	3900a3f4 	strb	w20, [sp, #40]
    send_frame_series(&single_frame, 1, rx_addr);
  405ac8:	aa1303e0 	mov	x0, x19
  405acc:	52804022 	mov	w2, #0x201                 	// #513
  405ad0:	72a31b42 	movk	w2, #0x18da, lsl #16
  405ad4:	d2800021 	mov	x1, #0x1                   	// #1
  405ad8:	97fff8b5 	bl	403dac <send_frame_series>
    get_sf_ignore(&ctx);
  405adc:	97fff84b 	bl	403c08 <get_sf_ignore.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  405ae0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405ae4:	f9476800 	ldr	x0, [x0, #3792]
  405ae8:	f9401fe2 	ldr	x2, [sp, #56]
  405aec:	f9400001 	ldr	x1, [x0]
  405af0:	eb010042 	subs	x2, x2, x1
  405af4:	d2800001 	mov	x1, #0x0                   	// #0
  405af8:	54000040 	b.eq	405b00 <_isotp_fast_conformance_async_test_receive_sf_wrapper+0xa0>  // b.none
  405afc:	97ffee09 	bl	401320 <__stack_chk_fail@plt>
  405b00:	a94153f3 	ldp	x19, x20, [sp, #16]
  405b04:	a8c47bfd 	ldp	x29, x30, [sp], #64
  405b08:	d65f03c0 	ret

0000000000405b0c <isotp_fast_conformance_after>:
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
                    isotp_fast_recv_error_handler, isotp_fast_sent_handler);
}

void isotp_fast_conformance_after(void *)
{
  405b0c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    isotp_fast_unbind(&ctx);
  405b10:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
{
  405b14:	910003fd 	mov	x29, sp
    isotp_fast_unbind(&ctx);
  405b18:	f9470c00 	ldr	x0, [x0, #3608]
{
  405b1c:	f9000bf3 	str	x19, [sp, #16]
    isotp_fast_unbind(&ctx);
  405b20:	97fff6e7 	bl	4036bc <isotp_fast_unbind>
	z_impl_k_msgq_purge(msgq);
  405b24:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405b28:	d0000133 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  405b2c:	f947e000 	ldr	x0, [x0, #4032]
  405b30:	94002475 	bl	40ed04 <z_impl_k_msgq_purge>

    k_msgq_purge(&frame_msgq);
    if (filter_id >= 0) {
  405b34:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405b38:	f947b400 	ldr	x0, [x0, #3944]
  405b3c:	b9400001 	ldr	w1, [x0]
  405b40:	37f800a1 	tbnz	w1, #31, 405b54 <isotp_fast_conformance_after+0x48>
  405b44:	f9472260 	ldr	x0, [x19, #3648]
  405b48:	f9400802 	ldr	x2, [x0, #16]
  405b4c:	f9401c42 	ldr	x2, [x2, #56]
  405b50:	d63f0040 	blr	x2
	return api->stop(dev);
  405b54:	f9472260 	ldr	x0, [x19, #3648]
        can_remove_rx_filter(can_dev, filter_id);
    }
    can_stop(can_dev);
}
  405b58:	f9400bf3 	ldr	x19, [sp, #16]
  405b5c:	f9400801 	ldr	x1, [x0, #16]
  405b60:	a8c27bfd 	ldp	x29, x30, [sp], #32
  405b64:	f9400821 	ldr	x1, [x1, #16]
  405b68:	aa0103f0 	mov	x16, x1
  405b6c:	d61f0200 	br	x16

0000000000405b70 <isotp_fast_conformance_before>:
{
  405b70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  405b74:	910003fd 	mov	x29, sp
  405b78:	f9000bf3 	str	x19, [sp, #16]
	return api->start(dev);
  405b7c:	d0000133 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  405b80:	f9472273 	ldr	x19, [x19, #3648]
  405b84:	f9400a60 	ldr	x0, [x19, #16]
  405b88:	f9400401 	ldr	x1, [x0, #8]
  405b8c:	aa1303e0 	mov	x0, x19
  405b90:	d63f0020 	blr	x1
    zassert_equal(ret, 0, "Failed to start CAN controller [%d]", ret);
  405b94:	7100001f 	cmp	w0, #0x0
  405b98:	2a0003e6 	mov	w6, w0
  405b9c:	52805c23 	mov	w3, #0x2e1                 	// #737
  405ba0:	1a9f17e0 	cset	w0, eq  // eq = none
  405ba4:	d0000065 	adrp	x5, 413000 <z_impl_k_uptime_ticks>
  405ba8:	f0000064 	adrp	x4, 414000 <dlc_table.0+0x78d>
  405bac:	913db0a5 	add	x5, x5, #0xf6c
  405bb0:	91029484 	add	x4, x4, #0xa5
  405bb4:	d0000062 	adrp	x2, 413000 <z_impl_k_uptime_ticks>
  405bb8:	d0000061 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  405bbc:	91220c42 	add	x2, x2, #0x883
  405bc0:	91256c21 	add	x1, x1, #0x95b
  405bc4:	97fff7ce 	bl	403afc <z_zassert.constprop.0>
    filter_id = -1;
  405bc8:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405bcc:	12800001 	mov	w1, #0xffffffff            	// #-1
  405bd0:	f947b400 	ldr	x0, [x0, #3944]
  405bd4:	b9000001 	str	w1, [x0]
  405bd8:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405bdc:	f947e000 	ldr	x0, [x0, #4032]
  405be0:	94002449 	bl	40ed04 <z_impl_k_msgq_purge>
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  405be4:	aa1303e1 	mov	x1, x19
  405be8:	d0000127 	adrp	x7, 42b000 <__FRAME_END__+0xff4c>
  405bec:	d0000126 	adrp	x6, 42b000 <__FRAME_END__+0xff4c>
  405bf0:	d0000124 	adrp	x4, 42b000 <__FRAME_END__+0xff4c>
  405bf4:	d0000123 	adrp	x3, 42b000 <__FRAME_END__+0xff4c>
  405bf8:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
}
  405bfc:	f9400bf3 	ldr	x19, [sp, #16]
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  405c00:	52804022 	mov	w2, #0x201                 	// #513
}
  405c04:	a8c27bfd 	ldp	x29, x30, [sp], #32
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  405c08:	d2800005 	mov	x5, #0x0                   	// #0
  405c0c:	f947c4e7 	ldr	x7, [x7, #3976]
  405c10:	72a31b42 	movk	w2, #0x18da, lsl #16
  405c14:	f947c0c6 	ldr	x6, [x6, #3968]
  405c18:	f9470084 	ldr	x4, [x4, #3584]
  405c1c:	f947ac63 	ldr	x3, [x3, #3928]
  405c20:	f9470c00 	ldr	x0, [x0, #3608]
  405c24:	17fff660 	b	4035a4 <isotp_fast_bind>

0000000000405c28 <cbvprintf_package>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
  405c28:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  405c2c:	910003fd 	mov	x29, sp
  405c30:	a90153f3 	stp	x19, x20, [sp, #16]
  405c34:	aa0003f4 	mov	x20, x0
  405c38:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  405c3c:	a9025bf5 	stp	x21, x22, [sp, #32]
  405c40:	aa0103f5 	mov	x21, x1
  405c44:	f9476800 	ldr	x0, [x0, #3792]
  405c48:	a90363f7 	stp	x23, x24, [sp, #48]
  405c4c:	a9046bf9 	stp	x25, x26, [sp, #64]
  405c50:	a90573fb 	stp	x27, x28, [sp, #80]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
	bool is_str_arg = false;
	union cbprintf_package_hdr *pkg_hdr = packaged;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
  405c54:	f2400a9c 	ands	x28, x20, #0x7
{
  405c58:	f9400001 	ldr	x1, [x0]
  405c5c:	f90067e1 	str	x1, [sp, #200]
  405c60:	d2800001 	mov	x1, #0x0                   	// #0
  405c64:	121e0040 	and	w0, w2, #0x4
  405c68:	b90083e0 	str	w0, [sp, #128]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
  405c6c:	d3431441 	ubfx	x1, x2, #3, #3
  405c70:	29436488 	ldp	w8, w25, [x4, #24]
  405c74:	a940289b 	ldp	x27, x10, [x4]
  405c78:	f940088c 	ldr	x12, [x4, #16]
	if ((uintptr_t)packaged % sizeof(void *)) {
  405c7c:	54003781 	b.ne	40636c <cbvprintf_package+0x744>  // b.any
  405c80:	aa0303fa 	mov	x26, x3
  405c84:	11000421 	add	w1, w1, #0x1
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * multiple of pointer size for the above to preserve alignment.
	 *
	 * Refer to union cbprintf_package_hdr for more details.
	 */
	buf += sizeof(*pkg_hdr);
  405c88:	91002293 	add	x19, x20, #0x8
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
  405c8c:	b5003754 	cbnz	x20, 406374 <cbvprintf_package+0x74c>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  405c90:	92400ab5 	and	x21, x21, #0x7
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  405c94:	d2800100 	mov	x0, #0x8                   	// #8
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  405c98:	910022b3 	add	x19, x21, #0x8
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  405c9c:	cb150015 	sub	x21, x0, x21
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
	align = VA_STACK_ALIGN(char *);
  405ca0:	52800118 	mov	w24, #0x8                   	// #8
					align = VA_STACK_ALIGN(int);
					size = sizeof(int);
				}
				continue;
			}
			switch (*fmt) {
  405ca4:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  405ca8:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  405cac:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  405cb0:	d000006b 	adrp	x11, 413000 <z_impl_k_uptime_ticks>
	s = fmt--;
  405cb4:	d1000749 	sub	x9, x26, #0x1
	size = sizeof(char *);
  405cb8:	2a1803f6 	mov	w22, w24
			switch (*fmt) {
  405cbc:	9119116b 	add	x11, x11, #0x644
  405cc0:	d0000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
	bool parsing = false;
  405cc4:	52800017 	mov	w23, #0x0                   	// #0
			switch (*fmt) {
  405cc8:	9118c000 	add	x0, x0, #0x630
	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
  405ccc:	12800006 	mov	w6, #0xffffffff            	// #-1
	unsigned int s_ro_cnt = 0; /* number of ro strings */
  405cd0:	52800005 	mov	w5, #0x0                   	// #0
	unsigned int s_rw_cnt = 0; /* number of rw strings */
  405cd4:	52800004 	mov	w4, #0x0                   	// #0
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
  405cd8:	52800003 	mov	w3, #0x0                   	// #0
  405cdc:	d280002d 	mov	x13, #0x1                   	// #1
			switch (*fmt) {
  405ce0:	f2c0004e 	movk	x14, #0x2, lsl #32
  405ce4:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  405ce8:	f2e06012 	movk	x18, #0x300, lsl #48
  405cec:	f90033e0 	str	x0, [sp, #96]

		/* copy va_list data over to our buffer */
		if (is_str_arg) {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
  405cf0:	b4000054 	cbz	x20, 405cf8 <cbvprintf_package+0xd0>
				*(const char **)buf = s;
  405cf4:	f900027a 	str	x26, [x19]
			}

			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);

			if (is_ro && !do_ro) {
  405cf8:	721f0050 	ands	w16, w2, #0x2
  405cfc:	7a400824 	ccmp	w1, #0x0, #0x4, eq  // eq = none
  405d00:	54001aec 	b.gt	40605c <cbvprintf_package+0x434>
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
  405d04:	cb140260 	sub	x0, x19, x20
  405d08:	d342fc00 	lsr	x0, x0, #2
				 * In the do_ro case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
  405d0c:	7101fc1f 	cmp	w0, #0x7f
  405d10:	7a408a04 	ccmp	w16, #0x0, #0x4, hi  // hi = pmore
  405d14:	54001640 	b.eq	405fdc <cbvprintf_package+0x3b4>  // b.none
					__ASSERT(false, "String with too many arguments");
  405d18:	f0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  405d1c:	911d7273 	add	x19, x19, #0x75c
  405d20:	aa1303e2 	mov	x2, x19
  405d24:	b0000081 	adrp	x1, 416000 <__func__.0+0xb3f>
  405d28:	9122f821 	add	x1, x1, #0x8be
  405d2c:	52804f63 	mov	w3, #0x27b                 	// #635
  405d30:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  405d34:	911e2800 	add	x0, x0, #0x78a
  405d38:	94000796 	bl	407b90 <assert_print>
  405d3c:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  405d40:	911e9c00 	add	x0, x0, #0x7a7
  405d44:	94000793 	bl	407b90 <assert_print>
  405d48:	aa1303e0 	mov	x0, x19
  405d4c:	52804f61 	mov	w1, #0x27b                 	// #635
  405d50:	940007ba 	bl	407c38 <assert_post_action>
  405d54:	52804f62 	mov	w2, #0x27b                 	// #635
					return -EINVAL;
				}

				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
					__ASSERT(false, "str_ptr_pos[] too small");
  405d58:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  405d5c:	aa1303e1 	mov	x1, x19
  405d60:	911f2000 	add	x0, x0, #0x7c8
  405d64:	940011a7 	bl	40a400 <posix_print_error_and_exit>
			switch (*fmt) {
  405d68:	7101e91f 	cmp	w8, #0x7a
  405d6c:	540000e8 	b.hi	405d88 <cbvprintf_package+0x160>  // b.pmore
  405d70:	71019d1f 	cmp	w8, #0x67
  405d74:	54000208 	b.hi	405db4 <cbvprintf_package+0x18c>  // b.pmore
  405d78:	7100a91f 	cmp	w8, #0x2a
  405d7c:	54000408 	b.hi	405dfc <cbvprintf_package+0x1d4>  // b.pmore
  405d80:	71007d1f 	cmp	w8, #0x1f
  405d84:	540002e8 	b.hi	405de0 <cbvprintf_package+0x1b8>  // b.pmore
				parsing = false;
  405d88:	52800017 	mov	w23, #0x0                   	// #0
			if (*++fmt == '\0') {
  405d8c:	38401d28 	ldrb	w8, [x9, #1]!
  405d90:	340022a8 	cbz	w8, 4061e4 <cbvprintf_package+0x5bc>
			if (!parsing) {
  405d94:	35fffeb7 	cbnz	w23, 405d68 <cbvprintf_package+0x140>
				if (*fmt == '%') {
  405d98:	7100951f 	cmp	w8, #0x25
  405d9c:	54ffff81 	b.ne	405d8c <cbvprintf_package+0x164>  // b.any
					arg_idx++;
  405da0:	110004c6 	add	w6, w6, #0x1
					parsing = true;
  405da4:	52800037 	mov	w23, #0x1                   	// #1
					align = VA_STACK_ALIGN(int);
  405da8:	52800118 	mov	w24, #0x8                   	// #8
					size = sizeof(int);
  405dac:	52800096 	mov	w22, #0x4                   	// #4
  405db0:	17fffff7 	b	405d8c <cbvprintf_package+0x164>
			switch (*fmt) {
  405db4:	5101a108 	sub	w8, w8, #0x68
  405db8:	7100491f 	cmp	w8, #0x12
  405dbc:	54fffe68 	b.hi	405d88 <cbvprintf_package+0x160>  // b.pmore
  405dc0:	f94033e7 	ldr	x7, [sp, #96]
  405dc4:	386848e8 	ldrb	w8, [x7, w8, uxtw]
  405dc8:	10000070 	adr	x16, 405dd4 <cbvprintf_package+0x1ac>
  405dcc:	8b288a08 	add	x8, x16, w8, sxtb #2
  405dd0:	d61f0100 	br	x8
  405dd4:	52800118 	mov	w24, #0x8                   	// #8
  405dd8:	2a1803f6 	mov	w22, w24
  405ddc:	17ffffec 	b	405d8c <cbvprintf_package+0x164>
  405de0:	51008108 	sub	w8, w8, #0x20
  405de4:	7100291f 	cmp	w8, #0xa
  405de8:	54fffd08 	b.hi	405d88 <cbvprintf_package+0x160>  // b.pmore
  405dec:	38684968 	ldrb	w8, [x11, w8, uxtw]
  405df0:	10000070 	adr	x16, 405dfc <cbvprintf_package+0x1d4>
  405df4:	8b288a08 	add	x8, x16, w8, sxtb #2
  405df8:	d61f0100 	br	x8
  405dfc:	5100ad08 	sub	w8, w8, #0x2b
  405e00:	9ac821a8 	lsl	x8, x13, x8
  405e04:	ea0e011f 	tst	x8, x14
  405e08:	54fffc21 	b.ne	405d8c <cbvprintf_package+0x164>  // b.any
  405e0c:	ea0f011f 	tst	x8, x15
  405e10:	540003e1 	b.ne	405e8c <cbvprintf_package+0x264>  // b.any
  405e14:	ea12011f 	tst	x8, x18
  405e18:	54fffb80 	b.eq	405d88 <cbvprintf_package+0x160>  // b.none
				if (fmt[-1] == 'l') {
  405e1c:	385ff128 	ldurb	w8, [x9, #-1]
				parsing = false;
  405e20:	52800017 	mov	w23, #0x0                   	// #0
				if (fmt[-1] == 'l') {
  405e24:	7101b11f 	cmp	w8, #0x6c
  405e28:	52800008 	mov	w8, #0x0                   	// #0
  405e2c:	54000061 	b.ne	405e38 <cbvprintf_package+0x210>  // b.any
				align = VA_STACK_ALIGN(void *);
  405e30:	52800118 	mov	w24, #0x8                   	// #8
				size = sizeof(void *);
  405e34:	2a1803f6 	mov	w22, w24
		buf = (void *) ROUND_UP(buf, align);
  405e38:	2a1803f0 	mov	w16, w24
  405e3c:	d1000673 	sub	x19, x19, #0x1
  405e40:	8b384273 	add	x19, x19, w24, uxtw
  405e44:	cb1003f0 	neg	x16, x16
  405e48:	8a100273 	and	x19, x19, x16
		if (buf0 != NULL && BUF_OFFSET + size > len) {
  405e4c:	b40000d4 	cbz	x20, 405e64 <cbvprintf_package+0x23c>
  405e50:	2a1603f0 	mov	w16, w22
  405e54:	cb140210 	sub	x16, x16, x20
  405e58:	8b130210 	add	x16, x16, x19
  405e5c:	eb15021f 	cmp	x16, x21
  405e60:	54000408 	b.hi	405ee0 <cbvprintf_package+0x2b8>  // b.pmore
		if (is_str_arg) {
  405e64:	34001488 	cbz	w8, 4060f4 <cbvprintf_package+0x4cc>
			s = va_arg(ap, char *);
  405e68:	37f80a80 	tbnz	w0, #31, 405fb8 <cbvprintf_package+0x390>
  405e6c:	91003fdb 	add	x27, x30, #0xf
  405e70:	2a0003e8 	mov	w8, w0
  405e74:	927df37b 	and	x27, x27, #0xfffffffffffffff8
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
  405e78:	51000421 	sub	w1, w1, #0x1
			s = va_arg(ap, char *);
  405e7c:	f94003da 	ldr	x26, [x30]
  405e80:	17ffff9c 	b	405cf0 <cbvprintf_package+0xc8>
				arg_idx--;
  405e84:	510004c6 	sub	w6, w6, #0x1
				continue;
  405e88:	17ffffc0 	b	405d88 <cbvprintf_package+0x160>
				if (fmt[-1] == 'L') {
  405e8c:	385ff138 	ldurb	w24, [x9, #-1]
  405e90:	7101331f 	cmp	w24, #0x4c
  405e94:	540004a1 	b.ne	405f28 <cbvprintf_package+0x300>  // b.any
					v.ld = va_arg(ap, long double);
  405e98:	37f80379 	tbnz	w25, #31, 405f04 <cbvprintf_package+0x2dc>
  405e9c:	91003fc8 	add	x8, x30, #0xf
  405ea0:	2a1903f7 	mov	w23, w25
  405ea4:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  405ea8:	9100411e 	add	x30, x8, #0x10
  405eac:	a9404510 	ldp	x16, x17, [x8]
					size = sizeof(long double);
  405eb0:	aa1e03e8 	mov	x8, x30
  405eb4:	52800216 	mov	w22, #0x10                  	// #16
				buf = (void *) ROUND_UP(buf, align);
  405eb8:	2a1603f9 	mov	w25, w22
  405ebc:	d1000673 	sub	x19, x19, #0x1
  405ec0:	8b364273 	add	x19, x19, w22, uxtw
  405ec4:	cb1903fb 	neg	x27, x25
  405ec8:	8a1b0273 	and	x19, x19, x27
				if (buf0 != NULL) {
  405ecc:	b40005b4 	cbz	x20, 405f80 <cbvprintf_package+0x358>
					if (BUF_OFFSET + size > len) {
  405ed0:	cb14033b 	sub	x27, x25, x20
  405ed4:	8b13037b 	add	x27, x27, x19
  405ed8:	eb15037f 	cmp	x27, x21
  405edc:	54000489 	b.ls	405f6c <cbvprintf_package+0x344>  // b.plast
			return -ENOSPC;
  405ee0:	12800360 	mov	w0, #0xffffffe4            	// #-28
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
  405ee4:	d0000121 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  405ee8:	f9476821 	ldr	x1, [x1, #3792]
  405eec:	f94067e3 	ldr	x3, [sp, #200]
  405ef0:	f9400022 	ldr	x2, [x1]
  405ef4:	eb020063 	subs	x3, x3, x2
  405ef8:	d2800002 	mov	x2, #0x0                   	// #0
  405efc:	54002420 	b.eq	406380 <cbvprintf_package+0x758>  // b.none
  405f00:	97ffed08 	bl	401320 <__stack_chk_fail@plt>
					v.ld = va_arg(ap, long double);
  405f04:	11004337 	add	w23, w25, #0x10
  405f08:	710002ff 	cmp	w23, #0x0
  405f0c:	540000ad 	b.le	405f20 <cbvprintf_package+0x2f8>
  405f10:	91003fc8 	add	x8, x30, #0xf
  405f14:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  405f18:	9100411e 	add	x30, x8, #0x10
  405f1c:	17ffffe4 	b	405eac <cbvprintf_package+0x284>
  405f20:	8b39c188 	add	x8, x12, w25, sxtw
  405f24:	17ffffe2 	b	405eac <cbvprintf_package+0x284>
					v.d = va_arg(ap, double);
  405f28:	37f80119 	tbnz	w25, #31, 405f48 <cbvprintf_package+0x320>
  405f2c:	91003fc8 	add	x8, x30, #0xf
  405f30:	2a1903f7 	mov	w23, w25
  405f34:	927df108 	and	x8, x8, #0xfffffffffffffff8
  405f38:	d2800011 	mov	x17, #0x0                   	// #0
					size = sizeof(double);
  405f3c:	52800116 	mov	w22, #0x8                   	// #8
					v.d = va_arg(ap, double);
  405f40:	f94003d0 	ldr	x16, [x30]
					size = sizeof(double);
  405f44:	17ffffdd 	b	405eb8 <cbvprintf_package+0x290>
					v.d = va_arg(ap, double);
  405f48:	11004337 	add	w23, w25, #0x10
  405f4c:	710002ff 	cmp	w23, #0x0
  405f50:	5400008d 	b.le	405f60 <cbvprintf_package+0x338>
  405f54:	91003fc8 	add	x8, x30, #0xf
  405f58:	927df108 	and	x8, x8, #0xfffffffffffffff8
  405f5c:	17fffff7 	b	405f38 <cbvprintf_package+0x310>
  405f60:	aa1e03e8 	mov	x8, x30
  405f64:	8b39c19e 	add	x30, x12, w25, sxtw
  405f68:	17fffff4 	b	405f38 <cbvprintf_package+0x310>
					} else if (fmt[-1] == 'L') {
  405f6c:	7101331f 	cmp	w24, #0x4c
  405f70:	54000121 	b.ne	405f94 <cbvprintf_package+0x36c>  // b.any
						*(long double *)buf = v.ld;
  405f74:	9e670200 	fmov	d0, x16
  405f78:	9eaf0220 	fmov	v0.d[1], x17
  405f7c:	3d800260 	str	q0, [x19]
				buf += size;
  405f80:	8b190273 	add	x19, x19, x25
				continue;
  405f84:	aa0803fe 	mov	x30, x8
  405f88:	2a1703f9 	mov	w25, w23
  405f8c:	2a1603f8 	mov	w24, w22
  405f90:	17ffff7e 	b	405d88 <cbvprintf_package+0x160>
						*(double *)buf = v.d;
  405f94:	f9000270 	str	x16, [x19]
  405f98:	17fffffa 	b	405f80 <cbvprintf_package+0x358>
			switch (*fmt) {
  405f9c:	52800008 	mov	w8, #0x0                   	// #0
				parsing = false;
  405fa0:	52800017 	mov	w23, #0x0                   	// #0
  405fa4:	17ffffa3 	b	405e30 <cbvprintf_package+0x208>
				is_str_arg = true;
  405fa8:	2a1703e8 	mov	w8, w23
  405fac:	17fffffd 	b	405fa0 <cbvprintf_package+0x378>
			switch (*fmt) {
  405fb0:	52800008 	mov	w8, #0x0                   	// #0
  405fb4:	17ffffa1 	b	405e38 <cbvprintf_package+0x210>
			s = va_arg(ap, char *);
  405fb8:	11002008 	add	w8, w0, #0x8
  405fbc:	7100011f 	cmp	w8, #0x0
  405fc0:	5400008d 	b.le	405fd0 <cbvprintf_package+0x3a8>
  405fc4:	91003fdb 	add	x27, x30, #0xf
  405fc8:	927df37b 	and	x27, x27, #0xfffffffffffffff8
  405fcc:	17ffffab 	b	405e78 <cbvprintf_package+0x250>
  405fd0:	aa1e03fb 	mov	x27, x30
  405fd4:	8b20c15e 	add	x30, x10, w0, sxtw
  405fd8:	17ffffa8 	b	405e78 <cbvprintf_package+0x250>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
  405fdc:	71003c7f 	cmp	w3, #0xf
  405fe0:	54000249 	b.ls	406028 <cbvprintf_package+0x400>  // b.plast
					__ASSERT(false, "str_ptr_pos[] too small");
  405fe4:	f0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  405fe8:	911d7273 	add	x19, x19, #0x75c
  405fec:	aa1303e2 	mov	x2, x19
  405ff0:	b0000081 	adrp	x1, 416000 <__func__.0+0xb3f>
  405ff4:	9122f821 	add	x1, x1, #0x8be
  405ff8:	52805003 	mov	w3, #0x280                 	// #640
  405ffc:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406000:	911e2800 	add	x0, x0, #0x78a
  406004:	940006e3 	bl	407b90 <assert_print>
  406008:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40600c:	911fb400 	add	x0, x0, #0x7ed
  406010:	940006e0 	bl	407b90 <assert_print>
  406014:	aa1303e0 	mov	x0, x19
  406018:	52805001 	mov	w1, #0x280                 	// #640
  40601c:	94000707 	bl	407c38 <assert_post_action>
  406020:	52805002 	mov	w2, #0x280                 	// #640
  406024:	17ffff4d 	b	405d58 <cbvprintf_package+0x130>
				if (buf0 != NULL) {
  406028:	b4000274 	cbz	x20, 406074 <cbvprintf_package+0x44c>
					str_ptr_pos[s_idx] = s_ptr_idx;
  40602c:	2a0303f0 	mov	w16, w3
  406030:	9102a3f1 	add	x17, sp, #0xa8
					str_ptr_arg[s_idx] = arg_idx;
  406034:	9102e3fe 	add	x30, sp, #0xb8
					str_ptr_pos[s_idx] = s_ptr_idx;
  406038:	12001c00 	and	w0, w0, #0xff
  40603c:	38306a20 	strb	w0, [x17, x16]
					str_ptr_arg[s_idx] = arg_idx;
  406040:	38306bc6 	strb	w6, [x30, x16]
					if (is_ro) {
  406044:	7100003f 	cmp	w1, #0x0
  406048:	5400012d 	b.le	40606c <cbvprintf_package+0x444>
						s_ro_cnt++;
  40604c:	110004a5 	add	w5, w5, #0x1
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
  406050:	32196000 	orr	w0, w0, #0xffffff80
  406054:	38306a20 	strb	w0, [x17, x16]
				s_idx++;
  406058:	11000463 	add	w3, w3, #0x1
			buf += sizeof(char *);
  40605c:	91002273 	add	x19, x19, #0x8
			is_str_arg = false;
  406060:	2a0803e0 	mov	w0, w8
  406064:	aa1b03fe 	mov	x30, x27
  406068:	17ffff49 	b	405d8c <cbvprintf_package+0x164>
						s_rw_cnt++;
  40606c:	11000484 	add	w4, w4, #0x1
  406070:	17fffffa 	b	406058 <cbvprintf_package+0x430>
				} else if (is_ro) {
  406074:	7100003f 	cmp	w1, #0x0
  406078:	5400006d 	b.le	406084 <cbvprintf_package+0x45c>
					len += 1;
  40607c:	910006b5 	add	x21, x21, #0x1
  406080:	17fffff6 	b	406058 <cbvprintf_package+0x430>
				} else if (rws_pos_en) {
  406084:	b94083e0 	ldr	w0, [sp, #128]
					len += 2;
  406088:	91000ab5 	add	x21, x21, #0x2
				} else if (rws_pos_en) {
  40608c:	35fffe60 	cbnz	w0, 406058 <cbvprintf_package+0x430>
					len += strlen(s) + 1 + 1;
  406090:	aa1a03e0 	mov	x0, x26
  406094:	a906b3ea 	stp	x10, x12, [sp, #104]
  406098:	f9003fe9 	str	x9, [sp, #120]
  40609c:	291093e3 	stp	w3, w4, [sp, #132]
  4060a0:	29119be5 	stp	w5, w6, [sp, #140]
  4060a4:	2912a3e1 	stp	w1, w8, [sp, #148]
  4060a8:	b9009fe2 	str	w2, [sp, #156]
  4060ac:	97ffec3d 	bl	4011a0 <strlen@plt>
  4060b0:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  4060b4:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  4060b8:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  4060bc:	8b0002b5 	add	x21, x21, x0
  4060c0:	295093e3 	ldp	w3, w4, [sp, #132]
  4060c4:	b0000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  4060c8:	29519be5 	ldp	w5, w6, [sp, #140]
  4060cc:	9119100b 	add	x11, x0, #0x644
  4060d0:	2952a3e1 	ldp	w1, w8, [sp, #148]
  4060d4:	f2e06012 	movk	x18, #0x300, lsl #48
  4060d8:	b9409fe2 	ldr	w2, [sp, #156]
  4060dc:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  4060e0:	f2c0004e 	movk	x14, #0x2, lsl #32
  4060e4:	d280002d 	mov	x13, #0x1                   	// #1
  4060e8:	a946b3ea 	ldp	x10, x12, [sp, #104]
  4060ec:	f9403fe9 	ldr	x9, [sp, #120]
  4060f0:	17ffffda 	b	406058 <cbvprintf_package+0x430>
		} else if (size == sizeof(int)) {
  4060f4:	710012df 	cmp	w22, #0x4
  4060f8:	540002a1 	b.ne	40614c <cbvprintf_package+0x524>  // b.any
			int v = va_arg(ap, int);
  4060fc:	37f80160 	tbnz	w0, #31, 406128 <cbvprintf_package+0x500>
  406100:	91002fc8 	add	x8, x30, #0xb
  406104:	2a0003f0 	mov	w16, w0
  406108:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  40610c:	b4000074 	cbz	x20, 406118 <cbvprintf_package+0x4f0>
			int v = va_arg(ap, int);
  406110:	b94003c0 	ldr	w0, [x30]
				*(int *)buf = v;
  406114:	b9000260 	str	w0, [x19]
			buf += sizeof(int);
  406118:	91001273 	add	x19, x19, #0x4
  40611c:	2a1003e0 	mov	w0, w16
  406120:	aa0803fe 	mov	x30, x8
  406124:	17ffff1a 	b	405d8c <cbvprintf_package+0x164>
			int v = va_arg(ap, int);
  406128:	11002010 	add	w16, w0, #0x8
  40612c:	7100021f 	cmp	w16, #0x0
  406130:	5400008d 	b.le	406140 <cbvprintf_package+0x518>
  406134:	91002fc8 	add	x8, x30, #0xb
  406138:	927df108 	and	x8, x8, #0xfffffffffffffff8
  40613c:	17fffff4 	b	40610c <cbvprintf_package+0x4e4>
  406140:	aa1e03e8 	mov	x8, x30
  406144:	8b20c15e 	add	x30, x10, w0, sxtw
  406148:	17fffff1 	b	40610c <cbvprintf_package+0x4e4>
		} else if (size == sizeof(long)) {
  40614c:	710022df 	cmp	w22, #0x8
  406150:	54000261 	b.ne	40619c <cbvprintf_package+0x574>  // b.any
			long v = va_arg(ap, long);
  406154:	37f80120 	tbnz	w0, #31, 406178 <cbvprintf_package+0x550>
  406158:	91003fc8 	add	x8, x30, #0xf
  40615c:	2a0003f0 	mov	w16, w0
  406160:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  406164:	b4000074 	cbz	x20, 406170 <cbvprintf_package+0x548>
			long v = va_arg(ap, long);
  406168:	f94003c0 	ldr	x0, [x30]
				*(long *)buf = v;
  40616c:	f9000260 	str	x0, [x19]
			buf += sizeof(long);
  406170:	91002273 	add	x19, x19, #0x8
  406174:	17ffffea 	b	40611c <cbvprintf_package+0x4f4>
			long v = va_arg(ap, long);
  406178:	11002010 	add	w16, w0, #0x8
  40617c:	7100021f 	cmp	w16, #0x0
  406180:	5400008d 	b.le	406190 <cbvprintf_package+0x568>
  406184:	91003fc8 	add	x8, x30, #0xf
  406188:	927df108 	and	x8, x8, #0xfffffffffffffff8
  40618c:	17fffff6 	b	406164 <cbvprintf_package+0x53c>
  406190:	aa1e03e8 	mov	x8, x30
  406194:	8b20c15e 	add	x30, x10, w0, sxtw
  406198:	17fffff3 	b	406164 <cbvprintf_package+0x53c>
			__ASSERT(false, "unexpected size %u", size);
  40619c:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  4061a0:	911d7273 	add	x19, x19, #0x75c
  4061a4:	aa1303e2 	mov	x2, x19
  4061a8:	528058a3 	mov	w3, #0x2c5                 	// #709
  4061ac:	90000081 	adrp	x1, 416000 <__func__.0+0xb3f>
  4061b0:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4061b4:	9122f821 	add	x1, x1, #0x8be
  4061b8:	911e2800 	add	x0, x0, #0x78a
  4061bc:	94000675 	bl	407b90 <assert_print>
  4061c0:	2a1603e1 	mov	w1, w22
  4061c4:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4061c8:	91201c00 	add	x0, x0, #0x807
  4061cc:	94000671 	bl	407b90 <assert_print>
  4061d0:	aa1303e0 	mov	x0, x19
  4061d4:	528058a1 	mov	w1, #0x2c5                 	// #709
  4061d8:	94000698 	bl	407c38 <assert_post_action>
  4061dc:	528058a2 	mov	w2, #0x2c5                 	// #709
  4061e0:	17fffede 	b	405d58 <cbvprintf_package+0x130>
	if (BUF_OFFSET / sizeof(int) > 255) {
  4061e4:	cb140261 	sub	x1, x19, x20
  4061e8:	f10ffc3f 	cmp	x1, #0x3ff
  4061ec:	54000249 	b.ls	406234 <cbvprintf_package+0x60c>  // b.plast
		__ASSERT(false, "too many format args");
  4061f0:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  4061f4:	911d7273 	add	x19, x19, #0x75c
  4061f8:	aa1303e2 	mov	x2, x19
  4061fc:	90000081 	adrp	x1, 416000 <__func__.0+0xb3f>
  406200:	9122f821 	add	x1, x1, #0x8be
  406204:	52805a23 	mov	w3, #0x2d1                 	// #721
  406208:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40620c:	911e2800 	add	x0, x0, #0x78a
  406210:	94000660 	bl	407b90 <assert_print>
  406214:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406218:	91207000 	add	x0, x0, #0x81c
  40621c:	9400065d 	bl	407b90 <assert_print>
  406220:	aa1303e0 	mov	x0, x19
  406224:	52805a21 	mov	w1, #0x2d1                 	// #721
  406228:	94000684 	bl	407c38 <assert_post_action>
  40622c:	52805a22 	mov	w2, #0x2d1                 	// #721
  406230:	17fffeca 	b	405d58 <cbvprintf_package+0x130>
	if (buf0 == NULL) {
  406234:	b5000094 	cbnz	x20, 406244 <cbvprintf_package+0x61c>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
  406238:	510022a0 	sub	w0, w21, #0x8
  40623c:	0b010000 	add	w0, w0, w1
  406240:	17ffff29 	b	405ee4 <cbvprintf_package+0x2bc>
	if (rws_pos_en) {
  406244:	b94083e0 	ldr	w0, [sp, #128]
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  406248:	d342fc21 	lsr	x1, x1, #2
	*(char **)buf0 = NULL;
  40624c:	f900029f 	str	xzr, [x20]
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  406250:	12001c84 	and	w4, w4, #0xff
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  406254:	39000281 	strb	w1, [x20]
	if (rws_pos_en) {
  406258:	34000120 	cbz	w0, 40627c <cbvprintf_package+0x654>
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  40625c:	39000e84 	strb	w4, [x20, #3]
	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
  406260:	39000a85 	strb	w5, [x20, #2]
	if (s_ro_cnt) {
  406264:	9102a3f8 	add	x24, sp, #0xa8
  406268:	35000265 	cbnz	w5, 4062b4 <cbvprintf_package+0x68c>
		if (BUF_OFFSET + 1 + size > len) {
  40626c:	d2800036 	mov	x22, #0x1                   	// #1
			*buf++ = str_ptr_arg[i];
  406270:	9102e3f7 	add	x23, sp, #0xb8
		if (BUF_OFFSET + 1 + size > len) {
  406274:	cb1402d6 	sub	x22, x22, x20
  406278:	1400002d 	b	40632c <cbvprintf_package+0x704>
		pkg_hdr->desc.str_cnt = s_rw_cnt;
  40627c:	39000684 	strb	w4, [x20, #1]
		pkg_hdr->desc.rw_str_cnt = 0;
  406280:	17fffff8 	b	406260 <cbvprintf_package+0x638>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
  406284:	38e16b04 	ldrsb	w4, [x24, x1]
  406288:	38786820 	ldrb	w0, [x1, x24]
  40628c:	36f800c4 	tbz	w4, #31, 4062a4 <cbvprintf_package+0x67c>
			if (BUF_OFFSET + 1 > len) {
  406290:	8b020264 	add	x4, x19, x2
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
  406294:	12001800 	and	w0, w0, #0x7f
			if (BUF_OFFSET + 1 > len) {
  406298:	eb15009f 	cmp	x4, x21
  40629c:	54ffe228 	b.hi	405ee0 <cbvprintf_package+0x2b8>  // b.pmore
			*buf++ = pos;
  4062a0:	38001660 	strb	w0, [x19], #1
		for (i = 0; i < s_idx; i++) {
  4062a4:	91000421 	add	x1, x1, #0x1
  4062a8:	6b01007f 	cmp	w3, w1
  4062ac:	54fffec8 	b.hi	406284 <cbvprintf_package+0x65c>  // b.pmore
  4062b0:	17ffffef 	b	40626c <cbvprintf_package+0x644>
			if (BUF_OFFSET + 1 > len) {
  4062b4:	d2800022 	mov	x2, #0x1                   	// #1
  4062b8:	d2800001 	mov	x1, #0x0                   	// #0
  4062bc:	cb140042 	sub	x2, x2, x20
  4062c0:	17fffffa 	b	4062a8 <cbvprintf_package+0x680>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
  4062c4:	34000065 	cbz	w5, 4062d0 <cbvprintf_package+0x6a8>
  4062c8:	39c00300 	ldrsb	w0, [x24]
  4062cc:	37f802c0 	tbnz	w0, #31, 406324 <cbvprintf_package+0x6fc>
		if (rws_pos_en) {
  4062d0:	b94083e0 	ldr	w0, [sp, #128]
  4062d4:	34000340 	cbz	w0, 40633c <cbvprintf_package+0x714>
			*buf++ = str_ptr_arg[i];
  4062d8:	38776b80 	ldrb	w0, [x28, x23]
  4062dc:	38001660 	strb	w0, [x19], #1
			size = 0;
  4062e0:	52800000 	mov	w0, #0x0                   	// #0
		if (BUF_OFFSET + 1 + size > len) {
  4062e4:	2a0003f9 	mov	w25, w0
  4062e8:	8b204260 	add	x0, x19, w0, uxtw
  4062ec:	8b160000 	add	x0, x0, x22
  4062f0:	b90063e3 	str	w3, [sp, #96]
  4062f4:	b9006be5 	str	w5, [sp, #104]
  4062f8:	eb15001f 	cmp	x0, x21
  4062fc:	54ffdf28 	b.hi	405ee0 <cbvprintf_package+0x2b8>  // b.pmore
		*buf++ = str_ptr_pos[i];
  406300:	39400300 	ldrb	w0, [x24]
  406304:	aa1903e2 	mov	x2, x25
  406308:	38001660 	strb	w0, [x19], #1
  40630c:	aa1a03e1 	mov	x1, x26
  406310:	aa1303e0 	mov	x0, x19
  406314:	97ffeb97 	bl	401170 <memcpy@plt>
		buf += size;
  406318:	b94063e3 	ldr	w3, [sp, #96]
  40631c:	8b190273 	add	x19, x19, x25
  406320:	b9406be5 	ldr	w5, [sp, #104]
	for (i = 0; i < s_idx; i++) {
  406324:	9100079c 	add	x28, x28, #0x1
  406328:	91000718 	add	x24, x24, #0x1
  40632c:	6b1c007f 	cmp	w3, w28
  406330:	54fffca8 	b.hi	4062c4 <cbvprintf_package+0x69c>  // b.pmore
	return BUF_OFFSET;
  406334:	4b140260 	sub	w0, w19, w20
  406338:	17fffeeb 	b	405ee4 <cbvprintf_package+0x2bc>
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
  40633c:	39400300 	ldrb	w0, [x24]
  406340:	b90063e3 	str	w3, [sp, #96]
  406344:	b9006be5 	str	w5, [sp, #104]
  406348:	d37ef400 	lsl	x0, x0, #2
  40634c:	f8606a9a 	ldr	x26, [x20, x0]
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
  406350:	f8206a9f 	str	xzr, [x20, x0]
			size = strlen(s) + 1;
  406354:	aa1a03e0 	mov	x0, x26
  406358:	97ffeb92 	bl	4011a0 <strlen@plt>
  40635c:	b94063e3 	ldr	w3, [sp, #96]
  406360:	11000400 	add	w0, w0, #0x1
  406364:	b9406be5 	ldr	w5, [sp, #104]
  406368:	17ffffdf 	b	4062e4 <cbvprintf_package+0x6bc>
		return -EFAULT;
  40636c:	128001a0 	mov	w0, #0xfffffff2            	// #-14
  406370:	17fffedd 	b	405ee4 <cbvprintf_package+0x2bc>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
  406374:	f1003ebf 	cmp	x21, #0xf
  406378:	54ffc948 	b.hi	405ca0 <cbvprintf_package+0x78>  // b.pmore
  40637c:	17fffed9 	b	405ee0 <cbvprintf_package+0x2b8>
}
  406380:	a94153f3 	ldp	x19, x20, [sp, #16]
  406384:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406388:	a94363f7 	ldp	x23, x24, [sp, #48]
  40638c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  406390:	a94573fb 	ldp	x27, x28, [sp, #80]
  406394:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  406398:	d65f03c0 	ret

000000000040639c <cbpprintf_external>:
	uint8_t *buf = packaged;
	struct cbprintf_package_hdr_ext *hdr = packaged;
	char *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, rws_nbr, s_idx;

	if (buf == NULL) {
  40639c:	b40005e3 	cbz	x3, 406458 <cbpprintf_external+0xbc>
{
  4063a0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  4063a4:	910003fd 	mov	x29, sp
  4063a8:	a90153f3 	stp	x19, x20, [sp, #16]
  4063ac:	aa0303f4 	mov	x20, x3
  4063b0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4063b4:	aa0003f6 	mov	x22, x0
  4063b8:	aa0103f5 	mov	x21, x1
  4063bc:	a90363f7 	stp	x23, x24, [sp, #48]
  4063c0:	aa0203f7 	mov	x23, x2
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
  4063c4:	52800018 	mov	w24, #0x0                   	// #0
{
  4063c8:	f90023f9 	str	x25, [sp, #64]
	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
  4063cc:	39400c60 	ldrb	w0, [x3, #3]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  4063d0:	39400073 	ldrb	w19, [x3]
	s_nbr     = hdr->hdr.desc.str_cnt;
  4063d4:	39400479 	ldrb	w25, [x3, #1]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  4063d8:	d37f1c00 	ubfiz	x0, x0, #1, #8
  4063dc:	8b334813 	add	x19, x0, w19, uxtw #2
  4063e0:	39400860 	ldrb	w0, [x3, #2]
  4063e4:	8b000273 	add	x19, x19, x0
  4063e8:	8b130073 	add	x19, x3, x19
	for (i = 0; i < s_nbr; i++) {
  4063ec:	6b19031f 	cmp	w24, w25
  4063f0:	54000223 	b.cc	406434 <cbpprintf_external+0x98>  // b.lo, b.ul, b.last
		/* move to next string */
		s += strlen(s) + 1;
	}

	/* Skip past the header */
	buf += sizeof(*hdr);
  4063f4:	91004280 	add	x0, x20, #0x10
	u.__ap.__gr_top = NULL;
  4063f8:	a9077fe0 	stp	x0, xzr, [sp, #112]
	return formatter(out, ctx, fmt, u.ap);
  4063fc:	910143e3 	add	x3, sp, #0x50
	u.__ap.__gr_offs = 0;
  406400:	a9087fff 	stp	xzr, xzr, [sp, #128]
	return formatter(out, ctx, fmt, u.ap);
  406404:	aa1703e1 	mov	x1, x23
  406408:	aa1603e0 	mov	x0, x22
  40640c:	ad4387e0 	ldp	q0, q1, [sp, #112]
  406410:	ad000460 	stp	q0, q1, [x3]
  406414:	f9400682 	ldr	x2, [x20, #8]
  406418:	d63f02a0 	blr	x21

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
}
  40641c:	a94153f3 	ldp	x19, x20, [sp, #16]
  406420:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406424:	a94363f7 	ldp	x23, x24, [sp, #48]
  406428:	f94023f9 	ldr	x25, [sp, #64]
  40642c:	a8c97bfd 	ldp	x29, x30, [sp], #144
  406430:	d65f03c0 	ret
		ps = (char **)(buf + s_idx * sizeof(int));
  406434:	38401660 	ldrb	w0, [x19], #1
	for (i = 0; i < s_nbr; i++) {
  406438:	11000718 	add	w24, w24, #0x1
		ps = (char **)(buf + s_idx * sizeof(int));
  40643c:	d37ef400 	lsl	x0, x0, #2
		*ps = s;
  406440:	f8206a93 	str	x19, [x20, x0]
		s += strlen(s) + 1;
  406444:	aa1303e0 	mov	x0, x19
  406448:	97ffeb56 	bl	4011a0 <strlen@plt>
  40644c:	91000400 	add	x0, x0, #0x1
  406450:	8b000273 	add	x19, x19, x0
	for (i = 0; i < s_nbr; i++) {
  406454:	17ffffe6 	b	4063ec <cbpprintf_external+0x50>
		return -EINVAL;
  406458:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  40645c:	d65f03c0 	ret

0000000000406460 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  406460:	52800000 	mov	w0, #0x0                   	// #0
  406464:	d65f03c0 	ret

0000000000406468 <__printk_hook_install>:
 * routine that outputs one ASCII character at a time.
 * @param fn putc routine to install
 */
void __printk_hook_install(int (*fn)(int c))
{
	_char_out = fn;
  406468:	b0000121 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40646c:	f947b821 	ldr	x1, [x1, #3952]
  406470:	f9000020 	str	x0, [x1]
}
  406474:	d65f03c0 	ret

0000000000406478 <vprintk>:
	(void) ctx_p;
	return _char_out(c);
}

void vprintk(const char *fmt, va_list ap)
{
  406478:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40647c:	910003fd 	mov	x29, sp
	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		z_log_vprintk(fmt, ap);
  406480:	ad400420 	ldp	q0, q1, [x1]
  406484:	910043e2 	add	x2, sp, #0x10
  406488:	aa0203e1 	mov	x1, x2
  40648c:	ad000440 	stp	q0, q1, [x2]
  406490:	94000687 	bl	407eac <z_log_vprintk>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
  406494:	a8c37bfd 	ldp	x29, x30, [sp], #48
  406498:	d65f03c0 	ret

000000000040649c <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
  40649c:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  4064a0:	910003fd 	mov	x29, sp
  4064a4:	a90e8be1 	stp	x1, x2, [sp, #232]
  4064a8:	b0000121 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4064ac:	f9476821 	ldr	x1, [x1, #3792]
  4064b0:	3d801be0 	str	q0, [sp, #96]
  4064b4:	3d801fe1 	str	q1, [sp, #112]
  4064b8:	3d8023e2 	str	q2, [sp, #128]
  4064bc:	3d8027e3 	str	q3, [sp, #144]
  4064c0:	3d802be4 	str	q4, [sp, #160]
  4064c4:	3d802fe5 	str	q5, [sp, #176]
  4064c8:	3d8033e6 	str	q6, [sp, #192]
  4064cc:	3d8037e7 	str	q7, [sp, #208]
  4064d0:	a90f93e3 	stp	x3, x4, [sp, #248]
  4064d4:	a9109be5 	stp	x5, x6, [sp, #264]
  4064d8:	f9008fe7 	str	x7, [sp, #280]
  4064dc:	f9400022 	ldr	x2, [x1]
  4064e0:	f9002fe2 	str	x2, [sp, #88]
  4064e4:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  4064e8:	910483e1 	add	x1, sp, #0x120
  4064ec:	a90387e1 	stp	x1, x1, [sp, #56]
  4064f0:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  4064f4:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  4064f8:	f90027e1 	str	x1, [sp, #72]
  4064fc:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  406500:	b90053e1 	str	w1, [sp, #80]
  406504:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  406508:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  40650c:	910043e1 	add	x1, sp, #0x10
  406510:	ad400440 	ldp	q0, q1, [x2]
  406514:	ad000420 	stp	q0, q1, [x1]
  406518:	97ffffd8 	bl	406478 <vprintk>

	va_end(ap);
}
  40651c:	b0000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  406520:	f9476800 	ldr	x0, [x0, #3792]
  406524:	f9402fe2 	ldr	x2, [sp, #88]
  406528:	f9400001 	ldr	x1, [x0]
  40652c:	eb010042 	subs	x2, x2, x1
  406530:	d2800001 	mov	x1, #0x0                   	// #0
  406534:	54000040 	b.eq	40653c <printk+0xa0>  // b.none
  406538:	97ffeb7a 	bl	401320 <__stack_chk_fail@plt>
  40653c:	a8d27bfd 	ldp	x29, x30, [sp], #288
  406540:	d65f03c0 	ret

0000000000406544 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  406544:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406548:	aa0003e4 	mov	x4, x0
  40654c:	aa0103e0 	mov	x0, x1
  406550:	910003fd 	mov	x29, sp
  406554:	aa0203e1 	mov	x1, x2
  406558:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
  40655c:	d63f0080 	blr	x4
	return z_impl_z_current_get();
  406560:	94002f2c 	bl	412210 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
  406564:	94000b3e 	bl	40925c <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  406568:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  40656c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406570:	91211021 	add	x1, x1, #0x844
  406574:	911f2000 	add	x0, x0, #0x7c8
  406578:	528005a2 	mov	w2, #0x2d                  	// #45
  40657c:	94000fa1 	bl	40a400 <posix_print_error_and_exit>

0000000000406580 <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
  406580:	d2800082 	mov	x2, #0x4                   	// #4
  406584:	8b214c41 	add	x1, x2, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  406588:	b8616800 	ldr	w0, [x0, x1]
}
  40658c:	53017c00 	lsr	w0, w0, #1
  406590:	d65f03c0 	ret

0000000000406594 <free_list_remove_bidx>:
		return ((uint32_t *)cmem)[f];
  406594:	8b214c04 	add	x4, x0, w1, uxtw #3
  406598:	b9400c83 	ldr	w3, [x4, #12]

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & BIT(bidx));

	if (next_free_chunk(h, c) == c) {
  40659c:	6b03003f 	cmp	w1, w3
  4065a0:	93407c41 	sxtw	x1, w2
  4065a4:	54000121 	b.ne	4065c8 <free_list_remove_bidx+0x34>  // b.any
		/* this is the last chunk */
		h->avail_buckets &= ~BIT(bidx);
  4065a8:	d2800023 	mov	x3, #0x1                   	// #1
		b->next = 0;
  4065ac:	91001021 	add	x1, x1, #0x4
		h->avail_buckets &= ~BIT(bidx);
  4065b0:	9ac22062 	lsl	x2, x3, x2
  4065b4:	b9400c03 	ldr	w3, [x0, #12]
  4065b8:	0a220062 	bic	w2, w3, w2
  4065bc:	b9000c02 	str	w2, [x0, #12]
		b->next = 0;
  4065c0:	b821781f 	str	wzr, [x0, x1, lsl #2]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes -= chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
  4065c4:	d65f03c0 	ret
		b->next = second;
  4065c8:	91001021 	add	x1, x1, #0x4
  4065cc:	b9400882 	ldr	w2, [x4, #8]
  4065d0:	b8217803 	str	w3, [x0, x1, lsl #2]
		((uint32_t *)cmem)[f] = val;
  4065d4:	d2800181 	mov	x1, #0xc                   	// #12
  4065d8:	8b224c21 	add	x1, x1, w2, uxtw #3
  4065dc:	b8216803 	str	w3, [x0, x1]
  4065e0:	d37d7c63 	ubfiz	x3, x3, #3, #32
  4065e4:	91002063 	add	x3, x3, #0x8
  4065e8:	b8236802 	str	w2, [x0, x3]
}
  4065ec:	17fffff6 	b	4065c4 <free_list_remove_bidx+0x30>

00000000004065f0 <alloc_chunk>:
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  4065f0:	51000424 	sub	w4, w1, #0x1
	return 31 - __builtin_clz(usable_sz);
  4065f4:	528003e6 	mov	w6, #0x1f                  	// #31
  4065f8:	5ac01084 	clz	w4, w4

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
  4065fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406600:	4b0400c6 	sub	w6, w6, w4
  406604:	910003fd 	mov	x29, sp
  406608:	8b26c808 	add	x8, x0, w6, sxtw #2
  40660c:	aa0003e3 	mov	x3, x0
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
  406610:	b940110a 	ldr	w10, [x8, #16]
  406614:	3400030a 	cbz	w10, 406674 <alloc_chunk+0x84>
  406618:	2a0103e7 	mov	w7, w1
  40661c:	52800069 	mov	w9, #0x3                   	// #3
		return ((uint32_t *)cmem)[f];
  406620:	d280018b 	mov	x11, #0xc                   	// #12
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
  406624:	b9401105 	ldr	w5, [x8, #16]
			if (chunk_size(h, c) >= sz) {
  406628:	aa0303e0 	mov	x0, x3
  40662c:	2a0503e1 	mov	w1, w5
  406630:	97ffffd4 	bl	406580 <chunk_size>
  406634:	6b07001f 	cmp	w0, w7
  406638:	54000103 	b.cc	406658 <alloc_chunk+0x68>  // b.lo, b.ul, b.last
				free_list_remove_bidx(h, c, bi);
  40663c:	2a0603e2 	mov	w2, w6

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
  406640:	2a0503e1 	mov	w1, w5
  406644:	aa0303e0 	mov	x0, x3
  406648:	97ffffd3 	bl	406594 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
  40664c:	2a0503e0 	mov	w0, w5
  406650:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406654:	d65f03c0 	ret
  406658:	8b254d65 	add	x5, x11, w5, uxtw #3
		} while (--i && b->next != first);
  40665c:	71000529 	subs	w9, w9, #0x1
  406660:	b8656860 	ldr	w0, [x3, x5]
			b->next = next_free_chunk(h, c);
  406664:	b9001100 	str	w0, [x8, #16]
		} while (--i && b->next != first);
  406668:	54000060 	b.eq	406674 <alloc_chunk+0x84>  // b.none
  40666c:	6b00015f 	cmp	w10, w0
  406670:	54fffda1 	b.ne	406624 <alloc_chunk+0x34>  // b.any
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
  406674:	52800400 	mov	w0, #0x20                  	// #32
  406678:	4b040000 	sub	w0, w0, w4
  40667c:	d2800025 	mov	x5, #0x1                   	// #1
  406680:	9ac020a5 	lsl	x5, x5, x0
  406684:	b9400c60 	ldr	w0, [x3, #12]
  406688:	4b0503e5 	neg	w5, w5
	if (bmask != 0U) {
  40668c:	6a0000a5 	ands	w5, w5, w0
  406690:	54fffde0 	b.eq	40664c <alloc_chunk+0x5c>  // b.none
		int minbucket = __builtin_ctz(bmask);
  406694:	5ac000a2 	rbit	w2, w5
  406698:	5ac01042 	clz	w2, w2
		chunkid_t c = h->buckets[minbucket].next;
  40669c:	8b22c860 	add	x0, x3, w2, sxtw #2
  4066a0:	b9401005 	ldr	w5, [x0, #16]
  4066a4:	17ffffe7 	b	406640 <alloc_chunk+0x50>

00000000004066a8 <free_list_remove>:
{
  4066a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4066ac:	aa0003e3 	mov	x3, x0
  4066b0:	2a0103e4 	mov	w4, w1
  4066b4:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  4066b8:	97ffffb2 	bl	406580 <chunk_size>
	if (!solo_free_header(h, c)) {
  4066bc:	7100041f 	cmp	w0, #0x1
  4066c0:	54000120 	b.eq	4066e4 <free_list_remove+0x3c>  // b.none
}
  4066c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  4066c8:	51000402 	sub	w2, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  4066cc:	5ac01042 	clz	w2, w2
		free_list_remove_bidx(h, c, bidx);
  4066d0:	528003e0 	mov	w0, #0x1f                  	// #31
  4066d4:	2a0403e1 	mov	w1, w4
  4066d8:	4b020002 	sub	w2, w0, w2
  4066dc:	aa0303e0 	mov	x0, x3
  4066e0:	17ffffad 	b	406594 <free_list_remove_bidx>
}
  4066e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4066e8:	d65f03c0 	ret

00000000004066ec <free_list_add>:
{
  4066ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4066f0:	aa0003e3 	mov	x3, x0
  4066f4:	2a0103e4 	mov	w4, w1
  4066f8:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  4066fc:	97ffffa1 	bl	406580 <chunk_size>
	if (!solo_free_header(h, c)) {
  406700:	7100041f 	cmp	w0, #0x1
  406704:	54000260 	b.eq	406750 <free_list_add+0x64>  // b.none
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  406708:	51000400 	sub	w0, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  40670c:	528003e1 	mov	w1, #0x1f                  	// #31
  406710:	5ac01000 	clz	w0, w0
  406714:	4b000021 	sub	w1, w1, w0
	if (b->next == 0U) {
  406718:	d37d7c80 	ubfiz	x0, x4, #3, #32
  40671c:	91002006 	add	x6, x0, #0x8
		((uint32_t *)cmem)[f] = val;
  406720:	91003000 	add	x0, x0, #0xc
  406724:	8b21c867 	add	x7, x3, w1, sxtw #2
  406728:	b94010e5 	ldr	w5, [x7, #16]
  40672c:	35000165 	cbnz	w5, 406758 <free_list_add+0x6c>
		h->avail_buckets |= BIT(bidx);
  406730:	d2800022 	mov	x2, #0x1                   	// #1
  406734:	9ac12042 	lsl	x2, x2, x1
  406738:	b9400c61 	ldr	w1, [x3, #12]
  40673c:	2a020021 	orr	w1, w1, w2
  406740:	b9000c61 	str	w1, [x3, #12]
		b->next = c;
  406744:	b90010e4 	str	w4, [x7, #16]
  406748:	b8266864 	str	w4, [x3, x6]
  40674c:	b8206864 	str	w4, [x3, x0]
}
  406750:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406754:	d65f03c0 	ret
		return ((uint32_t *)cmem)[f];
  406758:	d37d7ca1 	ubfiz	x1, x5, #3, #32
  40675c:	91002021 	add	x1, x1, #0x8
  406760:	b8616862 	ldr	w2, [x3, x1]
		((uint32_t *)cmem)[f] = val;
  406764:	b8266862 	str	w2, [x3, x6]
  406768:	b8206865 	str	w5, [x3, x0]
  40676c:	d2800180 	mov	x0, #0xc                   	// #12
  406770:	8b224c02 	add	x2, x0, w2, uxtw #3
  406774:	b8226864 	str	w4, [x3, x2]
  406778:	b8216864 	str	w4, [x3, x1]
  40677c:	17fffff5 	b	406750 <free_list_add+0x64>

0000000000406780 <merge_chunks>:
{
  406780:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406784:	2a0203e3 	mov	w3, w2
  406788:	aa0003e4 	mov	x4, x0
  40678c:	910003fd 	mov	x29, sp
  406790:	2a0103e6 	mov	w6, w1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
  406794:	97ffff7b 	bl	406580 <chunk_size>
  406798:	2a0303e1 	mov	w1, w3
  40679c:	2a0003e5 	mov	w5, w0
  4067a0:	aa0403e0 	mov	x0, x4
  4067a4:	97ffff77 	bl	406580 <chunk_size>
  4067a8:	0b0000a5 	add	w5, w5, w0
  4067ac:	d2800080 	mov	x0, #0x4                   	// #4
  4067b0:	8b264c06 	add	x6, x0, w6, uxtw #3
	return c + chunk_size(h, c);
  4067b4:	2a0303e1 	mov	w1, w3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  4067b8:	531f78a0 	lsl	w0, w5, #1
		((uint32_t *)cmem)[f] = val;
  4067bc:	b8266880 	str	w0, [x4, x6]
	return c + chunk_size(h, c);
  4067c0:	aa0403e0 	mov	x0, x4
  4067c4:	97ffff6f 	bl	406580 <chunk_size>
	void *cmem = &buf[c];
  4067c8:	0b000063 	add	w3, w3, w0
  4067cc:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  4067d0:	b8236885 	str	w5, [x4, x3]
}
  4067d4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4067d8:	d65f03c0 	ret

00000000004067dc <free_chunk>:
{
  4067dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4067e0:	2a0103e8 	mov	w8, w1
  4067e4:	aa0003e7 	mov	x7, x0
  4067e8:	910003fd 	mov	x29, sp
	return c + chunk_size(h, c);
  4067ec:	97ffff65 	bl	406580 <chunk_size>
  4067f0:	0b000101 	add	w1, w8, w0
		return ((uint32_t *)cmem)[f];
  4067f4:	d2800080 	mov	x0, #0x4                   	// #4
  4067f8:	8b214c00 	add	x0, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  4067fc:	b86068e0 	ldr	w0, [x7, x0]
	if (!chunk_used(h, right_chunk(h, c))) {
  406800:	37000140 	tbnz	w0, #0, 406828 <free_chunk+0x4c>
		free_list_remove(h, right_chunk(h, c));
  406804:	aa0703e0 	mov	x0, x7
  406808:	97ffffa8 	bl	4066a8 <free_list_remove>
	return c + chunk_size(h, c);
  40680c:	2a0803e1 	mov	w1, w8
  406810:	aa0703e0 	mov	x0, x7
  406814:	97ffff5b 	bl	406580 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
  406818:	0b000102 	add	w2, w8, w0
  40681c:	2a0803e1 	mov	w1, w8
  406820:	aa0703e0 	mov	x0, x7
  406824:	97ffffd7 	bl	406780 <merge_chunks>
	void *cmem = &buf[c];
  406828:	d37d7d09 	ubfiz	x9, x8, #3, #32
		return ((uint32_t *)cmem)[f];
  40682c:	d2800080 	mov	x0, #0x4                   	// #4
	return c - chunk_field(h, c, LEFT_SIZE);
  406830:	b86968e1 	ldr	w1, [x7, x9]
  406834:	4b010101 	sub	w1, w8, w1
		return ((uint32_t *)cmem)[f];
  406838:	8b214c00 	add	x0, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  40683c:	b86068e0 	ldr	w0, [x7, x0]
	if (!chunk_used(h, left_chunk(h, c))) {
  406840:	37000140 	tbnz	w0, #0, 406868 <free_chunk+0x8c>
		free_list_remove(h, left_chunk(h, c));
  406844:	aa0703e0 	mov	x0, x7
  406848:	97ffff98 	bl	4066a8 <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
  40684c:	b86968e1 	ldr	w1, [x7, x9]
		merge_chunks(h, left_chunk(h, c), c);
  406850:	2a0803e2 	mov	w2, w8
  406854:	aa0703e0 	mov	x0, x7
  406858:	4b010101 	sub	w1, w8, w1
  40685c:	97ffffc9 	bl	406780 <merge_chunks>
  406860:	b86968e0 	ldr	w0, [x7, x9]
  406864:	4b000108 	sub	w8, w8, w0
}
  406868:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free_list_add(h, c);
  40686c:	2a0803e1 	mov	w1, w8
  406870:	aa0703e0 	mov	x0, x7
  406874:	17ffff9e 	b	4066ec <free_list_add>

0000000000406878 <split_chunks>:
{
  406878:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40687c:	2a0203e3 	mov	w3, w2
  406880:	2a0103e5 	mov	w5, w1
  406884:	aa0003e4 	mov	x4, x0
  406888:	910003fd 	mov	x29, sp
	chunksz_t rsz = sz0 - lsz;
  40688c:	4b0300a6 	sub	w6, w5, w3
	chunksz_t sz0 = chunk_size(h, lc);
  406890:	97ffff3c 	bl	406580 <chunk_size>
	chunksz_t rsz = sz0 - lsz;
  406894:	0b0000c6 	add	w6, w6, w0
		((uint32_t *)cmem)[f] = val;
  406898:	d2800080 	mov	x0, #0x4                   	// #4
	chunksz_t lsz = rc - lc;
  40689c:	4b050061 	sub	w1, w3, w5
  4068a0:	8b254c05 	add	x5, x0, w5, uxtw #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  4068a4:	531f7820 	lsl	w0, w1, #1
		((uint32_t *)cmem)[f] = val;
  4068a8:	b8256880 	str	w0, [x4, x5]
	void *cmem = &buf[c];
  4068ac:	d37d7c60 	ubfiz	x0, x3, #3, #32
		((uint32_t *)cmem)[f] = val;
  4068b0:	8b000082 	add	x2, x4, x0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  4068b4:	531f78c5 	lsl	w5, w6, #1
		((uint32_t *)cmem)[f] = val;
  4068b8:	b9000445 	str	w5, [x2, #4]
  4068bc:	b8206881 	str	w1, [x4, x0]
	return c + chunk_size(h, c);
  4068c0:	2a0303e1 	mov	w1, w3
  4068c4:	aa0403e0 	mov	x0, x4
  4068c8:	97ffff2e 	bl	406580 <chunk_size>
	void *cmem = &buf[c];
  4068cc:	0b000063 	add	w3, w3, w0
  4068d0:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  4068d4:	b8236886 	str	w6, [x4, x3]
}
  4068d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4068dc:	d65f03c0 	ret

00000000004068e0 <sys_heap_free>:
	if (mem == NULL) {
  4068e0:	b4000901 	cbz	x1, 406a00 <sys_heap_free+0x120>
{
  4068e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  4068e8:	d1002023 	sub	x3, x1, #0x8
{
  4068ec:	910003fd 	mov	x29, sp
  4068f0:	a90153f3 	stp	x19, x20, [sp, #16]
  4068f4:	aa0103f3 	mov	x19, x1
	struct z_heap *h = heap->heap;
  4068f8:	f9400004 	ldr	x4, [x0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  4068fc:	d2800100 	mov	x0, #0x8                   	// #8
  406900:	cb040063 	sub	x3, x3, x4
  406904:	9ac00c63 	sdiv	x3, x3, x0
		return ((uint32_t *)cmem)[f];
  406908:	8b234c86 	add	x6, x4, w3, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  40690c:	b94004c5 	ldr	w5, [x6, #4]
	__ASSERT(chunk_used(h, c),
  406910:	370002c5 	tbnz	w5, #0, 406968 <sys_heap_free+0x88>
  406914:	d0000074 	adrp	x20, 414000 <dlc_table.0+0x78d>
  406918:	9121b694 	add	x20, x20, #0x86d
  40691c:	aa1403e2 	mov	x2, x20
  406920:	528015e3 	mov	w3, #0xaf                  	// #175
  406924:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  406928:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40692c:	91223821 	add	x1, x1, #0x88e
  406930:	911e2800 	add	x0, x0, #0x78a
  406934:	94000497 	bl	407b90 <assert_print>
  406938:	aa1303e1 	mov	x1, x19
  40693c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406940:	91227c00 	add	x0, x0, #0x89f
  406944:	94000493 	bl	407b90 <assert_print>
  406948:	aa1403e0 	mov	x0, x20
  40694c:	528015e1 	mov	w1, #0xaf                  	// #175
  406950:	940004ba 	bl	407c38 <assert_post_action>
  406954:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406958:	aa1403e1 	mov	x1, x20
  40695c:	911f2000 	add	x0, x0, #0x7c8
  406960:	528015e2 	mov	w2, #0xaf                  	// #175
  406964:	94000ea7 	bl	40a400 <posix_print_error_and_exit>
	return c + chunk_size(h, c);
  406968:	2a0303e1 	mov	w1, w3
  40696c:	aa0403e0 	mov	x0, x4
  406970:	97ffff04 	bl	406580 <chunk_size>
  406974:	0b030001 	add	w1, w0, w3
	void *cmem = &buf[c];
  406978:	0b030000 	add	w0, w0, w3
  40697c:	d37df000 	lsl	x0, x0, #3
	return c - chunk_field(h, c, LEFT_SIZE);
  406980:	b8606880 	ldr	w0, [x4, x0]
  406984:	4b000021 	sub	w1, w1, w0
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
  406988:	6b01007f 	cmp	w3, w1
  40698c:	540002c0 	b.eq	4069e4 <sys_heap_free+0x104>  // b.none
  406990:	d0000074 	adrp	x20, 414000 <dlc_table.0+0x78d>
  406994:	9121b694 	add	x20, x20, #0x86d
  406998:	aa1403e2 	mov	x2, x20
  40699c:	528016e3 	mov	w3, #0xb7                  	// #183
  4069a0:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  4069a4:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4069a8:	91235c21 	add	x1, x1, #0x8d7
  4069ac:	911e2800 	add	x0, x0, #0x78a
  4069b0:	94000478 	bl	407b90 <assert_print>
  4069b4:	aa1303e1 	mov	x1, x19
  4069b8:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4069bc:	9123f400 	add	x0, x0, #0x8fd
  4069c0:	94000474 	bl	407b90 <assert_print>
  4069c4:	aa1403e0 	mov	x0, x20
  4069c8:	528016e1 	mov	w1, #0xb7                  	// #183
  4069cc:	9400049b 	bl	407c38 <assert_post_action>
  4069d0:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4069d4:	aa1403e1 	mov	x1, x20
  4069d8:	911f2000 	add	x0, x0, #0x7c8
  4069dc:	528016e2 	mov	w2, #0xb7                  	// #183
  4069e0:	94000e88 	bl	40a400 <posix_print_error_and_exit>
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
  4069e4:	121f78a5 	and	w5, w5, #0xfffffffe
  4069e8:	b90004c5 	str	w5, [x6, #4]
	free_chunk(h, c);
  4069ec:	2a0303e1 	mov	w1, w3
  4069f0:	aa0403e0 	mov	x0, x4
}
  4069f4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4069f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free_chunk(h, c);
  4069fc:	17ffff78 	b	4067dc <free_chunk>
  406a00:	d65f03c0 	ret

0000000000406a04 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
	struct z_heap *h = heap->heap;
  406a04:	f940000d 	ldr	x13, [x0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
  406a08:	b50000c1 	cbnz	x1, 406a20 <sys_heap_alloc+0x1c>
		return NULL;
  406a0c:	d2800000 	mov	x0, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  406a10:	d65f03c0 	ret
		return NULL;
  406a14:	d2800000 	mov	x0, #0x0                   	// #0
}
  406a18:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406a1c:	d65f03c0 	ret
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  406a20:	b94009a0 	ldr	w0, [x13, #8]
	if (bytes == 0U || size_too_big(h, bytes)) {
  406a24:	eb410c1f 	cmp	x0, x1, lsr #3
  406a28:	54ffff29 	b.ls	406a0c <sys_heap_alloc+0x8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406a2c:	91003c21 	add	x1, x1, #0xf
{
  406a30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	chunkid_t c = alloc_chunk(h, chunk_sz);
  406a34:	aa0d03e0 	mov	x0, x13
  406a38:	d343fc2c 	lsr	x12, x1, #3
{
  406a3c:	910003fd 	mov	x29, sp
	chunkid_t c = alloc_chunk(h, chunk_sz);
  406a40:	2a0c03e1 	mov	w1, w12
  406a44:	97fffeeb 	bl	4065f0 <alloc_chunk>
  406a48:	2a0003e8 	mov	w8, w0
	if (c == 0U) {
  406a4c:	34fffe40 	cbz	w0, 406a14 <sys_heap_alloc+0x10>
	if (chunk_size(h, c) > chunk_sz) {
  406a50:	2a0003e1 	mov	w1, w0
  406a54:	aa0d03e0 	mov	x0, x13
  406a58:	97fffeca 	bl	406580 <chunk_size>
  406a5c:	6b0c001f 	cmp	w0, w12
  406a60:	54000129 	b.ls	406a84 <sys_heap_alloc+0x80>  // b.plast
		split_chunks(h, c, c + chunk_sz);
  406a64:	0b0c010c 	add	w12, w8, w12
  406a68:	2a0803e1 	mov	w1, w8
  406a6c:	2a0c03e2 	mov	w2, w12
  406a70:	aa0d03e0 	mov	x0, x13
  406a74:	97ffff81 	bl	406878 <split_chunks>
		free_list_add(h, c + chunk_sz);
  406a78:	2a0c03e1 	mov	w1, w12
  406a7c:	aa0d03e0 	mov	x0, x13
  406a80:	97ffff1b 	bl	4066ec <free_list_add>
	void *cmem = &buf[c];
  406a84:	d37d7d08 	ubfiz	x8, x8, #3, #32
  406a88:	8b0801a1 	add	x1, x13, x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406a8c:	91002108 	add	x8, x8, #0x8
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406a90:	b9400420 	ldr	w0, [x1, #4]
  406a94:	32000000 	orr	w0, w0, #0x1
  406a98:	b9000420 	str	w0, [x1, #4]
  406a9c:	8b0801a0 	add	x0, x13, x8
	return mem;
  406aa0:	17ffffde 	b	406a18 <sys_heap_alloc+0x14>

0000000000406aa4 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
  406aa4:	aa0203ec 	mov	x12, x2
  406aa8:	91003c43 	add	x3, x2, #0xf
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
  406aac:	cb0103e2 	neg	x2, x1
  406ab0:	8a01004e 	and	x14, x2, x1
	struct z_heap *h = heap->heap;
  406ab4:	f940000d 	ldr	x13, [x0]
	if (align != rew) {
  406ab8:	ea22003f 	bics	xzr, x1, x2
  406abc:	54000400 	b.eq	406b3c <sys_heap_aligned_alloc+0x98>  // b.none
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
  406ac0:	f10021df 	cmp	x14, #0x8
  406ac4:	aa0e03ef 	mov	x15, x14
  406ac8:	d2800100 	mov	x0, #0x8                   	// #8
  406acc:	9a8091c0 	csel	x0, x14, x0, ls  // ls = plast
		align -= rew;
  406ad0:	cb0e002e 	sub	x14, x1, x14
{
  406ad4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  406ad8:	d10005d2 	sub	x18, x14, #0x1
{
  406adc:	910003fd 	mov	x29, sp
  406ae0:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  406ae4:	ea0e025f 	tst	x18, x14
  406ae8:	54000380 	b.eq	406b58 <sys_heap_aligned_alloc+0xb4>  // b.none
  406aec:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  406af0:	9121b673 	add	x19, x19, #0x86d
  406af4:	aa1303e2 	mov	x2, x19
  406af8:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  406afc:	9124e421 	add	x1, x1, #0x939
  406b00:	52802883 	mov	w3, #0x144                 	// #324
  406b04:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406b08:	911e2800 	add	x0, x0, #0x78a
  406b0c:	94000421 	bl	407b90 <assert_print>
  406b10:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406b14:	91255000 	add	x0, x0, #0x954
  406b18:	9400041e 	bl	407b90 <assert_print>
  406b1c:	aa1303e0 	mov	x0, x19
  406b20:	52802881 	mov	w1, #0x144                 	// #324
  406b24:	94000445 	bl	407c38 <assert_post_action>
  406b28:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406b2c:	aa1303e1 	mov	x1, x19
  406b30:	911f2000 	add	x0, x0, #0x7c8
  406b34:	52802882 	mov	w2, #0x144                 	// #324
  406b38:	94000e32 	bl	40a400 <posix_print_error_and_exit>
		if (align <= chunk_header_bytes(h)) {
  406b3c:	f100203f 	cmp	x1, #0x8
  406b40:	54000068 	b.hi	406b4c <sys_heap_aligned_alloc+0xa8>  // b.pmore
			return sys_heap_alloc(heap, bytes);
  406b44:	aa0c03e1 	mov	x1, x12
  406b48:	17ffffaf 	b	406a04 <sys_heap_alloc>
		rew = 0;
  406b4c:	d280000f 	mov	x15, #0x0                   	// #0
		gap = chunk_header_bytes(h);
  406b50:	d2800100 	mov	x0, #0x8                   	// #8
  406b54:	17ffffe0 	b	406ad4 <sys_heap_aligned_alloc+0x30>

	if (bytes == 0 || size_too_big(h, bytes)) {
  406b58:	b50000cc 	cbnz	x12, 406b70 <sys_heap_aligned_alloc+0xcc>
		return NULL;
  406b5c:	d2800009 	mov	x9, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  406b60:	aa0903e0 	mov	x0, x9
  406b64:	f9400bf3 	ldr	x19, [sp, #16]
  406b68:	a8c27bfd 	ldp	x29, x30, [sp], #32
  406b6c:	d65f03c0 	ret
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  406b70:	b94009a1 	ldr	w1, [x13, #8]
	if (bytes == 0 || size_too_big(h, bytes)) {
  406b74:	eb4c0c3f 	cmp	x1, x12, lsr #3
  406b78:	54ffff29 	b.ls	406b5c <sys_heap_aligned_alloc+0xb8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406b7c:	cb0001c1 	sub	x1, x14, x0
	chunkid_t c0 = alloc_chunk(h, padded_sz);
  406b80:	aa0d03e0 	mov	x0, x13
  406b84:	8b030021 	add	x1, x1, x3
  406b88:	d3438821 	ubfx	x1, x1, #3, #32
  406b8c:	97fffe99 	bl	4065f0 <alloc_chunk>
  406b90:	2a0003e7 	mov	w7, w0
	if (c0 == 0) {
  406b94:	34fffe40 	cbz	w0, 406b5c <sys_heap_aligned_alloc+0xb8>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406b98:	d37d7ce9 	ubfiz	x9, x7, #3, #32
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  406b9c:	cb0e03ee 	neg	x14, x14
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406ba0:	91002129 	add	x9, x9, #0x8
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406ba4:	d2800100 	mov	x0, #0x8                   	// #8
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  406ba8:	8b0f0129 	add	x9, x9, x15
  406bac:	8b0901a9 	add	x9, x13, x9
  406bb0:	8b120129 	add	x9, x9, x18
  406bb4:	8a0e0129 	and	x9, x9, x14
  406bb8:	cb0f0129 	sub	x9, x9, x15
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406bbc:	d100212a 	sub	x10, x9, #0x8
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  406bc0:	8b0c0128 	add	x8, x9, x12
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406bc4:	cb0d014a 	sub	x10, x10, x13
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  406bc8:	91001d08 	add	x8, x8, #0x7
  406bcc:	927df108 	and	x8, x8, #0xfffffffffffffff8
	chunkid_t c_end = end - chunk_buf(h);
  406bd0:	cb0d0108 	sub	x8, x8, x13
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406bd4:	9ac00d4a 	sdiv	x10, x10, x0
	chunkid_t c_end = end - chunk_buf(h);
  406bd8:	9343fd08 	asr	x8, x8, #3
	if (c > c0) {
  406bdc:	6b0a00ff 	cmp	w7, w10
  406be0:	54000102 	b.cs	406c00 <sys_heap_aligned_alloc+0x15c>  // b.hs, b.nlast
		split_chunks(h, c0, c);
  406be4:	2a0a03e2 	mov	w2, w10
  406be8:	2a0703e1 	mov	w1, w7
  406bec:	aa0d03e0 	mov	x0, x13
  406bf0:	97ffff22 	bl	406878 <split_chunks>
		free_list_add(h, c0);
  406bf4:	2a0703e1 	mov	w1, w7
  406bf8:	aa0d03e0 	mov	x0, x13
  406bfc:	97fffebc 	bl	4066ec <free_list_add>
	return c + chunk_size(h, c);
  406c00:	2a0a03e1 	mov	w1, w10
  406c04:	aa0d03e0 	mov	x0, x13
  406c08:	97fffe5e 	bl	406580 <chunk_size>
  406c0c:	0b0a0000 	add	w0, w0, w10
	if (right_chunk(h, c) > c_end) {
  406c10:	6b00011f 	cmp	w8, w0
  406c14:	54000102 	b.cs	406c34 <sys_heap_aligned_alloc+0x190>  // b.hs, b.nlast
		split_chunks(h, c, c_end);
  406c18:	2a0803e2 	mov	w2, w8
  406c1c:	2a0a03e1 	mov	w1, w10
  406c20:	aa0d03e0 	mov	x0, x13
  406c24:	97ffff15 	bl	406878 <split_chunks>
		free_list_add(h, c_end);
  406c28:	2a0803e1 	mov	w1, w8
  406c2c:	aa0d03e0 	mov	x0, x13
  406c30:	97fffeaf 	bl	4066ec <free_list_add>
	void *cmem = &buf[c];
  406c34:	8b2a4daa 	add	x10, x13, w10, uxtw #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406c38:	b9400540 	ldr	w0, [x10, #4]
  406c3c:	32000000 	orr	w0, w0, #0x1
  406c40:	b9000540 	str	w0, [x10, #4]
  406c44:	17ffffc7 	b	406b60 <sys_heap_aligned_alloc+0xbc>

0000000000406c48 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
  406c48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		/* Must fit in a 15 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
	} else {
		/* Must fit in a 31 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  406c4c:	b24087e3 	mov	x3, #0x3ffffffff           	// #17179869183
{
  406c50:	910003fd 	mov	x29, sp
  406c54:	a90153f3 	stp	x19, x20, [sp, #16]
  406c58:	f90013f5 	str	x21, [sp, #32]
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  406c5c:	eb03005f 	cmp	x2, x3
  406c60:	540002a9 	b.ls	406cb4 <sys_heap_init+0x6c>  // b.plast
  406c64:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  406c68:	9121b673 	add	x19, x19, #0x86d
  406c6c:	aa1303e2 	mov	x2, x19
  406c70:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  406c74:	9125c421 	add	x1, x1, #0x971
  406c78:	52803dc3 	mov	w3, #0x1ee                 	// #494
  406c7c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406c80:	911e2800 	add	x0, x0, #0x78a
  406c84:	940003c3 	bl	407b90 <assert_print>
  406c88:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406c8c:	91262c00 	add	x0, x0, #0x98b
  406c90:	940003c0 	bl	407b90 <assert_print>
  406c94:	aa1303e0 	mov	x0, x19
  406c98:	52803dc1 	mov	w1, #0x1ee                 	// #494
  406c9c:	940003e7 	bl	407c38 <assert_post_action>
  406ca0:	52803dc2 	mov	w2, #0x1ee                 	// #494
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
  406ca4:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406ca8:	aa1303e1 	mov	x1, x19
  406cac:	911f2000 	add	x0, x0, #0x7c8
  406cb0:	94000dd4 	bl	40a400 <posix_print_error_and_exit>
  406cb4:	f100205f 	cmp	x2, #0x8
  406cb8:	54000248 	b.hi	406d00 <sys_heap_init+0xb8>  // b.pmore
  406cbc:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  406cc0:	9121b673 	add	x19, x19, #0x86d
  406cc4:	aa1303e2 	mov	x2, x19
  406cc8:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  406ccc:	91268821 	add	x1, x1, #0x9a2
  406cd0:	52803e43 	mov	w3, #0x1f2                 	// #498
  406cd4:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406cd8:	911e2800 	add	x0, x0, #0x78a
  406cdc:	940003ad 	bl	407b90 <assert_print>
  406ce0:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406ce4:	91270c00 	add	x0, x0, #0x9c3
  406ce8:	940003aa 	bl	407b90 <assert_print>
  406cec:	aa1303e0 	mov	x0, x19
  406cf0:	52803e41 	mov	w1, #0x1f2                 	// #498
  406cf4:	940003d1 	bl	407c38 <assert_post_action>
  406cf8:	52803e42 	mov	w2, #0x1f2                 	// #498
  406cfc:	17ffffea 	b	406ca4 <sys_heap_init+0x5c>
	bytes -= heap_footer_bytes(bytes);
  406d00:	d1002042 	sub	x2, x2, #0x8

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  406d04:	91001c34 	add	x20, x1, #0x7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  406d08:	8b020033 	add	x19, x1, x2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  406d0c:	927df294 	and	x20, x20, #0xfffffffffffffff8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  406d10:	927df273 	and	x19, x19, #0xfffffffffffffff8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
  406d14:	cb140273 	sub	x19, x19, x20
  406d18:	d343fe73 	lsr	x19, x19, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
  406d1c:	71000a7f 	cmp	w19, #0x2
  406d20:	54000248 	b.hi	406d68 <sys_heap_init+0x120>  // b.pmore
  406d24:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  406d28:	9121b673 	add	x19, x19, #0x86d
  406d2c:	aa1303e2 	mov	x2, x19
  406d30:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  406d34:	91277021 	add	x1, x1, #0x9dc
  406d38:	52803f63 	mov	w3, #0x1fb                 	// #507
  406d3c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406d40:	911e2800 	add	x0, x0, #0x78a
  406d44:	94000393 	bl	407b90 <assert_print>
  406d48:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406d4c:	91270c00 	add	x0, x0, #0x9c3
  406d50:	94000390 	bl	407b90 <assert_print>
  406d54:	aa1303e0 	mov	x0, x19
  406d58:	52803f61 	mov	w1, #0x1fb                 	// #507
  406d5c:	940003b7 	bl	407c38 <assert_post_action>
  406d60:	52803f62 	mov	w2, #0x1fb                 	// #507
  406d64:	17ffffd0 	b	406ca4 <sys_heap_init+0x5c>

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
  406d68:	f9000014 	str	x20, [x0]
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  406d6c:	51000660 	sub	w0, w19, #0x1
	return 31 - __builtin_clz(usable_sz);
  406d70:	5ac01000 	clz	w0, w0
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406d74:	52800495 	mov	w21, #0x24                  	// #36
  406d78:	4b0002b5 	sub	w21, w21, w0
  406d7c:	d28000e1 	mov	x1, #0x7                   	// #7
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
  406d80:	29017e93 	stp	w19, wzr, [x20, #8]
  406d84:	8b35c835 	add	x21, x1, w21, sxtw #2
  406d88:	d343feb5 	lsr	x21, x21, #3

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
  406d8c:	11000aa1 	add	w1, w21, #0x2
  406d90:	6b13003f 	cmp	w1, w19
  406d94:	54000249 	b.ls	406ddc <sys_heap_init+0x194>  // b.plast
  406d98:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  406d9c:	9121b673 	add	x19, x19, #0x86d
  406da0:	aa1303e2 	mov	x2, x19
  406da4:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  406da8:	91281421 	add	x1, x1, #0xa05
  406dac:	52804183 	mov	w3, #0x20c                 	// #524
  406db0:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406db4:	911e2800 	add	x0, x0, #0x78a
  406db8:	94000376 	bl	407b90 <assert_print>
  406dbc:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  406dc0:	91270c00 	add	x0, x0, #0x9c3
  406dc4:	94000373 	bl	407b90 <assert_print>
  406dc8:	aa1303e0 	mov	x0, x19
  406dcc:	52804181 	mov	w1, #0x20c                 	// #524
  406dd0:	9400039a 	bl	407c38 <assert_post_action>
  406dd4:	52804182 	mov	w2, #0x20c                 	// #524
  406dd8:	17ffffb3 	b	406ca4 <sys_heap_init+0x5c>

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
  406ddc:	52800402 	mov	w2, #0x20                  	// #32
  406de0:	4b000042 	sub	w2, w2, w0
  406de4:	52800001 	mov	w1, #0x0                   	// #0
  406de8:	91004280 	add	x0, x20, #0x10
  406dec:	d37ef442 	lsl	x2, x2, #2
  406df0:	97ffe92c 	bl	4012a0 <memset@plt>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406df4:	531f7aa0 	lsl	w0, w21, #1
		((uint32_t *)cmem)[f] = val;
  406df8:	8b150e82 	add	x2, x20, x21, lsl #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406dfc:	32000000 	orr	w0, w0, #0x1
	void *cmem = &buf[c];
  406e00:	d37df2a1 	lsl	x1, x21, #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406e04:	2900029f 	stp	wzr, w0, [x20]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  406e08:	4b150260 	sub	w0, w19, w21
	void *cmem = &buf[c];
  406e0c:	d37d7e73 	ubfiz	x19, x19, #3, #32
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406e10:	531f7803 	lsl	w3, w0, #1
		((uint32_t *)cmem)[f] = val;
  406e14:	b9000443 	str	w3, [x2, #4]
  406e18:	b8216a95 	str	w21, [x20, x1]
  406e1c:	8b130281 	add	x1, x20, x19
  406e20:	b8336a80 	str	w0, [x20, x19]
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406e24:	52800020 	mov	w0, #0x1                   	// #1
  406e28:	b9000420 	str	w0, [x1, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
  406e2c:	2a1503e1 	mov	w1, w21
  406e30:	aa1403e0 	mov	x0, x20
}
  406e34:	a94153f3 	ldp	x19, x20, [sp, #16]
  406e38:	f94013f5 	ldr	x21, [sp, #32]
  406e3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	free_list_add(h, chunk0_size);
  406e40:	17fffe2b 	b	4066ec <free_list_add>

0000000000406e44 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
  406e44:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  406e48:	910003fd 	mov	x29, sp
  406e4c:	a90153f3 	stp	x19, x20, [sp, #16]
  406e50:	aa0203f4 	mov	x20, x2
	size_t count = 0;
  406e54:	d2800013 	mov	x19, #0x0                   	// #0
{
  406e58:	a9025bf5 	stp	x21, x22, [sp, #32]
  406e5c:	aa0003f6 	mov	x22, x0
  406e60:	aa0303f5 	mov	x21, x3
  406e64:	f9001bf7 	str	x23, [sp, #48]
  406e68:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
  406e6c:	8b130280 	add	x0, x20, x19
  406e70:	eb0002bf 	cmp	x21, x0
  406e74:	54000148 	b.hi	406e9c <outs+0x58>  // b.pmore
  406e78:	b40000f5 	cbz	x21, 406e94 <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
  406e7c:	2a1303e0 	mov	w0, w19
}
  406e80:	a94153f3 	ldp	x19, x20, [sp, #16]
  406e84:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406e88:	f9401bf7 	ldr	x23, [sp, #48]
  406e8c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  406e90:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
  406e94:	38736a80 	ldrb	w0, [x20, x19]
  406e98:	34ffff20 	cbz	w0, 406e7c <outs+0x38>
		int rc = out((int)*sp++, ctx);
  406e9c:	38736a80 	ldrb	w0, [x20, x19]
  406ea0:	aa1703e1 	mov	x1, x23
  406ea4:	d63f02c0 	blr	x22
		if (rc < 0) {
  406ea8:	37fffec0 	tbnz	w0, #31, 406e80 <outs+0x3c>
		++count;
  406eac:	91000673 	add	x19, x19, #0x1
  406eb0:	17ffffef 	b	406e6c <outs+0x28>

0000000000406eb4 <extract_decimal>:
{
  406eb4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  406eb8:	910003fd 	mov	x29, sp
  406ebc:	a90153f3 	stp	x19, x20, [sp, #16]
  406ec0:	aa0003f4 	mov	x20, x0
	const char *sp = *str;
  406ec4:	f9400013 	ldr	x19, [x0]
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406ec8:	97ffe93a 	bl	4013b0 <__ctype_b_loc@plt>
		val = 10U * val + *sp++ - '0';
  406ecc:	d2800144 	mov	x4, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406ed0:	f9400002 	ldr	x2, [x0]
	size_t val = 0;
  406ed4:	d2800000 	mov	x0, #0x0                   	// #0
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406ed8:	39400263 	ldrb	w3, [x19]
  406edc:	78637841 	ldrh	w1, [x2, x3, lsl #1]
  406ee0:	375800a1 	tbnz	w1, #11, 406ef4 <extract_decimal+0x40>
	*str = sp;
  406ee4:	f9000293 	str	x19, [x20]
}
  406ee8:	a94153f3 	ldp	x19, x20, [sp, #16]
  406eec:	a8c27bfd 	ldp	x29, x30, [sp], #32
  406ef0:	d65f03c0 	ret
		val = 10U * val + *sp++ - '0';
  406ef4:	9b040c00 	madd	x0, x0, x4, x3
  406ef8:	91000673 	add	x19, x19, #0x1
  406efc:	d100c000 	sub	x0, x0, #0x30
  406f00:	17fffff6 	b	406ed8 <extract_decimal+0x24>

0000000000406f04 <encode_uint>:
{
  406f04:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  406f08:	910003fd 	mov	x29, sp
  406f0c:	a90153f3 	stp	x19, x20, [sp, #16]
  406f10:	aa0103f3 	mov	x19, x1
  406f14:	aa0303f4 	mov	x20, x3
  406f18:	a9025bf5 	stp	x21, x22, [sp, #32]
  406f1c:	aa0203f6 	mov	x22, x2
  406f20:	aa0003f5 	mov	x21, x0
	bool upcase = isupper((int)conv->specifier) != 0;
  406f24:	97ffe923 	bl	4013b0 <__ctype_b_loc@plt>
  406f28:	39400e62 	ldrb	w2, [x19, #3]
  406f2c:	f9400000 	ldr	x0, [x0]
  406f30:	39400e61 	ldrb	w1, [x19, #3]
  406f34:	78627802 	ldrh	w2, [x0, x2, lsl #1]
  406f38:	12180042 	and	w2, w2, #0x100
	switch (specifier) {
  406f3c:	7101bc3f 	cmp	w1, #0x6f
  406f40:	54000400 	b.eq	406fc0 <encode_uint+0xbc>  // b.none
  406f44:	54000388 	b.hi	406fb4 <encode_uint+0xb0>  // b.pmore
		return 16;
  406f48:	7101603f 	cmp	w1, #0x58
  406f4c:	d2800145 	mov	x5, #0xa                   	// #10
  406f50:	d2800200 	mov	x0, #0x10                  	// #16
  406f54:	9a8010a5 	csel	x5, x5, x0, ne  // ne = any
	char *bp = bps + (bpe - bps);
  406f58:	aa1403e0 	mov	x0, x20
		unsigned int lsv = (unsigned int)(value % radix);
  406f5c:	9ac50aa3 	udiv	x3, x21, x5
  406f60:	9b05d461 	msub	x1, x3, x5, x21
		*--bp = (lsv <= 9) ? ('0' + lsv)
  406f64:	12001c24 	and	w4, w1, #0xff
  406f68:	f100243f 	cmp	x1, #0x9
  406f6c:	54000328 	b.hi	406fd0 <encode_uint+0xcc>  // b.pmore
  406f70:	1100c084 	add	w4, w4, #0x30
  406f74:	12001c84 	and	w4, w4, #0xff
  406f78:	381ffc04 	strb	w4, [x0, #-1]!
	} while ((value != 0) && (bps < bp));
  406f7c:	eb0502bf 	cmp	x21, x5
  406f80:	fa562000 	ccmp	x0, x22, #0x0, cs  // cs = hs, nlast
  406f84:	54000228 	b.hi	406fc8 <encode_uint+0xc4>  // b.pmore
	if (conv->flag_hash) {
  406f88:	79400261 	ldrh	w1, [x19]
  406f8c:	362800c1 	tbz	w1, #5, 406fa4 <encode_uint+0xa0>
		if (radix == 8) {
  406f90:	f10020bf 	cmp	x5, #0x8
  406f94:	540002c1 	b.ne	406fec <encode_uint+0xe8>  // b.any
			conv->altform_0 = true;
  406f98:	39400a61 	ldrb	w1, [x19, #2]
  406f9c:	321d0021 	orr	w1, w1, #0x8
			conv->altform_0c = true;
  406fa0:	39000a61 	strb	w1, [x19, #2]
}
  406fa4:	a94153f3 	ldp	x19, x20, [sp, #16]
  406fa8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406fac:	a8c37bfd 	ldp	x29, x30, [sp], #48
  406fb0:	d65f03c0 	ret
	switch (specifier) {
  406fb4:	121c7821 	and	w1, w1, #0xfffffff7
		return 16;
  406fb8:	7101c03f 	cmp	w1, #0x70
  406fbc:	17ffffe4 	b	406f4c <encode_uint+0x48>
	switch (specifier) {
  406fc0:	d2800105 	mov	x5, #0x8                   	// #8
  406fc4:	17ffffe5 	b	406f58 <encode_uint+0x54>
		value /= radix;
  406fc8:	aa0303f5 	mov	x21, x3
  406fcc:	17ffffe4 	b	406f5c <encode_uint+0x58>
		*--bp = (lsv <= 9) ? ('0' + lsv)
  406fd0:	1100dc81 	add	w1, w4, #0x37
  406fd4:	11015c84 	add	w4, w4, #0x57
  406fd8:	12001c21 	and	w1, w1, #0xff
  406fdc:	12001c84 	and	w4, w4, #0xff
  406fe0:	7100005f 	cmp	w2, #0x0
  406fe4:	1a810084 	csel	w4, w4, w1, eq  // eq = none
  406fe8:	17ffffe4 	b	406f78 <encode_uint+0x74>
		} else if (radix == 16) {
  406fec:	f10040bf 	cmp	x5, #0x10
  406ff0:	54fffda1 	b.ne	406fa4 <encode_uint+0xa0>  // b.any
			conv->altform_0c = true;
  406ff4:	39400a61 	ldrb	w1, [x19, #2]
  406ff8:	321c0021 	orr	w1, w1, #0x10
  406ffc:	17ffffe9 	b	406fa0 <encode_uint+0x9c>

0000000000407000 <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
  407000:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  407004:	910003fd 	mov	x29, sp
  407008:	a9046bf9 	stp	x25, x26, [sp, #64]
  40700c:	aa0003f9 	mov	x25, x0
  407010:	90000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  407014:	a90153f3 	stp	x19, x20, [sp, #16]
  407018:	aa0103fa 	mov	x26, x1
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
  40701c:	d2800013 	mov	x19, #0x0                   	// #0
{
  407020:	a9025bf5 	stp	x21, x22, [sp, #32]
  407024:	aa0203f5 	mov	x21, x2
  407028:	a90363f7 	stp	x23, x24, [sp, #48]
  40702c:	a90573fb 	stp	x27, x28, [sp, #80]
  407030:	f9476800 	ldr	x0, [x0, #3792]
  407034:	a940607c 	ldp	x28, x24, [x3]
  407038:	f9400001 	ldr	x1, [x0]
  40703c:	f90067e1 	str	x1, [sp, #200]
  407040:	d2800001 	mov	x1, #0x0                   	// #0
  407044:	b940187b 	ldr	w27, [x3, #24]
  407048:	f9400860 	ldr	x0, [x3, #16]
  40704c:	f9003be0 	str	x0, [sp, #112]
  407050:	b9401c60 	ldr	w0, [x3, #28]
  407054:	b90067e0 	str	w0, [sp, #100]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
  407058:	91031be0 	add	x0, sp, #0xc6
  40705c:	f90037e0 	str	x0, [sp, #104]
  407060:	394002a0 	ldrb	w0, [x21]
  407064:	35000140 	cbnz	w0, 40708c <z_cbvprintf_impl+0x8c>
			OUTC(' ');
			--width;
		}
	}

	return count;
  407068:	2a1303e0 	mov	w0, w19
#undef OUTS
#undef OUTC
}
  40706c:	90000121 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  407070:	f9476821 	ldr	x1, [x1, #3792]
  407074:	f94067e3 	ldr	x3, [sp, #200]
  407078:	f9400022 	ldr	x2, [x1]
  40707c:	eb020063 	subs	x3, x3, x2
  407080:	d2800002 	mov	x2, #0x0                   	// #0
  407084:	54005780 	b.eq	407b74 <z_cbvprintf_impl+0xb74>  // b.none
  407088:	97ffe8a6 	bl	401320 <__stack_chk_fail@plt>
			OUTC(*fp++);
  40708c:	910006b4 	add	x20, x21, #0x1
		if (*fp != '%') {
  407090:	7100941f 	cmp	w0, #0x25
  407094:	540000c0 	b.eq	4070ac <z_cbvprintf_impl+0xac>  // b.none
			OUTC('%');
  407098:	aa1a03e1 	mov	x1, x26
  40709c:	d63f0320 	blr	x25
  4070a0:	37fffe60 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  4070a4:	91000673 	add	x19, x19, #0x1
			break;
  4070a8:	14000140 	b	4075a8 <z_cbvprintf_impl+0x5a8>
		} state = {
  4070ac:	a9097fff 	stp	xzr, xzr, [sp, #144]
  4070b0:	a90a7fff 	stp	xzr, xzr, [sp, #160]
	if (*sp == '%') {
  4070b4:	394006a0 	ldrb	w0, [x21, #1]
  4070b8:	7100941f 	cmp	w0, #0x25
  4070bc:	54000661 	b.ne	407188 <z_cbvprintf_impl+0x188>  // b.any
		conv->specifier = *sp++;
  4070c0:	91000ab4 	add	x20, x21, #0x2
  4070c4:	39028fe0 	strb	w0, [sp, #163]
		if (conv->width_star) {
  4070c8:	794143e0 	ldrh	w0, [sp, #160]
  4070cc:	364021c0 	tbz	w0, #8, 407504 <z_cbvprintf_impl+0x504>
			width = va_arg(ap, int);
  4070d0:	37f8205b 	tbnz	w27, #31, 4074d8 <z_cbvprintf_impl+0x4d8>
  4070d4:	91002f81 	add	x1, x28, #0xb
  4070d8:	aa1c03e0 	mov	x0, x28
  4070dc:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  4070e0:	b9400016 	ldr	w22, [x0]
			if (width < 0) {
  4070e4:	36f800b6 	tbz	w22, #31, 4070f8 <z_cbvprintf_impl+0xf8>
				conv->flag_dash = true;
  4070e8:	794143e0 	ldrh	w0, [sp, #160]
				width = -width;
  4070ec:	4b1603f6 	neg	w22, w22
				conv->flag_dash = true;
  4070f0:	321e0000 	orr	w0, w0, #0x4
  4070f4:	790143e0 	strh	w0, [sp, #160]
		if (conv->prec_star) {
  4070f8:	794143e0 	ldrh	w0, [sp, #160]
  4070fc:	36502220 	tbz	w0, #10, 407540 <z_cbvprintf_impl+0x540>
			int arg = va_arg(ap, int);
  407100:	37f820bb 	tbnz	w27, #31, 407514 <z_cbvprintf_impl+0x514>
  407104:	91002f81 	add	x1, x28, #0xb
  407108:	aa1c03e0 	mov	x0, x28
  40710c:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  407110:	b9400017 	ldr	w23, [x0]
			if (arg < 0) {
  407114:	36f800b7 	tbz	w23, #31, 407128 <z_cbvprintf_impl+0x128>
				conv->prec_present = false;
  407118:	794143e0 	ldrh	w0, [sp, #160]
		int precision = -1;
  40711c:	12800017 	mov	w23, #0xffffffff            	// #-1
				conv->prec_present = false;
  407120:	12167800 	and	w0, w0, #0xfffffdff
  407124:	790143e0 	strh	w0, [sp, #160]
		conv->pad0_value = 0;
  407128:	f80a43ff 	stur	xzr, [sp, #164]
			= (enum specifier_cat_enum)conv->specifier_cat;
  40712c:	f94053e1 	ldr	x1, [sp, #160]
		enum specifier_cat_enum specifier_cat
  407130:	53104820 	ubfx	w0, w1, #16, #3
			= (enum length_mod_enum)conv->length_mod;
  407134:	530b3821 	ubfx	w1, w1, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
  407138:	7100041f 	cmp	w0, #0x1
  40713c:	54002721 	b.ne	407620 <z_cbvprintf_impl+0x620>  // b.any
			switch (length_mod) {
  407140:	51000c22 	sub	w2, w1, #0x3
  407144:	7100105f 	cmp	w2, #0x4
  407148:	54002048 	b.hi	407550 <z_cbvprintf_impl+0x550>  // b.pmore
  40714c:	90000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  407150:	91194000 	add	x0, x0, #0x650
  407154:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
  407158:	10000062 	adr	x2, 407164 <z_cbvprintf_impl+0x164>
  40715c:	8b20a840 	add	x0, x2, w0, sxth #2
  407160:	d61f0000 	br	x0
		switch (*sp) {
  407164:	7100b43f 	cmp	w1, #0x2d
  407168:	540000a0 	b.eq	40717c <z_cbvprintf_impl+0x17c>  // b.none
  40716c:	7100c03f 	cmp	w1, #0x30
  407170:	540001e1 	b.ne	4071ac <z_cbvprintf_impl+0x1ac>  // b.any
			conv->flag_zero = true;
  407174:	321a0000 	orr	w0, w0, #0x40
  407178:	14000002 	b	407180 <z_cbvprintf_impl+0x180>
			conv->flag_dash = true;
  40717c:	321e0000 	orr	w0, w0, #0x4
			++sp;
  407180:	91000694 	add	x20, x20, #0x1
			conv->flag_zero = true;
  407184:	790143e0 	strh	w0, [sp, #160]
		switch (*sp) {
  407188:	39400281 	ldrb	w1, [x20]
  40718c:	794143e0 	ldrh	w0, [sp, #160]
  407190:	7100ac3f 	cmp	w1, #0x2b
  407194:	54000b00 	b.eq	4072f4 <z_cbvprintf_impl+0x2f4>  // b.none
  407198:	54fffe68 	b.hi	407164 <z_cbvprintf_impl+0x164>  // b.pmore
  40719c:	7100803f 	cmp	w1, #0x20
  4071a0:	54000ae0 	b.eq	4072fc <z_cbvprintf_impl+0x2fc>  // b.none
  4071a4:	71008c3f 	cmp	w1, #0x23
  4071a8:	54000ae0 	b.eq	407304 <z_cbvprintf_impl+0x304>  // b.none
	if (conv->flag_zero && conv->flag_dash) {
  4071ac:	b940a3e1 	ldr	w1, [sp, #160]
  4071b0:	52800882 	mov	w2, #0x44                  	// #68
  4071b4:	0a020021 	and	w1, w1, w2
  4071b8:	6b02003f 	cmp	w1, w2
  4071bc:	54000061 	b.ne	4071c8 <z_cbvprintf_impl+0x1c8>  // b.any
		conv->flag_zero = false;
  4071c0:	12197800 	and	w0, w0, #0xffffffbf
  4071c4:	790143e0 	strh	w0, [sp, #160]
	conv->width_present = true;
  4071c8:	794143e0 	ldrh	w0, [sp, #160]
  4071cc:	f90047f4 	str	x20, [sp, #136]
  4071d0:	32190001 	orr	w1, w0, #0x80
  4071d4:	790143e1 	strh	w1, [sp, #160]
	if (*sp == '*') {
  4071d8:	39400281 	ldrb	w1, [x20]
  4071dc:	7100a83f 	cmp	w1, #0x2a
  4071e0:	54000961 	b.ne	40730c <z_cbvprintf_impl+0x30c>  // b.any
		return ++sp;
  4071e4:	91000694 	add	x20, x20, #0x1
		conv->width_star = true;
  4071e8:	32190400 	orr	w0, w0, #0x180
  4071ec:	790143e0 	strh	w0, [sp, #160]
	sp = extract_prec(conv, sp);
  4071f0:	f90047f4 	str	x20, [sp, #136]
	conv->prec_present = (*sp == '.');
  4071f4:	39400280 	ldrb	w0, [x20]
  4071f8:	7100b81f 	cmp	w0, #0x2e
  4071fc:	794143e0 	ldrh	w0, [sp, #160]
  407200:	1a9f17e1 	cset	w1, eq  // eq = none
  407204:	33170020 	bfi	w0, w1, #9, #1
  407208:	790143e0 	strh	w0, [sp, #160]
	if (!conv->prec_present) {
  40720c:	54000121 	b.ne	407230 <z_cbvprintf_impl+0x230>  // b.any
	++sp;
  407210:	91000681 	add	x1, x20, #0x1
  407214:	f90047e1 	str	x1, [sp, #136]
	if (*sp == '*') {
  407218:	39400681 	ldrb	w1, [x20, #1]
  40721c:	7100a83f 	cmp	w1, #0x2a
  407220:	54000961 	b.ne	40734c <z_cbvprintf_impl+0x34c>  // b.any
		return ++sp;
  407224:	91000a94 	add	x20, x20, #0x2
		conv->prec_star = true;
  407228:	32160000 	orr	w0, w0, #0x400
  40722c:	790143e0 	strh	w0, [sp, #160]
	switch (*sp) {
  407230:	aa1403e1 	mov	x1, x20
  407234:	38401420 	ldrb	w0, [x1], #1
  407238:	7101b01f 	cmp	w0, #0x6c
  40723c:	54000d00 	b.eq	4073dc <z_cbvprintf_impl+0x3dc>  // b.none
  407240:	54000a68 	b.hi	40738c <z_cbvprintf_impl+0x38c>  // b.pmore
  407244:	7101a01f 	cmp	w0, #0x68
  407248:	54000b00 	b.eq	4073a8 <z_cbvprintf_impl+0x3a8>  // b.none
  40724c:	7101a81f 	cmp	w0, #0x6a
  407250:	54000d60 	b.eq	4073fc <z_cbvprintf_impl+0x3fc>  // b.none
  407254:	7101301f 	cmp	w0, #0x4c
  407258:	54000de0 	b.eq	407414 <z_cbvprintf_impl+0x414>  // b.none
  40725c:	aa1403e1 	mov	x1, x20
	conv->specifier = *sp++;
  407260:	aa0103f4 	mov	x20, x1
  407264:	38401682 	ldrb	w2, [x20], #1
  407268:	39028fe2 	strb	w2, [sp, #163]
	switch (conv->specifier) {
  40726c:	7101a45f 	cmp	w2, #0x69
  407270:	54001028 	b.hi	407474 <z_cbvprintf_impl+0x474>  // b.pmore
  407274:	7101005f 	cmp	w2, #0x40
  407278:	54001069 	b.ls	407484 <z_cbvprintf_impl+0x484>  // b.plast
  40727c:	51010441 	sub	w1, w2, #0x41
  407280:	d2800020 	mov	x0, #0x1                   	// #1
  407284:	d2800e23 	mov	x3, #0x71                  	// #113
  407288:	9ac12001 	lsl	x1, x0, x1
  40728c:	f2c00e23 	movk	x3, #0x71, lsl #32
  407290:	ea03003f 	tst	x1, x3
  407294:	54001021 	b.ne	407498 <z_cbvprintf_impl+0x498>  // b.any
  407298:	d2c02103 	mov	x3, #0x10800000000         	// #1133871366144
  40729c:	ea03003f 	tst	x1, x3
  4072a0:	540000c1 	b.ne	4072b8 <z_cbvprintf_impl+0x2b8>  // b.any
  4072a4:	d2a01000 	mov	x0, #0x800000              	// #8388608
  4072a8:	f2c00080 	movk	x0, #0x4, lsl #32
  4072ac:	ea00003f 	tst	x1, x0
  4072b0:	54000ea0 	b.eq	407484 <z_cbvprintf_impl+0x484>  // b.none
  4072b4:	52800040 	mov	w0, #0x2                   	// #2
		conv->specifier_cat = SPECIFIER_SINT;
  4072b8:	39428be1 	ldrb	w1, [sp, #162]
  4072bc:	33000801 	bfxil	w1, w0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
  4072c0:	794143e0 	ldrh	w0, [sp, #160]
		conv->specifier_cat = SPECIFIER_SINT;
  4072c4:	39028be1 	strb	w1, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  4072c8:	12150c01 	and	w1, w0, #0x7800
  4072cc:	7140103f 	cmp	w1, #0x4, lsl #12
  4072d0:	54000061 	b.ne	4072dc <z_cbvprintf_impl+0x2dc>  // b.any
			conv->invalid = true;
  4072d4:	32000000 	orr	w0, w0, #0x1
  4072d8:	790143e0 	strh	w0, [sp, #160]
		if (conv->specifier == 'c') {
  4072dc:	71018c5f 	cmp	w2, #0x63
  4072e0:	54000d81 	b.ne	407490 <z_cbvprintf_impl+0x490>  // b.any
		if (conv->length_mod != LENGTH_NONE) {
  4072e4:	794143e0 	ldrh	w0, [sp, #160]
  4072e8:	72150c1f 	tst	w0, #0x7800
  4072ec:	1a9f07e0 	cset	w0, ne  // ne = any
  4072f0:	1400006e 	b	4074a8 <z_cbvprintf_impl+0x4a8>
			conv->flag_plus = true;
  4072f4:	321d0000 	orr	w0, w0, #0x8
  4072f8:	17ffffa2 	b	407180 <z_cbvprintf_impl+0x180>
			conv->flag_space = true;
  4072fc:	321c0000 	orr	w0, w0, #0x10
  407300:	17ffffa0 	b	407180 <z_cbvprintf_impl+0x180>
			conv->flag_hash = true;
  407304:	321b0000 	orr	w0, w0, #0x20
  407308:	17ffff9e 	b	407180 <z_cbvprintf_impl+0x180>
	size_t width = extract_decimal(&sp);
  40730c:	910223e0 	add	x0, sp, #0x88
  407310:	97fffee9 	bl	406eb4 <extract_decimal>
	if (sp != wp) {
  407314:	f94047e1 	ldr	x1, [sp, #136]
  407318:	eb14003f 	cmp	x1, x20
  40731c:	54fff6a0 	b.eq	4071f0 <z_cbvprintf_impl+0x1f0>  // b.none
		conv->width_value = width;
  407320:	b900a7e0 	str	w0, [sp, #164]
				      || (width != (size_t)conv->width_value));
  407324:	37f80100 	tbnz	w0, #31, 407344 <z_cbvprintf_impl+0x344>
  407328:	eb20c01f 	cmp	x0, w0, sxtw
  40732c:	1a9f07e2 	cset	w2, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
  407330:	794143e0 	ldrh	w0, [sp, #160]
  407334:	aa0103f4 	mov	x20, x1
  407338:	331f0040 	bfi	w0, w2, #1, #1
  40733c:	790143e0 	strh	w0, [sp, #160]
  407340:	17ffffac 	b	4071f0 <z_cbvprintf_impl+0x1f0>
				      || (width != (size_t)conv->width_value));
  407344:	52800022 	mov	w2, #0x1                   	// #1
  407348:	17fffffa 	b	407330 <z_cbvprintf_impl+0x330>
	size_t prec = extract_decimal(&sp);
  40734c:	910223e0 	add	x0, sp, #0x88
  407350:	97fffed9 	bl	406eb4 <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
  407354:	f94053e1 	ldr	x1, [sp, #160]
	conv->prec_value = prec;
  407358:	b900abe0 	str	w0, [sp, #168]
	conv->unsupported |= ((conv->prec_value < 0)
  40735c:	53010421 	ubfx	w1, w1, #1, #1
			      || (prec != (size_t)conv->prec_value));
  407360:	37f80120 	tbnz	w0, #31, 407384 <z_cbvprintf_impl+0x384>
  407364:	eb20c01f 	cmp	x0, w0, sxtw
  407368:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
  40736c:	2a000020 	orr	w0, w1, w0
  407370:	794143e1 	ldrh	w1, [sp, #160]
	return sp;
  407374:	f94047f4 	ldr	x20, [sp, #136]
	conv->unsupported |= ((conv->prec_value < 0)
  407378:	331f0001 	bfi	w1, w0, #1, #1
  40737c:	790143e1 	strh	w1, [sp, #160]
	return sp;
  407380:	17ffffac 	b	407230 <z_cbvprintf_impl+0x230>
			      || (prec != (size_t)conv->prec_value));
  407384:	52800020 	mov	w0, #0x1                   	// #1
  407388:	17fffff9 	b	40736c <z_cbvprintf_impl+0x36c>
	switch (*sp) {
  40738c:	7101d01f 	cmp	w0, #0x74
  407390:	540003c0 	b.eq	407408 <z_cbvprintf_impl+0x408>  // b.none
  407394:	7101e81f 	cmp	w0, #0x7a
  407398:	54fff621 	b.ne	40725c <z_cbvprintf_impl+0x25c>  // b.any
		conv->length_mod = LENGTH_Z;
  40739c:	794143e0 	ldrh	w0, [sp, #160]
  4073a0:	528000c2 	mov	w2, #0x6                   	// #6
  4073a4:	1400000b 	b	4073d0 <z_cbvprintf_impl+0x3d0>
		if (*++sp == 'h') {
  4073a8:	39400680 	ldrb	w0, [x20, #1]
  4073ac:	7101a01f 	cmp	w0, #0x68
  4073b0:	794143e0 	ldrh	w0, [sp, #160]
  4073b4:	540000c1 	b.ne	4073cc <z_cbvprintf_impl+0x3cc>  // b.any
			conv->length_mod = LENGTH_HH;
  4073b8:	52800021 	mov	w1, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
  4073bc:	33150c20 	bfi	w0, w1, #11, #4
			++sp;
  4073c0:	91000a81 	add	x1, x20, #0x2
			conv->length_mod = LENGTH_LL;
  4073c4:	790143e0 	strh	w0, [sp, #160]
			++sp;
  4073c8:	17ffffa6 	b	407260 <z_cbvprintf_impl+0x260>
			conv->length_mod = LENGTH_H;
  4073cc:	52800042 	mov	w2, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
  4073d0:	33150c40 	bfi	w0, w2, #11, #4
		conv->unsupported = true;
  4073d4:	790143e0 	strh	w0, [sp, #160]
		break;
  4073d8:	17ffffa2 	b	407260 <z_cbvprintf_impl+0x260>
		if (*++sp == 'l') {
  4073dc:	39400680 	ldrb	w0, [x20, #1]
  4073e0:	7101b01f 	cmp	w0, #0x6c
  4073e4:	794143e0 	ldrh	w0, [sp, #160]
  4073e8:	54000061 	b.ne	4073f4 <z_cbvprintf_impl+0x3f4>  // b.any
			conv->length_mod = LENGTH_LL;
  4073ec:	52800081 	mov	w1, #0x4                   	// #4
  4073f0:	17fffff3 	b	4073bc <z_cbvprintf_impl+0x3bc>
			conv->length_mod = LENGTH_L;
  4073f4:	52800062 	mov	w2, #0x3                   	// #3
  4073f8:	17fffff6 	b	4073d0 <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_J;
  4073fc:	794143e0 	ldrh	w0, [sp, #160]
  407400:	528000a2 	mov	w2, #0x5                   	// #5
  407404:	17fffff3 	b	4073d0 <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_T;
  407408:	794143e0 	ldrh	w0, [sp, #160]
  40740c:	528000e2 	mov	w2, #0x7                   	// #7
  407410:	17fffff0 	b	4073d0 <z_cbvprintf_impl+0x3d0>
		conv->unsupported = true;
  407414:	794143e0 	ldrh	w0, [sp, #160]
  407418:	128f0042 	mov	w2, #0xffff87fd            	// #-30723
  40741c:	0a020000 	and	w0, w0, w2
  407420:	52880042 	mov	w2, #0x4002                	// #16386
  407424:	2a020000 	orr	w0, w0, w2
  407428:	17ffffeb 	b	4073d4 <z_cbvprintf_impl+0x3d4>
  40742c:	d2800020 	mov	x0, #0x1                   	// #1
  407430:	9ac12000 	lsl	x0, x0, x1
	switch (conv->specifier) {
  407434:	d2809041 	mov	x1, #0x482                 	// #1154
  407438:	ea01001f 	tst	x0, x1
  40743c:	54fff3c1 	b.ne	4072b4 <z_cbvprintf_impl+0x2b4>  // b.any
  407440:	d2800481 	mov	x1, #0x24                  	// #36
  407444:	ea01001f 	tst	x0, x1
  407448:	540003e1 	b.ne	4074c4 <z_cbvprintf_impl+0x4c4>  // b.any
  40744c:	360001c0 	tbz	w0, #0, 407484 <z_cbvprintf_impl+0x484>
		conv->specifier_cat = SPECIFIER_PTR;
  407450:	39428be0 	ldrb	w0, [sp, #162]
  407454:	52800061 	mov	w1, #0x3                   	// #3
  407458:	33000820 	bfxil	w0, w1, #0, #3
  40745c:	39028be0 	strb	w0, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  407460:	794143e0 	ldrh	w0, [sp, #160]
  407464:	12150c00 	and	w0, w0, #0x7800
  407468:	7140101f 	cmp	w0, #0x4, lsl #12
  40746c:	1a9f17e0 	cset	w0, eq  // eq = none
  407470:	1400000e 	b	4074a8 <z_cbvprintf_impl+0x4a8>
	switch (conv->specifier) {
  407474:	5101b841 	sub	w1, w2, #0x6e
  407478:	12001c21 	and	w1, w1, #0xff
  40747c:	7100283f 	cmp	w1, #0xa
  407480:	54fffd69 	b.ls	40742c <z_cbvprintf_impl+0x42c>  // b.plast
		conv->invalid = true;
  407484:	794143e0 	ldrh	w0, [sp, #160]
  407488:	32000000 	orr	w0, w0, #0x1
  40748c:	790143e0 	strh	w0, [sp, #160]
	bool unsupported = false;
  407490:	52800000 	mov	w0, #0x0                   	// #0
  407494:	14000005 	b	4074a8 <z_cbvprintf_impl+0x4a8>
		conv->specifier_cat = SPECIFIER_FP;
  407498:	39428be1 	ldrb	w1, [sp, #162]
  40749c:	52800082 	mov	w2, #0x4                   	// #4
  4074a0:	33000841 	bfxil	w1, w2, #0, #3
  4074a4:	39028be1 	strb	w1, [sp, #162]
	conv->unsupported |= unsupported;
  4074a8:	f94053e1 	ldr	x1, [sp, #160]
  4074ac:	d3410421 	ubfx	x1, x1, #1, #1
  4074b0:	2a010000 	orr	w0, w0, w1
  4074b4:	794143e1 	ldrh	w1, [sp, #160]
  4074b8:	331f0001 	bfi	w1, w0, #1, #1
  4074bc:	790143e1 	strh	w1, [sp, #160]
	return sp;
  4074c0:	17ffff02 	b	4070c8 <z_cbvprintf_impl+0xc8>
		conv->specifier_cat = SPECIFIER_PTR;
  4074c4:	39428be0 	ldrb	w0, [sp, #162]
  4074c8:	52800061 	mov	w1, #0x3                   	// #3
  4074cc:	33000820 	bfxil	w0, w1, #0, #3
  4074d0:	39028be0 	strb	w0, [sp, #162]
  4074d4:	17ffff84 	b	4072e4 <z_cbvprintf_impl+0x2e4>
			width = va_arg(ap, int);
  4074d8:	11002361 	add	w1, w27, #0x8
  4074dc:	7100003f 	cmp	w1, #0x0
  4074e0:	540000cd 	b.le	4074f8 <z_cbvprintf_impl+0x4f8>
  4074e4:	91002f82 	add	x2, x28, #0xb
  4074e8:	aa1c03e0 	mov	x0, x28
  4074ec:	2a0103fb 	mov	w27, w1
  4074f0:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  4074f4:	17fffefb 	b	4070e0 <z_cbvprintf_impl+0xe0>
  4074f8:	8b3bc300 	add	x0, x24, w27, sxtw
  4074fc:	2a0103fb 	mov	w27, w1
  407500:	17fffef8 	b	4070e0 <z_cbvprintf_impl+0xe0>
			width = conv->width_value;
  407504:	b940a7f6 	ldr	w22, [sp, #164]
  407508:	f279001f 	tst	x0, #0x80
  40750c:	5a9f12d6 	csinv	w22, w22, wzr, ne  // ne = any
  407510:	17fffefa 	b	4070f8 <z_cbvprintf_impl+0xf8>
			int arg = va_arg(ap, int);
  407514:	11002361 	add	w1, w27, #0x8
  407518:	7100003f 	cmp	w1, #0x0
  40751c:	540000cd 	b.le	407534 <z_cbvprintf_impl+0x534>
  407520:	91002f82 	add	x2, x28, #0xb
  407524:	aa1c03e0 	mov	x0, x28
  407528:	2a0103fb 	mov	w27, w1
  40752c:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  407530:	17fffef8 	b	407110 <z_cbvprintf_impl+0x110>
  407534:	8b3bc300 	add	x0, x24, w27, sxtw
  407538:	2a0103fb 	mov	w27, w1
  40753c:	17fffef5 	b	407110 <z_cbvprintf_impl+0x110>
			precision = conv->prec_value;
  407540:	b940abf7 	ldr	w23, [sp, #168]
  407544:	f277001f 	tst	x0, #0x200
  407548:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
  40754c:	17fffef7 	b	407128 <z_cbvprintf_impl+0x128>
				value->sint = va_arg(ap, int);
  407550:	37f8031b 	tbnz	w27, #31, 4075b0 <z_cbvprintf_impl+0x5b0>
  407554:	91002f82 	add	x2, x28, #0xb
  407558:	2a1b03e3 	mov	w3, w27
  40755c:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407560:	b9800380 	ldrsw	x0, [x28]
  407564:	f9004be0 	str	x0, [sp, #144]
				break;
  407568:	2a0303fb 	mov	w27, w3
  40756c:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  407570:	7100043f 	cmp	w1, #0x1
  407574:	540004e1 	b.ne	407610 <z_cbvprintf_impl+0x610>  // b.any
				value->sint = (signed char)value->sint;
  407578:	93401c00 	sxtb	x0, w0
				value->uint = (unsigned short)value->uint;
  40757c:	f9004be0 	str	x0, [sp, #144]
		if (conv->invalid || conv->unsupported) {
  407580:	b940a3e0 	ldr	w0, [sp, #160]
  407584:	f240041f 	tst	x0, #0x3
  407588:	540015a0 	b.eq	40783c <z_cbvprintf_impl+0x83c>  // b.none
			OUTS(sp, fp);
  40758c:	aa1403e3 	mov	x3, x20
  407590:	aa1503e2 	mov	x2, x21
  407594:	aa1a03e1 	mov	x1, x26
  407598:	aa1903e0 	mov	x0, x25
  40759c:	97fffe2a 	bl	406e44 <outs>
  4075a0:	37ffd660 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  4075a4:	8b20c273 	add	x19, x19, w0, sxtw
			continue;
  4075a8:	aa1403f5 	mov	x21, x20
  4075ac:	17fffead 	b	407060 <z_cbvprintf_impl+0x60>
				value->sint = va_arg(ap, int);
  4075b0:	11002363 	add	w3, w27, #0x8
  4075b4:	7100007f 	cmp	w3, #0x0
  4075b8:	5400008d 	b.le	4075c8 <z_cbvprintf_impl+0x5c8>
  4075bc:	91002f82 	add	x2, x28, #0xb
  4075c0:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4075c4:	17ffffe7 	b	407560 <z_cbvprintf_impl+0x560>
  4075c8:	aa1c03e2 	mov	x2, x28
  4075cc:	8b3bc31c 	add	x28, x24, w27, sxtw
  4075d0:	17ffffe4 	b	407560 <z_cbvprintf_impl+0x560>
					(sint_value_type)va_arg(ap, ptrdiff_t);
  4075d4:	37f800db 	tbnz	w27, #31, 4075ec <z_cbvprintf_impl+0x5ec>
  4075d8:	91003f82 	add	x2, x28, #0xf
  4075dc:	2a1b03e3 	mov	w3, w27
  4075e0:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4075e4:	f9400380 	ldr	x0, [x28]
  4075e8:	17ffffdf 	b	407564 <z_cbvprintf_impl+0x564>
  4075ec:	11002363 	add	w3, w27, #0x8
  4075f0:	7100007f 	cmp	w3, #0x0
  4075f4:	5400008d 	b.le	407604 <z_cbvprintf_impl+0x604>
  4075f8:	91003f82 	add	x2, x28, #0xf
  4075fc:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407600:	17fffff9 	b	4075e4 <z_cbvprintf_impl+0x5e4>
  407604:	aa1c03e2 	mov	x2, x28
  407608:	8b3bc31c 	add	x28, x24, w27, sxtw
  40760c:	17fffff6 	b	4075e4 <z_cbvprintf_impl+0x5e4>
			} else if (length_mod == LENGTH_H) {
  407610:	7100083f 	cmp	w1, #0x2
  407614:	54fffb61 	b.ne	407580 <z_cbvprintf_impl+0x580>  // b.any
				value->sint = (short)value->sint;
  407618:	93403c00 	sxth	x0, w0
  40761c:	17ffffd8 	b	40757c <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_UINT) {
  407620:	7100081f 	cmp	w0, #0x2
  407624:	540008c1 	b.ne	40773c <z_cbvprintf_impl+0x73c>  // b.any
			switch (length_mod) {
  407628:	51000c22 	sub	w2, w1, #0x3
  40762c:	7100105f 	cmp	w2, #0x4
  407630:	540000e8 	b.hi	40764c <z_cbvprintf_impl+0x64c>  // b.pmore
  407634:	90000060 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  407638:	91197000 	add	x0, x0, #0x65c
  40763c:	38624800 	ldrb	w0, [x0, w2, uxtw]
  407640:	10000062 	adr	x2, 40764c <z_cbvprintf_impl+0x64c>
  407644:	8b208840 	add	x0, x2, w0, sxtb #2
  407648:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
  40764c:	37f8019b 	tbnz	w27, #31, 40767c <z_cbvprintf_impl+0x67c>
  407650:	91002f82 	add	x2, x28, #0xb
  407654:	2a1b03e3 	mov	w3, w27
  407658:	927df042 	and	x2, x2, #0xfffffffffffffff8
  40765c:	b9400380 	ldr	w0, [x28]
  407660:	f9004be0 	str	x0, [sp, #144]
				break;
  407664:	2a0303fb 	mov	w27, w3
  407668:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  40766c:	7100043f 	cmp	w1, #0x1
  407670:	540005e1 	b.ne	40772c <z_cbvprintf_impl+0x72c>  // b.any
				value->uint = (unsigned char)value->uint;
  407674:	92401c00 	and	x0, x0, #0xff
  407678:	17ffffc1 	b	40757c <z_cbvprintf_impl+0x57c>
				value->uint = va_arg(ap, unsigned int);
  40767c:	11002363 	add	w3, w27, #0x8
  407680:	7100007f 	cmp	w3, #0x0
  407684:	5400008d 	b.le	407694 <z_cbvprintf_impl+0x694>
  407688:	91002f82 	add	x2, x28, #0xb
  40768c:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407690:	17fffff3 	b	40765c <z_cbvprintf_impl+0x65c>
  407694:	aa1c03e2 	mov	x2, x28
  407698:	8b3bc31c 	add	x28, x24, w27, sxtw
  40769c:	17fffff0 	b	40765c <z_cbvprintf_impl+0x65c>
				if ((!WCHAR_IS_SIGNED)
  4076a0:	39428fe0 	ldrb	w0, [sp, #163]
  4076a4:	71018c1f 	cmp	w0, #0x63
  4076a8:	54000ac1 	b.ne	407800 <z_cbvprintf_impl+0x800>  // b.any
					value->uint = (wchar_t)va_arg(ap,
  4076ac:	37f8011b 	tbnz	w27, #31, 4076cc <z_cbvprintf_impl+0x6cc>
  4076b0:	91002f80 	add	x0, x28, #0xb
  4076b4:	2a1b03e2 	mov	w2, w27
  4076b8:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4076bc:	b9400383 	ldr	w3, [x28]
			value->ptr = va_arg(ap, void *);
  4076c0:	2a0203fb 	mov	w27, w2
  4076c4:	f9004be3 	str	x3, [sp, #144]
  4076c8:	1400003e 	b	4077c0 <z_cbvprintf_impl+0x7c0>
					value->uint = (wchar_t)va_arg(ap,
  4076cc:	11002362 	add	w2, w27, #0x8
  4076d0:	7100005f 	cmp	w2, #0x0
  4076d4:	5400008d 	b.le	4076e4 <z_cbvprintf_impl+0x6e4>
  4076d8:	91002f80 	add	x0, x28, #0xb
  4076dc:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4076e0:	17fffff7 	b	4076bc <z_cbvprintf_impl+0x6bc>
  4076e4:	aa1c03e0 	mov	x0, x28
  4076e8:	8b3bc31c 	add	x28, x24, w27, sxtw
  4076ec:	17fffff4 	b	4076bc <z_cbvprintf_impl+0x6bc>
					(uint_value_type)va_arg(ap, size_t);
  4076f0:	37f800db 	tbnz	w27, #31, 407708 <z_cbvprintf_impl+0x708>
  4076f4:	91003f82 	add	x2, x28, #0xf
  4076f8:	2a1b03e3 	mov	w3, w27
  4076fc:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407700:	f9400380 	ldr	x0, [x28]
  407704:	17ffffd7 	b	407660 <z_cbvprintf_impl+0x660>
  407708:	11002363 	add	w3, w27, #0x8
  40770c:	7100007f 	cmp	w3, #0x0
  407710:	5400008d 	b.le	407720 <z_cbvprintf_impl+0x720>
  407714:	91003f82 	add	x2, x28, #0xf
  407718:	927df042 	and	x2, x2, #0xfffffffffffffff8
  40771c:	17fffff9 	b	407700 <z_cbvprintf_impl+0x700>
  407720:	aa1c03e2 	mov	x2, x28
  407724:	8b3bc31c 	add	x28, x24, w27, sxtw
  407728:	17fffff6 	b	407700 <z_cbvprintf_impl+0x700>
			} else if (length_mod == LENGTH_H) {
  40772c:	7100083f 	cmp	w1, #0x2
  407730:	54fff281 	b.ne	407580 <z_cbvprintf_impl+0x580>  // b.any
				value->uint = (unsigned short)value->uint;
  407734:	92403c00 	and	x0, x0, #0xffff
  407738:	17ffff91 	b	40757c <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_FP) {
  40773c:	7100101f 	cmp	w0, #0x4
  407740:	540005c1 	b.ne	4077f8 <z_cbvprintf_impl+0x7f8>  // b.any
				value->ldbl = va_arg(ap, long double);
  407744:	b94067e0 	ldr	w0, [sp, #100]
			if (length_mod == LENGTH_UPPER_L) {
  407748:	7100203f 	cmp	w1, #0x8
  40774c:	540002c1 	b.ne	4077a4 <z_cbvprintf_impl+0x7a4>  // b.any
				value->ldbl = va_arg(ap, long double);
  407750:	37f80120 	tbnz	w0, #31, 407774 <z_cbvprintf_impl+0x774>
  407754:	91003f80 	add	x0, x28, #0xf
  407758:	b94067e2 	ldr	w2, [sp, #100]
  40775c:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  407760:	9100401c 	add	x28, x0, #0x10
  407764:	3dc00000 	ldr	q0, [x0]
  407768:	b90067e2 	str	w2, [sp, #100]
  40776c:	3d8027e0 	str	q0, [sp, #144]
  407770:	17ffff84 	b	407580 <z_cbvprintf_impl+0x580>
  407774:	b94067e0 	ldr	w0, [sp, #100]
  407778:	11004002 	add	w2, w0, #0x10
  40777c:	7100005f 	cmp	w2, #0x0
  407780:	540000ad 	b.le	407794 <z_cbvprintf_impl+0x794>
  407784:	91003f80 	add	x0, x28, #0xf
  407788:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  40778c:	9100401c 	add	x28, x0, #0x10
  407790:	17fffff5 	b	407764 <z_cbvprintf_impl+0x764>
  407794:	f9403be3 	ldr	x3, [sp, #112]
  407798:	b94067e0 	ldr	w0, [sp, #100]
  40779c:	8b20c060 	add	x0, x3, w0, sxtw
  4077a0:	17fffff1 	b	407764 <z_cbvprintf_impl+0x764>
				value->dbl = va_arg(ap, double);
  4077a4:	37f80120 	tbnz	w0, #31, 4077c8 <z_cbvprintf_impl+0x7c8>
  4077a8:	91003f80 	add	x0, x28, #0xf
  4077ac:	b94067e2 	ldr	w2, [sp, #100]
  4077b0:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4077b4:	fd400380 	ldr	d0, [x28]
  4077b8:	b90067e2 	str	w2, [sp, #100]
  4077bc:	fd004be0 	str	d0, [sp, #144]
			value->ptr = va_arg(ap, void *);
  4077c0:	aa0003fc 	mov	x28, x0
  4077c4:	17ffff6f 	b	407580 <z_cbvprintf_impl+0x580>
				value->dbl = va_arg(ap, double);
  4077c8:	b94067e0 	ldr	w0, [sp, #100]
  4077cc:	11004002 	add	w2, w0, #0x10
  4077d0:	7100005f 	cmp	w2, #0x0
  4077d4:	5400008d 	b.le	4077e4 <z_cbvprintf_impl+0x7e4>
  4077d8:	91003f80 	add	x0, x28, #0xf
  4077dc:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4077e0:	17fffff5 	b	4077b4 <z_cbvprintf_impl+0x7b4>
  4077e4:	f9403be4 	ldr	x4, [sp, #112]
  4077e8:	aa1c03e0 	mov	x0, x28
  4077ec:	b94067e3 	ldr	w3, [sp, #100]
  4077f0:	8b23c09c 	add	x28, x4, w3, sxtw
  4077f4:	17fffff0 	b	4077b4 <z_cbvprintf_impl+0x7b4>
		} else if (specifier_cat == SPECIFIER_PTR) {
  4077f8:	71000c1f 	cmp	w0, #0x3
  4077fc:	54ffec21 	b.ne	407580 <z_cbvprintf_impl+0x580>  // b.any
			value->ptr = va_arg(ap, void *);
  407800:	37f800db 	tbnz	w27, #31, 407818 <z_cbvprintf_impl+0x818>
  407804:	91003f80 	add	x0, x28, #0xf
  407808:	2a1b03e2 	mov	w2, w27
  40780c:	927df000 	and	x0, x0, #0xfffffffffffffff8
  407810:	f9400383 	ldr	x3, [x28]
  407814:	17ffffab 	b	4076c0 <z_cbvprintf_impl+0x6c0>
  407818:	11002362 	add	w2, w27, #0x8
  40781c:	7100005f 	cmp	w2, #0x0
  407820:	5400008d 	b.le	407830 <z_cbvprintf_impl+0x830>
  407824:	91003f80 	add	x0, x28, #0xf
  407828:	927df000 	and	x0, x0, #0xfffffffffffffff8
  40782c:	17fffff9 	b	407810 <z_cbvprintf_impl+0x810>
  407830:	aa1c03e0 	mov	x0, x28
  407834:	8b3bc31c 	add	x28, x24, w27, sxtw
  407838:	17fffff6 	b	407810 <z_cbvprintf_impl+0x810>
		switch (conv->specifier) {
  40783c:	39428fe0 	ldrb	w0, [sp, #163]
  407840:	7101e01f 	cmp	w0, #0x78
  407844:	54ffeb28 	b.hi	4075a8 <z_cbvprintf_impl+0x5a8>  // b.pmore
  407848:	7101881f 	cmp	w0, #0x62
  40784c:	540000e8 	b.hi	407868 <z_cbvprintf_impl+0x868>  // b.pmore
  407850:	7100941f 	cmp	w0, #0x25
  407854:	54ffc220 	b.eq	407098 <z_cbvprintf_impl+0x98>  // b.none
  407858:	7101601f 	cmp	w0, #0x58
  40785c:	54ffea61 	b.ne	4075a8 <z_cbvprintf_impl+0x5a8>  // b.any
  407860:	52800006 	mov	w6, #0x0                   	// #0
  407864:	14000043 	b	407970 <z_cbvprintf_impl+0x970>
  407868:	51018c00 	sub	w0, w0, #0x63
  40786c:	7100541f 	cmp	w0, #0x15
  407870:	54ffe9c8 	b.hi	4075a8 <z_cbvprintf_impl+0x5a8>  // b.pmore
  407874:	90000062 	adrp	x2, 413000 <z_impl_k_uptime_ticks>
  407878:	91199042 	add	x2, x2, #0x664
  40787c:	78605842 	ldrh	w2, [x2, w0, uxtw #1]
  407880:	10000060 	adr	x0, 40788c <z_cbvprintf_impl+0x88c>
  407884:	8b22a802 	add	x2, x0, w2, sxth #2
  407888:	d61f0040 	br	x2
			bps = (const char *)value->ptr;
  40788c:	f9404bf5 	ldr	x21, [sp, #144]
			if (precision >= 0) {
  407890:	37f80497 	tbnz	w23, #31, 407920 <z_cbvprintf_impl+0x920>
				len = strnlen(bps, precision);
  407894:	93407ee1 	sxtw	x1, w23
  407898:	aa1503e0 	mov	x0, x21
  40789c:	97ffe651 	bl	4011e0 <strnlen@plt>
			bpe = bps + len;
  4078a0:	8b0002b7 	add	x23, x21, x0
		char sign = 0;
  4078a4:	52800006 	mov	w6, #0x0                   	// #0
		if (bps == NULL) {
  4078a8:	b4ffe815 	cbz	x21, 4075a8 <z_cbvprintf_impl+0x5a8>
		size_t nj_len = (bpe - bps);
  4078ac:	cb1502e0 	sub	x0, x23, x21
		if (sign != 0) {
  4078b0:	34000046 	cbz	w6, 4078b8 <z_cbvprintf_impl+0x8b8>
			nj_len += 1U;
  4078b4:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
  4078b8:	39428be2 	ldrb	w2, [sp, #162]
  4078bc:	36200ce2 	tbz	w2, #4, 407a58 <z_cbvprintf_impl+0xa58>
			nj_len += 2U;
  4078c0:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
  4078c4:	b980a7e1 	ldrsw	x1, [sp, #164]
  4078c8:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
  4078cc:	36300062 	tbz	w2, #6, 4078d8 <z_cbvprintf_impl+0x8d8>
			nj_len += conv->pad0_pre_exp;
  4078d0:	b980abe1 	ldrsw	x1, [sp, #168]
  4078d4:	8b010000 	add	x0, x0, x1
		if (width > 0) {
  4078d8:	710002df 	cmp	w22, #0x0
  4078dc:	54000dad 	b.le	407a90 <z_cbvprintf_impl+0xa90>
			width -= (int)nj_len;
  4078e0:	4b0002d6 	sub	w22, w22, w0
			if (!conv->flag_dash) {
  4078e4:	f94053e0 	ldr	x0, [sp, #160]
  4078e8:	721e001f 	tst	w0, #0x4
  4078ec:	54000d21 	b.ne	407a90 <z_cbvprintf_impl+0xa90>  // b.any
				if (conv->flag_zero) {
  4078f0:	794143e0 	ldrh	w0, [sp, #160]
  4078f4:	36301280 	tbz	w0, #6, 407b44 <z_cbvprintf_impl+0xb44>
					if (sign != 0) {
  4078f8:	340012a6 	cbz	w6, 407b4c <z_cbvprintf_impl+0xb4c>
						OUTC(sign);
  4078fc:	aa1a03e1 	mov	x1, x26
  407900:	2a0603e0 	mov	w0, w6
  407904:	d63f0320 	blr	x25
  407908:	37ffbb20 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  40790c:	91000673 	add	x19, x19, #0x1
					pad = '0';
  407910:	52800602 	mov	w2, #0x30                  	// #48
						OUTC(sign);
  407914:	52800006 	mov	w6, #0x0                   	// #0
					pad = '0';
  407918:	2a1603e0 	mov	w0, w22
  40791c:	1400005a 	b	407a84 <z_cbvprintf_impl+0xa84>
				len = strlen(bps);
  407920:	aa1503e0 	mov	x0, x21
  407924:	97ffe61f 	bl	4011a0 <strlen@plt>
  407928:	17ffffde 	b	4078a0 <z_cbvprintf_impl+0x8a0>
			bps = buf;
  40792c:	9102c3f5 	add	x21, sp, #0xb0
			bpe = buf + 1;
  407930:	9102c7f7 	add	x23, sp, #0xb1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  407934:	f9404be0 	ldr	x0, [sp, #144]
  407938:	3902c3e0 	strb	w0, [sp, #176]
			break;
  40793c:	52800006 	mov	w6, #0x0                   	// #0
  407940:	17ffffdb 	b	4078ac <z_cbvprintf_impl+0x8ac>
			if (conv->flag_plus) {
  407944:	794143e0 	ldrh	w0, [sp, #160]
			} else if (conv->flag_space) {
  407948:	d3441006 	ubfx	x6, x0, #4, #1
  40794c:	f27d001f 	tst	x0, #0x8
  407950:	52800560 	mov	w0, #0x2b                  	// #43
  407954:	531b68c6 	lsl	w6, w6, #5
  407958:	1a8000c6 	csel	w6, w6, w0, eq  // eq = none
			sint = value->sint;
  40795c:	f9404be0 	ldr	x0, [sp, #144]
			if (sint < 0) {
  407960:	b6f80080 	tbz	x0, #63, 407970 <z_cbvprintf_impl+0x970>
				value->uint = (uint_value_type)-sint;
  407964:	cb0003e0 	neg	x0, x0
				sign = '-';
  407968:	528005a6 	mov	w6, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
  40796c:	f9004be0 	str	x0, [sp, #144]
			bps = encode_uint(value->uint, conv, buf, bpe);
  407970:	f94037e3 	ldr	x3, [sp, #104]
  407974:	9102c3e2 	add	x2, sp, #0xb0
  407978:	f9404be0 	ldr	x0, [sp, #144]
  40797c:	910283e1 	add	x1, sp, #0xa0
  407980:	b9007be6 	str	w6, [sp, #120]
  407984:	97fffd60 	bl	406f04 <encode_uint>
  407988:	aa0003f5 	mov	x21, x0
  40798c:	b9407be6 	ldr	w6, [sp, #120]
			if (precision >= 0) {
  407990:	37f80157 	tbnz	w23, #31, 4079b8 <z_cbvprintf_impl+0x9b8>
				size_t len = bpe - bps;
  407994:	f94037e0 	ldr	x0, [sp, #104]
				conv->flag_zero = false;
  407998:	794143e1 	ldrh	w1, [sp, #160]
				size_t len = bpe - bps;
  40799c:	cb150000 	sub	x0, x0, x21
				conv->flag_zero = false;
  4079a0:	12197821 	and	w1, w1, #0xffffffbf
  4079a4:	790143e1 	strh	w1, [sp, #160]
				if (len < (size_t)precision) {
  4079a8:	eb37c01f 	cmp	x0, w23, sxtw
  4079ac:	54000062 	b.cs	4079b8 <z_cbvprintf_impl+0x9b8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
  4079b0:	4b0002e0 	sub	w0, w23, w0
  4079b4:	b900a7e0 	str	w0, [sp, #164]
		const char *bpe = buf + sizeof(buf);
  4079b8:	f94037f7 	ldr	x23, [sp, #104]
  4079bc:	17ffffbb 	b	4078a8 <z_cbvprintf_impl+0x8a8>
			if (value->ptr != NULL) {
  4079c0:	f9404be0 	ldr	x0, [sp, #144]
  4079c4:	b4000400 	cbz	x0, 407a44 <z_cbvprintf_impl+0xa44>
				bps = encode_uint((uintptr_t)value->ptr, conv,
  4079c8:	f94037e3 	ldr	x3, [sp, #104]
  4079cc:	910283e1 	add	x1, sp, #0xa0
  4079d0:	9102c3e2 	add	x2, sp, #0xb0
  4079d4:	97fffd4c 	bl	406f04 <encode_uint>
  4079d8:	aa0003f5 	mov	x21, x0
				conv->altform_0c = true;
  4079dc:	794147e0 	ldrh	w0, [sp, #162]
  4079e0:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
  4079e4:	52800006 	mov	w6, #0x0                   	// #0
				conv->altform_0c = true;
  4079e8:	0a010000 	and	w0, w0, w1
  4079ec:	528f0201 	mov	w1, #0x7810                	// #30736
  4079f0:	2a010000 	orr	w0, w0, w1
  4079f4:	790147e0 	strh	w0, [sp, #162]
				goto prec_int_pad0;
  4079f8:	17ffffe6 	b	407990 <z_cbvprintf_impl+0x990>
				store_count(conv, value->ptr, count);
  4079fc:	93407e60 	sxtw	x0, w19
  407a00:	f9404be2 	ldr	x2, [sp, #144]
	switch ((enum length_mod_enum)conv->length_mod) {
  407a04:	71001c3f 	cmp	w1, #0x7
  407a08:	54ffdd08 	b.hi	4075a8 <z_cbvprintf_impl+0x5a8>  // b.pmore
  407a0c:	90000063 	adrp	x3, 413000 <z_impl_k_uptime_ticks>
  407a10:	911a4063 	add	x3, x3, #0x690
  407a14:	38614863 	ldrb	w3, [x3, w1, uxtw]
  407a18:	10000061 	adr	x1, 407a24 <z_cbvprintf_impl+0xa24>
  407a1c:	8b238823 	add	x3, x1, w3, sxtb #2
  407a20:	d61f0060 	br	x3
		*(int *)dp = count;
  407a24:	b9000040 	str	w0, [x2]
		break;
  407a28:	17fffee0 	b	4075a8 <z_cbvprintf_impl+0x5a8>
		*(signed char *)dp = (signed char)count;
  407a2c:	39000053 	strb	w19, [x2]
		break;
  407a30:	17fffede 	b	4075a8 <z_cbvprintf_impl+0x5a8>
		*(short *)dp = (short)count;
  407a34:	79000053 	strh	w19, [x2]
		break;
  407a38:	17fffedc 	b	4075a8 <z_cbvprintf_impl+0x5a8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
  407a3c:	f9000040 	str	x0, [x2]
		break;
  407a40:	17fffeda 	b	4075a8 <z_cbvprintf_impl+0x5a8>
			bps = "(nil)";
  407a44:	b0000075 	adrp	x21, 414000 <dlc_table.0+0x78d>
			bpe = bps + 5;
  407a48:	b0000077 	adrp	x23, 414000 <dlc_table.0+0x78d>
			bps = "(nil)";
  407a4c:	9128c2b5 	add	x21, x21, #0xa30
			bpe = bps + 5;
  407a50:	9128d6f7 	add	x23, x23, #0xa35
  407a54:	17ffffba 	b	40793c <z_cbvprintf_impl+0x93c>
		} else if (conv->altform_0) {
  407a58:	361ff362 	tbz	w2, #3, 4078c4 <z_cbvprintf_impl+0x8c4>
			nj_len += 1U;
  407a5c:	91000400 	add	x0, x0, #0x1
  407a60:	17ffff99 	b	4078c4 <z_cbvprintf_impl+0x8c4>
  407a64:	290f1be2 	stp	w2, w6, [sp, #120]
					OUTC(pad);
  407a68:	aa1a03e1 	mov	x1, x26
  407a6c:	2a0203e0 	mov	w0, w2
  407a70:	d63f0320 	blr	x25
  407a74:	37ffafc0 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  407a78:	294f1be2 	ldp	w2, w6, [sp, #120]
  407a7c:	91000673 	add	x19, x19, #0x1
				while (width-- > 0) {
  407a80:	2a1603e0 	mov	w0, w22
  407a84:	510006d6 	sub	w22, w22, #0x1
  407a88:	7100001f 	cmp	w0, #0x0
  407a8c:	54fffecc 	b.gt	407a64 <z_cbvprintf_impl+0xa64>
		if (sign != 0) {
  407a90:	340000c6 	cbz	w6, 407aa8 <z_cbvprintf_impl+0xaa8>
			OUTC(sign);
  407a94:	aa1a03e1 	mov	x1, x26
  407a98:	2a0603e0 	mov	w0, w6
  407a9c:	d63f0320 	blr	x25
  407aa0:	37ffae60 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  407aa4:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c | conv->altform_0) {
  407aa8:	f94053e0 	ldr	x0, [sp, #160]
  407aac:	d3545001 	ubfx	x1, x0, #20, #1
  407ab0:	d3534c00 	ubfx	x0, x0, #19, #1
  407ab4:	2a000020 	orr	w0, w1, w0
  407ab8:	360000c0 	tbz	w0, #0, 407ad0 <z_cbvprintf_impl+0xad0>
				OUTC('0');
  407abc:	aa1a03e1 	mov	x1, x26
  407ac0:	52800600 	mov	w0, #0x30                  	// #48
  407ac4:	d63f0320 	blr	x25
  407ac8:	37ffad20 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  407acc:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c) {
  407ad0:	39428be0 	ldrb	w0, [sp, #162]
  407ad4:	362000c0 	tbz	w0, #4, 407aec <z_cbvprintf_impl+0xaec>
				OUTC(conv->specifier);
  407ad8:	39428fe0 	ldrb	w0, [sp, #163]
  407adc:	aa1a03e1 	mov	x1, x26
  407ae0:	d63f0320 	blr	x25
  407ae4:	37ffac40 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  407ae8:	91000673 	add	x19, x19, #0x1
			while (pad_len-- > 0) {
  407aec:	b940a7e2 	ldr	w2, [sp, #164]
  407af0:	0b130042 	add	w2, w2, w19
  407af4:	4b130040 	sub	w0, w2, w19
  407af8:	7100001f 	cmp	w0, #0x0
  407afc:	540002cc 	b.gt	407b54 <z_cbvprintf_impl+0xb54>
			OUTS(bps, bpe);
  407b00:	aa1703e3 	mov	x3, x23
  407b04:	aa1503e2 	mov	x2, x21
  407b08:	aa1a03e1 	mov	x1, x26
  407b0c:	aa1903e0 	mov	x0, x25
  407b10:	97fffccd 	bl	406e44 <outs>
  407b14:	37ffaac0 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  407b18:	8b20c273 	add	x19, x19, w0, sxtw
		while (width > 0) {
  407b1c:	0b1302d6 	add	w22, w22, w19
  407b20:	4b1302c0 	sub	w0, w22, w19
  407b24:	7100001f 	cmp	w0, #0x0
  407b28:	54ffd40d 	b.le	4075a8 <z_cbvprintf_impl+0x5a8>
			OUTC(' ');
  407b2c:	aa1a03e1 	mov	x1, x26
  407b30:	52800400 	mov	w0, #0x20                  	// #32
  407b34:	d63f0320 	blr	x25
  407b38:	37ffa9a0 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  407b3c:	91000673 	add	x19, x19, #0x1
			--width;
  407b40:	17fffff8 	b	407b20 <z_cbvprintf_impl+0xb20>
				char pad = ' ';
  407b44:	52800402 	mov	w2, #0x20                  	// #32
  407b48:	17ffff74 	b	407918 <z_cbvprintf_impl+0x918>
					pad = '0';
  407b4c:	52800602 	mov	w2, #0x30                  	// #48
  407b50:	17ffff72 	b	407918 <z_cbvprintf_impl+0x918>
  407b54:	b9007be2 	str	w2, [sp, #120]
				OUTC('0');
  407b58:	aa1a03e1 	mov	x1, x26
  407b5c:	52800600 	mov	w0, #0x30                  	// #48
  407b60:	d63f0320 	blr	x25
  407b64:	37ffa840 	tbnz	w0, #31, 40706c <z_cbvprintf_impl+0x6c>
  407b68:	b9407be2 	ldr	w2, [sp, #120]
  407b6c:	91000673 	add	x19, x19, #0x1
  407b70:	17ffffe1 	b	407af4 <z_cbvprintf_impl+0xaf4>
}
  407b74:	a94153f3 	ldp	x19, x20, [sp, #16]
  407b78:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407b7c:	a94363f7 	ldp	x23, x24, [sp, #48]
  407b80:	a9446bf9 	ldp	x25, x26, [sp, #64]
  407b84:	a94573fb 	ldp	x27, x28, [sp, #80]
  407b88:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  407b8c:	d65f03c0 	ret

0000000000407b90 <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
  407b90:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  407b94:	910003fd 	mov	x29, sp
  407b98:	a90e8be1 	stp	x1, x2, [sp, #232]
  407b9c:	90000121 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  407ba0:	f9476821 	ldr	x1, [x1, #3792]
  407ba4:	3d801be0 	str	q0, [sp, #96]
  407ba8:	3d801fe1 	str	q1, [sp, #112]
  407bac:	3d8023e2 	str	q2, [sp, #128]
  407bb0:	3d8027e3 	str	q3, [sp, #144]
  407bb4:	3d802be4 	str	q4, [sp, #160]
  407bb8:	3d802fe5 	str	q5, [sp, #176]
  407bbc:	3d8033e6 	str	q6, [sp, #192]
  407bc0:	3d8037e7 	str	q7, [sp, #208]
  407bc4:	a90f93e3 	stp	x3, x4, [sp, #248]
  407bc8:	a9109be5 	stp	x5, x6, [sp, #264]
  407bcc:	f9008fe7 	str	x7, [sp, #280]
  407bd0:	f9400022 	ldr	x2, [x1]
  407bd4:	f9002fe2 	str	x2, [sp, #88]
  407bd8:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  407bdc:	910483e1 	add	x1, sp, #0x120
  407be0:	a90387e1 	stp	x1, x1, [sp, #56]
  407be4:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  407be8:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  407bec:	f90027e1 	str	x1, [sp, #72]
  407bf0:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  407bf4:	b90053e1 	str	w1, [sp, #80]
  407bf8:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  407bfc:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  407c00:	910043e1 	add	x1, sp, #0x10
  407c04:	ad400440 	ldp	q0, q1, [x2]
  407c08:	ad000420 	stp	q0, q1, [x1]
  407c0c:	97fffa1b 	bl	406478 <vprintk>

	va_end(ap);
}
  407c10:	90000120 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  407c14:	f9476800 	ldr	x0, [x0, #3792]
  407c18:	f9402fe2 	ldr	x2, [sp, #88]
  407c1c:	f9400001 	ldr	x1, [x0]
  407c20:	eb010042 	subs	x2, x2, x1
  407c24:	d2800001 	mov	x1, #0x0                   	// #0
  407c28:	54000040 	b.eq	407c30 <assert_print+0xa0>  // b.none
  407c2c:	97ffe5bd 	bl	401320 <__stack_chk_fail@plt>
  407c30:	a8d27bfd 	ldp	x29, x30, [sp], #288
  407c34:	d65f03c0 	ret

0000000000407c38 <assert_post_action>:
{
  407c38:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	k_panic();
  407c3c:	52800562 	mov	w2, #0x2b                  	// #43
  407c40:	b0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
{
  407c44:	910003fd 	mov	x29, sp
	k_panic();
  407c48:	9128d821 	add	x1, x1, #0xa36
  407c4c:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  407c50:	911e7800 	add	x0, x0, #0x79e
  407c54:	97ffffcf 	bl	407b90 <assert_print>
}
  407c58:	a8c17bfd 	ldp	x29, x30, [sp], #16
	k_panic();
  407c5c:	d2800001 	mov	x1, #0x0                   	// #0
  407c60:	52800080 	mov	w0, #0x4                   	// #4
  407c64:	14001687 	b	40d680 <z_fatal_error>

0000000000407c68 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_EXPERIMENTAL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  407c68:	d65f03c0 	ret

0000000000407c6c <dummy_timestamp>:
static void msg_process(union log_msg_generic *msg);

static log_timestamp_t dummy_timestamp(void)
{
	return 0;
}
  407c6c:	52800000 	mov	w0, #0x0                   	// #0
  407c70:	d65f03c0 	ret

0000000000407c74 <default_get_timestamp>:

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
  407c74:	140015fe 	b	40d46c <sys_clock_cycle_get_32>

0000000000407c78 <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  407c78:	f9400400 	ldr	x0, [x0, #8]
}
  407c7c:	39402400 	ldrb	w0, [x0, #9]
  407c80:	d65f03c0 	ret

0000000000407c84 <log_backend_is_ready>:
	if (backend->api->is_ready != NULL) {
  407c84:	f9400001 	ldr	x1, [x0]
  407c88:	f9401021 	ldr	x1, [x1, #32]
  407c8c:	b4000061 	cbz	x1, 407c98 <log_backend_is_ready+0x14>
		return backend->api->is_ready(backend);
  407c90:	aa0103f0 	mov	x16, x1
  407c94:	d61f0200 	br	x16
}
  407c98:	52800000 	mov	w0, #0x0                   	// #0
  407c9c:	d65f03c0 	ret

0000000000407ca0 <z_log_init.isra.0>:
	}

	return mask;
}

static uint32_t z_log_init(bool blocking, bool can_sleep)
  407ca0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  407ca4:	910003fd 	mov	x29, sp
  407ca8:	a9025bf5 	stp	x21, x22, [sp, #32]
	STRUCT_SECTION_COUNT(log_backend, &cnt);
  407cac:	90000136 	adrp	x22, 42b000 <__FRAME_END__+0xff4c>
  407cb0:	90000135 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
  407cb4:	f947fed6 	ldr	x22, [x22, #4088]
  407cb8:	a90153f3 	stp	x19, x20, [sp, #16]
  407cbc:	f947b2b3 	ldr	x19, [x21, #3936]
  407cc0:	a9046bf9 	stp	x25, x26, [sp, #64]
  407cc4:	12001c19 	and	w25, w0, #0xff
  407cc8:	cb1302c0 	sub	x0, x22, x19
  407ccc:	a90363f7 	stp	x23, x24, [sp, #48]
  407cd0:	d345fc00 	lsr	x0, x0, #5

	if (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY)) {
		return 0;
	}

	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
  407cd4:	7100241f 	cmp	w0, #0x9
  407cd8:	54000249 	b.ls	407d20 <z_log_init.isra.0+0x80>  // b.plast
  407cdc:	b0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  407ce0:	91296673 	add	x19, x19, #0xa59
  407ce4:	aa1303e2 	mov	x2, x19
  407ce8:	52802323 	mov	w3, #0x119                 	// #281
  407cec:	b0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  407cf0:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  407cf4:	912a1821 	add	x1, x1, #0xa86
  407cf8:	911e2800 	add	x0, x0, #0x78a
  407cfc:	97ffffa5 	bl	407b90 <assert_print>
  407d00:	aa1303e0 	mov	x0, x19
  407d04:	52802321 	mov	w1, #0x119                 	// #281
  407d08:	97ffffcc 	bl	407c38 <assert_post_action>
  407d0c:	52802322 	mov	w2, #0x119                 	// #281
		z_log_links_initiate();
	}


	/* Assign ids to backends. */
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407d10:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  407d14:	aa1303e1 	mov	x1, x19
  407d18:	911f2000 	add	x0, x0, #0x7c8
  407d1c:	940009b9 	bl	40a400 <posix_print_error_and_exit>
  407d20:	12001c37 	and	w23, w1, #0xff
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  407d24:	d2800020 	mov	x0, #0x1                   	// #1
  407d28:	b0000121 	adrp	x1, 42c000 <__dso_handle>
  407d2c:	912e0021 	add	x1, x1, #0xb80
  407d30:	97ffe638 	bl	401610 <__aarch64_ldadd8_acq_rel>
	if (atomic_inc(&initialized) != 0) {
  407d34:	b40005c0 	cbz	x0, 407dec <z_log_init.isra.0+0x14c>
			}
		}
	}

	return mask;
}
  407d38:	a94153f3 	ldp	x19, x20, [sp, #16]
  407d3c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407d40:	a94363f7 	ldp	x23, x24, [sp, #48]
  407d44:	a9446bf9 	ldp	x25, x26, [sp, #64]
  407d48:	a8c57bfd 	ldp	x29, x30, [sp], #80
  407d4c:	d65f03c0 	ret
		if (backend->autostart) {
  407d50:	39406260 	ldrb	w0, [x19, #24]
  407d54:	340001e0 	cbz	w0, 407d90 <z_log_init.isra.0+0xf0>
	if (backend->api->init) {
  407d58:	f9400260 	ldr	x0, [x19]
  407d5c:	f9400c01 	ldr	x1, [x0, #24]
  407d60:	b4000061 	cbz	x1, 407d6c <z_log_init.isra.0+0xcc>
		backend->api->init(backend);
  407d64:	aa1303e0 	mov	x0, x19
  407d68:	d63f0020 	blr	x1
			if (log_backend_is_ready(backend) == 0) {
  407d6c:	aa1303e0 	mov	x0, x19
  407d70:	97ffffc5 	bl	407c84 <log_backend_is_ready>
  407d74:	35000360 	cbnz	w0, 407de0 <z_log_init.isra.0+0x140>
				log_backend_enable(backend,
  407d78:	f9400660 	ldr	x0, [x19, #8]
  407d7c:	52800082 	mov	w2, #0x4                   	// #4
  407d80:	f9400001 	ldr	x1, [x0]
  407d84:	aa1303e0 	mov	x0, x19
  407d88:	94000125 	bl	40821c <log_backend_enable>
			i++;
  407d8c:	11000718 	add	w24, w24, #0x1
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407d90:	91008273 	add	x19, x19, #0x20
  407d94:	eb16027f 	cmp	x19, x22
  407d98:	54000329 	b.ls	407dfc <z_log_init.isra.0+0x15c>  // b.plast
  407d9c:	b0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  407da0:	91296673 	add	x19, x19, #0xa59
  407da4:	aa1303e2 	mov	x2, x19
  407da8:	b0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  407dac:	912aa821 	add	x1, x1, #0xaaa
  407db0:	528024c3 	mov	w3, #0x126                 	// #294
  407db4:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  407db8:	911e2800 	add	x0, x0, #0x78a
  407dbc:	97ffff75 	bl	407b90 <assert_print>
  407dc0:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  407dc4:	912b2c00 	add	x0, x0, #0xacb
  407dc8:	97ffff72 	bl	407b90 <assert_print>
  407dcc:	aa1303e0 	mov	x0, x19
  407dd0:	528024c1 	mov	w1, #0x126                 	// #294
  407dd4:	97ffff99 	bl	407c38 <assert_post_action>
  407dd8:	528024c2 	mov	w2, #0x126                 	// #294
  407ddc:	17ffffcd 	b	407d10 <z_log_init.isra.0+0x70>
				mask |= BIT(i);
  407de0:	9ad82340 	lsl	x0, x26, x24
  407de4:	2a000294 	orr	w20, w20, w0
  407de8:	17ffffe9 	b	407d8c <z_log_init.isra.0+0xec>
	int i = 0;
  407dec:	52800018 	mov	w24, #0x0                   	// #0
	uint32_t mask = 0;
  407df0:	52800014 	mov	w20, #0x0                   	// #0
				mask |= BIT(i);
  407df4:	d280003a 	mov	x26, #0x1                   	// #1
  407df8:	17ffffe7 	b	407d94 <z_log_init.isra.0+0xf4>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407dfc:	54fffaa3 	b.cc	407d50 <z_log_init.isra.0+0xb0>  // b.lo, b.ul, b.last
	if (blocking) {
  407e00:	34fff9d9 	cbz	w25, 407d38 <z_log_init.isra.0+0x98>
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407e04:	f947b2b5 	ldr	x21, [x21, #3936]
		mask_cpy &= ~BIT(i);
  407e08:	d2800039 	mov	x25, #0x1                   	// #1
		while (mask) {
  407e0c:	34fff974 	cbz	w20, 407d38 <z_log_init.isra.0+0x98>
  407e10:	2a1403f8 	mov	w24, w20
		uint32_t i = __builtin_ctz(mask_cpy);
  407e14:	5ac00280 	rbit	w0, w20
  407e18:	5ac01000 	clz	w0, w0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407e1c:	d37b1416 	ubfiz	x22, x0, #5, #6
		mask_cpy &= ~BIT(i);
  407e20:	9ac02321 	lsl	x1, x25, x0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407e24:	8b1602b6 	add	x22, x21, x22
		mask_cpy &= ~BIT(i);
  407e28:	2a2103fa 	mvn	w26, w1
  407e2c:	0a210294 	bic	w20, w20, w1
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407e30:	394062c1 	ldrb	w1, [x22, #24]
  407e34:	34000181 	cbz	w1, 407e64 <z_log_init.isra.0+0x1c4>
	STRUCT_SECTION_GET(log_backend, idx, &backend);
  407e38:	937b7c00 	sbfiz	x0, x0, #5, #32
  407e3c:	8b150013 	add	x19, x0, x21
  407e40:	aa1303e0 	mov	x0, x19
  407e44:	97ffff90 	bl	407c84 <log_backend_is_ready>
  407e48:	350000e0 	cbnz	w0, 407e64 <z_log_init.isra.0+0x1c4>
			log_backend_enable(backend,
  407e4c:	f94006c0 	ldr	x0, [x22, #8]
			mask &= ~BIT(i);
  407e50:	0a1a0318 	and	w24, w24, w26
			log_backend_enable(backend,
  407e54:	52800082 	mov	w2, #0x4                   	// #4
  407e58:	f9400001 	ldr	x1, [x0]
  407e5c:	aa1303e0 	mov	x0, x19
  407e60:	940000ef 	bl	40821c <log_backend_enable>
	while (mask_cpy) {
  407e64:	35fffd94 	cbnz	w20, 407e14 <z_log_init.isra.0+0x174>
			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
  407e68:	34000077 	cbz	w23, 407e74 <z_log_init.isra.0+0x1d4>
	return z_impl_k_sleep(timeout);
  407e6c:	d2800020 	mov	x0, #0x1                   	// #1
  407e70:	940028c0 	bl	412170 <z_impl_k_sleep>
  407e74:	2a1803f4 	mov	w20, w24
  407e78:	17ffffe5 	b	407e0c <z_log_init.isra.0+0x16c>

0000000000407e7c <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(void)
{
  407e7c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
				COND_CODE_1(CONFIG_LOG_PROCESS_THREAD,
					K_MSEC(CONFIG_LOG_PROCESS_THREAD_STARTUP_DELAY_MS),
					K_NO_WAIT));
		k_thread_name_set(&logging_thread, "logging");
	} else {
		(void)z_log_init(false, false);
  407e80:	52800001 	mov	w1, #0x0                   	// #0
  407e84:	52800000 	mov	w0, #0x0                   	// #0
{
  407e88:	910003fd 	mov	x29, sp
		(void)z_log_init(false, false);
  407e8c:	97ffff85 	bl	407ca0 <z_log_init.isra.0>
	}

	return 0;
}
  407e90:	52800000 	mov	w0, #0x0                   	// #0
  407e94:	a8c17bfd 	ldp	x29, x30, [sp], #16
  407e98:	d65f03c0 	ret

0000000000407e9c <log_format_func_t_get>:
}
  407e9c:	90000121 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  407ea0:	9124e021 	add	x1, x1, #0x938
  407ea4:	f8605820 	ldr	x0, [x1, w0, uxtw #3]
  407ea8:	d65f03c0 	ret

0000000000407eac <z_log_vprintk>:
{
  407eac:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  407eb0:	aa0003e6 	mov	x6, x0
  407eb4:	910003fd 	mov	x29, sp
  407eb8:	ad400420 	ldp	q0, q1, [x1]
  407ebc:	9100c3e2 	add	x2, sp, #0x30
  407ec0:	ad000440 	stp	q0, q1, [x2]
  407ec4:	ad400440 	ldp	q0, q1, [x2]
  407ec8:	910043e7 	add	x7, sp, #0x10
  407ecc:	52800005 	mov	w5, #0x0                   	// #0
  407ed0:	d2800004 	mov	x4, #0x0                   	// #0
  407ed4:	d2800003 	mov	x3, #0x0                   	// #0
  407ed8:	52800002 	mov	w2, #0x0                   	// #0
  407edc:	d2800001 	mov	x1, #0x0                   	// #0
  407ee0:	52800000 	mov	w0, #0x0                   	// #0
  407ee4:	ad0004e0 	stp	q0, q1, [x7]
  407ee8:	9400010a 	bl	408310 <z_impl_z_log_msg_runtime_vcreate>
}
  407eec:	a8c57bfd 	ldp	x29, x30, [sp], #80
  407ef0:	d65f03c0 	ret

0000000000407ef4 <log_set_timestamp_func>:
{
  407ef4:	aa0003e2 	mov	x2, x0
	if (timestamp_getter == NULL) {
  407ef8:	b4000140 	cbz	x0, 407f20 <log_set_timestamp_func+0x2c>
{
  407efc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  407f00:	2a0103e0 	mov	w0, w1
	timestamp_func = timestamp_getter;
  407f04:	b0000121 	adrp	x1, 42c000 <__dso_handle>
{
  407f08:	910003fd 	mov	x29, sp
	timestamp_func = timestamp_getter;
  407f0c:	f9000822 	str	x2, [x1, #16]
		log_output_timestamp_freq_set(freq);
  407f10:	9400033c 	bl	408c00 <log_output_timestamp_freq_set>
	return 0;
  407f14:	52800000 	mov	w0, #0x0                   	// #0
}
  407f18:	a8c17bfd 	ldp	x29, x30, [sp], #16
  407f1c:	d65f03c0 	ret
		return -EINVAL;
  407f20:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  407f24:	d65f03c0 	ret

0000000000407f28 <log_core_init>:
	panic_mode = false;
  407f28:	d0000120 	adrp	x0, 42d000 <args_struct>
		log_set_timestamp_func(default_get_timestamp,
  407f2c:	52884801 	mov	w1, #0x4240                	// #16960
  407f30:	72a001e1 	movk	w1, #0xf, lsl #16
	panic_mode = false;
  407f34:	3937b01f 	strb	wzr, [x0, #3564]
	dropped_cnt = 0;
  407f38:	b0000120 	adrp	x0, 42c000 <__dso_handle>
  407f3c:	f905bc1f 	str	xzr, [x0, #2936]
	buffered_cnt = 0;
  407f40:	b0000120 	adrp	x0, 42c000 <__dso_handle>
  407f44:	f905b81f 	str	xzr, [x0, #2928]
		log_set_timestamp_func(default_get_timestamp,
  407f48:	90000000 	adrp	x0, 407000 <z_cbvprintf_impl>
  407f4c:	9131d000 	add	x0, x0, #0xc74
  407f50:	17ffffe9 	b	407ef4 <log_set_timestamp_func>

0000000000407f54 <z_impl_log_panic>:
{
  407f54:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  407f58:	910003fd 	mov	x29, sp
  407f5c:	f90013f5 	str	x21, [sp, #32]
	if (panic_mode) {
  407f60:	d0000135 	adrp	x21, 42d000 <args_struct>
{
  407f64:	a90153f3 	stp	x19, x20, [sp, #16]
	if (panic_mode) {
  407f68:	3977b2a0 	ldrb	w0, [x21, #3564]
  407f6c:	35000740 	cbnz	w0, 408054 <z_impl_log_panic+0x100>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407f70:	90000133 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  407f74:	90000134 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
	(void)z_log_init(true, false);
  407f78:	52800001 	mov	w1, #0x0                   	// #0
  407f7c:	52800020 	mov	w0, #0x1                   	// #1
  407f80:	97ffff48 	bl	407ca0 <z_log_init.isra.0>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407f84:	f947b273 	ldr	x19, [x19, #3936]
  407f88:	f947fe94 	ldr	x20, [x20, #4088]
  407f8c:	eb14027f 	cmp	x19, x20
  407f90:	540005c9 	b.ls	408048 <z_impl_log_panic+0xf4>  // b.plast
  407f94:	b0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  407f98:	91296673 	add	x19, x19, #0xa59
  407f9c:	aa1303e2 	mov	x2, x19
  407fa0:	b0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  407fa4:	912aa821 	add	x1, x1, #0xaaa
  407fa8:	52803103 	mov	w3, #0x188                 	// #392
  407fac:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  407fb0:	911e2800 	add	x0, x0, #0x78a
  407fb4:	97fffef7 	bl	407b90 <assert_print>
  407fb8:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  407fbc:	912b2c00 	add	x0, x0, #0xacb
  407fc0:	97fffef4 	bl	407b90 <assert_print>
  407fc4:	aa1303e0 	mov	x0, x19
  407fc8:	52803101 	mov	w1, #0x188                 	// #392
  407fcc:	97ffff1b 	bl	407c38 <assert_post_action>
  407fd0:	52803102 	mov	w2, #0x188                 	// #392
  407fd4:	14000013 	b	408020 <z_impl_log_panic+0xcc>
		if (log_backend_is_active(backend)) {
  407fd8:	aa1303e0 	mov	x0, x19
  407fdc:	97ffff27 	bl	407c78 <log_backend_is_active>
  407fe0:	72001c1f 	tst	w0, #0xff
  407fe4:	540002e0 	b.eq	408040 <z_impl_log_panic+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  407fe8:	b5000253 	cbnz	x19, 408030 <z_impl_log_panic+0xdc>
  407fec:	b0000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  407ff0:	912baa73 	add	x19, x19, #0xaea
  407ff4:	aa1303e2 	mov	x2, x19
  407ff8:	52801a03 	mov	w3, #0xd0                  	// #208
  407ffc:	b0000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408000:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408004:	912c8821 	add	x1, x1, #0xb22
  408008:	911e2800 	add	x0, x0, #0x78a
  40800c:	97fffee1 	bl	407b90 <assert_print>
  408010:	aa1303e0 	mov	x0, x19
  408014:	52801a01 	mov	w1, #0xd0                  	// #208
  408018:	97ffff08 	bl	407c38 <assert_post_action>
  40801c:	52801a02 	mov	w2, #0xd0                  	// #208
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  408020:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408024:	aa1303e1 	mov	x1, x19
  408028:	911f2000 	add	x0, x0, #0x7c8
  40802c:	940008f5 	bl	40a400 <posix_print_error_and_exit>
	backend->api->panic(backend);
  408030:	f9400260 	ldr	x0, [x19]
  408034:	f9400801 	ldr	x1, [x0, #16]
  408038:	aa1303e0 	mov	x0, x19
  40803c:	d63f0020 	blr	x1
  408040:	91008273 	add	x19, x19, #0x20
  408044:	17ffffd2 	b	407f8c <z_impl_log_panic+0x38>
  408048:	54fffc83 	b.cc	407fd8 <z_impl_log_panic+0x84>  // b.lo, b.ul, b.last
	panic_mode = true;
  40804c:	52800020 	mov	w0, #0x1                   	// #1
  408050:	3937b2a0 	strb	w0, [x21, #3564]
}
  408054:	a94153f3 	ldp	x19, x20, [sp, #16]
  408058:	f94013f5 	ldr	x21, [sp, #32]
  40805c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  408060:	d65f03c0 	ret

0000000000408064 <z_log_notify_backend_enabled>:
}
  408064:	d65f03c0 	ret

0000000000408068 <z_impl_log_process>:
  408068:	52800000 	mov	w0, #0x0                   	// #0
  40806c:	d65f03c0 	ret

0000000000408070 <z_log_dropped>:
{
  408070:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408074:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408078:	912de021 	add	x1, x1, #0xb78
  40807c:	910003fd 	mov	x29, sp
  408080:	f9000bf3 	str	x19, [sp, #16]
  408084:	12001c13 	and	w19, w0, #0xff
  408088:	d2800020 	mov	x0, #0x1                   	// #1
  40808c:	97ffe561 	bl	401610 <__aarch64_ldadd8_acq_rel>
	if (buffered) {
  408090:	340000b3 	cbz	w19, 4080a4 <z_log_dropped+0x34>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  408094:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408098:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40809c:	912dc021 	add	x1, x1, #0xb70
  4080a0:	97ffe55c 	bl	401610 <__aarch64_ldadd8_acq_rel>
}
  4080a4:	f9400bf3 	ldr	x19, [sp, #16]
  4080a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4080ac:	d65f03c0 	ret

00000000004080b0 <z_log_msg_commit>:
{
  4080b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4080b4:	910003fd 	mov	x29, sp
  4080b8:	a90153f3 	stp	x19, x20, [sp, #16]
  4080bc:	aa0003f4 	mov	x20, x0
	msg->hdr.timestamp = timestamp_func();
  4080c0:	90000120 	adrp	x0, 42c000 <__dso_handle>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4080c4:	f0000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
{
  4080c8:	f90013f5 	str	x21, [sp, #32]
	msg->hdr.timestamp = timestamp_func();
  4080cc:	f9400800 	ldr	x0, [x0, #16]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4080d0:	f0000115 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
	msg->hdr.timestamp = timestamp_func();
  4080d4:	d63f0000 	blr	x0
  4080d8:	b9000680 	str	w0, [x20, #4]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4080dc:	f947b273 	ldr	x19, [x19, #3936]
  4080e0:	f947feb5 	ldr	x21, [x21, #4088]
  4080e4:	eb15027f 	cmp	x19, x21
  4080e8:	540005e9 	b.ls	4081a4 <z_log_msg_commit+0xf4>  // b.plast
  4080ec:	90000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  4080f0:	91296673 	add	x19, x19, #0xa59
  4080f4:	aa1303e2 	mov	x2, x19
  4080f8:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  4080fc:	912aa821 	add	x1, x1, #0xaaa
  408100:	528038a3 	mov	w3, #0x1c5                 	// #453
  408104:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408108:	911e2800 	add	x0, x0, #0x78a
  40810c:	97fffea1 	bl	407b90 <assert_print>
  408110:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408114:	912b2c00 	add	x0, x0, #0xacb
  408118:	97fffe9e 	bl	407b90 <assert_print>
  40811c:	aa1303e0 	mov	x0, x19
  408120:	528038a1 	mov	w1, #0x1c5                 	// #453
  408124:	97fffec5 	bl	407c38 <assert_post_action>
  408128:	528038a2 	mov	w2, #0x1c5                 	// #453
  40812c:	14000013 	b	408178 <z_log_msg_commit+0xc8>
		if (log_backend_is_active(backend) &&
  408130:	aa1303e0 	mov	x0, x19
  408134:	97fffed1 	bl	407c78 <log_backend_is_active>
  408138:	72001c1f 	tst	w0, #0xff
  40813c:	54000300 	b.eq	40819c <z_log_msg_commit+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  408140:	b5000253 	cbnz	x19, 408188 <z_log_msg_commit+0xd8>
  408144:	90000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  408148:	912baa73 	add	x19, x19, #0xaea
  40814c:	aa1303e2 	mov	x2, x19
  408150:	52801643 	mov	w3, #0xb2                  	// #178
  408154:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408158:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40815c:	912c8821 	add	x1, x1, #0xb22
  408160:	911e2800 	add	x0, x0, #0x78a
  408164:	97fffe8b 	bl	407b90 <assert_print>
  408168:	aa1303e0 	mov	x0, x19
  40816c:	52801641 	mov	w1, #0xb2                  	// #178
  408170:	97fffeb2 	bl	407c38 <assert_post_action>
  408174:	52801642 	mov	w2, #0xb2                  	// #178
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  408178:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40817c:	aa1303e1 	mov	x1, x19
  408180:	911f2000 	add	x0, x0, #0x7c8
  408184:	9400089f 	bl	40a400 <posix_print_error_and_exit>
	backend->api->process(backend, msg);
  408188:	f9400260 	ldr	x0, [x19]
  40818c:	aa1403e1 	mov	x1, x20
  408190:	f9400002 	ldr	x2, [x0]
  408194:	aa1303e0 	mov	x0, x19
  408198:	d63f0040 	blr	x2
  40819c:	91008273 	add	x19, x19, #0x20
  4081a0:	17ffffd1 	b	4080e4 <z_log_msg_commit+0x34>
  4081a4:	54fffc63 	b.cc	408130 <z_log_msg_commit+0x80>  // b.lo, b.ul, b.last
}
  4081a8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4081ac:	f94013f5 	ldr	x21, [sp, #32]
  4081b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4081b4:	d65f03c0 	ret

00000000004081b8 <z_log_get_tag>:
}
  4081b8:	d2800000 	mov	x0, #0x0                   	// #0
  4081bc:	d65f03c0 	ret

00000000004081c0 <log_src_cnt_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
  4081c0:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4081c4:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4081c8:	f9475c00 	ldr	x0, [x0, #3768]
  4081cc:	f9472821 	ldr	x1, [x1, #3664]
  4081d0:	cb010000 	sub	x0, x0, x1
	if (z_log_is_local_domain(domain_id)) {
		return z_log_sources_count();
	}

	return link_source_count(domain_id);
}
  4081d4:	d3448c00 	ubfx	x0, x0, #4, #32
  4081d8:	d65f03c0 	ret

00000000004081dc <log_source_name_get>:

	return (const char *)cached;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t source_id)
{
  4081dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4081e0:	910003fd 	mov	x29, sp
  4081e4:	f9000bf3 	str	x19, [sp, #16]
  4081e8:	2a0103f3 	mov	w19, w1
	if (z_log_is_local_domain(domain_id)) {
		if (source_id < log_src_cnt_get(domain_id)) {
  4081ec:	97fffff5 	bl	4081c0 <log_src_cnt_get>
  4081f0:	6b13001f 	cmp	w0, w19
  4081f4:	54000109 	b.ls	408214 <log_source_name_get+0x38>  // b.plast
			return TYPE_SECTION_START(log_const)[source_id].name;
  4081f8:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4081fc:	d37c7e73 	ubfiz	x19, x19, #4, #32
  408200:	f9472800 	ldr	x0, [x0, #3664]
  408204:	f8736800 	ldr	x0, [x0, x19]
			return NULL;
		}
	}

	return link_source_name_get(domain_id, source_id);
}
  408208:	f9400bf3 	ldr	x19, [sp, #16]
  40820c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408210:	d65f03c0 	ret
			return NULL;
  408214:	d2800000 	mov	x0, #0x0                   	// #0
  408218:	17fffffc 	b	408208 <log_source_name_get+0x2c>

000000000040821c <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
  40821c:	f0000103 	adrp	x3, 42b000 <__FRAME_END__+0xff4c>
  408220:	f947b063 	ldr	x3, [x3, #3936]
  408224:	cb030003 	sub	x3, x0, x3
	__ASSERT_NO_MSG(backend != NULL);
  408228:	b50002a0 	cbnz	x0, 40827c <log_backend_enable+0x60>
{
  40822c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408230:	52801be3 	mov	w3, #0xdf                  	// #223
  408234:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408238:	910003fd 	mov	x29, sp
  40823c:	f9000bf3 	str	x19, [sp, #16]
  408240:	90000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  408244:	912baa73 	add	x19, x19, #0xaea
  408248:	912c8821 	add	x1, x1, #0xb22
  40824c:	aa1303e2 	mov	x2, x19
  408250:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408254:	911e2800 	add	x0, x0, #0x78a
  408258:	97fffe4e 	bl	407b90 <assert_print>
  40825c:	aa1303e0 	mov	x0, x19
  408260:	52801be1 	mov	w1, #0xdf                  	// #223
  408264:	97fffe75 	bl	407c38 <assert_post_action>
  408268:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40826c:	aa1303e1 	mov	x1, x19
  408270:	911f2000 	add	x0, x0, #0x7c8
  408274:	52801be2 	mov	w2, #0xdf                  	// #223
  408278:	94000862 	bl	40a400 <posix_print_error_and_exit>
	backend->cb->id = id;
  40827c:	f9400404 	ldr	x4, [x0, #8]
  408280:	9345fc63 	asr	x3, x3, #5
  408284:	11000463 	add	w3, w3, #0x1
  408288:	12001c63 	and	w3, w3, #0xff
  40828c:	39002083 	strb	w3, [x4, #8]

	log_backend_id_set(backend, id);
	backend->cb->level = level;
  408290:	f9400403 	ldr	x3, [x0, #8]
  408294:	39002862 	strb	w2, [x3, #10]
	backend->cb->ctx = ctx;
  408298:	f9400402 	ldr	x2, [x0, #8]
  40829c:	f9000041 	str	x1, [x2]
	backend->cb->active = true;
  4082a0:	52800021 	mov	w1, #0x1                   	// #1
  4082a4:	f9400400 	ldr	x0, [x0, #8]
  4082a8:	39002401 	strb	w1, [x0, #9]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
  4082ac:	17ffff6e 	b	408064 <z_log_notify_backend_enabled>

00000000004082b0 <z_log_msg_finalize>:
	 (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY) || log_backend_count_get() == 0))

void z_log_msg_finalize(struct log_msg *msg, const void *source,
			 const struct log_msg_desc desc, const void *data)
{
	if (!msg) {
  4082b0:	b5000060 	cbnz	x0, 4082bc <z_log_msg_finalize+0xc>
		z_log_dropped(false);
  4082b4:	52800000 	mov	w0, #0x0                   	// #0
  4082b8:	17ffff6e 	b	408070 <z_log_dropped>
{
  4082bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4082c0:	910003fd 	mov	x29, sp
  4082c4:	a90153f3 	stp	x19, x20, [sp, #16]
  4082c8:	aa0003f3 	mov	x19, x0
  4082cc:	2a0203f4 	mov	w20, w2
  4082d0:	f90013f5 	str	x21, [sp, #32]
  4082d4:	aa0103f5 	mov	x21, x1
  4082d8:	aa0303e1 	mov	x1, x3

		return;
	}

	if (data) {
  4082dc:	b40000c3 	cbz	x3, 4082f4 <z_log_msg_finalize+0x44>
		uint8_t *d = msg->data + desc.package_len;
  4082e0:	d3494e83 	ubfx	x3, x20, #9, #11
  4082e4:	91004000 	add	x0, x0, #0x10
  4082e8:	53147c42 	lsr	w2, w2, #20
  4082ec:	8b030000 	add	x0, x0, x3
  4082f0:	97ffe3a0 	bl	401170 <memcpy@plt>

		memcpy(d, data, desc.data_len);
	}

	msg->hdr.desc = desc;
  4082f4:	b9000274 	str	w20, [x19]
	msg->hdr.source = source;
	z_log_msg_commit(msg);
  4082f8:	aa1303e0 	mov	x0, x19
	msg->hdr.source = source;
  4082fc:	f9000675 	str	x21, [x19, #8]
}
  408300:	a94153f3 	ldp	x19, x20, [sp, #16]
  408304:	f94013f5 	ldr	x21, [sp, #32]
  408308:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_log_msg_commit(msg);
  40830c:	17ffff69 	b	4080b0 <z_log_msg_commit>

0000000000408310 <z_impl_z_log_msg_runtime_vcreate>:
#endif

void z_impl_z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				uint32_t package_flags, const char *fmt, va_list ap)
{
  408310:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  408314:	910003fd 	mov	x29, sp
  408318:	a9046bf9 	stp	x25, x26, [sp, #64]
  40831c:	12001c1a 	and	w26, w0, #0xff
  408320:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  408324:	a90153f3 	stp	x19, x20, [sp, #16]
  408328:	aa0103f4 	mov	x20, x1
  40832c:	12001c53 	and	w19, w2, #0xff
  408330:	f9476800 	ldr	x0, [x0, #3792]
  408334:	a9025bf5 	stp	x21, x22, [sp, #32]
  408338:	2a0503f9 	mov	w25, w5
  40833c:	a90363f7 	stp	x23, x24, [sp, #48]
  408340:	aa0303f5 	mov	x21, x3
  408344:	d10043ff 	sub	sp, sp, #0x10
  408348:	f9400001 	ldr	x1, [x0]
  40834c:	f9004fa1 	str	x1, [x29, #152]
  408350:	d2800001 	mov	x1, #0x0                   	// #0
  408354:	aa0403f8 	mov	x24, x4
  408358:	aa0603f6 	mov	x22, x6
  40835c:	aa0703f7 	mov	x23, x7
	int plen;

	if (fmt) {
  408360:	b40003a6 	cbz	x6, 4083d4 <z_impl_z_log_msg_runtime_vcreate+0xc4>
		va_list ap2;

		va_copy(ap2, ap);
  408364:	ad4004e0 	ldp	q0, q1, [x7]
  408368:	9101e3a0 	add	x0, x29, #0x78
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  40836c:	910143a4 	add	x4, x29, #0x50
  408370:	aa0603e3 	mov	x3, x6
  408374:	2a0503e2 	mov	w2, w5
  408378:	d2800201 	mov	x1, #0x10                  	// #16
		va_copy(ap2, ap);
  40837c:	ad000400 	stp	q0, q1, [x0]
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  408380:	d2800000 	mov	x0, #0x0                   	// #0
  408384:	ad000480 	stp	q0, q1, [x4]
  408388:	97fff628 	bl	405c28 <cbvprintf_package>
					 package_flags, fmt, ap2);
		__ASSERT_NO_MSG(plen >= 0);
  40838c:	36f80260 	tbz	w0, #31, 4083d8 <z_impl_z_log_msg_runtime_vcreate+0xc8>
  408390:	90000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  408394:	912e3a73 	add	x19, x19, #0xb8e
  408398:	aa1303e2 	mov	x2, x19
  40839c:	52800ea3 	mov	w3, #0x75                  	// #117
  4083a0:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  4083a4:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4083a8:	912ee821 	add	x1, x1, #0xbba
  4083ac:	911e2800 	add	x0, x0, #0x78a
  4083b0:	97fffdf8 	bl	407b90 <assert_print>
  4083b4:	aa1303e0 	mov	x0, x19
  4083b8:	52800ea1 	mov	w1, #0x75                  	// #117
  4083bc:	97fffe1f 	bl	407c38 <assert_post_action>
  4083c0:	52800ea2 	mov	w2, #0x75                  	// #117
		pkg = msg->data;
	}

	if (pkg && fmt) {
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
		__ASSERT_NO_MSG(plen >= 0);
  4083c4:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4083c8:	aa1303e1 	mov	x1, x19
  4083cc:	911f2000 	add	x0, x0, #0x7c8
  4083d0:	9400080c 	bl	40a400 <posix_print_error_and_exit>
		plen = 0;
  4083d4:	52800000 	mov	w0, #0x0                   	// #0
	struct log_msg_desc desc =
  4083d8:	531a0a73 	ubfiz	w19, w19, #6, #3
  4083dc:	531d0b5a 	ubfiz	w26, w26, #3, #3
  4083e0:	53172802 	ubfiz	w2, w0, #9, #11
  4083e4:	2a1a0273 	orr	w19, w19, w26
  4083e8:	2a020273 	orr	w19, w19, w2
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  4083ec:	93407c01 	sxtw	x1, w0
	struct log_msg_desc desc =
  4083f0:	2a185273 	orr	w19, w19, w24, lsl #20
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  4083f4:	91005f18 	add	x24, x24, #0x17
  4083f8:	8b20c300 	add	x0, x24, w0, sxtw
		msg = alloca(msg_wlen * sizeof(int));
  4083fc:	927df000 	and	x0, x0, #0xfffffffffffffff8
  408400:	91003c00 	add	x0, x0, #0xf
  408404:	927cec02 	and	x2, x0, #0xfffffffffffffff0
  408408:	9270bc00 	and	x0, x0, #0xffffffffffff0000
  40840c:	cb2063e0 	sub	x0, sp, x0
  408410:	eb2063ff 	cmp	sp, x0
  408414:	54000080 	b.eq	408424 <z_impl_z_log_msg_runtime_vcreate+0x114>  // b.none
  408418:	d14043ff 	sub	sp, sp, #0x10, lsl #12
  40841c:	f90203ff 	str	xzr, [sp, #1024]
  408420:	17fffffc 	b	408410 <z_impl_z_log_msg_runtime_vcreate+0x100>
  408424:	92403c40 	and	x0, x2, #0xffff
  408428:	cb2063ff 	sub	sp, sp, x0
  40842c:	f90003ff 	str	xzr, [sp]
  408430:	f110001f 	cmp	x0, #0x400
  408434:	54000043 	b.cc	40843c <z_impl_z_log_msg_runtime_vcreate+0x12c>  // b.lo, b.ul, b.last
  408438:	f90203ff 	str	xzr, [sp, #1024]
  40843c:	910043f8 	add	x24, sp, #0x10
	if (pkg && fmt) {
  408440:	b40002f6 	cbz	x22, 40849c <z_impl_z_log_msg_runtime_vcreate+0x18c>
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
  408444:	ad4006e0 	ldp	q0, q1, [x23]
  408448:	910143a4 	add	x4, x29, #0x50
  40844c:	aa1603e3 	mov	x3, x22
  408450:	2a1903e2 	mov	w2, w25
  408454:	91004300 	add	x0, x24, #0x10
  408458:	ad000480 	stp	q0, q1, [x4]
  40845c:	97fff5f3 	bl	405c28 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
  408460:	36f801e0 	tbz	w0, #31, 40849c <z_impl_z_log_msg_runtime_vcreate+0x18c>
  408464:	90000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  408468:	912e3a73 	add	x19, x19, #0xb8e
  40846c:	aa1303e2 	mov	x2, x19
  408470:	528011e3 	mov	w3, #0x8f                  	// #143
  408474:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408478:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40847c:	912ee821 	add	x1, x1, #0xbba
  408480:	911e2800 	add	x0, x0, #0x78a
  408484:	97fffdc3 	bl	407b90 <assert_print>
  408488:	aa1303e0 	mov	x0, x19
  40848c:	528011e1 	mov	w1, #0x8f                  	// #143
  408490:	97fffdea 	bl	407c38 <assert_post_action>
  408494:	528011e2 	mov	w2, #0x8f                  	// #143
  408498:	17ffffcb 	b	4083c4 <z_impl_z_log_msg_runtime_vcreate+0xb4>
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_msg(source, desc, pkg, data);
	}

	if (BACKENDS_IN_USE()) {
		z_log_msg_finalize(msg, source, desc, data);
  40849c:	2a1303e2 	mov	w2, w19
  4084a0:	aa1403e1 	mov	x1, x20
  4084a4:	aa1803e0 	mov	x0, x24
  4084a8:	aa1503e3 	mov	x3, x21
  4084ac:	97ffff81 	bl	4082b0 <z_log_msg_finalize>
	}
}
  4084b0:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4084b4:	f9476800 	ldr	x0, [x0, #3792]
  4084b8:	f9404fa2 	ldr	x2, [x29, #152]
  4084bc:	f9400001 	ldr	x1, [x0]
  4084c0:	eb010042 	subs	x2, x2, x1
  4084c4:	d2800001 	mov	x1, #0x0                   	// #0
  4084c8:	54000040 	b.eq	4084d0 <z_impl_z_log_msg_runtime_vcreate+0x1c0>  // b.none
  4084cc:	97ffe395 	bl	401320 <__stack_chk_fail@plt>
  4084d0:	910003bf 	mov	sp, x29
  4084d4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4084d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4084dc:	a94363f7 	ldp	x23, x24, [sp, #48]
  4084e0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4084e4:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  4084e8:	d65f03c0 	ret

00000000004084ec <out_func>:

	return ret;
}

static int out_func(int c, void *ctx)
{
  4084ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4084f0:	f0000102 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  4084f4:	910003fd 	mov	x29, sp
  4084f8:	f9476842 	ldr	x2, [x2, #3792]
  4084fc:	f9400043 	ldr	x3, [x2]
  408500:	f9000fe3 	str	x3, [sp, #24]
  408504:	d2800003 	mov	x3, #0x0                   	// #0
	int idx;

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		/* Backend must be thread safe in synchronous operation. */
		/* Need that step for big endian */
		char x = (char)c;
  408508:	39005fe0 	strb	w0, [sp, #23]

		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
  40850c:	a9400023 	ldp	x3, x0, [x1]
  408510:	d2800021 	mov	x1, #0x1                   	// #1
  408514:	f9400402 	ldr	x2, [x0, #8]
  408518:	91005fe0 	add	x0, sp, #0x17
  40851c:	d63f0060 	blr	x3
	out_ctx->buf[idx] = (uint8_t)c;

	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);

	return 0;
}
  408520:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  408524:	f9476800 	ldr	x0, [x0, #3792]
  408528:	f9400fe2 	ldr	x2, [sp, #24]
  40852c:	f9400001 	ldr	x1, [x0]
  408530:	eb010042 	subs	x2, x2, x1
  408534:	d2800001 	mov	x1, #0x0                   	// #0
  408538:	54000040 	b.eq	408540 <out_func+0x54>  // b.none
  40853c:	97ffe379 	bl	401320 <__stack_chk_fail@plt>
  408540:	52800000 	mov	w0, #0x0                   	// #0
  408544:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408548:	d65f03c0 	ret

000000000040854c <cr_out_func>:

static int cr_out_func(int c, void *ctx)
{
  40854c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408550:	910003fd 	mov	x29, sp
  408554:	a90153f3 	stp	x19, x20, [sp, #16]
  408558:	2a0003f3 	mov	w19, w0
  40855c:	aa0103f4 	mov	x20, x1
	if (c == '\n') {
  408560:	7100281f 	cmp	w0, #0xa
  408564:	54000061 	b.ne	408570 <cr_out_func+0x24>  // b.any
		out_func((int)'\r', ctx);
  408568:	528001a0 	mov	w0, #0xd                   	// #13
  40856c:	97ffffe0 	bl	4084ec <out_func>
	}
	out_func(c, ctx);
  408570:	aa1403e1 	mov	x1, x20
  408574:	2a1303e0 	mov	w0, w19
  408578:	97ffffdd 	bl	4084ec <out_func>

	return 0;
}
  40857c:	52800000 	mov	w0, #0x0                   	// #0
  408580:	a94153f3 	ldp	x19, x20, [sp, #16]
  408584:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408588:	d65f03c0 	ret

000000000040858c <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
  40858c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  408590:	910003fd 	mov	x29, sp
  408594:	a90153f3 	stp	x19, x20, [sp, #16]
  408598:	aa0103f4 	mov	x20, x1
  40859c:	aa0203f3 	mov	x19, x2
  4085a0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4085a4:	aa0003f5 	mov	x21, x0
  4085a8:	aa0303f6 	mov	x22, x3
	int processed;

	do {
		processed = outf(buf, len, ctx);
  4085ac:	aa1303e1 	mov	x1, x19
  4085b0:	aa1403e0 	mov	x0, x20
  4085b4:	aa1603e2 	mov	x2, x22
  4085b8:	d63f02a0 	blr	x21
		len -= processed;
		buf += processed;
  4085bc:	8b20c294 	add	x20, x20, w0, sxtw
	} while (len != 0);
  4085c0:	eb20c273 	subs	x19, x19, w0, sxtw
  4085c4:	54ffff41 	b.ne	4085ac <buffer_write+0x20>  // b.any
}
  4085c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4085cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4085d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4085d4:	d65f03c0 	ret

00000000004085d8 <cbvprintf>:
#ifdef CONFIG_PICOLIBC
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
  4085d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4085dc:	910003fd 	mov	x29, sp
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
  4085e0:	ad400460 	ldp	q0, q1, [x3]
  4085e4:	910043e4 	add	x4, sp, #0x10
  4085e8:	aa0403e3 	mov	x3, x4
  4085ec:	ad000480 	stp	q0, q1, [x4]
  4085f0:	52800004 	mov	w4, #0x0                   	// #0
  4085f4:	97fffa83 	bl	407000 <z_cbvprintf_impl>
}
  4085f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4085fc:	d65f03c0 	ret

0000000000408600 <print_formatted>:
{
  408600:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  408604:	910003fd 	mov	x29, sp
  408608:	a90e0fe2 	stp	x2, x3, [sp, #224]
  40860c:	f0000102 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  408610:	f9476842 	ldr	x2, [x2, #3792]
  408614:	3d801be0 	str	q0, [sp, #96]
  408618:	3d801fe1 	str	q1, [sp, #112]
  40861c:	3d8023e2 	str	q2, [sp, #128]
  408620:	3d8027e3 	str	q3, [sp, #144]
  408624:	3d802be4 	str	q4, [sp, #160]
  408628:	3d802fe5 	str	q5, [sp, #176]
  40862c:	3d8033e6 	str	q6, [sp, #192]
  408630:	3d8037e7 	str	q7, [sp, #208]
  408634:	a90f17e4 	stp	x4, x5, [sp, #240]
  408638:	a9101fe6 	stp	x6, x7, [sp, #256]
  40863c:	f9400043 	ldr	x3, [x2]
  408640:	f9002fe3 	str	x3, [sp, #88]
  408644:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(args, fmt);
  408648:	910443e2 	add	x2, sp, #0x110
  40864c:	a9038be2 	stp	x2, x2, [sp, #56]
  408650:	910383e2 	add	x2, sp, #0xe0
	length = cbvprintf(out_func, (void *)output, fmt, args);
  408654:	910043e3 	add	x3, sp, #0x10
	va_start(args, fmt);
  408658:	f90027e2 	str	x2, [sp, #72]
  40865c:	128005e2 	mov	w2, #0xffffffd0            	// #-48
  408660:	b90053e2 	str	w2, [sp, #80]
  408664:	12800fe2 	mov	w2, #0xffffff80            	// #-128
  408668:	b90057e2 	str	w2, [sp, #84]
	length = cbvprintf(out_func, (void *)output, fmt, args);
  40866c:	9100e3e2 	add	x2, sp, #0x38
  408670:	ad400440 	ldp	q0, q1, [x2]
  408674:	aa0103e2 	mov	x2, x1
  408678:	aa0003e1 	mov	x1, x0
  40867c:	90000000 	adrp	x0, 408000 <z_impl_log_panic+0xac>
  408680:	9113b000 	add	x0, x0, #0x4ec
  408684:	ad000460 	stp	q0, q1, [x3]
  408688:	97ffffd4 	bl	4085d8 <cbvprintf>
}
  40868c:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  408690:	f9476821 	ldr	x1, [x1, #3792]
  408694:	f9402fe3 	ldr	x3, [sp, #88]
  408698:	f9400022 	ldr	x2, [x1]
  40869c:	eb020063 	subs	x3, x3, x2
  4086a0:	d2800002 	mov	x2, #0x0                   	// #0
  4086a4:	54000040 	b.eq	4086ac <print_formatted+0xac>  // b.none
  4086a8:	97ffe31e 	bl	401320 <__stack_chk_fail@plt>
  4086ac:	a8d17bfd 	ldp	x29, x30, [sp], #272
  4086b0:	d65f03c0 	ret

00000000004086b4 <log_output_flush>:


void log_output_flush(const struct log_output *output)
{
  4086b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4086b8:	910003fd 	mov	x29, sp
  4086bc:	f9000bf3 	str	x19, [sp, #16]
  4086c0:	aa0003f3 	mov	x19, x0
	buffer_write(output->func, output->buf,
  4086c4:	a9408400 	ldp	x0, x1, [x0, #8]
  4086c8:	a9400c02 	ldp	x2, x3, [x0]
  4086cc:	f9400260 	ldr	x0, [x19]
  4086d0:	97ffffaf 	bl	40858c <buffer_write>
		     output->control_block->offset,
		     output->control_block->ctx);

	output->control_block->offset = 0;
  4086d4:	f9400660 	ldr	x0, [x19, #8]
  4086d8:	f900001f 	str	xzr, [x0]
}
  4086dc:	f9400bf3 	ldr	x19, [sp, #16]
  4086e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4086e4:	d65f03c0 	ret

00000000004086e8 <log_output_process>:
			uint8_t level,
			const uint8_t *package,
			const uint8_t *data,
			size_t data_len,
			uint32_t flags)
{
  4086e8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  4086ec:	910003fd 	mov	x29, sp
  4086f0:	a90153f3 	stp	x19, x20, [sp, #16]
  4086f4:	aa0003f3 	mov	x19, x0
  4086f8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4086fc:	aa0703f5 	mov	x21, x7
  408700:	b94083f6 	ldr	w22, [sp, #128]
  408704:	a90363f7 	stp	x23, x24, [sp, #48]
  408708:	aa0603f7 	mov	x23, x6
  40870c:	a9046bf9 	stp	x25, x26, [sp, #64]
  408710:	aa0303fa 	mov	x26, x3
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	uint32_t prefix_offset;
	cbprintf_cb cb;

	if (!raw_string) {
  408714:	72001c99 	ands	w25, w4, #0xff
{
  408718:	a90573fb 	stp	x27, x28, [sp, #80]
  40871c:	aa0503fb 	mov	x27, x5
	if (!raw_string) {
  408720:	54001100 	b.eq	408940 <log_output_process+0x258>  // b.none
	__ASSERT_NO_MSG(level <= LOG_LEVEL_DBG);
  408724:	7100133f 	cmp	w25, #0x4
  408728:	54000249 	b.ls	408770 <log_output_process+0x88>  // b.plast
  40872c:	90000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  408730:	912f2673 	add	x19, x19, #0xbc9
  408734:	aa1303e2 	mov	x2, x19
  408738:	52803663 	mov	w3, #0x1b3                 	// #435
  40873c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408740:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408744:	912fe021 	add	x1, x1, #0xbf8
  408748:	911e2800 	add	x0, x0, #0x78a
  40874c:	97fffd11 	bl	407b90 <assert_print>
  408750:	aa1303e0 	mov	x0, x19
  408754:	52803661 	mov	w1, #0x1b3                 	// #435
  408758:	97fffd38 	bl	407c38 <assert_post_action>
  40875c:	52803662 	mov	w2, #0x1b3                 	// #435

	if (package) {
		int err = cbpprintf(cb, (void *)output, (void *)package);

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
  408760:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408764:	aa1303e1 	mov	x1, x19
  408768:	911f2000 	add	x0, x0, #0x7c8
  40876c:	94000725 	bl	40a400 <posix_print_error_and_exit>
  408770:	121d02c0 	and	w0, w22, #0x8
  408774:	aa0203fc 	mov	x28, x2
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  408778:	2a0103f4 	mov	w20, w1
  40877c:	b9007be0 	str	w0, [sp, #120]
	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
  408780:	97fffe8e 	bl	4081b8 <z_log_get_tag>
  408784:	aa0003e2 	mov	x2, x0
	if (tag) {
  408788:	b40009e0 	cbz	x0, 4088c4 <log_output_process+0x1dc>
		length += print_formatted(output, "%s ", tag);
  40878c:	aa1303e0 	mov	x0, x19
  408790:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408794:	91301021 	add	x1, x1, #0xc04
  408798:	97ffff9a 	bl	408600 <print_formatted>
  40879c:	2a0003f8 	mov	w24, w0
	if (stamp) {
  4087a0:	121f02c0 	and	w0, w22, #0x2
  4087a4:	34000140 	cbz	w0, 4087cc <log_output_process+0xe4>
	if (!format) {
  4087a8:	52800880 	mov	w0, #0x44                  	// #68
  4087ac:	6a0002df 	tst	w22, w0
  4087b0:	540008e1 	b.ne	4088cc <log_output_process+0x1e4>  // b.any
		length = print_formatted(output, "[%08lu] ", timestamp);
  4087b4:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  4087b8:	2a1403e2 	mov	w2, w20
  4087bc:	91302021 	add	x1, x1, #0xc08
  4087c0:	aa1303e0 	mov	x0, x19
  4087c4:	97ffff8f 	bl	408600 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
  4087c8:	0b000318 	add	w24, w24, w0
	if (color) {
  4087cc:	120002c0 	and	w0, w22, #0x1
  4087d0:	34000180 	cbz	w0, 408800 <log_output_process+0x118>
		const char *log_color = start && (colors[level] != NULL) ?
  4087d4:	2a1903e1 	mov	w1, w25
  4087d8:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4087dc:	911ec000 	add	x0, x0, #0x7b0
  4087e0:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  4087e4:	b5000062 	cbnz	x2, 4087f0 <log_output_process+0x108>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
  4087e8:	90000062 	adrp	x2, 414000 <dlc_table.0+0x78d>
  4087ec:	912f1042 	add	x2, x2, #0xbc4
		print_formatted(output, "%s", log_color);
  4087f0:	b0000061 	adrp	x1, 415000 <random_data+0xca4>
  4087f4:	aa1303e0 	mov	x0, x19
  4087f8:	91165c21 	add	x1, x1, #0x597
  4087fc:	97ffff81 	bl	408600 <print_formatted>
	if (level_on) {
  408800:	121d02c0 	and	w0, w22, #0x8
  408804:	340009a0 	cbz	w0, 408938 <log_output_process+0x250>
		total += print_formatted(output, "<%s> ", severity[level]);
  408808:	2a1903e1 	mov	w1, w25
  40880c:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  408810:	911f6000 	add	x0, x0, #0x7d8
  408814:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  408818:	aa1303e0 	mov	x0, x19
  40881c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408820:	9130b421 	add	x1, x1, #0xc2d
  408824:	97ffff77 	bl	408600 <print_formatted>
  408828:	2a0003f4 	mov	w20, w0
	if (domain) {
  40882c:	b40000fc 	cbz	x28, 408848 <log_output_process+0x160>
		total += print_formatted(output, "%s/", domain);
  408830:	aa1c03e2 	mov	x2, x28
  408834:	aa1303e0 	mov	x0, x19
  408838:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  40883c:	9130cc21 	add	x1, x1, #0xc33
  408840:	97ffff70 	bl	408600 <print_formatted>
  408844:	0b000294 	add	w20, w20, w0
	if (source) {
  408848:	b40000fa 	cbz	x26, 408864 <log_output_process+0x17c>
		total += print_formatted(output,
  40884c:	aa1a03e2 	mov	x2, x26
  408850:	aa1303e0 	mov	x0, x19
  408854:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408858:	9130dc21 	add	x1, x1, #0xc37
  40885c:	97ffff69 	bl	408600 <print_formatted>
  408860:	0b000294 	add	w20, w20, w0
		cb = out_func;
  408864:	90000000 	adrp	x0, 408000 <z_impl_log_panic+0xac>
	length += ids_print(output, level_on, func_on, domain, source, level);
  408868:	0b180294 	add	w20, w20, w24
		cb = out_func;
  40886c:	9113b000 	add	x0, x0, #0x4ec
	if (package) {
  408870:	b40007bb 	cbz	x27, 408964 <log_output_process+0x27c>
		return cbpprintf_external(out, cbvprintf_tagged_args,
					  ctx, packaged);
	}
#endif

	return cbpprintf_external(out, cbvprintf, ctx, packaged);
  408874:	90000001 	adrp	x1, 408000 <z_impl_log_panic+0xac>
  408878:	aa1b03e3 	mov	x3, x27
  40887c:	aa1303e2 	mov	x2, x19
  408880:	91176021 	add	x1, x1, #0x5d8
  408884:	97fff6c6 	bl	40639c <cbpprintf_external>
		__ASSERT_NO_MSG(err >= 0);
  408888:	36f806e0 	tbz	w0, #31, 408964 <log_output_process+0x27c>
  40888c:	90000073 	adrp	x19, 414000 <dlc_table.0+0x78d>
  408890:	912f2673 	add	x19, x19, #0xbc9
  408894:	aa1303e2 	mov	x2, x19
  408898:	52804123 	mov	w3, #0x209                 	// #521
  40889c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  4088a0:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4088a4:	9130f021 	add	x1, x1, #0xc3c
  4088a8:	911e2800 	add	x0, x0, #0x78a
  4088ac:	97fffcb9 	bl	407b90 <assert_print>
  4088b0:	aa1303e0 	mov	x0, x19
  4088b4:	52804121 	mov	w1, #0x209                 	// #521
  4088b8:	97fffce0 	bl	407c38 <assert_post_action>
  4088bc:	52804122 	mov	w2, #0x209                 	// #521
  4088c0:	17ffffa8 	b	408760 <log_output_process+0x78>
	uint32_t length = 0U;
  4088c4:	52800018 	mov	w24, #0x0                   	// #0
  4088c8:	17ffffb6 	b	4087a0 <log_output_process+0xb8>
	} else if (freq != 0U) {
  4088cc:	b0000120 	adrp	x0, 42d000 <args_struct>
  4088d0:	b94bbc06 	ldr	w6, [x0, #3004]
  4088d4:	340002e6 	cbz	w6, 408930 <log_output_process+0x248>
		timestamp /= timestamp_div;
  4088d8:	b0000120 	adrp	x0, 42d000 <args_struct>
  4088dc:	5281c201 	mov	w1, #0xe10                 	// #3600
		ms = (remainder * 1000U) / freq;
  4088e0:	52807d03 	mov	w3, #0x3e8                 	// #1000
				length = print_formatted(output,
  4088e4:	52800784 	mov	w4, #0x3c                  	// #60
		timestamp /= timestamp_div;
  4088e8:	b94bc000 	ldr	w0, [x0, #3008]
  4088ec:	1ac00a94 	udiv	w20, w20, w0
		total_seconds = timestamp / freq;
  4088f0:	1ac60a80 	udiv	w0, w20, w6
		seconds -= hours * 3600U;
  4088f4:	1ac10802 	udiv	w2, w0, w1
  4088f8:	1b018041 	msub	w1, w2, w1, w0
		remainder = timestamp % freq;
  4088fc:	1b06d000 	msub	w0, w0, w6, w20
		ms = (remainder * 1000U) / freq;
  408900:	1b037c00 	mul	w0, w0, w3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  408904:	1ac60805 	udiv	w5, w0, w6
  408908:	1b0680a0 	msub	w0, w5, w6, w0
  40890c:	1b037c00 	mul	w0, w0, w3
				length = print_formatted(output,
  408910:	1ac40823 	udiv	w3, w1, w4
  408914:	1ac60806 	udiv	w6, w0, w6
  408918:	aa1303e0 	mov	x0, x19
  40891c:	1b048464 	msub	w4, w3, w4, w1
  408920:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408924:	91304421 	add	x1, x1, #0xc11
  408928:	97ffff36 	bl	408600 <print_formatted>
  40892c:	17ffffa7 	b	4087c8 <log_output_process+0xe0>
		length = 0;
  408930:	52800000 	mov	w0, #0x0                   	// #0
  408934:	17ffffa5 	b	4087c8 <log_output_process+0xe0>
	int total = 0;
  408938:	52800014 	mov	w20, #0x0                   	// #0
  40893c:	17ffffbc 	b	40882c <log_output_process+0x144>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  408940:	f100047f 	cmp	x3, #0x1
  408944:	540000a0 	b.eq	408958 <log_output_process+0x270>  // b.none
  408948:	90000000 	adrp	x0, 408000 <z_impl_log_panic+0xac>
  40894c:	91153000 	add	x0, x0, #0x54c
		prefix_offset = 0;
  408950:	52800014 	mov	w20, #0x0                   	// #0
  408954:	17ffffc7 	b	408870 <log_output_process+0x188>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  408958:	90000000 	adrp	x0, 408000 <z_impl_log_panic+0xac>
  40895c:	9113b000 	add	x0, x0, #0x4ec
  408960:	17fffffc 	b	408950 <log_output_process+0x268>
	}

	if (data_len) {
  408964:	b4000895 	cbz	x21, 408a74 <log_output_process+0x38c>
		print_formatted(output, " ");
  408968:	90000078 	adrp	x24, 414000 <dlc_table.0+0x78d>
  40896c:	91312b18 	add	x24, x24, #0xc4a
		print_formatted(ctx, "\r\n");
  408970:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408974:	91311400 	add	x0, x0, #0xc45
  408978:	f9003be0 	str	x0, [sp, #112]
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
  40897c:	52800200 	mov	w0, #0x10                  	// #16
  408980:	6b0002bf 	cmp	w21, w0
  408984:	1a8092a1 	csel	w1, w21, w0, ls  // ls = plast
  408988:	1a8092a0 	csel	w0, w21, w0, ls  // ls = plast
  40898c:	f90033e0 	str	x0, [sp, #96]
  408990:	b9007be1 	str	w1, [sp, #120]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  408994:	372000d6 	tbnz	w22, #4, 4089ac <log_output_process+0x2c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  408998:	362809b6 	tbz	w22, #5, 408acc <log_output_process+0x3e4>
		print_formatted(ctx, "\n");
  40899c:	b0000061 	adrp	x1, 415000 <random_data+0xca4>
  4089a0:	9135a821 	add	x1, x1, #0xd6a
		print_formatted(ctx, "\r\n");
  4089a4:	aa1303e0 	mov	x0, x19
  4089a8:	97ffff16 	bl	408600 <print_formatted>
		prefix_offset = 0;
  4089ac:	5280001b 	mov	w27, #0x0                   	// #0
	for (int i = 0; i < prefix_offset; i++) {
  4089b0:	6b1b029f 	cmp	w20, w27
  4089b4:	5400090c 	b.gt	408ad4 <log_output_process+0x3ec>
			print_formatted(output, "%02x ", data[i]);
  4089b8:	f000005c 	adrp	x28, 413000 <z_impl_k_uptime_ticks>
  4089bc:	9131ab9c 	add	x28, x28, #0xc6a
			print_formatted(output, "   ");
  4089c0:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4089c4:	d280001a 	mov	x26, #0x0                   	// #0
  4089c8:	91312000 	add	x0, x0, #0xc48
  4089cc:	f90037e0 	str	x0, [sp, #104]
		if (i < length) {
  4089d0:	b9407be0 	ldr	w0, [sp, #120]
  4089d4:	2a1a03fb 	mov	w27, w26
  4089d8:	6b1a001f 	cmp	w0, w26
  4089dc:	54000969 	b.ls	408b08 <log_output_process+0x420>  // b.plast
			print_formatted(output, "%02x ", data[i]);
  4089e0:	387a6ae2 	ldrb	w2, [x23, x26]
  4089e4:	aa1c03e1 	mov	x1, x28
  4089e8:	aa1303e0 	mov	x0, x19
  4089ec:	97ffff05 	bl	408600 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  4089f0:	f1003f5f 	cmp	x26, #0xf
  4089f4:	540007a1 	b.ne	408ae8 <log_output_process+0x400>  // b.any
			print_formatted(output, "%c",
  4089f8:	9000007b 	adrp	x27, 414000 <dlc_table.0+0x78d>
  4089fc:	91313b7b 	add	x27, x27, #0xc4e
	print_formatted(output, "|");
  408a00:	d280001c 	mov	x28, #0x0                   	// #0
  408a04:	528005da 	mov	w26, #0x2e                  	// #46
  408a08:	aa1303e0 	mov	x0, x19
  408a0c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408a10:	91313021 	add	x1, x1, #0xc4c
  408a14:	97fffefb 	bl	408600 <print_formatted>
		if (i < length) {
  408a18:	b9407be0 	ldr	w0, [sp, #120]
  408a1c:	b9006bfc 	str	w28, [sp, #104]
  408a20:	6b1c001f 	cmp	w0, w28
  408a24:	540008c9 	b.ls	408b3c <log_output_process+0x454>  // b.plast
			unsigned char c = (unsigned char)data[i];
  408a28:	387c6ae2 	ldrb	w2, [x23, x28]
  408a2c:	b9007fe2 	str	w2, [sp, #124]
			      isprint((int)c) != 0 ? c : '.');
  408a30:	97ffe260 	bl	4013b0 <__ctype_b_loc@plt>
  408a34:	b9407fe2 	ldr	w2, [sp, #124]
  408a38:	f9400000 	ldr	x0, [x0]
  408a3c:	d37f1c41 	ubfiz	x1, x2, #1, #8
			print_formatted(output, "%c",
  408a40:	78616800 	ldrh	w0, [x0, x1]
  408a44:	aa1b03e1 	mov	x1, x27
  408a48:	f272001f 	tst	x0, #0x4000
  408a4c:	aa1303e0 	mov	x0, x19
  408a50:	1a9a1042 	csel	w2, w2, w26, ne  // ne = any
  408a54:	97fffeeb 	bl	408600 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  408a58:	f1003f9f 	cmp	x28, #0xf
  408a5c:	540005e1 	b.ne	408b18 <log_output_process+0x430>  // b.any
		data += length;
  408a60:	f94033e0 	ldr	x0, [sp, #96]
  408a64:	8b0002f7 	add	x23, x23, x0
	} while (len);
  408a68:	b9407be0 	ldr	w0, [sp, #120]
  408a6c:	6b0002b5 	subs	w21, w21, w0
  408a70:	54fff861 	b.ne	40897c <log_output_process+0x294>  // b.any
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
	}

	if (!raw_string) {
  408a74:	340001d9 	cbz	w25, 408aac <log_output_process+0x3c4>
	if (color) {
  408a78:	360000f6 	tbz	w22, #0, 408a94 <log_output_process+0x3ac>
		print_formatted(output, "%s", log_color);
  408a7c:	90000062 	adrp	x2, 414000 <dlc_table.0+0x78d>
  408a80:	b0000061 	adrp	x1, 415000 <random_data+0xca4>
  408a84:	912f1042 	add	x2, x2, #0xbc4
  408a88:	91165c21 	add	x1, x1, #0x597
  408a8c:	aa1303e0 	mov	x0, x19
  408a90:	97fffedc 	bl	408600 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  408a94:	372000d6 	tbnz	w22, #4, 408aac <log_output_process+0x3c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  408a98:	362805b6 	tbz	w22, #5, 408b4c <log_output_process+0x464>
		print_formatted(ctx, "\n");
  408a9c:	b0000061 	adrp	x1, 415000 <random_data+0xca4>
  408aa0:	9135a821 	add	x1, x1, #0xd6a
		print_formatted(ctx, "\r\n");
  408aa4:	aa1303e0 	mov	x0, x19
  408aa8:	97fffed6 	bl	408600 <print_formatted>
		postfix_print(output, flags, level);
	}

	log_output_flush(output);
  408aac:	aa1303e0 	mov	x0, x19
}
  408ab0:	a94153f3 	ldp	x19, x20, [sp, #16]
  408ab4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408ab8:	a94363f7 	ldp	x23, x24, [sp, #48]
  408abc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  408ac0:	a94573fb 	ldp	x27, x28, [sp, #80]
  408ac4:	a8c87bfd 	ldp	x29, x30, [sp], #128
	log_output_flush(output);
  408ac8:	17fffefb 	b	4086b4 <log_output_flush>
		print_formatted(ctx, "\r\n");
  408acc:	f9403be1 	ldr	x1, [sp, #112]
  408ad0:	17ffffb5 	b	4089a4 <log_output_process+0x2bc>
		print_formatted(output, " ");
  408ad4:	aa1803e1 	mov	x1, x24
  408ad8:	aa1303e0 	mov	x0, x19
	for (int i = 0; i < prefix_offset; i++) {
  408adc:	1100077b 	add	w27, w27, #0x1
		print_formatted(output, " ");
  408ae0:	97fffec8 	bl	408600 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
  408ae4:	17ffffb3 	b	4089b0 <log_output_process+0x2c8>
		if (i > 0 && !(i % 8)) {
  408ae8:	1100077b 	add	w27, w27, #0x1
  408aec:	f2400b7f 	tst	x27, #0x7
  408af0:	54000081 	b.ne	408b00 <log_output_process+0x418>  // b.any
			print_formatted(output, " ");
  408af4:	aa1803e1 	mov	x1, x24
  408af8:	aa1303e0 	mov	x0, x19
  408afc:	97fffec1 	bl	408600 <print_formatted>
  408b00:	9100075a 	add	x26, x26, #0x1
  408b04:	17ffffb3 	b	4089d0 <log_output_process+0x2e8>
			print_formatted(output, "   ");
  408b08:	f94037e1 	ldr	x1, [sp, #104]
  408b0c:	aa1303e0 	mov	x0, x19
  408b10:	97fffebc 	bl	408600 <print_formatted>
  408b14:	17ffffb7 	b	4089f0 <log_output_process+0x308>
		if (i > 0 && !(i % 8)) {
  408b18:	b9406be0 	ldr	w0, [sp, #104]
  408b1c:	11000400 	add	w0, w0, #0x1
  408b20:	f240081f 	tst	x0, #0x7
  408b24:	54000081 	b.ne	408b34 <log_output_process+0x44c>  // b.any
			print_formatted(output, " ");
  408b28:	aa1803e1 	mov	x1, x24
  408b2c:	aa1303e0 	mov	x0, x19
  408b30:	97fffeb4 	bl	408600 <print_formatted>
  408b34:	9100079c 	add	x28, x28, #0x1
  408b38:	17ffffb8 	b	408a18 <log_output_process+0x330>
			print_formatted(output, " ");
  408b3c:	aa1803e1 	mov	x1, x24
  408b40:	aa1303e0 	mov	x0, x19
  408b44:	97fffeaf 	bl	408600 <print_formatted>
  408b48:	17ffffc4 	b	408a58 <log_output_process+0x370>
		print_formatted(ctx, "\r\n");
  408b4c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408b50:	91311421 	add	x1, x1, #0xc45
  408b54:	17ffffd4 	b	408aa4 <log_output_process+0x3bc>

0000000000408b58 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg, uint32_t flags)
{
  408b58:	d10143ff 	sub	sp, sp, #0x50
  408b5c:	a9017bfd 	stp	x29, x30, [sp, #16]
  408b60:	910043fd 	add	x29, sp, #0x10
  408b64:	a90253f3 	stp	x19, x20, [sp, #32]
  408b68:	aa0003f4 	mov	x20, x0
  408b6c:	aa0103f3 	mov	x19, x1
  408b70:	a9035bf5 	stp	x21, x22, [sp, #48]
  408b74:	2a0203f5 	mov	w21, w2
  408b78:	f90023f7 	str	x23, [sp, #64]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg_get_source(struct log_msg *msg)
{
	return msg->hdr.source;
  408b7c:	a9400c20 	ldp	x0, x3, [x1]
 *
 * @return Timestamp.
 */
static inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)
{
	return msg->hdr.timestamp;
  408b80:	b9400436 	ldr	w22, [x1, #4]
	return msg->hdr.desc.level;
  408b84:	d3462017 	ubfx	x23, x0, #6, #3
		/* Remote domain is converting source pointer to ID */
		source_id = (int16_t)(uintptr_t)log_msg_get_source(msg);
	} else {
		void *source = (void *)log_msg_get_source(msg);

		if (source != NULL) {
  408b88:	b4000143 	cbz	x3, 408bb0 <log_output_msg_process+0x58>
  408b8c:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  408b90:	f9472821 	ldr	x1, [x1, #3664]
  408b94:	cb010063 	sub	x3, x3, x1
  408b98:	d344fc63 	lsr	x3, x3, #4
			source_id = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
  408b9c:	13003c61 	sxth	w1, w3
		} else {
			source_id = -1;
		}
	}

	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  408ba0:	377802c3 	tbnz	w3, #15, 408bf8 <log_output_msg_process+0xa0>
  408ba4:	53031400 	ubfx	w0, w0, #3, #3
  408ba8:	97fffd8d 	bl	4081dc <log_source_name_get>
  408bac:	aa0003e3 	mov	x3, x0
 *
 * @return pointer to the package.
 */
static inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;
  408bb0:	f8410667 	ldr	x7, [x19], #16
	size_t plen, dlen;
	uint8_t *package = log_msg_get_package(msg, &plen);
	uint8_t *data = log_msg_get_data(msg, &dlen);

	log_output_process(output, timestamp, NULL, sname, level,
  408bb4:	b90003f5 	str	w21, [sp]
  408bb8:	2a1703e4 	mov	w4, w23
  408bbc:	2a1603e1 	mov	w1, w22
  408bc0:	d2800002 	mov	x2, #0x0                   	// #0
  408bc4:	d3494ce0 	ubfx	x0, x7, #9, #11
  408bc8:	53147ce7 	lsr	w7, w7, #20
  408bcc:	f100001f 	cmp	x0, #0x0
	return msg->data + msg->hdr.desc.package_len;
  408bd0:	8b000266 	add	x6, x19, x0
  408bd4:	9a9f1265 	csel	x5, x19, xzr, ne  // ne = any
  408bd8:	aa1403e0 	mov	x0, x20
  408bdc:	97fffec3 	bl	4086e8 <log_output_process>
			   plen > 0 ? package : NULL, data, dlen, flags);
}
  408be0:	a9417bfd 	ldp	x29, x30, [sp, #16]
  408be4:	a94253f3 	ldp	x19, x20, [sp, #32]
  408be8:	a9435bf5 	ldp	x21, x22, [sp, #48]
  408bec:	f94023f7 	ldr	x23, [sp, #64]
  408bf0:	910143ff 	add	sp, sp, #0x50
  408bf4:	d65f03c0 	ret
	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  408bf8:	d2800003 	mov	x3, #0x0                   	// #0
  408bfc:	17ffffed 	b	408bb0 <log_output_msg_process+0x58>

0000000000408c00 <log_output_timestamp_freq_set>:
		     output->control_block->ctx);
}

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
  408c00:	b0000122 	adrp	x2, 42d000 <args_struct>
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  408c04:	52884804 	mov	w4, #0x4240                	// #16960
	timestamp_div = 1U;
  408c08:	52800021 	mov	w1, #0x1                   	// #1
	while (frequency > 1000000) {
  408c0c:	52800003 	mov	w3, #0x0                   	// #0
	timestamp_div = 1U;
  408c10:	b90bc041 	str	w1, [x2, #3008]
	while (frequency > 1000000) {
  408c14:	72a001e4 	movk	w4, #0xf, lsl #16
  408c18:	6b04001f 	cmp	w0, w4
  408c1c:	540000c8 	b.hi	408c34 <log_output_timestamp_freq_set+0x34>  // b.pmore
  408c20:	34000043 	cbz	w3, 408c28 <log_output_timestamp_freq_set+0x28>
  408c24:	b90bc041 	str	w1, [x2, #3008]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
  408c28:	b0000121 	adrp	x1, 42d000 <args_struct>
  408c2c:	b90bbc20 	str	w0, [x1, #3004]
}
  408c30:	d65f03c0 	ret
		frequency /= 2U;
  408c34:	53017c00 	lsr	w0, w0, #1
		timestamp_div *= 2U;
  408c38:	531f7821 	lsl	w1, w1, #1
  408c3c:	52800023 	mov	w3, #0x1                   	// #1
  408c40:	17fffff6 	b	408c18 <log_output_timestamp_freq_set+0x18>

0000000000408c44 <format_set>:
	log_output_func(&log_output_posix, &msg->log, flags);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
	log_format_current = log_type;
  408c44:	b0000120 	adrp	x0, 42d000 <args_struct>
  408c48:	b90bc401 	str	w1, [x0, #3012]
	return 0;
}
  408c4c:	52800000 	mov	w0, #0x0                   	// #0
  408c50:	d65f03c0 	ret

0000000000408c54 <panic>:
	log_output_flush(&log_output_posix);
  408c54:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  408c58:	9120e000 	add	x0, x0, #0x838
  408c5c:	17fffe96 	b	4086b4 <log_output_flush>

0000000000408c60 <char_out>:
{
  408c60:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  408c64:	910003fd 	mov	x29, sp
  408c68:	a90153f3 	stp	x19, x20, [sp, #16]
  408c6c:	b0000134 	adrp	x20, 42d000 <args_struct>
  408c70:	aa0003f3 	mov	x19, x0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  408c74:	912f2294 	add	x20, x20, #0xbc8
{
  408c78:	a9025bf5 	stp	x21, x22, [sp, #32]
		posix_print_trace("%s\n", stdout_buff);
  408c7c:	b0000135 	adrp	x21, 42d000 <args_struct>
{
  408c80:	aa0103f6 	mov	x22, x1
		posix_print_trace("%s\n", stdout_buff);
  408c84:	913bb6b5 	add	x21, x21, #0xeed
{
  408c88:	a90363f7 	stp	x23, x24, [sp, #48]
  408c8c:	8b010017 	add	x23, x0, x1
		posix_print_trace("%s\n", stdout_buff);
  408c90:	b0000078 	adrp	x24, 415000 <random_data+0xca4>
	for (size_t i = 0; i < length; i++) {
  408c94:	eb17027f 	cmp	x19, x23
  408c98:	540000e1 	b.ne	408cb4 <char_out+0x54>  // b.any
}
  408c9c:	2a1603e0 	mov	w0, w22
  408ca0:	a94153f3 	ldp	x19, x20, [sp, #16]
  408ca4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408ca8:	a94363f7 	ldp	x23, x24, [sp, #48]
  408cac:	a8c47bfd 	ldp	x29, x30, [sp], #64
  408cb0:	d65f03c0 	ret
		preprint_char(data[i]);
  408cb4:	39400260 	ldrb	w0, [x19]
	if (c == '\r') {
  408cb8:	7100341f 	cmp	w0, #0xd
  408cbc:	54000240 	b.eq	408d04 <char_out+0xa4>  // b.none
	if (c != '\n') {
  408cc0:	7100281f 	cmp	w0, #0xa
  408cc4:	54000240 	b.eq	408d0c <char_out+0xac>  // b.none
		stdout_buff[n_pend++] = c;
  408cc8:	b9400282 	ldr	w2, [x20]
  408ccc:	11000441 	add	w1, w2, #0x1
  408cd0:	b9000281 	str	w1, [x20]
  408cd4:	3822caa0 	strb	w0, [x21, w2, sxtw]
	int printnow = 0;
  408cd8:	52800000 	mov	w0, #0x0                   	// #0
		stdout_buff[n_pend] = 0;
  408cdc:	3821cabf 	strb	wzr, [x21, w1, sxtw]
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  408ce0:	b9400281 	ldr	w1, [x20]
  408ce4:	7103f83f 	cmp	w1, #0xfe
  408ce8:	5400004c 	b.gt	408cf0 <char_out+0x90>
	if (printnow) {
  408cec:	340000c0 	cbz	w0, 408d04 <char_out+0xa4>
		posix_print_trace("%s\n", stdout_buff);
  408cf0:	aa1503e1 	mov	x1, x21
  408cf4:	91269f00 	add	x0, x24, #0x9a7
  408cf8:	94000628 	bl	40a598 <posix_print_trace>
		stdout_buff[0] = 0;
  408cfc:	390002bf 	strb	wzr, [x21]
		n_pend = 0;
  408d00:	b900029f 	str	wzr, [x20]
	for (size_t i = 0; i < length; i++) {
  408d04:	91000673 	add	x19, x19, #0x1
  408d08:	17ffffe3 	b	408c94 <char_out+0x34>
		printnow = 1;
  408d0c:	52800020 	mov	w0, #0x1                   	// #1
  408d10:	17fffff4 	b	408ce0 <char_out+0x80>

0000000000408d14 <process>:
{
  408d14:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408d18:	b0000120 	adrp	x0, 42d000 <args_struct>
{
  408d1c:	910003fd 	mov	x29, sp
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408d20:	b94bc400 	ldr	w0, [x0, #3012]
{
  408d24:	f9000bf3 	str	x19, [sp, #16]
  408d28:	aa0103f3 	mov	x19, x1
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408d2c:	97fffc5c 	bl	407e9c <log_format_func_t_get>
  408d30:	aa0003f0 	mov	x16, x0
	log_output_func(&log_output_posix, &msg->log, flags);
  408d34:	aa1303e1 	mov	x1, x19
  408d38:	528001e2 	mov	w2, #0xf                   	// #15
}
  408d3c:	f9400bf3 	ldr	x19, [sp, #16]
	log_output_func(&log_output_posix, &msg->log, flags);
  408d40:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
}
  408d44:	a8c27bfd 	ldp	x29, x30, [sp], #32
	log_output_func(&log_output_posix, &msg->log, flags);
  408d48:	9120e000 	add	x0, x0, #0x838
  408d4c:	d61f0200 	br	x16

0000000000408d50 <sys_trace_isr_enter>:
 *
 * SPDX-License-Identifier: Apache-2.0
 */


void sys_trace_isr_enter(void) {}
  408d50:	d65f03c0 	ret

0000000000408d54 <sys_trace_isr_exit>:
  408d54:	d65f03c0 	ret

0000000000408d58 <sys_trace_idle>:
  408d58:	d65f03c0 	ret

0000000000408d5c <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
  408d5c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  408d60:	910003fd 	mov	x29, sp
	sys_trace_idle();
  408d64:	97fffffd 	bl	408d58 <sys_trace_idle>
	posix_irq_full_unlock();
  408d68:	94000493 	bl	409fb4 <posix_irq_full_unlock>
	posix_halt_cpu();
}
  408d6c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_halt_cpu();
  408d70:	140001d9 	b	4094d4 <posix_halt_cpu>

0000000000408d74 <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
  408d74:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
  408d78:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408d7c:	91322800 	add	x0, x0, #0xc8a
{
  408d80:	910003fd 	mov	x29, sp
	posix_print_error_and_exit("Exiting due to fatal error\n");
  408d84:	9400059f 	bl	40a400 <posix_print_error_and_exit>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  408d88:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408d8c:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408d90:	91329821 	add	x1, x1, #0xca6
  408d94:	911f2000 	add	x0, x0, #0x7c8
  408d98:	528002a2 	mov	w2, #0x15                  	// #21
  408d9c:	94000599 	bl	40a400 <posix_print_error_and_exit>

0000000000408da0 <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
  408da0:	14000487 	b	409fbc <posix_irq_enable>

0000000000408da4 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
  408da4:	34000080 	cbz	w0, 408db4 <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  408da8:	90000060 	adrp	x0, 414000 <dlc_table.0+0x78d>
  408dac:	91334400 	add	x0, x0, #0xcd1
  408db0:	14000594 	b	40a400 <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
  408db4:	d65f03c0 	ret

0000000000408db8 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
  408db8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408dbc:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408dc0:	912f8000 	add	x0, x0, #0xbe0
{
  408dc4:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408dc8:	97ffe1b6 	bl	4014a0 <pthread_mutex_unlock@plt>
  408dcc:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408dd0:	9133ac21 	add	x1, x1, #0xceb
  408dd4:	97fffff4 	bl	408da4 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  408dd8:	97ffe1a6 	bl	401470 <pthread_self@plt>
}
  408ddc:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  408de0:	17ffe178 	b	4013c0 <pthread_detach@plt>

0000000000408de4 <abort_tail>:
{
  408de4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	threads_table[this_th_nbr].running = false;
  408de8:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408dec:	937b7c00 	sbfiz	x0, x0, #5, #32
{
  408df0:	910003fd 	mov	x29, sp
	threads_table[this_th_nbr].running = false;
  408df4:	f9460821 	ldr	x1, [x1, #3088]
  408df8:	8b000022 	add	x2, x1, x0
  408dfc:	3900105f 	strb	wzr, [x2, #4]
	threads_table[this_th_nbr].state = ABORTED;
  408e00:	52800062 	mov	w2, #0x3                   	// #3
  408e04:	b8206822 	str	w2, [x1, x0]
	posix_preexit_cleanup();
  408e08:	97ffffec 	bl	408db8 <posix_preexit_cleanup>
	pthread_exit(NULL);
  408e0c:	d2800000 	mov	x0, #0x0                   	// #0
  408e10:	97ffe158 	bl	401370 <pthread_exit@plt>

0000000000408e14 <posix_wait_until_allowed>:
{
  408e14:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  408e18:	910003fd 	mov	x29, sp
  408e1c:	a9025bf5 	stp	x21, x22, [sp, #32]
	threads_table[this_th_nbr].running = false;
  408e20:	90000135 	adrp	x21, 42c000 <__dso_handle>
	while (this_th_nbr != currently_allowed_thread) {
  408e24:	b0000136 	adrp	x22, 42d000 <args_struct>
{
  408e28:	a90153f3 	stp	x19, x20, [sp, #16]
	threads_table[this_th_nbr].running = false;
  408e2c:	937b7c14 	sbfiz	x20, x0, #5, #32
{
  408e30:	2a0003f3 	mov	w19, w0
	threads_table[this_th_nbr].running = false;
  408e34:	f9460aa0 	ldr	x0, [x21, #3088]
	while (this_th_nbr != currently_allowed_thread) {
  408e38:	912f32d6 	add	x22, x22, #0xbcc
{
  408e3c:	a90363f7 	stp	x23, x24, [sp, #48]
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408e40:	90000137 	adrp	x23, 42c000 <__dso_handle>
	threads_table[this_th_nbr].running = false;
  408e44:	8b140000 	add	x0, x0, x20
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408e48:	90000138 	adrp	x24, 42c000 <__dso_handle>
  408e4c:	912f82f7 	add	x23, x23, #0xbe0
  408e50:	912ec318 	add	x24, x24, #0xbb0
	threads_table[this_th_nbr].running = false;
  408e54:	3900101f 	strb	wzr, [x0, #4]
	while (this_th_nbr != currently_allowed_thread) {
  408e58:	b94002c0 	ldr	w0, [x22]
  408e5c:	6b13001f 	cmp	w0, w19
  408e60:	54000141 	b.ne	408e88 <posix_wait_until_allowed+0x74>  // b.any
	threads_table[this_th_nbr].running = true;
  408e64:	f9460aa0 	ldr	x0, [x21, #3088]
  408e68:	52800021 	mov	w1, #0x1                   	// #1
  408e6c:	8b140000 	add	x0, x0, x20
  408e70:	39001001 	strb	w1, [x0, #4]
}
  408e74:	a94153f3 	ldp	x19, x20, [sp, #16]
  408e78:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408e7c:	a94363f7 	ldp	x23, x24, [sp, #48]
  408e80:	a8c47bfd 	ldp	x29, x30, [sp], #64
  408e84:	d65f03c0 	ret
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408e88:	aa1703e1 	mov	x1, x23
  408e8c:	aa1803e0 	mov	x0, x24
  408e90:	97ffe158 	bl	4013f0 <pthread_cond_wait@plt>
		if (threads_table &&
  408e94:	f9460aa0 	ldr	x0, [x21, #3088]
  408e98:	b4fffe00 	cbz	x0, 408e58 <posix_wait_until_allowed+0x44>
  408e9c:	b8746800 	ldr	w0, [x0, x20]
  408ea0:	7100081f 	cmp	w0, #0x2
  408ea4:	54fffda1 	b.ne	408e58 <posix_wait_until_allowed+0x44>  // b.any
			abort_tail(this_th_nbr);
  408ea8:	2a1303e0 	mov	w0, w19
  408eac:	97ffffce 	bl	408de4 <abort_tail>

0000000000408eb0 <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
  408eb0:	b0000120 	adrp	x0, 42d000 <args_struct>
  408eb4:	397fb400 	ldrb	w0, [x0, #4077]
  408eb8:	34000180 	cbz	w0, 408ee8 <posix_cleanup_handler+0x38>
{
  408ebc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408ec0:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408ec4:	912f8000 	add	x0, x0, #0xbe0
{
  408ec8:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408ecc:	97ffe175 	bl	4014a0 <pthread_mutex_unlock@plt>
  408ed0:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408ed4:	9133ac21 	add	x1, x1, #0xceb
  408ed8:	97ffffb3 	bl	408da4 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  408edc:	97ffe165 	bl	401470 <pthread_self@plt>
}
  408ee0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  408ee4:	17ffe137 	b	4013c0 <pthread_detach@plt>
  408ee8:	d65f03c0 	ret

0000000000408eec <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
  408eec:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  408ef0:	910003fd 	mov	x29, sp
  408ef4:	f9000be0 	str	x0, [sp, #16]
  408ef8:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  408efc:	f9476800 	ldr	x0, [x0, #3792]
  408f00:	f9400001 	ldr	x1, [x0]
  408f04:	f9007fe1 	str	x1, [sp, #248]
  408f08:	d2800001 	mov	x1, #0x0                   	// #0

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  408f0c:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408f10:	912f8000 	add	x0, x0, #0xbe0
  408f14:	97ffe15f 	bl	401490 <pthread_mutex_lock@plt>
  408f18:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408f1c:	91343821 	add	x1, x1, #0xd0e
  408f20:	97ffffa1 	bl	408da4 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
  408f24:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408f28:	f9460800 	ldr	x0, [x0, #3088]
  408f2c:	b50000a0 	cbnz	x0, 408f40 <posix_thread_starter+0x54>
		posix_cleanup_handler(arg);
  408f30:	f9400be0 	ldr	x0, [sp, #16]
  408f34:	97ffffdf 	bl	408eb0 <posix_cleanup_handler>
		pthread_exit(NULL);
  408f38:	d2800000 	mov	x0, #0x0                   	// #0
  408f3c:	97ffe10d 	bl	401370 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
  408f40:	90000000 	adrp	x0, 408000 <z_impl_log_panic+0xac>
  408f44:	913ac000 	add	x0, x0, #0xeb0
  408f48:	52800001 	mov	w1, #0x0                   	// #0
  408f4c:	f9000fe0 	str	x0, [sp, #24]
  408f50:	910083e0 	add	x0, sp, #0x20
  408f54:	97ffe0ab 	bl	401200 <__sigsetjmp@plt>
  408f58:	340000a0 	cbz	w0, 408f6c <posix_thread_starter+0x80>
  408f5c:	a94107e0 	ldp	x0, x1, [sp, #16]
  408f60:	d63f0020 	blr	x1
  408f64:	910083e0 	add	x0, sp, #0x20
  408f68:	97ffe12a 	bl	401410 <__pthread_unwind_next@plt>
  408f6c:	910083e0 	add	x0, sp, #0x20
  408f70:	97ffe13c 	bl	401460 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
  408f74:	b94013e0 	ldr	w0, [sp, #16]
  408f78:	97ffffa7 	bl	408e14 <posix_wait_until_allowed>

	posix_new_thread_pre_start();
  408f7c:	94000108 	bl	40939c <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
  408f80:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408f84:	b94013e0 	ldr	w0, [sp, #16]
  408f88:	f9460821 	ldr	x1, [x1, #3088]
  408f8c:	937b7c00 	sbfiz	x0, x0, #5, #32
  408f90:	8b000020 	add	x0, x1, x0
  408f94:	f9400c00 	ldr	x0, [x0, #24]

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
  408f98:	a9410c02 	ldp	x2, x3, [x0, #16]
  408f9c:	f9400401 	ldr	x1, [x0, #8]
  408fa0:	f9400000 	ldr	x0, [x0]
  408fa4:	97fff568 	bl	406544 <z_thread_entry>

0000000000408fa8 <posix_swap>:
{
  408fa8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408fac:	910003fd 	mov	x29, sp
  408fb0:	f9000bf3 	str	x19, [sp, #16]
  408fb4:	2a0103f3 	mov	w19, w1
	currently_allowed_thread = next_allowed_th;
  408fb8:	b0000121 	adrp	x1, 42d000 <args_struct>
  408fbc:	b90bcc20 	str	w0, [x1, #3020]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  408fc0:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408fc4:	912ec000 	add	x0, x0, #0xbb0
  408fc8:	97ffe0c6 	bl	4012e0 <pthread_cond_broadcast@plt>
  408fcc:	90000061 	adrp	x1, 414000 <dlc_table.0+0x78d>
  408fd0:	9134bc21 	add	x1, x1, #0xd2f
  408fd4:	97ffff74 	bl	408da4 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
  408fd8:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408fdc:	937b7e60 	sbfiz	x0, x19, #5, #32
  408fe0:	f9460821 	ldr	x1, [x1, #3088]
  408fe4:	b8606820 	ldr	w0, [x1, x0]
  408fe8:	7100081f 	cmp	w0, #0x2
		abort_tail(this_th_nbr);
  408fec:	2a1303e0 	mov	w0, w19
	if (threads_table[this_th_nbr].state == ABORTING) {
  408ff0:	54000041 	b.ne	408ff8 <posix_swap+0x50>  // b.any
		abort_tail(this_th_nbr);
  408ff4:	97ffff7c 	bl	408de4 <abort_tail>
}
  408ff8:	f9400bf3 	ldr	x19, [sp, #16]
  408ffc:	a8c27bfd 	ldp	x29, x30, [sp], #32
		posix_wait_until_allowed(this_th_nbr);
  409000:	17ffff85 	b	408e14 <posix_wait_until_allowed>

0000000000409004 <posix_main_thread_start>:
{
  409004:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	currently_allowed_thread = next_allowed_th;
  409008:	90000121 	adrp	x1, 42d000 <args_struct>
{
  40900c:	910003fd 	mov	x29, sp
	currently_allowed_thread = next_allowed_th;
  409010:	b90bcc20 	str	w0, [x1, #3020]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  409014:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409018:	912ec000 	add	x0, x0, #0xbb0
  40901c:	97ffe0b1 	bl	4012e0 <pthread_cond_broadcast@plt>
  409020:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  409024:	9134bc21 	add	x1, x1, #0xd2f
  409028:	97ffff5f 	bl	408da4 <pc_safe_call>
	posix_preexit_cleanup();
  40902c:	97ffff63 	bl	408db8 <posix_preexit_cleanup>
	pthread_exit(NULL);
  409030:	d2800000 	mov	x0, #0x0                   	// #0
  409034:	97ffe0cf 	bl	401370 <pthread_exit@plt>

0000000000409038 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
  409038:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (int i = 0; i < threads_table_size; i++) {
  40903c:	d2800002 	mov	x2, #0x0                   	// #0
{
  409040:	910003fd 	mov	x29, sp
  409044:	a9025bf5 	stp	x21, x22, [sp, #32]
		if ((threads_table[i].state == NOTUSED)
  409048:	f0000115 	adrp	x21, 42c000 <__dso_handle>
	for (int i = 0; i < threads_table_size; i++) {
  40904c:	90000136 	adrp	x22, 42d000 <args_struct>
{
  409050:	a90153f3 	stp	x19, x20, [sp, #16]
  409054:	aa0003f4 	mov	x20, x0
	for (int i = 0; i < threads_table_size; i++) {
  409058:	b94bd6c1 	ldr	w1, [x22, #3028]
		if ((threads_table[i].state == NOTUSED)
  40905c:	f9460aa0 	ldr	x0, [x21, #3088]
  409060:	d1008003 	sub	x3, x0, #0x20
  409064:	2a0203f3 	mov	w19, w2
	for (int i = 0; i < threads_table_size; i++) {
  409068:	6b02003f 	cmp	w1, w2
  40906c:	5400026c 	b.gt	4090b8 <posix_new_thread+0x80>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
  409070:	11010021 	add	w1, w1, #0x40
	threads_table = realloc(threads_table,
  409074:	937b7c21 	sbfiz	x1, x1, #5, #32
  409078:	97ffe0a2 	bl	401300 <realloc@plt>
  40907c:	f9060aa0 	str	x0, [x21, #3088]
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  409080:	b5000080 	cbnz	x0, 409090 <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  409084:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  409088:	91355400 	add	x0, x0, #0xd55
  40908c:	940004dd 	bl	40a400 <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
  409090:	b94bd6d3 	ldr	w19, [x22, #3028]
  return __builtin___memset_chk (__dest, __ch, __len,
  409094:	d2810002 	mov	x2, #0x800                 	// #2048
  409098:	f9460aa3 	ldr	x3, [x21, #3088]
  40909c:	52800001 	mov	w1, #0x0                   	// #0
  4090a0:	937b7e60 	sbfiz	x0, x19, #5, #32
  4090a4:	8b000060 	add	x0, x3, x0
  4090a8:	97ffe07e 	bl	4012a0 <memset@plt>
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
  4090ac:	11010260 	add	w0, w19, #0x40
  4090b0:	b90bd6c0 	str	w0, [x22, #3028]
	return threads_table_size - PC_ALLOC_CHUNK_SIZE;
  4090b4:	14000005 	b	4090c8 <posix_new_thread+0x90>
		if ((threads_table[i].state == NOTUSED)
  4090b8:	91000442 	add	x2, x2, #0x1
  4090bc:	d37be844 	lsl	x4, x2, #5
  4090c0:	b8646864 	ldr	w4, [x3, x4]
  4090c4:	35fffd04 	cbnz	w4, 409064 <posix_new_thread+0x2c>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
  4090c8:	f9460aa1 	ldr	x1, [x21, #3088]
  4090cc:	937b7e60 	sbfiz	x0, x19, #5, #32
  4090d0:	52800022 	mov	w2, #0x1                   	// #1
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  4090d4:	93407e63 	sxtw	x3, w19
	threads_table[t_slot].state = USED;
  4090d8:	8b000024 	add	x4, x1, x0
  4090dc:	b8206822 	str	w2, [x1, x0]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  4090e0:	90000121 	adrp	x1, 42d000 <args_struct>
  4090e4:	b94bd020 	ldr	w0, [x1, #3024]
	threads_table[t_slot].running = false;
  4090e8:	3900109f 	strb	wzr, [x4, #4]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  4090ec:	b9001080 	str	w0, [x4, #16]
  4090f0:	0b020002 	add	w2, w0, w2
	threads_table[t_slot].t_status = ptr;
  4090f4:	f9000c94 	str	x20, [x4, #24]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  4090f8:	91002080 	add	x0, x4, #0x8
	ptr->thread_idx = t_slot;
  4090fc:	b9002293 	str	w19, [x20, #32]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  409100:	b90bd022 	str	w2, [x1, #3024]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409104:	d2800001 	mov	x1, #0x0                   	// #0
  409108:	f0ffffe2 	adrp	x2, 408000 <z_impl_log_panic+0xac>
  40910c:	913bb042 	add	x2, x2, #0xeec
  409110:	97ffe0c8 	bl	401430 <pthread_create@plt>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
  409114:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409118:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
}
  40911c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409120:	9135f421 	add	x1, x1, #0xd7d
}
  409124:	a8c37bfd 	ldp	x29, x30, [sp], #48
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409128:	17ffff1f 	b	408da4 <pc_safe_call>

000000000040912c <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
  40912c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_create_count = 0;
  409130:	90000120 	adrp	x0, 42d000 <args_struct>

	currently_allowed_thread = -1;
  409134:	12800001 	mov	w1, #0xffffffff            	// #-1
{
  409138:	910003fd 	mov	x29, sp
	thread_create_count = 0;
  40913c:	b90bd01f 	str	wzr, [x0, #3024]
	currently_allowed_thread = -1;
  409140:	90000120 	adrp	x0, 42d000 <args_struct>
  409144:	b90bcc01 	str	w1, [x0, #3020]

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
  409148:	d2800401 	mov	x1, #0x20                  	// #32
  40914c:	d2800800 	mov	x0, #0x40                  	// #64
  409150:	97ffe060 	bl	4012d0 <calloc@plt>
  409154:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409158:	f9060820 	str	x0, [x1, #3088]
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  40915c:	b5000080 	cbnz	x0, 40916c <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  409160:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  409164:	91355400 	add	x0, x0, #0xd55
  409168:	940004a6 	bl	40a400 <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
  40916c:	52800801 	mov	w1, #0x40                  	// #64
  409170:	90000120 	adrp	x0, 42d000 <args_struct>
  409174:	b90bd401 	str	w1, [x0, #3028]


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  409178:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  40917c:	912f8000 	add	x0, x0, #0xbe0
  409180:	97ffe0c4 	bl	401490 <pthread_mutex_lock@plt>
}
  409184:	a8c17bfd 	ldp	x29, x30, [sp], #16
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  409188:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  40918c:	91343821 	add	x1, x1, #0xd0e
  409190:	17ffff05 	b	408da4 <pc_safe_call>

0000000000409194 <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
  409194:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  409198:	910003fd 	mov	x29, sp
  40919c:	a9025bf5 	stp	x21, x22, [sp, #32]

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  4091a0:	f0000115 	adrp	x21, 42c000 <__dso_handle>
  4091a4:	f9460aa0 	ldr	x0, [x21, #3088]
{
  4091a8:	a90153f3 	stp	x19, x20, [sp, #16]
  4091ac:	f9001bf7 	str	x23, [sp, #48]
	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  4091b0:	b4000200 	cbz	x0, 4091f0 <posix_core_clean_up+0x5c>
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;
  4091b4:	90000120 	adrp	x0, 42d000 <args_struct>

	for (int i = 0; i < threads_table_size; i++) {
  4091b8:	90000134 	adrp	x20, 42d000 <args_struct>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
  4091bc:	f0000056 	adrp	x22, 414000 <dlc_table.0+0x78d>
	for (int i = 0; i < threads_table_size; i++) {
  4091c0:	912f5294 	add	x20, x20, #0xbd4
			posix_print_warning(
  4091c4:	913786d6 	add	x22, x22, #0xde1
	terminate = true;
  4091c8:	52800021 	mov	w1, #0x1                   	// #1
	for (int i = 0; i < threads_table_size; i++) {
  4091cc:	d2800013 	mov	x19, #0x0                   	// #0
	terminate = true;
  4091d0:	393fb401 	strb	w1, [x0, #4077]
	for (int i = 0; i < threads_table_size; i++) {
  4091d4:	b9400281 	ldr	w1, [x20]
		if (threads_table[i].state != USED) {
  4091d8:	913042b7 	add	x23, x21, #0xc10
  4091dc:	f9460aa0 	ldr	x0, [x21, #3088]
	for (int i = 0; i < threads_table_size; i++) {
  4091e0:	6b13003f 	cmp	w1, w19
  4091e4:	5400010c 	b.gt	409204 <posix_core_clean_up+0x70>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
  4091e8:	97ffe07e 	bl	4013e0 <free@plt>
	threads_table = NULL;
  4091ec:	f90002ff 	str	xzr, [x23]
}
  4091f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4091f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4091f8:	f9401bf7 	ldr	x23, [sp, #48]
  4091fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  409200:	d65f03c0 	ret
		if (threads_table[i].state != USED) {
  409204:	d37bea61 	lsl	x1, x19, #5
  409208:	8b131402 	add	x2, x0, x19, lsl #5
  40920c:	b8616800 	ldr	w0, [x0, x1]
  409210:	7100041f 	cmp	w0, #0x1
  409214:	540000e1 	b.ne	409230 <posix_core_clean_up+0x9c>  // b.any
		if (pthread_cancel(threads_table[i].thread)) {
  409218:	f9400440 	ldr	x0, [x2, #8]
  40921c:	97ffe099 	bl	401480 <pthread_cancel@plt>
  409220:	34000080 	cbz	w0, 409230 <posix_core_clean_up+0x9c>
			posix_print_warning(
  409224:	2a1303e1 	mov	w1, w19
  409228:	aa1603e0 	mov	x0, x22
  40922c:	940004a9 	bl	40a4d0 <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
  409230:	91000673 	add	x19, x19, #0x1
  409234:	17ffffe8 	b	4091d4 <posix_core_clean_up+0x40>

0000000000409238 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
  409238:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  40923c:	937b7c00 	sbfiz	x0, x0, #5, #32
  409240:	f9460821 	ldr	x1, [x1, #3088]
  409244:	b8606822 	ldr	w2, [x1, x0]
  409248:	7100045f 	cmp	w2, #0x1
  40924c:	54000061 	b.ne	409258 <posix_abort_thread+0x20>  // b.any

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
  409250:	52800042 	mov	w2, #0x2                   	// #2
  409254:	b8206822 	str	w2, [x1, x0]
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
  409258:	d65f03c0 	ret

000000000040925c <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
  40925c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409260:	910003fd 	mov	x29, sp
  409264:	a90153f3 	stp	x19, x20, [sp, #16]
  409268:	aa0003f4 	mov	x20, x0
  40926c:	a9025bf5 	stp	x21, x22, [sp, #32]
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
  409270:	f9402813 	ldr	x19, [x0, #80]
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
  409274:	b9402276 	ldr	w22, [x19, #32]
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
  409278:	9400034c 	bl	409fa8 <posix_irq_lock>
  40927c:	2a0003f5 	mov	w21, w0

	key = irq_lock();

	if (_current == thread) {
  409280:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409284:	f9472c00 	ldr	x0, [x0, #3672]
  409288:	f9400800 	ldr	x0, [x0, #16]
  40928c:	eb14001f 	cmp	x0, x20
  409290:	54000141 	b.ne	4092b8 <z_impl_k_thread_abort+0x5c>  // b.any
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
  409294:	b9402660 	ldr	w0, [x19, #36]
  409298:	350002a0 	cbnz	w0, 4092ec <z_impl_k_thread_abort+0x90>
			tstatus->aborted = 1;
  40929c:	52800020 	mov	w0, #0x1                   	// #1
  4092a0:	b9002660 	str	w0, [x19, #36]
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
  4092a4:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  4092a8:	937b7ec0 	sbfiz	x0, x22, #5, #32
  4092ac:	52800042 	mov	w2, #0x2                   	// #2
  4092b0:	f9460821 	ldr	x1, [x1, #3088]
  4092b4:	b8206822 	str	w2, [x1, x0]
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
  4092b8:	aa1403e0 	mov	x0, x20
  4092bc:	940023d9 	bl	412220 <z_thread_abort>

	if (tstatus->aborted == 0) {
  4092c0:	b9402660 	ldr	w0, [x19, #36]
  4092c4:	350000a0 	cbnz	w0, 4092d8 <z_impl_k_thread_abort+0x7c>
		PC_DEBUG("%s aborting now [%i] %i\n",
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
  4092c8:	52800020 	mov	w0, #0x1                   	// #1
  4092cc:	b9002660 	str	w0, [x19, #36]
		posix_abort_thread(thread_idx);
  4092d0:	2a1603e0 	mov	w0, w22
  4092d4:	97ffffd9 	bl	409238 <posix_abort_thread>
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
  4092d8:	2a1503e0 	mov	w0, w21
}
  4092dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4092e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4092e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule_irqlock(key);
  4092e8:	14001cc0 	b	4105e8 <z_reschedule_irqlock>
			posix_print_warning(/* LCOV_EXCL_LINE */
  4092ec:	2a1603e1 	mov	w1, w22
  4092f0:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4092f4:	91385400 	add	x0, x0, #0xe15
  4092f8:	94000476 	bl	40a4d0 <posix_print_warning>
  4092fc:	17ffffea 	b	4092a4 <z_impl_k_thread_abort+0x48>

0000000000409300 <arch_swap>:
#include <zephyr/irq.h>
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
  409300:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409304:	910003fd 	mov	x29, sp
  409308:	f9000bf3 	str	x19, [sp, #16]
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
  40930c:	d0000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  409310:	f9472e73 	ldr	x19, [x19, #3672]
  409314:	f9400a61 	ldr	x1, [x19, #16]
  409318:	b9004820 	str	w0, [x1, #72]
	_current->callee_saved.retval = -EAGAIN;
  40931c:	12800140 	mov	w0, #0xfffffff5            	// #-11
  409320:	b9004c20 	str	w0, [x1, #76]
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
  409324:	f9401660 	ldr	x0, [x19, #40]
	posix_thread_status_t *this_thread_ptr  =
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
  409328:	f9000a60 	str	x0, [x19, #16]
	posix_thread_status_t *this_thread_ptr  =
  40932c:	f9402821 	ldr	x1, [x1, #80]
	posix_thread_status_t *ready_thread_ptr =
  409330:	f9402802 	ldr	x2, [x0, #80]
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
  409334:	b9402021 	ldr	w1, [x1, #32]
  409338:	b9402040 	ldr	w0, [x2, #32]
  40933c:	97ffff1b 	bl	408fa8 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
  409340:	f9400a60 	ldr	x0, [x19, #16]
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
  409344:	b9404800 	ldr	w0, [x0, #72]
  409348:	9400031a 	bl	409fb0 <posix_irq_unlock>

	return _current->callee_saved.retval;
  40934c:	f9400a60 	ldr	x0, [x19, #16]
}
  409350:	f9400bf3 	ldr	x19, [sp, #16]
  409354:	b9404c00 	ldr	w0, [x0, #76]
  409358:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40935c:	d65f03c0 	ret

0000000000409360 <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
  409360:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409364:	f9472c00 	ldr	x0, [x0, #3672]
  409368:	f9401401 	ldr	x1, [x0, #40]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
  40936c:	f9000801 	str	x1, [x0, #16]
	posix_thread_status_t *ready_thread_ptr =
  409370:	f9402822 	ldr	x2, [x1, #80]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
  409374:	b9402040 	ldr	w0, [x2, #32]
  409378:	17ffff23 	b	409004 <posix_main_thread_start>

000000000040937c <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
  40937c:	aa0003e1 	mov	x1, x0
	posix_thread_status_t *thread_status;

	/* We store it in the same place where normal archs store the
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
  409380:	d100a040 	sub	x0, x2, #0x28

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
  409384:	f81d8043 	stur	x3, [x2, #-40]
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
  409388:	a9009404 	stp	x4, x5, [x0, #8]
	thread_status->arg3 = p3;
  40938c:	f9000c06 	str	x6, [x0, #24]
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
  409390:	b900241f 	str	wzr, [x0, #36]
#endif

	thread->callee_saved.thread_status = thread_status;
  409394:	f9002820 	str	x0, [x1, #80]

	posix_new_thread(thread_status);
  409398:	17ffff28 	b	409038 <posix_new_thread>

000000000040939c <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
  40939c:	14000306 	b	409fb4 <posix_irq_full_unlock>

00000000004093a0 <pc_safe_call>:
	if (unlikely(test)) {
  4093a0:	34000080 	cbz	w0, 4093b0 <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  4093a4:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4093a8:	91334400 	add	x0, x0, #0xcd1
  4093ac:	14000415 	b	40a400 <posix_print_error_and_exit>
}
  4093b0:	d65f03c0 	ret

00000000004093b4 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
  4093b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4093b8:	910003fd 	mov	x29, sp
  4093bc:	f9000bf3 	str	x19, [sp, #16]
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4093c0:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  4093c4:	91312273 	add	x19, x19, #0xc48
  4093c8:	aa1303e0 	mov	x0, x19
  4093cc:	97ffe031 	bl	401490 <pthread_mutex_lock@plt>
  4093d0:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  4093d4:	913a4421 	add	x1, x1, #0xe91
  4093d8:	97fffff2 	bl	4093a0 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  4093dc:	aa1303e0 	mov	x0, x19
  4093e0:	97ffe030 	bl	4014a0 <pthread_mutex_unlock@plt>
  4093e4:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  4093e8:	913ab821 	add	x1, x1, #0xeae
  4093ec:	97ffffed 	bl	4093a0 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
  4093f0:	97ffff4f 	bl	40912c <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
  4093f4:	94001168 	bl	40d994 <z_cstart>

00000000004093f8 <posix_is_cpu_running>:
	return !cpu_halted;
  4093f8:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  4093fc:	39504000 	ldrb	w0, [x0, #1040]
}
  409400:	52000000 	eor	w0, w0, #0x1
  409404:	d65f03c0 	ret

0000000000409408 <posix_change_cpu_state_and_wait>:
{
  409408:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40940c:	910003fd 	mov	x29, sp
  409410:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409414:	f0000115 	adrp	x21, 42c000 <__dso_handle>
{
  409418:	12001c16 	and	w22, w0, #0xff
  40941c:	f9001bf7 	str	x23, [sp, #48]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409420:	913122b7 	add	x23, x21, #0xc48
  409424:	aa1703e0 	mov	x0, x23
{
  409428:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  40942c:	97ffe019 	bl	401490 <pthread_mutex_lock@plt>
	cpu_halted = halted;
  409430:	f0000113 	adrp	x19, 42c000 <__dso_handle>
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409434:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  409438:	913a4421 	add	x1, x1, #0xe91
  40943c:	97ffffd9 	bl	4093a0 <pc_safe_call>
	cpu_halted = halted;
  409440:	39104276 	strb	w22, [x19, #1040]
	while (cpu_halted == halted) {
  409444:	91104273 	add	x19, x19, #0x410
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  409448:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  40944c:	91306294 	add	x20, x20, #0xc18
  409450:	aa1403e0 	mov	x0, x20
  409454:	97ffdfa3 	bl	4012e0 <pthread_cond_broadcast@plt>
  409458:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  40945c:	913b3421 	add	x1, x1, #0xecd
  409460:	97ffffd0 	bl	4093a0 <pc_safe_call>
	while (cpu_halted == halted) {
  409464:	39400260 	ldrb	w0, [x19]
  409468:	6b16001f 	cmp	w0, w22
  40946c:	54000140 	b.eq	409494 <posix_change_cpu_state_and_wait+0x8c>  // b.none
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409470:	913122a0 	add	x0, x21, #0xc48
  409474:	97ffe00b 	bl	4014a0 <pthread_mutex_unlock@plt>
}
  409478:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  40947c:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
}
  409480:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409484:	913ab821 	add	x1, x1, #0xeae
}
  409488:	f9401bf7 	ldr	x23, [sp, #48]
  40948c:	a8c47bfd 	ldp	x29, x30, [sp], #64
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409490:	17ffffc4 	b	4093a0 <pc_safe_call>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  409494:	aa1703e1 	mov	x1, x23
  409498:	aa1403e0 	mov	x0, x20
  40949c:	97ffdfd5 	bl	4013f0 <pthread_cond_wait@plt>
  4094a0:	17fffff1 	b	409464 <posix_change_cpu_state_and_wait+0x5c>

00000000004094a4 <posix_interrupt_raised>:
{
  4094a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(false);
  4094a8:	52800000 	mov	w0, #0x0                   	// #0
{
  4094ac:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(false);
  4094b0:	97ffffd6 	bl	409408 <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
  4094b4:	90000120 	adrp	x0, 42d000 <args_struct>
  4094b8:	397fb800 	ldrb	w0, [x0, #4078]
  4094bc:	34000080 	cbz	w0, 4094cc <posix_interrupt_raised+0x28>
}
  4094c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_exit(0);
  4094c4:	52800000 	mov	w0, #0x0                   	// #0
  4094c8:	14000378 	b	40a2a8 <posix_exit>
}
  4094cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4094d0:	d65f03c0 	ret

00000000004094d4 <posix_halt_cpu>:
{
  4094d4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(true);
  4094d8:	52800020 	mov	w0, #0x1                   	// #1
{
  4094dc:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(true);
  4094e0:	97ffffca 	bl	409408 <posix_change_cpu_state_and_wait>
}
  4094e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_irq_handler();
  4094e8:	14000245 	b	409dfc <posix_irq_handler>

00000000004094ec <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
  4094ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4094f0:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4094f4:	910003fd 	mov	x29, sp
  4094f8:	f9476800 	ldr	x0, [x0, #3792]
  4094fc:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));

	cpu_halted = false;
  409500:	f0000113 	adrp	x19, 42c000 <__dso_handle>
{
  409504:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409508:	f0000115 	adrp	x21, 42c000 <__dso_handle>
  40950c:	913122b6 	add	x22, x21, #0xc48
{
  409510:	f9400001 	ldr	x1, [x0]
  409514:	f9001fe1 	str	x1, [sp, #56]
  409518:	d2800001 	mov	x1, #0x0                   	// #0
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  40951c:	aa1603e0 	mov	x0, x22
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  409520:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  409524:	91306294 	add	x20, x20, #0xc18
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409528:	97ffdfda 	bl	401490 <pthread_mutex_lock@plt>
  40952c:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  409530:	913a4421 	add	x1, x1, #0xe91
  409534:	97ffff9b 	bl	4093a0 <pc_safe_call>
	cpu_halted = false;
  409538:	3910427f 	strb	wzr, [x19, #1040]
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  40953c:	90000002 	adrp	x2, 409000 <posix_swap+0x58>
	while (cpu_halted == false) {
  409540:	91104273 	add	x19, x19, #0x410
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  409544:	910ed042 	add	x2, x2, #0x3b4
  409548:	d2800003 	mov	x3, #0x0                   	// #0
  40954c:	d2800001 	mov	x1, #0x0                   	// #0
  409550:	9100c3e0 	add	x0, sp, #0x30
  409554:	97ffdfb7 	bl	401430 <pthread_create@plt>
  409558:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  40955c:	913bbc21 	add	x1, x1, #0xeef
  409560:	97ffff90 	bl	4093a0 <pc_safe_call>
	while (cpu_halted == false) {
  409564:	39400260 	ldrb	w0, [x19]
  409568:	34000260 	cbz	w0, 4095b4 <posix_boot_cpu+0xc8>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  40956c:	913122a0 	add	x0, x21, #0xc48
  409570:	97ffdfcc 	bl	4014a0 <pthread_mutex_unlock@plt>
  409574:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  409578:	913ab821 	add	x1, x1, #0xeae
  40957c:	97ffff89 	bl	4093a0 <pc_safe_call>

	if (soc_terminate) {
  409580:	90000120 	adrp	x0, 42d000 <args_struct>
  409584:	397fb800 	ldrb	w0, [x0, #4078]
  409588:	34000060 	cbz	w0, 409594 <posix_boot_cpu+0xa8>
		posix_exit(0);
  40958c:	52800000 	mov	w0, #0x0                   	// #0
  409590:	94000346 	bl	40a2a8 <posix_exit>
	}
}
  409594:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409598:	f9476800 	ldr	x0, [x0, #3792]
  40959c:	f9401fe2 	ldr	x2, [sp, #56]
  4095a0:	f9400001 	ldr	x1, [x0]
  4095a4:	eb010042 	subs	x2, x2, x1
  4095a8:	d2800001 	mov	x1, #0x0                   	// #0
  4095ac:	540000c0 	b.eq	4095c4 <posix_boot_cpu+0xd8>  // b.none
  4095b0:	97ffdf5c 	bl	401320 <__stack_chk_fail@plt>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  4095b4:	aa1603e1 	mov	x1, x22
  4095b8:	aa1403e0 	mov	x0, x20
  4095bc:	97ffdf8d 	bl	4013f0 <pthread_cond_wait@plt>
  4095c0:	17ffffe9 	b	409564 <posix_boot_cpu+0x78>
}
  4095c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4095c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4095cc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4095d0:	d65f03c0 	ret

00000000004095d4 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
  4095d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  4095d8:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4095dc:	91256021 	add	x1, x1, #0x958
{
  4095e0:	910003fd 	mov	x29, sp
  4095e4:	a90153f3 	stp	x19, x20, [sp, #16]
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  4095e8:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
  4095ec:	11000400 	add	w0, w0, #0x1
  4095f0:	f860d834 	ldr	x20, [x1, w0, sxtw #3]
  4095f4:	eb13029f 	cmp	x20, x19
  4095f8:	54000088 	b.hi	409608 <run_native_tasks+0x34>  // b.pmore
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
			(*fptr)();
		}
	}
}
  4095fc:	a94153f3 	ldp	x19, x20, [sp, #16]
  409600:	a8c27bfd 	ldp	x29, x30, [sp], #32
  409604:	d65f03c0 	ret
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
  409608:	f9400260 	ldr	x0, [x19]
  40960c:	b4000040 	cbz	x0, 409614 <run_native_tasks+0x40>
			(*fptr)();
  409610:	d63f0000 	blr	x0
		fptr++) {
  409614:	91002273 	add	x19, x19, #0x8
  409618:	17fffff7 	b	4095f4 <run_native_tasks+0x20>

000000000040961c <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
  40961c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409620:	910003fd 	mov	x29, sp
  409624:	a90153f3 	stp	x19, x20, [sp, #16]
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
  409628:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  40962c:	39504280 	ldrb	w0, [x20, #1040]
{
  409630:	f90013f5 	str	x21, [sp, #32]
	if (cpu_halted) {
  409634:	340000e0 	cbz	w0, 409650 <posix_soc_clean_up+0x34>

		posix_core_clean_up();
  409638:	97fffed7 	bl	409194 <posix_core_clean_up>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
  40963c:	a94153f3 	ldp	x19, x20, [sp, #16]
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  409640:	52800080 	mov	w0, #0x4                   	// #4
}
  409644:	f94013f5 	ldr	x21, [sp, #32]
  409648:	a8c37bfd 	ldp	x29, x30, [sp], #48
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  40964c:	17ffffe2 	b	4095d4 <run_native_tasks>
	} else if (soc_terminate == false) {
  409650:	90000120 	adrp	x0, 42d000 <args_struct>
  409654:	397fb801 	ldrb	w1, [x0, #4078]
  409658:	35000321 	cbnz	w1, 4096bc <posix_soc_clean_up+0xa0>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  40965c:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409660:	91312273 	add	x19, x19, #0xc48
		soc_terminate = true;
  409664:	52800035 	mov	w21, #0x1                   	// #1
  409668:	393fb815 	strb	w21, [x0, #4078]
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  40966c:	aa1303e0 	mov	x0, x19
  409670:	97ffdf88 	bl	401490 <pthread_mutex_lock@plt>
  409674:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  409678:	913a4421 	add	x1, x1, #0xe91
  40967c:	97ffff49 	bl	4093a0 <pc_safe_call>
		cpu_halted = true;
  409680:	39104295 	strb	w21, [x20, #1040]
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  409684:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409688:	91306000 	add	x0, x0, #0xc18
  40968c:	97ffdf15 	bl	4012e0 <pthread_cond_broadcast@plt>
  409690:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  409694:	913b3421 	add	x1, x1, #0xecd
  409698:	97ffff42 	bl	4093a0 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  40969c:	aa1303e0 	mov	x0, x19
  4096a0:	97ffdf80 	bl	4014a0 <pthread_mutex_unlock@plt>
  4096a4:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  4096a8:	913ab821 	add	x1, x1, #0xeae
  4096ac:	97ffff3d 	bl	4093a0 <pc_safe_call>
			sleep(1);
  4096b0:	52800020 	mov	w0, #0x1                   	// #1
  4096b4:	97ffdeff 	bl	4012b0 <sleep@plt>
		while (1) {
  4096b8:	17fffffe 	b	4096b0 <posix_soc_clean_up+0x94>
}
  4096bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4096c0:	f94013f5 	ldr	x21, [sp, #32]
  4096c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4096c8:	d65f03c0 	ret

00000000004096cc <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
  4096cc:	90000120 	adrp	x0, 42d000 <args_struct>
  4096d0:	52800021 	mov	w1, #0x1                   	// #1
  4096d4:	b90bd801 	str	w1, [x0, #3032]
}
  4096d8:	d65f03c0 	ret

00000000004096dc <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
  4096dc:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
  4096e0:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4096e4:	910003fd 	mov	x29, sp
  4096e8:	f9476800 	ldr	x0, [x0, #3792]
  4096ec:	f9000bf3 	str	x19, [sp, #16]
  4096f0:	f9400001 	ldr	x1, [x0]
  4096f4:	f9005fe1 	str	x1, [sp, #184]
  4096f8:	d2800001 	mov	x1, #0x0                   	// #0
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
  4096fc:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409700:	f9475400 	ldr	x0, [x0, #3752]
  409704:	f90013e0 	str	x0, [sp, #32]
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
  409708:	9100a3e0 	add	x0, sp, #0x28
  40970c:	97ffdedd 	bl	401280 <sigemptyset@plt>
	if (unlikely(test)) {
  409710:	340000c0 	cbz	w0, 409728 <hwm_set_sig_handler+0x4c>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  409714:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  409718:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40971c:	913ca821 	add	x1, x1, #0xf2a
  409720:	91334400 	add	x0, x0, #0xcd1
  409724:	94000337 	bl	40a400 <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;
  409728:	52b00000 	mov	w0, #0x80000000            	// #-2147483648

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  40972c:	910083f3 	add	x19, sp, #0x20
  409730:	aa1303e1 	mov	x1, x19
  409734:	d2800002 	mov	x2, #0x0                   	// #0
	act.sa_flags = SA_RESETHAND;
  409738:	b900abe0 	str	w0, [sp, #168]
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  40973c:	528001e0 	mov	w0, #0xf                   	// #15
  409740:	97ffdefc 	bl	401330 <sigaction@plt>
	if (unlikely(test)) {
  409744:	340000c0 	cbz	w0, 40975c <hwm_set_sig_handler+0x80>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  409748:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  40974c:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  409750:	913d1021 	add	x1, x1, #0xf44
  409754:	91334400 	add	x0, x0, #0xcd1
  409758:	9400032a 	bl	40a400 <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
  40975c:	aa1303e1 	mov	x1, x19
  409760:	d2800002 	mov	x2, #0x0                   	// #0
  409764:	52800040 	mov	w0, #0x2                   	// #2
  409768:	97ffdef2 	bl	401330 <sigaction@plt>
	if (unlikely(test)) {
  40976c:	340000c0 	cbz	w0, 409784 <hwm_set_sig_handler+0xa8>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  409770:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x78d>
  409774:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  409778:	913d8c21 	add	x1, x1, #0xf63
  40977c:	91334400 	add	x0, x0, #0xcd1
  409780:	94000320 	bl	40a400 <posix_print_error_and_exit>
}
  409784:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409788:	f9476800 	ldr	x0, [x0, #3792]
  40978c:	f9405fe2 	ldr	x2, [sp, #184]
  409790:	f9400001 	ldr	x1, [x0]
  409794:	eb010042 	subs	x2, x2, x1
  409798:	d2800001 	mov	x1, #0x0                   	// #0
  40979c:	54000040 	b.eq	4097a4 <hwm_set_sig_handler+0xc8>  // b.none
  4097a0:	97ffdee0 	bl	401320 <__stack_chk_fail@plt>
  4097a4:	f9400bf3 	ldr	x19, [sp, #16]
  4097a8:	a8cc7bfd 	ldp	x29, x30, [sp], #192
  4097ac:	d65f03c0 	ret

00000000004097b0 <hwm_find_next_timer>:
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
  4097b0:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
  4097b4:	d0000102 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
	next_timer_index = 0;
  4097b8:	f0000101 	adrp	x1, 42c000 <__dso_handle>
	next_timer_time  = *Timer_list[0];
  4097bc:	f9475800 	ldr	x0, [x0, #3760]
	next_timer_index = 0;
  4097c0:	b903f83f 	str	wzr, [x1, #1016]
		if (next_timer_time > *Timer_list[i]) {
  4097c4:	f9478c42 	ldr	x2, [x2, #3864]
	next_timer_time  = *Timer_list[0];
  4097c8:	f9400003 	ldr	x3, [x0]
  4097cc:	f0000100 	adrp	x0, 42c000 <__dso_handle>
		if (next_timer_time > *Timer_list[i]) {
  4097d0:	f9400042 	ldr	x2, [x2]
	next_timer_time  = *Timer_list[0];
  4097d4:	f9063c03 	str	x3, [x0, #3192]
		if (next_timer_time > *Timer_list[i]) {
  4097d8:	eb02007f 	cmp	x3, x2
  4097dc:	54000089 	b.ls	4097ec <hwm_find_next_timer+0x3c>  // b.plast
			next_timer_index = i;
  4097e0:	52800023 	mov	w3, #0x1                   	// #1
			next_timer_time = *Timer_list[i];
  4097e4:	f9063c02 	str	x2, [x0, #3192]
			next_timer_index = i;
  4097e8:	b903f823 	str	w3, [x1, #1016]
		if (next_timer_time > *Timer_list[i]) {
  4097ec:	d0000102 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  4097f0:	f9463c03 	ldr	x3, [x0, #3192]
  4097f4:	f947d042 	ldr	x2, [x2, #4000]
  4097f8:	f9400042 	ldr	x2, [x2]
  4097fc:	eb03005f 	cmp	x2, x3
  409800:	54000082 	b.cs	409810 <hwm_find_next_timer+0x60>  // b.hs, b.nlast
			next_timer_index = i;
  409804:	52800043 	mov	w3, #0x2                   	// #2
			next_timer_time = *Timer_list[i];
  409808:	f9063c02 	str	x2, [x0, #3192]
			next_timer_index = i;
  40980c:	b903f823 	str	w3, [x1, #1016]
		}
	}
}
  409810:	d65f03c0 	ret

0000000000409814 <hwm_one_event>:

/**
 * Execute the next scheduled HW event/timer
 */
void hwm_one_event(void)
{
  409814:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  409818:	f0000100 	adrp	x0, 42c000 <__dso_handle>
{
  40981c:	910003fd 	mov	x29, sp
  409820:	a90153f3 	stp	x19, x20, [sp, #16]
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  409824:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409828:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  40982c:	f9463c01 	ldr	x1, [x0, #3192]
  409830:	f9464262 	ldr	x2, [x19, #3200]
  409834:	eb02003f 	cmp	x1, x2
  409838:	540003c3 	b.cc	4098b0 <hwm_one_event+0x9c>  // b.lo, b.ul, b.last
		simu_time = next_timer_time;
  40983c:	f9064261 	str	x1, [x19, #3200]
	if (signaled_end || (simu_time > end_of_time)) {
  409840:	90000120 	adrp	x0, 42d000 <args_struct>
  409844:	b94bd801 	ldr	w1, [x0, #3032]
  409848:	f9464260 	ldr	x0, [x19, #3200]
  40984c:	350000a1 	cbnz	w1, 409860 <hwm_one_event+0x4c>
  409850:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409854:	f9400c21 	ldr	x1, [x1, #24]
  409858:	eb00003f 	cmp	x1, x0
  40985c:	54000162 	b.cs	409888 <hwm_one_event+0x74>  // b.hs, b.nlast
				((long double)simu_time)/1.0e6L);
  409860:	97ffe1d0 	bl	401fa0 <__floatunditf>
		posix_print_trace("\nStopped at %.3Lfs\n",
  409864:	d0000040 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  409868:	9117c000 	add	x0, x0, #0x5f0
  40986c:	3dc00001 	ldr	q1, [x0]
  409870:	97ffdf74 	bl	401640 <__divtf3>
  409874:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  409878:	913ed800 	add	x0, x0, #0xfb6
  40987c:	94000347 	bl	40a598 <posix_print_trace>
		posix_exit(0);
  409880:	52800000 	mov	w0, #0x0                   	// #0
  409884:	94000289 	bl	40a2a8 <posix_exit>
	hwm_sleep_until_next_timer();

	switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
  409888:	b943fa80 	ldr	w0, [x20, #1016]
  40988c:	7100041f 	cmp	w0, #0x1
  409890:	540001a0 	b.eq	4098c4 <hwm_one_event+0xb0>  // b.none
  409894:	7100081f 	cmp	w0, #0x2
  409898:	540001a0 	b.eq	4098cc <hwm_one_event+0xb8>  // b.none
  40989c:	350001c0 	cbnz	w0, 4098d4 <hwm_one_event+0xc0>
	case HWTIMER:
		hwtimer_timer_reached();
  4098a0:	940000b7 	bl	409b7c <hwtimer_timer_reached>
		break;
		/* LCOV_EXCL_STOP */
	}

	hwm_find_next_timer();
}
  4098a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4098a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  4098ac:	17ffffc1 	b	4097b0 <hwm_find_next_timer>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
  4098b0:	b943fa83 	ldr	w3, [x20, #1016]
  4098b4:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4098b8:	913e0400 	add	x0, x0, #0xf81
  4098bc:	94000305 	bl	40a4d0 <posix_print_warning>
  4098c0:	17ffffe0 	b	409840 <hwm_one_event+0x2c>
		hw_irq_ctrl_timer_triggered();
  4098c4:	94000274 	bl	40a294 <hw_irq_ctrl_timer_triggered>
		break;
  4098c8:	17fffff7 	b	4098a4 <hwm_one_event+0x90>
		hw_counter_triggered();
  4098cc:	94000615 	bl	40b120 <hw_counter_triggered>
		break;
  4098d0:	17fffff5 	b	4098a4 <hwm_one_event+0x90>
		posix_print_error_and_exit(
  4098d4:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4098d8:	913f2800 	add	x0, x0, #0xfca
  4098dc:	940002c9 	bl	40a400 <posix_print_error_and_exit>
		break;
  4098e0:	17fffff1 	b	4098a4 <hwm_one_event+0x90>

00000000004098e4 <hwm_set_end_of_time>:
/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
	end_of_time = new_end_of_time;
  4098e4:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  4098e8:	f9000c20 	str	x0, [x1, #24]
}
  4098ec:	d65f03c0 	ret

00000000004098f0 <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
  4098f0:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  4098f4:	f9464000 	ldr	x0, [x0, #3200]
  4098f8:	d65f03c0 	ret

00000000004098fc <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
  4098fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409900:	910003fd 	mov	x29, sp
	hwm_set_sig_handler();
  409904:	97ffff76 	bl	4096dc <hwm_set_sig_handler>
	hwtimer_init();
  409908:	94000055 	bl	409a5c <hwtimer_init>
	hw_counter_init();
  40990c:	940005f8 	bl	40b0ec <hw_counter_init>
	hw_irq_ctrl_init();
  409910:	940001da 	bl	40a078 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
  409914:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hwm_find_next_timer();
  409918:	17ffffa6 	b	4097b0 <hwm_find_next_timer>

000000000040991c <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
  40991c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409920:	910003fd 	mov	x29, sp
	hwtimer_cleanup();
  409924:	94000086 	bl	409b3c <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
  409928:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hw_irq_ctrl_cleanup();
  40992c:	140001e0 	b	40a0ac <hw_irq_ctrl_cleanup>

0000000000409930 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
  409930:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409934:	f947a800 	ldr	x0, [x0, #3920]
  409938:	f9400001 	ldr	x1, [x0]
  40993c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409940:	f9477c00 	ldr	x0, [x0, #3832]
  409944:	f9400000 	ldr	x0, [x0]
  409948:	eb01001f 	cmp	x0, x1
  40994c:	9a819000 	csel	x0, x0, x1, ls  // ls = plast
  409950:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  409954:	f9475821 	ldr	x1, [x1, #3760]
  409958:	f9000020 	str	x0, [x1]
}
  40995c:	d65f03c0 	ret

0000000000409960 <native_add_time_options>:
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
  409960:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409964:	9100a000 	add	x0, x0, #0x28
  409968:	14000573 	b	40af34 <native_add_command_line_opts>

000000000040996c <cmd_stop_at_found>:
{
  40996c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409970:	910003fd 	mov	x29, sp
  409974:	f9000bf3 	str	x19, [sp, #16]
	if (args.stop_at < 0) {
  409978:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  40997c:	fd464660 	ldr	d0, [x19, #3208]
  409980:	1e602018 	fcmpe	d0, #0.0
  409984:	54000144 	b.mi	4099ac <cmd_stop_at_found+0x40>  // b.first
	hwm_set_end_of_time(args.stop_at*1e6);
  409988:	fd464660 	ldr	d0, [x19, #3208]
  40998c:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409990:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409994:	9e670001 	fmov	d1, x0
}
  409998:	f9400bf3 	ldr	x19, [sp, #16]
	hwm_set_end_of_time(args.stop_at*1e6);
  40999c:	1e610800 	fmul	d0, d0, d1
}
  4099a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_set_end_of_time(args.stop_at*1e6);
  4099a4:	9e790000 	fcvtzu	x0, d0
  4099a8:	17ffffcf 	b	4098e4 <hwm_set_end_of_time>
  4099ac:	aa0003e1 	mov	x1, x0
		posix_print_error_and_exit("Error: stop-at must be positive "
  4099b0:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4099b4:	913f9800 	add	x0, x0, #0xfe6
  4099b8:	94000292 	bl	40a400 <posix_print_error_and_exit>
  4099bc:	17fffff3 	b	409988 <cmd_stop_at_found+0x1c>

00000000004099c0 <hwtimer_set_real_time_mode>:
	real_time_mode = new_rt;
  4099c0:	90000121 	adrp	x1, 42d000 <args_struct>
  4099c4:	393fbc20 	strb	w0, [x1, #4079]
}
  4099c8:	d65f03c0 	ret

00000000004099cc <cmd_no_realtime_found>:
	hwtimer_set_real_time_mode(false);
  4099cc:	52800000 	mov	w0, #0x0                   	// #0
  4099d0:	17fffffc 	b	4099c0 <hwtimer_set_real_time_mode>

00000000004099d4 <cmd_realtime_found>:
	hwtimer_set_real_time_mode(true);
  4099d4:	52800020 	mov	w0, #0x1                   	// #1
  4099d8:	17fffffa 	b	4099c0 <hwtimer_set_real_time_mode>

00000000004099dc <get_host_us_time>:
{
  4099dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4099e0:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4099e4:	910003fd 	mov	x29, sp
  4099e8:	f9476800 	ldr	x0, [x0, #3792]
  4099ec:	f9400001 	ldr	x1, [x0]
  4099f0:	f90017e1 	str	x1, [sp, #40]
  4099f4:	d2800001 	mov	x1, #0x0                   	// #0
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
  4099f8:	52800080 	mov	w0, #0x4                   	// #4
  4099fc:	910063e1 	add	x1, sp, #0x18
  409a00:	97ffde08 	bl	401220 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409a04:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409a08:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  409a0c:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409a10:	9e670001 	fmov	d1, x0
  409a14:	fd400fe0 	ldr	d0, [sp, #24]
  409a18:	f94013e0 	ldr	x0, [sp, #32]
  409a1c:	7e61d800 	ucvtf	d0, d0
  409a20:	9ac10c00 	sdiv	x0, x0, x1
}
  409a24:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409a28:	1e610800 	fmul	d0, d0, d1
}
  409a2c:	f9476821 	ldr	x1, [x1, #3792]
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409a30:	9e620001 	scvtf	d1, x0
}
  409a34:	f94017e3 	ldr	x3, [sp, #40]
  409a38:	f9400022 	ldr	x2, [x1]
  409a3c:	eb020063 	subs	x3, x3, x2
  409a40:	d2800002 	mov	x2, #0x0                   	// #0
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409a44:	1e612800 	fadd	d0, d0, d1
}
  409a48:	54000040 	b.eq	409a50 <get_host_us_time+0x74>  // b.none
  409a4c:	97ffde35 	bl	401320 <__stack_chk_fail@plt>
  409a50:	9e790000 	fcvtzu	x0, d0
  409a54:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409a58:	d65f03c0 	ret

0000000000409a5c <hwtimer_init>:
{
  409a5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409a60:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409a64:	910003fd 	mov	x29, sp
  409a68:	f9476800 	ldr	x0, [x0, #3792]
  409a6c:	f9400001 	ldr	x1, [x0]
  409a70:	f90017e1 	str	x1, [sp, #40]
  409a74:	d2800001 	mov	x1, #0x0                   	// #0
	silent_ticks = 0;
  409a78:	f0000100 	adrp	x0, 42c000 <__dso_handle>
	hw_timer_tick_timer = NEVER;
  409a7c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	silent_ticks = 0;
  409a80:	f9066c1f 	str	xzr, [x0, #3288]
	hw_timer_tick_timer = NEVER;
  409a84:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409a88:	f947a800 	ldr	x0, [x0, #3920]
  409a8c:	f9000001 	str	x1, [x0]
	hw_timer_awake_timer = NEVER;
  409a90:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409a94:	f9477c00 	ldr	x0, [x0, #3832]
  409a98:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409a9c:	97ffffa5 	bl	409930 <hwtimer_update_timer>
	if (real_time_mode) {
  409aa0:	90000120 	adrp	x0, 42d000 <args_struct>
  409aa4:	397fbc00 	ldrb	w0, [x0, #4079]
  409aa8:	340000c0 	cbz	w0, 409ac0 <hwtimer_init+0x64>
		boot_time = get_host_us_time();
  409aac:	97ffffcc 	bl	4099dc <get_host_us_time>
		last_radj_rtime = boot_time;
  409ab0:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409ab4:	f9066020 	str	x0, [x1, #3264]
		last_radj_stime = 0U;
  409ab8:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409abc:	f906641f 	str	xzr, [x0, #3272]
	if (!reset_rtc) {
  409ac0:	90000120 	adrp	x0, 42d000 <args_struct>
  409ac4:	397fc000 	ldrb	w0, [x0, #4080]
  409ac8:	35000260 	cbnz	w0, 409b14 <hwtimer_init+0xb8>
		clock_gettime(CLOCK_REALTIME, &tv);
  409acc:	910063e1 	add	x1, sp, #0x18
  409ad0:	97ffddd4 	bl	401220 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409ad4:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409ad8:	d2807d02 	mov	x2, #0x3e8                 	// #1000
  409adc:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409ae0:	9e670001 	fmov	d1, x0
  409ae4:	fd400fe0 	ldr	d0, [sp, #24]
		rtc_offset += realhosttime;
  409ae8:	f0000101 	adrp	x1, 42c000 <__dso_handle>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409aec:	f94013e0 	ldr	x0, [sp, #32]
  409af0:	7e61d800 	ucvtf	d0, d0
  409af4:	9ac20c00 	sdiv	x0, x0, x2
		rtc_offset += realhosttime;
  409af8:	f9466822 	ldr	x2, [x1, #3280]
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409afc:	1e610800 	fmul	d0, d0, d1
  409b00:	9e620001 	scvtf	d1, x0
  409b04:	1e612800 	fadd	d0, d0, d1
  409b08:	9e790000 	fcvtzu	x0, d0
		rtc_offset += realhosttime;
  409b0c:	8b020000 	add	x0, x0, x2
  409b10:	f9066820 	str	x0, [x1, #3280]
}
  409b14:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409b18:	f9476800 	ldr	x0, [x0, #3792]
  409b1c:	f94017e2 	ldr	x2, [sp, #40]
  409b20:	f9400001 	ldr	x1, [x0]
  409b24:	eb010042 	subs	x2, x2, x1
  409b28:	d2800001 	mov	x1, #0x0                   	// #0
  409b2c:	54000040 	b.eq	409b34 <hwtimer_init+0xd8>  // b.none
  409b30:	97ffddfc 	bl	401320 <__stack_chk_fail@plt>
  409b34:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409b38:	d65f03c0 	ret

0000000000409b3c <hwtimer_cleanup>:
}
  409b3c:	d65f03c0 	ret

0000000000409b40 <hwtimer_enable>:
{
  409b40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409b44:	910003fd 	mov	x29, sp
  409b48:	f9000bf3 	str	x19, [sp, #16]
	tick_p = period;
  409b4c:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409b50:	f9067260 	str	x0, [x19, #3296]
	hw_timer_tick_timer = hwm_get_time() + tick_p;
  409b54:	97ffff67 	bl	4098f0 <hwm_get_time>
  409b58:	f9467261 	ldr	x1, [x19, #3296]
  409b5c:	8b000020 	add	x0, x1, x0
  409b60:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  409b64:	f947a821 	ldr	x1, [x1, #3920]
  409b68:	f9000020 	str	x0, [x1]
	hwtimer_update_timer();
  409b6c:	97ffff71 	bl	409930 <hwtimer_update_timer>
}
  409b70:	f9400bf3 	ldr	x19, [sp, #16]
  409b74:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  409b78:	17ffff0e 	b	4097b0 <hwm_find_next_timer>

0000000000409b7c <hwtimer_timer_reached>:
{
  409b7c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  409b80:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409b84:	910003fd 	mov	x29, sp
  409b88:	f9476800 	ldr	x0, [x0, #3792]
  409b8c:	a90153f3 	stp	x19, x20, [sp, #16]
  409b90:	f90013f5 	str	x21, [sp, #32]
  409b94:	f9400001 	ldr	x1, [x0]
  409b98:	f9002fe1 	str	x1, [sp, #88]
  409b9c:	d2800001 	mov	x1, #0x0                   	// #0
	uint64_t Now = hw_timer_timer;
  409ba0:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409ba4:	f9475800 	ldr	x0, [x0, #3760]
  409ba8:	f9400013 	ldr	x19, [x0]
	if (hw_timer_awake_timer == Now) {
  409bac:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409bb0:	f9477c00 	ldr	x0, [x0, #3832]
  409bb4:	f9400001 	ldr	x1, [x0]
  409bb8:	eb13003f 	cmp	x1, x19
  409bbc:	540000c1 	b.ne	409bd4 <hwtimer_timer_reached+0x58>  // b.any
	hw_timer_awake_timer = NEVER;
  409bc0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  409bc4:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409bc8:	97ffff5a 	bl	409930 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
  409bcc:	529fffe0 	mov	w0, #0xffff                	// #65535
  409bd0:	9400018a 	bl	40a1f8 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
  409bd4:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  409bd8:	d0000114 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  409bdc:	aa0003f5 	mov	x21, x0
  409be0:	f947a801 	ldr	x1, [x0, #3920]
  409be4:	f9400021 	ldr	x1, [x1]
  409be8:	eb13003f 	cmp	x1, x19
  409bec:	54000661 	b.ne	409cb8 <hwtimer_timer_reached+0x13c>  // b.any
	if (real_time_mode) {
  409bf0:	90000120 	adrp	x0, 42d000 <args_struct>
  409bf4:	397fbc00 	ldrb	w0, [x0, #4079]
  409bf8:	34000460 	cbz	w0, 409c84 <hwtimer_timer_reached+0x108>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  409bfc:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409c00:	f9466400 	ldr	x0, [x0, #3272]
  409c04:	cb000273 	sub	x19, x19, x0
				    / clock_ratio
  409c08:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409c0c:	9e630260 	ucvtf	d0, x19
  409c10:	fd401001 	ldr	d1, [x0, #32]
				    + last_radj_rtime;
  409c14:	f0000100 	adrp	x0, 42c000 <__dso_handle>
				    / clock_ratio
  409c18:	1e611800 	fdiv	d0, d0, d1
				    + last_radj_rtime;
  409c1c:	fd466001 	ldr	d1, [x0, #3264]
  409c20:	7e61d821 	ucvtf	d1, d1
  409c24:	1e612800 	fadd	d0, d0, d1
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  409c28:	9e790013 	fcvtzu	x19, d0
		uint64_t real_time = get_host_us_time();
  409c2c:	97ffff6c 	bl	4099dc <get_host_us_time>
		int64_t diff = expected_rt - real_time;
  409c30:	cb000260 	sub	x0, x19, x0
		if (diff > 0) { /* we need to slow down */
  409c34:	f100001f 	cmp	x0, #0x0
  409c38:	5400026d 	b.le	409c84 <hwtimer_timer_reached+0x108>
			requested_time.tv_sec  = diff / 1e6;
  409c3c:	9e620000 	scvtf	d0, x0
  409c40:	d0000040 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
			(void) nanosleep(&requested_time, &remaining);
  409c44:	910123e1 	add	x1, sp, #0x48
			requested_time.tv_sec  = diff / 1e6;
  409c48:	fd430002 	ldr	d2, [x0, #1536]
						 requested_time.tv_sec*1e6)*1e3;
  409c4c:	d2c80000 	mov	x0, #0x400000000000        	// #70368744177664
  409c50:	f2e811e0 	movk	x0, #0x408f, lsl #48
			requested_time.tv_sec  = diff / 1e6;
  409c54:	1e621801 	fdiv	d1, d0, d2
  409c58:	5ee1b821 	fcvtzs	d1, d1
  409c5c:	fd001fe1 	str	d1, [sp, #56]
						 requested_time.tv_sec*1e6)*1e3;
  409c60:	5e61d821 	scvtf	d1, d1
  409c64:	1e620821 	fmul	d1, d1, d2
			requested_time.tv_nsec = (diff -
  409c68:	1e613800 	fsub	d0, d0, d1
						 requested_time.tv_sec*1e6)*1e3;
  409c6c:	9e670001 	fmov	d1, x0
			(void) nanosleep(&requested_time, &remaining);
  409c70:	9100e3e0 	add	x0, sp, #0x38
						 requested_time.tv_sec*1e6)*1e3;
  409c74:	1e610800 	fmul	d0, d0, d1
			requested_time.tv_nsec = (diff -
  409c78:	5ee1b800 	fcvtzs	d0, d0
  409c7c:	fd0023e0 	str	d0, [sp, #64]
			(void) nanosleep(&requested_time, &remaining);
  409c80:	97ffdde0 	bl	401400 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
  409c84:	f947aaa0 	ldr	x0, [x21, #3920]
  409c88:	f0000102 	adrp	x2, 42c000 <__dso_handle>
  409c8c:	f9467042 	ldr	x2, [x2, #3296]
  409c90:	f9400001 	ldr	x1, [x0]
  409c94:	8b020021 	add	x1, x1, x2
  409c98:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409c9c:	97ffff25 	bl	409930 <hwtimer_update_timer>
	if (silent_ticks > 0) {
  409ca0:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409ca4:	f9466c20 	ldr	x0, [x1, #3288]
  409ca8:	f100001f 	cmp	x0, #0x0
  409cac:	540001ad 	b.le	409ce0 <hwtimer_timer_reached+0x164>
		silent_ticks -= 1;
  409cb0:	d1000400 	sub	x0, x0, #0x1
  409cb4:	f9066c20 	str	x0, [x1, #3288]
}
  409cb8:	f9476a80 	ldr	x0, [x20, #3792]
  409cbc:	f9402fe2 	ldr	x2, [sp, #88]
  409cc0:	f9400001 	ldr	x1, [x0]
  409cc4:	eb010042 	subs	x2, x2, x1
  409cc8:	d2800001 	mov	x1, #0x0                   	// #0
  409ccc:	54000161 	b.ne	409cf8 <hwtimer_timer_reached+0x17c>  // b.any
  409cd0:	a94153f3 	ldp	x19, x20, [sp, #16]
  409cd4:	f94013f5 	ldr	x21, [sp, #32]
  409cd8:	a8c67bfd 	ldp	x29, x30, [sp], #96
  409cdc:	d65f03c0 	ret
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409ce0:	f9476a80 	ldr	x0, [x20, #3792]
  409ce4:	f9402fe2 	ldr	x2, [sp, #88]
  409ce8:	f9400001 	ldr	x1, [x0]
  409cec:	eb010042 	subs	x2, x2, x1
  409cf0:	d2800001 	mov	x1, #0x0                   	// #0
  409cf4:	54000040 	b.eq	409cfc <hwtimer_timer_reached+0x180>  // b.none
}
  409cf8:	97ffdd8a 	bl	401320 <__stack_chk_fail@plt>
  409cfc:	a94153f3 	ldp	x19, x20, [sp, #16]
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409d00:	52800000 	mov	w0, #0x0                   	// #0
}
  409d04:	f94013f5 	ldr	x21, [sp, #32]
  409d08:	a8c67bfd 	ldp	x29, x30, [sp], #96
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409d0c:	1400013b 	b	40a1f8 <hw_irq_ctrl_set_irq>

0000000000409d10 <hwtimer_set_silent_ticks>:
	silent_ticks = sys_ticks;
  409d10:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409d14:	f9066c20 	str	x0, [x1, #3288]
}
  409d18:	d65f03c0 	ret

0000000000409d1c <hwtimer_reset_rtc>:
	reset_rtc = true;
  409d1c:	90000120 	adrp	x0, 42d000 <args_struct>
  409d20:	52800021 	mov	w1, #0x1                   	// #1
  409d24:	393fc001 	strb	w1, [x0, #4080]
}
  409d28:	d65f03c0 	ret

0000000000409d2c <cmd_rtcreset_found>:
	hwtimer_reset_rtc();
  409d2c:	17fffffc 	b	409d1c <hwtimer_reset_rtc>

0000000000409d30 <hwtimer_set_rtc_offset>:
	rtc_offset = offset;
  409d30:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409d34:	f9066820 	str	x0, [x1, #3280]
}
  409d38:	d65f03c0 	ret

0000000000409d3c <cmd_rtcoffset_found>:
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
  409d3c:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409d40:	fd464800 	ldr	d0, [x0, #3216]
  409d44:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409d48:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409d4c:	9e670001 	fmov	d1, x0
  409d50:	1e610800 	fmul	d0, d0, d1
  409d54:	9e780000 	fcvtzs	x0, d0
  409d58:	17fffff6 	b	409d30 <hwtimer_set_rtc_offset>

0000000000409d5c <hwtimer_set_rt_ratio>:
	clock_ratio = ratio;
  409d5c:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409d60:	fd001000 	str	d0, [x0, #32]
}
  409d64:	d65f03c0 	ret

0000000000409d68 <cmd_rt_ratio_found>:
{
  409d68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409d6c:	910003fd 	mov	x29, sp
  409d70:	f9000bf3 	str	x19, [sp, #16]
	if ((args.rt_ratio <= 0)) {
  409d74:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409d78:	91322260 	add	x0, x19, #0xc88
  409d7c:	fd400c00 	ldr	d0, [x0, #24]
  409d80:	1e602018 	fcmpe	d0, #0.0
  409d84:	540000c9 	b.ls	409d9c <cmd_rt_ratio_found+0x34>  // b.plast
	hwtimer_set_rt_ratio(args.rt_ratio);
  409d88:	91322273 	add	x19, x19, #0xc88
  409d8c:	fd400e60 	ldr	d0, [x19, #24]
}
  409d90:	f9400bf3 	ldr	x19, [sp, #16]
  409d94:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  409d98:	17fffff1 	b	409d5c <hwtimer_set_rt_ratio>
		posix_print_error_and_exit("The ratio needs to be > 0. "
  409d9c:	90000060 	adrp	x0, 415000 <random_data+0xca4>
  409da0:	91003000 	add	x0, x0, #0xc
  409da4:	94000197 	bl	40a400 <posix_print_error_and_exit>
  409da8:	17fffff8 	b	409d88 <cmd_rt_ratio_found+0x20>

0000000000409dac <cmd_rt_drift_found>:
{
  409dac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!(args.rt_drift > -1)) {
  409db0:	1e7e1000 	fmov	d0, #-1.000000000000000000e+00
{
  409db4:	910003fd 	mov	x29, sp
  409db8:	f9000bf3 	str	x19, [sp, #16]
	if (!(args.rt_drift > -1)) {
  409dbc:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409dc0:	91322260 	add	x0, x19, #0xc88
  409dc4:	fd400801 	ldr	d1, [x0, #16]
  409dc8:	1e602030 	fcmpe	d1, d0
  409dcc:	5400008c 	b.gt	409ddc <cmd_rt_drift_found+0x30>
		posix_print_error_and_exit("The drift needs to be > -1. "
  409dd0:	90000060 	adrp	x0, 415000 <random_data+0xca4>
  409dd4:	91012000 	add	x0, x0, #0x48
  409dd8:	9400018a 	bl	40a400 <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
  409ddc:	91322273 	add	x19, x19, #0xc88
  409de0:	1e6e1001 	fmov	d1, #1.000000000000000000e+00
  409de4:	fd400a60 	ldr	d0, [x19, #16]
  409de8:	1e612800 	fadd	d0, d0, d1
  409dec:	fd000e60 	str	d0, [x19, #24]
}
  409df0:	f9400bf3 	ldr	x19, [sp, #16]
  409df4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  409df8:	17ffffd9 	b	409d5c <hwtimer_set_rt_ratio>

0000000000409dfc <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
  409dfc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  409e00:	910003fd 	mov	x29, sp
  409e04:	a90153f3 	stp	x19, x20, [sp, #16]
  409e08:	a9025bf5 	stp	x21, x22, [sp, #32]
  409e0c:	a90363f7 	stp	x23, x24, [sp, #48]
  409e10:	f90023f9 	str	x25, [sp, #64]
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
  409e14:	940000b5 	bl	40a0e8 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
  409e18:	350009c0 	cbnz	w0, 409f50 <posix_irq_handler+0x154>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
  409e1c:	d0000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  409e20:	aa1303f4 	mov	x20, x19
  409e24:	f9472e60 	ldr	x0, [x19, #3672]
  409e28:	b9400000 	ldr	w0, [x0]
  409e2c:	35000060 	cbnz	w0, 409e38 <posix_irq_handler+0x3c>
		may_swap = 0;
  409e30:	90000121 	adrp	x1, 42d000 <args_struct>
  409e34:	b90bdc3f 	str	wzr, [x1, #3036]
	}

	_kernel.cpus[0].nested++;
  409e38:	f9472e81 	ldr	x1, [x20, #3672]

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
		int last_running_irq = currently_running_irq;
  409e3c:	f0000115 	adrp	x21, 42c000 <__dso_handle>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  409e40:	f0000116 	adrp	x22, 42c000 <__dso_handle>
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
		hw_irq_ctrl_clear_irq(irq_nbr);

		currently_running_irq = irq_nbr;
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;
  409e44:	910ff2b8 	add	x24, x21, #0x3fc
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  409e48:	9133a2d6 	add	x22, x22, #0xce8
	_kernel.cpus[0].nested++;
  409e4c:	11000400 	add	w0, w0, #0x1
  409e50:	b9000020 	str	w0, [x1]
	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
  409e54:	940000bd 	bl	40a148 <hw_irq_ctrl_get_highest_prio_irq>
  409e58:	2a0003f3 	mov	w19, w0
  409e5c:	3100041f 	cmn	w0, #0x1
  409e60:	540002c1 	b.ne	409eb8 <posix_irq_handler+0xbc>  // b.any

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
	}

	_kernel.cpus[0].nested--;
  409e64:	f9472e94 	ldr	x20, [x20, #3672]
  409e68:	b9400280 	ldr	w0, [x20]
  409e6c:	51000400 	sub	w0, w0, #0x1
  409e70:	b9000280 	str	w0, [x20]
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
  409e74:	90000120 	adrp	x0, 42d000 <args_struct>
  409e78:	b94bdc00 	ldr	w0, [x0, #3036]
  409e7c:	340006a0 	cbz	w0, 409f50 <posix_irq_handler+0x154>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
  409e80:	9400008f 	bl	40a0bc <hw_irq_ctrl_get_cur_prio>
  409e84:	7104001f 	cmp	w0, #0x100
  409e88:	54000641 	b.ne	409f50 <posix_irq_handler+0x154>  // b.any
		&& (_kernel.ready_q.cache != _current)) {
  409e8c:	f9400a80 	ldr	x0, [x20, #16]
  409e90:	f9401681 	ldr	x1, [x20, #40]
  409e94:	eb00003f 	cmp	x1, x0
  409e98:	540005c0 	b.eq	409f50 <posix_irq_handler+0x154>  // b.none

		(void)z_swap_irqlock(irq_lock);
	}
}
  409e9c:	a94153f3 	ldp	x19, x20, [sp, #16]

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
  409ea0:	52800000 	mov	w0, #0x0                   	// #0
  409ea4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409ea8:	a94363f7 	ldp	x23, x24, [sp, #48]
  409eac:	f94023f9 	ldr	x25, [sp, #64]
  409eb0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  409eb4:	17fffd13 	b	409300 <arch_swap>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  409eb8:	94000081 	bl	40a0bc <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;
  409ebc:	b943feb9 	ldr	w25, [x21, #1020]
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  409ec0:	2a0003f7 	mov	w23, w0
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
  409ec4:	2a1303e0 	mov	w0, w19
  409ec8:	94000084 	bl	40a0d8 <hw_irq_ctrl_get_prio>
  409ecc:	12001c00 	and	w0, w0, #0xff
  409ed0:	94000078 	bl	40a0b0 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
  409ed4:	2a1303e0 	mov	w0, w19
  409ed8:	940000bd 	bl	40a1cc <hw_irq_ctrl_clear_irq>
		currently_running_irq = irq_nbr;
  409edc:	b903feb3 	str	w19, [x21, #1020]
	sys_trace_isr_enter();
  409ee0:	97fffb9c 	bl	408d50 <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  409ee4:	93407e61 	sxtw	x1, w19
  409ee8:	d2800300 	mov	x0, #0x18                  	// #24
  409eec:	9b005821 	madd	x1, x1, x0, x22
  409ef0:	f9400422 	ldr	x2, [x1, #8]
  409ef4:	b5000142 	cbnz	x2, 409f1c <posix_irq_handler+0x120>
		posix_print_error_and_exit("Received irq %i without a "
  409ef8:	90000060 	adrp	x0, 415000 <random_data+0xca4>
  409efc:	2a1303e1 	mov	w1, w19
  409f00:	91117800 	add	x0, x0, #0x45e
  409f04:	9400013f 	bl	40a400 <posix_print_error_and_exit>
	sys_trace_isr_exit();
  409f08:	97fffb93 	bl	408d54 <sys_trace_isr_exit>
		currently_running_irq = last_running_irq;
  409f0c:	b9000319 	str	w25, [x24]
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
  409f10:	2a1703e0 	mov	w0, w23
  409f14:	94000067 	bl	40a0b0 <hw_irq_ctrl_set_cur_prio>
  409f18:	17ffffcf 	b	409e54 <posix_irq_handler+0x58>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
  409f1c:	b9400420 	ldr	w0, [x1, #4]
  409f20:	90000133 	adrp	x19, 42d000 <args_struct>
  409f24:	360000c0 	tbz	w0, #0, 409f3c <posix_irq_handler+0x140>
			*may_swap |= ((direct_irq_f_ptr)
  409f28:	d63f0040 	blr	x2
  409f2c:	b94bde61 	ldr	w1, [x19, #3036]
  409f30:	2a000021 	orr	w1, w1, w0
  409f34:	b90bde61 	str	w1, [x19, #3036]
  409f38:	17fffff4 	b	409f08 <posix_irq_handler+0x10c>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
  409f3c:	f9400820 	ldr	x0, [x1, #16]
  409f40:	d63f0040 	blr	x2
			*may_swap = 1;
  409f44:	52800020 	mov	w0, #0x1                   	// #1
  409f48:	b90bde60 	str	w0, [x19, #3036]
  409f4c:	17ffffef 	b	409f08 <posix_irq_handler+0x10c>
}
  409f50:	a94153f3 	ldp	x19, x20, [sp, #16]
  409f54:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409f58:	a94363f7 	ldp	x23, x24, [sp, #48]
  409f5c:	f94023f9 	ldr	x25, [sp, #64]
  409f60:	a8c57bfd 	ldp	x29, x30, [sp], #80
  409f64:	d65f03c0 	ret

0000000000409f68 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
  409f68:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409f6c:	910003fd 	mov	x29, sp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
  409f70:	94000076 	bl	40a148 <hw_irq_ctrl_get_highest_prio_irq>
  409f74:	3100041f 	cmn	w0, #0x1
  409f78:	54000140 	b.eq	409fa0 <posix_irq_handler_im_from_sw+0x38>  // b.none
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
  409f7c:	97fffd1f 	bl	4093f8 <posix_is_cpu_running>
  409f80:	350000c0 	cbnz	w0, 409f98 <posix_irq_handler_im_from_sw+0x30>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
  409f84:	90000061 	adrp	x1, 415000 <random_data+0xca4>
  409f88:	90000060 	adrp	x0, 415000 <random_data+0xca4>
  409f8c:	91130421 	add	x1, x1, #0x4c1
  409f90:	91123000 	add	x0, x0, #0x48c
  409f94:	9400011b 	bl	40a400 <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
  409f98:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler();
  409f9c:	17ffff98 	b	409dfc <posix_irq_handler>
}
  409fa0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  409fa4:	d65f03c0 	ret

0000000000409fa8 <posix_irq_lock>:
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
	return hw_irq_ctrl_change_lock(true);
  409fa8:	52800020 	mov	w0, #0x1                   	// #1
  409fac:	14000052 	b	40a0f4 <hw_irq_ctrl_change_lock>

0000000000409fb0 <posix_irq_unlock>:
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
  409fb0:	14000051 	b	40a0f4 <hw_irq_ctrl_change_lock>

0000000000409fb4 <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
	hw_irq_ctrl_change_lock(false);
  409fb4:	52800000 	mov	w0, #0x0                   	// #0
  409fb8:	1400004f 	b	40a0f4 <hw_irq_ctrl_change_lock>

0000000000409fbc <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
  409fbc:	140000aa 	b	40a264 <hw_irq_ctrl_enable_irq>

0000000000409fc0 <posix_isr_declare>:
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
	irq_vector_table[irq_p].irq   = irq_p;
  409fc0:	2a0003e4 	mov	w4, w0
  409fc4:	d2800306 	mov	x6, #0x18                  	// #24
  409fc8:	f0000105 	adrp	x5, 42c000 <__dso_handle>
  409fcc:	9133a0a5 	add	x5, x5, #0xce8
  409fd0:	9b067c84 	mul	x4, x4, x6
  409fd4:	8b0400a6 	add	x6, x5, x4
  409fd8:	b82468a0 	str	w0, [x5, x4]
	irq_vector_table[irq_p].func  = isr_p;
	irq_vector_table[irq_p].param = isr_param_p;
	irq_vector_table[irq_p].flags = flags;
  409fdc:	b90004c1 	str	w1, [x6, #4]
	irq_vector_table[irq_p].param = isr_param_p;
  409fe0:	a9008cc2 	stp	x2, x3, [x6, #8]
}
  409fe4:	d65f03c0 	ret

0000000000409fe8 <posix_irq_priority_set>:
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
  409fe8:	14000038 	b	40a0c8 <hw_irq_ctrl_prio_set>

0000000000409fec <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
  409fec:	b0000120 	adrp	x0, 42e000 <irq_prio+0xf>
  409ff0:	39404401 	ldrb	w1, [x0, #17]
  409ff4:	b0000120 	adrp	x0, 42e000 <irq_prio+0xf>
  409ff8:	34000061 	cbz	w1, 40a004 <irq_raising_from_hw_now+0x18>
  409ffc:	39404801 	ldrb	w1, [x0, #18]
  40a000:	34000061 	cbz	w1, 40a00c <irq_raising_from_hw_now+0x20>
		lock_ignore = false;
  40a004:	3900481f 	strb	wzr, [x0, #18]
		posix_interrupt_raised();
  40a008:	17fffd27 	b	4094a4 <posix_interrupt_raised>
	}
}
  40a00c:	d65f03c0 	ret

000000000040a010 <hw_irq_ctrl_irq_raise_prefix>:
	if (irq < N_IRQS) {
  40a010:	71007c1f 	cmp	w0, #0x1f
  40a014:	54000248 	b.hi	40a05c <hw_irq_ctrl_irq_raise_prefix+0x4c>  // b.pmore
		irq_premask |= ((uint64_t)1<<irq);
  40a018:	d2800021 	mov	x1, #0x1                   	// #1
  40a01c:	d0000104 	adrp	x4, 42c000 <__dso_handle>
  40a020:	9ac02023 	lsl	x3, x1, x0
		if (irq_mask & (1 << irq)) {
  40a024:	1ac02021 	lsl	w1, w1, w0
  40a028:	d0000100 	adrp	x0, 42c000 <__dso_handle>
		irq_premask |= ((uint64_t)1<<irq);
  40a02c:	f947f882 	ldr	x2, [x4, #4080]
		if (irq_mask & (1 << irq)) {
  40a030:	93407c21 	sxtw	x1, w1
  40a034:	f947f400 	ldr	x0, [x0, #4072]
		irq_premask |= ((uint64_t)1<<irq);
  40a038:	aa030042 	orr	x2, x2, x3
  40a03c:	f907f882 	str	x2, [x4, #4080]
		if (irq_mask & (1 << irq)) {
  40a040:	ea00003f 	tst	x1, x0
  40a044:	540000a0 	b.eq	40a058 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.none
			irq_status |= ((uint64_t)1<<irq);
  40a048:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a04c:	f947fc20 	ldr	x0, [x1, #4088]
  40a050:	aa030000 	orr	x0, x0, x3
  40a054:	f907fc20 	str	x0, [x1, #4088]
}
  40a058:	d65f03c0 	ret
	} else if (irq == PHONY_HARD_IRQ) {
  40a05c:	529fffe1 	mov	w1, #0xffff                	// #65535
  40a060:	6b01001f 	cmp	w0, w1
  40a064:	54ffffa1 	b.ne	40a058 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.any
		lock_ignore = true;
  40a068:	90000120 	adrp	x0, 42e000 <irq_prio+0xf>
  40a06c:	52800021 	mov	w1, #0x1                   	// #1
  40a070:	39004801 	strb	w1, [x0, #18]
}
  40a074:	17fffff9 	b	40a058 <hw_irq_ctrl_irq_raise_prefix+0x48>

000000000040a078 <hw_irq_ctrl_init>:
		irq_prio[i] = 255U;
  40a078:	6f000400 	mvni	v0.4s, #0x0
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
  40a07c:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a080:	f907f41f 	str	xzr, [x0, #4072]
	irq_premask = 0U;
  40a084:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a088:	f907f81f 	str	xzr, [x0, #4080]
	irqs_locked = false;
  40a08c:	90000120 	adrp	x0, 42e000 <irq_prio+0xf>
  40a090:	3900441f 	strb	wzr, [x0, #17]
	lock_ignore = false;
  40a094:	90000120 	adrp	x0, 42e000 <irq_prio+0xf>
  40a098:	3900481f 	strb	wzr, [x0, #18]
		irq_prio[i] = 255U;
  40a09c:	f0000100 	adrp	x0, 42d000 <args_struct>
  40a0a0:	913fc400 	add	x0, x0, #0xff1
  40a0a4:	ad000000 	stp	q0, q0, [x0]
}
  40a0a8:	d65f03c0 	ret

000000000040a0ac <hw_irq_ctrl_cleanup>:
}
  40a0ac:	d65f03c0 	ret

000000000040a0b0 <hw_irq_ctrl_set_cur_prio>:
	currently_running_prio = new;
  40a0b0:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a0b4:	b9040020 	str	w0, [x1, #1024]
}
  40a0b8:	d65f03c0 	ret

000000000040a0bc <hw_irq_ctrl_get_cur_prio>:
}
  40a0bc:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a0c0:	b9440000 	ldr	w0, [x0, #1024]
  40a0c4:	d65f03c0 	ret

000000000040a0c8 <hw_irq_ctrl_prio_set>:
	irq_prio[irq] = prio;
  40a0c8:	f0000102 	adrp	x2, 42d000 <args_struct>
  40a0cc:	913fc442 	add	x2, x2, #0xff1
  40a0d0:	38204841 	strb	w1, [x2, w0, uxtw]
}
  40a0d4:	d65f03c0 	ret

000000000040a0d8 <hw_irq_ctrl_get_prio>:
}
  40a0d8:	f0000101 	adrp	x1, 42d000 <args_struct>
  40a0dc:	913fc421 	add	x1, x1, #0xff1
  40a0e0:	38604820 	ldrb	w0, [x1, w0, uxtw]
  40a0e4:	d65f03c0 	ret

000000000040a0e8 <hw_irq_ctrl_get_current_lock>:
}
  40a0e8:	90000120 	adrp	x0, 42e000 <irq_prio+0xf>
  40a0ec:	39404400 	ldrb	w0, [x0, #17]
  40a0f0:	d65f03c0 	ret

000000000040a0f4 <hw_irq_ctrl_change_lock>:
{
  40a0f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t previous_lock = irqs_locked;
  40a0f8:	90000121 	adrp	x1, 42e000 <irq_prio+0xf>
	irqs_locked = new_lock;
  40a0fc:	7100001f 	cmp	w0, #0x0
{
  40a100:	910003fd 	mov	x29, sp
	irqs_locked = new_lock;
  40a104:	1a9f07e0 	cset	w0, ne  // ne = any
{
  40a108:	f9000bf3 	str	x19, [sp, #16]
	uint32_t previous_lock = irqs_locked;
  40a10c:	39404433 	ldrb	w19, [x1, #17]
	irqs_locked = new_lock;
  40a110:	39004420 	strb	w0, [x1, #17]
	if ((previous_lock == true) && (new_lock == false)) {
  40a114:	7a400a64 	ccmp	w19, #0x0, #0x4, eq  // eq = none
  40a118:	540000a0 	b.eq	40a12c <hw_irq_ctrl_change_lock+0x38>  // b.none
		if (irq_status != 0U) {
  40a11c:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a120:	f947fc00 	ldr	x0, [x0, #4088]
  40a124:	b4000040 	cbz	x0, 40a12c <hw_irq_ctrl_change_lock+0x38>
			posix_irq_handler_im_from_sw();
  40a128:	97ffff90 	bl	409f68 <posix_irq_handler_im_from_sw>
}
  40a12c:	2a1303e0 	mov	w0, w19
  40a130:	f9400bf3 	ldr	x19, [sp, #16]
  40a134:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a138:	d65f03c0 	ret

000000000040a13c <hw_irq_ctrl_get_irq_status>:
}
  40a13c:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a140:	f947fc00 	ldr	x0, [x0, #4088]
  40a144:	d65f03c0 	ret

000000000040a148 <hw_irq_ctrl_get_highest_prio_irq>:
	if (irqs_locked) {
  40a148:	90000120 	adrp	x0, 42e000 <irq_prio+0xf>
  40a14c:	39404400 	ldrb	w0, [x0, #17]
  40a150:	350003a0 	cbnz	w0, 40a1c4 <hw_irq_ctrl_get_highest_prio_irq+0x7c>
{
  40a154:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a158:	910003fd 	mov	x29, sp
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
  40a15c:	97fffff8 	bl	40a13c <hw_irq_ctrl_get_irq_status>
  40a160:	aa0003e2 	mov	x2, x0
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a164:	d0000100 	adrp	x0, 42c000 <__dso_handle>
		if ((winner_prio > (int)irq_prio[irq_nbr])
  40a168:	f0000104 	adrp	x4, 42d000 <args_struct>
  40a16c:	913fc484 	add	x4, x4, #0xff1
	int winner_prio = 256;
  40a170:	52802003 	mov	w3, #0x100                 	// #256
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a174:	b9440006 	ldr	w6, [x0, #1024]
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  40a178:	d2800027 	mov	x7, #0x1                   	// #1
	int winner = -1;
  40a17c:	12800000 	mov	w0, #0xffffffff            	// #-1
	while (irq_status != 0U) {
  40a180:	b5000062 	cbnz	x2, 40a18c <hw_irq_ctrl_get_highest_prio_irq+0x44>
}
  40a184:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a188:	d65f03c0 	ret
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
  40a18c:	5ac00041 	rbit	w1, w2
  40a190:	7100005f 	cmp	w2, #0x0
  40a194:	5ac01021 	clz	w1, w1
  40a198:	1a8107e1 	csinc	w1, wzr, w1, eq  // eq = none
		int irq_nbr = find_lsb_set(irq_status) - 1;
  40a19c:	51000421 	sub	w1, w1, #0x1
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  40a1a0:	9ac120e5 	lsl	x5, x7, x1
  40a1a4:	8a250042 	bic	x2, x2, x5
		if ((winner_prio > (int)irq_prio[irq_nbr])
  40a1a8:	3861c885 	ldrb	w5, [x4, w1, sxtw]
  40a1ac:	6b0300bf 	cmp	w5, w3
  40a1b0:	54fffe8a 	b.ge	40a180 <hw_irq_ctrl_get_highest_prio_irq+0x38>  // b.tcont
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a1b4:	6b0600bf 	cmp	w5, w6
  40a1b8:	1a85a063 	csel	w3, w3, w5, ge  // ge = tcont
  40a1bc:	1a81a000 	csel	w0, w0, w1, ge  // ge = tcont
  40a1c0:	17fffff0 	b	40a180 <hw_irq_ctrl_get_highest_prio_irq+0x38>
		return -1;
  40a1c4:	12800000 	mov	w0, #0xffffffff            	// #-1
}
  40a1c8:	d65f03c0 	ret

000000000040a1cc <hw_irq_ctrl_clear_irq>:
	irq_status  &= ~((uint64_t)1<<irq);
  40a1cc:	d0000102 	adrp	x2, 42c000 <__dso_handle>
  40a1d0:	d2800021 	mov	x1, #0x1                   	// #1
  40a1d4:	9ac02020 	lsl	x0, x1, x0
  40a1d8:	f947fc41 	ldr	x1, [x2, #4088]
  40a1dc:	8a200021 	bic	x1, x1, x0
  40a1e0:	f907fc41 	str	x1, [x2, #4088]
	irq_premask &= ~((uint64_t)1<<irq);
  40a1e4:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a1e8:	f947f822 	ldr	x2, [x1, #4080]
  40a1ec:	8a200040 	bic	x0, x2, x0
  40a1f0:	f907f820 	str	x0, [x1, #4080]
}
  40a1f4:	d65f03c0 	ret

000000000040a1f8 <hw_irq_ctrl_set_irq>:
{
  40a1f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a1fc:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  40a200:	97ffff84 	bl	40a010 <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
  40a204:	90000120 	adrp	x0, 42e000 <irq_prio+0xf>
  40a208:	39404400 	ldrb	w0, [x0, #17]
  40a20c:	34000080 	cbz	w0, 40a21c <hw_irq_ctrl_set_irq+0x24>
  40a210:	90000120 	adrp	x0, 42e000 <irq_prio+0xf>
  40a214:	39404800 	ldrb	w0, [x0, #18]
  40a218:	340000e0 	cbz	w0, 40a234 <hw_irq_ctrl_set_irq+0x3c>
		irq_ctrl_timer = hwm_get_time();
  40a21c:	97fffdb5 	bl	4098f0 <hwm_get_time>
  40a220:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40a224:	f9478c21 	ldr	x1, [x1, #3864]
  40a228:	f9000020 	str	x0, [x1]
}
  40a22c:	a8c17bfd 	ldp	x29, x30, [sp], #16
		hwm_find_next_timer();
  40a230:	17fffd60 	b	4097b0 <hwm_find_next_timer>
}
  40a234:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a238:	d65f03c0 	ret

000000000040a23c <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
  40a23c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a240:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  40a244:	97ffff73 	bl	40a010 <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
  40a248:	90000120 	adrp	x0, 42e000 <irq_prio+0xf>
  40a24c:	39404400 	ldrb	w0, [x0, #17]
  40a250:	35000060 	cbnz	w0, 40a25c <hw_irq_ctrl_raise_im_from_sw+0x20>
		posix_irq_handler_im_from_sw();
	}
}
  40a254:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler_im_from_sw();
  40a258:	17ffff44 	b	409f68 <posix_irq_handler_im_from_sw>
}
  40a25c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a260:	d65f03c0 	ret

000000000040a264 <hw_irq_ctrl_enable_irq>:
	irq_mask |= ((uint64_t)1<<irq);
  40a264:	d0000103 	adrp	x3, 42c000 <__dso_handle>
  40a268:	d2800021 	mov	x1, #0x1                   	// #1
  40a26c:	9ac02021 	lsl	x1, x1, x0
  40a270:	f947f464 	ldr	x4, [x3, #4072]
  40a274:	aa040021 	orr	x1, x1, x4
  40a278:	f907f461 	str	x1, [x3, #4072]
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
  40a27c:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a280:	f947f821 	ldr	x1, [x1, #4080]
  40a284:	9ac02421 	lsr	x1, x1, x0
  40a288:	36000041 	tbz	w1, #0, 40a290 <hw_irq_ctrl_enable_irq+0x2c>
		hw_irq_ctrl_raise_im_from_sw(irq);
  40a28c:	17ffffec 	b	40a23c <hw_irq_ctrl_raise_im_from_sw>
}
  40a290:	d65f03c0 	ret

000000000040a294 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
  40a294:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40a298:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40a29c:	f9478c00 	ldr	x0, [x0, #3864]
  40a2a0:	f9000001 	str	x1, [x0]
	irq_raising_from_hw_now();
  40a2a4:	17ffff52 	b	409fec <irq_raising_from_hw_now>

000000000040a2a8 <posix_exit>:
#include <zephyr/sys/time_units.h>
#include "cmdline.h"
#include "irq_ctrl.h"

void posix_exit(int exit_code)
{
  40a2a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a2ac:	910003fd 	mov	x29, sp
  40a2b0:	f9000bf3 	str	x19, [sp, #16]
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
  40a2b4:	f0000113 	adrp	x19, 42d000 <args_struct>
  40a2b8:	b94be261 	ldr	w1, [x19, #3040]
  40a2bc:	6b00003f 	cmp	w1, w0
  40a2c0:	1a80a021 	csel	w1, w1, w0, ge  // ge = tcont
  40a2c4:	b90be261 	str	w1, [x19, #3040]
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
  40a2c8:	97fffcd5 	bl	40961c <posix_soc_clean_up>
	hwm_cleanup();
  40a2cc:	97fffd94 	bl	40991c <hwm_cleanup>
	native_cleanup_cmd_line();
  40a2d0:	9400030e 	bl	40af08 <native_cleanup_cmd_line>
	exit(max_exit_code);
  40a2d4:	b94be260 	ldr	w0, [x19, #3040]
  40a2d8:	97ffdbb6 	bl	4011b0 <exit@plt>

000000000040a2dc <posix_init>:
 * Run all early native_posix initialization steps, including command
 * line parsing and CPU start, until we are ready to let the HW models
 * run via hwm_one_event()
 */
void posix_init(int argc, char *argv[])
{
  40a2dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	 * Let's ensure that even if we are redirecting to a file, we get stdout
	 * and stderr line buffered (default for console)
	 * Note that glibc ignores size. But just in case we set a reasonable
	 * number in case somebody tries to compile against a different library
	 */
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a2e0:	d2804003 	mov	x3, #0x200                 	// #512
  40a2e4:	52800022 	mov	w2, #0x1                   	// #1
{
  40a2e8:	910003fd 	mov	x29, sp
  40a2ec:	a90153f3 	stp	x19, x20, [sp, #16]
  40a2f0:	2a0003f3 	mov	w19, w0
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a2f4:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
{
  40a2f8:	aa0103f4 	mov	x20, x1
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a2fc:	d2800001 	mov	x1, #0x0                   	// #0
  40a300:	f9474000 	ldr	x0, [x0, #3712]
  40a304:	f9400000 	ldr	x0, [x0]
  40a308:	97ffdbca 	bl	401230 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
  40a30c:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40a310:	d2804003 	mov	x3, #0x200                 	// #512
  40a314:	52800022 	mov	w2, #0x1                   	// #1
  40a318:	d2800001 	mov	x1, #0x0                   	// #0
  40a31c:	f9471800 	ldr	x0, [x0, #3632]
  40a320:	f9400000 	ldr	x0, [x0]
  40a324:	97ffdbc3 	bl	401230 <setvbuf@plt>

	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
  40a328:	52800000 	mov	w0, #0x0                   	// #0
  40a32c:	97fffcaa 	bl	4095d4 <run_native_tasks>

	native_handle_cmd_line(argc, argv);
  40a330:	aa1403e1 	mov	x1, x20
  40a334:	2a1303e0 	mov	w0, w19
  40a338:	94000335 	bl	40b00c <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
  40a33c:	52800020 	mov	w0, #0x1                   	// #1
  40a340:	97fffca5 	bl	4095d4 <run_native_tasks>

	hwm_init();
  40a344:	97fffd6e 	bl	4098fc <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
  40a348:	52800040 	mov	w0, #0x2                   	// #2
  40a34c:	97fffca2 	bl	4095d4 <run_native_tasks>

	posix_boot_cpu();
  40a350:	97fffc67 	bl	4094ec <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
}
  40a354:	a94153f3 	ldp	x19, x20, [sp, #16]
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  40a358:	52800060 	mov	w0, #0x3                   	// #3
}
  40a35c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  40a360:	17fffc9d 	b	4095d4 <run_native_tasks>

000000000040a364 <main>:
 *
 * Not used when building fuzz cases, as libfuzzer has its own main()
 * and calls the "OS" through a per-case fuzz test entry point.
 */
int main(int argc, char *argv[])
{
  40a364:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a368:	910003fd 	mov	x29, sp
	posix_init(argc, argv);
  40a36c:	97ffffdc 	bl	40a2dc <posix_init>
	while (true) {
		hwm_one_event();
  40a370:	97fffd29 	bl	409814 <hwm_one_event>
	while (true) {
  40a374:	17ffffff 	b	40a370 <main+0xc>

000000000040a378 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
  40a378:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a37c:	91101000 	add	x0, x0, #0x404
  40a380:	f900001f 	str	xzr, [x0]
	is_a_tty[1] = 0;
}
  40a384:	d65f03c0 	ret

000000000040a388 <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
  40a388:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a38c:	91101000 	add	x0, x0, #0x404
  40a390:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40a394:	f9000001 	str	x1, [x0]
	is_a_tty[1] = -1;

}
  40a398:	d65f03c0 	ret

000000000040a39c <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
  40a39c:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a3a0:	91101000 	add	x0, x0, #0x404
  40a3a4:	b20003e1 	mov	x1, #0x100000001           	// #4294967297
  40a3a8:	f9000001 	str	x1, [x0]
	is_a_tty[1] = 1;
}
  40a3ac:	d65f03c0 	ret

000000000040a3b0 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
  40a3b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a3b4:	910003fd 	mov	x29, sp
  40a3b8:	f9000bf3 	str	x19, [sp, #16]
	if (is_a_tty[0] == -1) {
  40a3bc:	d0000113 	adrp	x19, 42c000 <__dso_handle>
  40a3c0:	b9440660 	ldr	w0, [x19, #1028]
  40a3c4:	3100041f 	cmn	w0, #0x1
  40a3c8:	54000081 	b.ne	40a3d8 <decide_about_color+0x28>  // b.any
		is_a_tty[0] = isatty(STDOUT_FILENO);
  40a3cc:	52800020 	mov	w0, #0x1                   	// #1
  40a3d0:	97ffdc1c 	bl	401440 <isatty@plt>
  40a3d4:	b9040660 	str	w0, [x19, #1028]
	}
	if (is_a_tty[1] == -1) {
  40a3d8:	91101273 	add	x19, x19, #0x404
  40a3dc:	b9400660 	ldr	w0, [x19, #4]
  40a3e0:	3100041f 	cmn	w0, #0x1
  40a3e4:	54000081 	b.ne	40a3f4 <decide_about_color+0x44>  // b.any
		is_a_tty[1] = isatty(STDERR_FILENO);
  40a3e8:	52800040 	mov	w0, #0x2                   	// #2
  40a3ec:	97ffdc15 	bl	401440 <isatty@plt>
  40a3f0:	b9000660 	str	w0, [x19, #4]
	}
}
  40a3f4:	f9400bf3 	ldr	x19, [sp, #16]
  40a3f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a3fc:	d65f03c0 	ret

000000000040a400 <posix_print_error_and_exit>:
{
  40a400:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a404:	aa0003e8 	mov	x8, x0
  40a408:	910003fd 	mov	x29, sp
  40a40c:	a9108be1 	stp	x1, x2, [sp, #264]
  40a410:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
  40a414:	aa0803e2 	mov	x2, x8
  40a418:	f9476821 	ldr	x1, [x1, #3792]
  40a41c:	3d8023e0 	str	q0, [sp, #128]
  40a420:	3d8027e1 	str	q1, [sp, #144]
  40a424:	3d802be2 	str	q2, [sp, #160]
  40a428:	3d802fe3 	str	q3, [sp, #176]
  40a42c:	3d8033e4 	str	q4, [sp, #192]
  40a430:	3d8037e5 	str	q5, [sp, #208]
  40a434:	3d803be6 	str	q6, [sp, #224]
  40a438:	3d803fe7 	str	q7, [sp, #240]
  40a43c:	a91193e3 	stp	x3, x4, [sp, #280]
  40a440:	910043e3 	add	x3, sp, #0x10
  40a444:	a9129be5 	stp	x5, x6, [sp, #296]
  40a448:	f9009fe7 	str	x7, [sp, #312]
  40a44c:	f9400020 	ldr	x0, [x1]
  40a450:	f9003fe0 	str	x0, [sp, #120]
  40a454:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  40a458:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
	va_start(variable_args, format);
  40a45c:	910503e0 	add	x0, sp, #0x140
  40a460:	a90383e0 	stp	x0, x0, [sp, #56]
  40a464:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  40a468:	f9471821 	ldr	x1, [x1, #3632]
	va_start(variable_args, format);
  40a46c:	f90027e0 	str	x0, [sp, #72]
  40a470:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a474:	b90053e0 	str	w0, [sp, #80]
  40a478:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a47c:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  40a480:	f9400020 	ldr	x0, [x1]
  40a484:	9100e3e1 	add	x1, sp, #0x38
  40a488:	ad400420 	ldp	q0, q1, [x1]
  40a48c:	910163e1 	add	x1, sp, #0x58
  40a490:	ad000420 	stp	q0, q1, [x1]
  40a494:	52800021 	mov	w1, #0x1                   	// #1
  40a498:	ad000460 	stp	q0, q1, [x3]
  40a49c:	97ffdb89 	bl	4012c0 <__vfprintf_chk@plt>
	posix_exit(1);
  40a4a0:	52800020 	mov	w0, #0x1                   	// #1
  40a4a4:	97ffff81 	bl	40a2a8 <posix_exit>
}
  40a4a8:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40a4ac:	f9476800 	ldr	x0, [x0, #3792]
  40a4b0:	f9403fe2 	ldr	x2, [sp, #120]
  40a4b4:	f9400001 	ldr	x1, [x0]
  40a4b8:	eb010042 	subs	x2, x2, x1
  40a4bc:	d2800001 	mov	x1, #0x0                   	// #0
  40a4c0:	54000040 	b.eq	40a4c8 <posix_print_error_and_exit+0xc8>  // b.none
  40a4c4:	97ffdb97 	bl	401320 <__stack_chk_fail@plt>
  40a4c8:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a4cc:	d65f03c0 	ret

000000000040a4d0 <posix_print_warning>:
{
  40a4d0:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a4d4:	aa0003e8 	mov	x8, x0
  40a4d8:	910003fd 	mov	x29, sp
  40a4dc:	a9108be1 	stp	x1, x2, [sp, #264]
  40a4e0:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40a4e4:	aa0803e2 	mov	x2, x8
  40a4e8:	f9476821 	ldr	x1, [x1, #3792]
  40a4ec:	3d8023e0 	str	q0, [sp, #128]
  40a4f0:	3d8027e1 	str	q1, [sp, #144]
  40a4f4:	3d802be2 	str	q2, [sp, #160]
  40a4f8:	3d802fe3 	str	q3, [sp, #176]
  40a4fc:	3d8033e4 	str	q4, [sp, #192]
  40a500:	3d8037e5 	str	q5, [sp, #208]
  40a504:	3d803be6 	str	q6, [sp, #224]
  40a508:	3d803fe7 	str	q7, [sp, #240]
  40a50c:	a91193e3 	stp	x3, x4, [sp, #280]
  40a510:	910043e3 	add	x3, sp, #0x10
  40a514:	a9129be5 	stp	x5, x6, [sp, #296]
  40a518:	f9009fe7 	str	x7, [sp, #312]
  40a51c:	f9400020 	ldr	x0, [x1]
  40a520:	f9003fe0 	str	x0, [sp, #120]
  40a524:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  40a528:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
	va_start(variable_args, format);
  40a52c:	910503e0 	add	x0, sp, #0x140
  40a530:	a90383e0 	stp	x0, x0, [sp, #56]
  40a534:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  40a538:	f9471821 	ldr	x1, [x1, #3632]
	va_start(variable_args, format);
  40a53c:	f90027e0 	str	x0, [sp, #72]
  40a540:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a544:	b90053e0 	str	w0, [sp, #80]
  40a548:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a54c:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  40a550:	f9400020 	ldr	x0, [x1]
  40a554:	9100e3e1 	add	x1, sp, #0x38
  40a558:	ad400420 	ldp	q0, q1, [x1]
  40a55c:	910163e1 	add	x1, sp, #0x58
  40a560:	ad000420 	stp	q0, q1, [x1]
  40a564:	52800021 	mov	w1, #0x1                   	// #1
  40a568:	ad000460 	stp	q0, q1, [x3]
  40a56c:	97ffdb55 	bl	4012c0 <__vfprintf_chk@plt>
}
  40a570:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40a574:	f9476800 	ldr	x0, [x0, #3792]
  40a578:	f9403fe2 	ldr	x2, [sp, #120]
  40a57c:	f9400001 	ldr	x1, [x0]
  40a580:	eb010042 	subs	x2, x2, x1
  40a584:	d2800001 	mov	x1, #0x0                   	// #0
  40a588:	54000040 	b.eq	40a590 <posix_print_warning+0xc0>  // b.none
  40a58c:	97ffdb65 	bl	401320 <__stack_chk_fail@plt>
  40a590:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a594:	d65f03c0 	ret

000000000040a598 <posix_print_trace>:
{
  40a598:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a59c:	aa0003e8 	mov	x8, x0
  40a5a0:	910003fd 	mov	x29, sp
  40a5a4:	a9108be1 	stp	x1, x2, [sp, #264]
  40a5a8:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40a5ac:	aa0803e2 	mov	x2, x8
  40a5b0:	f9476821 	ldr	x1, [x1, #3792]
  40a5b4:	3d8023e0 	str	q0, [sp, #128]
  40a5b8:	3d8027e1 	str	q1, [sp, #144]
  40a5bc:	3d802be2 	str	q2, [sp, #160]
  40a5c0:	3d802fe3 	str	q3, [sp, #176]
  40a5c4:	3d8033e4 	str	q4, [sp, #192]
  40a5c8:	3d8037e5 	str	q5, [sp, #208]
  40a5cc:	3d803be6 	str	q6, [sp, #224]
  40a5d0:	3d803fe7 	str	q7, [sp, #240]
  40a5d4:	a91193e3 	stp	x3, x4, [sp, #280]
  40a5d8:	910043e3 	add	x3, sp, #0x10
  40a5dc:	a9129be5 	stp	x5, x6, [sp, #296]
  40a5e0:	f9009fe7 	str	x7, [sp, #312]
  40a5e4:	f9400020 	ldr	x0, [x1]
  40a5e8:	f9003fe0 	str	x0, [sp, #120]
  40a5ec:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stdout, format, variable_args);
  40a5f0:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
	va_start(variable_args, format);
  40a5f4:	910503e0 	add	x0, sp, #0x140
  40a5f8:	a90383e0 	stp	x0, x0, [sp, #56]
  40a5fc:	910403e0 	add	x0, sp, #0x100
	vfprintf(stdout, format, variable_args);
  40a600:	f9474021 	ldr	x1, [x1, #3712]
	va_start(variable_args, format);
  40a604:	f90027e0 	str	x0, [sp, #72]
  40a608:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a60c:	b90053e0 	str	w0, [sp, #80]
  40a610:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a614:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stdout, format, variable_args);
  40a618:	f9400020 	ldr	x0, [x1]
  40a61c:	9100e3e1 	add	x1, sp, #0x38
  40a620:	ad400420 	ldp	q0, q1, [x1]
  40a624:	910163e1 	add	x1, sp, #0x58
  40a628:	ad000420 	stp	q0, q1, [x1]
  40a62c:	52800021 	mov	w1, #0x1                   	// #1
  40a630:	ad000460 	stp	q0, q1, [x3]
  40a634:	97ffdb23 	bl	4012c0 <__vfprintf_chk@plt>
}
  40a638:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40a63c:	f9476800 	ldr	x0, [x0, #3792]
  40a640:	f9403fe2 	ldr	x2, [sp, #120]
  40a644:	f9400001 	ldr	x1, [x0]
  40a648:	eb010042 	subs	x2, x2, x1
  40a64c:	d2800001 	mov	x1, #0x0                   	// #0
  40a650:	54000040 	b.eq	40a658 <posix_print_trace+0xc0>  // b.none
  40a654:	97ffdb33 	bl	401320 <__stack_chk_fail@plt>
  40a658:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a65c:	d65f03c0 	ret

000000000040a660 <native_add_tracing_options>:
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
  40a660:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a664:	9107c000 	add	x0, x0, #0x1f0
  40a668:	14000233 	b	40af34 <native_add_command_line_opts>

000000000040a66c <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
  40a66c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a670:	910003fd 	mov	x29, sp
  40a674:	a90153f3 	stp	x19, x20, [sp, #16]
  40a678:	aa0003f4 	mov	x20, x0
  40a67c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a680:	aa0103f6 	mov	x22, x1

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
  40a684:	39400420 	ldrb	w0, [x1, #1]
  40a688:	35000440 	cbnz	w0, 40a710 <cmd_gen_switch_syntax.constprop.0+0xa4>
		*buf++ = '[';
  40a68c:	52800b60 	mov	w0, #0x5b                  	// #91
		size--;
  40a690:	528008b5 	mov	w21, #0x45                  	// #69
		*buf++ = '[';
  40a694:	38001680 	strb	w0, [x20], #1
	}

	if (args_s_el->is_switch == true) {
  40a698:	39400ac0 	ldrb	w0, [x22, #2]
		ret = snprintf(buf, size, "-%s", args_s_el->option);
  40a69c:	93407ea1 	sxtw	x1, w21
  40a6a0:	f94006c5 	ldr	x5, [x22, #8]
	if (args_s_el->is_switch == true) {
  40a6a4:	340003a0 	cbz	w0, 40a718 <cmd_gen_switch_syntax.constprop.0+0xac>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40a6a8:	f0000044 	adrp	x4, 415000 <random_data+0xca4>
  40a6ac:	aa1403e0 	mov	x0, x20
  40a6b0:	91165884 	add	x4, x4, #0x596
  40a6b4:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40a6b8:	52800022 	mov	w2, #0x1                   	// #1
  40a6bc:	97ffdae9 	bl	401260 <__snprintf_chk@plt>
  40a6c0:	2a0003f3 	mov	w19, w0
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
  40a6c4:	36f800e0 	tbz	w0, #31, 40a6e0 <cmd_gen_switch_syntax.constprop.0+0x74>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
  40a6c8:	f0000041 	adrp	x1, 415000 <random_data+0xca4>
  40a6cc:	f0000040 	adrp	x0, 415000 <random_data+0xca4>
  40a6d0:	9116bc21 	add	x1, x1, #0x5af
  40a6d4:	9117b400 	add	x0, x0, #0x5ed
  40a6d8:	528020e2 	mov	w2, #0x107                 	// #263
  40a6dc:	97ffff49 	bl	40a400 <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
  40a6e0:	6b1302a1 	subs	w1, w21, w19
  40a6e4:	540003c4 	b.mi	40a75c <cmd_gen_switch_syntax.constprop.0+0xf0>  // b.first
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
  40a6e8:	394006c2 	ldrb	w2, [x22, #1]
	buf += ret;
  40a6ec:	8b33c280 	add	x0, x20, w19, sxtw
		snprintf(buf, size, "] ");
  40a6f0:	93407c21 	sxtw	x1, w1
	if (args_s_el->is_mandatory == false) {
  40a6f4:	350002e2 	cbnz	w2, 40a750 <cmd_gen_switch_syntax.constprop.0+0xe4>
  40a6f8:	d0000042 	adrp	x2, 414000 <dlc_table.0+0x78d>
  40a6fc:	9130a842 	add	x2, x2, #0xc2a
	} else {
		snprintf(buf, size, " ");
	}
}
  40a700:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a704:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a708:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a70c:	17ffdacd 	b	401240 <snprintf@plt>
  40a710:	528008d5 	mov	w21, #0x46                  	// #70
  40a714:	17ffffe1 	b	40a698 <cmd_gen_switch_syntax.constprop.0+0x2c>
		if (args_s_el->type != 'l') {
  40a718:	394062c0 	ldrb	w0, [x22, #24]
			ret = snprintf(buf, size, "-%s=<%s>",
  40a71c:	f9400ac6 	ldr	x6, [x22, #16]
		if (args_s_el->type != 'l') {
  40a720:	7101b01f 	cmp	w0, #0x6c
  40a724:	54000100 	b.eq	40a744 <cmd_gen_switch_syntax.constprop.0+0xd8>  // b.none
  40a728:	f0000044 	adrp	x4, 415000 <random_data+0xca4>
  40a72c:	91166884 	add	x4, x4, #0x59a
  40a730:	aa1403e0 	mov	x0, x20
  40a734:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40a738:	52800022 	mov	w2, #0x1                   	// #1
  40a73c:	97ffdac9 	bl	401260 <__snprintf_chk@plt>
  40a740:	17ffffe0 	b	40a6c0 <cmd_gen_switch_syntax.constprop.0+0x54>
  40a744:	f0000044 	adrp	x4, 415000 <random_data+0xca4>
  40a748:	91168c84 	add	x4, x4, #0x5a3
  40a74c:	17fffff9 	b	40a730 <cmd_gen_switch_syntax.constprop.0+0xc4>
  40a750:	d0000042 	adrp	x2, 414000 <dlc_table.0+0x78d>
  40a754:	91312842 	add	x2, x2, #0xc4a
  40a758:	17ffffea 	b	40a700 <cmd_gen_switch_syntax.constprop.0+0x94>
}
  40a75c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a760:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a764:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a768:	d65f03c0 	ret

000000000040a76c <cmd_is_option>:
{
  40a76c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40a770:	910003fd 	mov	x29, sp
  40a774:	a90153f3 	stp	x19, x20, [sp, #16]
  40a778:	aa0003f4 	mov	x20, x0
  40a77c:	2a0203f3 	mov	w19, w2
	size_t to_match_len = strlen(option);
  40a780:	aa0103e0 	mov	x0, x1
{
  40a784:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a788:	aa0103f5 	mov	x21, x1
  40a78c:	f9001bf7 	str	x23, [sp, #48]
	size_t to_match_len = strlen(option);
  40a790:	97ffda84 	bl	4011a0 <strlen@plt>
  40a794:	aa0003f7 	mov	x23, x0
	if (arg[of] == '-') {
  40a798:	39400280 	ldrb	w0, [x20]
  40a79c:	7100b41f 	cmp	w0, #0x2d
	if (arg[of] == '-') {
  40a7a0:	9a9f17e0 	cset	x0, eq  // eq = none
	if (arg[of] == '-') {
  40a7a4:	1a9f17f6 	cset	w22, eq  // eq = none
	if (arg[of] == '-') {
  40a7a8:	38606a80 	ldrb	w0, [x20, x0]
		of++;
  40a7ac:	7100b41f 	cmp	w0, #0x2d
  40a7b0:	1a9616d6 	cinc	w22, w22, eq  // eq = none
	if (!with_value) {
  40a7b4:	93407ec2 	sxtw	x2, w22
  40a7b8:	34000293 	cbz	w19, 40a808 <cmd_is_option+0x9c>
		if (*option == 0) {
  40a7bc:	cb0202b5 	sub	x21, x21, x2
	while (!(arg[of] == 0 && *option == 0)) {
  40a7c0:	38626a80 	ldrb	w0, [x20, x2]
  40a7c4:	2a0203f3 	mov	w19, w2
		if (*option == 0) {
  40a7c8:	38626aa1 	ldrb	w1, [x21, x2]
	while (!(arg[of] == 0 && *option == 0)) {
  40a7cc:	2a010003 	orr	w3, w0, w1
  40a7d0:	34000123 	cbz	w3, 40a7f4 <cmd_is_option+0x88>
		if (*option == 0) {
  40a7d4:	35000301 	cbnz	w1, 40a834 <cmd_is_option+0xc8>
			if ((arg[of] == ':') || (arg[of] == '=')) {
  40a7d8:	7100e81f 	cmp	w0, #0x3a
  40a7dc:	528007a1 	mov	w1, #0x3d                  	// #61
  40a7e0:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40a7e4:	540002e1 	b.ne	40a840 <cmd_is_option+0xd4>  // b.any
				of++;
  40a7e8:	11000673 	add	w19, w19, #0x1
	if (arg[of] == 0) { /* we need a value to follow */
  40a7ec:	3873ca80 	ldrb	w0, [x20, w19, sxtw]
  40a7f0:	35000160 	cbnz	w0, 40a81c <cmd_is_option+0xb0>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
  40a7f4:	aa1403e1 	mov	x1, x20
  40a7f8:	f0000040 	adrp	x0, 415000 <random_data+0xca4>
  40a7fc:	91182000 	add	x0, x0, #0x608
  40a800:	97ffff00 	bl	40a400 <posix_print_error_and_exit>
  40a804:	14000006 	b	40a81c <cmd_is_option+0xb0>
		if (strcmp(&arg[of], option) != 0) {
  40a808:	aa1503e1 	mov	x1, x21
  40a80c:	8b020280 	add	x0, x20, x2
  40a810:	97ffdae4 	bl	4013a0 <strcmp@plt>
  40a814:	35000040 	cbnz	w0, 40a81c <cmd_is_option+0xb0>
			return of + to_match_len;
  40a818:	0b1702d3 	add	w19, w22, w23
}
  40a81c:	2a1303e0 	mov	w0, w19
  40a820:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a824:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a828:	f9401bf7 	ldr	x23, [sp, #48]
  40a82c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40a830:	d65f03c0 	ret
		if (arg[of] != *option) {
  40a834:	91000442 	add	x2, x2, #0x1
  40a838:	6b01001f 	cmp	w0, w1
  40a83c:	54fffc20 	b.eq	40a7c0 <cmd_is_option+0x54>  // b.none
			return 0;
  40a840:	52800013 	mov	w19, #0x0                   	// #0
  40a844:	17fffff6 	b	40a81c <cmd_is_option+0xb0>

000000000040a848 <cmd_is_help_option>:
{
  40a848:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a84c:	910003fd 	mov	x29, sp
  40a850:	f9000bf3 	str	x19, [sp, #16]
  40a854:	aa0003f3 	mov	x19, x0
	if (arg[0] == '-') {
  40a858:	39400000 	ldrb	w0, [x0]
  40a85c:	7100b41f 	cmp	w0, #0x2d
  40a860:	540000c1 	b.ne	40a878 <cmd_is_help_option+0x30>  // b.any
	if (arg[0] == '-') {
  40a864:	aa1303e0 	mov	x0, x19
		arg++;
  40a868:	91000a73 	add	x19, x19, #0x2
	if (arg[0] == '-') {
  40a86c:	38401c01 	ldrb	w1, [x0, #1]!
		arg++;
  40a870:	7100b43f 	cmp	w1, #0x2d
  40a874:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	if ((strcasecmp(arg, "?") == 0) ||
  40a878:	f0000041 	adrp	x1, 415000 <random_data+0xca4>
  40a87c:	aa1303e0 	mov	x0, x19
  40a880:	91198821 	add	x1, x1, #0x662
  40a884:	97ffda9b 	bl	4012f0 <strcasecmp@plt>
  40a888:	340001e0 	cbz	w0, 40a8c4 <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "h") == 0) ||
  40a88c:	90000061 	adrp	x1, 416000 <__func__.0+0xb3f>
  40a890:	aa1303e0 	mov	x0, x19
  40a894:	911a5821 	add	x1, x1, #0x696
  40a898:	97ffda96 	bl	4012f0 <strcasecmp@plt>
	if ((strcasecmp(arg, "?") == 0) ||
  40a89c:	34000140 	cbz	w0, 40a8c4 <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "help") == 0)) {
  40a8a0:	aa1303e0 	mov	x0, x19
  40a8a4:	f0000041 	adrp	x1, 415000 <random_data+0xca4>
  40a8a8:	911bf821 	add	x1, x1, #0x6fe
  40a8ac:	97ffda91 	bl	4012f0 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
  40a8b0:	7100001f 	cmp	w0, #0x0
  40a8b4:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40a8b8:	f9400bf3 	ldr	x19, [sp, #16]
  40a8bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a8c0:	d65f03c0 	ret
		return 1;
  40a8c4:	52800020 	mov	w0, #0x1                   	// #1
  40a8c8:	17fffffc 	b	40a8b8 <cmd_is_help_option+0x70>

000000000040a8cc <cmd_read_option_value>:
{
  40a8cc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40a8d0:	910003fd 	mov	x29, sp
  40a8d4:	a90153f3 	stp	x19, x20, [sp, #16]
  40a8d8:	aa0103f4 	mov	x20, x1
  40a8dc:	12001c41 	and	w1, w2, #0xff
  40a8e0:	b0000102 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  40a8e4:	f90013f5 	str	x21, [sp, #32]
  40a8e8:	aa0303f5 	mov	x21, x3
  40a8ec:	aa0003f3 	mov	x19, x0
  40a8f0:	f9476842 	ldr	x2, [x2, #3792]
  40a8f4:	f9400043 	ldr	x3, [x2]
  40a8f8:	f9001fe3 	str	x3, [sp, #56]
  40a8fc:	d2800003 	mov	x3, #0x0                   	// #0
	char *endptr = NULL;
  40a900:	f9001bff 	str	xzr, [sp, #48]
	switch (type) {
  40a904:	7101903f 	cmp	w1, #0x64
  40a908:	54000b40 	b.eq	40aa70 <cmd_read_option_value+0x1a4>  // b.none
  40a90c:	54000168 	b.hi	40a938 <cmd_read_option_value+0x6c>  // b.pmore
  40a910:	7101543f 	cmp	w1, #0x55
  40a914:	540009c0 	b.eq	40aa4c <cmd_read_option_value+0x180>  // b.none
  40a918:	7101883f 	cmp	w1, #0x62
  40a91c:	54000220 	b.eq	40a960 <cmd_read_option_value+0x94>  // b.none
  40a920:	7101243f 	cmp	w1, #0x49
  40a924:	540009e0 	b.eq	40aa60 <cmd_read_option_value+0x194>  // b.none
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
  40a928:	f0000040 	adrp	x0, 415000 <random_data+0xca4>
  40a92c:	911acc00 	add	x0, x0, #0x6b3
  40a930:	97fffeb4 	bl	40a400 <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
  40a934:	14000012 	b	40a97c <cmd_read_option_value+0xb0>
	switch (type) {
  40a938:	7101cc3f 	cmp	w1, #0x73
  40a93c:	54000760 	b.eq	40aa28 <cmd_read_option_value+0x15c>  // b.none
  40a940:	7101d43f 	cmp	w1, #0x75
  40a944:	540007a0 	b.eq	40aa38 <cmd_read_option_value+0x16c>  // b.none
  40a948:	7101a43f 	cmp	w1, #0x69
  40a94c:	54fffee1 	b.ne	40a928 <cmd_read_option_value+0x5c>  // b.any
		*(int32_t *)dest = strtol(str, &endptr, 0);
  40a950:	9100c3e1 	add	x1, sp, #0x30
  40a954:	52800002 	mov	w2, #0x0                   	// #0
  40a958:	97ffda9e 	bl	4013d0 <strtol@plt>
  40a95c:	1400003a 	b	40aa44 <cmd_read_option_value+0x178>
		if (strcasecmp(str, "false") == 0) {
  40a960:	f0000041 	adrp	x1, 415000 <random_data+0xca4>
  40a964:	91199021 	add	x1, x1, #0x664
  40a968:	97ffda62 	bl	4012f0 <strcasecmp@plt>
  40a96c:	35000120 	cbnz	w0, 40a990 <cmd_read_option_value+0xc4>
			endptr = (char *)str + 5;
  40a970:	91001660 	add	x0, x19, #0x5
			*(bool *)dest = false;
  40a974:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  40a978:	f9001be0 	str	x0, [sp, #48]
	if (!error && endptr && *endptr != 0) {
  40a97c:	f9401be0 	ldr	x0, [sp, #48]
  40a980:	b40003e0 	cbz	x0, 40a9fc <cmd_read_option_value+0x130>
  40a984:	39400000 	ldrb	w0, [x0]
  40a988:	35000300 	cbnz	w0, 40a9e8 <cmd_read_option_value+0x11c>
  40a98c:	1400001c 	b	40a9fc <cmd_read_option_value+0x130>
		} else if (strcmp(str, "0") == 0) {
  40a990:	90000061 	adrp	x1, 416000 <__func__.0+0xb3f>
  40a994:	aa1303e0 	mov	x0, x19
  40a998:	9122f821 	add	x1, x1, #0x8be
  40a99c:	97ffda81 	bl	4013a0 <strcmp@plt>
  40a9a0:	35000080 	cbnz	w0, 40a9b0 <cmd_read_option_value+0xe4>
			*(bool *)dest = false;
  40a9a4:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  40a9a8:	91000660 	add	x0, x19, #0x1
  40a9ac:	17fffff3 	b	40a978 <cmd_read_option_value+0xac>
		} else if (strcasecmp(str, "true") == 0) {
  40a9b0:	f0000041 	adrp	x1, 415000 <random_data+0xca4>
  40a9b4:	aa1303e0 	mov	x0, x19
  40a9b8:	9119a821 	add	x1, x1, #0x66a
  40a9bc:	97ffda4d 	bl	4012f0 <strcasecmp@plt>
  40a9c0:	350000a0 	cbnz	w0, 40a9d4 <cmd_read_option_value+0x108>
			*(bool *)dest = true;
  40a9c4:	52800020 	mov	w0, #0x1                   	// #1
  40a9c8:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 4;
  40a9cc:	91001260 	add	x0, x19, #0x4
  40a9d0:	17ffffea 	b	40a978 <cmd_read_option_value+0xac>
		} else if (strcmp(str, "1") == 0) {
  40a9d4:	f0000041 	adrp	x1, 415000 <random_data+0xca4>
  40a9d8:	aa1303e0 	mov	x0, x19
  40a9dc:	9119bc21 	add	x1, x1, #0x66f
  40a9e0:	97ffda70 	bl	4013a0 <strcmp@plt>
  40a9e4:	340001c0 	cbz	w0, 40aa1c <cmd_read_option_value+0x150>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
  40a9e8:	f0000040 	adrp	x0, 415000 <random_data+0xca4>
  40a9ec:	aa1303e2 	mov	x2, x19
  40a9f0:	aa1503e1 	mov	x1, x21
  40a9f4:	9119c400 	add	x0, x0, #0x671
  40a9f8:	97fffe82 	bl	40a400 <posix_print_error_and_exit>
}
  40a9fc:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40aa00:	f9476800 	ldr	x0, [x0, #3792]
  40aa04:	f9401fe2 	ldr	x2, [sp, #56]
  40aa08:	f9400001 	ldr	x1, [x0]
  40aa0c:	eb010042 	subs	x2, x2, x1
  40aa10:	d2800001 	mov	x1, #0x0                   	// #0
  40aa14:	54000360 	b.eq	40aa80 <cmd_read_option_value+0x1b4>  // b.none
  40aa18:	97ffda42 	bl	401320 <__stack_chk_fail@plt>
			*(bool *)dest = true;
  40aa1c:	52800020 	mov	w0, #0x1                   	// #1
  40aa20:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 1;
  40aa24:	17ffffe1 	b	40a9a8 <cmd_read_option_value+0xdc>
		*(char **)dest = (char *)str;
  40aa28:	f9000280 	str	x0, [x20]
		endptr = (char *)str + strlen(str);
  40aa2c:	97ffd9dd 	bl	4011a0 <strlen@plt>
  40aa30:	8b000260 	add	x0, x19, x0
  40aa34:	17ffffd1 	b	40a978 <cmd_read_option_value+0xac>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
  40aa38:	9100c3e1 	add	x1, sp, #0x30
  40aa3c:	52800002 	mov	w2, #0x0                   	// #0
  40aa40:	97ffd9d4 	bl	401190 <strtoul@plt>
		*(int32_t *)dest = strtol(str, &endptr, 0);
  40aa44:	b9000280 	str	w0, [x20]
	if (!error && endptr && *endptr != 0) {
  40aa48:	17ffffcd 	b	40a97c <cmd_read_option_value+0xb0>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
  40aa4c:	9100c3e1 	add	x1, sp, #0x30
  40aa50:	52800002 	mov	w2, #0x0                   	// #0
  40aa54:	97ffda73 	bl	401420 <strtoull@plt>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  40aa58:	f9000280 	str	x0, [x20]
	if (!error && endptr && *endptr != 0) {
  40aa5c:	17ffffc8 	b	40a97c <cmd_read_option_value+0xb0>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  40aa60:	9100c3e1 	add	x1, sp, #0x30
  40aa64:	52800002 	mov	w2, #0x0                   	// #0
  40aa68:	97ffd9da 	bl	4011d0 <strtoll@plt>
  40aa6c:	17fffffb 	b	40aa58 <cmd_read_option_value+0x18c>
		*(double *)dest = strtod(str, &endptr);
  40aa70:	9100c3e1 	add	x1, sp, #0x30
  40aa74:	97ffd9df 	bl	4011f0 <strtod@plt>
  40aa78:	fd000280 	str	d0, [x20]
	if (!error && endptr && *endptr != 0) {
  40aa7c:	17ffffc0 	b	40a97c <cmd_read_option_value+0xb0>
}
  40aa80:	a94153f3 	ldp	x19, x20, [sp, #16]
  40aa84:	f94013f5 	ldr	x21, [sp, #32]
  40aa88:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40aa8c:	d65f03c0 	ret

000000000040aa90 <cmd_args_set_defaults>:
{
  40aa90:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40aa94:	910003fd 	mov	x29, sp
  40aa98:	a90153f3 	stp	x19, x20, [sp, #16]
  40aa9c:	91002013 	add	x19, x0, #0x8
			*(double *)args_struct[count].dest = (double)NAN;
  40aaa0:	b0000040 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  40aaa4:	f0000054 	adrp	x20, 415000 <random_data+0xca4>
  40aaa8:	911ace94 	add	x20, x20, #0x6b3
{
  40aaac:	fd001be8 	str	d8, [sp, #48]
			*(double *)args_struct[count].dest = (double)NAN;
  40aab0:	fd430408 	ldr	d8, [x0, #1544]
{
  40aab4:	a9025bf5 	stp	x21, x22, [sp, #32]
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  40aab8:	12800015 	mov	w21, #0xffffffff            	// #-1
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  40aabc:	12b00016 	mov	w22, #0x7fffffff            	// #2147483647
	while (args_struct[count].option != NULL) {
  40aac0:	f9400260 	ldr	x0, [x19]
  40aac4:	b50000c0 	cbnz	x0, 40aadc <cmd_args_set_defaults+0x4c>
}
  40aac8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40aacc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40aad0:	fd401be8 	ldr	d8, [sp, #48]
  40aad4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40aad8:	d65f03c0 	ret
		if (args_struct[count].dest == NULL) {
  40aadc:	f9400e62 	ldr	x2, [x19, #24]
  40aae0:	b4000222 	cbz	x2, 40ab24 <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  40aae4:	39404261 	ldrb	w1, [x19, #16]
  40aae8:	7101903f 	cmp	w1, #0x64
  40aaec:	54000420 	b.eq	40ab70 <cmd_args_set_defaults+0xe0>  // b.none
  40aaf0:	540001e8 	b.hi	40ab2c <cmd_args_set_defaults+0x9c>  // b.pmore
  40aaf4:	7101543f 	cmp	w1, #0x55
  40aaf8:	54000320 	b.eq	40ab5c <cmd_args_set_defaults+0xcc>  // b.none
  40aafc:	540000e8 	b.hi	40ab18 <cmd_args_set_defaults+0x88>  // b.pmore
  40ab00:	34000121 	cbz	w1, 40ab24 <cmd_args_set_defaults+0x94>
  40ab04:	7101243f 	cmp	w1, #0x49
  40ab08:	54000300 	b.eq	40ab68 <cmd_args_set_defaults+0xd8>  // b.none
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  40ab0c:	aa1403e0 	mov	x0, x20
  40ab10:	97fffe3c 	bl	40a400 <posix_print_error_and_exit>
			break;
  40ab14:	14000004 	b	40ab24 <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  40ab18:	7101883f 	cmp	w1, #0x62
  40ab1c:	54ffff81 	b.ne	40ab0c <cmd_args_set_defaults+0x7c>  // b.any
			*(bool *)args_struct[count].dest = false;
  40ab20:	3900005f 	strb	wzr, [x2]
			break;
  40ab24:	9100e273 	add	x19, x19, #0x38
  40ab28:	17ffffe6 	b	40aac0 <cmd_args_set_defaults+0x30>
		switch (args_struct[count].type) {
  40ab2c:	7101cc3f 	cmp	w1, #0x73
  40ab30:	540000e0 	b.eq	40ab4c <cmd_args_set_defaults+0xbc>  // b.none
  40ab34:	7101d43f 	cmp	w1, #0x75
  40ab38:	540000e0 	b.eq	40ab54 <cmd_args_set_defaults+0xc4>  // b.none
  40ab3c:	7101a43f 	cmp	w1, #0x69
  40ab40:	54fffe61 	b.ne	40ab0c <cmd_args_set_defaults+0x7c>  // b.any
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  40ab44:	b9000056 	str	w22, [x2]
			break;
  40ab48:	17fffff7 	b	40ab24 <cmd_args_set_defaults+0x94>
			*(char **)args_struct[count].dest = NULL;
  40ab4c:	f900005f 	str	xzr, [x2]
			break;
  40ab50:	17fffff5 	b	40ab24 <cmd_args_set_defaults+0x94>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  40ab54:	b9000055 	str	w21, [x2]
			break;
  40ab58:	17fffff3 	b	40ab24 <cmd_args_set_defaults+0x94>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
  40ab5c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  40ab60:	f9000040 	str	x0, [x2]
			break;
  40ab64:	17fffff0 	b	40ab24 <cmd_args_set_defaults+0x94>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  40ab68:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  40ab6c:	17fffffd 	b	40ab60 <cmd_args_set_defaults+0xd0>
			*(double *)args_struct[count].dest = (double)NAN;
  40ab70:	fd000048 	str	d8, [x2]
			break;
  40ab74:	17ffffec 	b	40ab24 <cmd_args_set_defaults+0x94>

000000000040ab78 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
  40ab78:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  40ab7c:	f0000043 	adrp	x3, 415000 <random_data+0xca4>
  40ab80:	d0000042 	adrp	x2, 414000 <dlc_table.0+0x78d>
  40ab84:	910003fd 	mov	x29, sp
  40ab88:	a90153f3 	stp	x19, x20, [sp, #16]
  40ab8c:	aa0003f4 	mov	x20, x0
  40ab90:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;

	fprintf(stdout, "%s ", _HELP_SWITCH);
  40ab94:	b0000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
{
  40ab98:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ab9c:	911b6063 	add	x3, x3, #0x6d8
  40aba0:	f9476800 	ldr	x0, [x0, #3792]
  40aba4:	a90363f7 	stp	x23, x24, [sp, #48]
  40aba8:	91301042 	add	x2, x2, #0xc04
  40abac:	f9400001 	ldr	x1, [x0]
  40abb0:	f90047e1 	str	x1, [sp, #136]
  40abb4:	d2800001 	mov	x1, #0x0                   	// #0
  40abb8:	f0000057 	adrp	x23, 415000 <random_data+0xca4>
	fprintf(stdout, "%s ", _HELP_SWITCH);
  40abbc:	f9474260 	ldr	x0, [x19, #3712]
  40abc0:	f0000058 	adrp	x24, 415000 <random_data+0xca4>

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40abc4:	910103f6 	add	x22, sp, #0x40
  40abc8:	9135aaf7 	add	x23, x23, #0xd6a
  40abcc:	91165f18 	add	x24, x24, #0x597
  40abd0:	52800021 	mov	w1, #0x1                   	// #1
  40abd4:	f9400000 	ldr	x0, [x0]
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
  40abd8:	52800335 	mov	w21, #0x19                  	// #25
  40abdc:	97ffd9ed 	bl	401390 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
  40abe0:	f9400680 	ldr	x0, [x20, #8]
  40abe4:	b5000120 	cbnz	x0, 40ac08 <cmd_print_switches_help+0x90>
  40abe8:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40abec:	f9476800 	ldr	x0, [x0, #3792]
  40abf0:	f94047e2 	ldr	x2, [sp, #136]
  40abf4:	f9400001 	ldr	x1, [x0]
  40abf8:	eb010042 	subs	x2, x2, x1
  40abfc:	d2800001 	mov	x1, #0x0                   	// #0
  40ac00:	54000360 	b.eq	40ac6c <cmd_print_switches_help+0xf4>  // b.none
  40ac04:	97ffd9c7 	bl	401320 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40ac08:	aa1403e1 	mov	x1, x20
  40ac0c:	aa1603e0 	mov	x0, x22
  40ac10:	97fffe97 	bl	40a66c <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
  40ac14:	aa1603e0 	mov	x0, x22
  40ac18:	97ffd962 	bl	4011a0 <strlen@plt>
  40ac1c:	8b35c000 	add	x0, x0, w21, sxtw
  40ac20:	f101901f 	cmp	x0, #0x64
  40ac24:	540000e9 	b.ls	40ac40 <cmd_print_switches_help+0xc8>  // b.plast
			fprintf(stdout, "\n");
  40ac28:	f9474260 	ldr	x0, [x19, #3712]
  40ac2c:	aa1703e2 	mov	x2, x23
  40ac30:	52800021 	mov	w1, #0x1                   	// #1
			printed_in_line = 0;
  40ac34:	52800015 	mov	w21, #0x0                   	// #0
  40ac38:	f9400000 	ldr	x0, [x0]
  40ac3c:	97ffd9d5 	bl	401390 <__fprintf_chk@plt>
		}

		fprintf(stdout, "%s", stringy);
  40ac40:	f9474260 	ldr	x0, [x19, #3712]
  40ac44:	aa1603e3 	mov	x3, x22
  40ac48:	aa1803e2 	mov	x2, x24
  40ac4c:	52800021 	mov	w1, #0x1                   	// #1
  40ac50:	9100e294 	add	x20, x20, #0x38
  40ac54:	f9400000 	ldr	x0, [x0]
  40ac58:	97ffd9ce 	bl	401390 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
  40ac5c:	aa1603e0 	mov	x0, x22
  40ac60:	97ffd950 	bl	4011a0 <strlen@plt>
  40ac64:	0b0002b5 	add	w21, w21, w0
		count++;
  40ac68:	17ffffde 	b	40abe0 <cmd_print_switches_help+0x68>
	}

	fprintf(stdout, "\n");
  40ac6c:	f9474273 	ldr	x19, [x19, #3712]
  40ac70:	f0000042 	adrp	x2, 415000 <random_data+0xca4>
}
  40ac74:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ac78:	9135a842 	add	x2, x2, #0xd6a
  40ac7c:	f9400260 	ldr	x0, [x19]
  40ac80:	52800021 	mov	w1, #0x1                   	// #1
  40ac84:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ac88:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ac8c:	a8c97bfd 	ldp	x29, x30, [sp], #144
  40ac90:	17ffd9c0 	b	401390 <__fprintf_chk@plt>

000000000040ac94 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
  40ac94:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  40ac98:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40ac9c:	910003fd 	mov	x29, sp
  40aca0:	f9476821 	ldr	x1, [x1, #3792]
  40aca4:	a90153f3 	stp	x19, x20, [sp, #16]
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  40aca8:	b0000114 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
{
  40acac:	a9025bf5 	stp	x21, x22, [sp, #32]
  40acb0:	aa0003f3 	mov	x19, x0
  40acb4:	a90363f7 	stp	x23, x24, [sp, #48]
  40acb8:	f0000057 	adrp	x23, 415000 <random_data+0xca4>
  40acbc:	f0000058 	adrp	x24, 415000 <random_data+0xca4>
  40acc0:	a9046bf9 	stp	x25, x26, [sp, #64]
  40acc4:	911c3af7 	add	x23, x23, #0x70e
  40acc8:	9135af18 	add	x24, x24, #0xd6b
  40accc:	a90573fb 	stp	x27, x28, [sp, #80]
  40acd0:	f9400022 	ldr	x2, [x1]
  40acd4:	f90057e2 	str	x2, [sp, #168]
  40acd8:	d2800002 	mov	x2, #0x0                   	// #0
	cmd_print_switches_help(args_struct);
  40acdc:	97ffffa7 	bl	40ab78 <cmd_print_switches_help>
	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  40ace0:	f9474280 	ldr	x0, [x20, #3712]
  40ace4:	f0000045 	adrp	x5, 415000 <random_data+0xca4>
  40ace8:	f0000044 	adrp	x4, 415000 <random_data+0xca4>
  40acec:	f0000042 	adrp	x2, 415000 <random_data+0xca4>
  40acf0:	911bc4a5 	add	x5, x5, #0x6f1
  40acf4:	911b6084 	add	x4, x4, #0x6d8
  40acf8:	f9400000 	ldr	x0, [x0]
  40acfc:	911c0c42 	add	x2, x2, #0x703
  40ad00:	528003a3 	mov	w3, #0x1d                  	// #29
  40ad04:	52800021 	mov	w1, #0x1                   	// #1
  40ad08:	97ffd9a2 	bl	401390 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
  40ad0c:	f9400660 	ldr	x0, [x19, #8]
  40ad10:	b5000280 	cbnz	x0, 40ad60 <cmd_print_long_help+0xcc>
				      &toprint[printed_right]);
			printed_right += ret - 1;
		}
		count++;
	}
	fprintf(stdout, "\n");
  40ad14:	f9474294 	ldr	x20, [x20, #3712]
  40ad18:	52800021 	mov	w1, #0x1                   	// #1
  40ad1c:	f0000042 	adrp	x2, 415000 <random_data+0xca4>
  40ad20:	9135a842 	add	x2, x2, #0xd6a
  40ad24:	f9400280 	ldr	x0, [x20]
  40ad28:	97ffd99a 	bl	401390 <__fprintf_chk@plt>
  40ad2c:	f9400280 	ldr	x0, [x20]
  40ad30:	52800021 	mov	w1, #0x1                   	// #1
  40ad34:	f0000042 	adrp	x2, 415000 <random_data+0xca4>
  40ad38:	911c7c42 	add	x2, x2, #0x71f
  40ad3c:	97ffd995 	bl	401390 <__fprintf_chk@plt>
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
  40ad40:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40ad44:	f9476800 	ldr	x0, [x0, #3792]
  40ad48:	f94057e2 	ldr	x2, [sp, #168]
  40ad4c:	f9400001 	ldr	x1, [x0]
  40ad50:	eb010042 	subs	x2, x2, x1
  40ad54:	d2800001 	mov	x1, #0x0                   	// #0
  40ad58:	54000600 	b.eq	40ae18 <cmd_print_long_help+0x184>  // b.none
  40ad5c:	97ffd971 	bl	401320 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40ad60:	910183f5 	add	x21, sp, #0x60
  40ad64:	aa1303e1 	mov	x1, x19
  40ad68:	aa1503e0 	mov	x0, x21
  40ad6c:	97fffe40 	bl	40a66c <cmd_gen_switch_syntax.constprop.0>
		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
  40ad70:	f9474296 	ldr	x22, [x20, #3712]
  40ad74:	aa1503e4 	mov	x4, x21
  40ad78:	aa1703e2 	mov	x2, x23
  40ad7c:	528003a3 	mov	w3, #0x1d                  	// #29
  40ad80:	52800021 	mov	w1, #0x1                   	// #1
  40ad84:	f000005b 	adrp	x27, 415000 <random_data+0xca4>
  40ad88:	f94002c0 	ldr	x0, [x22]
  40ad8c:	f000005c 	adrp	x28, 415000 <random_data+0xca4>
  40ad90:	911c6f9c 	add	x28, x28, #0x71b
  40ad94:	97ffd97f 	bl	401390 <__fprintf_chk@plt>
  40ad98:	2a0003f5 	mov	w21, w0
		toprint = args_struct[count].descript;
  40ad9c:	f9401a7a 	ldr	x26, [x19, #48]
		total_to_print = strlen(toprint);
  40ada0:	aa1a03e0 	mov	x0, x26
  40ada4:	97ffd8ff 	bl	4011a0 <strlen@plt>
  40ada8:	2a0003f9 	mov	w25, w0
  40adac:	aa1a03e4 	mov	x4, x26
  40adb0:	f94002c0 	ldr	x0, [x22]
  40adb4:	911c5762 	add	x2, x27, #0x715
  40adb8:	52800c83 	mov	w3, #0x64                  	// #100
  40adbc:	52800021 	mov	w1, #0x1                   	// #1
  40adc0:	4b150063 	sub	w3, w3, w21
  40adc4:	97ffd973 	bl	401390 <__fprintf_chk@plt>
		printed_right += ret - 1;
  40adc8:	51000415 	sub	w21, w0, #0x1
		while (printed_right < total_to_print) {
  40adcc:	6b1902bf 	cmp	w21, w25
  40add0:	5400006b 	b.lt	40addc <cmd_print_long_help+0x148>  // b.tstop
		count++;
  40add4:	9100e273 	add	x19, x19, #0x38
  40add8:	17ffffcd 	b	40ad0c <cmd_print_long_help+0x78>
  40addc:	f94002c0 	ldr	x0, [x22]
  40ade0:	aa1803e4 	mov	x4, x24
  40ade4:	aa1c03e2 	mov	x2, x28
  40ade8:	528003c3 	mov	w3, #0x1e                  	// #30
  40adec:	52800021 	mov	w1, #0x1                   	// #1
  40adf0:	97ffd968 	bl	401390 <__fprintf_chk@plt>
  40adf4:	f94002c0 	ldr	x0, [x22]
  40adf8:	8b35c344 	add	x4, x26, w21, sxtw
  40adfc:	911c5762 	add	x2, x27, #0x715
  40ae00:	528008c3 	mov	w3, #0x46                  	// #70
  40ae04:	52800021 	mov	w1, #0x1                   	// #1
  40ae08:	97ffd962 	bl	401390 <__fprintf_chk@plt>
			printed_right += ret - 1;
  40ae0c:	51000400 	sub	w0, w0, #0x1
  40ae10:	0b0002b5 	add	w21, w21, w0
  40ae14:	17ffffee 	b	40adcc <cmd_print_long_help+0x138>
}
  40ae18:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ae1c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ae20:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ae24:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40ae28:	a94573fb 	ldp	x27, x28, [sp, #80]
  40ae2c:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  40ae30:	d65f03c0 	ret

000000000040ae34 <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
  40ae34:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ae38:	910003fd 	mov	x29, sp
  40ae3c:	a90153f3 	stp	x19, x20, [sp, #16]
  40ae40:	aa0003f4 	mov	x20, x0
  40ae44:	aa0103f3 	mov	x19, x1
  40ae48:	f90013f5 	str	x21, [sp, #32]
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
  40ae4c:	97fffe7f 	bl	40a848 <cmd_is_help_option>
  40ae50:	340000a0 	cbz	w0, 40ae64 <cmd_parse_one_arg+0x30>
		cmd_print_long_help(args_struct);
  40ae54:	aa1303e0 	mov	x0, x19
  40ae58:	97ffff8f 	bl	40ac94 <cmd_print_long_help>
		posix_exit(0);
  40ae5c:	52800000 	mov	w0, #0x0                   	// #0
  40ae60:	97fffd12 	bl	40a2a8 <posix_exit>
	}

	while (args_struct[count].option != NULL) {
  40ae64:	f9400661 	ldr	x1, [x19, #8]
  40ae68:	b50000c1 	cbnz	x1, 40ae80 <cmd_parse_one_arg+0x4c>
						    &args_struct[count]);
			return true;
		}
		count++;
	}
	return false;
  40ae6c:	52800000 	mov	w0, #0x0                   	// #0
}
  40ae70:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ae74:	f94013f5 	ldr	x21, [sp, #32]
  40ae78:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40ae7c:	d65f03c0 	ret
		if (args_struct[count].manual) {
  40ae80:	39400260 	ldrb	w0, [x19]
  40ae84:	350003e0 	cbnz	w0, 40af00 <cmd_parse_one_arg+0xcc>
				    !args_struct[count].is_switch);
  40ae88:	39400a62 	ldrb	w2, [x19, #2]
		ret = cmd_is_option(argv, args_struct[count].option,
  40ae8c:	aa1403e0 	mov	x0, x20
  40ae90:	52000042 	eor	w2, w2, #0x1
  40ae94:	97fffe36 	bl	40a76c <cmd_is_option>
  40ae98:	2a0003f5 	mov	w21, w0
		if (ret) {
  40ae9c:	34000320 	cbz	w0, 40af00 <cmd_parse_one_arg+0xcc>
	if (arg_element->dest != NULL) {
  40aea0:	f9401261 	ldr	x1, [x19, #32]
  40aea4:	b4000101 	cbz	x1, 40aec4 <cmd_parse_one_arg+0x90>
		if (arg_element->is_switch) {
  40aea8:	39400a60 	ldrb	w0, [x19, #2]
			if (arg_element->type == 'b') {
  40aeac:	39406262 	ldrb	w2, [x19, #24]
		if (arg_element->is_switch) {
  40aeb0:	34000200 	cbz	w0, 40aef0 <cmd_parse_one_arg+0xbc>
			if (arg_element->type == 'b') {
  40aeb4:	7101885f 	cmp	w2, #0x62
  40aeb8:	54000141 	b.ne	40aee0 <cmd_parse_one_arg+0xac>  // b.any
				*(bool *)arg_element->dest = true;
  40aebc:	52800020 	mov	w0, #0x1                   	// #1
  40aec0:	39000020 	strb	w0, [x1]
	if (arg_element->call_when_found) {
  40aec4:	f9401662 	ldr	x2, [x19, #40]
  40aec8:	b4000082 	cbz	x2, 40aed8 <cmd_parse_one_arg+0xa4>
		arg_element->call_when_found(argv, offset);
  40aecc:	2a1503e1 	mov	w1, w21
  40aed0:	aa1403e0 	mov	x0, x20
  40aed4:	d63f0040 	blr	x2
			return true;
  40aed8:	52800020 	mov	w0, #0x1                   	// #1
  40aedc:	17ffffe5 	b	40ae70 <cmd_parse_one_arg+0x3c>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
  40aee0:	f0000040 	adrp	x0, 415000 <random_data+0xca4>
  40aee4:	911dbc00 	add	x0, x0, #0x76f
  40aee8:	97fffd46 	bl	40a400 <posix_print_error_and_exit>
  40aeec:	17fffff6 	b	40aec4 <cmd_parse_one_arg+0x90>
			cmd_read_option_value(&argv[offset],
  40aef0:	f9400663 	ldr	x3, [x19, #8]
  40aef4:	8b35c280 	add	x0, x20, w21, sxtw
  40aef8:	97fffe75 	bl	40a8cc <cmd_read_option_value>
  40aefc:	17fffff2 	b	40aec4 <cmd_parse_one_arg+0x90>
  40af00:	9100e273 	add	x19, x19, #0x38
  40af04:	17ffffd8 	b	40ae64 <cmd_parse_one_arg+0x30>

000000000040af08 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
  40af08:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40af0c:	910003fd 	mov	x29, sp
  40af10:	f9000bf3 	str	x19, [sp, #16]
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
  40af14:	f0000113 	adrp	x19, 42d000 <args_struct>
  40af18:	f9400260 	ldr	x0, [x19]
  40af1c:	b4000060 	cbz	x0, 40af28 <native_cleanup_cmd_line+0x20>
		free(args_struct);
  40af20:	97ffd930 	bl	4013e0 <free@plt>
		args_struct = NULL;
  40af24:	f900027f 	str	xzr, [x19]
	}
}
  40af28:	f9400bf3 	ldr	x19, [sp, #16]
  40af2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40af30:	d65f03c0 	ret

000000000040af34 <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
  40af34:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40af38:	910003fd 	mov	x29, sp
  40af3c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40af40:	aa0003f5 	mov	x21, x0
  40af44:	91002000 	add	x0, x0, #0x8
  40af48:	a90153f3 	stp	x19, x20, [sp, #16]
	int count = 0;
  40af4c:	52800013 	mov	w19, #0x0                   	// #0
{
  40af50:	a90363f7 	stp	x23, x24, [sp, #48]
  40af54:	f90023f9 	str	x25, [sp, #64]

	while (args[count].option != NULL) {
  40af58:	f8438401 	ldr	x1, [x0], #56
  40af5c:	2a1303f7 	mov	w23, w19
		count++;
  40af60:	11000673 	add	w19, w19, #0x1
	while (args[count].option != NULL) {
  40af64:	b5ffffa1 	cbnz	x1, 40af58 <native_add_command_line_opts+0x24>
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
  40af68:	f0000116 	adrp	x22, 42d000 <args_struct>
  40af6c:	f0000119 	adrp	x25, 42d000 <args_struct>
  40af70:	f0000118 	adrp	x24, 42d000 <args_struct>
  40af74:	b94bf2c0 	ldr	w0, [x22, #3056]
  40af78:	b94be721 	ldr	w1, [x25, #3044]
  40af7c:	0b000260 	add	w0, w19, w0
  40af80:	6b01001f 	cmp	w0, w1
  40af84:	540001cb 	b.lt	40afbc <native_add_command_line_opts+0x88>  // b.tstop
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
  40af88:	7100527f 	cmp	w19, #0x14
  40af8c:	52800294 	mov	w20, #0x14                  	// #20
  40af90:	1a94a274 	csel	w20, w19, w20, ge  // ge = tcont
  40af94:	0b010294 	add	w20, w20, w1
		struct args_struct_t *new_args_struct = realloc(args_struct,
  40af98:	52800701 	mov	w1, #0x38                  	// #56
  40af9c:	f9400300 	ldr	x0, [x24]
  40afa0:	9b217e81 	smull	x1, w20, w1
  40afa4:	97ffd8d7 	bl	401300 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
  40afa8:	b90be734 	str	w20, [x25, #3044]
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
  40afac:	b5000260 	cbnz	x0, 40aff8 <native_add_command_line_opts+0xc4>
			posix_print_error_and_exit("Could not allocate memory");
  40afb0:	f0000040 	adrp	x0, 415000 <random_data+0xca4>
  40afb4:	911ee800 	add	x0, x0, #0x7ba
  40afb8:	97fffd12 	bl	40a400 <posix_print_error_and_exit>
			args_struct = new_args_struct;
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
  40afbc:	b94bf2d4 	ldr	w20, [x22, #3056]
  40afc0:	52800700 	mov	w0, #0x38                  	// #56
  40afc4:	f9400303 	ldr	x3, [x24]
  return __builtin___memcpy_chk (__dest, __src, __len,
  40afc8:	9b207e62 	smull	x2, w19, w0
  40afcc:	aa1503e1 	mov	x1, x21
  40afd0:	9b200e80 	smaddl	x0, w20, w0, x3
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
  40afd4:	0b170294 	add	w20, w20, w23
  40afd8:	97ffd866 	bl	401170 <memcpy@plt>
  40afdc:	b90bf2d4 	str	w20, [x22, #3056]
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
  40afe0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40afe4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40afe8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40afec:	f94023f9 	ldr	x25, [sp, #64]
  40aff0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40aff4:	d65f03c0 	ret
			args_struct = new_args_struct;
  40aff8:	f9000300 	str	x0, [x24]
  40affc:	17fffff0 	b	40afbc <native_add_command_line_opts+0x88>

000000000040b000 <native_add_testargs_option>:
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
  40b000:	b0000100 	adrp	x0, 42c000 <__dso_handle>
  40b004:	910b4000 	add	x0, x0, #0x2d0
  40b008:	17ffffcb 	b	40af34 <native_add_command_line_opts>

000000000040b00c <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
  40b00c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b010:	910003fd 	mov	x29, sp
  40b014:	a90153f3 	stp	x19, x20, [sp, #16]
  40b018:	aa0103f4 	mov	x20, x1
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
  40b01c:	d2800033 	mov	x19, #0x1                   	// #1
{
  40b020:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b024:	2a0003f5 	mov	w21, w0
  40b028:	a90363f7 	stp	x23, x24, [sp, #48]
	cmd_args_set_defaults(args_struct);
  40b02c:	d0000118 	adrp	x24, 42d000 <args_struct>
{
  40b030:	a9046bf9 	stp	x25, x26, [sp, #64]
	native_add_tracing_options();
  40b034:	97fffd8b 	bl	40a660 <native_add_tracing_options>
	native_add_testargs_option();
  40b038:	97fffff2 	bl	40b000 <native_add_testargs_option>
	s_argv = argv;
  40b03c:	d0000100 	adrp	x0, 42d000 <args_struct>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40b040:	d0000059 	adrp	x25, 415000 <random_data+0xca4>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40b044:	d000005a 	adrp	x26, 415000 <random_data+0xca4>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40b048:	911f5339 	add	x25, x25, #0x7d4
	s_argv = argv;
  40b04c:	f9000414 	str	x20, [x0, #8]
	s_argc = argc;
  40b050:	d0000100 	adrp	x0, 42d000 <args_struct>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40b054:	911f775a 	add	x26, x26, #0x7dd
	s_argc = argc;
  40b058:	b90be815 	str	w21, [x0, #3048]
	cmd_args_set_defaults(args_struct);
  40b05c:	f9400300 	ldr	x0, [x24]
  40b060:	97fffe8c 	bl	40aa90 <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
  40b064:	2a1303f6 	mov	w22, w19
  40b068:	6b1302bf 	cmp	w21, w19
  40b06c:	540001cd 	b.le	40b0a4 <native_handle_cmd_line+0x98>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40b070:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  40b074:	aa1903e1 	mov	x1, x25
  40b078:	52800002 	mov	w2, #0x0                   	// #0
  40b07c:	91000677 	add	x23, x19, #0x1
  40b080:	97fffdbb 	bl	40a76c <cmd_is_option>
  40b084:	340001c0 	cbz	w0, 40b0bc <native_handle_cmd_line+0xb0>
			test_argc = argc - i - 1;
  40b088:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b08c:	4b1602b6 	sub	w22, w21, w22
  40b090:	510006d6 	sub	w22, w22, #0x1
			test_argv = &argv[i+1];
  40b094:	8b170e97 	add	x23, x20, x23, lsl #3
			test_argc = argc - i - 1;
  40b098:	b90bec16 	str	w22, [x0, #3052]
			test_argv = &argv[i+1];
  40b09c:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b0a0:	f9000817 	str	x23, [x0, #16]
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
			cmd_print_switches_help(args_struct);
			print_invalid_opt_error(argv[i]);
		}
	}
}
  40b0a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b0a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b0ac:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b0b0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40b0b4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40b0b8:	d65f03c0 	ret
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
  40b0bc:	f9400301 	ldr	x1, [x24]
  40b0c0:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  40b0c4:	97ffff5c 	bl	40ae34 <cmd_parse_one_arg>
  40b0c8:	72001c1f 	tst	w0, #0xff
  40b0cc:	540000c1 	b.ne	40b0e4 <native_handle_cmd_line+0xd8>  // b.any
			cmd_print_switches_help(args_struct);
  40b0d0:	f9400300 	ldr	x0, [x24]
  40b0d4:	97fffea9 	bl	40ab78 <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40b0d8:	f8737a81 	ldr	x1, [x20, x19, lsl #3]
  40b0dc:	aa1a03e0 	mov	x0, x26
  40b0e0:	97fffcc8 	bl	40a400 <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
  40b0e4:	aa1703f3 	mov	x19, x23
  40b0e8:	17ffffdf 	b	40b064 <native_handle_cmd_line+0x58>

000000000040b0ec <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
  40b0ec:	90000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40b0f0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40b0f4:	f947d021 	ldr	x1, [x1, #4000]
  40b0f8:	f9000020 	str	x0, [x1]
	counter_target = NEVER;
  40b0fc:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b100:	f9001020 	str	x0, [x1, #32]
	counter_value = 0;
  40b104:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b108:	f900143f 	str	xzr, [x1, #40]
	counter_running = false;
  40b10c:	f0000101 	adrp	x1, 42e000 <irq_prio+0xf>
  40b110:	39004c3f 	strb	wzr, [x1, #19]
	counter_period = NEVER;
  40b114:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b118:	f9000c20 	str	x0, [x1, #24]
}
  40b11c:	d65f03c0 	ret

000000000040b120 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
  40b120:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!counter_running) {
  40b124:	f0000100 	adrp	x0, 42e000 <irq_prio+0xf>
{
  40b128:	910003fd 	mov	x29, sp
	if (!counter_running) {
  40b12c:	39404c00 	ldrb	w0, [x0, #19]
{
  40b130:	f9000bf3 	str	x19, [sp, #16]
  40b134:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
	if (!counter_running) {
  40b138:	350000e0 	cbnz	w0, 40b154 <hw_counter_triggered+0x34>
		hw_counter_timer = NEVER;
  40b13c:	f947d273 	ldr	x19, [x19, #4000]
  40b140:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40b144:	f9000260 	str	x0, [x19]
	counter_value = counter_value + 1;

	if (counter_value == counter_target) {
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
	}
}
  40b148:	f9400bf3 	ldr	x19, [sp, #16]
  40b14c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b150:	d65f03c0 	ret
	hw_counter_timer = hwm_get_time() + counter_period;
  40b154:	97fff9e7 	bl	4098f0 <hwm_get_time>
  40b158:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b15c:	f947d273 	ldr	x19, [x19, #4000]
  40b160:	f9400c21 	ldr	x1, [x1, #24]
  40b164:	8b000021 	add	x1, x1, x0
  40b168:	f9000261 	str	x1, [x19]
	counter_value = counter_value + 1;
  40b16c:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b170:	f9401420 	ldr	x0, [x1, #40]
  40b174:	91000400 	add	x0, x0, #0x1
  40b178:	f9001420 	str	x0, [x1, #40]
	if (counter_value == counter_target) {
  40b17c:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b180:	f9401021 	ldr	x1, [x1, #32]
  40b184:	eb01001f 	cmp	x0, x1
  40b188:	54fffe01 	b.ne	40b148 <hw_counter_triggered+0x28>  // b.any
}
  40b18c:	f9400bf3 	ldr	x19, [sp, #16]
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  40b190:	52800040 	mov	w0, #0x2                   	// #2
}
  40b194:	a8c27bfd 	ldp	x29, x30, [sp], #32
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  40b198:	17fffc18 	b	40a1f8 <hw_irq_ctrl_set_irq>

000000000040b19c <receive_pool_free>:

/*
 * Wake every context that is waiting for a buffer
 */
static void receive_pool_free(struct net_buf *buf)
{
  40b19c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b1a0:	910003fd 	mov	x29, sp
  40b1a4:	f9000bf3 	str	x19, [sp, #16]
  40b1a8:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b1ac:	39404800 	ldrb	w0, [x0, #18]
  40b1b0:	94000425 	bl	40c244 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40b1b4:	aa1303e1 	mov	x1, x19
  40b1b8:	940010d3 	bl	40f504 <k_queue_prepend>
	return list->head;
  40b1bc:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b1c0:	f9401c13 	ldr	x19, [x0, #56]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.alloc_list, ctx_node) {
  40b1c4:	b5000093 	cbnz	x19, 40b1d4 <receive_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  40b1c8:	f9400bf3 	ldr	x19, [sp, #16]
  40b1cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b1d0:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  40b1d4:	91004260 	add	x0, x19, #0x10
  40b1d8:	940013b9 	bl	4100bc <k_work_submit>
	return node->next;
  40b1dc:	f9400273 	ldr	x19, [x19]
  40b1e0:	17fffff9 	b	40b1c4 <receive_pool_free+0x28>

000000000040b1e4 <receive_ff_sf_pool_free>:

static void receive_ff_sf_pool_free(struct net_buf *buf)
{
  40b1e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b1e8:	910003fd 	mov	x29, sp
  40b1ec:	f9000bf3 	str	x19, [sp, #16]
  40b1f0:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b1f4:	39404800 	ldrb	w0, [x0, #18]
  40b1f8:	94000413 	bl	40c244 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40b1fc:	aa1303e1 	mov	x1, x19
  40b200:	940010c1 	bl	40f504 <k_queue_prepend>
	return list->head;
  40b204:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b208:	f9402413 	ldr	x19, [x0, #72]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.ff_sf_alloc_list, ctx_node) {
  40b20c:	b5000093 	cbnz	x19, 40b21c <receive_ff_sf_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  40b210:	f9400bf3 	ldr	x19, [sp, #16]
  40b214:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b218:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  40b21c:	91004260 	add	x0, x19, #0x10
  40b220:	940013a7 	bl	4100bc <k_work_submit>
	return node->next;
  40b224:	f9400273 	ldr	x19, [x19]
  40b228:	17fffff9 	b	40b20c <receive_ff_sf_pool_free+0x28>

000000000040b22c <TC_RESULT_TO_STR>:
#define TC_SKIP_STR "SKIP"
#endif

static inline const char *TC_RESULT_TO_STR(int result)
{
	switch (result) {
  40b22c:	7100041f 	cmp	w0, #0x1
  40b230:	54000140 	b.eq	40b258 <TC_RESULT_TO_STR+0x2c>  // b.none
  40b234:	7100081f 	cmp	w0, #0x2
  40b238:	54000160 	b.eq	40b264 <TC_RESULT_TO_STR+0x38>  // b.none
	case TC_PASS:
		return TC_PASS_STR;
  40b23c:	7100001f 	cmp	w0, #0x0
  40b240:	d0000042 	adrp	x2, 415000 <random_data+0xca4>
  40b244:	d0000041 	adrp	x1, 415000 <random_data+0xca4>
  40b248:	91227c42 	add	x2, x2, #0x89f
  40b24c:	91198820 	add	x0, x1, #0x662
  40b250:	9a821000 	csel	x0, x0, x2, ne  // ne = any
	case TC_SKIP:
		return TC_SKIP_STR;
	default:
		return "?";
	}
}
  40b254:	d65f03c0 	ret
	switch (result) {
  40b258:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b25c:	91229000 	add	x0, x0, #0x8a4
  40b260:	17fffffd 	b	40b254 <TC_RESULT_TO_STR+0x28>
		return TC_SKIP_STR;
  40b264:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b268:	9122a400 	add	x0, x0, #0x8a9
  40b26c:	17fffffa 	b	40b254 <TC_RESULT_TO_STR+0x28>

000000000040b270 <get_friendly_phase_name>:
 * @param phase an enum ztest_phase value describing the desired test phase
 * @returns a string name for `phase`
 */
static inline const char *get_friendly_phase_name(enum ztest_phase phase)
{
	switch (phase) {
  40b270:	7100141f 	cmp	w0, #0x5
  40b274:	540002c8 	b.hi	40b2cc <get_friendly_phase_name+0x5c>  // b.pmore
  40b278:	90000041 	adrp	x1, 413000 <z_impl_k_uptime_ticks>
  40b27c:	911a6021 	add	x1, x1, #0x698
  40b280:	38604821 	ldrb	w1, [x1, w0, uxtw]
  40b284:	10000060 	adr	x0, 40b290 <get_friendly_phase_name+0x20>
  40b288:	8b218801 	add	x1, x0, w1, sxtb #2
  40b28c:	d61f0020 	br	x1
  40b290:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b294:	9122d000 	add	x0, x0, #0x8b4
	case TEST_PHASE_FRAMEWORK:
		return "framework";
	default:
		return "(unknown)";
	}
}
  40b298:	d65f03c0 	ret
		return "test";
  40b29c:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b2a0:	912f6000 	add	x0, x0, #0xbd8
  40b2a4:	17fffffd 	b	40b298 <get_friendly_phase_name+0x28>
		return "after";
  40b2a8:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b2ac:	9122ec00 	add	x0, x0, #0x8bb
  40b2b0:	17fffffa 	b	40b298 <get_friendly_phase_name+0x28>
		return "teardown";
  40b2b4:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b2b8:	91230400 	add	x0, x0, #0x8c1
  40b2bc:	17fffff7 	b	40b298 <get_friendly_phase_name+0x28>
		return "framework";
  40b2c0:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b2c4:	91232800 	add	x0, x0, #0x8ca
  40b2c8:	17fffff4 	b	40b298 <get_friendly_phase_name+0x28>
		return "(unknown)";
  40b2cc:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b2d0:	91235000 	add	x0, x0, #0x8d4
  40b2d4:	17fffff1 	b	40b298 <get_friendly_phase_name+0x28>
		return "setup";
  40b2d8:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b2dc:	9122b800 	add	x0, x0, #0x8ae
  40b2e0:	17ffffee 	b	40b298 <get_friendly_phase_name+0x28>

000000000040b2e4 <ztest_find_test_suite>:
}

#endif /* !KERNEL */

static struct ztest_suite_node *ztest_find_test_suite(const char *name)
{
  40b2e4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40b2e8:	910003fd 	mov	x29, sp
  40b2ec:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_suite_node *node;

	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b2f0:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  40b2f4:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  40b2f8:	f9471e73 	ldr	x19, [x19, #3640]
{
  40b2fc:	f90013f5 	str	x21, [sp, #32]
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b300:	f9473a94 	ldr	x20, [x20, #3696]
{
  40b304:	aa0003f5 	mov	x21, x0
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b308:	eb14027f 	cmp	x19, x20
  40b30c:	540000e3 	b.cc	40b328 <ztest_find_test_suite+0x44>  // b.lo, b.ul, b.last
		if (strcmp(name, node->name) == 0) {
			return node;
		}
	}

	return NULL;
  40b310:	d2800013 	mov	x19, #0x0                   	// #0
}
  40b314:	aa1303e0 	mov	x0, x19
  40b318:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b31c:	f94013f5 	ldr	x21, [sp, #32]
  40b320:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b324:	d65f03c0 	ret
		if (strcmp(name, node->name) == 0) {
  40b328:	f9400261 	ldr	x1, [x19]
  40b32c:	aa1503e0 	mov	x0, x21
  40b330:	97ffd81c 	bl	4013a0 <strcmp@plt>
  40b334:	34ffff00 	cbz	w0, 40b314 <ztest_find_test_suite+0x30>
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b338:	9100e273 	add	x19, x19, #0x38
  40b33c:	17fffff3 	b	40b308 <ztest_find_test_suite+0x24>

000000000040b340 <flush_log>:
		test->stats->duration_worst_ms = 0;
	}
}

static void flush_log(void)
{
  40b340:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b344:	910003fd 	mov	x29, sp
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke0(K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process();
  40b348:	97fff348 	bl	408068 <z_impl_log_process>
		while (log_data_pending()) {
			k_sleep(K_MSEC(10));
		}
		k_sleep(K_MSEC(10));
	} else {
		while (LOG_PROCESS()) {
  40b34c:	72001c1f 	tst	w0, #0xff
  40b350:	54ffffc1 	b.ne	40b348 <flush_log+0x8>  // b.any
		}
	}
}
  40b354:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b358:	d65f03c0 	ret

000000000040b35c <test_cb>:
{
  40b35c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40b360:	910003fd 	mov	x29, sp
  40b364:	a90153f3 	stp	x19, x20, [sp, #16]
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40b368:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
{
  40b36c:	aa0203f4 	mov	x20, x2
  40b370:	a90363f7 	stp	x23, x24, [sp, #48]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b374:	90000117 	adrp	x23, 42b000 <__FRAME_END__+0xff4c>
	test_result = ZTEST_RESULT_PENDING;
  40b378:	d0000118 	adrp	x24, 42d000 <args_struct>
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40b37c:	f9476e73 	ldr	x19, [x19, #3800]
{
  40b380:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b384:	aa0003f6 	mov	x22, x0
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b388:	f947d6f7 	ldr	x23, [x23, #4008]
{
  40b38c:	aa0103f5 	mov	x21, x1
	test_result = ZTEST_RESULT_PENDING;
  40b390:	b90bff1f 	str	wzr, [x24, #3068]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b394:	eb17027f 	cmp	x19, x23
  40b398:	54000263 	b.cc	40b3e4 <test_cb+0x88>  // b.lo, b.ul, b.last
	if (suite->before) {
  40b39c:	f9400ac1 	ldr	x1, [x22, #16]
  40b3a0:	b4000061 	cbz	x1, 40b3ac <test_cb+0x50>
		suite->before(/*data=*/c);
  40b3a4:	aa1403e0 	mov	x0, x20
  40b3a8:	d63f0020 	blr	x1
	phase = TEST_PHASE_TEST;
  40b3ac:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40b3b0:	52800042 	mov	w2, #0x2                   	// #2
  40b3b4:	f9400aa1 	ldr	x1, [x21, #16]
  40b3b8:	f947cc00 	ldr	x0, [x0, #3992]
  40b3bc:	b9000002 	str	w2, [x0]
	test->test(data);
  40b3c0:	aa1403e0 	mov	x0, x20
  40b3c4:	d63f0020 	blr	x1
	test_result = ZTEST_RESULT_PASS;
  40b3c8:	52800020 	mov	w0, #0x1                   	// #1
  40b3cc:	b90bff00 	str	w0, [x24, #3068]
}
  40b3d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b3d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b3d8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b3dc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40b3e0:	d65f03c0 	ret
		if (is_before && rule->before_each) {
  40b3e4:	f9400262 	ldr	x2, [x19]
  40b3e8:	b4000082 	cbz	x2, 40b3f8 <test_cb+0x9c>
			rule->before_each(test, data);
  40b3ec:	aa1403e1 	mov	x1, x20
  40b3f0:	aa1503e0 	mov	x0, x21
  40b3f4:	d63f0040 	blr	x2
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b3f8:	91004273 	add	x19, x19, #0x10
  40b3fc:	17ffffe6 	b	40b394 <test_cb+0x38>

000000000040b400 <test_finalize>:
{
  40b400:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b404:	910003fd 	mov	x29, sp
	z_impl_k_thread_abort(thread);
  40b408:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b40c:	91016000 	add	x0, x0, #0x58
  40b410:	97fff793 	bl	40925c <z_impl_k_thread_abort>
	return z_impl_z_current_get();
  40b414:	94001b7f 	bl	412210 <z_impl_z_current_get>
}
  40b418:	a8c17bfd 	ldp	x29, x30, [sp], #16
	z_impl_k_thread_abort(thread);
  40b41c:	17fff790 	b	40925c <z_impl_k_thread_abort>

000000000040b420 <ztest_test_fail>:
	switch (phase) {
  40b420:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40b424:	f947cc00 	ldr	x0, [x0, #3992]
  40b428:	b9400000 	ldr	w0, [x0]
  40b42c:	34000200 	cbz	w0, 40b46c <ztest_test_fail+0x4c>
  40b430:	51000401 	sub	w1, w0, #0x1
  40b434:	7100043f 	cmp	w1, #0x1
  40b438:	54000229 	b.ls	40b47c <ztest_test_fail+0x5c>  // b.plast
{
  40b43c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b440:	910003fd 	mov	x29, sp
		PRINT(" ERROR: cannot fail in test phase '%s()', bailing\n",
  40b444:	97ffff8b 	bl	40b270 <get_friendly_phase_name>
  40b448:	aa0003e1 	mov	x1, x0
  40b44c:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b450:	91237800 	add	x0, x0, #0x8de
  40b454:	97ffec12 	bl	40649c <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b458:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b45c:	52800041 	mov	w1, #0x2                   	// #2
}
  40b460:	a8c17bfd 	ldp	x29, x30, [sp], #16
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b464:	b90c0001 	str	w1, [x0, #3072]
}
  40b468:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SUITE_FAIL;
  40b46c:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b470:	528000a1 	mov	w1, #0x5                   	// #5
  40b474:	b90bfc01 	str	w1, [x0, #3068]
		break;
  40b478:	d65f03c0 	ret
		test_result = ZTEST_RESULT_FAIL;
  40b47c:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b480:	52800041 	mov	w1, #0x2                   	// #2
  40b484:	b90bfc01 	str	w1, [x0, #3068]
		test_finalize();
  40b488:	17ffffde 	b	40b400 <test_finalize>

000000000040b48c <ztest_test_skip>:
	switch (phase) {
  40b48c:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40b490:	f947cc00 	ldr	x0, [x0, #3992]
  40b494:	b9400000 	ldr	w0, [x0]
  40b498:	34000200 	cbz	w0, 40b4d8 <ztest_test_skip+0x4c>
  40b49c:	51000401 	sub	w1, w0, #0x1
  40b4a0:	7100043f 	cmp	w1, #0x1
  40b4a4:	54000229 	b.ls	40b4e8 <ztest_test_skip+0x5c>  // b.plast
{
  40b4a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b4ac:	910003fd 	mov	x29, sp
		PRINT(" ERROR: cannot skip in test phase '%s()', bailing\n",
  40b4b0:	97ffff70 	bl	40b270 <get_friendly_phase_name>
  40b4b4:	aa0003e1 	mov	x1, x0
  40b4b8:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b4bc:	91244400 	add	x0, x0, #0x911
  40b4c0:	97ffebf7 	bl	40649c <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b4c4:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b4c8:	52800041 	mov	w1, #0x2                   	// #2
}
  40b4cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b4d0:	b90c0001 	str	w1, [x0, #3072]
}
  40b4d4:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SUITE_SKIP;
  40b4d8:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b4dc:	52800081 	mov	w1, #0x4                   	// #4
  40b4e0:	b90bfc01 	str	w1, [x0, #3068]
		break;
  40b4e4:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SKIP;
  40b4e8:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b4ec:	52800061 	mov	w1, #0x3                   	// #3
  40b4f0:	b90bfc01 	str	w1, [x0, #3068]
		test_finalize();
  40b4f4:	17ffffc3 	b	40b400 <test_finalize>

000000000040b4f8 <z_ztest_get_next_test>:
{
  40b4f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b4fc:	f100003f 	cmp	x1, #0x0
{
  40b500:	910003fd 	mov	x29, sp
  40b504:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b508:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b50c:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b510:	f946ea73 	ldr	x19, [x19, #3536]
{
  40b514:	f90013f5 	str	x21, [sp, #32]
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b518:	f9473e94 	ldr	x20, [x20, #3704]
{
  40b51c:	aa0003f5 	mov	x21, x0
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b520:	9100a020 	add	x0, x1, #0x28
  40b524:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b528:	eb14027f 	cmp	x19, x20
  40b52c:	540000e3 	b.cc	40b548 <z_ztest_get_next_test+0x50>  // b.lo, b.ul, b.last
	return NULL;
  40b530:	d2800013 	mov	x19, #0x0                   	// #0
}
  40b534:	aa1303e0 	mov	x0, x19
  40b538:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b53c:	f94013f5 	ldr	x21, [sp, #32]
  40b540:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b544:	d65f03c0 	ret
		if (strcmp(suite, test->test_suite_name) == 0) {
  40b548:	f9400261 	ldr	x1, [x19]
  40b54c:	aa1503e0 	mov	x0, x21
  40b550:	97ffd794 	bl	4013a0 <strcmp@plt>
  40b554:	34ffff00 	cbz	w0, 40b534 <z_ztest_get_next_test+0x3c>
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b558:	9100a273 	add	x19, x19, #0x28
  40b55c:	17fffff3 	b	40b528 <z_ztest_get_next_test+0x30>

000000000040b560 <z_ztest_run_test_suite_ptr>:
{
  40b560:	d10203ff 	sub	sp, sp, #0x80
  40b564:	a9017bfd 	stp	x29, x30, [sp, #16]
  40b568:	910043fd 	add	x29, sp, #0x10
  40b56c:	a90253f3 	stp	x19, x20, [sp, #32]
  40b570:	a9035bf5 	stp	x21, x22, [sp, #48]
  40b574:	a90463f7 	stp	x23, x24, [sp, #64]
  40b578:	a9056bf9 	stp	x25, x26, [sp, #80]
  40b57c:	a90673fb 	stp	x27, x28, [sp, #96]
	if (suite == NULL) {
  40b580:	b50001c0 	cbnz	x0, 40b5b8 <z_ztest_run_test_suite_ptr+0x58>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b584:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b588:	52800041 	mov	w1, #0x2                   	// #2
		return -1;
  40b58c:	12800016 	mov	w22, #0xffffffff            	// #-1
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b590:	b90c0001 	str	w1, [x0, #3072]
}
  40b594:	2a1603e0 	mov	w0, w22
  40b598:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40b59c:	a94253f3 	ldp	x19, x20, [sp, #32]
  40b5a0:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40b5a4:	a94463f7 	ldp	x23, x24, [sp, #64]
  40b5a8:	a9456bf9 	ldp	x25, x26, [sp, #80]
  40b5ac:	a94673fb 	ldp	x27, x28, [sp, #96]
  40b5b0:	910203ff 	add	sp, sp, #0x80
  40b5b4:	d65f03c0 	ret
  40b5b8:	aa0003f4 	mov	x20, x0
	TC_SUITE_START(suite->name);
  40b5bc:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b5c0:	91251000 	add	x0, x0, #0x944
	phase = TEST_PHASE_SETUP;
  40b5c4:	90000115 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
	test_result = ZTEST_RESULT_PENDING;
  40b5c8:	d0000118 	adrp	x24, 42d000 <args_struct>
	TC_SUITE_START(suite->name);
  40b5cc:	f9400281 	ldr	x1, [x20]
  40b5d0:	97ffebb3 	bl	40649c <printk>
  40b5d4:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b5d8:	91256800 	add	x0, x0, #0x95a
  40b5dc:	97ffebb0 	bl	40649c <printk>
	test_result = ZTEST_RESULT_PENDING;
  40b5e0:	b90bff1f 	str	wzr, [x24, #3068]
	current_test_failed_assumption = false;
  40b5e4:	f0000100 	adrp	x0, 42e000 <irq_prio+0xf>
  40b5e8:	3900501f 	strb	wzr, [x0, #20]
	phase = TEST_PHASE_SETUP;
  40b5ec:	f947cea0 	ldr	x0, [x21, #3992]
  40b5f0:	b900001f 	str	wzr, [x0]
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
  40b5f4:	f9400680 	ldr	x0, [x20, #8]
  40b5f8:	b4000340 	cbz	x0, 40b660 <z_ztest_run_test_suite_ptr+0x100>
		data = suite->setup();
  40b5fc:	d63f0000 	blr	x0
  40b600:	aa0003f7 	mov	x23, x0
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b604:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
		fail = 0;
  40b608:	52800016 	mov	w22, #0x0                   	// #0
	struct ztest_unit_test *test = NULL;
  40b60c:	d2800013 	mov	x19, #0x0                   	// #0
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b610:	f9479400 	ldr	x0, [x0, #3880]
  40b614:	f9003fe0 	str	x0, [sp, #120]
	tc_start_time = k_cycle_get_32();
}

static inline void get_test_duration_ms(void)
{
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40b618:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b61c:	912fe01c 	add	x28, x0, #0xbf8
		while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40b620:	f9400280 	ldr	x0, [x20]
  40b624:	aa1303e1 	mov	x1, x19
  40b628:	97ffffb4 	bl	40b4f8 <z_ztest_get_next_test>
  40b62c:	aa0003f3 	mov	x19, x0
  40b630:	b50001c0 	cbnz	x0, 40b668 <z_ztest_run_test_suite_ptr+0x108>
		if (test_status == ZTEST_STATUS_OK && fail != 0) {
  40b634:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b638:	b94c0001 	ldr	w1, [x0, #3072]
  40b63c:	35001741 	cbnz	w1, 40b924 <z_ztest_run_test_suite_ptr+0x3c4>
  40b640:	34001756 	cbz	w22, 40b928 <z_ztest_run_test_suite_ptr+0x3c8>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  40b644:	52800021 	mov	w1, #0x1                   	// #1
  40b648:	b90c0001 	str	w1, [x0, #3072]
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  40b64c:	f9400281 	ldr	x1, [x20]
  40b650:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b654:	91278000 	add	x0, x0, #0x9e0
  40b658:	97ffeb91 	bl	40649c <printk>
  40b65c:	140000b8 	b	40b93c <z_ztest_run_test_suite_ptr+0x3dc>
	void *data = NULL;
  40b660:	d2800017 	mov	x23, #0x0                   	// #0
  40b664:	17ffffe8 	b	40b604 <z_ztest_run_test_suite_ptr+0xa4>
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b668:	f9403fe0 	ldr	x0, [sp, #120]
  40b66c:	f9400661 	ldr	x1, [x19, #8]
  40b670:	f9400802 	ldr	x2, [x0, #16]
  40b674:	f9400280 	ldr	x0, [x20]
  40b678:	d63f0040 	blr	x2
  40b67c:	72001c1f 	tst	w0, #0xff
  40b680:	540014a0 	b.eq	40b914 <z_ztest_run_test_suite_ptr+0x3b4>  // b.none
				test->stats->run_count++;
  40b684:	f9401261 	ldr	x1, [x19, #32]
  40b688:	b9400020 	ldr	w0, [x1]
  40b68c:	11000400 	add	w0, w0, #0x1
  40b690:	b9000020 	str	w0, [x1]
	TC_START(test->name);
  40b694:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b698:	91267c00 	add	x0, x0, #0x99f
  40b69c:	f9400661 	ldr	x1, [x19, #8]
  40b6a0:	97ffeb7f 	bl	40649c <printk>
	phase = TEST_PHASE_BEFORE;
  40b6a4:	f947cea0 	ldr	x0, [x21, #3992]
  40b6a8:	52800021 	mov	w1, #0x1                   	// #1
  40b6ac:	b9000001 	str	w1, [x0]
	return sys_clock_cycle_get_32();
  40b6b0:	9400076f 	bl	40d46c <sys_clock_cycle_get_32>
	tc_start_time = k_cycle_get_32();
  40b6b4:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b6b8:	92800007 	mov	x7, #0xffffffffffffffff    	// #-1
  40b6bc:	b90bf820 	str	w0, [x1, #3064]
		k_thread_create(&ztest_thread, ztest_thread_stack,
  40b6c0:	b9401a60 	ldr	w0, [x19, #24]
  40b6c4:	321d0000 	orr	w0, w0, #0x8
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40b6c8:	90000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40b6cc:	b90003e0 	str	w0, [sp]
  40b6d0:	f90007e7 	str	x7, [sp, #8]
  40b6d4:	d0000119 	adrp	x25, 42d000 <args_struct>
  40b6d8:	f947ec21 	ldr	x1, [x1, #4056]
  40b6dc:	9101633b 	add	x27, x25, #0x58
  40b6e0:	aa1703e6 	mov	x6, x23
  40b6e4:	aa1303e5 	mov	x5, x19
  40b6e8:	aa1403e4 	mov	x4, x20
  40b6ec:	aa1b03e0 	mov	x0, x27
  40b6f0:	d2808002 	mov	x2, #0x400                 	// #1024
  40b6f4:	90000003 	adrp	x3, 40b000 <native_add_testargs_option>
  40b6f8:	910d7063 	add	x3, x3, #0x35c
  40b6fc:	94000b40 	bl	40e3fc <z_impl_k_thread_create>
		if (test->name != NULL) {
  40b700:	f9400661 	ldr	x1, [x19, #8]
  40b704:	b4000061 	cbz	x1, 40b710 <z_ztest_run_test_suite_ptr+0x1b0>
	return z_impl_k_thread_name_set(thread, str);
  40b708:	aa1b03e0 	mov	x0, x27
  40b70c:	94000ac7 	bl	40e228 <z_impl_k_thread_name_set>
		if (test_result != ZTEST_RESULT_SUITE_SKIP &&
  40b710:	b94bff00 	ldr	w0, [x24, #3068]
  40b714:	51001000 	sub	w0, w0, #0x4
  40b718:	7100041f 	cmp	w0, #0x1
  40b71c:	540000e9 	b.ls	40b738 <z_ztest_run_test_suite_ptr+0x1d8>  // b.plast
	z_impl_k_thread_start(thread);
  40b720:	9101633b 	add	x27, x25, #0x58
  40b724:	aa1b03e0 	mov	x0, x27
  40b728:	94000ad3 	bl	40e274 <z_impl_k_thread_start>
	return z_impl_k_thread_join(thread, timeout);
  40b72c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40b730:	aa1b03e0 	mov	x0, x27
  40b734:	94001b71 	bl	4124f8 <z_impl_k_thread_join>
	phase = TEST_PHASE_AFTER;
  40b738:	f947cea0 	ldr	x0, [x21, #3992]
  40b73c:	52800061 	mov	w1, #0x3                   	// #3
  40b740:	b9000001 	str	w1, [x0]
	if (suite->after != NULL) {
  40b744:	f9400e81 	ldr	x1, [x20, #24]
  40b748:	b4000061 	cbz	x1, 40b754 <z_ztest_run_test_suite_ptr+0x1f4>
		suite->after(data);
  40b74c:	aa1703e0 	mov	x0, x23
  40b750:	d63f0020 	blr	x1
	void *data = NULL;
  40b754:	9000011b 	adrp	x27, 42b000 <__FRAME_END__+0xff4c>
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b758:	90000102 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
	void *data = NULL;
  40b75c:	f9476f7b 	ldr	x27, [x27, #3800]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b760:	f947d45a 	ldr	x26, [x2, #4008]
  40b764:	14000007 	b	40b780 <z_ztest_run_test_suite_ptr+0x220>
		} else if (!is_before && rule->after_each) {
  40b768:	f9400763 	ldr	x3, [x27, #8]
  40b76c:	b4000083 	cbz	x3, 40b77c <z_ztest_run_test_suite_ptr+0x21c>
			rule->after_each(test, data);
  40b770:	aa1703e1 	mov	x1, x23
  40b774:	aa1303e0 	mov	x0, x19
  40b778:	d63f0060 	blr	x3
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b77c:	9100437b 	add	x27, x27, #0x10
  40b780:	eb1a037f 	cmp	x27, x26
  40b784:	54ffff23 	b.cc	40b768 <z_ztest_run_test_suite_ptr+0x208>  // b.lo, b.ul, b.last
  40b788:	94000739 	bl	40d46c <sys_clock_cycle_get_32>
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40b78c:	b9400382 	ldr	w2, [x28]
  40b790:	4b020001 	sub	w1, w0, w2
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_cyc_to_ms_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
  40b794:	4b020000 	sub	w0, w0, w2
		t += off;
  40b798:	910f9c00 	add	x0, x0, #0x3e7
		if (result32 && (t < BIT64(32))) {
  40b79c:	b2407fe2 	mov	x2, #0xffffffff            	// #4294967295
  40b7a0:	eb02001f 	cmp	x0, x2
  40b7a4:	540007c8 	b.hi	40b89c <z_ztest_run_test_suite_ptr+0x33c>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
  40b7a8:	110f9c21 	add	w1, w1, #0x3e7
  40b7ac:	52807d00 	mov	w0, #0x3e8                 	// #1000
  40b7b0:	1ac00820 	udiv	w0, w1, w0

	tc_spend_time = k_cyc_to_ms_ceil32(spend_cycle);
  40b7b4:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b7b8:	b90bf420 	str	w0, [x1, #3060]
	if (tc_spend_time > test->stats->duration_worst_ms) {
  40b7bc:	f9401261 	ldr	x1, [x19, #32]
  40b7c0:	b9401022 	ldr	w2, [x1, #16]
  40b7c4:	6b00005f 	cmp	w2, w0
  40b7c8:	54000042 	b.cs	40b7d0 <z_ztest_run_test_suite_ptr+0x270>  // b.hs, b.nlast
		test->stats->duration_worst_ms = tc_spend_time;
  40b7cc:	b9001020 	str	w0, [x1, #16]
	phase = TEST_PHASE_FRAMEWORK;
  40b7d0:	f947cea0 	ldr	x0, [x21, #3992]
  40b7d4:	528000a1 	mov	w1, #0x5                   	// #5
  40b7d8:	b9000001 	str	w1, [x0]
	if (test_result == ZTEST_RESULT_FAIL || test_result == ZTEST_RESULT_SUITE_FAIL ||
  40b7dc:	b94bff00 	ldr	w0, [x24, #3068]
  40b7e0:	7100081f 	cmp	w0, #0x2
  40b7e4:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40b7e8:	f0000101 	adrp	x1, 42e000 <irq_prio+0xf>
  40b7ec:	54000060 	b.eq	40b7f8 <z_ztest_run_test_suite_ptr+0x298>  // b.none
  40b7f0:	39405422 	ldrb	w2, [x1, #21]
  40b7f4:	340005a2 	cbz	w2, 40b8a8 <z_ztest_run_test_suite_ptr+0x348>
		failed_expectation = false;
  40b7f8:	3900543f 	strb	wzr, [x1, #21]
		ret = TC_FAIL;
  40b7fc:	5280003a 	mov	w26, #0x1                   	// #1
	z_impl_k_thread_abort(thread);
  40b800:	91016320 	add	x0, x25, #0x58
  40b804:	97fff696 	bl	40925c <z_impl_k_thread_abort>
	for (struct ztest_expected_result_entry *expectation =
  40b808:	90000102 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40b80c:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40b810:	f9400679 	ldr	x25, [x19, #8]
	for (struct ztest_expected_result_entry *expectation =
  40b814:	f947745b 	ldr	x27, [x2, #3816]
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40b818:	f9478000 	ldr	x0, [x0, #3840]
  40b81c:	f9003be0 	str	x0, [sp, #112]
  40b820:	f9403be0 	ldr	x0, [sp, #112]
  40b824:	eb00037f 	cmp	x27, x0
  40b828:	540004a3 	b.cc	40b8bc <z_ztest_run_test_suite_ptr+0x35c>  // b.lo, b.ul, b.last
	Z_TC_END_RESULT(ret, test->name);
  40b82c:	2a1a03e0 	mov	w0, w26
  40b830:	97fffe7f 	bl	40b22c <TC_RESULT_TO_STR>
  40b834:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b838:	52807d02 	mov	w2, #0x3e8                 	// #1000
  40b83c:	b94bf424 	ldr	w4, [x1, #3060]
  40b840:	aa0003e1 	mov	x1, x0
  40b844:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b848:	9126ac00 	add	x0, x0, #0x9ab
  40b84c:	1ac20883 	udiv	w3, w4, w2
  40b850:	1b029064 	msub	w4, w3, w2, w4
  40b854:	aa1903e2 	mov	x2, x25
  40b858:	97ffeb11 	bl	40649c <printk>
  40b85c:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b860:	91256800 	add	x0, x0, #0x95a
  40b864:	97ffeb0e 	bl	40649c <printk>
	if (ret == TC_SKIP && current_test_failed_assumption) {
  40b868:	71000b5f 	cmp	w26, #0x2
  40b86c:	f9401260 	ldr	x0, [x19, #32]
  40b870:	54000761 	b.ne	40b95c <z_ztest_run_test_suite_ptr+0x3fc>  // b.any
  40b874:	f0000101 	adrp	x1, 42e000 <irq_prio+0xf>
  40b878:	39405021 	ldrb	w1, [x1, #20]
  40b87c:	34000081 	cbz	w1, 40b88c <z_ztest_run_test_suite_ptr+0x32c>
		test_status = 1;
  40b880:	d0000101 	adrp	x1, 42d000 <args_struct>
  40b884:	52800022 	mov	w2, #0x1                   	// #1
  40b888:	b90c0022 	str	w2, [x1, #3072]
					test->stats->skip_count++;
  40b88c:	b9400401 	ldr	w1, [x0, #4]
  40b890:	11000421 	add	w1, w1, #0x1
  40b894:	b9000401 	str	w1, [x0, #4]
				if (tc_result == TC_FAIL) {
  40b898:	1400001f 	b	40b914 <z_ztest_run_test_suite_ptr+0x3b4>
			return t / ((uint64_t)from_hz / to_hz);
  40b89c:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  40b8a0:	9ac10800 	udiv	x0, x0, x1
  40b8a4:	17ffffc4 	b	40b7b4 <z_ztest_run_test_suite_ptr+0x254>
	} else if (test_result == ZTEST_RESULT_SKIP || test_result == ZTEST_RESULT_SUITE_SKIP) {
  40b8a8:	51000c00 	sub	w0, w0, #0x3
  40b8ac:	7100041f 	cmp	w0, #0x1
  40b8b0:	1a9f87e5 	cset	w5, ls  // ls = plast
  40b8b4:	531f78ba 	lsl	w26, w5, #1
  40b8b8:	17ffffd2 	b	40b800 <z_ztest_run_test_suite_ptr+0x2a0>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40b8bc:	f9400760 	ldr	x0, [x27, #8]
  40b8c0:	aa1903e1 	mov	x1, x25
  40b8c4:	97ffd6b7 	bl	4013a0 <strcmp@plt>
  40b8c8:	35000160 	cbnz	w0, 40b8f4 <z_ztest_run_test_suite_ptr+0x394>
		    strcmp(expectation->test_suite_name, test->test_suite_name) == 0) {
  40b8cc:	f9400261 	ldr	x1, [x19]
  40b8d0:	f9400360 	ldr	x0, [x27]
  40b8d4:	97ffd6b3 	bl	4013a0 <strcmp@plt>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40b8d8:	350000e0 	cbnz	w0, 40b8f4 <z_ztest_run_test_suite_ptr+0x394>
			expected_result = expectation->expected_result;
  40b8dc:	b9401360 	ldr	w0, [x27, #16]
	if (expected_result == ZTEST_EXPECTED_RESULT_FAIL) {
  40b8e0:	340000e0 	cbz	w0, 40b8fc <z_ztest_run_test_suite_ptr+0x39c>
	if (expected_result == ZTEST_EXPECTED_RESULT_SKIP) {
  40b8e4:	7100041f 	cmp	w0, #0x1
  40b8e8:	54fffa21 	b.ne	40b82c <z_ztest_run_test_suite_ptr+0x2cc>  // b.any
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  40b8ec:	71000b5f 	cmp	w26, #0x2
  40b8f0:	14000004 	b	40b900 <z_ztest_run_test_suite_ptr+0x3a0>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40b8f4:	9100637b 	add	x27, x27, #0x18
  40b8f8:	17ffffca 	b	40b820 <z_ztest_run_test_suite_ptr+0x2c0>
		return (ret == TC_FAIL) ? TC_PASS : TC_FAIL;
  40b8fc:	7100075f 	cmp	w26, #0x1
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  40b900:	1a9f07fa 	cset	w26, ne  // ne = any
  40b904:	17ffffca 	b	40b82c <z_ztest_run_test_suite_ptr+0x2cc>
					test->stats->pass_count++;
  40b908:	b9400c01 	ldr	w1, [x0, #12]
  40b90c:	11000421 	add	w1, w1, #0x1
  40b910:	b9000c01 	str	w1, [x0, #12]
			if ((fail && FAIL_FAST) || test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40b914:	d0000100 	adrp	x0, 42d000 <args_struct>
  40b918:	b94c0000 	ldr	w0, [x0, #3072]
  40b91c:	7100081f 	cmp	w0, #0x2
  40b920:	54ffe801 	b.ne	40b620 <z_ztest_run_test_suite_ptr+0xc0>  // b.any
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  40b924:	35ffe956 	cbnz	w22, 40b64c <z_ztest_run_test_suite_ptr+0xec>
  40b928:	f9400281 	ldr	x1, [x20]
  40b92c:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40b930:	52800016 	mov	w22, #0x0                   	// #0
  40b934:	91272000 	add	x0, x0, #0x9c8
  40b938:	97ffead9 	bl	40649c <printk>
	phase = TEST_PHASE_TEARDOWN;
  40b93c:	f947ceb5 	ldr	x21, [x21, #3992]
  40b940:	52800080 	mov	w0, #0x4                   	// #4
	if (suite->teardown != NULL) {
  40b944:	f9401281 	ldr	x1, [x20, #32]
	phase = TEST_PHASE_TEARDOWN;
  40b948:	b90002a0 	str	w0, [x21]
	if (suite->teardown != NULL) {
  40b94c:	b4ffe241 	cbz	x1, 40b594 <z_ztest_run_test_suite_ptr+0x34>
		suite->teardown(data);
  40b950:	aa1703e0 	mov	x0, x23
  40b954:	d63f0020 	blr	x1
  40b958:	17ffff0f 	b	40b594 <z_ztest_run_test_suite_ptr+0x34>
				if (tc_result == TC_PASS) {
  40b95c:	34fffd7a 	cbz	w26, 40b908 <z_ztest_run_test_suite_ptr+0x3a8>
					test->stats->fail_count++;
  40b960:	b9400801 	ldr	w1, [x0, #8]
					fail++;
  40b964:	110006d6 	add	w22, w22, #0x1
					test->stats->fail_count++;
  40b968:	11000421 	add	w1, w1, #0x1
  40b96c:	b9000801 	str	w1, [x0, #8]
					fail++;
  40b970:	17ffffe9 	b	40b914 <z_ztest_run_test_suite_ptr+0x3b4>

000000000040b974 <z_impl_ztest_run_test_suites>:

	return count;
}

int z_impl_ztest_run_test_suites(const void *state)
{
  40b974:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b978:	910003fd 	mov	x29, sp
  40b97c:	f90023f9 	str	x25, [sp, #64]
	int count = 0;

	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40b980:	d0000119 	adrp	x25, 42d000 <args_struct>
{
  40b984:	a90363f7 	stp	x23, x24, [sp, #48]
  40b988:	aa0003f7 	mov	x23, x0
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40b98c:	b94c0320 	ldr	w0, [x25, #3072]
{
  40b990:	a90153f3 	stp	x19, x20, [sp, #16]
  40b994:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40b998:	7100081f 	cmp	w0, #0x2
  40b99c:	540007a0 	b.eq	40ba90 <z_impl_ztest_run_test_suites+0x11c>  // b.none
		    (test_status == ZTEST_STATUS_HAS_FAILURE && FAIL_FAST)) {
			break;
		}
	}
#else
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40b9a0:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40b9a4:	90000116 	adrp	x22, 42b000 <__FRAME_END__+0xff4c>
		if (ztest_api.should_suite_run(state, ptr)) {
  40b9a8:	90000118 	adrp	x24, 42b000 <__FRAME_END__+0xff4c>
	int count = 0;
  40b9ac:	52800015 	mov	w21, #0x0                   	// #0
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40b9b0:	f9471e73 	ldr	x19, [x19, #3640]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40b9b4:	f9473ad6 	ldr	x22, [x22, #3696]
		if (ztest_api.should_suite_run(state, ptr)) {
  40b9b8:	f9479718 	ldr	x24, [x24, #3880]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40b9bc:	eb16027f 	cmp	x19, x22
  40b9c0:	54000103 	b.cc	40b9e0 <z_impl_ztest_run_test_suites+0x6c>  // b.lo, b.ul, b.last
		}
	}
#endif

	return count;
}
  40b9c4:	2a1503e0 	mov	w0, w21
  40b9c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b9cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b9d0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b9d4:	f94023f9 	ldr	x25, [sp, #64]
  40b9d8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40b9dc:	d65f03c0 	ret
		if (ztest_api.should_suite_run(state, ptr)) {
  40b9e0:	f9400702 	ldr	x2, [x24, #8]
  40b9e4:	aa1303e1 	mov	x1, x19
  40b9e8:	aa1703e0 	mov	x0, x23
	struct ztest_suite_stats *stats = ptr->stats;
  40b9ec:	f9401a74 	ldr	x20, [x19, #48]
		if (ztest_api.should_suite_run(state, ptr)) {
  40b9f0:	d63f0040 	blr	x2
  40b9f4:	72001c1f 	tst	w0, #0xff
  40b9f8:	54000420 	b.eq	40ba7c <z_impl_ztest_run_test_suites+0x108>  // b.none
	struct ztest_unit_test *test = NULL;
  40b9fc:	d2800001 	mov	x1, #0x0                   	// #0
  40ba00:	1400000b 	b	40ba2c <z_impl_ztest_run_test_suites+0xb8>
		test->stats->run_count = 0;
  40ba04:	f9401020 	ldr	x0, [x1, #32]
  40ba08:	b900001f 	str	wzr, [x0]
		test->stats->skip_count = 0;
  40ba0c:	f9401020 	ldr	x0, [x1, #32]
  40ba10:	b900041f 	str	wzr, [x0, #4]
		test->stats->fail_count = 0;
  40ba14:	f9401020 	ldr	x0, [x1, #32]
  40ba18:	b900081f 	str	wzr, [x0, #8]
		test->stats->pass_count = 0;
  40ba1c:	f9401020 	ldr	x0, [x1, #32]
  40ba20:	b9000c1f 	str	wzr, [x0, #12]
		test->stats->duration_worst_ms = 0;
  40ba24:	f9401020 	ldr	x0, [x1, #32]
  40ba28:	b900101f 	str	wzr, [x0, #16]
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40ba2c:	f9400260 	ldr	x0, [x19]
  40ba30:	97fffeb2 	bl	40b4f8 <z_ztest_get_next_test>
  40ba34:	aa0003e1 	mov	x1, x0
  40ba38:	b5fffe60 	cbnz	x0, 40ba04 <z_impl_ztest_run_test_suites+0x90>
			int fail = z_ztest_run_test_suite_ptr(ptr);
  40ba3c:	aa1303e0 	mov	x0, x19
  40ba40:	97fffec8 	bl	40b560 <z_ztest_run_test_suite_ptr>
			stats->fail_count += (fail != 0) ? 1 : 0;
  40ba44:	7100001f 	cmp	w0, #0x0
  40ba48:	b9400a80 	ldr	w0, [x20, #8]
			stats->run_count++;
  40ba4c:	b9400281 	ldr	w1, [x20]
			stats->fail_count += (fail != 0) ? 1 : 0;
  40ba50:	1a800400 	cinc	w0, w0, ne  // ne = any
  40ba54:	b9000a80 	str	w0, [x20, #8]
			stats->run_count++;
  40ba58:	11000421 	add	w1, w1, #0x1
			count++;
  40ba5c:	52800020 	mov	w0, #0x1                   	// #1
			stats->run_count++;
  40ba60:	b9000281 	str	w1, [x20]
		count += __ztest_run_test_suite(ptr, state);
  40ba64:	0b0002b5 	add	w21, w21, w0
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
  40ba68:	b94c0320 	ldr	w0, [x25, #3072]
  40ba6c:	7100081f 	cmp	w0, #0x2
  40ba70:	54fffaa0 	b.eq	40b9c4 <z_impl_ztest_run_test_suites+0x50>  // b.none
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40ba74:	9100e273 	add	x19, x19, #0x38
  40ba78:	17ffffd1 	b	40b9bc <z_impl_ztest_run_test_suites+0x48>
			stats->skip_count++;
  40ba7c:	b9400680 	ldr	w0, [x20, #4]
  40ba80:	11000400 	add	w0, w0, #0x1
  40ba84:	b9000680 	str	w0, [x20, #4]
	int count = 0;
  40ba88:	52800000 	mov	w0, #0x0                   	// #0
  40ba8c:	17fffff6 	b	40ba64 <z_impl_ztest_run_test_suites+0xf0>
		return count;
  40ba90:	52800015 	mov	w21, #0x0                   	// #0
  40ba94:	17ffffcc 	b	40b9c4 <z_impl_ztest_run_test_suites+0x50>

000000000040ba98 <ztest_verify_all_test_suites_ran>:

void ztest_verify_all_test_suites_ran(void)
{
  40ba98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ba9c:	910003fd 	mov	x29, sp
  40baa0:	a90153f3 	stp	x19, x20, [sp, #16]
	bool all_tests_run = true;
	struct ztest_suite_node *suite;
	struct ztest_unit_test *test;

	if (IS_ENABLED(CONFIG_ZTEST_VERIFY_RUN_ALL)) {
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40baa4:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  40baa8:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  40baac:	f9471e73 	ldr	x19, [x19, #3640]
{
  40bab0:	a9025bf5 	stp	x21, x22, [sp, #32]
		     ++suite) {
			if (suite->stats->run_count < 1) {
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40bab4:	d0000056 	adrp	x22, 415000 <random_data+0xca4>
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40bab8:	f9473a94 	ldr	x20, [x20, #3696]
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40babc:	9127dad6 	add	x22, x22, #0x9f6
	bool all_tests_run = true;
  40bac0:	52800035 	mov	w21, #0x1                   	// #1
{
  40bac4:	a90363f7 	stp	x23, x24, [sp, #48]
  40bac8:	f90023f9 	str	x25, [sp, #64]
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40bacc:	eb14027f 	cmp	x19, x20
  40bad0:	54000383 	b.cc	40bb40 <ztest_verify_all_test_suites_ran+0xa8>  // b.lo, b.ul, b.last
				all_tests_run = false;
			}
		}

		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bad4:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40bad8:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
			suite = ztest_find_test_suite(test->test_suite_name);
			if (suite == NULL) {
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40badc:	d0000056 	adrp	x22, 415000 <random_data+0xca4>
  40bae0:	aa0003f8 	mov	x24, x0
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bae4:	f946ea74 	ldr	x20, [x19, #3536]
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40bae8:	91286ed6 	add	x22, x22, #0xa1b
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40baec:	f9473c19 	ldr	x25, [x0, #3704]
  40baf0:	eb19029f 	cmp	x20, x25
  40baf4:	54000383 	b.cc	40bb64 <ztest_verify_all_test_suites_ran+0xcc>  // b.lo, b.ul, b.last
				      test->name, test->test_suite_name);
				all_tests_run = false;
			}
		}

		if (!all_tests_run) {
  40baf8:	35000095 	cbnz	w21, 40bb08 <ztest_verify_all_test_suites_ran+0x70>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  40bafc:	d0000100 	adrp	x0, 42d000 <args_struct>
  40bb00:	52800021 	mov	w1, #0x1                   	// #1
  40bb04:	b90c0001 	str	w1, [x0, #3072]
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bb08:	f946ea73 	ldr	x19, [x19, #3536]
	}

	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
		    test->stats->run_count) {
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40bb0c:	d0000055 	adrp	x21, 415000 <random_data+0xca4>
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bb10:	f9473f18 	ldr	x24, [x24, #3704]
			test_status = 1;
  40bb14:	d0000116 	adrp	x22, 42d000 <args_struct>
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40bb18:	912976b5 	add	x21, x21, #0xa5d
			test_status = 1;
  40bb1c:	913002d6 	add	x22, x22, #0xc00
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bb20:	eb18027f 	cmp	x19, x24
  40bb24:	54000363 	b.cc	40bb90 <ztest_verify_all_test_suites_ran+0xf8>  // b.lo, b.ul, b.last
		}
	}
}
  40bb28:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bb2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40bb30:	a94363f7 	ldp	x23, x24, [sp, #48]
  40bb34:	f94023f9 	ldr	x25, [sp, #64]
  40bb38:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40bb3c:	d65f03c0 	ret
			if (suite->stats->run_count < 1) {
  40bb40:	f9401a60 	ldr	x0, [x19, #48]
  40bb44:	b9400000 	ldr	w0, [x0]
  40bb48:	350000a0 	cbnz	w0, 40bb5c <ztest_verify_all_test_suites_ran+0xc4>
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40bb4c:	f9400261 	ldr	x1, [x19]
  40bb50:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  40bb54:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40bb58:	97ffea51 	bl	40649c <printk>
		     ++suite) {
  40bb5c:	9100e273 	add	x19, x19, #0x38
  40bb60:	17ffffdb 	b	40bacc <ztest_verify_all_test_suites_ran+0x34>
			suite = ztest_find_test_suite(test->test_suite_name);
  40bb64:	f9400297 	ldr	x23, [x20]
  40bb68:	aa1703e0 	mov	x0, x23
  40bb6c:	97fffdde 	bl	40b2e4 <ztest_find_test_suite>
			if (suite == NULL) {
  40bb70:	b50000c0 	cbnz	x0, 40bb88 <ztest_verify_all_test_suites_ran+0xf0>
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40bb74:	f9400681 	ldr	x1, [x20, #8]
  40bb78:	aa1703e2 	mov	x2, x23
  40bb7c:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  40bb80:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40bb84:	97ffea46 	bl	40649c <printk>
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bb88:	9100a294 	add	x20, x20, #0x28
  40bb8c:	17ffffd9 	b	40baf0 <ztest_verify_all_test_suites_ran+0x58>
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
  40bb90:	f9401262 	ldr	x2, [x19, #32]
  40bb94:	29410041 	ldp	w1, w0, [x2, #8]
  40bb98:	0b000021 	add	w1, w1, w0
  40bb9c:	b9400440 	ldr	w0, [x2, #4]
  40bba0:	0b000021 	add	w1, w1, w0
  40bba4:	b9400040 	ldr	w0, [x2]
  40bba8:	6b00003f 	cmp	w1, w0
  40bbac:	540000c0 	b.eq	40bbc4 <ztest_verify_all_test_suites_ran+0x12c>  // b.none
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40bbb0:	a9400a61 	ldp	x1, x2, [x19]
  40bbb4:	aa1503e0 	mov	x0, x21
  40bbb8:	97ffea39 	bl	40649c <printk>
			test_status = 1;
  40bbbc:	52800020 	mov	w0, #0x1                   	// #1
  40bbc0:	b90002c0 	str	w0, [x22]
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bbc4:	9100a273 	add	x19, x19, #0x28
  40bbc8:	17ffffd6 	b	40bb20 <ztest_verify_all_test_suites_ran+0x88>

000000000040bbcc <ztest_run_all>:

void ztest_run_all(const void *state) { ztest_api.run_all(state); }
  40bbcc:	90000101 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40bbd0:	f9479421 	ldr	x1, [x1, #3880]
  40bbd4:	f9400021 	ldr	x1, [x1]
  40bbd8:	aa0103f0 	mov	x16, x1
  40bbdc:	d61f0200 	br	x16

000000000040bbe0 <test_main>:

void __weak test_main(void)
{
  40bbe0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ztest_run_all(NULL);
  40bbe4:	d2800000 	mov	x0, #0x0                   	// #0
{
  40bbe8:	910003fd 	mov	x29, sp
	ztest_run_all(NULL);
  40bbec:	97fffff8 	bl	40bbcc <ztest_run_all>

	ztest_verify_all_test_suites_ran();
}
  40bbf0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ztest_verify_all_test_suites_ran();
  40bbf4:	17ffffa9 	b	40ba98 <ztest_verify_all_test_suites_ran>

000000000040bbf8 <_posix_zephyr_main>:

	return test_status;
}
#else
int main(void)
{
  40bbf8:	d10203ff 	sub	sp, sp, #0x80
  40bbfc:	a9027bfd 	stp	x29, x30, [sp, #32]
  40bc00:	910083fd 	add	x29, sp, #0x20
  40bc04:	a90353f3 	stp	x19, x20, [sp, #48]
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40bc08:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
{
  40bc0c:	a9045bf5 	stp	x21, x22, [sp, #64]
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40bc10:	d0000056 	adrp	x22, 415000 <random_data+0xca4>
  40bc14:	912bfed6 	add	x22, x22, #0xaff
{
  40bc18:	a90563f7 	stp	x23, x24, [sp, #80]
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40bc1c:	52955577 	mov	w23, #0xaaab                	// #43691
  40bc20:	72b55557 	movk	w23, #0xaaaa, lsl #16
{
  40bc24:	a9066bf9 	stp	x25, x26, [sp, #96]
  40bc28:	a90773fb 	stp	x27, x28, [sp, #112]
	k_mem_domain_add_partition(&k_mem_domain_default, &z_malloc_partition);
#endif
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
  40bc2c:	97ffffed 	bl	40bbe0 <test_main>
	flush_log();
  40bc30:	97fffdc4 	bl	40b340 <flush_log>
	TC_SUMMARY_PRINT("\n------ TESTSUITE SUMMARY START ------\n\n");
  40bc34:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40bc38:	9129c800 	add	x0, x0, #0xa72
  40bc3c:	97ffea18 	bl	40649c <printk>
	flush_log();
  40bc40:	97fffdc0 	bl	40b340 <flush_log>
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40bc44:	f9471e94 	ldr	x20, [x20, #3640]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bc48:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40bc4c:	f9473800 	ldr	x0, [x0, #3696]
  40bc50:	eb00029f 	cmp	x20, x0
  40bc54:	54000cc3 	b.cc	40bdec <_posix_zephyr_main+0x1f4>  // b.lo, b.ul, b.last
	TC_SUMMARY_PRINT("------ TESTSUITE SUMMARY END ------\n\n");
  40bc58:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40bc5c:	912cac00 	add	x0, x0, #0xb2b
  40bc60:	97ffea0f 	bl	40649c <printk>
	flush_log();
  40bc64:	d0000054 	adrp	x20, 415000 <random_data+0xca4>
  40bc68:	d0000053 	adrp	x19, 415000 <random_data+0xca4>
  40bc6c:	97fffdb5 	bl	40b340 <flush_log>
	if (test_status) {
  40bc70:	d0000100 	adrp	x0, 42d000 <args_struct>
  40bc74:	b94c0001 	ldr	w1, [x0, #3072]
  40bc78:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
		TC_END_REPORT(TC_FAIL);
  40bc7c:	91256800 	add	x0, x0, #0x95a
	if (test_status) {
  40bc80:	34000fc1 	cbz	w1, 40be78 <_posix_zephyr_main+0x280>
		TC_END_REPORT(TC_FAIL);
  40bc84:	97ffea06 	bl	40649c <printk>
  40bc88:	912d4680 	add	x0, x20, #0xb51
  40bc8c:	97ffea04 	bl	40649c <printk>
  40bc90:	912e0660 	add	x0, x19, #0xb81
  40bc94:	d0000041 	adrp	x1, 415000 <random_data+0xca4>
  40bc98:	912de821 	add	x1, x1, #0xb7a
  40bc9c:	97ffea00 	bl	40649c <printk>
	z_impl_log_panic();
  40bca0:	97fff0ad 	bl	407f54 <z_impl_log_panic>
  40bca4:	52800020 	mov	w0, #0x1                   	// #1
		TC_END_REPORT(TC_PASS);
  40bca8:	97fff980 	bl	40a2a8 <posix_exit>
	end_report();
	flush_log();
  40bcac:	97fffda5 	bl	40b340 <flush_log>
  40bcb0:	97fff0a9 	bl	407f54 <z_impl_log_panic>
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
	return 0;
}
  40bcb4:	52800000 	mov	w0, #0x0                   	// #0
  40bcb8:	a9427bfd 	ldp	x29, x30, [sp, #32]
  40bcbc:	a94353f3 	ldp	x19, x20, [sp, #48]
  40bcc0:	a9445bf5 	ldp	x21, x22, [sp, #64]
  40bcc4:	a94563f7 	ldp	x23, x24, [sp, #80]
  40bcc8:	a9466bf9 	ldp	x25, x26, [sp, #96]
  40bccc:	a94773fb 	ldp	x27, x28, [sp, #112]
  40bcd0:	910203ff 	add	sp, sp, #0x80
  40bcd4:	d65f03c0 	ret
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40bcd8:	f9401260 	ldr	x0, [x19, #32]
		distinct_total++;
  40bcdc:	1100075a 	add	w26, w26, #0x1
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40bce0:	b9401001 	ldr	w1, [x0, #16]
		if (test->stats->skip_count == test->stats->run_count) {
  40bce4:	b9400402 	ldr	w2, [x0, #4]
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40bce8:	0b0102b5 	add	w21, w21, w1
		if (test->stats->skip_count == test->stats->run_count) {
  40bcec:	b9400001 	ldr	w1, [x0]
  40bcf0:	6b01005f 	cmp	w2, w1
  40bcf4:	540006e1 	b.ne	40bdd0 <_posix_zephyr_main+0x1d8>  // b.any
			distinct_skip++;
  40bcf8:	11000718 	add	w24, w24, #0x1
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40bcfc:	f9400280 	ldr	x0, [x20]
  40bd00:	aa1303e1 	mov	x1, x19
  40bd04:	97fffdfd 	bl	40b4f8 <z_ztest_get_next_test>
  40bd08:	aa0003f3 	mov	x19, x0
  40bd0c:	b5fffe60 	cbnz	x0, 40bcd8 <_posix_zephyr_main+0xe0>
	if (distinct_skip == distinct_total) {
  40bd10:	6b18035f 	cmp	w26, w24
  40bd14:	540007a0 	b.eq	40be08 <_posix_zephyr_main+0x210>  // b.none
		expanded_pass = distinct_pass * 100000;
  40bd18:	5290d401 	mov	w1, #0x86a0                	// #34464
		effective_total = distinct_total - distinct_skip;
  40bd1c:	4b180342 	sub	w2, w26, w24
		expanded_pass = distinct_pass * 100000;
  40bd20:	72a00021 	movk	w1, #0x1, lsl #16
		passrate_major = expanded_passrate / 1000;
  40bd24:	52807d08 	mov	w8, #0x3e8                 	// #1000
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bd28:	52800143 	mov	w3, #0xa                   	// #10
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
  40bd2c:	7100039f 	cmp	w28, #0x0
		expanded_pass = distinct_pass * 100000;
  40bd30:	1b017f61 	mul	w1, w27, w1
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
  40bd34:	1a9fd7e0 	cset	w0, gt
		expanded_passrate = expanded_pass / effective_total;
  40bd38:	1ac20c21 	sdiv	w1, w1, w2
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bd3c:	12807ce2 	mov	w2, #0xfffffc18            	// #-1000
		passrate_major = expanded_passrate / 1000;
  40bd40:	1ac80c28 	sdiv	w8, w1, w8
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bd44:	1b020501 	madd	w1, w8, w2, w1
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
  40bd48:	12800122 	mov	w2, #0xfffffff6            	// #-10
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bd4c:	1ac30c23 	sdiv	w3, w1, w3
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
  40bd50:	1b020461 	madd	w1, w3, w2, w1
			passrate_minor++;
  40bd54:	7100103f 	cmp	w1, #0x4
  40bd58:	1a83d463 	cinc	w3, w3, gt
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
  40bd5c:	52807d19 	mov	w25, #0x3e8                 	// #1000
  40bd60:	97fffd33 	bl	40b22c <TC_RESULT_TO_STR>
  40bd64:	b90003fa 	str	w26, [sp]
  40bd68:	aa0003e1 	mov	x1, x0
  40bd6c:	1ad90aa2 	udiv	w2, w21, w25
  40bd70:	2a1803e7 	mov	w7, w24
  40bd74:	2a1c03e6 	mov	w6, w28
  40bd78:	2a1b03e5 	mov	w5, w27
  40bd7c:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40bd80:	912a6c00 	add	x0, x0, #0xa9b
  40bd84:	1b19d455 	msub	w21, w2, w25, w21
  40bd88:	b9000be2 	str	w2, [sp, #8]
  40bd8c:	b90013f5 	str	w21, [sp, #16]
  40bd90:	2a0803e2 	mov	w2, w8
	int flush_frequency = 0;
  40bd94:	52800015 	mov	w21, #0x0                   	// #0
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
  40bd98:	f9400284 	ldr	x4, [x20]
  40bd9c:	97ffe9c0 	bl	40649c <printk>
	flush_log();
  40bda0:	97fffd68 	bl	40b340 <flush_log>
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40bda4:	f9400280 	ldr	x0, [x20]
  40bda8:	aa1303e1 	mov	x1, x19
  40bdac:	97fffdd3 	bl	40b4f8 <z_ztest_get_next_test>
  40bdb0:	aa0003f3 	mov	x19, x0
  40bdb4:	b5000320 	cbnz	x0, 40be18 <_posix_zephyr_main+0x220>
	TC_SUMMARY_PRINT("\n");
  40bdb8:	d0000040 	adrp	x0, 415000 <random_data+0xca4>
  40bdbc:	9135a800 	add	x0, x0, #0xd6a
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bdc0:	9100e294 	add	x20, x20, #0x38
	TC_SUMMARY_PRINT("\n");
  40bdc4:	97ffe9b6 	bl	40649c <printk>
	flush_log();
  40bdc8:	97fffd5e 	bl	40b340 <flush_log>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bdcc:	17ffff9f 	b	40bc48 <_posix_zephyr_main+0x50>
		} else if (test->stats->pass_count == test->stats->run_count) {
  40bdd0:	b9400c00 	ldr	w0, [x0, #12]
  40bdd4:	6b00003f 	cmp	w1, w0
  40bdd8:	54000061 	b.ne	40bde4 <_posix_zephyr_main+0x1ec>  // b.any
			distinct_pass++;
  40bddc:	1100077b 	add	w27, w27, #0x1
  40bde0:	17ffffc7 	b	40bcfc <_posix_zephyr_main+0x104>
			distinct_fail++;
  40bde4:	1100079c 	add	w28, w28, #0x1
  40bde8:	17ffffc5 	b	40bcfc <_posix_zephyr_main+0x104>
	unsigned int suite_duration_worst_ms = 0;
  40bdec:	52800015 	mov	w21, #0x0                   	// #0
	struct ztest_unit_test *test = NULL;
  40bdf0:	d2800013 	mov	x19, #0x0                   	// #0
	int distinct_pass = 0, distinct_fail = 0, distinct_skip = 0, distinct_total = 0;
  40bdf4:	5280001a 	mov	w26, #0x0                   	// #0
  40bdf8:	52800018 	mov	w24, #0x0                   	// #0
  40bdfc:	5280001c 	mov	w28, #0x0                   	// #0
  40be00:	5280001b 	mov	w27, #0x0                   	// #0
  40be04:	17ffffbe 	b	40bcfc <_posix_zephyr_main+0x104>
		suite_result = TC_SKIP;
  40be08:	52800040 	mov	w0, #0x2                   	// #2
		passrate_major = passrate_minor = 0;
  40be0c:	52800003 	mov	w3, #0x0                   	// #0
  40be10:	52800008 	mov	w8, #0x0                   	// #0
  40be14:	17ffffd2 	b	40bd5c <_posix_zephyr_main+0x164>
		if (test->stats->skip_count == test->stats->run_count) {
  40be18:	f9401263 	ldr	x3, [x19, #32]
  40be1c:	29400460 	ldp	w0, w1, [x3]
  40be20:	6b00003f 	cmp	w1, w0
  40be24:	54000260 	b.eq	40be70 <_posix_zephyr_main+0x278>  // b.none
		} else if (test->stats->pass_count == test->stats->run_count) {
  40be28:	b9400c61 	ldr	w1, [x3, #12]
  40be2c:	6b00003f 	cmp	w1, w0
  40be30:	1a9f07e0 	cset	w0, ne  // ne = any
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40be34:	97fffcfe 	bl	40b22c <TC_RESULT_TO_STR>
  40be38:	b9401065 	ldr	w5, [x3, #16]
  40be3c:	a9400e62 	ldp	x2, x3, [x19]
  40be40:	aa0003e1 	mov	x1, x0
  40be44:	aa1603e0 	mov	x0, x22
  40be48:	1ad908a4 	udiv	w4, w5, w25
  40be4c:	1b199485 	msub	w5, w4, w25, w5
  40be50:	97ffe993 	bl	40649c <printk>
  40be54:	1b177ea1 	mul	w1, w21, w23
		if (flush_frequency % 3 == 0) {
  40be58:	3200f3e0 	mov	w0, #0x55555555            	// #1431655765
  40be5c:	6b00003f 	cmp	w1, w0
  40be60:	54000048 	b.hi	40be68 <_posix_zephyr_main+0x270>  // b.pmore
			flush_log();
  40be64:	97fffd37 	bl	40b340 <flush_log>
		flush_frequency++;
  40be68:	110006b5 	add	w21, w21, #0x1
  40be6c:	17ffffce 	b	40bda4 <_posix_zephyr_main+0x1ac>
			tc_result = TC_SKIP;
  40be70:	52800040 	mov	w0, #0x2                   	// #2
  40be74:	17fffff0 	b	40be34 <_posix_zephyr_main+0x23c>
		TC_END_REPORT(TC_PASS);
  40be78:	97ffe989 	bl	40649c <printk>
  40be7c:	912d4680 	add	x0, x20, #0xb51
  40be80:	97ffe987 	bl	40649c <printk>
  40be84:	912e0660 	add	x0, x19, #0xb81
  40be88:	d0000041 	adrp	x1, 415000 <random_data+0xca4>
  40be8c:	912e5c21 	add	x1, x1, #0xb97
  40be90:	97ffe983 	bl	40649c <printk>
  40be94:	97fff030 	bl	407f54 <z_impl_log_panic>
  40be98:	52800000 	mov	w0, #0x0                   	// #0
  40be9c:	17ffff83 	b	40bca8 <_posix_zephyr_main+0xb0>

000000000040bea0 <add_test_filter_option>:
		  "\'suiteA::test1,suiteA::test2,suiteB::*\'. An * can be used "
		  "as a wildcard to run all tests within a suite." },
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(test_filter_s);
  40bea0:	b0000100 	adrp	x0, 42c000 <__dso_handle>
  40bea4:	910d0000 	add	x0, x0, #0x340
  40bea8:	17fffc23 	b	40af34 <native_add_command_line_opts>

000000000040beac <z_ztest_testargs_contains>:
 * @param test_name
 * @return true
 * @return false
 */
static bool z_ztest_testargs_contains(const char *suite_name, const char *test_name)
{
  40beac:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40beb0:	910003fd 	mov	x29, sp
  40beb4:	a90363f7 	stp	x23, x24, [sp, #48]
  40beb8:	aa0003f7 	mov	x23, x0
  40bebc:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40bec0:	a90153f3 	stp	x19, x20, [sp, #16]
  40bec4:	aa0103f4 	mov	x20, x1
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
		test_arg = strtok_r(NULL, ":", &last_arg);

		found = !strcmp(suite_arg, suite_name);
		if (test_name) {
			found &= !strcmp(test_arg, "*") ||
  40bec8:	d0000058 	adrp	x24, 415000 <random_data+0xca4>
{
  40becc:	f9476800 	ldr	x0, [x0, #3792]
  40bed0:	a9025bf5 	stp	x21, x22, [sp, #32]
			found &= !strcmp(test_arg, "*") ||
  40bed4:	912e9318 	add	x24, x24, #0xba4
{
  40bed8:	a9046bf9 	stp	x25, x26, [sp, #64]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40bedc:	d0000055 	adrp	x21, 415000 <random_data+0xca4>
  40bee0:	911c4eb5 	add	x21, x21, #0x713
{
  40bee4:	a90573fb 	stp	x27, x28, [sp, #80]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40bee8:	9101c3fb 	add	x27, sp, #0x70
	bool found = false;
  40beec:	52800013 	mov	w19, #0x0                   	// #0
{
  40bef0:	f9400001 	ldr	x1, [x0]
  40bef4:	f9003fe1 	str	x1, [sp, #120]
  40bef8:	d2800001 	mov	x1, #0x0                   	// #0
	char *test_args_local = strdup(test_args);
  40befc:	d0000100 	adrp	x0, 42d000 <args_struct>
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40bf00:	9101a3f9 	add	x25, sp, #0x68
  40bf04:	d000005a 	adrp	x26, 415000 <random_data+0xca4>
	char *test_args_local = strdup(test_args);
  40bf08:	f9408c00 	ldr	x0, [x0, #280]
  40bf0c:	97ffd501 	bl	401310 <strdup@plt>
  40bf10:	aa0003f6 	mov	x22, x0
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40bf14:	aa1903e2 	mov	x2, x25
  40bf18:	912e8b41 	add	x1, x26, #0xba2
  40bf1c:	97ffd4d5 	bl	401270 <strtok_r@plt>
	while (suite_test_pair && !found) {
  40bf20:	f100001f 	cmp	x0, #0x0
  40bf24:	52000261 	eor	w1, w19, #0x1
  40bf28:	1a9f07e2 	cset	w2, ne  // ne = any
  40bf2c:	6a01005f 	tst	w2, w1
  40bf30:	54000161 	b.ne	40bf5c <z_ztest_testargs_contains+0xb0>  // b.any
		}

		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
	}

	free(test_args_local);
  40bf34:	aa1603e0 	mov	x0, x22
  40bf38:	97ffd52a 	bl	4013e0 <free@plt>
	return found;
}
  40bf3c:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40bf40:	f9476800 	ldr	x0, [x0, #3792]
  40bf44:	f9403fe2 	ldr	x2, [sp, #120]
  40bf48:	f9400001 	ldr	x1, [x0]
  40bf4c:	eb010042 	subs	x2, x2, x1
  40bf50:	d2800001 	mov	x1, #0x0                   	// #0
  40bf54:	54000440 	b.eq	40bfdc <z_ztest_testargs_contains+0x130>  // b.none
  40bf58:	97ffd4f2 	bl	401320 <__stack_chk_fail@plt>
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40bf5c:	aa1b03e2 	mov	x2, x27
  40bf60:	aa1503e1 	mov	x1, x21
  40bf64:	97ffd4c3 	bl	401270 <strtok_r@plt>
  40bf68:	aa0003f3 	mov	x19, x0
		test_arg = strtok_r(NULL, ":", &last_arg);
  40bf6c:	aa1b03e2 	mov	x2, x27
  40bf70:	aa1503e1 	mov	x1, x21
  40bf74:	d2800000 	mov	x0, #0x0                   	// #0
  40bf78:	97ffd4be 	bl	401270 <strtok_r@plt>
		found = !strcmp(suite_arg, suite_name);
  40bf7c:	aa1703e1 	mov	x1, x23
		test_arg = strtok_r(NULL, ":", &last_arg);
  40bf80:	aa0003fc 	mov	x28, x0
		found = !strcmp(suite_arg, suite_name);
  40bf84:	aa1303e0 	mov	x0, x19
  40bf88:	97ffd506 	bl	4013a0 <strcmp@plt>
  40bf8c:	7100001f 	cmp	w0, #0x0
  40bf90:	1a9f17f3 	cset	w19, eq  // eq = none
		if (test_name) {
  40bf94:	b4000174 	cbz	x20, 40bfc0 <z_ztest_testargs_contains+0x114>
			found &= !strcmp(test_arg, "*") ||
  40bf98:	aa1803e1 	mov	x1, x24
  40bf9c:	aa1c03e0 	mov	x0, x28
  40bfa0:	97ffd500 	bl	4013a0 <strcmp@plt>
  40bfa4:	34000180 	cbz	w0, 40bfd4 <z_ztest_testargs_contains+0x128>
				 !strcmp(test_arg, test_name);
  40bfa8:	aa1403e1 	mov	x1, x20
  40bfac:	aa1c03e0 	mov	x0, x28
  40bfb0:	97ffd4fc 	bl	4013a0 <strcmp@plt>
			found &= !strcmp(test_arg, "*") ||
  40bfb4:	7100001f 	cmp	w0, #0x0
  40bfb8:	1a9f17e0 	cset	w0, eq  // eq = none
  40bfbc:	0a000273 	and	w19, w19, w0
		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
  40bfc0:	aa1903e2 	mov	x2, x25
  40bfc4:	912e8b41 	add	x1, x26, #0xba2
  40bfc8:	d2800000 	mov	x0, #0x0                   	// #0
  40bfcc:	97ffd4a9 	bl	401270 <strtok_r@plt>
  40bfd0:	17ffffd4 	b	40bf20 <z_ztest_testargs_contains+0x74>
			found &= !strcmp(test_arg, "*") ||
  40bfd4:	52800020 	mov	w0, #0x1                   	// #1
  40bfd8:	17fffff9 	b	40bfbc <z_ztest_testargs_contains+0x110>
}
  40bfdc:	2a1303e0 	mov	w0, w19
  40bfe0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bfe4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40bfe8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40bfec:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40bff0:	a94573fb 	ldp	x27, x28, [sp, #80]
  40bff4:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40bff8:	d65f03c0 	ret

000000000040bffc <z_ztest_should_test_run>:
 */
bool z_ztest_should_test_run(const char *suite, const char *test)
{
	bool run_test = false;

	run_test = (test_args == NULL ||
  40bffc:	d0000102 	adrp	x2, 42d000 <args_struct>
  40c000:	f9408c42 	ldr	x2, [x2, #280]
  40c004:	b4000102 	cbz	x2, 40c024 <z_ztest_should_test_run+0x28>
{
  40c008:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40c00c:	910003fd 	mov	x29, sp
		    z_ztest_testargs_contains(suite, test));
  40c010:	97ffffa7 	bl	40beac <z_ztest_testargs_contains>
  40c014:	12001c00 	and	w0, w0, #0xff

	return run_test;
}
  40c018:	12000000 	and	w0, w0, #0x1
  40c01c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40c020:	d65f03c0 	ret
	run_test = (test_args == NULL ||
  40c024:	52800020 	mov	w0, #0x1                   	// #1
}
  40c028:	12000000 	and	w0, w0, #0x1
  40c02c:	d65f03c0 	ret

000000000040c030 <z_ztest_should_suite_run>:
 * @param suite Pointer to ztest_suite_node
 * @return true
 * @return false
 */
bool z_ztest_should_suite_run(const void *state, struct ztest_suite_node *suite)
{
  40c030:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c034:	910003fd 	mov	x29, sp
  40c038:	a90153f3 	stp	x19, x20, [sp, #16]
  40c03c:	aa0003f4 	mov	x20, x0
	bool run_suite = true;

	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40c040:	b0000100 	adrp	x0, 42d000 <args_struct>
{
  40c044:	aa0103f3 	mov	x19, x1
	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40c048:	f9408c00 	ldr	x0, [x0, #280]
  40c04c:	b40001a0 	cbz	x0, 40c080 <z_ztest_should_suite_run+0x50>
  40c050:	f9400260 	ldr	x0, [x19]
  40c054:	d2800001 	mov	x1, #0x0                   	// #0
  40c058:	97ffff95 	bl	40beac <z_ztest_testargs_contains>
  40c05c:	72001c00 	ands	w0, w0, #0xff
  40c060:	54000101 	b.ne	40c080 <z_ztest_should_suite_run+0x50>  // b.any
  40c064:	f9401a62 	ldr	x2, [x19, #48]
		run_suite = false;
		suite->stats->run_count++;
  40c068:	b9400041 	ldr	w1, [x2]
  40c06c:	11000421 	add	w1, w1, #0x1
  40c070:	b9000041 	str	w1, [x2]
	} else if (suite->predicate != NULL) {
		run_suite = suite->predicate(state);
	}

	return run_suite;
}
  40c074:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c078:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c07c:	d65f03c0 	ret
	} else if (suite->predicate != NULL) {
  40c080:	f9401661 	ldr	x1, [x19, #40]
  40c084:	b40000c1 	cbz	x1, 40c09c <z_ztest_should_suite_run+0x6c>
		run_suite = suite->predicate(state);
  40c088:	aa1403e0 	mov	x0, x20
  40c08c:	aa0103f0 	mov	x16, x1
}
  40c090:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c094:	a8c27bfd 	ldp	x29, x30, [sp], #32
		run_suite = suite->predicate(state);
  40c098:	d61f0200 	br	x16
	bool run_suite = true;
  40c09c:	52800020 	mov	w0, #0x1                   	// #1
  40c0a0:	17fffff5 	b	40c074 <z_ztest_should_suite_run+0x44>

000000000040c0a4 <ztest_relative_filename>:
{
  40c0a4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  40c0a8:	910003fd 	mov	x29, sp
  40c0ac:	a90153f3 	stp	x19, x20, [sp, #16]
  40c0b0:	aa0003f3 	mov	x19, x0
  40c0b4:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40c0b8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c0bc:	f9476800 	ldr	x0, [x0, #3792]
  40c0c0:	f9400001 	ldr	x1, [x0]
  40c0c4:	f9007fe1 	str	x1, [sp, #248]
  40c0c8:	d2800001 	mov	x1, #0x0                   	// #0
		       "destination buffer");

__fortify_function __wur char *
__NTH (getcwd (char *__buf, size_t __size))
{
  return __glibc_fortify (getcwd, __size, sizeof (char),
  40c0cc:	9100c3e0 	add	x0, sp, #0x30
  40c0d0:	d2801901 	mov	x1, #0xc8                  	// #200
  40c0d4:	97ffd42b 	bl	401180 <getcwd@plt>
	if (cwd && strlen(file) > strlen(cwd) && !strncmp(file, cwd, strlen(cwd))) {
  40c0d8:	b4000220 	cbz	x0, 40c11c <ztest_relative_filename+0x78>
  40c0dc:	aa0003f5 	mov	x21, x0
  40c0e0:	aa1303e0 	mov	x0, x19
  40c0e4:	97ffd42f 	bl	4011a0 <strlen@plt>
  40c0e8:	aa0003f6 	mov	x22, x0
  40c0ec:	aa1503e0 	mov	x0, x21
  40c0f0:	97ffd42c 	bl	4011a0 <strlen@plt>
  40c0f4:	aa0003f4 	mov	x20, x0
  40c0f8:	eb0002df 	cmp	x22, x0
  40c0fc:	54000109 	b.ls	40c11c <ztest_relative_filename+0x78>  // b.plast
  40c100:	aa0003e2 	mov	x2, x0
  40c104:	aa1503e1 	mov	x1, x21
  40c108:	aa1303e0 	mov	x0, x19
  40c10c:	97ffd461 	bl	401290 <strncmp@plt>
  40c110:	35000060 	cbnz	w0, 40c11c <ztest_relative_filename+0x78>
		return file + strlen(cwd) + 1; /* move past the trailing '/' */
  40c114:	91000694 	add	x20, x20, #0x1
  40c118:	8b140273 	add	x19, x19, x20
}
  40c11c:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40c120:	f9476800 	ldr	x0, [x0, #3792]
  40c124:	f9407fe2 	ldr	x2, [sp, #248]
  40c128:	f9400001 	ldr	x1, [x0]
  40c12c:	eb010042 	subs	x2, x2, x1
  40c130:	d2800001 	mov	x1, #0x0                   	// #0
  40c134:	54000040 	b.eq	40c13c <ztest_relative_filename+0x98>  // b.none
  40c138:	97ffd47a 	bl	401320 <__stack_chk_fail@plt>
  40c13c:	aa1303e0 	mov	x0, x19
  40c140:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c144:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c148:	a8d07bfd 	ldp	x29, x30, [sp], #256
  40c14c:	d65f03c0 	ret

000000000040c150 <z_ztest_get_list_test>:
}
  40c150:	d0000100 	adrp	x0, 42e000 <irq_prio+0xf>
  40c154:	39405800 	ldrb	w0, [x0, #22]
  40c158:	d65f03c0 	ret

000000000040c15c <z_ztest_list_tests>:
{
  40c15c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40c160:	910003fd 	mov	x29, sp
  40c164:	a90363f7 	stp	x23, x24, [sp, #48]
	if (list_once) {
  40c168:	90000118 	adrp	x24, 42c000 <__dso_handle>
  40c16c:	39504700 	ldrb	w0, [x24, #1041]
{
  40c170:	a90153f3 	stp	x19, x20, [sp, #16]
  40c174:	a9025bf5 	stp	x21, x22, [sp, #32]
	int test_count = 0;
  40c178:	52800015 	mov	w21, #0x0                   	// #0
	if (list_once) {
  40c17c:	350002e0 	cbnz	w0, 40c1d8 <z_ztest_list_tests+0x7c>
}
  40c180:	2a1503e0 	mov	w0, w21
  40c184:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c188:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c18c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c190:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40c194:	d65f03c0 	ret
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c198:	a9400a61 	ldp	x1, x2, [x19]
  40c19c:	aa1703e0 	mov	x0, x23
				test_count++;
  40c1a0:	110006b5 	add	w21, w21, #0x1
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c1a4:	97ffe8be 	bl	40649c <printk>
			while ((test = z_ztest_get_next_test(ptr->name, test)) != NULL) {
  40c1a8:	f9400280 	ldr	x0, [x20]
  40c1ac:	aa1303e1 	mov	x1, x19
  40c1b0:	97fffcd2 	bl	40b4f8 <z_ztest_get_next_test>
  40c1b4:	aa0003f3 	mov	x19, x0
  40c1b8:	b5ffff00 	cbnz	x0, 40c198 <z_ztest_list_tests+0x3c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c1bc:	9100e294 	add	x20, x20, #0x38
  40c1c0:	eb16029f 	cmp	x20, x22
  40c1c4:	54000063 	b.cc	40c1d0 <z_ztest_list_tests+0x74>  // b.lo, b.ul, b.last
		list_once = false;
  40c1c8:	3910471f 	strb	wzr, [x24, #1041]
	return test_count;
  40c1cc:	17ffffed 	b	40c180 <z_ztest_list_tests+0x24>
			test = NULL;
  40c1d0:	d2800013 	mov	x19, #0x0                   	// #0
  40c1d4:	17fffff5 	b	40c1a8 <z_ztest_list_tests+0x4c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c1d8:	f00000f4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  40c1dc:	f00000f6 	adrp	x22, 42b000 <__FRAME_END__+0xff4c>
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c1e0:	b0000057 	adrp	x23, 415000 <random_data+0xca4>
  40c1e4:	912e9af7 	add	x23, x23, #0xba6
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c1e8:	f9471e94 	ldr	x20, [x20, #3640]
  40c1ec:	f9473ad6 	ldr	x22, [x22, #3696]
  40c1f0:	17fffff4 	b	40c1c0 <z_ztest_list_tests+0x64>

000000000040c1f4 <z_ztest_run_all>:
{
  40c1f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c1f8:	910003fd 	mov	x29, sp
  40c1fc:	f9000bf3 	str	x19, [sp, #16]
  40c200:	aa0003f3 	mov	x19, x0
	if (z_ztest_get_list_test()) {
  40c204:	97ffffd3 	bl	40c150 <z_ztest_get_list_test>
  40c208:	72001c1f 	tst	w0, #0xff
  40c20c:	54000080 	b.eq	40c21c <z_ztest_run_all+0x28>  // b.none
}
  40c210:	f9400bf3 	ldr	x19, [sp, #16]
  40c214:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_ztest_list_tests();
  40c218:	17ffffd1 	b	40c15c <z_ztest_list_tests>
		union { uintptr_t x; const void * val; } parm0 = { .val = state };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_ZTEST_RUN_TEST_SUITES);
	}
#endif
	compiler_barrier();
	return z_impl_ztest_run_test_suites(state);
  40c21c:	aa1303e0 	mov	x0, x19
}
  40c220:	f9400bf3 	ldr	x19, [sp, #16]
  40c224:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c228:	17fffdd3 	b	40b974 <z_impl_ztest_run_test_suites>

000000000040c22c <generic_data_ref>:

	net_buf_simple_reset(&buf->b);
}

static uint8_t *generic_data_ref(struct net_buf *buf, uint8_t *data)
{
  40c22c:	aa0103e0 	mov	x0, x1
	uint8_t *ref_count;

	ref_count = data - sizeof(void *);
	(*ref_count)++;
  40c230:	385f8021 	ldurb	w1, [x1, #-8]
  40c234:	11000421 	add	w1, w1, #0x1
  40c238:	381f8001 	sturb	w1, [x0, #-8]

	return data;
}
  40c23c:	d65f03c0 	ret

000000000040c240 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
  40c240:	d65f03c0 	ret

000000000040c244 <net_buf_pool_get>:
}
  40c244:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40c248:	52800c02 	mov	w2, #0x60                  	// #96
  40c24c:	f9479821 	ldr	x1, [x1, #3888]
  40c250:	9b220400 	smaddl	x0, w0, w2, x1
  40c254:	d65f03c0 	ret

000000000040c258 <mem_pool_data_unref>:
{
  40c258:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c25c:	910003fd 	mov	x29, sp
  40c260:	f9000bf3 	str	x19, [sp, #16]
  40c264:	aa0103f3 	mov	x19, x1
	struct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);
  40c268:	39404800 	ldrb	w0, [x0, #18]
  40c26c:	97fffff6 	bl	40c244 <net_buf_pool_get>
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c270:	f9402800 	ldr	x0, [x0, #80]
	if (--(*ref_count)) {
  40c274:	385f8262 	ldurb	w2, [x19, #-8]
  40c278:	51000442 	sub	w2, w2, #0x1
  40c27c:	12001c42 	and	w2, w2, #0xff
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c280:	f9400400 	ldr	x0, [x0, #8]
	if (--(*ref_count)) {
  40c284:	381f8262 	sturb	w2, [x19, #-8]
  40c288:	350000a2 	cbnz	w2, 40c29c <mem_pool_data_unref+0x44>
	k_heap_free(pool, ref_count);
  40c28c:	d1002261 	sub	x1, x19, #0x8
}
  40c290:	f9400bf3 	ldr	x19, [sp, #16]
  40c294:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_heap_free(pool, ref_count);
  40c298:	140006a4 	b	40dd28 <k_heap_free>
}
  40c29c:	f9400bf3 	ldr	x19, [sp, #16]
  40c2a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c2a4:	d65f03c0 	ret

000000000040c2a8 <mem_pool_data_alloc>:
{
  40c2a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c2ac:	910003fd 	mov	x29, sp
  40c2b0:	a90153f3 	stp	x19, x20, [sp, #16]
  40c2b4:	aa0103f4 	mov	x20, x1
  40c2b8:	aa0203f3 	mov	x19, x2
	struct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);
  40c2bc:	39404800 	ldrb	w0, [x0, #18]
  40c2c0:	97ffffe1 	bl	40c244 <net_buf_pool_get>
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c2c4:	f9402800 	ldr	x0, [x0, #80]
	void *b = k_heap_alloc(pool, sizeof(void *) + *size, timeout);
  40c2c8:	aa1303e2 	mov	x2, x19
  40c2cc:	f9400281 	ldr	x1, [x20]
  40c2d0:	f9400400 	ldr	x0, [x0, #8]
  40c2d4:	91002021 	add	x1, x1, #0x8
  40c2d8:	94000690 	bl	40dd18 <k_heap_alloc>
	if (b == NULL) {
  40c2dc:	b4000060 	cbz	x0, 40c2e8 <mem_pool_data_alloc+0x40>
	*ref_count = 1U;
  40c2e0:	52800021 	mov	w1, #0x1                   	// #1
  40c2e4:	38008401 	strb	w1, [x0], #8
}
  40c2e8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c2ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c2f0:	d65f03c0 	ret

000000000040c2f4 <data_alloc>:
};

#endif /* CONFIG_HEAP_MEM_POOL_SIZE > 0 */

static uint8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)
{
  40c2f4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c2f8:	910003fd 	mov	x29, sp
  40c2fc:	a90153f3 	stp	x19, x20, [sp, #16]
  40c300:	aa0003f3 	mov	x19, x0
  40c304:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c308:	39404800 	ldrb	w0, [x0, #18]
{
  40c30c:	f90013f5 	str	x21, [sp, #32]
  40c310:	aa0203f5 	mov	x21, x2
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c314:	97ffffcc 	bl	40c244 <net_buf_pool_get>

	return pool->alloc->cb->alloc(buf, size, timeout);
  40c318:	f9402800 	ldr	x0, [x0, #80]
  40c31c:	aa1503e2 	mov	x2, x21
  40c320:	aa1403e1 	mov	x1, x20
}
  40c324:	f94013f5 	ldr	x21, [sp, #32]
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c328:	f9400000 	ldr	x0, [x0]
  40c32c:	f9400003 	ldr	x3, [x0]
  40c330:	aa1303e0 	mov	x0, x19
}
  40c334:	a94153f3 	ldp	x19, x20, [sp, #16]
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c338:	aa0303f0 	mov	x16, x3
}
  40c33c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c340:	d61f0200 	br	x16

000000000040c344 <net_buf_destroy>:
{
  40c344:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c348:	910003fd 	mov	x29, sp
  40c34c:	f9000bf3 	str	x19, [sp, #16]
  40c350:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c354:	39404800 	ldrb	w0, [x0, #18]
  40c358:	97ffffbb 	bl	40c244 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40c35c:	aa1303e1 	mov	x1, x19
}
  40c360:	f9400bf3 	ldr	x19, [sp, #16]
  40c364:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_lifo_put(&pool->free, buf);
  40c368:	14000c67 	b	40f504 <k_queue_prepend>

000000000040c36c <net_buf_id>:
{
  40c36c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c370:	910003fd 	mov	x29, sp
  40c374:	f9000bf3 	str	x19, [sp, #16]
  40c378:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c37c:	39404800 	ldrb	w0, [x0, #18]
  40c380:	97ffffb1 	bl	40c244 <net_buf_pool_get>
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40c384:	f9402c01 	ldr	x1, [x0, #88]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c388:	39411000 	ldrb	w0, [x0, #68]
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40c38c:	cb010273 	sub	x19, x19, x1
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c390:	9100dc00 	add	x0, x0, #0x37
  40c394:	927df000 	and	x0, x0, #0xfffffffffffffff8
}
  40c398:	9ac00a60 	udiv	x0, x19, x0
  40c39c:	f9400bf3 	ldr	x19, [sp, #16]
  40c3a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c3a4:	d65f03c0 	ret

000000000040c3a8 <fixed_data_alloc>:
{
  40c3a8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c3ac:	910003fd 	mov	x29, sp
  40c3b0:	a90153f3 	stp	x19, x20, [sp, #16]
  40c3b4:	aa0003f3 	mov	x19, x0
  40c3b8:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c3bc:	39404800 	ldrb	w0, [x0, #18]
{
  40c3c0:	f90013f5 	str	x21, [sp, #32]
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c3c4:	97ffffa0 	bl	40c244 <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40c3c8:	f9402800 	ldr	x0, [x0, #80]
  40c3cc:	f9400401 	ldr	x1, [x0, #8]
	*size = MIN(fixed->data_size, *size);
  40c3d0:	f9400280 	ldr	x0, [x20]
  40c3d4:	f9400022 	ldr	x2, [x1]
  40c3d8:	eb02001f 	cmp	x0, x2
  40c3dc:	9a829000 	csel	x0, x0, x2, ls  // ls = plast
  40c3e0:	f9000280 	str	x0, [x20]
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
  40c3e4:	aa1303e0 	mov	x0, x19
  40c3e8:	a9405035 	ldp	x21, x20, [x1]
  40c3ec:	97ffffe0 	bl	40c36c <net_buf_id>
  40c3f0:	93407c00 	sxtw	x0, w0
}
  40c3f4:	9b155000 	madd	x0, x0, x21, x20
  40c3f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c3fc:	f94013f5 	ldr	x21, [sp, #32]
  40c400:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40c404:	d65f03c0 	ret

000000000040c408 <net_buf_reset>:
{
  40c408:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c40c:	910003fd 	mov	x29, sp
  40c410:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(buf->flags == 0U);
  40c414:	39404401 	ldrb	w1, [x0, #17]
  40c418:	34000241 	cbz	w1, 40c460 <net_buf_reset+0x58>
  40c41c:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40c420:	9131fa73 	add	x19, x19, #0xc7e
  40c424:	aa1303e2 	mov	x2, x19
  40c428:	52800b43 	mov	w3, #0x5a                  	// #90
  40c42c:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40c430:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c434:	91328821 	add	x1, x1, #0xca2
  40c438:	911e2800 	add	x0, x0, #0x78a
  40c43c:	97ffedd5 	bl	407b90 <assert_print>
  40c440:	aa1303e0 	mov	x0, x19
  40c444:	52800b41 	mov	w1, #0x5a                  	// #90
  40c448:	97ffedfc 	bl	407c38 <assert_post_action>
  40c44c:	52800b42 	mov	w2, #0x5a                  	// #90
	__ASSERT_NO_MSG(buf->frags == NULL);
  40c450:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c454:	aa1303e1 	mov	x1, x19
  40c458:	911f2000 	add	x0, x0, #0x7c8
  40c45c:	97fff7e9 	bl	40a400 <posix_print_error_and_exit>
  40c460:	f9400401 	ldr	x1, [x0, #8]
  40c464:	b40001e1 	cbz	x1, 40c4a0 <net_buf_reset+0x98>
  40c468:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40c46c:	9131fa73 	add	x19, x19, #0xc7e
  40c470:	aa1303e2 	mov	x2, x19
  40c474:	52800b63 	mov	w3, #0x5b                  	// #91
  40c478:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40c47c:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c480:	9132cc21 	add	x1, x1, #0xcb3
  40c484:	911e2800 	add	x0, x0, #0x78a
  40c488:	97ffedc2 	bl	407b90 <assert_print>
  40c48c:	aa1303e0 	mov	x0, x19
  40c490:	52800b61 	mov	w1, #0x5b                  	// #91
  40c494:	97ffede9 	bl	407c38 <assert_post_action>
  40c498:	52800b62 	mov	w2, #0x5b                  	// #91
  40c49c:	17ffffed 	b	40c450 <net_buf_reset+0x48>
	buf->data = buf->__buf;
  40c4a0:	f9401401 	ldr	x1, [x0, #40]
  40c4a4:	f9000c01 	str	x1, [x0, #24]
	buf->len  = 0U;
  40c4a8:	7900401f 	strh	wzr, [x0, #32]
}
  40c4ac:	f9400bf3 	ldr	x19, [sp, #16]
  40c4b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c4b4:	d65f03c0 	ret

000000000040c4b8 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
  40c4b8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40c4bc:	910003fd 	mov	x29, sp
  40c4c0:	a90153f3 	stp	x19, x20, [sp, #16]
  40c4c4:	aa0003f4 	mov	x20, x0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
  40c4c8:	aa0203e0 	mov	x0, x2
{
  40c4cc:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c4d0:	aa0203f5 	mov	x21, x2
  40c4d4:	a90363f7 	stp	x23, x24, [sp, #48]
  40c4d8:	f90023f9 	str	x25, [sp, #64]
  40c4dc:	f9002fe1 	str	x1, [sp, #88]
	uint64_t end = sys_clock_timeout_end_calc(timeout);
  40c4e0:	94001ac9 	bl	413004 <sys_clock_timeout_end_calc>
	struct net_buf *buf;
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(pool);
  40c4e4:	b5000254 	cbnz	x20, 40c52c <net_buf_alloc_len+0x74>
  40c4e8:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40c4ec:	9131fa73 	add	x19, x19, #0xc7e
  40c4f0:	aa1303e2 	mov	x2, x19
  40c4f4:	52801f03 	mov	w3, #0xf8                  	// #248
  40c4f8:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40c4fc:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c500:	91333421 	add	x1, x1, #0xccd
  40c504:	911e2800 	add	x0, x0, #0x78a
  40c508:	97ffeda2 	bl	407b90 <assert_print>
  40c50c:	aa1303e0 	mov	x0, x19
  40c510:	52801f01 	mov	w1, #0xf8                  	// #248
  40c514:	97ffedc9 	bl	407c38 <assert_post_action>
  40c518:	52801f02 	mov	w2, #0xf8                  	// #248
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40c51c:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c520:	aa1303e1 	mov	x1, x19
  40c524:	911f2000 	add	x0, x0, #0x7c8
  40c528:	97fff7b6 	bl	40a400 <posix_print_error_and_exit>
  40c52c:	aa0003f7 	mov	x23, x0
	NET_BUF_DBG("%s():%d: pool %p size %zu", func, line, pool, size);

	/* We need to prevent race conditions
	 * when accessing pool->uninit_count.
	 */
	key = k_spin_lock(&pool->lock);
  40c530:	9100e296 	add	x22, x20, #0x38
	return posix_irq_lock();
  40c534:	97fff69d 	bl	409fa8 <posix_irq_lock>
  40c538:	2a0003f8 	mov	w24, w0
  40c53c:	aa1603e0 	mov	x0, x22
  40c540:	94000841 	bl	40e644 <z_spin_lock_valid>
  40c544:	72001c1f 	tst	w0, #0xff
  40c548:	54000261 	b.ne	40c594 <net_buf_alloc_len+0xdc>  // b.any
  40c54c:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40c550:	91334a73 	add	x19, x19, #0xcd2
  40c554:	aa1303e2 	mov	x2, x19
  40c558:	52801283 	mov	w3, #0x94                  	// #148
  40c55c:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40c560:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c564:	9133fc21 	add	x1, x1, #0xcff
  40c568:	911e2800 	add	x0, x0, #0x78a
  40c56c:	97ffed89 	bl	407b90 <assert_print>
  40c570:	aa1603e1 	mov	x1, x22
  40c574:	b0000040 	adrp	x0, 415000 <random_data+0xca4>
  40c578:	91345000 	add	x0, x0, #0xd14
  40c57c:	97ffed85 	bl	407b90 <assert_print>
  40c580:	aa1303e0 	mov	x0, x19
  40c584:	52801281 	mov	w1, #0x94                  	// #148
  40c588:	97ffedac 	bl	407c38 <assert_post_action>
  40c58c:	52801282 	mov	w2, #0x94                  	// #148
  40c590:	17ffffe3 	b	40c51c <net_buf_alloc_len+0x64>
		arch_spin_relax();
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
  40c594:	aa1603e0 	mov	x0, x22
  40c598:	94000843 	bl	40e6a4 <z_spin_lock_set_owner>

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
  40c59c:	79408680 	ldrh	w0, [x20, #66]
  40c5a0:	340009e0 	cbz	w0, 40c6dc <net_buf_alloc_len+0x224>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
  40c5a4:	79408281 	ldrh	w1, [x20, #64]
  40c5a8:	6b00003f 	cmp	w1, w0
  40c5ac:	54000609 	b.ls	40c66c <net_buf_alloc_len+0x1b4>  // b.plast
	return z_impl_k_queue_get(queue, timeout);
  40c5b0:	d2800001 	mov	x1, #0x0                   	// #0
  40c5b4:	aa1403e0 	mov	x0, x20
  40c5b8:	94000bd8 	bl	40f518 <z_impl_k_queue_get>
  40c5bc:	aa0003f3 	mov	x19, x0
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
  40c5c0:	b4000560 	cbz	x0, 40c66c <net_buf_alloc_len+0x1b4>
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40c5c4:	aa1603e0 	mov	x0, x22
  40c5c8:	9400082a 	bl	40e670 <z_spin_unlock_valid>
  40c5cc:	72001c1f 	tst	w0, #0xff
  40c5d0:	54000261 	b.ne	40c61c <net_buf_alloc_len+0x164>  // b.any
  40c5d4:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40c5d8:	91334a73 	add	x19, x19, #0xcd2
  40c5dc:	aa1303e2 	mov	x2, x19
  40c5e0:	52801863 	mov	w3, #0xc3                  	// #195
  40c5e4:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40c5e8:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c5ec:	9134b021 	add	x1, x1, #0xd2c
  40c5f0:	911e2800 	add	x0, x0, #0x78a
  40c5f4:	97ffed67 	bl	407b90 <assert_print>
  40c5f8:	aa1603e1 	mov	x1, x22
  40c5fc:	b0000040 	adrp	x0, 415000 <random_data+0xca4>
  40c600:	91350c00 	add	x0, x0, #0xd43
  40c604:	97ffed63 	bl	407b90 <assert_print>
  40c608:	aa1303e0 	mov	x0, x19
  40c60c:	52801861 	mov	w1, #0xc3                  	// #195
  40c610:	97ffed8a 	bl	407c38 <assert_post_action>
  40c614:	52801862 	mov	w2, #0xc3                  	// #195
  40c618:	17ffffc1 	b	40c51c <net_buf_alloc_len+0x64>
	posix_irq_unlock(key);
  40c61c:	2a1803e0 	mov	w0, w24
  40c620:	97fff664 	bl	409fb0 <posix_irq_unlock>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
  40c624:	f9402ff4 	ldr	x20, [sp, #88]
  40c628:	b4000a74 	cbz	x20, 40c774 <net_buf_alloc_len+0x2bc>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  40c62c:	b40000d5 	cbz	x21, 40c644 <net_buf_alloc_len+0x18c>
  40c630:	b10006bf 	cmn	x21, #0x1
  40c634:	54000080 	b.eq	40c644 <net_buf_alloc_len+0x18c>  // b.none
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
  40c638:	94001a29 	bl	412edc <sys_clock_tick_get>

			if (remaining <= 0) {
  40c63c:	eb0002f5 	subs	x21, x23, x0
  40c640:	9a9f52b5 	csel	x21, x21, xzr, pl  // pl = nfrst
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
  40c644:	aa1503e2 	mov	x2, x21
  40c648:	910163e1 	add	x1, sp, #0x58
  40c64c:	aa1303e0 	mov	x0, x19
  40c650:	97ffff29 	bl	40c2f4 <data_alloc>
  40c654:	f9001660 	str	x0, [x19, #40]
		if (!buf->__buf) {
  40c658:	b5000660 	cbnz	x0, 40c724 <net_buf_alloc_len+0x26c>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
  40c65c:	aa1303e0 	mov	x0, x19
			return NULL;
  40c660:	d2800013 	mov	x19, #0x0                   	// #0
			net_buf_destroy(buf);
  40c664:	97ffff38 	bl	40c344 <net_buf_destroy>
			return NULL;
  40c668:	14000028 	b	40c708 <net_buf_alloc_len+0x250>
		uninit_count = pool->uninit_count--;
  40c66c:	79408699 	ldrh	w25, [x20, #66]
  40c670:	51000720 	sub	w0, w25, #0x1
  40c674:	79008680 	strh	w0, [x20, #66]
  40c678:	aa1603e0 	mov	x0, x22
  40c67c:	940007fd 	bl	40e670 <z_spin_unlock_valid>
  40c680:	72001c1f 	tst	w0, #0xff
  40c684:	54fffa80 	b.eq	40c5d4 <net_buf_alloc_len+0x11c>  // b.none
  40c688:	2a1803e0 	mov	w0, w24
  40c68c:	97fff649 	bl	409fb0 <posix_irq_unlock>
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c690:	79408280 	ldrh	w0, [x20, #64]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c694:	39411293 	ldrb	w19, [x20, #68]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c698:	4b190000 	sub	w0, w0, w25
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c69c:	9100de73 	add	x19, x19, #0x37
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
  40c6a0:	f9402e81 	ldr	x1, [x20, #88]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c6a4:	93407c00 	sxtw	x0, w0
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c6a8:	927df273 	and	x19, x19, #0xfffffffffffffff8
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
  40c6ac:	9b000673 	madd	x19, x19, x0, x1
	return pool - TYPE_SECTION_START(net_buf_pool);
  40c6b0:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40c6b4:	b201f3e1 	mov	x1, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
  40c6b8:	f9479800 	ldr	x0, [x0, #3888]
  40c6bc:	f2955561 	movk	x1, #0xaaab
  40c6c0:	cb000280 	sub	x0, x20, x0
  40c6c4:	9345fc00 	asr	x0, x0, #5
  40c6c8:	9b017c00 	mul	x0, x0, x1
	buf->pool_id = pool_id(pool);
  40c6cc:	39004a60 	strb	w0, [x19, #18]
	buf->user_data_size = pool->user_data_size;
  40c6d0:	39411280 	ldrb	w0, [x20, #68]
  40c6d4:	39004e60 	strb	w0, [x19, #19]
		goto success;
  40c6d8:	17ffffd3 	b	40c624 <net_buf_alloc_len+0x16c>
  40c6dc:	aa1603e0 	mov	x0, x22
  40c6e0:	940007e4 	bl	40e670 <z_spin_unlock_valid>
  40c6e4:	72001c1f 	tst	w0, #0xff
  40c6e8:	54fff760 	b.eq	40c5d4 <net_buf_alloc_len+0x11c>  // b.none
  40c6ec:	2a1803e0 	mov	w0, w24
  40c6f0:	97fff630 	bl	409fb0 <posix_irq_unlock>
  40c6f4:	aa1503e1 	mov	x1, x21
  40c6f8:	aa1403e0 	mov	x0, x20
  40c6fc:	94000b87 	bl	40f518 <z_impl_k_queue_get>
  40c700:	aa0003f3 	mov	x19, x0
	if (!buf) {
  40c704:	b5fff900 	cbnz	x0, 40c624 <net_buf_alloc_len+0x16c>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
  40c708:	aa1303e0 	mov	x0, x19
  40c70c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c710:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c714:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c718:	f94023f9 	ldr	x25, [sp, #64]
  40c71c:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40c720:	d65f03c0 	ret
		NET_BUF_ASSERT(req_size <= size);
  40c724:	f9402fe0 	ldr	x0, [sp, #88]
  40c728:	eb00029f 	cmp	x20, x0
  40c72c:	54000269 	b.ls	40c778 <net_buf_alloc_len+0x2c0>  // b.plast
  40c730:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40c734:	9131fa73 	add	x19, x19, #0xc7e
  40c738:	aa1303e2 	mov	x2, x19
  40c73c:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40c740:	91356021 	add	x1, x1, #0xd58
  40c744:	52802b23 	mov	w3, #0x159                 	// #345
  40c748:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c74c:	911e2800 	add	x0, x0, #0x78a
  40c750:	97ffed10 	bl	407b90 <assert_print>
  40c754:	b0000040 	adrp	x0, 415000 <random_data+0xca4>
  40c758:	9135a400 	add	x0, x0, #0xd69
  40c75c:	97ffed0d 	bl	407b90 <assert_print>
  40c760:	aa1303e0 	mov	x0, x19
  40c764:	52802b21 	mov	w1, #0x159                 	// #345
  40c768:	97ffed34 	bl	407c38 <assert_post_action>
  40c76c:	52802b22 	mov	w2, #0x159                 	// #345
  40c770:	17ffff6b 	b	40c51c <net_buf_alloc_len+0x64>
		buf->__buf = NULL;
  40c774:	f900167f 	str	xzr, [x19, #40]
	buf->ref   = 1U;
  40c778:	52800020 	mov	w0, #0x1                   	// #1
  40c77c:	79002260 	strh	w0, [x19, #16]
	buf->size  = size;
  40c780:	f9402fe0 	ldr	x0, [sp, #88]
	buf->frags = NULL;
  40c784:	f900067f 	str	xzr, [x19, #8]
	buf->size  = size;
  40c788:	79004660 	strh	w0, [x19, #34]
	net_buf_reset(buf);
  40c78c:	aa1303e0 	mov	x0, x19
  40c790:	97ffff1e 	bl	40c408 <net_buf_reset>
	return buf;
  40c794:	17ffffdd 	b	40c708 <net_buf_alloc_len+0x250>

000000000040c798 <net_buf_alloc_fixed>:
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40c798:	f9402802 	ldr	x2, [x0, #80]

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
  40c79c:	f9400443 	ldr	x3, [x2, #8]
  40c7a0:	aa0103e2 	mov	x2, x1
  40c7a4:	f9400061 	ldr	x1, [x3]
  40c7a8:	17ffff44 	b	40c4b8 <net_buf_alloc_len>

000000000040c7ac <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
  40c7ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c7b0:	910003fd 	mov	x29, sp
  40c7b4:	a90153f3 	stp	x19, x20, [sp, #16]
  40c7b8:	f90013f5 	str	x21, [sp, #32]
	__ASSERT_NO_MSG(buf);
  40c7bc:	b5000240 	cbnz	x0, 40c804 <net_buf_unref+0x58>
  40c7c0:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40c7c4:	9131fa73 	add	x19, x19, #0xc7e
  40c7c8:	aa1303e2 	mov	x2, x19
  40c7cc:	52803ba3 	mov	w3, #0x1dd                 	// #477
  40c7d0:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40c7d4:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c7d8:	9135c021 	add	x1, x1, #0xd70
  40c7dc:	911e2800 	add	x0, x0, #0x78a
  40c7e0:	97ffecec 	bl	407b90 <assert_print>
  40c7e4:	aa1303e0 	mov	x0, x19
  40c7e8:	52803ba1 	mov	w1, #0x1dd                 	// #477
  40c7ec:	97ffed13 	bl	407c38 <assert_post_action>
  40c7f0:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c7f4:	aa1303e1 	mov	x1, x19
  40c7f8:	911f2000 	add	x0, x0, #0x7c8
  40c7fc:	52803ba2 	mov	w2, #0x1dd                 	// #477
  40c800:	97fff700 	bl	40a400 <posix_print_error_and_exit>
  40c804:	aa0003f4 	mov	x20, x0
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
  40c808:	39404280 	ldrb	w0, [x20, #16]
  40c80c:	aa1403f3 	mov	x19, x20
		struct net_buf *frags = buf->frags;
  40c810:	f9400694 	ldr	x20, [x20, #8]
		if (--buf->ref > 0) {
  40c814:	51000400 	sub	w0, w0, #0x1
  40c818:	12001c00 	and	w0, w0, #0xff
  40c81c:	39004260 	strb	w0, [x19, #16]
  40c820:	350002e0 	cbnz	w0, 40c87c <net_buf_unref+0xd0>
			return;
		}

		if (buf->__buf) {
  40c824:	f9401675 	ldr	x21, [x19, #40]
  40c828:	b4000195 	cbz	x21, 40c858 <net_buf_unref+0xac>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c82c:	39404a60 	ldrb	w0, [x19, #18]
  40c830:	97fffe85 	bl	40c244 <net_buf_pool_get>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
  40c834:	39404661 	ldrb	w1, [x19, #17]
  40c838:	370000e1 	tbnz	w1, #0, 40c854 <net_buf_unref+0xa8>
	pool->alloc->cb->unref(buf, data);
  40c83c:	f9402800 	ldr	x0, [x0, #80]
  40c840:	aa1503e1 	mov	x1, x21
  40c844:	f9400000 	ldr	x0, [x0]
  40c848:	f9400802 	ldr	x2, [x0, #16]
  40c84c:	aa1303e0 	mov	x0, x19
  40c850:	d63f0040 	blr	x2
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
  40c854:	f900167f 	str	xzr, [x19, #40]
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
  40c858:	39404a60 	ldrb	w0, [x19, #18]
		buf->frags = NULL;
  40c85c:	f900067f 	str	xzr, [x19, #8]
		buf->data = NULL;
  40c860:	f9000e7f 	str	xzr, [x19, #24]
		pool = net_buf_pool_get(buf->pool_id);
  40c864:	97fffe78 	bl	40c244 <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
  40c868:	f9402401 	ldr	x1, [x0, #72]
			pool->destroy(buf);
  40c86c:	aa1303e0 	mov	x0, x19
		if (pool->destroy) {
  40c870:	b40000e1 	cbz	x1, 40c88c <net_buf_unref+0xe0>
			pool->destroy(buf);
  40c874:	d63f0020 	blr	x1
	while (buf) {
  40c878:	b5fffc94 	cbnz	x20, 40c808 <net_buf_unref+0x5c>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
  40c87c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c880:	f94013f5 	ldr	x21, [sp, #32]
  40c884:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40c888:	d65f03c0 	ret
			net_buf_destroy(buf);
  40c88c:	97fffeae 	bl	40c344 <net_buf_destroy>
  40c890:	17fffffa 	b	40c878 <net_buf_unref+0xcc>

000000000040c894 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
  40c894:	f9400001 	ldr	x1, [x0]
  40c898:	f9400800 	ldr	x0, [x0, #16]
}
  40c89c:	cb000020 	sub	x0, x1, x0
  40c8a0:	d65f03c0 	ret

000000000040c8a4 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
  40c8a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c8a8:	910003fd 	mov	x29, sp
  40c8ac:	a90153f3 	stp	x19, x20, [sp, #16]
  40c8b0:	aa0003f3 	mov	x19, x0
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
  40c8b4:	79401414 	ldrh	w20, [x0, #10]
  40c8b8:	97fffff7 	bl	40c894 <net_buf_simple_headroom>
  40c8bc:	79401261 	ldrh	w1, [x19, #8]
  40c8c0:	cb010294 	sub	x20, x20, x1
}
  40c8c4:	cb000280 	sub	x0, x20, x0
  40c8c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c8cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c8d0:	d65f03c0 	ret

000000000040c8d4 <net_buf_simple_add>:
{
  40c8d4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c8d8:	910003fd 	mov	x29, sp
  40c8dc:	a90153f3 	stp	x19, x20, [sp, #16]
  40c8e0:	aa0103f4 	mov	x20, x1
  40c8e4:	aa0003f3 	mov	x19, x0
  40c8e8:	f90013f5 	str	x21, [sp, #32]
	return buf->data + buf->len;
  40c8ec:	79401001 	ldrh	w1, [x0, #8]
  40c8f0:	f9400015 	ldr	x21, [x0]
  40c8f4:	8b0102b5 	add	x21, x21, x1
	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
  40c8f8:	97ffffeb 	bl	40c8a4 <net_buf_simple_tailroom>
  40c8fc:	eb14001f 	cmp	x0, x20
  40c900:	54000242 	b.cs	40c948 <net_buf_simple_add+0x74>  // b.hs, b.nlast
  40c904:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40c908:	9135d273 	add	x19, x19, #0xd74
  40c90c:	aa1303e2 	mov	x2, x19
  40c910:	528007c3 	mov	w3, #0x3e                  	// #62
  40c914:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40c918:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c91c:	9136b821 	add	x1, x1, #0xdae
  40c920:	911e2800 	add	x0, x0, #0x78a
  40c924:	97ffec9b 	bl	407b90 <assert_print>
  40c928:	aa1303e0 	mov	x0, x19
  40c92c:	528007c1 	mov	w1, #0x3e                  	// #62
  40c930:	97ffecc2 	bl	407c38 <assert_post_action>
  40c934:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40c938:	aa1303e1 	mov	x1, x19
  40c93c:	911f2000 	add	x0, x0, #0x7c8
  40c940:	528007c2 	mov	w2, #0x3e                  	// #62
  40c944:	97fff6af 	bl	40a400 <posix_print_error_and_exit>
	buf->len += len;
  40c948:	79401260 	ldrh	w0, [x19, #8]
  40c94c:	0b140000 	add	w0, w0, w20
  40c950:	79001260 	strh	w0, [x19, #8]
}
  40c954:	aa1503e0 	mov	x0, x21
  40c958:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c95c:	f94013f5 	ldr	x21, [sp, #32]
  40c960:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40c964:	d65f03c0 	ret

000000000040c968 <net_buf_simple_add_mem>:
{
  40c968:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c96c:	910003fd 	mov	x29, sp
  40c970:	a90153f3 	stp	x19, x20, [sp, #16]
  40c974:	aa0103f4 	mov	x20, x1
  40c978:	aa0203f3 	mov	x19, x2
	return memcpy(net_buf_simple_add(buf, len), mem, len);
  40c97c:	aa0203e1 	mov	x1, x2
  40c980:	97ffffd5 	bl	40c8d4 <net_buf_simple_add>
  40c984:	aa1303e2 	mov	x2, x19
  40c988:	aa1403e1 	mov	x1, x20
}
  40c98c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c990:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c994:	17ffd1f7 	b	401170 <memcpy@plt>

000000000040c998 <can_tx_default_cb>:
	struct k_sem done;
	int status;
};

static void can_tx_default_cb(const struct device *dev, int error, void *user_data)
{
  40c998:	aa0203e0 	mov	x0, x2
	struct can_tx_default_cb_ctx *ctx = user_data;

	ctx->status = error;
  40c99c:	b9002841 	str	w1, [x2, #40]
	z_impl_k_sem_give(sem);
  40c9a0:	14000b45 	b	40f6b4 <z_impl_k_sem_give>

000000000040c9a4 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40c9a4:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40c9a8:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40c9ac:	910003fd 	mov	x29, sp
  40c9b0:	f9476800 	ldr	x0, [x0, #3792]
  40c9b4:	3d8023e0 	str	q0, [sp, #128]
  40c9b8:	3d8027e1 	str	q1, [sp, #144]
  40c9bc:	3d802be2 	str	q2, [sp, #160]
  40c9c0:	3d802fe3 	str	q3, [sp, #176]
  40c9c4:	3d8033e4 	str	q4, [sp, #192]
  40c9c8:	3d8037e5 	str	q5, [sp, #208]
  40c9cc:	3d803be6 	str	q6, [sp, #224]
  40c9d0:	3d803fe7 	str	q7, [sp, #240]
  40c9d4:	f90087e7 	str	x7, [sp, #264]
  40c9d8:	f9400002 	ldr	x2, [x0]
  40c9dc:	f9003fe2 	str	x2, [sp, #120]
  40c9e0:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40c9e4:	910443e0 	add	x0, sp, #0x110
  40c9e8:	a90383e0 	stp	x0, x0, [sp, #56]
  40c9ec:	910403e0 	add	x0, sp, #0x100
  40c9f0:	9100e3e2 	add	x2, sp, #0x38
  40c9f4:	f90027e0 	str	x0, [sp, #72]
  40c9f8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40c9fc:	b90053e0 	str	w0, [sp, #80]
  40ca00:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40ca04:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40ca08:	910163e0 	add	x0, sp, #0x58
  40ca0c:	ad400440 	ldp	q0, q1, [x2]
  40ca10:	ad000400 	stp	q0, q1, [x0]
  40ca14:	ad400400 	ldp	q0, q1, [x0]
  40ca18:	910043e7 	add	x7, sp, #0x10
  40ca1c:	52800022 	mov	w2, #0x1                   	// #1
  40ca20:	52800000 	mov	w0, #0x0                   	// #0
  40ca24:	b0000046 	adrp	x6, 415000 <random_data+0xca4>
  40ca28:	52800005 	mov	w5, #0x0                   	// #0
  40ca2c:	913784c6 	add	x6, x6, #0xde1
  40ca30:	d2800004 	mov	x4, #0x0                   	// #0
  40ca34:	d2800003 	mov	x3, #0x0                   	// #0
  40ca38:	ad0004e0 	stp	q0, q1, [x7]
  40ca3c:	97ffee35 	bl	408310 <z_impl_z_log_msg_runtime_vcreate>
}
  40ca40:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40ca44:	f9476800 	ldr	x0, [x0, #3792]
  40ca48:	f9403fe2 	ldr	x2, [sp, #120]
  40ca4c:	f9400001 	ldr	x1, [x0]
  40ca50:	eb010042 	subs	x2, x2, x1
  40ca54:	d2800001 	mov	x1, #0x0                   	// #0
  40ca58:	54000040 	b.eq	40ca60 <z_log_msg_runtime_create.constprop.0+0xbc>  // b.none
  40ca5c:	97ffd231 	bl	401320 <__stack_chk_fail@plt>
  40ca60:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40ca64:	d65f03c0 	ret

000000000040ca68 <can_msgq_put>:

	return api->send(dev, frame, timeout, callback, user_data);
}

static void can_msgq_put(const struct device *dev, struct can_frame *frame, void *user_data)
{
  40ca68:	d100c3ff 	sub	sp, sp, #0x30
  40ca6c:	a9017bfd 	stp	x29, x30, [sp, #16]
  40ca70:	910043fd 	add	x29, sp, #0x10
  40ca74:	a90253f3 	stp	x19, x20, [sp, #32]
	struct k_msgq *msgq = (struct k_msgq *)user_data;
	int ret;

	ARG_UNUSED(dev);

	__ASSERT_NO_MSG(msgq);
  40ca78:	b5000242 	cbnz	x2, 40cac0 <can_msgq_put+0x58>
  40ca7c:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40ca80:	91381273 	add	x19, x19, #0xe04
  40ca84:	aa1303e2 	mov	x2, x19
  40ca88:	52800823 	mov	w3, #0x41                  	// #65
  40ca8c:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40ca90:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ca94:	9138c021 	add	x1, x1, #0xe30
  40ca98:	911e2800 	add	x0, x0, #0x78a
  40ca9c:	97ffec3d 	bl	407b90 <assert_print>
  40caa0:	aa1303e0 	mov	x0, x19
  40caa4:	52800821 	mov	w1, #0x41                  	// #65
  40caa8:	97ffec64 	bl	407c38 <assert_post_action>
  40caac:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40cab0:	aa1303e1 	mov	x1, x19
  40cab4:	911f2000 	add	x0, x0, #0x7c8
  40cab8:	52800822 	mov	w2, #0x41                  	// #65
  40cabc:	97fff651 	bl	40a400 <posix_print_error_and_exit>
  40cac0:	aa0103f4 	mov	x20, x1
  40cac4:	aa0203f3 	mov	x19, x2
	return z_impl_k_msgq_put(msgq, data, timeout);
  40cac8:	d2800002 	mov	x2, #0x0                   	// #0
  40cacc:	aa1303e0 	mov	x0, x19
  40cad0:	9400073a 	bl	40e7b8 <z_impl_k_msgq_put>

	ret = k_msgq_put(msgq, frame, K_NO_WAIT);
	if (ret) {
  40cad4:	340001e0 	cbz	w0, 40cb10 <can_msgq_put+0xa8>
		LOG_ERR("Msgq %p overflowed. Frame ID: 0x%x", msgq, frame->id);
  40cad8:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40cadc:	b9400280 	ldr	w0, [x20]
  40cae0:	b0000046 	adrp	x6, 415000 <random_data+0xca4>
  40cae4:	aa1303e7 	mov	x7, x19
  40cae8:	f9473421 	ldr	x1, [x1, #3688]
  40caec:	d3407000 	ubfx	x0, x0, #0, #29
  40caf0:	b90003e0 	str	w0, [sp]
  40caf4:	913784c6 	add	x6, x6, #0xde1
  40caf8:	52800005 	mov	w5, #0x0                   	// #0
  40cafc:	d2800004 	mov	x4, #0x0                   	// #0
  40cb00:	d2800003 	mov	x3, #0x0                   	// #0
  40cb04:	52800022 	mov	w2, #0x1                   	// #1
  40cb08:	52800000 	mov	w0, #0x0                   	// #0
  40cb0c:	97ffffa6 	bl	40c9a4 <z_log_msg_runtime_create.constprop.0>
	}
}
  40cb10:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40cb14:	a94253f3 	ldp	x19, x20, [sp, #32]
  40cb18:	9100c3ff 	add	sp, sp, #0x30
  40cb1c:	d65f03c0 	ret

000000000040cb20 <z_impl_can_send>:
{
  40cb20:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40cb24:	f00000e5 	adrp	x5, 42b000 <__FRAME_END__+0xff4c>
  40cb28:	910003fd 	mov	x29, sp
  40cb2c:	f94768a5 	ldr	x5, [x5, #3792]
  40cb30:	a90153f3 	stp	x19, x20, [sp, #16]
  40cb34:	f00000f3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  40cb38:	a9025bf5 	stp	x21, x22, [sp, #32]
  40cb3c:	a90363f7 	stp	x23, x24, [sp, #48]
  40cb40:	f94000a6 	ldr	x6, [x5]
  40cb44:	f9003fe6 	str	x6, [sp, #120]
  40cb48:	d2800006 	mov	x6, #0x0                   	// #0
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  40cb4c:	f9400818 	ldr	x24, [x0, #16]
	if (callback == NULL) {
  40cb50:	b5000423 	cbnz	x3, 40cbd4 <z_impl_can_send+0xb4>
  40cb54:	aa0003f4 	mov	x20, x0
  40cb58:	aa0103f6 	mov	x22, x1
  40cb5c:	aa0203f7 	mov	x23, x2
	return z_impl_k_sem_init(sem, initial_count, limit);
  40cb60:	910123f5 	add	x21, sp, #0x48
  40cb64:	52800022 	mov	w2, #0x1                   	// #1
  40cb68:	52800001 	mov	w1, #0x0                   	// #0
  40cb6c:	aa1503e0 	mov	x0, x21
  40cb70:	94000ac6 	bl	40f688 <z_impl_k_sem_init>
		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
  40cb74:	f9401705 	ldr	x5, [x24, #40]
  40cb78:	90000003 	adrp	x3, 40c000 <z_ztest_should_test_run+0x4>
  40cb7c:	aa1503e4 	mov	x4, x21
  40cb80:	91266063 	add	x3, x3, #0x998
  40cb84:	aa1703e2 	mov	x2, x23
  40cb88:	aa1603e1 	mov	x1, x22
  40cb8c:	aa1403e0 	mov	x0, x20
  40cb90:	d63f00a0 	blr	x5
		if (err != 0) {
  40cb94:	350000a0 	cbnz	w0, 40cba8 <z_impl_can_send+0x88>
	return z_impl_k_sem_take(sem, timeout);
  40cb98:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40cb9c:	aa1503e0 	mov	x0, x21
  40cba0:	94000afc 	bl	40f790 <z_impl_k_sem_take>
		return ctx.status;
  40cba4:	b94073e0 	ldr	w0, [sp, #112]
}
  40cba8:	f9476a73 	ldr	x19, [x19, #3792]
  40cbac:	f9403fe1 	ldr	x1, [sp, #120]
  40cbb0:	f9400262 	ldr	x2, [x19]
  40cbb4:	eb020021 	subs	x1, x1, x2
  40cbb8:	d2800002 	mov	x2, #0x0                   	// #0
  40cbbc:	54000181 	b.ne	40cbec <z_impl_can_send+0xcc>  // b.any
  40cbc0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cbc4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40cbc8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40cbcc:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40cbd0:	d65f03c0 	ret
	return api->send(dev, frame, timeout, callback, user_data);
  40cbd4:	f9476a73 	ldr	x19, [x19, #3792]
  40cbd8:	f9403fe5 	ldr	x5, [sp, #120]
  40cbdc:	f9400266 	ldr	x6, [x19]
  40cbe0:	eb0600a5 	subs	x5, x5, x6
  40cbe4:	d2800006 	mov	x6, #0x0                   	// #0
  40cbe8:	54000040 	b.eq	40cbf0 <z_impl_can_send+0xd0>  // b.none
}
  40cbec:	97ffd1cd 	bl	401320 <__stack_chk_fail@plt>
  40cbf0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cbf4:	a9425bf5 	ldp	x21, x22, [sp, #32]
	return api->send(dev, frame, timeout, callback, user_data);
  40cbf8:	f9401705 	ldr	x5, [x24, #40]
}
  40cbfc:	a94363f7 	ldp	x23, x24, [sp, #48]
	return api->send(dev, frame, timeout, callback, user_data);
  40cc00:	aa0503f0 	mov	x16, x5
}
  40cc04:	a8c87bfd 	ldp	x29, x30, [sp], #128
	return api->send(dev, frame, timeout, callback, user_data);
  40cc08:	d61f0200 	br	x16

000000000040cc0c <z_impl_can_add_rx_filter_msgq>:
int z_impl_can_add_rx_filter_msgq(const struct device *dev, struct k_msgq *msgq,
				  const struct can_filter *filter)
{
	const struct can_driver_api *api = dev->api;

	return api->add_rx_filter(dev, can_msgq_put, msgq, filter);
  40cc0c:	f9400803 	ldr	x3, [x0, #16]
  40cc10:	f9401864 	ldr	x4, [x3, #48]
  40cc14:	aa0203e3 	mov	x3, x2
  40cc18:	aa0103e2 	mov	x2, x1
  40cc1c:	90000001 	adrp	x1, 40c000 <z_ztest_should_test_run+0x4>
  40cc20:	aa0403f0 	mov	x16, x4
  40cc24:	9129a021 	add	x1, x1, #0xa68
  40cc28:	d61f0200 	br	x16

000000000040cc2c <can_loopback_get_capabilities>:

static int can_loopback_get_capabilities(const struct device *dev, can_mode_t *cap)
{
	ARG_UNUSED(dev);

	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK;
  40cc2c:	52800020 	mov	w0, #0x1                   	// #1
  40cc30:	b9000020 	str	w0, [x1]
#if CONFIG_CAN_FD_MODE
	*cap |= CAN_MODE_FD;
#endif /* CONFIG_CAN_FD_MODE */

	return 0;
}
  40cc34:	52800000 	mov	w0, #0x0                   	// #0
  40cc38:	d65f03c0 	ret

000000000040cc3c <can_loopback_start>:

static int can_loopback_start(const struct device *dev)
{
	struct can_loopback_data *data = dev->data;
  40cc3c:	f9401000 	ldr	x0, [x0, #32]

	if (data->started) {
  40cc40:	39552001 	ldrb	w1, [x0, #1352]
  40cc44:	350000a1 	cbnz	w1, 40cc58 <can_loopback_start+0x1c>
		return -EALREADY;
	}

	data->started = true;
  40cc48:	52800021 	mov	w1, #0x1                   	// #1
  40cc4c:	39152001 	strb	w1, [x0, #1352]

	return 0;
  40cc50:	52800000 	mov	w0, #0x0                   	// #0
}
  40cc54:	d65f03c0 	ret
		return -EALREADY;
  40cc58:	12800e20 	mov	w0, #0xffffff8e            	// #-114
  40cc5c:	17fffffe 	b	40cc54 <can_loopback_start+0x18>

000000000040cc60 <can_loopback_set_timing>:
{
	struct can_loopback_data *data = dev->data;

	ARG_UNUSED(timing);

	if (data->started) {
  40cc60:	f9401000 	ldr	x0, [x0, #32]
  40cc64:	39552000 	ldrb	w0, [x0, #1352]
		return -EBUSY;
  40cc68:	7100001f 	cmp	w0, #0x0
	}

	return 0;
}
  40cc6c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40cc70:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40cc74:	d65f03c0 	ret

000000000040cc78 <can_loopback_get_state>:
static int can_loopback_get_state(const struct device *dev, enum can_state *state,
				  struct can_bus_err_cnt *err_cnt)
{
	struct can_loopback_data *data = dev->data;

	if (state != NULL) {
  40cc78:	b40000e1 	cbz	x1, 40cc94 <can_loopback_get_state+0x1c>
		if (data->started) {
  40cc7c:	f9401000 	ldr	x0, [x0, #32]
  40cc80:	39552000 	ldrb	w0, [x0, #1352]
			*state = CAN_STATE_ERROR_ACTIVE;
  40cc84:	7100001f 	cmp	w0, #0x0
  40cc88:	52800080 	mov	w0, #0x4                   	// #4
  40cc8c:	1a8013e0 	csel	w0, wzr, w0, ne  // ne = any
  40cc90:	b9000020 	str	w0, [x1]
		} else {
			*state = CAN_STATE_STOPPED;
		}
	}

	if (err_cnt) {
  40cc94:	b4000042 	cbz	x2, 40cc9c <can_loopback_get_state+0x24>
		err_cnt->tx_err_cnt = 0;
  40cc98:	7900005f 	strh	wzr, [x2]
		err_cnt->rx_err_cnt = 0;
	}

	return 0;
}
  40cc9c:	52800000 	mov	w0, #0x0                   	// #0
  40cca0:	d65f03c0 	ret

000000000040cca4 <can_loopback_set_state_change_callback>:
						   void *user_data)
{
	ARG_UNUSED(dev);
	ARG_UNUSED(cb);
	ARG_UNUSED(user_data);
}
  40cca4:	d65f03c0 	ret

000000000040cca8 <can_loopback_get_core_clock>:

static int can_loopback_get_core_clock(const struct device *dev, uint32_t *rate)
{
	/* Return 16MHz as an realistic value for the testcases */
	*rate = 16000000;
  40cca8:	52848000 	mov	w0, #0x2400                	// #9216
  40ccac:	72a01e80 	movk	w0, #0xf4, lsl #16
  40ccb0:	b9000020 	str	w0, [x1]
	return 0;
}
  40ccb4:	52800000 	mov	w0, #0x0                   	// #0
  40ccb8:	d65f03c0 	ret

000000000040ccbc <can_loopback_get_max_filters>:
static int can_loopback_get_max_filters(const struct device *dev, bool ide)
{
	ARG_UNUSED(ide);

	return CONFIG_CAN_MAX_FILTER;
}
  40ccbc:	52800200 	mov	w0, #0x10                  	// #16
  40ccc0:	d65f03c0 	ret

000000000040ccc4 <can_loopback_stop>:
	struct can_loopback_data *data = dev->data;
  40ccc4:	f9401000 	ldr	x0, [x0, #32]
	if (!data->started) {
  40ccc8:	39552001 	ldrb	w1, [x0, #1352]
  40cccc:	34000121 	cbz	w1, 40ccf0 <can_loopback_stop+0x2c>
{
  40ccd0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40ccd4:	910003fd 	mov	x29, sp
	data->started = false;
  40ccd8:	3915201f 	strb	wzr, [x0, #1352]
	z_impl_k_msgq_purge(msgq);
  40ccdc:	91088000 	add	x0, x0, #0x220
  40cce0:	94000809 	bl	40ed04 <z_impl_k_msgq_purge>
	return 0;
  40cce4:	52800000 	mov	w0, #0x0                   	// #0
}
  40cce8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40ccec:	d65f03c0 	ret
		return -EALREADY;
  40ccf0:	12800e20 	mov	w0, #0xffffff8e            	// #-114
}
  40ccf4:	d65f03c0 	ret

000000000040ccf8 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40ccf8:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40ccfc:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40cd00:	12001c42 	and	w2, w2, #0xff
  40cd04:	910003fd 	mov	x29, sp
  40cd08:	f9476800 	ldr	x0, [x0, #3792]
  40cd0c:	3d8023e0 	str	q0, [sp, #128]
  40cd10:	3d8027e1 	str	q1, [sp, #144]
  40cd14:	3d802be2 	str	q2, [sp, #160]
  40cd18:	3d802fe3 	str	q3, [sp, #176]
  40cd1c:	3d8033e4 	str	q4, [sp, #192]
  40cd20:	3d8037e5 	str	q5, [sp, #208]
  40cd24:	3d803be6 	str	q6, [sp, #224]
  40cd28:	3d803fe7 	str	q7, [sp, #240]
  40cd2c:	f90087e7 	str	x7, [sp, #264]
  40cd30:	f9400003 	ldr	x3, [x0]
  40cd34:	f9003fe3 	str	x3, [sp, #120]
  40cd38:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(ap, fmt);
  40cd3c:	910443e0 	add	x0, sp, #0x110
  40cd40:	a90383e0 	stp	x0, x0, [sp, #56]
  40cd44:	910403e0 	add	x0, sp, #0x100
  40cd48:	9100e3e3 	add	x3, sp, #0x38
  40cd4c:	f90027e0 	str	x0, [sp, #72]
  40cd50:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40cd54:	b90053e0 	str	w0, [sp, #80]
  40cd58:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40cd5c:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40cd60:	910163e0 	add	x0, sp, #0x58
  40cd64:	ad400460 	ldp	q0, q1, [x3]
  40cd68:	ad000400 	stp	q0, q1, [x0]
  40cd6c:	ad400400 	ldp	q0, q1, [x0]
  40cd70:	910043e7 	add	x7, sp, #0x10
  40cd74:	52800000 	mov	w0, #0x0                   	// #0
  40cd78:	52800005 	mov	w5, #0x0                   	// #0
  40cd7c:	d2800004 	mov	x4, #0x0                   	// #0
  40cd80:	d2800003 	mov	x3, #0x0                   	// #0
  40cd84:	ad0004e0 	stp	q0, q1, [x7]
  40cd88:	97ffed62 	bl	408310 <z_impl_z_log_msg_runtime_vcreate>
}
  40cd8c:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40cd90:	f9476800 	ldr	x0, [x0, #3792]
  40cd94:	f9403fe2 	ldr	x2, [sp, #120]
  40cd98:	f9400001 	ldr	x1, [x0]
  40cd9c:	eb010042 	subs	x2, x2, x1
  40cda0:	d2800001 	mov	x1, #0x0                   	// #0
  40cda4:	54000040 	b.eq	40cdac <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40cda8:	97ffd15e 	bl	401320 <__stack_chk_fail@plt>
  40cdac:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40cdb0:	d65f03c0 	ret

000000000040cdb4 <can_loopback_send>:
{
  40cdb4:	d10183ff 	sub	sp, sp, #0x60
  40cdb8:	f00000e5 	adrp	x5, 42b000 <__FRAME_END__+0xff4c>
  40cdbc:	a9017bfd 	stp	x29, x30, [sp, #16]
  40cdc0:	910043fd 	add	x29, sp, #0x10
  40cdc4:	f94768a5 	ldr	x5, [x5, #3792]
  40cdc8:	f90013f3 	str	x19, [sp, #32]
  40cdcc:	f94000a6 	ldr	x6, [x5]
  40cdd0:	f9002fe6 	str	x6, [sp, #88]
  40cdd4:	d2800006 	mov	x6, #0x0                   	// #0
	struct can_loopback_data *data = dev->data;
  40cdd8:	f9401000 	ldr	x0, [x0, #32]
	__ASSERT_NO_MSG(callback != NULL);
  40cddc:	b5000243 	cbnz	x3, 40ce24 <can_loopback_send+0x70>
  40cde0:	b0000053 	adrp	x19, 415000 <random_data+0xca4>
  40cde4:	91390273 	add	x19, x19, #0xe40
  40cde8:	aa1303e2 	mov	x2, x19
  40cdec:	52800d83 	mov	w3, #0x6c                  	// #108
  40cdf0:	b0000041 	adrp	x1, 415000 <random_data+0xca4>
  40cdf4:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40cdf8:	9139b821 	add	x1, x1, #0xe6e
  40cdfc:	911e2800 	add	x0, x0, #0x78a
  40ce00:	97ffeb64 	bl	407b90 <assert_print>
  40ce04:	aa1303e0 	mov	x0, x19
  40ce08:	52800d81 	mov	w1, #0x6c                  	// #108
  40ce0c:	97ffeb8b 	bl	407c38 <assert_post_action>
  40ce10:	90000040 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ce14:	aa1303e1 	mov	x1, x19
  40ce18:	911f2000 	add	x0, x0, #0x7c8
  40ce1c:	52800d82 	mov	w2, #0x6c                  	// #108
  40ce20:	97fff578 	bl	40a400 <posix_print_error_and_exit>
	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0) {
  40ce24:	39401425 	ldrb	w5, [x1, #5]
  40ce28:	39401427 	ldrb	w7, [x1, #5]
  40ce2c:	f27e14bf 	tst	x5, #0xfc
  40ce30:	54000280 	b.eq	40ce80 <can_loopback_send+0xcc>  // b.none
		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
  40ce34:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40ce38:	52800000 	mov	w0, #0x0                   	// #0
  40ce3c:	b0000046 	adrp	x6, 415000 <random_data+0xca4>
  40ce40:	52800005 	mov	w5, #0x0                   	// #0
  40ce44:	f9474c21 	ldr	x1, [x1, #3736]
  40ce48:	913a18c6 	add	x6, x6, #0xe86
  40ce4c:	d2800004 	mov	x4, #0x0                   	// #0
  40ce50:	d2800003 	mov	x3, #0x0                   	// #0
  40ce54:	52800022 	mov	w2, #0x1                   	// #1
  40ce58:	97ffffa8 	bl	40ccf8 <z_log_msg_runtime_create.constprop.0>
		return -ENOTSUP;
  40ce5c:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40ce60:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40ce64:	f9476821 	ldr	x1, [x1, #3792]
  40ce68:	f9402fe3 	ldr	x3, [sp, #88]
  40ce6c:	f9400022 	ldr	x2, [x1]
  40ce70:	eb020063 	subs	x3, x3, x2
  40ce74:	d2800002 	mov	x2, #0x0                   	// #0
  40ce78:	54000420 	b.eq	40cefc <can_loopback_send+0x148>  // b.none
  40ce7c:	97ffd129 	bl	401320 <__stack_chk_fail@plt>
	if (frame->dlc > max_dlc) {
  40ce80:	39401027 	ldrb	w7, [x1, #4]
  40ce84:	710020ff 	cmp	w7, #0x8
  40ce88:	540001e9 	b.ls	40cec4 <can_loopback_send+0x110>  // b.plast
		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, max_dlc);
  40ce8c:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40ce90:	52800100 	mov	w0, #0x8                   	// #8
  40ce94:	b90003e0 	str	w0, [sp]
  40ce98:	b0000046 	adrp	x6, 415000 <random_data+0xca4>
  40ce9c:	f9474c21 	ldr	x1, [x1, #3736]
  40cea0:	52800000 	mov	w0, #0x0                   	// #0
  40cea4:	913aa4c6 	add	x6, x6, #0xea9
  40cea8:	52800005 	mov	w5, #0x0                   	// #0
  40ceac:	d2800004 	mov	x4, #0x0                   	// #0
  40ceb0:	d2800003 	mov	x3, #0x0                   	// #0
  40ceb4:	52800022 	mov	w2, #0x1                   	// #1
  40ceb8:	97ffff90 	bl	40ccf8 <z_log_msg_runtime_create.constprop.0>
		return -EINVAL;
  40cebc:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40cec0:	17ffffe8 	b	40ce60 <can_loopback_send+0xac>
	if (!data->started) {
  40cec4:	39552005 	ldrb	w5, [x0, #1352]
  40cec8:	34000165 	cbz	w5, 40cef4 <can_loopback_send+0x140>
	loopback_frame.frame = *frame;
  40cecc:	a9401c26 	ldp	x6, x7, [x1]
  40ced0:	a9039fe6 	stp	x6, x7, [sp, #56]
	loopback_frame.cb_arg = user_data;
  40ced4:	a90493e3 	stp	x3, x4, [sp, #72]
	return z_impl_k_msgq_put(msgq, data, timeout);
  40ced8:	9100e3e1 	add	x1, sp, #0x38
  40cedc:	91088000 	add	x0, x0, #0x220
  40cee0:	94000636 	bl	40e7b8 <z_impl_k_msgq_put>
		return -EAGAIN;
  40cee4:	7100001f 	cmp	w0, #0x0
  40cee8:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40ceec:	1a80a3e0 	csel	w0, wzr, w0, ge  // ge = tcont
  40cef0:	17ffffdc 	b	40ce60 <can_loopback_send+0xac>
		return -ENETDOWN;
  40cef4:	12800c60 	mov	w0, #0xffffff9c            	// #-100
  40cef8:	17ffffda 	b	40ce60 <can_loopback_send+0xac>
}
  40cefc:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40cf00:	f94013f3 	ldr	x19, [sp, #32]
  40cf04:	910183ff 	add	sp, sp, #0x60
  40cf08:	d65f03c0 	ret

000000000040cf0c <can_loopback_set_mode>:
	struct can_loopback_data *data = dev->data;
  40cf0c:	f9401000 	ldr	x0, [x0, #32]
{
  40cf10:	2a0103e7 	mov	w7, w1
	if (data->started) {
  40cf14:	39552001 	ldrb	w1, [x0, #1352]
  40cf18:	350002c1 	cbnz	w1, 40cf70 <can_loopback_set_mode+0x64>
	if ((mode & ~(CAN_MODE_LOOPBACK)) != 0) {
  40cf1c:	f27f78ff 	tst	x7, #0xfffffffe
  40cf20:	54000200 	b.eq	40cf60 <can_loopback_set_mode+0x54>  // b.none
{
  40cf24:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40cf28:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40cf2c:	52800005 	mov	w5, #0x0                   	// #0
{
  40cf30:	910003fd 	mov	x29, sp
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40cf34:	f9474c21 	ldr	x1, [x1, #3736]
  40cf38:	d2800004 	mov	x4, #0x0                   	// #0
  40cf3c:	d2800003 	mov	x3, #0x0                   	// #0
  40cf40:	52800022 	mov	w2, #0x1                   	// #1
  40cf44:	52800000 	mov	w0, #0x0                   	// #0
  40cf48:	b0000046 	adrp	x6, 415000 <random_data+0xca4>
  40cf4c:	913b20c6 	add	x6, x6, #0xec8
  40cf50:	97ffff6a 	bl	40ccf8 <z_log_msg_runtime_create.constprop.0>
  40cf54:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40cf58:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40cf5c:	d65f03c0 	ret
	data->loopback = (mode & CAN_MODE_LOOPBACK) != 0;
  40cf60:	120000e7 	and	w7, w7, #0x1
  40cf64:	39152407 	strb	w7, [x0, #1353]
	return 0;
  40cf68:	52800000 	mov	w0, #0x0                   	// #0
  40cf6c:	d65f03c0 	ret
		return -EBUSY;
  40cf70:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
  40cf74:	d65f03c0 	ret

000000000040cf78 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
  40cf78:	1400084e 	b	40f0b0 <z_impl_k_mutex_unlock>

000000000040cf7c <can_loopback_remove_rx_filter>:
{
  40cf7c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40cf80:	910003fd 	mov	x29, sp
  40cf84:	a90153f3 	stp	x19, x20, [sp, #16]
  40cf88:	2a0103f3 	mov	w19, w1
  40cf8c:	f90013f5 	str	x21, [sp, #32]
	struct can_loopback_data *data = dev->data;
  40cf90:	f9401015 	ldr	x21, [x0, #32]
	if (filter_id >= ARRAY_SIZE(data->filters)) {
  40cf94:	71003c3f 	cmp	w1, #0xf
  40cf98:	540001e9 	b.ls	40cfd4 <can_loopback_remove_rx_filter+0x58>  // b.plast
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40cf9c:	2a0103e7 	mov	w7, w1
  40cfa0:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
}
  40cfa4:	a94153f3 	ldp	x19, x20, [sp, #16]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40cfa8:	b0000046 	adrp	x6, 415000 <random_data+0xca4>
}
  40cfac:	f94013f5 	ldr	x21, [sp, #32]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40cfb0:	913b84c6 	add	x6, x6, #0xee1
}
  40cfb4:	a8c37bfd 	ldp	x29, x30, [sp], #48
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40cfb8:	52800005 	mov	w5, #0x0                   	// #0
  40cfbc:	f9474c21 	ldr	x1, [x1, #3736]
  40cfc0:	d2800004 	mov	x4, #0x0                   	// #0
  40cfc4:	d2800003 	mov	x3, #0x0                   	// #0
  40cfc8:	52800022 	mov	w2, #0x1                   	// #1
  40cfcc:	52800000 	mov	w0, #0x0                   	// #0
  40cfd0:	17ffff4a 	b	40ccf8 <z_log_msg_runtime_create.constprop.0>
	k_mutex_lock(&data->mtx, K_FOREVER);
  40cfd4:	910802b4 	add	x20, x21, #0x200
	data->filters[filter_id].rx_cb = NULL;
  40cfd8:	937b7e73 	sbfiz	x19, x19, #5, #32
	return z_impl_k_mutex_lock(mutex, timeout);
  40cfdc:	aa1403e0 	mov	x0, x20
  40cfe0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40cfe4:	94000787 	bl	40ee00 <z_impl_k_mutex_lock>
	k_mutex_unlock(&data->mtx);
  40cfe8:	aa1403e0 	mov	x0, x20
	data->filters[filter_id].rx_cb = NULL;
  40cfec:	f8336abf 	str	xzr, [x21, x19]
}
  40cff0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cff4:	f94013f5 	ldr	x21, [sp, #32]
  40cff8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	k_mutex_unlock(&data->mtx);
  40cffc:	17ffffdf 	b	40cf78 <k_mutex_unlock.isra.0>

000000000040d000 <can_loopback_init>:
	},
#endif /* CONFIG_CAN_FD_MODE */
};

static int can_loopback_init(const struct device *dev)
{
  40d000:	d10103ff 	sub	sp, sp, #0x40
  40d004:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d008:	910043fd 	add	x29, sp, #0x10
  40d00c:	a90253f3 	stp	x19, x20, [sp, #32]
  40d010:	aa0003f4 	mov	x20, x0
	struct can_loopback_data *data = dev->data;
  40d014:	f9401013 	ldr	x19, [x0, #32]
{
  40d018:	f9001bf5 	str	x21, [sp, #48]
	k_tid_t tx_tid;

	k_mutex_init(&data->mtx);
  40d01c:	91080275 	add	x21, x19, #0x200
	return z_impl_k_mutex_init(mutex);
  40d020:	aa1503e0 	mov	x0, x21
  40d024:	94000772 	bl	40edec <z_impl_k_mutex_init>

	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d028:	aa1303e0 	mov	x0, x19
		data->filters[i].rx_cb = NULL;
  40d02c:	f802041f 	str	xzr, [x0], #32
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d030:	eb15001f 	cmp	x0, x21
  40d034:	54ffffc1 	b.ne	40d02c <can_loopback_init+0x2c>  // b.any
	}

	k_msgq_init(&data->tx_msgq, data->msgq_buffer, sizeof(struct can_loopback_frame),
  40d038:	910a2261 	add	x1, x19, #0x288
  40d03c:	91088260 	add	x0, x19, #0x220
  40d040:	52800203 	mov	w3, #0x10                  	// #16
  40d044:	d2800402 	mov	x2, #0x20                  	// #32
  40d048:	940005ba 	bl	40e730 <k_msgq_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40d04c:	b90003ff 	str	wzr, [sp]
  40d050:	91154261 	add	x1, x19, #0x550
  40d054:	f90007ff 	str	xzr, [sp, #8]
  40d058:	aa1403e4 	mov	x4, x20
  40d05c:	91122260 	add	x0, x19, #0x488
  40d060:	52800047 	mov	w7, #0x2                   	// #2
  40d064:	d2800006 	mov	x6, #0x0                   	// #0
  40d068:	d2800005 	mov	x5, #0x0                   	// #0
  40d06c:	90000003 	adrp	x3, 40d000 <can_loopback_init>
  40d070:	d2802002 	mov	x2, #0x100                 	// #256
  40d074:	9103b063 	add	x3, x3, #0xec
  40d078:	940004e1 	bl	40e3fc <z_impl_k_thread_create>
	tx_tid = k_thread_create(&data->tx_thread_data, data->tx_thread_stack,
				 K_KERNEL_STACK_SIZEOF(data->tx_thread_stack),
				 tx_thread, (void *)dev, NULL, NULL,
				 CONFIG_CAN_LOOPBACK_TX_THREAD_PRIORITY,
				 0, K_NO_WAIT);
	if (!tx_tid) {
  40d07c:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40d080:	b50001e0 	cbnz	x0, 40d0bc <can_loopback_init+0xbc>
		LOG_ERR("ERROR spawning tx thread");
  40d084:	f9474c21 	ldr	x1, [x1, #3736]
  40d088:	90000046 	adrp	x6, 415000 <random_data+0xca4>
  40d08c:	52800005 	mov	w5, #0x0                   	// #0
  40d090:	913bf0c6 	add	x6, x6, #0xefc
  40d094:	d2800004 	mov	x4, #0x0                   	// #0
  40d098:	d2800003 	mov	x3, #0x0                   	// #0
  40d09c:	52800022 	mov	w2, #0x1                   	// #1
  40d0a0:	97ffff16 	bl	40ccf8 <z_log_msg_runtime_create.constprop.0>
		return -1;
  40d0a4:	12800000 	mov	w0, #0xffffffff            	// #-1
	}

	LOG_INF("Init of %s done", dev->name);

	return 0;
}
  40d0a8:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40d0ac:	a94253f3 	ldp	x19, x20, [sp, #32]
  40d0b0:	f9401bf5 	ldr	x21, [sp, #48]
  40d0b4:	910103ff 	add	sp, sp, #0x40
  40d0b8:	d65f03c0 	ret
	LOG_INF("Init of %s done", dev->name);
  40d0bc:	f9474c21 	ldr	x1, [x1, #3736]
  40d0c0:	52800000 	mov	w0, #0x0                   	// #0
  40d0c4:	f9400287 	ldr	x7, [x20]
  40d0c8:	90000046 	adrp	x6, 415000 <random_data+0xca4>
  40d0cc:	52800005 	mov	w5, #0x0                   	// #0
  40d0d0:	913c54c6 	add	x6, x6, #0xf15
  40d0d4:	d2800004 	mov	x4, #0x0                   	// #0
  40d0d8:	d2800003 	mov	x3, #0x0                   	// #0
  40d0dc:	52800062 	mov	w2, #0x3                   	// #3
  40d0e0:	97ffff06 	bl	40ccf8 <z_log_msg_runtime_create.constprop.0>
	return 0;
  40d0e4:	52800000 	mov	w0, #0x0                   	// #0
  40d0e8:	17fffff0 	b	40d0a8 <can_loopback_init+0xa8>

000000000040d0ec <tx_thread>:
{
  40d0ec:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  40d0f0:	910003fd 	mov	x29, sp
  40d0f4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d0f8:	aa0003f5 	mov	x21, x0
  40d0fc:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40d100:	a90153f3 	stp	x19, x20, [sp, #16]
  40d104:	a90363f7 	stp	x23, x24, [sp, #48]
	return z_impl_k_msgq_get(msgq, data, timeout);
  40d108:	9101a3f7 	add	x23, sp, #0x68
  40d10c:	a9046bf9 	stp	x25, x26, [sp, #64]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40d110:	910163f9 	add	x25, sp, #0x58
{
  40d114:	f9476800 	ldr	x0, [x0, #3792]
	struct can_loopback_data *data = dev->data;
  40d118:	f94012b4 	ldr	x20, [x21, #32]
{
  40d11c:	f9400001 	ldr	x1, [x0]
  40d120:	f90047e1 	str	x1, [sp, #136]
  40d124:	d2800001 	mov	x1, #0x0                   	// #0
		ret = k_msgq_get(&data->tx_msgq, &frame, K_FOREVER);
  40d128:	91088298 	add	x24, x20, #0x220
  40d12c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  40d130:	aa1703e1 	mov	x1, x23
  40d134:	aa1803e0 	mov	x0, x24
  40d138:	94000646 	bl	40ea50 <z_impl_k_msgq_get>
		if (ret < 0) {
  40d13c:	37ffff80 	tbnz	w0, #31, 40d12c <tx_thread+0x40>
		frame.cb(dev, 0, frame.cb_arg);
  40d140:	a9478be3 	ldp	x3, x2, [sp, #120]
  40d144:	aa1503e0 	mov	x0, x21
  40d148:	52800001 	mov	w1, #0x0                   	// #0
  40d14c:	d63f0060 	blr	x3
		if (!data->loopback) {
  40d150:	39552680 	ldrb	w0, [x20, #1353]
  40d154:	34fffec0 	cbz	w0, 40d12c <tx_thread+0x40>
		k_mutex_lock(&data->mtx, K_FOREVER);
  40d158:	9108029a 	add	x26, x20, #0x200
	return z_impl_k_mutex_lock(mutex, timeout);
  40d15c:	aa1403f3 	mov	x19, x20
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d160:	52800016 	mov	w22, #0x0                   	// #0
  40d164:	aa1a03e0 	mov	x0, x26
  40d168:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40d16c:	94000725 	bl	40ee00 <z_impl_k_mutex_lock>
			if (filter->rx_cb != NULL &&
  40d170:	f9400260 	ldr	x0, [x19]
  40d174:	b40000c0 	cbz	x0, 40d18c <tx_thread+0xa0>
 * @return true if the CAN frame matches the CAN filter, false otherwise
 */
static inline bool can_frame_matches_filter(const struct can_frame *frame,
					    const struct can_filter *filter)
{
	if ((frame->flags & CAN_FRAME_IDE) != 0 && (filter->flags & CAN_FILTER_IDE) == 0) {
  40d178:	3941b7e0 	ldrb	w0, [sp, #109]
  40d17c:	39406261 	ldrb	w1, [x19, #24]
  40d180:	12000022 	and	w2, w1, #0x1
  40d184:	36000120 	tbz	w0, #0, 40d1a8 <tx_thread+0xbc>
  40d188:	35000122 	cbnz	w2, 40d1ac <tx_thread+0xc0>
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d18c:	110006d6 	add	w22, w22, #0x1
  40d190:	91008273 	add	x19, x19, #0x20
  40d194:	710042df 	cmp	w22, #0x10
  40d198:	54fffec1 	b.ne	40d170 <tx_thread+0x84>  // b.any
		k_mutex_unlock(&data->mtx);
  40d19c:	aa1a03e0 	mov	x0, x26
  40d1a0:	97ffff76 	bl	40cf78 <k_mutex_unlock.isra.0>
  40d1a4:	17ffffe2 	b	40d12c <tx_thread+0x40>
		/* Extended (29-bit) ID frame, standard (11-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_IDE) == 0 && (filter->flags & CAN_FILTER_IDE) != 0) {
  40d1a8:	35ffff22 	cbnz	w2, 40d18c <tx_thread+0xa0>
		/* Standard (11-bit) ID frame, extended (29-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_RTR) == 0 && (filter->flags & CAN_FILTER_DATA) == 0) {
  40d1ac:	37080280 	tbnz	w0, #1, 40d1fc <tx_thread+0x110>
  40d1b0:	3617fee1 	tbz	w1, #2, 40d18c <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
		/* Remote transmission request (RTR) frame, non-RTR filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_FDF) != 0 && (filter->flags & CAN_FILTER_FDF) == 0) {
  40d1b4:	121d0021 	and	w1, w1, #0x8
  40d1b8:	36100260 	tbz	w0, #2, 40d204 <tx_thread+0x118>
  40d1bc:	34fffe81 	cbz	w1, 40d18c <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
		/* Classic frame, CAN-FD format filter */
		return false;
	}

	if ((frame->id ^ filter->id) & filter->mask) {
  40d1c0:	937b7ec0 	sbfiz	x0, x22, #5, #32
  40d1c4:	8b000280 	add	x0, x20, x0
  40d1c8:	f94037e1 	ldr	x1, [sp, #104]
  40d1cc:	f9400800 	ldr	x0, [x0, #16]
  40d1d0:	4a010001 	eor	w1, w0, w1
  40d1d4:	d360f000 	ubfx	x0, x0, #32, #29
  40d1d8:	6a00003f 	tst	w1, w0
  40d1dc:	54fffd81 	b.ne	40d18c <tx_thread+0xa0>  // b.any
	struct can_frame frame_tmp = *frame;
  40d1e0:	a94687e0 	ldp	x0, x1, [sp, #104]
  40d1e4:	a90587e0 	stp	x0, x1, [sp, #88]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40d1e8:	a9400a63 	ldp	x3, x2, [x19]
  40d1ec:	aa1903e1 	mov	x1, x25
  40d1f0:	aa1503e0 	mov	x0, x21
  40d1f4:	d63f0060 	blr	x3
}
  40d1f8:	17ffffe5 	b	40d18c <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
  40d1fc:	370ffdc1 	tbnz	w1, #1, 40d1b4 <tx_thread+0xc8>
  40d200:	17ffffe3 	b	40d18c <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
  40d204:	34fffde1 	cbz	w1, 40d1c0 <tx_thread+0xd4>
  40d208:	17ffffe1 	b	40d18c <tx_thread+0xa0>

000000000040d20c <can_loopback_add_rx_filter>:
{
  40d20c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40d210:	910003fd 	mov	x29, sp
  40d214:	a90153f3 	stp	x19, x20, [sp, #16]
  40d218:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d21c:	a90363f7 	stp	x23, x24, [sp, #48]
  40d220:	f90023f9 	str	x25, [sp, #64]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA | CAN_FILTER_RTR)) != 0) {
  40d224:	39402073 	ldrb	w19, [x3, #8]
  40d228:	39402067 	ldrb	w7, [x3, #8]
  40d22c:	f27df273 	ands	x19, x19, #0xfffffffffffffff8
	struct can_loopback_data *data = dev->data;
  40d230:	f9401016 	ldr	x22, [x0, #32]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA | CAN_FILTER_RTR)) != 0) {
  40d234:	54000260 	b.eq	40d280 <can_loopback_add_rx_filter+0x74>  // b.none
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40d238:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
		return -ENOTSUP;
  40d23c:	12800bd5 	mov	w21, #0xffffffa1            	// #-95
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40d240:	90000046 	adrp	x6, 415000 <random_data+0xca4>
  40d244:	52800005 	mov	w5, #0x0                   	// #0
  40d248:	f9474c21 	ldr	x1, [x1, #3736]
  40d24c:	913c94c6 	add	x6, x6, #0xf25
  40d250:	d2800004 	mov	x4, #0x0                   	// #0
  40d254:	d2800003 	mov	x3, #0x0                   	// #0
  40d258:	52800022 	mov	w2, #0x1                   	// #1
  40d25c:	52800000 	mov	w0, #0x0                   	// #0
  40d260:	97fffea6 	bl	40ccf8 <z_log_msg_runtime_create.constprop.0>
}
  40d264:	2a1503e0 	mov	w0, w21
  40d268:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d26c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d270:	a94363f7 	ldp	x23, x24, [sp, #48]
  40d274:	f94023f9 	ldr	x25, [sp, #64]
  40d278:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40d27c:	d65f03c0 	ret
  40d280:	aa0103f9 	mov	x25, x1
  40d284:	aa0203f8 	mov	x24, x2
  40d288:	aa0303f4 	mov	x20, x3
	k_mutex_lock(&data->mtx, K_FOREVER);
  40d28c:	910802d7 	add	x23, x22, #0x200
  40d290:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40d294:	aa1703e0 	mov	x0, x23
  40d298:	940006da 	bl	40ee00 <z_impl_k_mutex_lock>
		if (filters[i].rx_cb == NULL) {
  40d29c:	d37bea60 	lsl	x0, x19, #5
  40d2a0:	2a1303f5 	mov	w21, w19
  40d2a4:	f8606ac0 	ldr	x0, [x22, x0]
  40d2a8:	b4000240 	cbz	x0, 40d2f0 <can_loopback_add_rx_filter+0xe4>
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d2ac:	91000673 	add	x19, x19, #0x1
  40d2b0:	f100427f 	cmp	x19, #0x10
  40d2b4:	54ffff41 	b.ne	40d29c <can_loopback_add_rx_filter+0x90>  // b.any
		LOG_ERR("No free filter left");
  40d2b8:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40d2bc:	90000046 	adrp	x6, 415000 <random_data+0xca4>
  40d2c0:	913d24c6 	add	x6, x6, #0xf49
  40d2c4:	52800005 	mov	w5, #0x0                   	// #0
  40d2c8:	f9474c21 	ldr	x1, [x1, #3736]
  40d2cc:	d2800004 	mov	x4, #0x0                   	// #0
  40d2d0:	d2800003 	mov	x3, #0x0                   	// #0
  40d2d4:	52800022 	mov	w2, #0x1                   	// #1
  40d2d8:	52800000 	mov	w0, #0x0                   	// #0
	return -ENOSPC;
  40d2dc:	12800375 	mov	w21, #0xffffffe4            	// #-28
		LOG_ERR("No free filter left");
  40d2e0:	97fffe86 	bl	40ccf8 <z_log_msg_runtime_create.constprop.0>
		k_mutex_unlock(&data->mtx);
  40d2e4:	aa1703e0 	mov	x0, x23
  40d2e8:	97ffff24 	bl	40cf78 <k_mutex_unlock.isra.0>
		return filter_id;
  40d2ec:	17ffffde 	b	40d264 <can_loopback_add_rx_filter+0x58>
	loopback_filter->rx_cb = cb;
  40d2f0:	937b7e61 	sbfiz	x1, x19, #5, #32
  40d2f4:	8b0102c0 	add	x0, x22, x1
  40d2f8:	f8216ad9 	str	x25, [x22, x1]
	loopback_filter->cb_arg = cb_arg;
  40d2fc:	f9000418 	str	x24, [x0, #8]
	loopback_filter->filter = *filter;
  40d300:	f9400281 	ldr	x1, [x20]
  40d304:	f9000801 	str	x1, [x0, #16]
  40d308:	b9400a81 	ldr	w1, [x20, #8]
  40d30c:	b9001801 	str	w1, [x0, #24]
	k_mutex_unlock(&data->mtx);
  40d310:	aa1703e0 	mov	x0, x23
  40d314:	97ffff19 	bl	40cf78 <k_mutex_unlock.isra.0>
	return filter_id;
  40d318:	17ffffd3 	b	40d264 <can_loopback_add_rx_filter+0x58>

000000000040d31c <posix_arch_console_init>:
		stdout_buff[0] = 0;
	}
}

static int posix_arch_console_init(void)
{
  40d31c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#ifdef CONFIG_PRINTK
	extern void __printk_hook_install(int (*fn)(int));
	__printk_hook_install(print_char);
  40d320:	90000000 	adrp	x0, 40d000 <can_loopback_init>
  40d324:	910cf000 	add	x0, x0, #0x33c
{
  40d328:	910003fd 	mov	x29, sp
	__printk_hook_install(print_char);
  40d32c:	97ffe44f 	bl	406468 <__printk_hook_install>
#ifdef CONFIG_STDOUT_CONSOLE
	extern void __stdout_hook_install(int (*fn)(int));
	__stdout_hook_install(print_char);
#endif
	return 0;
}
  40d330:	52800000 	mov	w0, #0x0                   	// #0
  40d334:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d338:	d65f03c0 	ret

000000000040d33c <print_char>:
{
  40d33c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if ((c != '\n') && (c != '\r')) {
  40d340:	7100281f 	cmp	w0, #0xa
  40d344:	7a4d1804 	ccmp	w0, #0xd, #0x4, ne  // ne = any
{
  40d348:	910003fd 	mov	x29, sp
  40d34c:	a90153f3 	stp	x19, x20, [sp, #16]
  40d350:	2a0003f3 	mov	w19, w0
  40d354:	90000114 	adrp	x20, 42d000 <args_struct>
  40d358:	f90013f5 	str	x21, [sp, #32]
	if ((c != '\n') && (c != '\r')) {
  40d35c:	54000320 	b.eq	40d3c0 <print_char+0x84>  // b.none
		stdout_buff[n_pend++] = c;
  40d360:	b94c0682 	ldr	w2, [x20, #3076]
  40d364:	b0000100 	adrp	x0, 42e000 <irq_prio+0xf>
  40d368:	91005c00 	add	x0, x0, #0x17
  40d36c:	11000441 	add	w1, w2, #0x1
  40d370:	b90c0681 	str	w1, [x20, #3076]
  40d374:	3822c813 	strb	w19, [x0, w2, sxtw]
		stdout_buff[n_pend] = 0;
  40d378:	3821c81f 	strb	wzr, [x0, w1, sxtw]
	int printnow = 0;
  40d37c:	52800000 	mov	w0, #0x0                   	// #0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  40d380:	b94c0681 	ldr	w1, [x20, #3076]
  40d384:	7103f83f 	cmp	w1, #0xfe
  40d388:	5400004c 	b.gt	40d390 <print_char+0x54>
	if (printnow) {
  40d38c:	34000100 	cbz	w0, 40d3ac <print_char+0x70>
		posix_print_trace("%s\n", stdout_buff);
  40d390:	b0000115 	adrp	x21, 42e000 <irq_prio+0xf>
  40d394:	90000040 	adrp	x0, 415000 <random_data+0xca4>
  40d398:	91005ea1 	add	x1, x21, #0x17
  40d39c:	91269c00 	add	x0, x0, #0x9a7
  40d3a0:	97fff47e 	bl	40a598 <posix_print_trace>
		n_pend = 0;
  40d3a4:	b90c069f 	str	wzr, [x20, #3076]
		stdout_buff[0] = 0;
  40d3a8:	39005ebf 	strb	wzr, [x21, #23]
}
  40d3ac:	2a1303e0 	mov	w0, w19
  40d3b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d3b4:	f94013f5 	ldr	x21, [sp, #32]
  40d3b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40d3bc:	d65f03c0 	ret
		printnow = 1;
  40d3c0:	52800020 	mov	w0, #0x1                   	// #1
  40d3c4:	17ffffef 	b	40d380 <print_char+0x44>

000000000040d3c8 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
  40d3c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d3cc:	910003fd 	mov	x29, sp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
  40d3d0:	97fff148 	bl	4098f0 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40d3d4:	90000102 	adrp	x2, 42d000 <args_struct>
  40d3d8:	90000101 	adrp	x1, 42d000 <args_struct>

	last_tick_time += elapsed_ticks*tick_period;
	sys_clock_announce(elapsed_ticks);
}
  40d3dc:	a8c17bfd 	ldp	x29, x30, [sp], #16
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40d3e0:	f943b843 	ldr	x3, [x2, #1904]
  40d3e4:	f943bc24 	ldr	x4, [x1, #1912]
  40d3e8:	cb030000 	sub	x0, x0, x3
  40d3ec:	9ac40800 	udiv	x0, x0, x4
	last_tick_time += elapsed_ticks*tick_period;
  40d3f0:	93407c01 	sxtw	x1, w0
  40d3f4:	9b040c21 	madd	x1, x1, x4, x3
  40d3f8:	f903b841 	str	x1, [x2, #1904]
	sys_clock_announce(elapsed_ticks);
  40d3fc:	1400163b 	b	412ce8 <sys_clock_announce>

000000000040d400 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(void)
{
  40d400:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40d404:	d284e200 	mov	x0, #0x2710                	// #10000
{
  40d408:	910003fd 	mov	x29, sp
  40d40c:	f9000bf3 	str	x19, [sp, #16]
	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40d410:	90000113 	adrp	x19, 42d000 <args_struct>
  40d414:	f903be60 	str	x0, [x19, #1912]

	last_tick_time = hwm_get_time();
  40d418:	97fff136 	bl	4098f0 <hwm_get_time>
  40d41c:	90000101 	adrp	x1, 42d000 <args_struct>
  40d420:	f903b820 	str	x0, [x1, #1904]
	hwtimer_enable(tick_period);
  40d424:	f943be60 	ldr	x0, [x19, #1912]
  40d428:	97fff1c6 	bl	409b40 <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
  40d42c:	d2800003 	mov	x3, #0x0                   	// #0
  40d430:	52800001 	mov	w1, #0x0                   	// #0
  40d434:	52800000 	mov	w0, #0x0                   	// #0
  40d438:	90000002 	adrp	x2, 40d000 <can_loopback_init>
  40d43c:	910f2042 	add	x2, x2, #0x3c8
  40d440:	97fff2e0 	bl	409fc0 <posix_isr_declare>
  40d444:	52800002 	mov	w2, #0x0                   	// #0
  40d448:	52800021 	mov	w1, #0x1                   	// #1
  40d44c:	52800000 	mov	w0, #0x0                   	// #0
  40d450:	97fff2e6 	bl	409fe8 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
  40d454:	52800000 	mov	w0, #0x0                   	// #0
  40d458:	97ffee52 	bl	408da0 <arch_irq_enable>

	return 0;
}
  40d45c:	52800000 	mov	w0, #0x0                   	// #0
  40d460:	f9400bf3 	ldr	x19, [sp, #16]
  40d464:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40d468:	d65f03c0 	ret

000000000040d46c <sys_clock_cycle_get_32>:
{
  40d46c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d470:	910003fd 	mov	x29, sp
	return hwm_get_time();
  40d474:	97fff11f 	bl	4098f0 <hwm_get_time>
}
  40d478:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d47c:	d65f03c0 	ret

000000000040d480 <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
  40d480:	3100041f 	cmn	w0, #0x1
  40d484:	540000c0 	b.eq	40d49c <sys_clock_set_timeout+0x1c>  // b.none
		silent_ticks = ticks - 1;
  40d488:	51000401 	sub	w1, w0, #0x1
  40d48c:	7100001f 	cmp	w0, #0x0
  40d490:	93407c21 	sxtw	x1, w1
  40d494:	9a9fc020 	csel	x0, x1, xzr, gt
	hwtimer_set_silent_ticks(silent_ticks);
  40d498:	17fff21e 	b	409d10 <hwtimer_set_silent_ticks>
		silent_ticks = INT64_MAX;
  40d49c:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  40d4a0:	17fffffe 	b	40d498 <sys_clock_set_timeout+0x18>

000000000040d4a4 <sys_clock_elapsed>:
{
  40d4a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d4a8:	910003fd 	mov	x29, sp
	return (hwm_get_time() - last_tick_time)/tick_period;
  40d4ac:	97fff111 	bl	4098f0 <hwm_get_time>
  40d4b0:	90000101 	adrp	x1, 42d000 <args_struct>
}
  40d4b4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return (hwm_get_time() - last_tick_time)/tick_period;
  40d4b8:	f943b821 	ldr	x1, [x1, #1904]
  40d4bc:	cb010000 	sub	x0, x0, x1
  40d4c0:	90000101 	adrp	x1, 42d000 <args_struct>
  40d4c4:	f943bc21 	ldr	x1, [x1, #1912]
}
  40d4c8:	9ac10800 	udiv	x0, x0, x1
  40d4cc:	d65f03c0 	ret

000000000040d4d0 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	STRUCT_SECTION_FOREACH(device, dev) {
  40d4d0:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40d4d4:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40d4d8:	f9476000 	ldr	x0, [x0, #3776]
  40d4dc:	f9478421 	ldr	x1, [x1, #3848]
  40d4e0:	eb01001f 	cmp	x0, x1
  40d4e4:	54000349 	b.ls	40d54c <z_device_state_init+0x7c>  // b.plast
{
  40d4e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	STRUCT_SECTION_FOREACH(device, dev) {
  40d4ec:	90000041 	adrp	x1, 415000 <random_data+0xca4>
  40d4f0:	913e6c21 	add	x1, x1, #0xf9b
{
  40d4f4:	910003fd 	mov	x29, sp
  40d4f8:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(device, dev) {
  40d4fc:	90000053 	adrp	x19, 415000 <random_data+0xca4>
  40d500:	913de273 	add	x19, x19, #0xf78
  40d504:	528002e3 	mov	w3, #0x17                  	// #23
  40d508:	aa1303e2 	mov	x2, x19
  40d50c:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40d510:	911e2800 	add	x0, x0, #0x78a
  40d514:	97ffe99f 	bl	407b90 <assert_print>
  40d518:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40d51c:	912b2c00 	add	x0, x0, #0xacb
  40d520:	97ffe99c 	bl	407b90 <assert_print>
  40d524:	aa1303e0 	mov	x0, x19
  40d528:	528002e1 	mov	w1, #0x17                  	// #23
  40d52c:	97ffe9c3 	bl	407c38 <assert_post_action>
  40d530:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40d534:	aa1303e1 	mov	x1, x19
  40d538:	911f2000 	add	x0, x0, #0x7c8
  40d53c:	528002e2 	mov	w2, #0x17                  	// #23
  40d540:	97fff3b0 	bl	40a400 <posix_print_error_and_exit>
  40d544:	9100c000 	add	x0, x0, #0x30
  40d548:	17ffffe6 	b	40d4e0 <z_device_state_init+0x10>
  40d54c:	54ffffc3 	b.cc	40d544 <z_device_state_init+0x74>  // b.lo, b.ul, b.last
  40d550:	d65f03c0 	ret

000000000040d554 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
  40d554:	b4000100 	cbz	x0, 40d574 <z_device_is_ready+0x20>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
  40d558:	f9400c00 	ldr	x0, [x0, #24]
  40d55c:	39400401 	ldrb	w1, [x0, #1]
  40d560:	360000a1 	tbz	w1, #0, 40d574 <z_device_is_ready+0x20>
  40d564:	39400000 	ldrb	w0, [x0]
  40d568:	7100001f 	cmp	w0, #0x0
  40d56c:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40d570:	d65f03c0 	ret
		return false;
  40d574:	52800000 	mov	w0, #0x0                   	// #0
  40d578:	17fffffe 	b	40d570 <z_device_is_ready+0x1c>

000000000040d57c <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40d57c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40d580:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40d584:	910003fd 	mov	x29, sp
  40d588:	f9476800 	ldr	x0, [x0, #3792]
  40d58c:	3d8023e0 	str	q0, [sp, #128]
  40d590:	3d8027e1 	str	q1, [sp, #144]
  40d594:	3d802be2 	str	q2, [sp, #160]
  40d598:	3d802fe3 	str	q3, [sp, #176]
  40d59c:	3d8033e4 	str	q4, [sp, #192]
  40d5a0:	3d8037e5 	str	q5, [sp, #208]
  40d5a4:	3d803be6 	str	q6, [sp, #224]
  40d5a8:	3d803fe7 	str	q7, [sp, #240]
  40d5ac:	f90087e7 	str	x7, [sp, #264]
  40d5b0:	f9400002 	ldr	x2, [x0]
  40d5b4:	f9003fe2 	str	x2, [sp, #120]
  40d5b8:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40d5bc:	910443e0 	add	x0, sp, #0x110
  40d5c0:	a90383e0 	stp	x0, x0, [sp, #56]
  40d5c4:	910403e0 	add	x0, sp, #0x100
  40d5c8:	9100e3e2 	add	x2, sp, #0x38
  40d5cc:	f90027e0 	str	x0, [sp, #72]
  40d5d0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40d5d4:	b90053e0 	str	w0, [sp, #80]
  40d5d8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40d5dc:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40d5e0:	910163e0 	add	x0, sp, #0x58
  40d5e4:	ad400440 	ldp	q0, q1, [x2]
  40d5e8:	ad000400 	stp	q0, q1, [x0]
  40d5ec:	ad400400 	ldp	q0, q1, [x0]
  40d5f0:	910043e7 	add	x7, sp, #0x10
  40d5f4:	52800022 	mov	w2, #0x1                   	// #1
  40d5f8:	52800000 	mov	w0, #0x0                   	// #0
  40d5fc:	52800005 	mov	w5, #0x0                   	// #0
  40d600:	d2800004 	mov	x4, #0x0                   	// #0
  40d604:	d2800003 	mov	x3, #0x0                   	// #0
  40d608:	ad0004e0 	stp	q0, q1, [x7]
  40d60c:	97ffeb41 	bl	408310 <z_impl_z_log_msg_runtime_vcreate>
}
  40d610:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40d614:	f9476800 	ldr	x0, [x0, #3792]
  40d618:	f9403fe2 	ldr	x2, [sp, #120]
  40d61c:	f9400001 	ldr	x1, [x0]
  40d620:	eb010042 	subs	x2, x2, x1
  40d624:	d2800001 	mov	x1, #0x0                   	// #0
  40d628:	54000040 	b.eq	40d630 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40d62c:	97ffcf3d 	bl	401320 <__stack_chk_fail@plt>
  40d630:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40d634:	d65f03c0 	ret

000000000040d638 <coredump>:
#else

void coredump(unsigned int reason, const z_arch_esf_t *esf,
	      struct k_thread *thread)
{
}
  40d638:	d65f03c0 	ret

000000000040d63c <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  40d63c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40d640:	910003fd 	mov	x29, sp
  40d644:	f9000bf3 	str	x19, [sp, #16]
  40d648:	2a0003f3 	mov	w19, w0
  40d64c:	97ffea42 	bl	407f54 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
  40d650:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40d654:	90000046 	adrp	x6, 415000 <random_data+0xca4>
  40d658:	913eccc6 	add	x6, x6, #0xfb3
  40d65c:	52800005 	mov	w5, #0x0                   	// #0
  40d660:	f9470421 	ldr	x1, [x1, #3592]
  40d664:	d2800004 	mov	x4, #0x0                   	// #0
  40d668:	d2800003 	mov	x3, #0x0                   	// #0
  40d66c:	52800022 	mov	w2, #0x1                   	// #1
  40d670:	52800000 	mov	w0, #0x0                   	// #0
  40d674:	97ffffc2 	bl	40d57c <z_log_msg_runtime_create.constprop.0>
	arch_system_halt(reason);
  40d678:	2a1303e0 	mov	w0, w19
  40d67c:	97ffedbe 	bl	408d74 <arch_system_halt>

000000000040d680 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  40d680:	d10143ff 	sub	sp, sp, #0x50
  40d684:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d688:	910043fd 	add	x29, sp, #0x10
  40d68c:	a90253f3 	stp	x19, x20, [sp, #32]
  40d690:	2a0003f3 	mov	w19, w0
  40d694:	aa0103f4 	mov	x20, x1
  40d698:	a9035bf5 	stp	x21, x22, [sp, #48]
  40d69c:	f90023f7 	str	x23, [sp, #64]
	return posix_irq_lock();
  40d6a0:	97fff242 	bl	409fa8 <posix_irq_lock>
  40d6a4:	2a0003f5 	mov	w21, w0
	return z_impl_z_current_get();
  40d6a8:	940012da 	bl	412210 <z_impl_z_current_get>
  40d6ac:	aa0003f6 	mov	x22, x0
	switch (reason) {
  40d6b0:	7100127f 	cmp	w19, #0x4
  40d6b4:	54000848 	b.hi	40d7bc <z_fatal_error+0x13c>  // b.pmore
  40d6b8:	d0000020 	adrp	x0, 413000 <z_impl_k_uptime_ticks>
  40d6bc:	911a8000 	add	x0, x0, #0x6a0
  40d6c0:	38734800 	ldrb	w0, [x0, w19, uxtw]
  40d6c4:	10000061 	adr	x1, 40d6d0 <z_fatal_error+0x50>
  40d6c8:	8b208820 	add	x0, x1, w0, sxtb #2
  40d6cc:	d61f0000 	br	x0
		return "Unhandled interrupt";
  40d6d0:	90000043 	adrp	x3, 415000 <random_data+0xca4>
  40d6d4:	913f4063 	add	x3, x3, #0xfd0
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  40d6d8:	d00000f7 	adrp	x23, 42b000 <__FRAME_END__+0xff4c>
  40d6dc:	f90003e3 	str	x3, [sp]
  40d6e0:	b9000bff 	str	wzr, [sp, #8]
  40d6e4:	b0000046 	adrp	x6, 416000 <__func__.0+0xb3f>
  40d6e8:	f94706e1 	ldr	x1, [x23, #3592]
  40d6ec:	2a1303e7 	mov	w7, w19
  40d6f0:	910088c6 	add	x6, x6, #0x22
  40d6f4:	52800005 	mov	w5, #0x0                   	// #0
  40d6f8:	d2800004 	mov	x4, #0x0                   	// #0
  40d6fc:	52800022 	mov	w2, #0x1                   	// #1
  40d700:	52800000 	mov	w0, #0x0                   	// #0
  40d704:	d2800003 	mov	x3, #0x0                   	// #0
  40d708:	97ffff9d 	bl	40d57c <z_log_msg_runtime_create.constprop.0>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
  40d70c:	b40000d6 	cbz	x22, 40d724 <z_fatal_error+0xa4>
  40d710:	aa1603e0 	mov	x0, x22
  40d714:	940002d6 	bl	40e26c <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
  40d718:	b4000060 	cbz	x0, 40d724 <z_fatal_error+0xa4>
  40d71c:	39400001 	ldrb	w1, [x0]
  40d720:	35000061 	cbnz	w1, 40d72c <z_fatal_error+0xac>
		thread_name = "unknown";
  40d724:	b0000043 	adrp	x3, 416000 <__func__.0+0xb3f>
  40d728:	91006860 	add	x0, x3, #0x1a
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  40d72c:	f94706e1 	ldr	x1, [x23, #3592]
  40d730:	aa1603e7 	mov	x7, x22
  40d734:	b0000046 	adrp	x6, 416000 <__func__.0+0xb3f>
  40d738:	910128c6 	add	x6, x6, #0x4a
  40d73c:	f90003e0 	str	x0, [sp]
  40d740:	52800005 	mov	w5, #0x0                   	// #0
  40d744:	d2800004 	mov	x4, #0x0                   	// #0
  40d748:	d2800003 	mov	x3, #0x0                   	// #0
  40d74c:	52800022 	mov	w2, #0x1                   	// #1
  40d750:	52800000 	mov	w0, #0x0                   	// #0
  40d754:	97ffff8a 	bl	40d57c <z_log_msg_runtime_create.constprop.0>
		thread_name_get(thread));

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
  40d758:	aa1603e2 	mov	x2, x22
  40d75c:	aa1403e1 	mov	x1, x20
  40d760:	2a1303e0 	mov	w0, w19
  40d764:	97ffffb5 	bl	40d638 <coredump>
#endif

	k_sys_fatal_error_handler(reason, esf);
  40d768:	aa1403e1 	mov	x1, x20
  40d76c:	2a1303e0 	mov	w0, w19
  40d770:	97ffffb3 	bl	40d63c <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
  40d774:	2a1503e0 	mov	w0, w21
  40d778:	97fff20e 	bl	409fb0 <posix_irq_unlock>
	z_impl_k_thread_abort(thread);
  40d77c:	aa1603e0 	mov	x0, x22
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
  40d780:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40d784:	a94253f3 	ldp	x19, x20, [sp, #32]
  40d788:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40d78c:	f94023f7 	ldr	x23, [sp, #64]
  40d790:	910143ff 	add	sp, sp, #0x50
  40d794:	17ffeeb2 	b	40925c <z_impl_k_thread_abort>
		return "Stack overflow";
  40d798:	90000043 	adrp	x3, 415000 <random_data+0xca4>
  40d79c:	913f9063 	add	x3, x3, #0xfe4
  40d7a0:	17ffffce 	b	40d6d8 <z_fatal_error+0x58>
		return "Kernel oops";
  40d7a4:	90000043 	adrp	x3, 415000 <random_data+0xca4>
  40d7a8:	913fcc63 	add	x3, x3, #0xff3
  40d7ac:	17ffffcb 	b	40d6d8 <z_fatal_error+0x58>
		return "Kernel panic";
  40d7b0:	90000043 	adrp	x3, 415000 <random_data+0xca4>
  40d7b4:	913ffc63 	add	x3, x3, #0xfff
  40d7b8:	17ffffc8 	b	40d6d8 <z_fatal_error+0x58>
		return "Unknown error";
  40d7bc:	b0000043 	adrp	x3, 416000 <__func__.0+0xb3f>
  40d7c0:	91003063 	add	x3, x3, #0xc
  40d7c4:	17ffffc5 	b	40d6d8 <z_fatal_error+0x58>
	switch (reason) {
  40d7c8:	90000043 	adrp	x3, 415000 <random_data+0xca4>
  40d7cc:	913f0863 	add	x3, x3, #0xfc2
  40d7d0:	17ffffc2 	b	40d6d8 <z_fatal_error+0x58>

000000000040d7d4 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
  40d7d4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d7d8:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40d7dc:	91274021 	add	x1, x1, #0x9d0
{
  40d7e0:	910003fd 	mov	x29, sp
  40d7e4:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d7e8:	f8605833 	ldr	x19, [x1, w0, uxtw #3]
  40d7ec:	11000400 	add	w0, w0, #0x1
{
  40d7f0:	a9025bf5 	stp	x21, x22, [sp, #32]
						rc = -rc;
					}
					if (rc > UINT8_MAX) {
						rc = UINT8_MAX;
					}
					dev->state->init_res = rc;
  40d7f4:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d7f8:	f8607835 	ldr	x21, [x1, x0, lsl #3]
  40d7fc:	eb1302bf 	cmp	x21, x19
  40d800:	540000a8 	b.hi	40d814 <z_sys_init_run_level+0x40>  // b.pmore
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
  40d804:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d808:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d80c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40d810:	d65f03c0 	ret
		const struct device *dev = entry->dev;
  40d814:	a9405261 	ldp	x1, x20, [x19]
		if (dev != NULL) {
  40d818:	b4000234 	cbz	x20, 40d85c <z_sys_init_run_level+0x88>
			if (entry->init_fn.dev != NULL) {
  40d81c:	b4000141 	cbz	x1, 40d844 <z_sys_init_run_level+0x70>
				rc = entry->init_fn.dev(dev);
  40d820:	aa1403e0 	mov	x0, x20
  40d824:	d63f0020 	blr	x1
				if (rc != 0) {
  40d828:	7100001f 	cmp	w0, #0x0
  40d82c:	340000c0 	cbz	w0, 40d844 <z_sys_init_run_level+0x70>
					dev->state->init_res = rc;
  40d830:	f9400e81 	ldr	x1, [x20, #24]
  40d834:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
  40d838:	7103fc1f 	cmp	w0, #0xff
  40d83c:	1a96d000 	csel	w0, w0, w22, le
  40d840:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
  40d844:	f9400e81 	ldr	x1, [x20, #24]
  40d848:	39400420 	ldrb	w0, [x1, #1]
  40d84c:	32000000 	orr	w0, w0, #0x1
  40d850:	39000420 	strb	w0, [x1, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d854:	91004273 	add	x19, x19, #0x10
  40d858:	17ffffe9 	b	40d7fc <z_sys_init_run_level+0x28>
			(void)entry->init_fn.sys();
  40d85c:	d63f0020 	blr	x1
  40d860:	17fffffd 	b	40d854 <z_sys_init_run_level+0x80>

000000000040d864 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
  40d864:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
  40d868:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40d86c:	52800021 	mov	w1, #0x1                   	// #1
{
  40d870:	910003fd 	mov	x29, sp
	z_sys_post_kernel = true;
  40d874:	f946f000 	ldr	x0, [x0, #3552]
  40d878:	39000001 	strb	w1, [x0]

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
  40d87c:	52800060 	mov	w0, #0x3                   	// #3
  40d880:	97ffffd5 	bl	40d7d4 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
  40d884:	94001733 	bl	413550 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
  40d888:	52800080 	mov	w0, #0x4                   	// #4
  40d88c:	97ffffd2 	bl	40d7d4 <z_sys_init_run_level>

	z_init_static_threads();
  40d890:	9400030d 	bl	40e4c4 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
  40d894:	97fff8d9 	bl	40bbf8 <_posix_zephyr_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  40d898:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40d89c:	f947e800 	ldr	x0, [x0, #4048]
  40d8a0:	39406001 	ldrb	w1, [x0, #24]
  40d8a4:	121f7821 	and	w1, w1, #0xfffffffe
  40d8a8:	39006001 	strb	w1, [x0, #24]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  40d8ac:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d8b0:	d65f03c0 	ret

000000000040d8b4 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
  40d8b4:	d10143ff 	sub	sp, sp, #0x50
	z_setup_new_thread(thread, stack,
  40d8b8:	52800504 	mov	w4, #0x28                  	// #40
  40d8bc:	d00000e3 	adrp	x3, 42b000 <__FRAME_END__+0xff4c>
  40d8c0:	528001e7 	mov	w7, #0xf                   	// #15
  40d8c4:	d2800006 	mov	x6, #0x0                   	// #0
  40d8c8:	d2800005 	mov	x5, #0x0                   	// #0
{
  40d8cc:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d8d0:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(thread, stack,
  40d8d4:	d2802002 	mov	x2, #0x100                 	// #256
  40d8d8:	f9475063 	ldr	x3, [x3, #3744]
{
  40d8dc:	a9035bf5 	stp	x21, x22, [sp, #48]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  40d8e0:	d00000f6 	adrp	x22, 42b000 <__FRAME_END__+0xff4c>
{
  40d8e4:	f90023f7 	str	x23, [sp, #64]
	struct k_thread *thread = &z_idle_threads[i];
  40d8e8:	d00000f7 	adrp	x23, 42b000 <__FRAME_END__+0xff4c>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  40d8ec:	f9472ed6 	ldr	x22, [x22, #3672]
{
  40d8f0:	a90253f3 	stp	x19, x20, [sp, #32]
  40d8f4:	93407c13 	sxtw	x19, w0
	struct k_thread *thread = &z_idle_threads[i];
  40d8f8:	f946fef7 	ldr	x23, [x23, #3576]
  40d8fc:	52801815 	mov	w21, #0xc0                  	// #192
	z_setup_new_thread(thread, stack,
  40d900:	9b245a64 	smaddl	x4, w19, w4, x22
  40d904:	b0000040 	adrp	x0, 416000 <__func__.0+0xb3f>
  40d908:	91018800 	add	x0, x0, #0x62
  40d90c:	f90007e0 	str	x0, [sp, #8]
	struct k_thread *thread = &z_idle_threads[i];
  40d910:	9b355e75 	smaddl	x21, w19, w21, x23
	z_setup_new_thread(thread, stack,
  40d914:	52800020 	mov	w0, #0x1                   	// #1
  40d918:	b90003e0 	str	w0, [sp]
	k_thread_stack_t *stack = z_idle_stacks[i];
  40d91c:	93787e61 	sbfiz	x1, x19, #8, #32
	z_setup_new_thread(thread, stack,
  40d920:	b0000120 	adrp	x0, 432000 <ztest_thread_stack+0x190>
  40d924:	9111c000 	add	x0, x0, #0x470
  40d928:	8b010001 	add	x1, x0, x1
  40d92c:	aa1503e0 	mov	x0, x21
  40d930:	94000259 	bl	40e294 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  40d934:	d2801800 	mov	x0, #0xc0                  	// #192
  40d938:	9b005e60 	madd	x0, x19, x0, x23
  40d93c:	39406401 	ldrb	w1, [x0, #25]
  40d940:	121d7821 	and	w1, w1, #0xfffffffb
  40d944:	39006401 	strb	w1, [x0, #25]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40d948:	d2800501 	mov	x1, #0x28                  	// #40
	_kernel.cpus[id].id = id;
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40d94c:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40d950:	9b015a61 	madd	x1, x19, x1, x22
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40d954:	f946f800 	ldr	x0, [x0, #3568]
	_kernel.cpus[id].id = id;
  40d958:	39008033 	strb	w19, [x1, #32]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40d95c:	91000673 	add	x19, x19, #0x1
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40d960:	f9000c35 	str	x21, [x1, #24]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40d964:	8b132c13 	add	x19, x0, x19, lsl #11
	_kernel.cpus[id].irq_stack =
  40d968:	f9000433 	str	x19, [x1, #8]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  40d96c:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40d970:	d2800020 	mov	x0, #0x1                   	// #1
  40d974:	f9477021 	ldr	x1, [x1, #3808]
  40d978:	97ffcf26 	bl	401610 <__aarch64_ldadd8_acq_rel>
	/*
	 * Increment number of CPUs active. The pm subsystem
	 * will keep track of this from here.
	 */
	atomic_inc(&_cpus_active);
}
  40d97c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40d980:	a94253f3 	ldp	x19, x20, [sp, #32]
  40d984:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40d988:	f94023f7 	ldr	x23, [sp, #64]
  40d98c:	910143ff 	add	sp, sp, #0x50
  40d990:	d65f03c0 	ret

000000000040d994 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
  40d994:	d10403ff 	sub	sp, sp, #0x100
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  40d998:	52800000 	mov	w0, #0x0                   	// #0
{
  40d99c:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d9a0:	910043fd 	add	x29, sp, #0x10
  40d9a4:	a90253f3 	stp	x19, x20, [sp, #32]

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
  40d9a8:	d00000f4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
	_kernel.ready_q.cache = &z_main_thread;
  40d9ac:	d00000f3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
{
  40d9b0:	f9001bf5 	str	x21, [sp, #48]
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  40d9b4:	97ffff88 	bl	40d7d4 <z_sys_init_run_level>

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
  40d9b8:	97ffe95c 	bl	407f28 <log_core_init>
	dummy_thread->resource_pool = NULL;
  40d9bc:	f9007bff 	str	xzr, [sp, #240]
	_current_cpu->current = dummy_thread;
  40d9c0:	f9472e94 	ldr	x20, [x20, #3672]
	dummy_thread->base.user_options = K_ESSENTIAL;
  40d9c4:	52802020 	mov	w0, #0x101                 	// #257
  40d9c8:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
  40d9cc:	910103e0 	add	x0, sp, #0x40
  40d9d0:	f9000a80 	str	x0, [x20, #16]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
  40d9d4:	97fffebf 	bl	40d4d0 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
  40d9d8:	52800020 	mov	w0, #0x1                   	// #1
  40d9dc:	97ffff7e 	bl	40d7d4 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
  40d9e0:	52800040 	mov	w0, #0x2                   	// #2
  40d9e4:	97ffff7c 	bl	40d7d4 <z_sys_init_run_level>
	z_sched_init();
  40d9e8:	940010c7 	bl	411d04 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40d9ec:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40d9f0:	b0000040 	adrp	x0, 416000 <__func__.0+0xb3f>
	_kernel.ready_q.cache = &z_main_thread;
  40d9f4:	f947ea73 	ldr	x19, [x19, #4048]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40d9f8:	91019c00 	add	x0, x0, #0x67
  40d9fc:	f9477821 	ldr	x1, [x1, #3824]
	_kernel.ready_q.cache = &z_main_thread;
  40da00:	f9001693 	str	x19, [x20, #40]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40da04:	f90007e0 	str	x0, [sp, #8]
  40da08:	52800020 	mov	w0, #0x1                   	// #1
  40da0c:	b90003e0 	str	w0, [sp]
  40da10:	90000014 	adrp	x20, 40d000 <can_loopback_init>
  40da14:	91219294 	add	x20, x20, #0x864
  40da18:	52800007 	mov	w7, #0x0                   	// #0
  40da1c:	aa1403e3 	mov	x3, x20
  40da20:	d2800006 	mov	x6, #0x0                   	// #0
  40da24:	d2800005 	mov	x5, #0x0                   	// #0
  40da28:	d2800004 	mov	x4, #0x0                   	// #0
  40da2c:	d2804002 	mov	x2, #0x200                 	// #512
  40da30:	aa1303e0 	mov	x0, x19
  40da34:	94000218 	bl	40e294 <z_setup_new_thread>
  40da38:	aa0003f5 	mov	x21, x0
  40da3c:	39406660 	ldrb	w0, [x19, #25]
  40da40:	121d7800 	and	w0, w0, #0xfffffffb
  40da44:	39006660 	strb	w0, [x19, #25]
	z_ready_thread(&z_main_thread);
  40da48:	aa1303e0 	mov	x0, x19
  40da4c:	94000cfe 	bl	410e44 <z_ready_thread>
	z_init_cpu(0);
  40da50:	52800000 	mov	w0, #0x0                   	// #0
  40da54:	97ffff98 	bl	40d8b4 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  40da58:	aa1403e2 	mov	x2, x20
  40da5c:	aa1503e1 	mov	x1, x21
  40da60:	aa1303e0 	mov	x0, x19
  40da64:	97ffee3f 	bl	409360 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  40da68:	b0000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40da6c:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40da70:	9101b021 	add	x1, x1, #0x6c
  40da74:	911f2000 	add	x0, x0, #0x7c8
  40da78:	52803a82 	mov	w2, #0x1d4                 	// #468
  40da7c:	97fff261 	bl	40a400 <posix_print_error_and_exit>

000000000040da80 <k_heap_init>:
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
  40da80:	91006004 	add	x4, x0, #0x18
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
  40da84:	a9019004 	stp	x4, x4, [x0, #24]
#include <zephyr/sys/iterable_sections.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
  40da88:	17ffe470 	b	406c48 <sys_heap_init>

000000000040da8c <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
  40da8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40da90:	910003fd 	mov	x29, sp
  40da94:	a90153f3 	stp	x19, x20, [sp, #16]
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40da98:	d00000f3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  40da9c:	d00000f4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  40daa0:	f9474673 	ldr	x19, [x19, #3720]
  40daa4:	f9473294 	ldr	x20, [x20, #3680]
  40daa8:	eb14027f 	cmp	x19, x20
  40daac:	54000349 	b.ls	40db14 <statics_init+0x88>  // b.plast
  40dab0:	b0000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40dab4:	91024273 	add	x19, x19, #0x90
  40dab8:	aa1303e2 	mov	x2, x19
  40dabc:	b0000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40dac0:	9102c821 	add	x1, x1, #0xb2
  40dac4:	52800303 	mov	w3, #0x18                  	// #24
  40dac8:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dacc:	911e2800 	add	x0, x0, #0x78a
  40dad0:	97ffe830 	bl	407b90 <assert_print>
  40dad4:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dad8:	912b2c00 	add	x0, x0, #0xacb
  40dadc:	97ffe82d 	bl	407b90 <assert_print>
  40dae0:	aa1303e0 	mov	x0, x19
  40dae4:	52800301 	mov	w1, #0x18                  	// #24
  40dae8:	97ffe854 	bl	407c38 <assert_post_action>
  40daec:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40daf0:	aa1303e1 	mov	x1, x19
  40daf4:	911f2000 	add	x0, x0, #0x7c8
  40daf8:	52800302 	mov	w2, #0x18                  	// #24
  40dafc:	97fff241 	bl	40a400 <posix_print_error_and_exit>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  40db00:	a9408a61 	ldp	x1, x2, [x19, #8]
  40db04:	aa1303e0 	mov	x0, x19
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40db08:	9100c273 	add	x19, x19, #0x30
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  40db0c:	97ffffdd 	bl	40da80 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40db10:	17ffffe6 	b	40daa8 <statics_init+0x1c>
  40db14:	54ffff63 	b.cc	40db00 <statics_init+0x74>  // b.lo, b.ul, b.last
		}
	}
	return 0;
}
  40db18:	52800000 	mov	w0, #0x0                   	// #0
  40db1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40db20:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40db24:	d65f03c0 	ret

000000000040db28 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
  40db28:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40db2c:	910003fd 	mov	x29, sp
  40db30:	a90153f3 	stp	x19, x20, [sp, #16]
  40db34:	a9025bf5 	stp	x21, x22, [sp, #32]
  40db38:	aa0303f6 	mov	x22, x3
  40db3c:	aa0003f5 	mov	x21, x0
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  40db40:	aa0303e0 	mov	x0, x3
{
  40db44:	a90363f7 	stp	x23, x24, [sp, #48]
  40db48:	aa0103f7 	mov	x23, x1
  40db4c:	aa0203f8 	mov	x24, x2
  40db50:	a9046bf9 	stp	x25, x26, [sp, #64]
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  40db54:	9400152c 	bl	413004 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  40db58:	b10006df 	cmn	x22, #0x1
  40db5c:	92f00001 	mov	x1, #0x7fffffffffffffff    	// #9223372036854775807

	k_spinlock_key_t key = k_spin_lock(&h->lock);
  40db60:	9100a2b3 	add	x19, x21, #0x28
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  40db64:	9a811019 	csel	x25, x0, x1, ne  // ne = any
	return posix_irq_lock();
  40db68:	97fff110 	bl	409fa8 <posix_irq_lock>
  40db6c:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40db70:	aa1303e0 	mov	x0, x19
  40db74:	940002b4 	bl	40e644 <z_spin_lock_valid>
  40db78:	72001c1f 	tst	w0, #0xff
  40db7c:	54000281 	b.ne	40dbcc <k_heap_aligned_alloc+0xa4>  // b.any
  40db80:	90000054 	adrp	x20, 415000 <random_data+0xca4>
  40db84:	91334a94 	add	x20, x20, #0xcd2
  40db88:	aa1403e2 	mov	x2, x20
  40db8c:	52801283 	mov	w3, #0x94                  	// #148
  40db90:	90000041 	adrp	x1, 415000 <random_data+0xca4>
  40db94:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40db98:	9133fc21 	add	x1, x1, #0xcff
  40db9c:	911e2800 	add	x0, x0, #0x78a
  40dba0:	97ffe7fc 	bl	407b90 <assert_print>
  40dba4:	aa1303e1 	mov	x1, x19
  40dba8:	90000040 	adrp	x0, 415000 <random_data+0xca4>
  40dbac:	91345000 	add	x0, x0, #0xd14
  40dbb0:	97ffe7f8 	bl	407b90 <assert_print>
  40dbb4:	aa1403e0 	mov	x0, x20
  40dbb8:	52801281 	mov	w1, #0x94                  	// #148
  40dbbc:	97ffe81f 	bl	407c38 <assert_post_action>
  40dbc0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dbc4:	aa1403e1 	mov	x1, x20
  40dbc8:	14000019 	b	40dc2c <k_heap_aligned_alloc+0x104>
	z_spin_lock_set_owner(l);
  40dbcc:	aa1303e0 	mov	x0, x19
  40dbd0:	940002b5 	bl	40e6a4 <z_spin_lock_set_owner>
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
  40dbd4:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40dbd8:	f9472c00 	ldr	x0, [x0, #3672]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40dbdc:	b9400000 	ldr	w0, [x0]
  40dbe0:	34000860 	cbz	w0, 40dcec <k_heap_aligned_alloc+0x1c4>
  40dbe4:	b4000856 	cbz	x22, 40dcec <k_heap_aligned_alloc+0x1c4>
  40dbe8:	b0000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40dbec:	91024273 	add	x19, x19, #0x90
  40dbf0:	aa1303e2 	mov	x2, x19
  40dbf4:	b0000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40dbf8:	91032021 	add	x1, x1, #0xc8
  40dbfc:	52800983 	mov	w3, #0x4c                  	// #76
  40dc00:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dc04:	911e2800 	add	x0, x0, #0x78a
  40dc08:	97ffe7e2 	bl	407b90 <assert_print>
  40dc0c:	90000040 	adrp	x0, 415000 <random_data+0xca4>
  40dc10:	9135a400 	add	x0, x0, #0xd69
  40dc14:	97ffe7df 	bl	407b90 <assert_print>
  40dc18:	52800981 	mov	w1, #0x4c                  	// #76
  40dc1c:	aa1303e0 	mov	x0, x19
  40dc20:	97ffe806 	bl	407c38 <assert_post_action>
  40dc24:	aa1303e1 	mov	x1, x19
  40dc28:	52800982 	mov	w2, #0x4c                  	// #76
  40dc2c:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dc30:	911f2000 	add	x0, x0, #0x7c8
  40dc34:	97fff1f3 	bl	40a400 <posix_print_error_and_exit>
	while (ret == NULL) {
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);

		now = sys_clock_tick_get();
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
		    (ret != NULL) || ((end - now) <= 0)) {
  40dc38:	cb030323 	sub	x3, x25, x3
  40dc3c:	f100007f 	cmp	x3, #0x0
  40dc40:	540002ad 	b.le	40dc94 <k_heap_aligned_alloc+0x16c>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  40dc44:	2a1403e1 	mov	w1, w20
  40dc48:	aa1a03e2 	mov	x2, x26
  40dc4c:	aa1303e0 	mov	x0, x19
  40dc50:	94000dc6 	bl	411368 <z_pend_curr>
  40dc54:	97fff0d5 	bl	409fa8 <posix_irq_lock>
  40dc58:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40dc5c:	aa1303e0 	mov	x0, x19
  40dc60:	94000279 	bl	40e644 <z_spin_lock_valid>
  40dc64:	72001c1f 	tst	w0, #0xff
  40dc68:	54fff8c0 	b.eq	40db80 <k_heap_aligned_alloc+0x58>  // b.none
	z_spin_lock_set_owner(l);
  40dc6c:	aa1303e0 	mov	x0, x19
  40dc70:	9400028d 	bl	40e6a4 <z_spin_lock_set_owner>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
  40dc74:	aa1803e2 	mov	x2, x24
  40dc78:	aa1703e1 	mov	x1, x23
  40dc7c:	aa1503e0 	mov	x0, x21
  40dc80:	97ffe389 	bl	406aa4 <sys_heap_aligned_alloc>
  40dc84:	aa0003f6 	mov	x22, x0
		now = sys_clock_tick_get();
  40dc88:	94001495 	bl	412edc <sys_clock_tick_get>
  40dc8c:	aa0003e3 	mov	x3, x0
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
  40dc90:	b4fffd56 	cbz	x22, 40dc38 <k_heap_aligned_alloc+0x110>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dc94:	aa1303e0 	mov	x0, x19
  40dc98:	94000276 	bl	40e670 <z_spin_unlock_valid>
  40dc9c:	72001c1f 	tst	w0, #0xff
  40dca0:	540002a1 	b.ne	40dcf4 <k_heap_aligned_alloc+0x1cc>  // b.any
  40dca4:	90000054 	adrp	x20, 415000 <random_data+0xca4>
  40dca8:	91334a94 	add	x20, x20, #0xcd2
  40dcac:	aa1403e2 	mov	x2, x20
  40dcb0:	52801863 	mov	w3, #0xc3                  	// #195
  40dcb4:	90000041 	adrp	x1, 415000 <random_data+0xca4>
  40dcb8:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dcbc:	9134b021 	add	x1, x1, #0xd2c
  40dcc0:	911e2800 	add	x0, x0, #0x78a
  40dcc4:	97ffe7b3 	bl	407b90 <assert_print>
  40dcc8:	aa1303e1 	mov	x1, x19
  40dccc:	90000040 	adrp	x0, 415000 <random_data+0xca4>
  40dcd0:	91350c00 	add	x0, x0, #0xd43
  40dcd4:	97ffe7af 	bl	407b90 <assert_print>
  40dcd8:	aa1403e0 	mov	x0, x20
  40dcdc:	52801861 	mov	w1, #0xc3                  	// #195
  40dce0:	97ffe7d6 	bl	407c38 <assert_post_action>
  40dce4:	52801862 	mov	w2, #0xc3                  	// #195
  40dce8:	17ffffb7 	b	40dbc4 <k_heap_aligned_alloc+0x9c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  40dcec:	910062ba 	add	x26, x21, #0x18
  40dcf0:	17ffffe1 	b	40dc74 <k_heap_aligned_alloc+0x14c>
	posix_irq_unlock(key);
  40dcf4:	2a1403e0 	mov	w0, w20
  40dcf8:	97fff0ae 	bl	409fb0 <posix_irq_unlock>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
  40dcfc:	aa1603e0 	mov	x0, x22
  40dd00:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dd04:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dd08:	a94363f7 	ldp	x23, x24, [sp, #48]
  40dd0c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40dd10:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40dd14:	d65f03c0 	ret

000000000040dd18 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
  40dd18:	aa0203e3 	mov	x3, x2
  40dd1c:	aa0103e2 	mov	x2, x1
  40dd20:	d2800101 	mov	x1, #0x8                   	// #8
  40dd24:	17ffff81 	b	40db28 <k_heap_aligned_alloc>

000000000040dd28 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
  40dd28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40dd2c:	910003fd 	mov	x29, sp
  40dd30:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  40dd34:	9100a013 	add	x19, x0, #0x28
{
  40dd38:	aa0003f4 	mov	x20, x0
  40dd3c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40dd40:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  40dd44:	97fff099 	bl	409fa8 <posix_irq_lock>
  40dd48:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40dd4c:	aa1303e0 	mov	x0, x19
  40dd50:	9400023d 	bl	40e644 <z_spin_lock_valid>
  40dd54:	72001c1f 	tst	w0, #0xff
  40dd58:	540002c1 	b.ne	40ddb0 <k_heap_free+0x88>  // b.any
  40dd5c:	90000054 	adrp	x20, 415000 <random_data+0xca4>
  40dd60:	91334a94 	add	x20, x20, #0xcd2
  40dd64:	aa1403e2 	mov	x2, x20
  40dd68:	52801283 	mov	w3, #0x94                  	// #148
  40dd6c:	90000041 	adrp	x1, 415000 <random_data+0xca4>
  40dd70:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dd74:	9133fc21 	add	x1, x1, #0xcff
  40dd78:	911e2800 	add	x0, x0, #0x78a
  40dd7c:	97ffe785 	bl	407b90 <assert_print>
  40dd80:	aa1303e1 	mov	x1, x19
  40dd84:	90000040 	adrp	x0, 415000 <random_data+0xca4>
  40dd88:	91345000 	add	x0, x0, #0xd14
  40dd8c:	97ffe781 	bl	407b90 <assert_print>
  40dd90:	aa1403e0 	mov	x0, x20
  40dd94:	52801281 	mov	w1, #0x94                  	// #148
  40dd98:	97ffe7a8 	bl	407c38 <assert_post_action>
  40dd9c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dda0:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dda4:	aa1403e1 	mov	x1, x20
  40dda8:	911f2000 	add	x0, x0, #0x7c8
  40ddac:	97fff195 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40ddb0:	aa1303e0 	mov	x0, x19
  40ddb4:	9400023c 	bl	40e6a4 <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
  40ddb8:	aa1603e1 	mov	x1, x22
  40ddbc:	aa1403e0 	mov	x0, x20
  40ddc0:	97ffe2c8 	bl	4068e0 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
  40ddc4:	91006280 	add	x0, x20, #0x18
  40ddc8:	94000fba 	bl	411cb0 <z_unpend_all>
  40ddcc:	340000e0 	cbz	w0, 40dde8 <k_heap_free+0xc0>
		z_reschedule(&h->lock, key);
  40ddd0:	2a1503e1 	mov	w1, w21
  40ddd4:	aa1303e0 	mov	x0, x19
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
  40ddd8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dddc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dde0:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&h->lock, key);
  40dde4:	140009bd 	b	4104d8 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dde8:	aa1303e0 	mov	x0, x19
  40ddec:	94000221 	bl	40e670 <z_spin_unlock_valid>
  40ddf0:	72001c1f 	tst	w0, #0xff
  40ddf4:	54000261 	b.ne	40de40 <k_heap_free+0x118>  // b.any
  40ddf8:	90000054 	adrp	x20, 415000 <random_data+0xca4>
  40ddfc:	91334a94 	add	x20, x20, #0xcd2
  40de00:	aa1403e2 	mov	x2, x20
  40de04:	52801863 	mov	w3, #0xc3                  	// #195
  40de08:	90000041 	adrp	x1, 415000 <random_data+0xca4>
  40de0c:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40de10:	9134b021 	add	x1, x1, #0xd2c
  40de14:	911e2800 	add	x0, x0, #0x78a
  40de18:	97ffe75e 	bl	407b90 <assert_print>
  40de1c:	aa1303e1 	mov	x1, x19
  40de20:	90000040 	adrp	x0, 415000 <random_data+0xca4>
  40de24:	91350c00 	add	x0, x0, #0xd43
  40de28:	97ffe75a 	bl	407b90 <assert_print>
  40de2c:	aa1403e0 	mov	x0, x20
  40de30:	52801861 	mov	w1, #0xc3                  	// #195
  40de34:	97ffe781 	bl	407c38 <assert_post_action>
  40de38:	52801862 	mov	w2, #0xc3                  	// #195
  40de3c:	17ffffd9 	b	40dda0 <k_heap_free+0x78>
	posix_irq_unlock(key);
  40de40:	2a1503e0 	mov	w0, w21
}
  40de44:	a94153f3 	ldp	x19, x20, [sp, #16]
  40de48:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40de4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40de50:	17fff058 	b	409fb0 <posix_irq_unlock>

000000000040de54 <create_free_list>:
{
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  40de54:	a9420402 	ldp	x2, x1, [x0, #32]
  40de58:	aa020022 	orr	x2, x1, x2
  40de5c:	f240085f 	tst	x2, #0x7
  40de60:	540001e1 	b.ne	40de9c <create_free_list+0x48>  // b.any
	}

	slab->free_list = NULL;
	p = slab->buffer;

	for (j = 0U; j < slab->num_blocks; j++) {
  40de64:	52800002 	mov	w2, #0x0                   	// #0
	slab->free_list = NULL;
  40de68:	f900181f 	str	xzr, [x0, #48]
	for (j = 0U; j < slab->num_blocks; j++) {
  40de6c:	b9401803 	ldr	w3, [x0, #24]
  40de70:	6b02007f 	cmp	w3, w2
  40de74:	54000068 	b.hi	40de80 <create_free_list+0x2c>  // b.pmore
		*(char **)p = slab->free_list;
		slab->free_list = p;
		p += slab->block_size;
	}
	return 0;
  40de78:	52800000 	mov	w0, #0x0                   	// #0
}
  40de7c:	d65f03c0 	ret
		*(char **)p = slab->free_list;
  40de80:	f9401803 	ldr	x3, [x0, #48]
  40de84:	f9000023 	str	x3, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
  40de88:	11000442 	add	w2, w2, #0x1
		slab->free_list = p;
  40de8c:	f9001801 	str	x1, [x0, #48]
		p += slab->block_size;
  40de90:	f9401003 	ldr	x3, [x0, #32]
  40de94:	8b030021 	add	x1, x1, x3
	for (j = 0U; j < slab->num_blocks; j++) {
  40de98:	17fffff5 	b	40de6c <create_free_list+0x18>
		return -EINVAL;
  40de9c:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40dea0:	17fffff7 	b	40de7c <create_free_list+0x28>

000000000040dea4 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
  40dea4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int rc = 0;

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40dea8:	d00000e4 	adrp	x4, 42b000 <__FRAME_END__+0xff4c>
  40deac:	d00000e5 	adrp	x5, 42b000 <__FRAME_END__+0xff4c>
{
  40deb0:	910003fd 	mov	x29, sp
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40deb4:	f947e484 	ldr	x4, [x4, #4040]
	int rc = 0;
  40deb8:	52800000 	mov	w0, #0x0                   	// #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40debc:	f946f4a5 	ldr	x5, [x5, #3560]
{
  40dec0:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40dec4:	eb05009f 	cmp	x4, x5
  40dec8:	54000349 	b.ls	40df30 <init_mem_slab_module+0x8c>  // b.plast
  40decc:	b0000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40ded0:	91043a73 	add	x19, x19, #0x10e
  40ded4:	aa1303e2 	mov	x2, x19
  40ded8:	b0000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40dedc:	9104cc21 	add	x1, x1, #0x133
  40dee0:	528007a3 	mov	w3, #0x3d                  	// #61
  40dee4:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dee8:	911e2800 	add	x0, x0, #0x78a
  40deec:	97ffe729 	bl	407b90 <assert_print>
  40def0:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40def4:	912b2c00 	add	x0, x0, #0xacb
  40def8:	97ffe726 	bl	407b90 <assert_print>
  40defc:	aa1303e0 	mov	x0, x19
  40df00:	528007a1 	mov	w1, #0x3d                  	// #61
  40df04:	97ffe74d 	bl	407c38 <assert_post_action>
  40df08:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40df0c:	aa1303e1 	mov	x1, x19
  40df10:	911f2000 	add	x0, x0, #0x7c8
  40df14:	528007a2 	mov	w2, #0x3d                  	// #61
  40df18:	97fff13a 	bl	40a400 <posix_print_error_and_exit>
		rc = create_free_list(slab);
  40df1c:	aa0403e0 	mov	x0, x4
  40df20:	97ffffcd 	bl	40de54 <create_free_list>
		if (rc < 0) {
  40df24:	37f80080 	tbnz	w0, #31, 40df34 <init_mem_slab_module+0x90>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40df28:	91010084 	add	x4, x4, #0x40
  40df2c:	17ffffe6 	b	40dec4 <init_mem_slab_module+0x20>
  40df30:	54ffff63 	b.cc	40df1c <init_mem_slab_module+0x78>  // b.lo, b.ul, b.last
		z_object_init(slab);
	}

out:
	return rc;
}
  40df34:	f9400bf3 	ldr	x19, [sp, #16]
  40df38:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40df3c:	d65f03c0 	ret

000000000040df40 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
  40df40:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40df44:	910003fd 	mov	x29, sp
  40df48:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  40df4c:	91004014 	add	x20, x0, #0x10
{
  40df50:	aa0003f3 	mov	x19, x0
  40df54:	a9025bf5 	stp	x21, x22, [sp, #32]
  40df58:	aa0103f5 	mov	x21, x1
  40df5c:	f9001bf7 	str	x23, [sp, #48]
  40df60:	aa0203f7 	mov	x23, x2
	return posix_irq_lock();
  40df64:	97fff011 	bl	409fa8 <posix_irq_lock>
  40df68:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40df6c:	aa1403e0 	mov	x0, x20
  40df70:	940001b5 	bl	40e644 <z_spin_lock_valid>
  40df74:	72001c1f 	tst	w0, #0xff
  40df78:	540002c1 	b.ne	40dfd0 <k_mem_slab_alloc+0x90>  // b.any
  40df7c:	90000053 	adrp	x19, 415000 <random_data+0xca4>
  40df80:	91334a73 	add	x19, x19, #0xcd2
  40df84:	aa1303e2 	mov	x2, x19
  40df88:	52801283 	mov	w3, #0x94                  	// #148
  40df8c:	90000041 	adrp	x1, 415000 <random_data+0xca4>
  40df90:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40df94:	9133fc21 	add	x1, x1, #0xcff
  40df98:	911e2800 	add	x0, x0, #0x78a
  40df9c:	97ffe6fd 	bl	407b90 <assert_print>
  40dfa0:	aa1403e1 	mov	x1, x20
  40dfa4:	90000040 	adrp	x0, 415000 <random_data+0xca4>
  40dfa8:	91345000 	add	x0, x0, #0xd14
  40dfac:	97ffe6f9 	bl	407b90 <assert_print>
  40dfb0:	aa1303e0 	mov	x0, x19
  40dfb4:	52801281 	mov	w1, #0x94                  	// #148
  40dfb8:	97ffe720 	bl	407c38 <assert_post_action>
  40dfbc:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dfc0:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40dfc4:	aa1303e1 	mov	x1, x19
  40dfc8:	911f2000 	add	x0, x0, #0x7c8
  40dfcc:	97fff10d 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40dfd0:	aa1403e0 	mov	x0, x20
  40dfd4:	940001b4 	bl	40e6a4 <z_spin_lock_set_owner>
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
  40dfd8:	f9401a60 	ldr	x0, [x19, #48]
  40dfdc:	b40003c0 	cbz	x0, 40e054 <k_mem_slab_alloc+0x114>
		/* take a free block */
		*mem = slab->free_list;
  40dfe0:	f90002a0 	str	x0, [x21]
		slab->free_list = *(char **)(slab->free_list);
  40dfe4:	f9400000 	ldr	x0, [x0]
  40dfe8:	f9001a60 	str	x0, [x19, #48]
		slab->num_used++;
  40dfec:	b9403a60 	ldr	w0, [x19, #56]
  40dff0:	11000400 	add	w0, w0, #0x1
  40dff4:	b9003a60 	str	w0, [x19, #56]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
  40dff8:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dffc:	aa1403e0 	mov	x0, x20
  40e000:	9400019c 	bl	40e670 <z_spin_unlock_valid>
  40e004:	72001c1f 	tst	w0, #0xff
  40e008:	54000521 	b.ne	40e0ac <k_mem_slab_alloc+0x16c>  // b.any
  40e00c:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40e010:	91334a73 	add	x19, x19, #0xcd2
  40e014:	aa1303e2 	mov	x2, x19
  40e018:	52801863 	mov	w3, #0xc3                  	// #195
  40e01c:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40e020:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e024:	9134b021 	add	x1, x1, #0xd2c
  40e028:	911e2800 	add	x0, x0, #0x78a
  40e02c:	97ffe6d9 	bl	407b90 <assert_print>
  40e030:	aa1403e1 	mov	x1, x20
  40e034:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40e038:	91350c00 	add	x0, x0, #0xd43
  40e03c:	97ffe6d5 	bl	407b90 <assert_print>
  40e040:	aa1303e0 	mov	x0, x19
  40e044:	52801861 	mov	w1, #0xc3                  	// #195
  40e048:	97ffe6fc 	bl	407c38 <assert_post_action>
  40e04c:	52801862 	mov	w2, #0xc3                  	// #195
  40e050:	17ffffdc 	b	40dfc0 <k_mem_slab_alloc+0x80>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
  40e054:	b5000097 	cbnz	x23, 40e064 <k_mem_slab_alloc+0x124>
		   !IS_ENABLED(CONFIG_MULTITHREADING)) {
		/* don't wait for a free block to become available */
		*mem = NULL;
		result = -ENOMEM;
  40e058:	12800173 	mov	w19, #0xfffffff4            	// #-12
		*mem = NULL;
  40e05c:	f90002bf 	str	xzr, [x21]
		result = -ENOMEM;
  40e060:	17ffffe7 	b	40dffc <k_mem_slab_alloc+0xbc>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);

		/* wait for a free block or timeout */
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
  40e064:	aa1303e2 	mov	x2, x19
  40e068:	aa1703e3 	mov	x3, x23
  40e06c:	2a1603e1 	mov	w1, w22
  40e070:	aa1403e0 	mov	x0, x20
  40e074:	94000cbd 	bl	411368 <z_pend_curr>
  40e078:	2a0003f3 	mov	w19, w0
		if (result == 0) {
  40e07c:	350000c0 	cbnz	w0, 40e094 <k_mem_slab_alloc+0x154>
			*mem = _current->base.swap_data;
  40e080:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40e084:	f9472c00 	ldr	x0, [x0, #3672]
  40e088:	f9400800 	ldr	x0, [x0, #16]
  40e08c:	f9401000 	ldr	x0, [x0, #32]
  40e090:	f90002a0 	str	x0, [x21]
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
  40e094:	2a1303e0 	mov	w0, w19
  40e098:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e09c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e0a0:	f9401bf7 	ldr	x23, [sp, #48]
  40e0a4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40e0a8:	d65f03c0 	ret
	posix_irq_unlock(key);
  40e0ac:	2a1603e0 	mov	w0, w22
  40e0b0:	97ffefc0 	bl	409fb0 <posix_irq_unlock>
	return result;
  40e0b4:	17fffff8 	b	40e094 <k_mem_slab_alloc+0x154>

000000000040e0b8 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
  40e0b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40e0bc:	910003fd 	mov	x29, sp
  40e0c0:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  40e0c4:	91004014 	add	x20, x0, #0x10
{
  40e0c8:	aa0003f3 	mov	x19, x0
  40e0cc:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e0d0:	aa0103f5 	mov	x21, x1
	return posix_irq_lock();
  40e0d4:	97ffefb5 	bl	409fa8 <posix_irq_lock>
  40e0d8:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40e0dc:	aa1403e0 	mov	x0, x20
  40e0e0:	94000159 	bl	40e644 <z_spin_lock_valid>
  40e0e4:	72001c1f 	tst	w0, #0xff
  40e0e8:	540002c1 	b.ne	40e140 <k_mem_slab_free+0x88>  // b.any
  40e0ec:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40e0f0:	91334a73 	add	x19, x19, #0xcd2
  40e0f4:	aa1303e2 	mov	x2, x19
  40e0f8:	52801283 	mov	w3, #0x94                  	// #148
  40e0fc:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40e100:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e104:	9133fc21 	add	x1, x1, #0xcff
  40e108:	911e2800 	add	x0, x0, #0x78a
  40e10c:	97ffe6a1 	bl	407b90 <assert_print>
  40e110:	aa1403e1 	mov	x1, x20
  40e114:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40e118:	91345000 	add	x0, x0, #0xd14
  40e11c:	97ffe69d 	bl	407b90 <assert_print>
  40e120:	aa1303e0 	mov	x0, x19
  40e124:	52801281 	mov	w1, #0x94                  	// #148
  40e128:	97ffe6c4 	bl	407c38 <assert_post_action>
  40e12c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e130:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e134:	aa1303e1 	mov	x1, x19
  40e138:	911f2000 	add	x0, x0, #0x7c8
  40e13c:	97fff0b1 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40e140:	aa1403e0 	mov	x0, x20
  40e144:	94000158 	bl	40e6a4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
  40e148:	f9401a60 	ldr	x0, [x19, #48]
  40e14c:	b50001c0 	cbnz	x0, 40e184 <k_mem_slab_free+0xcc>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
  40e150:	aa1303e0 	mov	x0, x19
  40e154:	94000e8d 	bl	411b88 <z_unpend_first_thread>

		if (pending_thread != NULL) {
  40e158:	b4000160 	cbz	x0, 40e184 <k_mem_slab_free+0xcc>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
  40e15c:	f94002a1 	ldr	x1, [x21]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
  40e160:	f9001001 	str	x1, [x0, #32]
	thread->callee_saved.retval = value;
  40e164:	b9004c1f 	str	wzr, [x0, #76]
			z_ready_thread(pending_thread);
  40e168:	94000b37 	bl	410e44 <z_ready_thread>
			z_reschedule(&slab->lock, key);
  40e16c:	2a1603e1 	mov	w1, w22
  40e170:	aa1403e0 	mov	x0, x20
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
  40e174:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e178:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e17c:	a8c37bfd 	ldp	x29, x30, [sp], #48
			z_reschedule(&slab->lock, key);
  40e180:	140008d6 	b	4104d8 <z_reschedule>
	**(char ***) mem = slab->free_list;
  40e184:	f94002a0 	ldr	x0, [x21]
  40e188:	f9401a61 	ldr	x1, [x19, #48]
  40e18c:	f9000001 	str	x1, [x0]
	slab->free_list = *(char **) mem;
  40e190:	f94002a0 	ldr	x0, [x21]
  40e194:	f9001a60 	str	x0, [x19, #48]
	slab->num_used--;
  40e198:	b9403a60 	ldr	w0, [x19, #56]
  40e19c:	51000400 	sub	w0, w0, #0x1
  40e1a0:	b9003a60 	str	w0, [x19, #56]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e1a4:	aa1403e0 	mov	x0, x20
  40e1a8:	94000132 	bl	40e670 <z_spin_unlock_valid>
  40e1ac:	72001c1f 	tst	w0, #0xff
  40e1b0:	54000261 	b.ne	40e1fc <k_mem_slab_free+0x144>  // b.any
  40e1b4:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40e1b8:	91334a73 	add	x19, x19, #0xcd2
  40e1bc:	aa1303e2 	mov	x2, x19
  40e1c0:	52801863 	mov	w3, #0xc3                  	// #195
  40e1c4:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40e1c8:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e1cc:	9134b021 	add	x1, x1, #0xd2c
  40e1d0:	911e2800 	add	x0, x0, #0x78a
  40e1d4:	97ffe66f 	bl	407b90 <assert_print>
  40e1d8:	aa1403e1 	mov	x1, x20
  40e1dc:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40e1e0:	91350c00 	add	x0, x0, #0xd43
  40e1e4:	97ffe66b 	bl	407b90 <assert_print>
  40e1e8:	aa1303e0 	mov	x0, x19
  40e1ec:	52801861 	mov	w1, #0xc3                  	// #195
  40e1f0:	97ffe692 	bl	407c38 <assert_post_action>
  40e1f4:	52801862 	mov	w2, #0xc3                  	// #195
  40e1f8:	17ffffce 	b	40e130 <k_mem_slab_free+0x78>
	posix_irq_unlock(key);
  40e1fc:	2a1603e0 	mov	w0, w22
}
  40e200:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e204:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e208:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40e20c:	17ffef69 	b	409fb0 <posix_irq_unlock>

000000000040e210 <k_is_in_isr>:
	return _kernel.cpus[0].nested != 0U;
  40e210:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40e214:	f9472c00 	ldr	x0, [x0, #3672]
  40e218:	b9400000 	ldr	w0, [x0]
  40e21c:	7100001f 	cmp	w0, #0x0
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
  40e220:	1a9f07e0 	cset	w0, ne  // ne = any
  40e224:	d65f03c0 	ret

000000000040e228 <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
  40e228:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e22c:	910003fd 	mov	x29, sp
  40e230:	f9000bf3 	str	x19, [sp, #16]
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
  40e234:	b5000180 	cbnz	x0, 40e264 <z_impl_k_thread_name_set+0x3c>
		thread = _current;
  40e238:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40e23c:	f9472c00 	ldr	x0, [x0, #3672]
  40e240:	f9400813 	ldr	x19, [x0, #16]

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len,
  40e244:	91022660 	add	x0, x19, #0x89
  40e248:	d28003e2 	mov	x2, #0x1f                  	// #31
  40e24c:	97ffcc81 	bl	401450 <strncpy@plt>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  40e250:	3902a27f 	strb	wzr, [x19, #168]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
  40e254:	52800000 	mov	w0, #0x0                   	// #0
  40e258:	f9400bf3 	ldr	x19, [sp, #16]
  40e25c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e260:	d65f03c0 	ret
  40e264:	aa0003f3 	mov	x19, x0
  40e268:	17fffff7 	b	40e244 <z_impl_k_thread_name_set+0x1c>

000000000040e26c <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
  40e26c:	91022400 	add	x0, x0, #0x89
  40e270:	d65f03c0 	ret

000000000040e274 <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
  40e274:	14000b35 	b	410f48 <z_sched_start>

000000000040e278 <z_init_thread_base>:

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
  40e278:	f900081f 	str	xzr, [x0, #16]
	thread_base->user_options = (uint8_t)options;
  40e27c:	39006003 	strb	w3, [x0, #24]
	thread_base->thread_state = (uint8_t)initial_state;
  40e280:	39006402 	strb	w2, [x0, #25]

	thread_base->prio = priority;
  40e284:	39006801 	strb	w1, [x0, #26]

	thread_base->sched_locked = 0U;
  40e288:	39006c1f 	strb	wzr, [x0, #27]
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
  40e28c:	a902fc1f 	stp	xzr, xzr, [x0, #40]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
  40e290:	d65f03c0 	ret

000000000040e294 <z_setup_new_thread>:
{
  40e294:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40e298:	910003fd 	mov	x29, sp
  40e29c:	a90153f3 	stp	x19, x20, [sp, #16]
  40e2a0:	aa0003f3 	mov	x19, x0
  40e2a4:	aa0203f4 	mov	x20, x2
  40e2a8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e2ac:	aa0103f6 	mov	x22, x1
  40e2b0:	2a0703f5 	mov	w21, w7
  40e2b4:	a90363f7 	stp	x23, x24, [sp, #48]
  40e2b8:	aa0303f7 	mov	x23, x3
  40e2bc:	aa0403f8 	mov	x24, x4
  40e2c0:	a9046bf9 	stp	x25, x26, [sp, #64]
  40e2c4:	aa0503fa 	mov	x26, x5
  40e2c8:	f9002bfb 	str	x27, [sp, #80]
  40e2cc:	aa0603fb 	mov	x27, x6
  40e2d0:	f94037f9 	ldr	x25, [sp, #104]
	Z_ASSERT_VALID_PRIO(prio, entry);
  40e2d4:	71003cff 	cmp	w7, #0xf
  40e2d8:	540005a1 	b.ne	40e38c <z_setup_new_thread+0xf8>  // b.any
  40e2dc:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40e2e0:	f9475000 	ldr	x0, [x0, #3744]
  40e2e4:	eb00007f 	cmp	x3, x0
  40e2e8:	54000581 	b.ne	40e398 <z_setup_new_thread+0x104>  // b.any
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e2ec:	b94063e3 	ldr	w3, [sp, #96]
  40e2f0:	91018260 	add	x0, x19, #0x60
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  40e2f4:	91001e94 	add	x20, x20, #0x7
	list->tail = (sys_dnode_t *)list;
  40e2f8:	a9060260 	stp	x0, x0, [x19, #96]
  40e2fc:	927df294 	and	x20, x20, #0xfffffffffffffff8
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e300:	2a1503e1 	mov	w1, w21
  40e304:	aa1303e0 	mov	x0, x19
  40e308:	52800082 	mov	w2, #0x4                   	// #4
	stack_ptr = (char *)stack + stack_obj_size;
  40e30c:	8b1402d4 	add	x20, x22, x20
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e310:	97ffffda 	bl	40e278 <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  40e314:	aa1b03e6 	mov	x6, x27
  40e318:	aa1a03e5 	mov	x5, x26
  40e31c:	aa1803e4 	mov	x4, x24
  40e320:	aa1703e3 	mov	x3, x23
  40e324:	aa1403e2 	mov	x2, x20
  40e328:	aa1603e1 	mov	x1, x22
  40e32c:	aa1303e0 	mov	x0, x19
  40e330:	97ffec13 	bl	40937c <arch_new_thread>
	new_thread->init_data = NULL;
  40e334:	f9002e7f 	str	xzr, [x19, #88]
	new_thread->no_wake_on_timeout = false;
  40e338:	3902227f 	strb	wzr, [x19, #136]
	if (name != NULL) {
  40e33c:	b40005d9 	cbz	x25, 40e3f4 <z_setup_new_thread+0x160>
  40e340:	aa1903e1 	mov	x1, x25
  40e344:	91022660 	add	x0, x19, #0x89
  40e348:	d28003e2 	mov	x2, #0x1f                  	// #31
  40e34c:	97ffcc41 	bl	401450 <strncpy@plt>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  40e350:	3902a27f 	strb	wzr, [x19, #168]
	if (!_current) {
  40e354:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40e358:	f9472c00 	ldr	x0, [x0, #3672]
  40e35c:	f9400800 	ldr	x0, [x0, #16]
  40e360:	b4000040 	cbz	x0, 40e368 <z_setup_new_thread+0xd4>
	new_thread->resource_pool = _current->resource_pool;
  40e364:	f9405800 	ldr	x0, [x0, #176]
	return stack_ptr;
  40e368:	f9005a60 	str	x0, [x19, #176]
}
  40e36c:	aa1403e0 	mov	x0, x20
  40e370:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e374:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e378:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e37c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40e380:	f9402bfb 	ldr	x27, [sp, #80]
  40e384:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40e388:	d65f03c0 	ret
	Z_ASSERT_VALID_PRIO(prio, entry);
  40e38c:	110040e0 	add	w0, w7, #0x10
  40e390:	7100781f 	cmp	w0, #0x1e
  40e394:	54fffac9 	b.ls	40e2ec <z_setup_new_thread+0x58>  // b.plast
  40e398:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40e39c:	91054273 	add	x19, x19, #0x150
  40e3a0:	aa1303e2 	mov	x2, x19
  40e3a4:	52804343 	mov	w3, #0x21a                 	// #538
  40e3a8:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40e3ac:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e3b0:	9105cc21 	add	x1, x1, #0x173
  40e3b4:	911e2800 	add	x0, x0, #0x78a
  40e3b8:	97ffe5f6 	bl	407b90 <assert_print>
  40e3bc:	528001c2 	mov	w2, #0xe                   	// #14
  40e3c0:	128001e3 	mov	w3, #0xfffffff0            	// #-16
  40e3c4:	2a1503e1 	mov	w1, w21
  40e3c8:	90000040 	adrp	x0, 416000 <__func__.0+0xb3f>
  40e3cc:	9107cc00 	add	x0, x0, #0x1f3
  40e3d0:	97ffe5f0 	bl	407b90 <assert_print>
  40e3d4:	aa1303e0 	mov	x0, x19
  40e3d8:	52804341 	mov	w1, #0x21a                 	// #538
  40e3dc:	97ffe617 	bl	407c38 <assert_post_action>
  40e3e0:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e3e4:	aa1303e1 	mov	x1, x19
  40e3e8:	911f2000 	add	x0, x0, #0x7c8
  40e3ec:	52804342 	mov	w2, #0x21a                 	// #538
  40e3f0:	97fff004 	bl	40a400 <posix_print_error_and_exit>
		new_thread->name[0] = '\0';
  40e3f4:	3902267f 	strb	wzr, [x19, #137]
  40e3f8:	17ffffd7 	b	40e354 <z_setup_new_thread+0xc0>

000000000040e3fc <z_impl_k_thread_create>:
{
  40e3fc:	d100c3ff 	sub	sp, sp, #0x30
  40e400:	b00000e8 	adrp	x8, 42b000 <__FRAME_END__+0xff4c>
  40e404:	a9017bfd 	stp	x29, x30, [sp, #16]
  40e408:	910043fd 	add	x29, sp, #0x10
  40e40c:	f9472d08 	ldr	x8, [x8, #3672]
  40e410:	a90253f3 	stp	x19, x20, [sp, #32]
  40e414:	f9401ff4 	ldr	x20, [sp, #56]
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
  40e418:	b9400108 	ldr	w8, [x8]
  40e41c:	340002a8 	cbz	w8, 40e470 <z_impl_k_thread_create+0x74>
  40e420:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40e424:	91054273 	add	x19, x19, #0x150
  40e428:	aa1303e2 	mov	x2, x19
  40e42c:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40e430:	91089021 	add	x1, x1, #0x224
  40e434:	52805183 	mov	w3, #0x28c                 	// #652
  40e438:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e43c:	911e2800 	add	x0, x0, #0x78a
  40e440:	97ffe5d4 	bl	407b90 <assert_print>
  40e444:	90000040 	adrp	x0, 416000 <__func__.0+0xb3f>
  40e448:	9108d800 	add	x0, x0, #0x236
  40e44c:	97ffe5d1 	bl	407b90 <assert_print>
  40e450:	aa1303e0 	mov	x0, x19
  40e454:	52805181 	mov	w1, #0x28c                 	// #652
  40e458:	97ffe5f8 	bl	407c38 <assert_post_action>
  40e45c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e460:	aa1303e1 	mov	x1, x19
  40e464:	911f2000 	add	x0, x0, #0x7c8
  40e468:	52805182 	mov	w2, #0x28c                 	// #652
  40e46c:	97ffefe5 	bl	40a400 <posix_print_error_and_exit>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  40e470:	b94033e8 	ldr	w8, [sp, #48]
  40e474:	aa0003f3 	mov	x19, x0
  40e478:	b90003e8 	str	w8, [sp]
  40e47c:	f90007ff 	str	xzr, [sp, #8]
  40e480:	97ffff85 	bl	40e294 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  40e484:	b100069f 	cmn	x20, #0x1
  40e488:	54000080 	b.eq	40e498 <z_impl_k_thread_create+0x9c>  // b.none
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  40e48c:	b5000114 	cbnz	x20, 40e4ac <z_impl_k_thread_create+0xb0>
	z_impl_k_thread_start(thread);
  40e490:	aa1303e0 	mov	x0, x19
  40e494:	97ffff78 	bl	40e274 <z_impl_k_thread_start>
}
  40e498:	aa1303e0 	mov	x0, x19
  40e49c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40e4a0:	a94253f3 	ldp	x19, x20, [sp, #32]
  40e4a4:	9100c3ff 	add	sp, sp, #0x30
  40e4a8:	d65f03c0 	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  40e4ac:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40e4b0:	aa1403e2 	mov	x2, x20
  40e4b4:	9100a260 	add	x0, x19, #0x28
  40e4b8:	f9472421 	ldr	x1, [x1, #3656]
  40e4bc:	94001130 	bl	41297c <z_add_timeout>
  40e4c0:	17fffff6 	b	40e498 <z_impl_k_thread_create+0x9c>

000000000040e4c4 <z_init_static_threads>:
{
  40e4c4:	d10103ff 	sub	sp, sp, #0x40
	_FOREACH_STATIC_THREAD(thread_data) {
  40e4c8:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
{
  40e4cc:	a9017bfd 	stp	x29, x30, [sp, #16]
  40e4d0:	910043fd 	add	x29, sp, #0x10
  40e4d4:	a90253f3 	stp	x19, x20, [sp, #32]
  40e4d8:	aa0003f4 	mov	x20, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  40e4dc:	f9479c13 	ldr	x19, [x0, #3896]
  40e4e0:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
{
  40e4e4:	a9035bf5 	stp	x21, x22, [sp, #48]
  40e4e8:	aa0003f5 	mov	x21, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  40e4ec:	f9471416 	ldr	x22, [x0, #3624]
  40e4f0:	eb16027f 	cmp	x19, x22
  40e4f4:	54000469 	b.ls	40e580 <z_init_static_threads+0xbc>  // b.plast
  40e4f8:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40e4fc:	91054273 	add	x19, x19, #0x150
  40e500:	aa1303e2 	mov	x2, x19
  40e504:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40e508:	91096c21 	add	x1, x1, #0x25b
  40e50c:	52805e63 	mov	w3, #0x2f3                 	// #755
  40e510:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e514:	911e2800 	add	x0, x0, #0x78a
  40e518:	97ffe59e 	bl	407b90 <assert_print>
  40e51c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e520:	912b2c00 	add	x0, x0, #0xacb
  40e524:	97ffe59b 	bl	407b90 <assert_print>
  40e528:	aa1303e0 	mov	x0, x19
  40e52c:	52805e61 	mov	w1, #0x2f3                 	// #755
  40e530:	97ffe5c2 	bl	407c38 <assert_post_action>
  40e534:	52805e62 	mov	w2, #0x2f3                 	// #755
	_FOREACH_STATIC_THREAD(thread_data) {
  40e538:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e53c:	aa1303e1 	mov	x1, x19
  40e540:	911f2000 	add	x0, x0, #0x7c8
  40e544:	97ffefaf 	bl	40a400 <posix_print_error_and_exit>
		z_setup_new_thread(
  40e548:	f9402660 	ldr	x0, [x19, #72]
  40e54c:	b9401262 	ldr	w2, [x19, #16]
  40e550:	f90007e0 	str	x0, [sp, #8]
  40e554:	b9403e60 	ldr	w0, [x19, #60]
  40e558:	b90003e0 	str	w0, [sp]
  40e55c:	a9400660 	ldp	x0, x1, [x19]
  40e560:	a9419263 	ldp	x3, x4, [x19, #24]
  40e564:	a9429a65 	ldp	x5, x6, [x19, #40]
  40e568:	b9403a67 	ldr	w7, [x19, #56]
  40e56c:	97ffff4a 	bl	40e294 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  40e570:	f9400260 	ldr	x0, [x19]
  40e574:	f9002c13 	str	x19, [x0, #88]
	_FOREACH_STATIC_THREAD(thread_data) {
  40e578:	91014273 	add	x19, x19, #0x50
  40e57c:	17ffffdd 	b	40e4f0 <z_init_static_threads+0x2c>
  40e580:	54fffe43 	b.cc	40e548 <z_init_static_threads+0x84>  // b.lo, b.ul, b.last
	k_sched_lock();
  40e584:	94000826 	bl	41061c <k_sched_lock>
  40e588:	d2800156 	mov	x22, #0xa                   	// #10
	_FOREACH_STATIC_THREAD(thread_data) {
  40e58c:	f9479e93 	ldr	x19, [x20, #3896]
  40e590:	f94716b4 	ldr	x20, [x21, #3624]
  40e594:	b00000f5 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
  40e598:	f94726b5 	ldr	x21, [x21, #3656]
  40e59c:	eb14027f 	cmp	x19, x20
  40e5a0:	54000469 	b.ls	40e62c <z_init_static_threads+0x168>  // b.plast
  40e5a4:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40e5a8:	91054273 	add	x19, x19, #0x150
  40e5ac:	aa1303e2 	mov	x2, x19
  40e5b0:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40e5b4:	91096c21 	add	x1, x1, #0x25b
  40e5b8:	52806243 	mov	w3, #0x312                 	// #786
  40e5bc:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e5c0:	911e2800 	add	x0, x0, #0x78a
  40e5c4:	97ffe573 	bl	407b90 <assert_print>
  40e5c8:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e5cc:	912b2c00 	add	x0, x0, #0xacb
  40e5d0:	97ffe570 	bl	407b90 <assert_print>
  40e5d4:	aa1303e0 	mov	x0, x19
  40e5d8:	52806241 	mov	w1, #0x312                 	// #786
  40e5dc:	97ffe597 	bl	407c38 <assert_post_action>
  40e5e0:	52806242 	mov	w2, #0x312                 	// #786
  40e5e4:	17ffffd5 	b	40e538 <z_init_static_threads+0x74>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
  40e5e8:	b9404262 	ldr	w2, [x19, #64]
  40e5ec:	3100045f 	cmn	w2, #0x1
  40e5f0:	54000100 	b.eq	40e610 <z_init_static_threads+0x14c>  // b.none
					    K_MSEC(thread_data->init_delay));
  40e5f4:	7100005f 	cmp	w2, #0x0
  40e5f8:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
  40e5fc:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
  40e600:	93407c43 	sxtw	x3, w2
		t += off;
  40e604:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  40e608:	b5000083 	cbnz	x3, 40e618 <z_init_static_threads+0x154>
  40e60c:	97ffff1a 	bl	40e274 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
  40e610:	91014273 	add	x19, x19, #0x50
  40e614:	17ffffe2 	b	40e59c <z_init_static_threads+0xd8>
  40e618:	9ad60842 	udiv	x2, x2, x22
  40e61c:	aa1503e1 	mov	x1, x21
  40e620:	9100a000 	add	x0, x0, #0x28
  40e624:	940010d6 	bl	41297c <z_add_timeout>
  40e628:	17fffffa 	b	40e610 <z_init_static_threads+0x14c>
  40e62c:	54fffde3 	b.cc	40e5e8 <z_init_static_threads+0x124>  // b.lo, b.ul, b.last
}
  40e630:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40e634:	a94253f3 	ldp	x19, x20, [sp, #32]
  40e638:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40e63c:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
  40e640:	14000c9f 	b	4118bc <k_sched_unlock>

000000000040e644 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
  40e644:	f9400000 	ldr	x0, [x0]

	if (thread_cpu != 0U) {
  40e648:	b4000100 	cbz	x0, 40e668 <z_spin_lock_valid+0x24>
		if ((thread_cpu & 3U) == _current_cpu->id) {
  40e64c:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40e650:	92400400 	and	x0, x0, #0x3
  40e654:	f9472c21 	ldr	x1, [x1, #3672]
  40e658:	39408021 	ldrb	w1, [x1, #32]
  40e65c:	eb01001f 	cmp	x0, x1
  40e660:	1a9f07e0 	cset	w0, ne  // ne = any
			return false;
		}
	}
	return true;
}
  40e664:	d65f03c0 	ret
	return true;
  40e668:	52800020 	mov	w0, #0x1                   	// #1
  40e66c:	17fffffe 	b	40e664 <z_spin_lock_valid+0x20>

000000000040e670 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
  40e670:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40e674:	f9472c21 	ldr	x1, [x1, #3672]
  40e678:	39408022 	ldrb	w2, [x1, #32]
  40e67c:	f9400821 	ldr	x1, [x1, #16]
  40e680:	aa020021 	orr	x1, x1, x2
  40e684:	f9400002 	ldr	x2, [x0]
  40e688:	eb01005f 	cmp	x2, x1
  40e68c:	54000081 	b.ne	40e69c <z_spin_unlock_valid+0x2c>  // b.any
		return false;
	}
	l->thread_cpu = 0;
  40e690:	f900001f 	str	xzr, [x0]
	return true;
  40e694:	52800020 	mov	w0, #0x1                   	// #1
}
  40e698:	d65f03c0 	ret
		return false;
  40e69c:	52800000 	mov	w0, #0x0                   	// #0
  40e6a0:	17fffffe 	b	40e698 <z_spin_unlock_valid+0x28>

000000000040e6a4 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
  40e6a4:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  40e6a8:	f9472c21 	ldr	x1, [x1, #3672]
  40e6ac:	39408022 	ldrb	w2, [x1, #32]
  40e6b0:	f9400821 	ldr	x1, [x1, #16]
  40e6b4:	aa020021 	orr	x1, x1, x2
  40e6b8:	f9000001 	str	x1, [x0]
}
  40e6bc:	d65f03c0 	ret

000000000040e6c0 <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
  40e6c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e6c4:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
{
  40e6c8:	910003fd 	mov	x29, sp
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e6cc:	f9472c00 	ldr	x0, [x0, #3672]
{
  40e6d0:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e6d4:	f9400800 	ldr	x0, [x0, #16]
  40e6d8:	39c06800 	ldrsb	w0, [x0, #26]
  40e6dc:	36f80240 	tbz	w0, #31, 40e724 <idle+0x64>
  40e6e0:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40e6e4:	910a2273 	add	x19, x19, #0x288
  40e6e8:	aa1303e2 	mov	x2, x19
  40e6ec:	52800523 	mov	w3, #0x29                  	// #41
  40e6f0:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40e6f4:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e6f8:	910aa421 	add	x1, x1, #0x2a9
  40e6fc:	911e2800 	add	x0, x0, #0x78a
  40e700:	97ffe524 	bl	407b90 <assert_print>
  40e704:	aa1303e0 	mov	x0, x19
  40e708:	52800521 	mov	w1, #0x29                  	// #41
  40e70c:	97ffe54b 	bl	407c38 <assert_post_action>
  40e710:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e714:	aa1303e1 	mov	x1, x19
  40e718:	911f2000 	add	x0, x0, #0x7c8
  40e71c:	52800522 	mov	w2, #0x29                  	// #41
  40e720:	97ffef38 	bl	40a400 <posix_print_error_and_exit>
	return posix_irq_lock();
  40e724:	97ffee21 	bl	409fa8 <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
  40e728:	97ffe98d 	bl	408d5c <arch_cpu_idle>
  40e72c:	17fffffe 	b	40e724 <idle+0x64>

000000000040e730 <k_msgq_init>:

void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
		 uint32_t max_msgs)
{
	msgq->msg_size = msg_size;
	msgq->max_msgs = max_msgs;
  40e730:	b9002003 	str	w3, [x0, #32]
	msgq->buffer_start = buffer;
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e734:	2a0303e3 	mov	w3, w3
	msgq->msg_size = msg_size;
  40e738:	a901081f 	stp	xzr, x2, [x0, #16]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e73c:	9b020462 	madd	x2, x3, x2, x1
  40e740:	a9000000 	stp	x0, x0, [x0]
	msgq->buffer_start = buffer;
  40e744:	f9001401 	str	x1, [x0, #40]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e748:	f9001802 	str	x2, [x0, #48]
	msgq->read_ptr = buffer;
	msgq->write_ptr = buffer;
  40e74c:	a9038401 	stp	x1, x1, [x0, #56]
	msgq->used_msgs = 0;
	msgq->flags = 0;
	z_waitq_init(&msgq->wait_q);
	msgq->lock = (struct k_spinlock) {};
#ifdef CONFIG_POLL
	sys_dlist_init(&msgq->poll_events);
  40e750:	91014001 	add	x1, x0, #0x50
	msgq->used_msgs = 0;
  40e754:	b900481f 	str	wzr, [x0, #72]
  40e758:	a9050401 	stp	x1, x1, [x0, #80]
	msgq->flags = 0;
  40e75c:	3901801f 	strb	wzr, [x0, #96]
#endif	/* CONFIG_POLL */

	SYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);

	z_object_init(msgq);
}
  40e760:	d65f03c0 	ret

000000000040e764 <k_msgq_cleanup>:
}
#include <syscalls/k_msgq_alloc_init_mrsh.c>
#endif

int k_msgq_cleanup(struct k_msgq *msgq)
{
  40e764:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e768:	910003fd 	mov	x29, sp
  40e76c:	f9000bf3 	str	x19, [sp, #16]
  40e770:	aa0003f3 	mov	x19, x0
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  40e774:	f9400000 	ldr	x0, [x0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40e778:	eb00027f 	cmp	x19, x0
  40e77c:	54000040 	b.eq	40e784 <k_msgq_cleanup+0x20>  // b.none
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);

	CHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {
  40e780:	b5000140 	cbnz	x0, 40e7a8 <k_msgq_cleanup+0x44>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, -EBUSY);

		return -EBUSY;
	}

	if ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {
  40e784:	39418260 	ldrb	w0, [x19, #96]
  40e788:	360000c0 	tbz	w0, #0, 40e7a0 <k_msgq_cleanup+0x3c>
		k_free(msgq->buffer_start);
  40e78c:	f9401660 	ldr	x0, [x19, #40]
  40e790:	94001334 	bl	413460 <k_free>
		msgq->flags &= ~K_MSGQ_FLAG_ALLOC;
  40e794:	39418260 	ldrb	w0, [x19, #96]
  40e798:	121f7800 	and	w0, w0, #0xfffffffe
  40e79c:	39018260 	strb	w0, [x19, #96]
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, 0);

	return 0;
  40e7a0:	52800000 	mov	w0, #0x0                   	// #0
  40e7a4:	14000002 	b	40e7ac <k_msgq_cleanup+0x48>
		return -EBUSY;
  40e7a8:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
  40e7ac:	f9400bf3 	ldr	x19, [sp, #16]
  40e7b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e7b4:	d65f03c0 	ret

000000000040e7b8 <z_impl_k_msgq_put>:


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
  40e7b8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40e7bc:	910003fd 	mov	x29, sp
  40e7c0:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e7c4:	aa0203f5 	mov	x21, x2
  40e7c8:	b00000e2 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  40e7cc:	a90153f3 	stp	x19, x20, [sp, #16]
  40e7d0:	aa0003f3 	mov	x19, x0
  40e7d4:	f9472c40 	ldr	x0, [x2, #3672]
  40e7d8:	a90363f7 	stp	x23, x24, [sp, #48]
  40e7dc:	aa0103f7 	mov	x23, x1
  40e7e0:	aa0203f8 	mov	x24, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40e7e4:	b9400000 	ldr	w0, [x0]
  40e7e8:	340002c0 	cbz	w0, 40e840 <z_impl_k_msgq_put+0x88>
  40e7ec:	b40002b5 	cbz	x21, 40e840 <z_impl_k_msgq_put+0x88>
  40e7f0:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40e7f4:	910b4673 	add	x19, x19, #0x2d1
  40e7f8:	aa1303e2 	mov	x2, x19
  40e7fc:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40e800:	91032021 	add	x1, x1, #0xc8
  40e804:	52800ec3 	mov	w3, #0x76                  	// #118
  40e808:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e80c:	911e2800 	add	x0, x0, #0x78a
  40e810:	97ffe4e0 	bl	407b90 <assert_print>
  40e814:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40e818:	9135a400 	add	x0, x0, #0xd69
  40e81c:	97ffe4dd 	bl	407b90 <assert_print>
  40e820:	aa1303e0 	mov	x0, x19
  40e824:	52800ec1 	mov	w1, #0x76                  	// #118
  40e828:	97ffe504 	bl	407c38 <assert_post_action>
  40e82c:	52800ec2 	mov	w2, #0x76                  	// #118
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40e830:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e834:	aa1303e1 	mov	x1, x19
  40e838:	911f2000 	add	x0, x0, #0x7c8
  40e83c:	97ffeef1 	bl	40a400 <posix_print_error_and_exit>
  40e840:	97ffedda 	bl	409fa8 <posix_irq_lock>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
  40e844:	91004274 	add	x20, x19, #0x10
  40e848:	2a0003f6 	mov	w22, w0
  40e84c:	aa1403e0 	mov	x0, x20
  40e850:	97ffff7d 	bl	40e644 <z_spin_lock_valid>
  40e854:	72001c1f 	tst	w0, #0xff
  40e858:	54000261 	b.ne	40e8a4 <z_impl_k_msgq_put+0xec>  // b.any
  40e85c:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40e860:	91334a73 	add	x19, x19, #0xcd2
  40e864:	aa1303e2 	mov	x2, x19
  40e868:	52801283 	mov	w3, #0x94                  	// #148
  40e86c:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40e870:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e874:	9133fc21 	add	x1, x1, #0xcff
  40e878:	911e2800 	add	x0, x0, #0x78a
  40e87c:	97ffe4c5 	bl	407b90 <assert_print>
  40e880:	aa1403e1 	mov	x1, x20
  40e884:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40e888:	91345000 	add	x0, x0, #0xd14
  40e88c:	97ffe4c1 	bl	407b90 <assert_print>
  40e890:	aa1303e0 	mov	x0, x19
  40e894:	52801281 	mov	w1, #0x94                  	// #148
  40e898:	97ffe4e8 	bl	407c38 <assert_post_action>
  40e89c:	52801282 	mov	w2, #0x94                  	// #148
  40e8a0:	17ffffe4 	b	40e830 <z_impl_k_msgq_put+0x78>
	z_spin_lock_set_owner(l);
  40e8a4:	aa1403e0 	mov	x0, x20
  40e8a8:	97ffff7f 	bl	40e6a4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
  40e8ac:	b9402260 	ldr	w0, [x19, #32]
  40e8b0:	b9404a61 	ldr	w1, [x19, #72]
  40e8b4:	6b00003f 	cmp	w1, w0
  40e8b8:	54000a82 	b.cs	40ea08 <z_impl_k_msgq_put+0x250>  // b.hs, b.nlast
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  40e8bc:	aa1303e0 	mov	x0, x19
  40e8c0:	94000cb2 	bl	411b88 <z_unpend_first_thread>
  40e8c4:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  40e8c8:	b4000240 	cbz	x0, 40e910 <z_impl_k_msgq_put+0x158>
  return __builtin___memcpy_chk (__dest, __src, __len,
  40e8cc:	f9400e62 	ldr	x2, [x19, #24]
  40e8d0:	aa1703e1 	mov	x1, x23
  40e8d4:	f9401000 	ldr	x0, [x0, #32]
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
  40e8d8:	52800013 	mov	w19, #0x0                   	// #0
  40e8dc:	97ffca25 	bl	401170 <memcpy@plt>
	thread->callee_saved.retval = value;
  40e8e0:	b9004ebf 	str	wzr, [x21, #76]
			z_ready_thread(pending_thread);
  40e8e4:	aa1503e0 	mov	x0, x21
  40e8e8:	94000957 	bl	410e44 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  40e8ec:	2a1603e1 	mov	w1, w22
  40e8f0:	aa1403e0 	mov	x0, x20
  40e8f4:	940006f9 	bl	4104d8 <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  40e8f8:	2a1303e0 	mov	w0, w19
  40e8fc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e900:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e904:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e908:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40e90c:	d65f03c0 	ret
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  40e910:	f9401661 	ldr	x1, [x19, #40]
  40e914:	f9402260 	ldr	x0, [x19, #64]
  40e918:	eb01001f 	cmp	x0, x1
  40e91c:	54000083 	b.cc	40e92c <z_impl_k_msgq_put+0x174>  // b.lo, b.ul, b.last
  40e920:	f9401a61 	ldr	x1, [x19, #48]
  40e924:	eb01001f 	cmp	x0, x1
  40e928:	540001e3 	b.cc	40e964 <z_impl_k_msgq_put+0x1ac>  // b.lo, b.ul, b.last
  40e92c:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40e930:	910b4673 	add	x19, x19, #0x2d1
  40e934:	aa1303e2 	mov	x2, x19
  40e938:	52801203 	mov	w3, #0x90                  	// #144
  40e93c:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40e940:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e944:	910bcc21 	add	x1, x1, #0x2f3
  40e948:	911e2800 	add	x0, x0, #0x78a
  40e94c:	97ffe491 	bl	407b90 <assert_print>
  40e950:	aa1303e0 	mov	x0, x19
  40e954:	52801201 	mov	w1, #0x90                  	// #144
  40e958:	97ffe4b8 	bl	407c38 <assert_post_action>
  40e95c:	52801202 	mov	w2, #0x90                  	// #144
  40e960:	17ffffb4 	b	40e830 <z_impl_k_msgq_put+0x78>
  40e964:	f9400e62 	ldr	x2, [x19, #24]
  40e968:	aa1703e1 	mov	x1, x23
  40e96c:	97ffca01 	bl	401170 <memcpy@plt>
			msgq->write_ptr += msgq->msg_size;
  40e970:	f9400e60 	ldr	x0, [x19, #24]
  40e974:	f9402262 	ldr	x2, [x19, #64]
  40e978:	8b000042 	add	x2, x2, x0
  40e97c:	f9002262 	str	x2, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  40e980:	f9401a60 	ldr	x0, [x19, #48]
  40e984:	eb00005f 	cmp	x2, x0
  40e988:	54000061 	b.ne	40e994 <z_impl_k_msgq_put+0x1dc>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  40e98c:	f9401660 	ldr	x0, [x19, #40]
  40e990:	f9002260 	str	x0, [x19, #64]
			msgq->used_msgs++;
  40e994:	b9404a60 	ldr	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40e998:	52800201 	mov	w1, #0x10                  	// #16
			msgq->used_msgs++;
  40e99c:	11000400 	add	w0, w0, #0x1
  40e9a0:	b9004a60 	str	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40e9a4:	91014260 	add	x0, x19, #0x50
		result = 0;
  40e9a8:	52800013 	mov	w19, #0x0                   	// #0
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40e9ac:	940012a3 	bl	413438 <z_handle_obj_poll_events>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e9b0:	aa1403e0 	mov	x0, x20
  40e9b4:	97ffff2f 	bl	40e670 <z_spin_unlock_valid>
  40e9b8:	72001c1f 	tst	w0, #0xff
  40e9bc:	54000441 	b.ne	40ea44 <z_impl_k_msgq_put+0x28c>  // b.any
  40e9c0:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40e9c4:	91334a73 	add	x19, x19, #0xcd2
  40e9c8:	aa1303e2 	mov	x2, x19
  40e9cc:	52801863 	mov	w3, #0xc3                  	// #195
  40e9d0:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40e9d4:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40e9d8:	9134b021 	add	x1, x1, #0xd2c
  40e9dc:	911e2800 	add	x0, x0, #0x78a
  40e9e0:	97ffe46c 	bl	407b90 <assert_print>
  40e9e4:	aa1403e1 	mov	x1, x20
  40e9e8:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40e9ec:	91350c00 	add	x0, x0, #0xd43
  40e9f0:	97ffe468 	bl	407b90 <assert_print>
  40e9f4:	aa1303e0 	mov	x0, x19
  40e9f8:	52801861 	mov	w1, #0xc3                  	// #195
  40e9fc:	97ffe48f 	bl	407c38 <assert_post_action>
  40ea00:	52801862 	mov	w2, #0xc3                  	// #195
  40ea04:	17ffff8b 	b	40e830 <z_impl_k_msgq_put+0x78>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40ea08:	b40001b5 	cbz	x21, 40ea3c <z_impl_k_msgq_put+0x284>
		_current->base.swap_data = (void *) data;
  40ea0c:	f9472f02 	ldr	x2, [x24, #3672]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ea10:	aa1503e3 	mov	x3, x21
  40ea14:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = (void *) data;
  40ea18:	f9400840 	ldr	x0, [x2, #16]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ea1c:	aa1303e2 	mov	x2, x19
		_current->base.swap_data = (void *) data;
  40ea20:	f9001017 	str	x23, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ea24:	aa1403e0 	mov	x0, x20
}
  40ea28:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ea2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ea30:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ea34:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ea38:	14000a4c 	b	411368 <z_pend_curr>
		result = -ENOMSG;
  40ea3c:	12800533 	mov	w19, #0xffffffd6            	// #-42
  40ea40:	17ffffdc 	b	40e9b0 <z_impl_k_msgq_put+0x1f8>
	posix_irq_unlock(key);
  40ea44:	2a1603e0 	mov	w0, w22
  40ea48:	97ffed5a 	bl	409fb0 <posix_irq_unlock>
	return result;
  40ea4c:	17ffffab 	b	40e8f8 <z_impl_k_msgq_put+0x140>

000000000040ea50 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
  40ea50:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	return _kernel.cpus[0].nested != 0U;
  40ea54:	b00000e4 	adrp	x4, 42b000 <__FRAME_END__+0xff4c>
  40ea58:	910003fd 	mov	x29, sp
  40ea5c:	a90153f3 	stp	x19, x20, [sp, #16]
  40ea60:	aa0003f3 	mov	x19, x0
  40ea64:	f9472c80 	ldr	x0, [x4, #3672]
  40ea68:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ea6c:	aa0403f5 	mov	x21, x4
  40ea70:	a90363f7 	stp	x23, x24, [sp, #48]
  40ea74:	aa0103f8 	mov	x24, x1
  40ea78:	aa0203f7 	mov	x23, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40ea7c:	b9400000 	ldr	w0, [x0]
  40ea80:	340002c0 	cbz	w0, 40ead8 <z_impl_k_msgq_get+0x88>
  40ea84:	b40002a2 	cbz	x2, 40ead8 <z_impl_k_msgq_get+0x88>
  40ea88:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40ea8c:	910b4673 	add	x19, x19, #0x2d1
  40ea90:	aa1303e2 	mov	x2, x19
  40ea94:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40ea98:	91032021 	add	x1, x1, #0xc8
  40ea9c:	52801a43 	mov	w3, #0xd2                  	// #210
  40eaa0:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40eaa4:	911e2800 	add	x0, x0, #0x78a
  40eaa8:	97ffe43a 	bl	407b90 <assert_print>
  40eaac:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40eab0:	9135a400 	add	x0, x0, #0xd69
  40eab4:	97ffe437 	bl	407b90 <assert_print>
  40eab8:	aa1303e0 	mov	x0, x19
  40eabc:	52801a41 	mov	w1, #0xd2                  	// #210
  40eac0:	97ffe45e 	bl	407c38 <assert_post_action>
  40eac4:	52801a42 	mov	w2, #0xd2                  	// #210
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40eac8:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40eacc:	aa1303e1 	mov	x1, x19
  40ead0:	911f2000 	add	x0, x0, #0x7c8
  40ead4:	97ffee4b 	bl	40a400 <posix_print_error_and_exit>
	return posix_irq_lock();
  40ead8:	97ffed34 	bl	409fa8 <posix_irq_lock>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
  40eadc:	91004274 	add	x20, x19, #0x10
  40eae0:	2a0003f6 	mov	w22, w0
  40eae4:	aa1403e0 	mov	x0, x20
  40eae8:	97fffed7 	bl	40e644 <z_spin_lock_valid>
  40eaec:	72001c1f 	tst	w0, #0xff
  40eaf0:	54000261 	b.ne	40eb3c <z_impl_k_msgq_get+0xec>  // b.any
  40eaf4:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40eaf8:	91334a73 	add	x19, x19, #0xcd2
  40eafc:	aa1303e2 	mov	x2, x19
  40eb00:	52801283 	mov	w3, #0x94                  	// #148
  40eb04:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40eb08:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40eb0c:	9133fc21 	add	x1, x1, #0xcff
  40eb10:	911e2800 	add	x0, x0, #0x78a
  40eb14:	97ffe41f 	bl	407b90 <assert_print>
  40eb18:	aa1403e1 	mov	x1, x20
  40eb1c:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40eb20:	91345000 	add	x0, x0, #0xd14
  40eb24:	97ffe41b 	bl	407b90 <assert_print>
  40eb28:	aa1303e0 	mov	x0, x19
  40eb2c:	52801281 	mov	w1, #0x94                  	// #148
  40eb30:	97ffe442 	bl	407c38 <assert_post_action>
  40eb34:	52801282 	mov	w2, #0x94                  	// #148
  40eb38:	17ffffe4 	b	40eac8 <z_impl_k_msgq_get+0x78>
	z_spin_lock_set_owner(l);
  40eb3c:	aa1403e0 	mov	x0, x20
  40eb40:	97fffed9 	bl	40e6a4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
  40eb44:	b9404a60 	ldr	w0, [x19, #72]
  40eb48:	340008c0 	cbz	w0, 40ec60 <z_impl_k_msgq_get+0x210>
  40eb4c:	f9400e62 	ldr	x2, [x19, #24]
  40eb50:	aa1803e0 	mov	x0, x24
  40eb54:	f9401e61 	ldr	x1, [x19, #56]
  40eb58:	97ffc986 	bl	401170 <memcpy@plt>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
  40eb5c:	f9400e61 	ldr	x1, [x19, #24]
  40eb60:	f9401e60 	ldr	x0, [x19, #56]
  40eb64:	8b010000 	add	x0, x0, x1
  40eb68:	f9001e60 	str	x0, [x19, #56]
		if (msgq->read_ptr == msgq->buffer_end) {
  40eb6c:	f9401a61 	ldr	x1, [x19, #48]
  40eb70:	eb01001f 	cmp	x0, x1
  40eb74:	54000061 	b.ne	40eb80 <z_impl_k_msgq_get+0x130>  // b.any
			msgq->read_ptr = msgq->buffer_start;
  40eb78:	f9401660 	ldr	x0, [x19, #40]
  40eb7c:	f9001e60 	str	x0, [x19, #56]
		}
		msgq->used_msgs--;
  40eb80:	b9404a60 	ldr	w0, [x19, #72]
  40eb84:	51000400 	sub	w0, w0, #0x1
  40eb88:	b9004a60 	str	w0, [x19, #72]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  40eb8c:	aa1303e0 	mov	x0, x19
  40eb90:	94000bfe 	bl	411b88 <z_unpend_first_thread>
  40eb94:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  40eb98:	b40007e0 	cbz	x0, 40ec94 <z_impl_k_msgq_get+0x244>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  40eb9c:	f9401661 	ldr	x1, [x19, #40]
  40eba0:	f9402260 	ldr	x0, [x19, #64]
  40eba4:	eb01001f 	cmp	x0, x1
  40eba8:	54000083 	b.cc	40ebb8 <z_impl_k_msgq_get+0x168>  // b.lo, b.ul, b.last
  40ebac:	f9401a61 	ldr	x1, [x19, #48]
  40ebb0:	eb01001f 	cmp	x0, x1
  40ebb4:	540001e3 	b.cc	40ebf0 <z_impl_k_msgq_get+0x1a0>  // b.lo, b.ul, b.last
  40ebb8:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40ebbc:	910b4673 	add	x19, x19, #0x2d1
  40ebc0:	aa1303e2 	mov	x2, x19
  40ebc4:	52801d63 	mov	w3, #0xeb                  	// #235
  40ebc8:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40ebcc:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ebd0:	910bcc21 	add	x1, x1, #0x2f3
  40ebd4:	911e2800 	add	x0, x0, #0x78a
  40ebd8:	97ffe3ee 	bl	407b90 <assert_print>
  40ebdc:	aa1303e0 	mov	x0, x19
  40ebe0:	52801d61 	mov	w1, #0xeb                  	// #235
  40ebe4:	97ffe415 	bl	407c38 <assert_post_action>
  40ebe8:	52801d62 	mov	w2, #0xeb                  	// #235
  40ebec:	17ffffb7 	b	40eac8 <z_impl_k_msgq_get+0x78>
  40ebf0:	f9400e62 	ldr	x2, [x19, #24]
  40ebf4:	f94012a1 	ldr	x1, [x21, #32]
  40ebf8:	97ffc95e 	bl	401170 <memcpy@plt>
					msgq->write_ptr < msgq->buffer_end);
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
  40ebfc:	f9400e61 	ldr	x1, [x19, #24]
  40ec00:	f9402260 	ldr	x0, [x19, #64]
  40ec04:	8b010000 	add	x0, x0, x1
  40ec08:	f9002260 	str	x0, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  40ec0c:	f9401a61 	ldr	x1, [x19, #48]
  40ec10:	eb01001f 	cmp	x0, x1
  40ec14:	54000061 	b.ne	40ec20 <z_impl_k_msgq_get+0x1d0>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  40ec18:	f9401660 	ldr	x0, [x19, #40]
  40ec1c:	f9002260 	str	x0, [x19, #64]
			}
			msgq->used_msgs++;
  40ec20:	b9404a60 	ldr	w0, [x19, #72]
  40ec24:	11000400 	add	w0, w0, #0x1
  40ec28:	b9004a60 	str	w0, [x19, #72]
	thread->callee_saved.retval = value;
  40ec2c:	b9004ebf 	str	wzr, [x21, #76]

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
  40ec30:	aa1503e0 	mov	x0, x21
			z_reschedule(&msgq->lock, key);

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
  40ec34:	52800013 	mov	w19, #0x0                   	// #0
			z_ready_thread(pending_thread);
  40ec38:	94000883 	bl	410e44 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  40ec3c:	2a1603e1 	mov	w1, w22
  40ec40:	aa1403e0 	mov	x0, x20
  40ec44:	94000625 	bl	4104d8 <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  40ec48:	2a1303e0 	mov	w0, w19
  40ec4c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ec50:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ec54:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ec58:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40ec5c:	d65f03c0 	ret
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40ec60:	b4000497 	cbz	x23, 40ecf0 <z_impl_k_msgq_get+0x2a0>
		_current->base.swap_data = data;
  40ec64:	f9472ea4 	ldr	x4, [x21, #3672]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ec68:	aa1703e3 	mov	x3, x23
  40ec6c:	aa1303e2 	mov	x2, x19
  40ec70:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = data;
  40ec74:	f9400880 	ldr	x0, [x4, #16]
  40ec78:	f9001018 	str	x24, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ec7c:	aa1403e0 	mov	x0, x20
}
  40ec80:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ec84:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ec88:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ec8c:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ec90:	140009b6 	b	411368 <z_pend_curr>
		result = 0;
  40ec94:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40ec98:	aa1403e0 	mov	x0, x20
  40ec9c:	97fffe75 	bl	40e670 <z_spin_unlock_valid>
  40eca0:	72001c1f 	tst	w0, #0xff
  40eca4:	540002a1 	b.ne	40ecf8 <z_impl_k_msgq_get+0x2a8>  // b.any
  40eca8:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40ecac:	91334a73 	add	x19, x19, #0xcd2
  40ecb0:	aa1303e2 	mov	x2, x19
  40ecb4:	52801863 	mov	w3, #0xc3                  	// #195
  40ecb8:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40ecbc:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ecc0:	9134b021 	add	x1, x1, #0xd2c
  40ecc4:	911e2800 	add	x0, x0, #0x78a
  40ecc8:	97ffe3b2 	bl	407b90 <assert_print>
  40eccc:	aa1403e1 	mov	x1, x20
  40ecd0:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40ecd4:	91350c00 	add	x0, x0, #0xd43
  40ecd8:	97ffe3ae 	bl	407b90 <assert_print>
  40ecdc:	aa1303e0 	mov	x0, x19
  40ece0:	52801861 	mov	w1, #0xc3                  	// #195
  40ece4:	97ffe3d5 	bl	407c38 <assert_post_action>
  40ece8:	52801862 	mov	w2, #0xc3                  	// #195
  40ecec:	17ffff77 	b	40eac8 <z_impl_k_msgq_get+0x78>
		result = -ENOMSG;
  40ecf0:	12800533 	mov	w19, #0xffffffd6            	// #-42
  40ecf4:	17ffffe9 	b	40ec98 <z_impl_k_msgq_get+0x248>
	posix_irq_unlock(key);
  40ecf8:	2a1603e0 	mov	w0, w22
  40ecfc:	97ffecad 	bl	409fb0 <posix_irq_unlock>
	return result;
  40ed00:	17ffffd2 	b	40ec48 <z_impl_k_msgq_get+0x1f8>

000000000040ed04 <z_impl_k_msgq_purge>:
}
#include <syscalls/k_msgq_peek_at_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
  40ed04:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ed08:	910003fd 	mov	x29, sp
  40ed0c:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
  40ed10:	91004014 	add	x20, x0, #0x10
{
  40ed14:	aa0003f3 	mov	x19, x0
  40ed18:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40ed1c:	97ffeca3 	bl	409fa8 <posix_irq_lock>
  40ed20:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ed24:	aa1403e0 	mov	x0, x20
  40ed28:	97fffe47 	bl	40e644 <z_spin_lock_valid>
  40ed2c:	72001c1f 	tst	w0, #0xff
  40ed30:	540002c1 	b.ne	40ed88 <z_impl_k_msgq_purge+0x84>  // b.any
  40ed34:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40ed38:	91334a73 	add	x19, x19, #0xcd2
  40ed3c:	aa1303e2 	mov	x2, x19
  40ed40:	52801283 	mov	w3, #0x94                  	// #148
  40ed44:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40ed48:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ed4c:	9133fc21 	add	x1, x1, #0xcff
  40ed50:	911e2800 	add	x0, x0, #0x78a
  40ed54:	97ffe38f 	bl	407b90 <assert_print>
  40ed58:	aa1403e1 	mov	x1, x20
  40ed5c:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40ed60:	91345000 	add	x0, x0, #0xd14
  40ed64:	97ffe38b 	bl	407b90 <assert_print>
  40ed68:	aa1303e0 	mov	x0, x19
  40ed6c:	52801281 	mov	w1, #0x94                  	// #148
  40ed70:	97ffe3b2 	bl	407c38 <assert_post_action>
  40ed74:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ed78:	aa1303e1 	mov	x1, x19
  40ed7c:	911f2000 	add	x0, x0, #0x7c8
  40ed80:	52801282 	mov	w2, #0x94                  	// #148
  40ed84:	97ffed9f 	bl	40a400 <posix_print_error_and_exit>
  40ed88:	12800536 	mov	w22, #0xffffffd6            	// #-42
	z_spin_lock_set_owner(l);
  40ed8c:	aa1403e0 	mov	x0, x20
  40ed90:	97fffe45 	bl	40e6a4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
  40ed94:	aa1303e0 	mov	x0, x19
  40ed98:	94000b7c 	bl	411b88 <z_unpend_first_thread>
  40ed9c:	aa0003e2 	mov	x2, x0
  40eda0:	b5000140 	cbnz	x0, 40edc8 <z_impl_k_msgq_purge+0xc4>
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
	}

	msgq->used_msgs = 0;
	msgq->read_ptr = msgq->write_ptr;
  40eda4:	f9402260 	ldr	x0, [x19, #64]
  40eda8:	f9001e60 	str	x0, [x19, #56]
	msgq->used_msgs = 0;
  40edac:	b9004a7f 	str	wzr, [x19, #72]

	z_reschedule(&msgq->lock, key);
  40edb0:	2a1503e1 	mov	w1, w21
  40edb4:	aa1403e0 	mov	x0, x20
}
  40edb8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40edbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40edc0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&msgq->lock, key);
  40edc4:	140005c5 	b	4104d8 <z_reschedule>
  40edc8:	b9004c56 	str	w22, [x2, #76]
		z_ready_thread(pending_thread);
  40edcc:	9400081e 	bl	410e44 <z_ready_thread>
  40edd0:	17fffff1 	b	40ed94 <z_impl_k_msgq_purge+0x90>

000000000040edd4 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
  40edd4:	39c06802 	ldrsb	w2, [x0, #26]
  40edd8:	6b01005f 	cmp	w2, w1
  40eddc:	54000040 	b.eq	40ede4 <adjust_owner_prio.isra.0+0x10>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
  40ede0:	140009d2 	b	411528 <z_set_prio>
	}
	return false;
}
  40ede4:	52800000 	mov	w0, #0x0                   	// #0
  40ede8:	d65f03c0 	ret

000000000040edec <z_impl_k_mutex_init>:
	list->tail = (sys_dnode_t *)list;
  40edec:	a9000000 	stp	x0, x0, [x0]
	mutex->owner = NULL;
  40edf0:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
  40edf4:	b900181f 	str	wzr, [x0, #24]
}
  40edf8:	52800000 	mov	w0, #0x0                   	// #0
  40edfc:	d65f03c0 	ret

000000000040ee00 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
  40ee00:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ee04:	910003fd 	mov	x29, sp
  40ee08:	a9025bf5 	stp	x21, x22, [sp, #32]
	return _kernel.cpus[0].nested != 0U;
  40ee0c:	b00000f5 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
  40ee10:	f90023f9 	str	x25, [sp, #64]
  40ee14:	f9472eb9 	ldr	x25, [x21, #3672]
  40ee18:	a90153f3 	stp	x19, x20, [sp, #16]
  40ee1c:	aa0003f3 	mov	x19, x0
  40ee20:	a90363f7 	stp	x23, x24, [sp, #48]
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  40ee24:	b9400320 	ldr	w0, [x25]
  40ee28:	340002a0 	cbz	w0, 40ee7c <z_impl_k_mutex_lock+0x7c>
  40ee2c:	90000053 	adrp	x19, 416000 <__func__.0+0xb3f>
  40ee30:	910cfe73 	add	x19, x19, #0x33f
  40ee34:	aa1303e2 	mov	x2, x19
  40ee38:	90000041 	adrp	x1, 416000 <__func__.0+0xb3f>
  40ee3c:	91089021 	add	x1, x1, #0x224
  40ee40:	52800ca3 	mov	w3, #0x65                  	// #101
  40ee44:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ee48:	911e2800 	add	x0, x0, #0x78a
  40ee4c:	97ffe351 	bl	407b90 <assert_print>
  40ee50:	90000040 	adrp	x0, 416000 <__func__.0+0xb3f>
  40ee54:	910d8400 	add	x0, x0, #0x361
  40ee58:	97ffe34e 	bl	407b90 <assert_print>
  40ee5c:	aa1303e0 	mov	x0, x19
  40ee60:	52800ca1 	mov	w1, #0x65                  	// #101
  40ee64:	97ffe375 	bl	407c38 <assert_post_action>
  40ee68:	52800ca2 	mov	w2, #0x65                  	// #101
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ee6c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ee70:	aa1303e1 	mov	x1, x19
  40ee74:	911f2000 	add	x0, x0, #0x7c8
  40ee78:	97ffed62 	bl	40a400 <posix_print_error_and_exit>
  40ee7c:	aa0103f8 	mov	x24, x1
  40ee80:	f00000f4 	adrp	x20, 42d000 <args_struct>
  40ee84:	97ffec49 	bl	409fa8 <posix_irq_lock>
  40ee88:	91252297 	add	x23, x20, #0x948
  40ee8c:	2a0003f6 	mov	w22, w0
  40ee90:	aa1703e0 	mov	x0, x23
  40ee94:	97fffdec 	bl	40e644 <z_spin_lock_valid>
  40ee98:	72001c1f 	tst	w0, #0xff
  40ee9c:	54000261 	b.ne	40eee8 <z_impl_k_mutex_lock+0xe8>  // b.any
  40eea0:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40eea4:	91334a73 	add	x19, x19, #0xcd2
  40eea8:	aa1303e2 	mov	x2, x19
  40eeac:	52801283 	mov	w3, #0x94                  	// #148
  40eeb0:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40eeb4:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40eeb8:	9133fc21 	add	x1, x1, #0xcff
  40eebc:	911e2800 	add	x0, x0, #0x78a
  40eec0:	97ffe334 	bl	407b90 <assert_print>
  40eec4:	91252281 	add	x1, x20, #0x948
  40eec8:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40eecc:	91345000 	add	x0, x0, #0xd14
  40eed0:	97ffe330 	bl	407b90 <assert_print>
  40eed4:	aa1303e0 	mov	x0, x19
  40eed8:	52801281 	mov	w1, #0x94                  	// #148
  40eedc:	97ffe357 	bl	407c38 <assert_post_action>
  40eee0:	52801282 	mov	w2, #0x94                  	// #148
  40eee4:	17ffffe2 	b	40ee6c <z_impl_k_mutex_lock+0x6c>
	z_spin_lock_set_owner(l);
  40eee8:	aa1703e0 	mov	x0, x23
  40eeec:	97fffdee 	bl	40e6a4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  40eef0:	b9401a61 	ldr	w1, [x19, #24]
  40eef4:	340001c1 	cbz	w1, 40ef2c <z_impl_k_mutex_lock+0x12c>
  40eef8:	f9400a60 	ldr	x0, [x19, #16]
  40eefc:	f9400b22 	ldr	x2, [x25, #16]
  40ef00:	eb02001f 	cmp	x0, x2
  40ef04:	540004e0 	b.eq	40efa0 <z_impl_k_mutex_lock+0x1a0>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
  40ef08:	b5000638 	cbnz	x24, 40efcc <z_impl_k_mutex_lock+0x1cc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40ef0c:	aa1703e0 	mov	x0, x23
  40ef10:	97fffdd8 	bl	40e670 <z_spin_unlock_valid>
  40ef14:	72001c1f 	tst	w0, #0xff
  40ef18:	54000200 	b.eq	40ef58 <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  40ef1c:	2a1603e0 	mov	w0, w22
  40ef20:	97ffec24 	bl	409fb0 <posix_irq_unlock>
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
  40ef24:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40ef28:	14000023 	b	40efb4 <z_impl_k_mutex_lock+0x1b4>
					_current->base.prio :
  40ef2c:	f9400b20 	ldr	x0, [x25, #16]
  40ef30:	39c06800 	ldrsb	w0, [x0, #26]
		mutex->owner = _current;
  40ef34:	f9472eb5 	ldr	x21, [x21, #3672]
		mutex->lock_count++;
  40ef38:	11000421 	add	w1, w1, #0x1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  40ef3c:	29030261 	stp	w1, w0, [x19, #24]
		mutex->owner = _current;
  40ef40:	f9400aa0 	ldr	x0, [x21, #16]
  40ef44:	f9000a60 	str	x0, [x19, #16]
  40ef48:	91252280 	add	x0, x20, #0x948
  40ef4c:	97fffdc9 	bl	40e670 <z_spin_unlock_valid>
  40ef50:	72001c1f 	tst	w0, #0xff
  40ef54:	540002a1 	b.ne	40efa8 <z_impl_k_mutex_lock+0x1a8>  // b.any
  40ef58:	f0000033 	adrp	x19, 415000 <random_data+0xca4>
  40ef5c:	91334a73 	add	x19, x19, #0xcd2
  40ef60:	aa1303e2 	mov	x2, x19
  40ef64:	52801863 	mov	w3, #0xc3                  	// #195
  40ef68:	f0000021 	adrp	x1, 415000 <random_data+0xca4>
  40ef6c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ef70:	9134b021 	add	x1, x1, #0xd2c
  40ef74:	911e2800 	add	x0, x0, #0x78a
  40ef78:	97ffe306 	bl	407b90 <assert_print>
  40ef7c:	91252281 	add	x1, x20, #0x948
  40ef80:	f0000020 	adrp	x0, 415000 <random_data+0xca4>
  40ef84:	91350c00 	add	x0, x0, #0xd43
  40ef88:	97ffe302 	bl	407b90 <assert_print>
  40ef8c:	aa1303e0 	mov	x0, x19
  40ef90:	52801861 	mov	w1, #0xc3                  	// #195
  40ef94:	97ffe329 	bl	407c38 <assert_post_action>
  40ef98:	52801862 	mov	w2, #0xc3                  	// #195
  40ef9c:	17ffffb4 	b	40ee6c <z_impl_k_mutex_lock+0x6c>
					_current->base.prio :
  40efa0:	b9401e60 	ldr	w0, [x19, #28]
  40efa4:	17ffffe4 	b	40ef34 <z_impl_k_mutex_lock+0x134>
  40efa8:	2a1603e0 	mov	w0, w22
  40efac:	97ffec01 	bl	409fb0 <posix_irq_unlock>
		return 0;
  40efb0:	52800000 	mov	w0, #0x0                   	// #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
  40efb4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40efb8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40efbc:	a94363f7 	ldp	x23, x24, [sp, #48]
  40efc0:	f94023f9 	ldr	x25, [sp, #64]
  40efc4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40efc8:	d65f03c0 	ret
	new_prio = new_prio_for_inheritance(_current->base.prio,
  40efcc:	39c06842 	ldrsb	w2, [x2, #26]
  40efd0:	39c06803 	ldrsb	w3, [x0, #26]
  40efd4:	6b03005f 	cmp	w2, w3
  40efd8:	1a83d041 	csel	w1, w2, w3, le
  40efdc:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  40efe0:	3101fc3f 	cmn	w1, #0x7f
  40efe4:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  40efe8:	6b01007f 	cmp	w3, w1
  40efec:	5400050d 	b.le	40f08c <z_impl_k_mutex_lock+0x28c>
		resched = adjust_owner_prio(mutex, new_prio);
  40eff0:	97ffff79 	bl	40edd4 <adjust_owner_prio.isra.0>
  40eff4:	12001c17 	and	w23, w0, #0xff
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  40eff8:	91252299 	add	x25, x20, #0x948
  40effc:	aa1803e3 	mov	x3, x24
  40f000:	aa1303e2 	mov	x2, x19
  40f004:	2a1603e1 	mov	w1, w22
  40f008:	aa1903e0 	mov	x0, x25
  40f00c:	940008d7 	bl	411368 <z_pend_curr>
	if (got_mutex == 0) {
  40f010:	34fffd20 	cbz	w0, 40efb4 <z_impl_k_mutex_lock+0x1b4>
	return posix_irq_lock();
  40f014:	97ffebe5 	bl	409fa8 <posix_irq_lock>
  40f018:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f01c:	aa1903e0 	mov	x0, x25
  40f020:	97fffd89 	bl	40e644 <z_spin_lock_valid>
  40f024:	72001c1f 	tst	w0, #0xff
  40f028:	54fff3c0 	b.eq	40eea0 <z_impl_k_mutex_lock+0xa0>  // b.none
	z_spin_lock_set_owner(l);
  40f02c:	aa1903e0 	mov	x0, x25
  40f030:	97fffd9d 	bl	40e6a4 <z_spin_lock_set_owner>
	if (likely(mutex->owner != NULL)) {
  40f034:	f9400a60 	ldr	x0, [x19, #16]
  40f038:	b40001e0 	cbz	x0, 40f074 <z_impl_k_mutex_lock+0x274>
	return list->head == list;
  40f03c:	f9400262 	ldr	x2, [x19]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  40f040:	b9401e61 	ldr	w1, [x19, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40f044:	eb02027f 	cmp	x19, x2
  40f048:	54000100 	b.eq	40f068 <z_impl_k_mutex_lock+0x268>  // b.none
  40f04c:	b40000e2 	cbz	x2, 40f068 <z_impl_k_mutex_lock+0x268>
  40f050:	39c06842 	ldrsb	w2, [x2, #26]
  40f054:	6b02003f 	cmp	w1, w2
  40f058:	1a82d021 	csel	w1, w1, w2, le
  40f05c:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  40f060:	3101fc3f 	cmn	w1, #0x7f
  40f064:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
		resched = adjust_owner_prio(mutex, new_prio) || resched;
  40f068:	97ffff5b 	bl	40edd4 <adjust_owner_prio.isra.0>
  40f06c:	72001c1f 	tst	w0, #0xff
  40f070:	54000041 	b.ne	40f078 <z_impl_k_mutex_lock+0x278>  // b.any
	if (resched) {
  40f074:	34000117 	cbz	w23, 40f094 <z_impl_k_mutex_lock+0x294>
		z_reschedule(&lock, key);
  40f078:	2a1503e1 	mov	w1, w21
  40f07c:	91252280 	add	x0, x20, #0x948
  40f080:	94000516 	bl	4104d8 <z_reschedule>
	return -EAGAIN;
  40f084:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40f088:	17ffffcb 	b	40efb4 <z_impl_k_mutex_lock+0x1b4>
	bool resched = false;
  40f08c:	52800017 	mov	w23, #0x0                   	// #0
  40f090:	17ffffda 	b	40eff8 <z_impl_k_mutex_lock+0x1f8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f094:	91252280 	add	x0, x20, #0x948
  40f098:	97fffd76 	bl	40e670 <z_spin_unlock_valid>
  40f09c:	72001c1f 	tst	w0, #0xff
  40f0a0:	54fff5c0 	b.eq	40ef58 <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  40f0a4:	2a1503e0 	mov	w0, w21
  40f0a8:	97ffebc2 	bl	409fb0 <posix_irq_unlock>
  40f0ac:	17fffff6 	b	40f084 <z_impl_k_mutex_lock+0x284>

000000000040f0b0 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  40f0b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40f0b4:	910003fd 	mov	x29, sp
  40f0b8:	a90153f3 	stp	x19, x20, [sp, #16]
  40f0bc:	aa0003f3 	mov	x19, x0
  40f0c0:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40f0c4:	f90013f5 	str	x21, [sp, #32]
  40f0c8:	f9472c00 	ldr	x0, [x0, #3672]
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  40f0cc:	b9400001 	ldr	w1, [x0]
  40f0d0:	340002a1 	cbz	w1, 40f124 <z_impl_k_mutex_unlock+0x74>
  40f0d4:	f0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  40f0d8:	910cfe73 	add	x19, x19, #0x33f
  40f0dc:	aa1303e2 	mov	x2, x19
  40f0e0:	f0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  40f0e4:	91089021 	add	x1, x1, #0x224
  40f0e8:	528019a3 	mov	w3, #0xcd                  	// #205
  40f0ec:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f0f0:	911e2800 	add	x0, x0, #0x78a
  40f0f4:	97ffe2a7 	bl	407b90 <assert_print>
  40f0f8:	f0000020 	adrp	x0, 416000 <__func__.0+0xb3f>
  40f0fc:	910d8400 	add	x0, x0, #0x361
  40f100:	97ffe2a4 	bl	407b90 <assert_print>
  40f104:	aa1303e0 	mov	x0, x19
  40f108:	528019a1 	mov	w1, #0xcd                  	// #205
  40f10c:	97ffe2cb 	bl	407c38 <assert_post_action>
  40f110:	528019a2 	mov	w2, #0xcd                  	// #205
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  40f114:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f118:	aa1303e1 	mov	x1, x19
  40f11c:	911f2000 	add	x0, x0, #0x7c8
  40f120:	97ffecb8 	bl	40a400 <posix_print_error_and_exit>
	CHECKIF(mutex->owner == NULL) {
  40f124:	f9400a61 	ldr	x1, [x19, #16]
  40f128:	b4000c41 	cbz	x1, 40f2b0 <z_impl_k_mutex_unlock+0x200>
	CHECKIF(mutex->owner != _current) {
  40f12c:	f9400800 	ldr	x0, [x0, #16]
  40f130:	eb00003f 	cmp	x1, x0
  40f134:	54000c21 	b.ne	40f2b8 <z_impl_k_mutex_unlock+0x208>  // b.any
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  40f138:	b9401a60 	ldr	w0, [x19, #24]
  40f13c:	350001e0 	cbnz	w0, 40f178 <z_impl_k_mutex_unlock+0xc8>
  40f140:	f0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  40f144:	910cfe73 	add	x19, x19, #0x33f
  40f148:	aa1303e2 	mov	x2, x19
  40f14c:	52801ca3 	mov	w3, #0xe5                  	// #229
  40f150:	f0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  40f154:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f158:	910e1821 	add	x1, x1, #0x386
  40f15c:	911e2800 	add	x0, x0, #0x78a
  40f160:	97ffe28c 	bl	407b90 <assert_print>
  40f164:	aa1303e0 	mov	x0, x19
  40f168:	52801ca1 	mov	w1, #0xe5                  	// #229
  40f16c:	97ffe2b3 	bl	407c38 <assert_post_action>
  40f170:	52801ca2 	mov	w2, #0xe5                  	// #229
  40f174:	17ffffe8 	b	40f114 <z_impl_k_mutex_unlock+0x64>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
  40f178:	7100041f 	cmp	w0, #0x1
  40f17c:	54000100 	b.eq	40f19c <z_impl_k_mutex_unlock+0xec>  // b.none
		mutex->lock_count--;
  40f180:	51000400 	sub	w0, w0, #0x1
  40f184:	b9001a60 	str	w0, [x19, #24]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
  40f188:	52800000 	mov	w0, #0x0                   	// #0
}
  40f18c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f190:	f94013f5 	ldr	x21, [sp, #32]
  40f194:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40f198:	d65f03c0 	ret
	return posix_irq_lock();
  40f19c:	97ffeb83 	bl	409fa8 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f1a0:	d00000f4 	adrp	x20, 42d000 <args_struct>
  40f1a4:	91252294 	add	x20, x20, #0x948
  40f1a8:	2a0003f5 	mov	w21, w0
  40f1ac:	aa1403e0 	mov	x0, x20
  40f1b0:	97fffd25 	bl	40e644 <z_spin_lock_valid>
  40f1b4:	72001c1f 	tst	w0, #0xff
  40f1b8:	54000261 	b.ne	40f204 <z_impl_k_mutex_unlock+0x154>  // b.any
  40f1bc:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f1c0:	91334a73 	add	x19, x19, #0xcd2
  40f1c4:	aa1303e2 	mov	x2, x19
  40f1c8:	52801283 	mov	w3, #0x94                  	// #148
  40f1cc:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f1d0:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f1d4:	9133fc21 	add	x1, x1, #0xcff
  40f1d8:	911e2800 	add	x0, x0, #0x78a
  40f1dc:	97ffe26d 	bl	407b90 <assert_print>
  40f1e0:	aa1403e1 	mov	x1, x20
  40f1e4:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f1e8:	91345000 	add	x0, x0, #0xd14
  40f1ec:	97ffe269 	bl	407b90 <assert_print>
  40f1f0:	aa1303e0 	mov	x0, x19
  40f1f4:	52801281 	mov	w1, #0x94                  	// #148
  40f1f8:	97ffe290 	bl	407c38 <assert_post_action>
  40f1fc:	52801282 	mov	w2, #0x94                  	// #148
  40f200:	17ffffc5 	b	40f114 <z_impl_k_mutex_unlock+0x64>
	z_spin_lock_set_owner(l);
  40f204:	aa1403e0 	mov	x0, x20
  40f208:	97fffd27 	bl	40e6a4 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  40f20c:	b9401e61 	ldr	w1, [x19, #28]
  40f210:	f9400a60 	ldr	x0, [x19, #16]
  40f214:	97fffef0 	bl	40edd4 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  40f218:	aa1303e0 	mov	x0, x19
  40f21c:	94000a5b 	bl	411b88 <z_unpend_first_thread>
	mutex->owner = new_owner;
  40f220:	f9000a60 	str	x0, [x19, #16]
	if (new_owner != NULL) {
  40f224:	b4000120 	cbz	x0, 40f248 <z_impl_k_mutex_unlock+0x198>
		mutex->owner_orig_prio = new_owner->base.prio;
  40f228:	39c06801 	ldrsb	w1, [x0, #26]
  40f22c:	b9001e61 	str	w1, [x19, #28]
	thread->callee_saved.retval = value;
  40f230:	b9004c1f 	str	wzr, [x0, #76]
		z_ready_thread(new_owner);
  40f234:	94000704 	bl	410e44 <z_ready_thread>
		z_reschedule(&lock, key);
  40f238:	2a1503e1 	mov	w1, w21
  40f23c:	aa1403e0 	mov	x0, x20
  40f240:	940004a6 	bl	4104d8 <z_reschedule>
  40f244:	17ffffd1 	b	40f188 <z_impl_k_mutex_unlock+0xd8>
		mutex->lock_count = 0U;
  40f248:	b9001a7f 	str	wzr, [x19, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f24c:	aa1403e0 	mov	x0, x20
  40f250:	97fffd08 	bl	40e670 <z_spin_unlock_valid>
  40f254:	72001c1f 	tst	w0, #0xff
  40f258:	54000261 	b.ne	40f2a4 <z_impl_k_mutex_unlock+0x1f4>  // b.any
  40f25c:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f260:	91334a73 	add	x19, x19, #0xcd2
  40f264:	aa1303e2 	mov	x2, x19
  40f268:	52801863 	mov	w3, #0xc3                  	// #195
  40f26c:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f270:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f274:	9134b021 	add	x1, x1, #0xd2c
  40f278:	911e2800 	add	x0, x0, #0x78a
  40f27c:	97ffe245 	bl	407b90 <assert_print>
  40f280:	aa1403e1 	mov	x1, x20
  40f284:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f288:	91350c00 	add	x0, x0, #0xd43
  40f28c:	97ffe241 	bl	407b90 <assert_print>
  40f290:	aa1303e0 	mov	x0, x19
  40f294:	52801861 	mov	w1, #0xc3                  	// #195
  40f298:	97ffe268 	bl	407c38 <assert_post_action>
  40f29c:	52801862 	mov	w2, #0xc3                  	// #195
  40f2a0:	17ffff9d 	b	40f114 <z_impl_k_mutex_unlock+0x64>
	posix_irq_unlock(key);
  40f2a4:	2a1503e0 	mov	w0, w21
  40f2a8:	97ffeb42 	bl	409fb0 <posix_irq_unlock>
  40f2ac:	17ffffb7 	b	40f188 <z_impl_k_mutex_unlock+0xd8>
		return -EINVAL;
  40f2b0:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40f2b4:	17ffffb6 	b	40f18c <z_impl_k_mutex_unlock+0xdc>
		return -EPERM;
  40f2b8:	12800000 	mov	w0, #0xffffffff            	// #-1
  40f2bc:	17ffffb4 	b	40f18c <z_impl_k_mutex_unlock+0xdc>

000000000040f2c0 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
  40f2c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40f2c4:	910003fd 	mov	x29, sp
  40f2c8:	a90153f3 	stp	x19, x20, [sp, #16]
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  40f2cc:	91004014 	add	x20, x0, #0x10
{
  40f2d0:	aa0003f3 	mov	x19, x0
  40f2d4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f2d8:	aa0103f5 	mov	x21, x1
  40f2dc:	a90363f7 	stp	x23, x24, [sp, #48]
  40f2e0:	aa0203f7 	mov	x23, x2
  40f2e4:	12001c78 	and	w24, w3, #0xff
  40f2e8:	f90023f9 	str	x25, [sp, #64]
  40f2ec:	12001c99 	and	w25, w4, #0xff
	return posix_irq_lock();
  40f2f0:	97ffeb2e 	bl	409fa8 <posix_irq_lock>
  40f2f4:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f2f8:	aa1403e0 	mov	x0, x20
  40f2fc:	97fffcd2 	bl	40e644 <z_spin_lock_valid>
  40f300:	72001c1f 	tst	w0, #0xff
  40f304:	540002c1 	b.ne	40f35c <queue_insert+0x9c>  // b.any
  40f308:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f30c:	91334a73 	add	x19, x19, #0xcd2
  40f310:	aa1303e2 	mov	x2, x19
  40f314:	52801283 	mov	w3, #0x94                  	// #148
  40f318:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f31c:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f320:	9133fc21 	add	x1, x1, #0xcff
  40f324:	911e2800 	add	x0, x0, #0x78a
  40f328:	97ffe21a 	bl	407b90 <assert_print>
  40f32c:	aa1403e1 	mov	x1, x20
  40f330:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f334:	91345000 	add	x0, x0, #0xd14
  40f338:	97ffe216 	bl	407b90 <assert_print>
  40f33c:	aa1303e0 	mov	x0, x19
  40f340:	52801281 	mov	w1, #0x94                  	// #148
  40f344:	97ffe23d 	bl	407c38 <assert_post_action>
  40f348:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f34c:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f350:	aa1303e1 	mov	x1, x19
  40f354:	911f2000 	add	x0, x0, #0x7c8
  40f358:	97ffec2a 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f35c:	aa1403e0 	mov	x0, x20
  40f360:	97fffcd1 	bl	40e6a4 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
  40f364:	34000059 	cbz	w25, 40f36c <queue_insert+0xac>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
  40f368:	f9400675 	ldr	x21, [x19, #8]
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  40f36c:	91006260 	add	x0, x19, #0x18
  40f370:	94000a06 	bl	411b88 <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
  40f374:	b4000120 	cbz	x0, 40f398 <queue_insert+0xd8>
  40f378:	f9001017 	str	x23, [x0, #32]
  40f37c:	b9004c1f 	str	wzr, [x0, #76]
	z_ready_thread(thread);
  40f380:	940006b1 	bl	410e44 <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
  40f384:	aa1403e0 	mov	x0, x20
  40f388:	2a1603e1 	mov	w1, w22
  40f38c:	94000453 	bl	4104d8 <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
  40f390:	52800000 	mov	w0, #0x0                   	// #0
  40f394:	1400001f 	b	40f410 <queue_insert+0x150>
	if (alloc) {
  40f398:	34000638 	cbz	w24, 40f45c <queue_insert+0x19c>
	return z_thread_aligned_alloc(0, size);
  40f39c:	d2800201 	mov	x1, #0x10                  	// #16
  40f3a0:	94001035 	bl	413474 <z_thread_aligned_alloc>
  40f3a4:	aa0003e3 	mov	x3, x0
		if (anode == NULL) {
  40f3a8:	b5000400 	cbnz	x0, 40f428 <queue_insert+0x168>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f3ac:	aa1403e0 	mov	x0, x20
  40f3b0:	97fffcb0 	bl	40e670 <z_spin_unlock_valid>
  40f3b4:	72001c1f 	tst	w0, #0xff
  40f3b8:	54000261 	b.ne	40f404 <queue_insert+0x144>  // b.any
  40f3bc:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f3c0:	91334a73 	add	x19, x19, #0xcd2
  40f3c4:	aa1303e2 	mov	x2, x19
  40f3c8:	52801863 	mov	w3, #0xc3                  	// #195
  40f3cc:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f3d0:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f3d4:	9134b021 	add	x1, x1, #0xd2c
  40f3d8:	911e2800 	add	x0, x0, #0x78a
  40f3dc:	97ffe1ed 	bl	407b90 <assert_print>
  40f3e0:	aa1403e1 	mov	x1, x20
  40f3e4:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f3e8:	91350c00 	add	x0, x0, #0xd43
  40f3ec:	97ffe1e9 	bl	407b90 <assert_print>
  40f3f0:	aa1303e0 	mov	x0, x19
  40f3f4:	52801861 	mov	w1, #0xc3                  	// #195
  40f3f8:	97ffe210 	bl	407c38 <assert_post_action>
  40f3fc:	52801862 	mov	w2, #0xc3                  	// #195
  40f400:	17ffffd3 	b	40f34c <queue_insert+0x8c>
	posix_irq_unlock(key);
  40f404:	2a1603e0 	mov	w0, w22
  40f408:	97ffeaea 	bl	409fb0 <posix_irq_unlock>
			return -ENOMEM;
  40f40c:	12800160 	mov	w0, #0xfffffff4            	// #-12
}
  40f410:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f414:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f418:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f41c:	f94023f9 	ldr	x25, [sp, #64]
  40f420:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40f424:	d65f03c0 	ret
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
  40f428:	d2800020 	mov	x0, #0x1                   	// #1
		anode->data = data;
  40f42c:	a9005c60 	stp	x0, x23, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f430:	f9400060 	ldr	x0, [x3]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f434:	92400400 	and	x0, x0, #0x3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
  40f438:	b5000195 	cbnz	x21, 40f468 <queue_insert+0x1a8>
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f43c:	f9400261 	ldr	x1, [x19]
  40f440:	aa000020 	orr	x0, x1, x0
  40f444:	f9000060 	str	x0, [x3]
	list->head = node;
  40f448:	f9000263 	str	x3, [x19]
Z_GENLIST_PREPEND(sflist, sfnode)
  40f44c:	f9400660 	ldr	x0, [x19, #8]
  40f450:	b50001a0 	cbnz	x0, 40f484 <queue_insert+0x1c4>
	list->tail = node;
  40f454:	f9000663 	str	x3, [x19, #8]
}
  40f458:	1400000b 	b	40f484 <queue_insert+0x1c4>
}
  40f45c:	aa1703e3 	mov	x3, x23
	node->next_and_flags = flags;
  40f460:	f90002ff 	str	xzr, [x23]
}
  40f464:	17fffff3 	b	40f430 <queue_insert+0x170>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f468:	f94002a2 	ldr	x2, [x21]
Z_GENLIST_INSERT(sflist, sfnode)
  40f46c:	f27ef442 	ands	x2, x2, #0xfffffffffffffffc
  40f470:	540001c1 	b.ne	40f4a8 <queue_insert+0x1e8>  // b.any
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f474:	f9000060 	str	x0, [x3]
	return list->tail;
  40f478:	f9400661 	ldr	x1, [x19, #8]
Z_GENLIST_APPEND(sflist, sfnode)
  40f47c:	b50000c1 	cbnz	x1, 40f494 <queue_insert+0x1d4>
	list->tail = node;
  40f480:	a9000e63 	stp	x3, x3, [x19]
	z_handle_obj_poll_events(&queue->poll_events, state);
  40f484:	9100a260 	add	x0, x19, #0x28
  40f488:	52800081 	mov	w1, #0x4                   	// #4
  40f48c:	94000feb 	bl	413438 <z_handle_obj_poll_events>
  40f490:	17ffffbd 	b	40f384 <queue_insert+0xc4>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f494:	f9400020 	ldr	x0, [x1]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f498:	92400400 	and	x0, x0, #0x3
  40f49c:	aa000060 	orr	x0, x3, x0
  40f4a0:	f9000020 	str	x0, [x1]
  40f4a4:	17ffffec 	b	40f454 <queue_insert+0x194>
  40f4a8:	aa000042 	orr	x2, x2, x0
  40f4ac:	f9000062 	str	x2, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f4b0:	f94002a0 	ldr	x0, [x21]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f4b4:	92400400 	and	x0, x0, #0x3
  40f4b8:	aa000063 	orr	x3, x3, x0
  40f4bc:	f90002a3 	str	x3, [x21]
}
  40f4c0:	17fffff1 	b	40f484 <queue_insert+0x1c4>

000000000040f4c4 <z_queue_node_peek>:
{
  40f4c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40f4c8:	910003fd 	mov	x29, sp
  40f4cc:	f9000bf3 	str	x19, [sp, #16]
  40f4d0:	aa0003f3 	mov	x19, x0
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
  40f4d4:	b4000100 	cbz	x0, 40f4f4 <z_queue_node_peek+0x30>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f4d8:	f9400003 	ldr	x3, [x0]
  40f4dc:	f240047f 	tst	x3, #0x3
  40f4e0:	540000a0 	b.eq	40f4f4 <z_queue_node_peek+0x30>  // b.none
  40f4e4:	12001c21 	and	w1, w1, #0xff
		ret = anode->data;
  40f4e8:	f9400413 	ldr	x19, [x0, #8]
		if (needs_free) {
  40f4ec:	34000041 	cbz	w1, 40f4f4 <z_queue_node_peek+0x30>
			k_free(anode);
  40f4f0:	94000fdc 	bl	413460 <k_free>
}
  40f4f4:	aa1303e0 	mov	x0, x19
  40f4f8:	f9400bf3 	ldr	x19, [sp, #16]
  40f4fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f500:	d65f03c0 	ret

000000000040f504 <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
  40f504:	aa0103e2 	mov	x2, x1
  40f508:	52800004 	mov	w4, #0x0                   	// #0
  40f50c:	52800003 	mov	w3, #0x0                   	// #0
  40f510:	d2800001 	mov	x1, #0x0                   	// #0
  40f514:	17ffff6b 	b	40f2c0 <queue_insert>

000000000040f518 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
  40f518:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40f51c:	910003fd 	mov	x29, sp
  40f520:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  40f524:	91004014 	add	x20, x0, #0x10
{
  40f528:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f52c:	aa0003f5 	mov	x21, x0
  40f530:	f9001bf7 	str	x23, [sp, #48]
  40f534:	aa0103f7 	mov	x23, x1
	return posix_irq_lock();
  40f538:	97ffea9c 	bl	409fa8 <posix_irq_lock>
  40f53c:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f540:	aa1403e0 	mov	x0, x20
  40f544:	97fffc40 	bl	40e644 <z_spin_lock_valid>
  40f548:	72001c1f 	tst	w0, #0xff
  40f54c:	540002c1 	b.ne	40f5a4 <z_impl_k_queue_get+0x8c>  // b.any
  40f550:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f554:	91334a73 	add	x19, x19, #0xcd2
  40f558:	aa1303e2 	mov	x2, x19
  40f55c:	52801283 	mov	w3, #0x94                  	// #148
  40f560:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f564:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f568:	9133fc21 	add	x1, x1, #0xcff
  40f56c:	911e2800 	add	x0, x0, #0x78a
  40f570:	97ffe188 	bl	407b90 <assert_print>
  40f574:	aa1403e1 	mov	x1, x20
  40f578:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f57c:	91345000 	add	x0, x0, #0xd14
  40f580:	97ffe184 	bl	407b90 <assert_print>
  40f584:	aa1303e0 	mov	x0, x19
  40f588:	52801281 	mov	w1, #0x94                  	// #148
  40f58c:	97ffe1ab 	bl	407c38 <assert_post_action>
  40f590:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f594:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f598:	aa1303e1 	mov	x1, x19
  40f59c:	911f2000 	add	x0, x0, #0x7c8
  40f5a0:	97ffeb98 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f5a4:	aa1403e0 	mov	x0, x20
  40f5a8:	97fffc3f 	bl	40e6a4 <z_spin_lock_set_owner>
	return list->head;
  40f5ac:	f94002b3 	ldr	x19, [x21]
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
  40f5b0:	b4000453 	cbz	x19, 40f638 <z_impl_k_queue_get+0x120>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f5b4:	f9400260 	ldr	x0, [x19]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  40f5b8:	f94006a1 	ldr	x1, [x21, #8]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f5bc:	927ef400 	and	x0, x0, #0xfffffffffffffffc
	list->head = node;
  40f5c0:	f90002a0 	str	x0, [x21]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  40f5c4:	eb01027f 	cmp	x19, x1
  40f5c8:	54000041 	b.ne	40f5d0 <z_impl_k_queue_get+0xb8>  // b.any
	list->tail = node;
  40f5cc:	f90006a0 	str	x0, [x21, #8]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
  40f5d0:	aa1303e0 	mov	x0, x19
  40f5d4:	52800021 	mov	w1, #0x1                   	// #1
  40f5d8:	97ffffbb 	bl	40f4c4 <z_queue_node_peek>
  40f5dc:	aa0003f3 	mov	x19, x0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f5e0:	aa1403e0 	mov	x0, x20
  40f5e4:	97fffc23 	bl	40e670 <z_spin_unlock_valid>
  40f5e8:	72001c1f 	tst	w0, #0xff
  40f5ec:	540003e1 	b.ne	40f668 <z_impl_k_queue_get+0x150>  // b.any
  40f5f0:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f5f4:	91334a73 	add	x19, x19, #0xcd2
  40f5f8:	aa1303e2 	mov	x2, x19
  40f5fc:	52801863 	mov	w3, #0xc3                  	// #195
  40f600:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f604:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f608:	9134b021 	add	x1, x1, #0xd2c
  40f60c:	911e2800 	add	x0, x0, #0x78a
  40f610:	97ffe160 	bl	407b90 <assert_print>
  40f614:	aa1403e1 	mov	x1, x20
  40f618:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f61c:	91350c00 	add	x0, x0, #0xd43
  40f620:	97ffe15c 	bl	407b90 <assert_print>
  40f624:	aa1303e0 	mov	x0, x19
  40f628:	52801861 	mov	w1, #0xc3                  	// #195
  40f62c:	97ffe183 	bl	407c38 <assert_post_action>
  40f630:	52801862 	mov	w2, #0xc3                  	// #195
  40f634:	17ffffd8 	b	40f594 <z_impl_k_queue_get+0x7c>
		return data;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40f638:	b4fffd57 	cbz	x23, 40f5e0 <z_impl_k_queue_get+0xc8>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
  40f63c:	aa1703e3 	mov	x3, x23
  40f640:	910062a2 	add	x2, x21, #0x18
  40f644:	2a1603e1 	mov	w1, w22
  40f648:	aa1403e0 	mov	x0, x20
  40f64c:	94000747 	bl	411368 <z_pend_curr>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
  40f650:	35000100 	cbnz	w0, 40f670 <z_impl_k_queue_get+0x158>
  40f654:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40f658:	f9472c00 	ldr	x0, [x0, #3672]
  40f65c:	f9400800 	ldr	x0, [x0, #16]
  40f660:	f9401013 	ldr	x19, [x0, #32]
  40f664:	14000003 	b	40f670 <z_impl_k_queue_get+0x158>
	posix_irq_unlock(key);
  40f668:	2a1603e0 	mov	w0, w22
  40f66c:	97ffea51 	bl	409fb0 <posix_irq_unlock>
}
  40f670:	aa1303e0 	mov	x0, x19
  40f674:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f678:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f67c:	f9401bf7 	ldr	x23, [sp, #48]
  40f680:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40f684:	d65f03c0 	ret

000000000040f688 <z_impl_k_sem_init>:
		      unsigned int limit)
{
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
  40f688:	7100005f 	cmp	w2, #0x0
  40f68c:	7a411040 	ccmp	w2, w1, #0x0, ne  // ne = any
  40f690:	540000e3 	b.cc	40f6ac <z_impl_k_sem_init+0x24>  // b.lo, b.ul, b.last
	list->tail = (sys_dnode_t *)list;
  40f694:	a9000000 	stp	x0, x0, [x0]

		return -EINVAL;
	}

	sem->count = initial_count;
	sem->limit = limit;
  40f698:	29020801 	stp	w1, w2, [x0, #16]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
  40f69c:	91006001 	add	x1, x0, #0x18
  40f6a0:	a9018401 	stp	x1, x1, [x0, #24]
#endif
	z_object_init(sem);

	return 0;
  40f6a4:	52800000 	mov	w0, #0x0                   	// #0
}
  40f6a8:	d65f03c0 	ret
		return -EINVAL;
  40f6ac:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40f6b0:	17fffffe 	b	40f6a8 <z_impl_k_sem_init+0x20>

000000000040f6b4 <z_impl_k_sem_give>:
	return false;
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  40f6b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40f6b8:	910003fd 	mov	x29, sp
  40f6bc:	a90153f3 	stp	x19, x20, [sp, #16]
  40f6c0:	aa0003f3 	mov	x19, x0
  40f6c4:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40f6c8:	97ffea38 	bl	409fa8 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f6cc:	d00000f6 	adrp	x22, 42d000 <args_struct>
  40f6d0:	912542d5 	add	x21, x22, #0x950
  40f6d4:	2a0003f4 	mov	w20, w0
  40f6d8:	aa1503e0 	mov	x0, x21
  40f6dc:	97fffbda 	bl	40e644 <z_spin_lock_valid>
  40f6e0:	72001c1f 	tst	w0, #0xff
  40f6e4:	540002c1 	b.ne	40f73c <z_impl_k_sem_give+0x88>  // b.any
  40f6e8:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f6ec:	91334a73 	add	x19, x19, #0xcd2
  40f6f0:	aa1303e2 	mov	x2, x19
  40f6f4:	52801283 	mov	w3, #0x94                  	// #148
  40f6f8:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f6fc:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f700:	9133fc21 	add	x1, x1, #0xcff
  40f704:	911e2800 	add	x0, x0, #0x78a
  40f708:	97ffe122 	bl	407b90 <assert_print>
  40f70c:	aa1503e1 	mov	x1, x21
  40f710:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f714:	91345000 	add	x0, x0, #0xd14
  40f718:	97ffe11e 	bl	407b90 <assert_print>
  40f71c:	aa1303e0 	mov	x0, x19
  40f720:	52801281 	mov	w1, #0x94                  	// #148
  40f724:	97ffe145 	bl	407c38 <assert_post_action>
  40f728:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f72c:	aa1303e1 	mov	x1, x19
  40f730:	911f2000 	add	x0, x0, #0x7c8
  40f734:	52801282 	mov	w2, #0x94                  	// #148
  40f738:	97ffeb32 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f73c:	aa1503e0 	mov	x0, x21
  40f740:	97fffbd9 	bl	40e6a4 <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool resched = true;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
  40f744:	aa1303e0 	mov	x0, x19
  40f748:	94000910 	bl	411b88 <z_unpend_first_thread>

	if (thread != NULL) {
  40f74c:	b4000120 	cbz	x0, 40f770 <z_impl_k_sem_give+0xbc>
  40f750:	b9004c1f 	str	wzr, [x0, #76]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
  40f754:	940005bc 	bl	410e44 <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		resched = handle_poll_events(sem);
	}

	if (resched) {
		z_reschedule(&lock, key);
  40f758:	2a1403e1 	mov	w1, w20
  40f75c:	912542c0 	add	x0, x22, #0x950
	} else {
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
  40f760:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f764:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f768:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&lock, key);
  40f76c:	1400035b 	b	4104d8 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f770:	29420262 	ldp	w2, w0, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f774:	52800041 	mov	w1, #0x2                   	// #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f778:	6b02001f 	cmp	w0, w2
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f77c:	91006260 	add	x0, x19, #0x18
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f780:	1a820442 	cinc	w2, w2, ne  // ne = any
  40f784:	b9001262 	str	w2, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f788:	94000f2c 	bl	413438 <z_handle_obj_poll_events>
	return true;
  40f78c:	17fffff3 	b	40f758 <z_impl_k_sem_give+0xa4>

000000000040f790 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
  40f790:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40f794:	910003fd 	mov	x29, sp
  40f798:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f79c:	aa0003f5 	mov	x21, x0
	return _kernel.cpus[0].nested != 0U;
  40f7a0:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40f7a4:	a90153f3 	stp	x19, x20, [sp, #16]
  40f7a8:	aa0103f6 	mov	x22, x1
  40f7ac:	f9472c00 	ldr	x0, [x0, #3672]
  40f7b0:	f9001bf7 	str	x23, [sp, #48]
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
  40f7b4:	b9400000 	ldr	w0, [x0]
  40f7b8:	34000280 	cbz	w0, 40f808 <z_impl_k_sem_take+0x78>
  40f7bc:	b4000261 	cbz	x1, 40f808 <z_impl_k_sem_take+0x78>
  40f7c0:	f0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  40f7c4:	910e7673 	add	x19, x19, #0x39d
  40f7c8:	aa1303e2 	mov	x2, x19
  40f7cc:	f0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  40f7d0:	910ef421 	add	x1, x1, #0x3bd
  40f7d4:	52801003 	mov	w3, #0x80                  	// #128
  40f7d8:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f7dc:	911e2800 	add	x0, x0, #0x78a
  40f7e0:	97ffe0ec 	bl	407b90 <assert_print>
  40f7e4:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f7e8:	9135a400 	add	x0, x0, #0xd69
  40f7ec:	97ffe0e9 	bl	407b90 <assert_print>
  40f7f0:	aa1303e0 	mov	x0, x19
  40f7f4:	52801001 	mov	w1, #0x80                  	// #128
  40f7f8:	97ffe110 	bl	407c38 <assert_post_action>
  40f7fc:	52801002 	mov	w2, #0x80                  	// #128
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f800:	aa1303e1 	mov	x1, x19
  40f804:	1400001b 	b	40f870 <z_impl_k_sem_take+0xe0>
  40f808:	97ffe9e8 	bl	409fa8 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f80c:	d00000f7 	adrp	x23, 42d000 <args_struct>
  40f810:	912542f3 	add	x19, x23, #0x950
  40f814:	2a0003f4 	mov	w20, w0
  40f818:	aa1303e0 	mov	x0, x19
  40f81c:	97fffb8a 	bl	40e644 <z_spin_lock_valid>
  40f820:	72001c1f 	tst	w0, #0xff
  40f824:	540002c1 	b.ne	40f87c <z_impl_k_sem_take+0xec>  // b.any
  40f828:	d0000034 	adrp	x20, 415000 <random_data+0xca4>
  40f82c:	91334a94 	add	x20, x20, #0xcd2
  40f830:	aa1403e2 	mov	x2, x20
  40f834:	52801283 	mov	w3, #0x94                  	// #148
  40f838:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f83c:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f840:	9133fc21 	add	x1, x1, #0xcff
  40f844:	911e2800 	add	x0, x0, #0x78a
  40f848:	97ffe0d2 	bl	407b90 <assert_print>
  40f84c:	aa1303e1 	mov	x1, x19
  40f850:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f854:	91345000 	add	x0, x0, #0xd14
  40f858:	97ffe0ce 	bl	407b90 <assert_print>
  40f85c:	52801281 	mov	w1, #0x94                  	// #148
  40f860:	aa1403e0 	mov	x0, x20
  40f864:	97ffe0f5 	bl	407c38 <assert_post_action>
  40f868:	aa1403e1 	mov	x1, x20
  40f86c:	52801282 	mov	w2, #0x94                  	// #148
  40f870:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f874:	911f2000 	add	x0, x0, #0x7c8
  40f878:	97ffeae2 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f87c:	aa1303e0 	mov	x0, x19
  40f880:	97fffb89 	bl	40e6a4 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
  40f884:	b94012a0 	ldr	w0, [x21, #16]
  40f888:	34000420 	cbz	w0, 40f90c <z_impl_k_sem_take+0x17c>
		sem->count--;
  40f88c:	51000400 	sub	w0, w0, #0x1
  40f890:	b90012a0 	str	w0, [x21, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f894:	aa1303e0 	mov	x0, x19
  40f898:	97fffb76 	bl	40e670 <z_spin_unlock_valid>
  40f89c:	72001c1f 	tst	w0, #0xff
  40f8a0:	54000261 	b.ne	40f8ec <z_impl_k_sem_take+0x15c>  // b.any
  40f8a4:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f8a8:	91334a73 	add	x19, x19, #0xcd2
  40f8ac:	aa1303e2 	mov	x2, x19
  40f8b0:	52801863 	mov	w3, #0xc3                  	// #195
  40f8b4:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f8b8:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f8bc:	9134b021 	add	x1, x1, #0xd2c
  40f8c0:	911e2800 	add	x0, x0, #0x78a
  40f8c4:	97ffe0b3 	bl	407b90 <assert_print>
  40f8c8:	912542e1 	add	x1, x23, #0x950
  40f8cc:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f8d0:	91350c00 	add	x0, x0, #0xd43
  40f8d4:	97ffe0af 	bl	407b90 <assert_print>
  40f8d8:	aa1303e0 	mov	x0, x19
  40f8dc:	52801861 	mov	w1, #0xc3                  	// #195
  40f8e0:	97ffe0d6 	bl	407c38 <assert_post_action>
  40f8e4:	52801862 	mov	w2, #0xc3                  	// #195
  40f8e8:	17ffffc6 	b	40f800 <z_impl_k_sem_take+0x70>
	posix_irq_unlock(key);
  40f8ec:	2a1403e0 	mov	w0, w20
  40f8f0:	97ffe9b0 	bl	409fb0 <posix_irq_unlock>
		k_spin_unlock(&lock, key);
		ret = 0;
  40f8f4:	52800000 	mov	w0, #0x0                   	// #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
  40f8f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f8fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f900:	f9401bf7 	ldr	x23, [sp, #48]
  40f904:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40f908:	d65f03c0 	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40f90c:	b5000136 	cbnz	x22, 40f930 <z_impl_k_sem_take+0x1a0>
  40f910:	aa1303e0 	mov	x0, x19
  40f914:	97fffb57 	bl	40e670 <z_spin_unlock_valid>
  40f918:	72001c1f 	tst	w0, #0xff
  40f91c:	54fffc40 	b.eq	40f8a4 <z_impl_k_sem_take+0x114>  // b.none
  40f920:	2a1403e0 	mov	w0, w20
  40f924:	97ffe9a3 	bl	409fb0 <posix_irq_unlock>
		ret = -EBUSY;
  40f928:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40f92c:	17fffff3 	b	40f8f8 <z_impl_k_sem_take+0x168>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  40f930:	aa1603e3 	mov	x3, x22
  40f934:	aa1503e2 	mov	x2, x21
  40f938:	2a1403e1 	mov	w1, w20
  40f93c:	aa1303e0 	mov	x0, x19
}
  40f940:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f944:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f948:	f9401bf7 	ldr	x23, [sp, #48]
  40f94c:	a8c47bfd 	ldp	x29, x30, [sp], #64
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  40f950:	14000686 	b	411368 <z_pend_curr>

000000000040f954 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
  40f954:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40f958:	910003fd 	mov	x29, sp
  40f95c:	a90153f3 	stp	x19, x20, [sp, #16]
  40f960:	aa0003f3 	mov	x19, x0
  40f964:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40f968:	97ffe990 	bl	409fa8 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f96c:	d00000f6 	adrp	x22, 42d000 <args_struct>
  40f970:	912542d5 	add	x21, x22, #0x950
  40f974:	2a0003f4 	mov	w20, w0
  40f978:	aa1503e0 	mov	x0, x21
  40f97c:	97fffb32 	bl	40e644 <z_spin_lock_valid>
  40f980:	72001c1f 	tst	w0, #0xff
  40f984:	540002c1 	b.ne	40f9dc <z_impl_k_sem_reset+0x88>  // b.any
  40f988:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40f98c:	91334a73 	add	x19, x19, #0xcd2
  40f990:	aa1303e2 	mov	x2, x19
  40f994:	52801283 	mov	w3, #0x94                  	// #148
  40f998:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40f99c:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f9a0:	9133fc21 	add	x1, x1, #0xcff
  40f9a4:	911e2800 	add	x0, x0, #0x78a
  40f9a8:	97ffe07a 	bl	407b90 <assert_print>
  40f9ac:	aa1503e1 	mov	x1, x21
  40f9b0:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40f9b4:	91345000 	add	x0, x0, #0xd14
  40f9b8:	97ffe076 	bl	407b90 <assert_print>
  40f9bc:	aa1303e0 	mov	x0, x19
  40f9c0:	52801281 	mov	w1, #0x94                  	// #148
  40f9c4:	97ffe09d 	bl	407c38 <assert_post_action>
  40f9c8:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40f9cc:	aa1303e1 	mov	x1, x19
  40f9d0:	911f2000 	add	x0, x0, #0x7c8
  40f9d4:	52801282 	mov	w2, #0x94                  	// #148
  40f9d8:	97ffea8a 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f9dc:	aa1503e0 	mov	x0, x21
	thread->callee_saved.retval = value;
  40f9e0:	12800155 	mov	w21, #0xfffffff5            	// #-11
  40f9e4:	97fffb30 	bl	40e6a4 <z_spin_lock_set_owner>
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
  40f9e8:	aa1303e0 	mov	x0, x19
  40f9ec:	94000867 	bl	411b88 <z_unpend_first_thread>
		if (thread == NULL) {
  40f9f0:	b4000080 	cbz	x0, 40fa00 <z_impl_k_sem_reset+0xac>
  40f9f4:	b9004c15 	str	w21, [x0, #76]
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
  40f9f8:	94000513 	bl	410e44 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
  40f9fc:	17fffffb 	b	40f9e8 <z_impl_k_sem_reset+0x94>
	}
	sem->count = 0;
  40fa00:	b900127f 	str	wzr, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40fa04:	91006260 	add	x0, x19, #0x18
  40fa08:	52800041 	mov	w1, #0x2                   	// #2
  40fa0c:	94000e8b 	bl	413438 <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
  40fa10:	2a1403e1 	mov	w1, w20
  40fa14:	912542c0 	add	x0, x22, #0x950
}
  40fa18:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fa1c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fa20:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&lock, key);
  40fa24:	140002ad 	b	4104d8 <z_reschedule>

000000000040fa28 <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
  40fa28:	b9400002 	ldr	w2, [x0]
	*flagp &= ~BIT(bit);
  40fa2c:	d2800023 	mov	x3, #0x1                   	// #1
  40fa30:	9ac12063 	lsl	x3, x3, x1
  40fa34:	0a230043 	bic	w3, w2, w3
  40fa38:	b9000003 	str	w3, [x0]
	return (*flagp & BIT(bit)) != 0U;
  40fa3c:	2a0203e0 	mov	w0, w2
  40fa40:	9ac12400 	lsr	x0, x0, x1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
  40fa44:	12000000 	and	w0, w0, #0x1
  40fa48:	d65f03c0 	ret

000000000040fa4c <notify_queue_locked.isra.0>:
 */
static inline bool notify_queue_locked(struct k_work_q *queue)
{
	bool rv = false;

	if (queue != NULL) {
  40fa4c:	b40000a0 	cbz	x0, 40fa60 <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
  40fa50:	91034000 	add	x0, x0, #0xd0
  40fa54:	d2800002 	mov	x2, #0x0                   	// #0
  40fa58:	52800001 	mov	w1, #0x0                   	// #0
  40fa5c:	14000b38 	b	41273c <z_sched_wake>
	}

	return rv;
}
  40fa60:	d65f03c0 	ret

000000000040fa64 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
  40fa64:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40fa68:	910003fd 	mov	x29, sp
  40fa6c:	a90153f3 	stp	x19, x20, [sp, #16]
  40fa70:	aa0003f3 	mov	x19, x0
  40fa74:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fa78:	d00000f5 	adrp	x21, 42d000 <args_struct>
  40fa7c:	a90363f7 	stp	x23, x24, [sp, #48]
	return list->head;
  40fa80:	d00000f8 	adrp	x24, 42d000 <args_struct>
	return list->tail;
  40fa84:	91258316 	add	x22, x24, #0x960
  40fa88:	a9046bf9 	stp	x25, x26, [sp, #64]
  40fa8c:	97ffe947 	bl	409fa8 <posix_irq_lock>
  40fa90:	912562b4 	add	x20, x21, #0x958
  40fa94:	2a0003f7 	mov	w23, w0
  40fa98:	aa1403e0 	mov	x0, x20
  40fa9c:	97fffaea 	bl	40e644 <z_spin_lock_valid>
  40faa0:	72001c1f 	tst	w0, #0xff
  40faa4:	540002c1 	b.ne	40fafc <work_queue_main+0x98>  // b.any
  40faa8:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40faac:	91334a73 	add	x19, x19, #0xcd2
  40fab0:	aa1303e2 	mov	x2, x19
  40fab4:	52801283 	mov	w3, #0x94                  	// #148
  40fab8:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40fabc:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40fac0:	9133fc21 	add	x1, x1, #0xcff
  40fac4:	911e2800 	add	x0, x0, #0x78a
  40fac8:	97ffe032 	bl	407b90 <assert_print>
  40facc:	912562a1 	add	x1, x21, #0x958
  40fad0:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40fad4:	91345000 	add	x0, x0, #0xd14
  40fad8:	97ffe02e 	bl	407b90 <assert_print>
  40fadc:	aa1303e0 	mov	x0, x19
  40fae0:	52801281 	mov	w1, #0x94                  	// #148
  40fae4:	97ffe055 	bl	407c38 <assert_post_action>
  40fae8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40faec:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40faf0:	aa1303e1 	mov	x1, x19
  40faf4:	911f2000 	add	x0, x0, #0x7c8
  40faf8:	97ffea42 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40fafc:	aa1403e0 	mov	x0, x20
  40fb00:	97fffae9 	bl	40e6a4 <z_spin_lock_set_owner>
	return list->head;
  40fb04:	f9406274 	ldr	x20, [x19, #192]
Z_GENLIST_GET(slist, snode)
  40fb08:	b50001b4 	cbnz	x20, 40fb3c <work_queue_main+0xd8>
			 * which should never happen, even line 'if (work != NULL)'
			 * ensures that.
			 * This means that if node is not NULL, then work will not be NULL.
			 */
			handler = work->handler;
		} else if (flag_test_and_clear(&queue->flags,
  40fb0c:	9103c260 	add	x0, x19, #0xf0
  40fb10:	52800041 	mov	w1, #0x2                   	// #2
  40fb14:	97ffffc5 	bl	40fa28 <flag_test_and_clear>
  40fb18:	72001c1f 	tst	w0, #0xff
  40fb1c:	54000581 	b.ne	40fbcc <work_queue_main+0x168>  // b.any
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
  40fb20:	91034262 	add	x2, x19, #0xd0
  40fb24:	2a1703e1 	mov	w1, w23
  40fb28:	912562a0 	add	x0, x21, #0x958
  40fb2c:	d2800004 	mov	x4, #0x0                   	// #0
  40fb30:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40fb34:	94000b58 	bl	412894 <z_sched_wait>
					   K_FOREVER, NULL);
			continue;
  40fb38:	17ffffd5 	b	40fa8c <work_queue_main+0x28>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  40fb3c:	f9406661 	ldr	x1, [x19, #200]
	return node->next;
  40fb40:	f9400280 	ldr	x0, [x20]
	list->head = node;
  40fb44:	f9006260 	str	x0, [x19, #192]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  40fb48:	eb01029f 	cmp	x20, x1
  40fb4c:	54000041 	b.ne	40fb54 <work_queue_main+0xf0>  // b.any
	list->tail = node;
  40fb50:	f9006660 	str	x0, [x19, #200]
	*flagp |= BIT(bit);
  40fb54:	b940f260 	ldr	w0, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fb58:	912562b9 	add	x25, x21, #0x958
  40fb5c:	321f0000 	orr	w0, w0, #0x2
  40fb60:	b900f260 	str	w0, [x19, #240]
  40fb64:	aa1903e0 	mov	x0, x25
	*flagp &= ~BIT(bit);
  40fb68:	b9401a82 	ldr	w2, [x20, #24]
			handler = work->handler;
  40fb6c:	f940069a 	ldr	x26, [x20, #8]
	*flagp &= ~BIT(bit);
  40fb70:	121d7842 	and	w2, w2, #0xfffffffb
  40fb74:	32000042 	orr	w2, w2, #0x1
  40fb78:	b9001a82 	str	w2, [x20, #24]
  40fb7c:	97fffabd 	bl	40e670 <z_spin_unlock_valid>
  40fb80:	72001c1f 	tst	w0, #0xff
  40fb84:	54000600 	b.eq	40fc44 <work_queue_main+0x1e0>  // b.none
	posix_irq_unlock(key);
  40fb88:	2a1703e0 	mov	w0, w23
  40fb8c:	97ffe909 	bl	409fb0 <posix_irq_unlock>
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
  40fb90:	b50002fa 	cbnz	x26, 40fbec <work_queue_main+0x188>
  40fb94:	f0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  40fb98:	91102e73 	add	x19, x19, #0x40b
  40fb9c:	aa1303e2 	mov	x2, x19
  40fba0:	52805363 	mov	w3, #0x29b                 	// #667
  40fba4:	f0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  40fba8:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40fbac:	9110b021 	add	x1, x1, #0x42c
  40fbb0:	911e2800 	add	x0, x0, #0x78a
  40fbb4:	97ffdff7 	bl	407b90 <assert_print>
  40fbb8:	aa1303e0 	mov	x0, x19
  40fbbc:	52805361 	mov	w1, #0x29b                 	// #667
  40fbc0:	97ffe01e 	bl	407c38 <assert_post_action>
  40fbc4:	52805362 	mov	w2, #0x29b                 	// #667
  40fbc8:	17ffffc9 	b	40faec <work_queue_main+0x88>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
  40fbcc:	91038274 	add	x20, x19, #0xe0
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
  40fbd0:	aa1403e0 	mov	x0, x20
  40fbd4:	d2800002 	mov	x2, #0x0                   	// #0
  40fbd8:	52800021 	mov	w1, #0x1                   	// #1
  40fbdc:	94000ad8 	bl	41273c <z_sched_wake>
  40fbe0:	72001c1f 	tst	w0, #0xff
  40fbe4:	54ffff61 	b.ne	40fbd0 <work_queue_main+0x16c>  // b.any
  40fbe8:	17ffffce 	b	40fb20 <work_queue_main+0xbc>
		handler(work);
  40fbec:	aa1403e0 	mov	x0, x20
  40fbf0:	d63f0340 	blr	x26
	return posix_irq_lock();
  40fbf4:	97ffe8ed 	bl	409fa8 <posix_irq_lock>
  40fbf8:	2a0003f7 	mov	w23, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fbfc:	aa1903e0 	mov	x0, x25
  40fc00:	97fffa91 	bl	40e644 <z_spin_lock_valid>
  40fc04:	72001c1f 	tst	w0, #0xff
  40fc08:	54fff500 	b.eq	40faa8 <work_queue_main+0x44>  // b.none
	z_spin_lock_set_owner(l);
  40fc0c:	aa1903e0 	mov	x0, x25
  40fc10:	97fffaa5 	bl	40e6a4 <z_spin_lock_set_owner>
	*flagp &= ~BIT(bit);
  40fc14:	b9401a80 	ldr	w0, [x20, #24]
  40fc18:	121f7801 	and	w1, w0, #0xfffffffe
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  40fc1c:	37080380 	tbnz	w0, #1, 40fc8c <work_queue_main+0x228>
	*flagp &= ~BIT(bit);
  40fc20:	b9001a81 	str	w1, [x20, #24]
  40fc24:	b940f261 	ldr	w1, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fc28:	912562a0 	add	x0, x21, #0x958
  40fc2c:	121e7821 	and	w1, w1, #0xfffffffd
  40fc30:	b900f261 	str	w1, [x19, #240]
	return (*flagp & BIT(bit)) != 0U;
  40fc34:	d3482034 	ubfx	x20, x1, #8, #1
  40fc38:	97fffa8e 	bl	40e670 <z_spin_unlock_valid>
  40fc3c:	72001c1f 	tst	w0, #0xff
  40fc40:	54000641 	b.ne	40fd08 <work_queue_main+0x2a4>  // b.any
  40fc44:	d0000033 	adrp	x19, 415000 <random_data+0xca4>
  40fc48:	91334a73 	add	x19, x19, #0xcd2
  40fc4c:	aa1303e2 	mov	x2, x19
  40fc50:	52801863 	mov	w3, #0xc3                  	// #195
  40fc54:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40fc58:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40fc5c:	9134b021 	add	x1, x1, #0xd2c
  40fc60:	911e2800 	add	x0, x0, #0x78a
  40fc64:	97ffdfcb 	bl	407b90 <assert_print>
  40fc68:	912562a1 	add	x1, x21, #0x958
  40fc6c:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40fc70:	91350c00 	add	x0, x0, #0xd43
  40fc74:	97ffdfc7 	bl	407b90 <assert_print>
  40fc78:	aa1303e0 	mov	x0, x19
  40fc7c:	52801861 	mov	w1, #0xc3                  	// #195
  40fc80:	97ffdfee 	bl	407c38 <assert_post_action>
  40fc84:	52801862 	mov	w2, #0xc3                  	// #195
  40fc88:	17ffff99 	b	40faec <work_queue_main+0x88>
	*flagp &= ~BIT(bit);
  40fc8c:	121e7400 	and	w0, w0, #0xfffffffc
  40fc90:	b9001a80 	str	w0, [x20, #24]
	return list->head;
  40fc94:	f944b300 	ldr	x0, [x24, #2400]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  40fc98:	b4fffc60 	cbz	x0, 40fc24 <work_queue_main+0x1c0>
	return node->next;
  40fc9c:	f940001a 	ldr	x26, [x0]
  40fca0:	d2800019 	mov	x25, #0x0                   	// #0
		if (wc->work == work) {
  40fca4:	f9400402 	ldr	x2, [x0, #8]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
  40fca8:	aa0003e1 	mov	x1, x0
		if (wc->work == work) {
  40fcac:	eb02029f 	cmp	x20, x2
  40fcb0:	54000161 	b.ne	40fcdc <work_queue_main+0x278>  // b.any
  40fcb4:	f9400001 	ldr	x1, [x0]
Z_GENLIST_REMOVE(slist, snode)
  40fcb8:	b50001d9 	cbnz	x25, 40fcf0 <work_queue_main+0x28c>
  40fcbc:	f94006c2 	ldr	x2, [x22, #8]
	list->head = node;
  40fcc0:	f90002c1 	str	x1, [x22]
Z_GENLIST_REMOVE(slist, snode)
  40fcc4:	eb00005f 	cmp	x2, x0
  40fcc8:	54000041 	b.ne	40fcd0 <work_queue_main+0x26c>  // b.any
	list->tail = node;
  40fccc:	f90006c1 	str	x1, [x22, #8]
	parent->next = child;
  40fcd0:	f801041f 	str	xzr, [x0], #16
	z_impl_k_sem_give(sem);
  40fcd4:	97fffe78 	bl	40f6b4 <z_impl_k_sem_give>
}
  40fcd8:	aa1903e1 	mov	x1, x25
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  40fcdc:	b4fffa5a 	cbz	x26, 40fc24 <work_queue_main+0x1c0>
	return node->next;
  40fce0:	aa1a03e0 	mov	x0, x26
  40fce4:	aa0103f9 	mov	x25, x1
  40fce8:	f940035a 	ldr	x26, [x26]
  40fcec:	17ffffee 	b	40fca4 <work_queue_main+0x240>
	parent->next = child;
  40fcf0:	f9000321 	str	x1, [x25]
Z_GENLIST_REMOVE(slist, snode)
  40fcf4:	f94006c1 	ldr	x1, [x22, #8]
  40fcf8:	eb00003f 	cmp	x1, x0
  40fcfc:	54fffea1 	b.ne	40fcd0 <work_queue_main+0x26c>  // b.any
	list->tail = node;
  40fd00:	f90006d9 	str	x25, [x22, #8]
}
  40fd04:	17fffff3 	b	40fcd0 <work_queue_main+0x26c>
	posix_irq_unlock(key);
  40fd08:	2a1703e0 	mov	w0, w23
  40fd0c:	97ffe8a9 	bl	409fb0 <posix_irq_unlock>
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
  40fd10:	35ffebf4 	cbnz	w20, 40fa8c <work_queue_main+0x28>
	z_impl_k_yield();
  40fd14:	94000800 	bl	411d14 <z_impl_k_yield>
}
  40fd18:	17ffff5d 	b	40fa8c <work_queue_main+0x28>

000000000040fd1c <submit_to_queue_locked>:
{
  40fd1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40fd20:	910003fd 	mov	x29, sp
  40fd24:	a90153f3 	stp	x19, x20, [sp, #16]
  40fd28:	aa0003f3 	mov	x19, x0
  40fd2c:	aa0103f4 	mov	x20, x1
  40fd30:	a9025bf5 	stp	x21, x22, [sp, #32]
	return (*flagp & BIT(bit)) != 0U;
  40fd34:	b9401800 	ldr	w0, [x0, #24]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  40fd38:	721f001f 	tst	w0, #0x2
  40fd3c:	54000941 	b.ne	40fe64 <submit_to_queue_locked+0x148>  // b.any
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
  40fd40:	721e001f 	tst	w0, #0x4
  40fd44:	54000961 	b.ne	40fe70 <submit_to_queue_locked+0x154>  // b.any
		if (*queuep == NULL) {
  40fd48:	f9400020 	ldr	x0, [x1]
  40fd4c:	b5000060 	cbnz	x0, 40fd58 <submit_to_queue_locked+0x3c>
			*queuep = work->queue;
  40fd50:	f9400a60 	ldr	x0, [x19, #16]
  40fd54:	f9000020 	str	x0, [x1]
	return (*flagp & BIT(bit)) != 0U;
  40fd58:	b9401a60 	ldr	w0, [x19, #24]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
  40fd5c:	36000760 	tbz	w0, #0, 40fe48 <submit_to_queue_locked+0x12c>
			__ASSERT_NO_MSG(work->queue != NULL);
  40fd60:	f9400a60 	ldr	x0, [x19, #16]
  40fd64:	b5000240 	cbnz	x0, 40fdac <submit_to_queue_locked+0x90>
  40fd68:	f0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  40fd6c:	91102e73 	add	x19, x19, #0x40b
  40fd70:	aa1303e2 	mov	x2, x19
  40fd74:	528029c3 	mov	w3, #0x14e                 	// #334
  40fd78:	f0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  40fd7c:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40fd80:	91110c21 	add	x1, x1, #0x443
  40fd84:	911e2800 	add	x0, x0, #0x78a
  40fd88:	97ffdf82 	bl	407b90 <assert_print>
  40fd8c:	aa1303e0 	mov	x0, x19
  40fd90:	528029c1 	mov	w1, #0x14e                 	// #334
  40fd94:	97ffdfa9 	bl	407c38 <assert_post_action>
  40fd98:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40fd9c:	aa1303e1 	mov	x1, x19
  40fda0:	911f2000 	add	x0, x0, #0x7c8
  40fda4:	528029c2 	mov	w2, #0x14e                 	// #334
  40fda8:	97ffe996 	bl	40a400 <posix_print_error_and_exit>
			ret = 2;
  40fdac:	52800056 	mov	w22, #0x2                   	// #2
			*queuep = work->queue;
  40fdb0:	f9000280 	str	x0, [x20]
		int rc = queue_submit_locked(*queuep, work);
  40fdb4:	f9400295 	ldr	x21, [x20]
	if (queue == NULL) {
  40fdb8:	b4000615 	cbz	x21, 40fe78 <submit_to_queue_locked+0x15c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40fdbc:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  40fdc0:	f9472c00 	ldr	x0, [x0, #3672]
  40fdc4:	f9400800 	ldr	x0, [x0, #16]
  40fdc8:	eb15001f 	cmp	x0, x21
  40fdcc:	54000421 	b.ne	40fe50 <submit_to_queue_locked+0x134>  // b.any
  40fdd0:	97fff910 	bl	40e210 <k_is_in_isr>
  40fdd4:	12001c00 	and	w0, w0, #0xff
  40fdd8:	52000000 	eor	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  40fddc:	b940f2a2 	ldr	w2, [x21, #240]
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40fde0:	12000000 	and	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  40fde4:	d3420841 	ubfx	x1, x2, #2, #1
  40fde8:	d3430c43 	ubfx	x3, x2, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
  40fdec:	360004a2 	tbz	w2, #0, 40fe80 <submit_to_queue_locked+0x164>
	} else if (draining && !chained) {
  40fdf0:	52000000 	eor	w0, w0, #0x1
  40fdf4:	6a00003f 	tst	w1, w0
  40fdf8:	54000361 	b.ne	40fe64 <submit_to_queue_locked+0x148>  // b.any
	} else if (plugged && !draining) {
  40fdfc:	52000021 	eor	w1, w1, #0x1
  40fe00:	6a01007f 	tst	w3, w1
  40fe04:	54000301 	b.ne	40fe64 <submit_to_queue_locked+0x148>  // b.any
	parent->next = child;
  40fe08:	f900027f 	str	xzr, [x19]
	return list->tail;
  40fe0c:	f94066a0 	ldr	x0, [x21, #200]
Z_GENLIST_APPEND(slist, snode)
  40fe10:	b5000240 	cbnz	x0, 40fe58 <submit_to_queue_locked+0x13c>
	list->tail = node;
  40fe14:	a90c4eb3 	stp	x19, x19, [x21, #192]
		(void)notify_queue_locked(queue);
  40fe18:	aa1503e0 	mov	x0, x21
  40fe1c:	97ffff0c 	bl	40fa4c <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
  40fe20:	b9401a60 	ldr	w0, [x19, #24]
  40fe24:	321e0000 	orr	w0, w0, #0x4
  40fe28:	b9001a60 	str	w0, [x19, #24]
			work->queue = *queuep;
  40fe2c:	f9400280 	ldr	x0, [x20]
  40fe30:	f9000a60 	str	x0, [x19, #16]
}
  40fe34:	2a1603e0 	mov	w0, w22
  40fe38:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fe3c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fe40:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40fe44:	d65f03c0 	ret
		ret = 1;
  40fe48:	52800036 	mov	w22, #0x1                   	// #1
  40fe4c:	17ffffda 	b	40fdb4 <submit_to_queue_locked+0x98>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40fe50:	52800000 	mov	w0, #0x0                   	// #0
  40fe54:	17ffffe2 	b	40fddc <submit_to_queue_locked+0xc0>
	parent->next = child;
  40fe58:	f9000013 	str	x19, [x0]
	list->tail = node;
  40fe5c:	f90066b3 	str	x19, [x21, #200]
}
  40fe60:	17ffffee 	b	40fe18 <submit_to_queue_locked+0xfc>
		ret = -EBUSY;
  40fe64:	128001f6 	mov	w22, #0xfffffff0            	// #-16
		*queuep = NULL;
  40fe68:	f900029f 	str	xzr, [x20]
	return ret;
  40fe6c:	17fffff2 	b	40fe34 <submit_to_queue_locked+0x118>
	int ret = 0;
  40fe70:	52800016 	mov	w22, #0x0                   	// #0
  40fe74:	17fffffd 	b	40fe68 <submit_to_queue_locked+0x14c>
		return -EINVAL;
  40fe78:	128002b6 	mov	w22, #0xffffffea            	// #-22
  40fe7c:	17fffffb 	b	40fe68 <submit_to_queue_locked+0x14c>
		ret = -ENODEV;
  40fe80:	12800256 	mov	w22, #0xffffffed            	// #-19
  40fe84:	17fffff9 	b	40fe68 <submit_to_queue_locked+0x14c>

000000000040fe88 <k_work_init>:
{
  40fe88:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40fe8c:	910003fd 	mov	x29, sp
  40fe90:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(work != NULL);
  40fe94:	b5000240 	cbnz	x0, 40fedc <k_work_init+0x54>
  40fe98:	f0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  40fe9c:	91102e73 	add	x19, x19, #0x40b
  40fea0:	aa1303e2 	mov	x2, x19
  40fea4:	52801123 	mov	w3, #0x89                  	// #137
  40fea8:	f0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  40feac:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40feb0:	91117821 	add	x1, x1, #0x45e
  40feb4:	911e2800 	add	x0, x0, #0x78a
  40feb8:	97ffdf36 	bl	407b90 <assert_print>
  40febc:	aa1303e0 	mov	x0, x19
  40fec0:	52801121 	mov	w1, #0x89                  	// #137
  40fec4:	97ffdf5d 	bl	407c38 <assert_post_action>
  40fec8:	52801122 	mov	w2, #0x89                  	// #137
	__ASSERT_NO_MSG(handler != NULL);
  40fecc:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40fed0:	aa1303e1 	mov	x1, x19
  40fed4:	911f2000 	add	x0, x0, #0x7c8
  40fed8:	97ffe94a 	bl	40a400 <posix_print_error_and_exit>
  40fedc:	b50001e1 	cbnz	x1, 40ff18 <k_work_init+0x90>
  40fee0:	f0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  40fee4:	91102e73 	add	x19, x19, #0x40b
  40fee8:	aa1303e2 	mov	x2, x19
  40feec:	52801143 	mov	w3, #0x8a                  	// #138
  40fef0:	f0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  40fef4:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40fef8:	9110b021 	add	x1, x1, #0x42c
  40fefc:	911e2800 	add	x0, x0, #0x78a
  40ff00:	97ffdf24 	bl	407b90 <assert_print>
  40ff04:	aa1303e0 	mov	x0, x19
  40ff08:	52801141 	mov	w1, #0x8a                  	// #138
  40ff0c:	97ffdf4b 	bl	407c38 <assert_post_action>
  40ff10:	52801142 	mov	w2, #0x8a                  	// #138
  40ff14:	17ffffee 	b	40fecc <k_work_init+0x44>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  40ff18:	a9007c1f 	stp	xzr, xzr, [x0]
  40ff1c:	f9000401 	str	x1, [x0, #8]
  40ff20:	a9017c1f 	stp	xzr, xzr, [x0, #16]
}
  40ff24:	f9400bf3 	ldr	x19, [sp, #16]
  40ff28:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40ff2c:	d65f03c0 	ret

000000000040ff30 <z_work_submit_to_queue>:
{
  40ff30:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40ff34:	910003fd 	mov	x29, sp
  40ff38:	a90153f3 	stp	x19, x20, [sp, #16]
  40ff3c:	f90013f5 	str	x21, [sp, #32]
  40ff40:	f9001fe0 	str	x0, [sp, #56]
	__ASSERT_NO_MSG(work != NULL);
  40ff44:	b5000241 	cbnz	x1, 40ff8c <z_work_submit_to_queue+0x5c>
  40ff48:	f0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  40ff4c:	91102e73 	add	x19, x19, #0x40b
  40ff50:	aa1303e2 	mov	x2, x19
  40ff54:	52802e83 	mov	w3, #0x174                 	// #372
  40ff58:	f0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  40ff5c:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ff60:	91117821 	add	x1, x1, #0x45e
  40ff64:	911e2800 	add	x0, x0, #0x78a
  40ff68:	97ffdf0a 	bl	407b90 <assert_print>
  40ff6c:	52802e81 	mov	w1, #0x174                 	// #372
  40ff70:	aa1303e0 	mov	x0, x19
  40ff74:	97ffdf31 	bl	407c38 <assert_post_action>
  40ff78:	aa1303e1 	mov	x1, x19
  40ff7c:	52802e82 	mov	w2, #0x174                 	// #372
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ff80:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ff84:	911f2000 	add	x0, x0, #0x7c8
  40ff88:	97ffe91e 	bl	40a400 <posix_print_error_and_exit>
  40ff8c:	aa0103f4 	mov	x20, x1
  40ff90:	d00000f3 	adrp	x19, 42d000 <args_struct>
	return posix_irq_lock();
  40ff94:	97ffe805 	bl	409fa8 <posix_irq_lock>
  40ff98:	91256273 	add	x19, x19, #0x958
  40ff9c:	2a0003f5 	mov	w21, w0
  40ffa0:	aa1303e0 	mov	x0, x19
  40ffa4:	97fff9a8 	bl	40e644 <z_spin_lock_valid>
  40ffa8:	72001c1f 	tst	w0, #0xff
  40ffac:	54000281 	b.ne	40fffc <z_work_submit_to_queue+0xcc>  // b.any
  40ffb0:	d0000034 	adrp	x20, 415000 <random_data+0xca4>
  40ffb4:	91334a94 	add	x20, x20, #0xcd2
  40ffb8:	aa1403e2 	mov	x2, x20
  40ffbc:	52801283 	mov	w3, #0x94                  	// #148
  40ffc0:	d0000021 	adrp	x1, 415000 <random_data+0xca4>
  40ffc4:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  40ffc8:	9133fc21 	add	x1, x1, #0xcff
  40ffcc:	911e2800 	add	x0, x0, #0x78a
  40ffd0:	97ffdef0 	bl	407b90 <assert_print>
  40ffd4:	aa1303e1 	mov	x1, x19
  40ffd8:	d0000020 	adrp	x0, 415000 <random_data+0xca4>
  40ffdc:	91345000 	add	x0, x0, #0xd14
  40ffe0:	97ffdeec 	bl	407b90 <assert_print>
  40ffe4:	aa1403e0 	mov	x0, x20
  40ffe8:	52801281 	mov	w1, #0x94                  	// #148
  40ffec:	97ffdf13 	bl	407c38 <assert_post_action>
  40fff0:	52801282 	mov	w2, #0x94                  	// #148
  40fff4:	aa1403e1 	mov	x1, x20
  40fff8:	17ffffe2 	b	40ff80 <z_work_submit_to_queue+0x50>
	z_spin_lock_set_owner(l);
  40fffc:	aa1303e0 	mov	x0, x19
  410000:	97fff9a9 	bl	40e6a4 <z_spin_lock_set_owner>
	int ret = submit_to_queue_locked(work, &queue);
  410004:	9100e3e1 	add	x1, sp, #0x38
  410008:	aa1403e0 	mov	x0, x20
  41000c:	97ffff44 	bl	40fd1c <submit_to_queue_locked>
  410010:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410014:	aa1303e0 	mov	x0, x19
  410018:	97fff996 	bl	40e670 <z_spin_unlock_valid>
  41001c:	72001c1f 	tst	w0, #0xff
  410020:	54000261 	b.ne	41006c <z_work_submit_to_queue+0x13c>  // b.any
  410024:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  410028:	91334a94 	add	x20, x20, #0xcd2
  41002c:	aa1403e2 	mov	x2, x20
  410030:	52801863 	mov	w3, #0xc3                  	// #195
  410034:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  410038:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  41003c:	9134b021 	add	x1, x1, #0xd2c
  410040:	911e2800 	add	x0, x0, #0x78a
  410044:	97ffded3 	bl	407b90 <assert_print>
  410048:	aa1303e1 	mov	x1, x19
  41004c:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410050:	91350c00 	add	x0, x0, #0xd43
  410054:	97ffdecf 	bl	407b90 <assert_print>
  410058:	aa1403e0 	mov	x0, x20
  41005c:	52801861 	mov	w1, #0xc3                  	// #195
  410060:	97ffdef6 	bl	407c38 <assert_post_action>
  410064:	52801862 	mov	w2, #0xc3                  	// #195
  410068:	17ffffe3 	b	40fff4 <z_work_submit_to_queue+0xc4>
	posix_irq_unlock(key);
  41006c:	2a1503e0 	mov	w0, w21
  410070:	97ffe7d0 	bl	409fb0 <posix_irq_unlock>
}
  410074:	2a1403e0 	mov	w0, w20
  410078:	a94153f3 	ldp	x19, x20, [sp, #16]
  41007c:	f94013f5 	ldr	x21, [sp, #32]
  410080:	a8c47bfd 	ldp	x29, x30, [sp], #64
  410084:	d65f03c0 	ret

0000000000410088 <k_work_submit_to_queue>:
{
  410088:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  41008c:	910003fd 	mov	x29, sp
  410090:	f9000bf3 	str	x19, [sp, #16]
	int ret = z_work_submit_to_queue(queue, work);
  410094:	97ffffa7 	bl	40ff30 <z_work_submit_to_queue>
  410098:	2a0003f3 	mov	w19, w0
	if (ret > 0) {
  41009c:	7100001f 	cmp	w0, #0x0
  4100a0:	5400006d 	b.le	4100ac <k_work_submit_to_queue+0x24>
	return posix_irq_lock();
  4100a4:	97ffe7c1 	bl	409fa8 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
  4100a8:	94000150 	bl	4105e8 <z_reschedule_irqlock>
}
  4100ac:	2a1303e0 	mov	w0, w19
  4100b0:	f9400bf3 	ldr	x19, [sp, #16]
  4100b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4100b8:	d65f03c0 	ret

00000000004100bc <k_work_submit>:
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
  4100bc:	aa0003e1 	mov	x1, x0
  4100c0:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4100c4:	f947f400 	ldr	x0, [x0, #4072]
  4100c8:	17fffff0 	b	410088 <k_work_submit_to_queue>

00000000004100cc <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
  4100cc:	d100c3ff 	sub	sp, sp, #0x30
  4100d0:	a9017bfd 	stp	x29, x30, [sp, #16]
  4100d4:	910043fd 	add	x29, sp, #0x10
  4100d8:	a90253f3 	stp	x19, x20, [sp, #32]
	__ASSERT_NO_MSG(queue);
  4100dc:	b5000240 	cbnz	x0, 410124 <k_work_queue_start+0x58>
  4100e0:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  4100e4:	91102e73 	add	x19, x19, #0x40b
  4100e8:	aa1303e2 	mov	x2, x19
  4100ec:	52805903 	mov	w3, #0x2c8                 	// #712
  4100f0:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  4100f4:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4100f8:	9111c821 	add	x1, x1, #0x472
  4100fc:	911e2800 	add	x0, x0, #0x78a
  410100:	97ffdea4 	bl	407b90 <assert_print>
  410104:	aa1303e0 	mov	x0, x19
  410108:	52805901 	mov	w1, #0x2c8                 	// #712
  41010c:	97ffdecb 	bl	407c38 <assert_post_action>
  410110:	52805902 	mov	w2, #0x2c8                 	// #712
	__ASSERT_NO_MSG(stack);
  410114:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410118:	aa1303e1 	mov	x1, x19
  41011c:	911f2000 	add	x0, x0, #0x7c8
  410120:	97ffe8b8 	bl	40a400 <posix_print_error_and_exit>
  410124:	b50001e1 	cbnz	x1, 410160 <k_work_queue_start+0x94>
  410128:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  41012c:	91102e73 	add	x19, x19, #0x40b
  410130:	aa1303e2 	mov	x2, x19
  410134:	52805923 	mov	w3, #0x2c9                 	// #713
  410138:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  41013c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410140:	9111e021 	add	x1, x1, #0x478
  410144:	911e2800 	add	x0, x0, #0x78a
  410148:	97ffde92 	bl	407b90 <assert_print>
  41014c:	aa1303e0 	mov	x0, x19
  410150:	52805921 	mov	w1, #0x2c9                 	// #713
  410154:	97ffdeb9 	bl	407c38 <assert_post_action>
  410158:	52805922 	mov	w2, #0x2c9                 	// #713
  41015c:	17ffffee 	b	410114 <k_work_queue_start+0x48>
  410160:	aa0003f3 	mov	x19, x0
	return (*flagp & BIT(bit)) != 0U;
  410164:	b940f000 	ldr	w0, [x0, #240]
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
  410168:	360001e0 	tbz	w0, #0, 4101a4 <k_work_queue_start+0xd8>
  41016c:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  410170:	91102e73 	add	x19, x19, #0x40b
  410174:	aa1303e2 	mov	x2, x19
  410178:	52805943 	mov	w3, #0x2ca                 	// #714
  41017c:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  410180:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410184:	9111f821 	add	x1, x1, #0x47e
  410188:	911e2800 	add	x0, x0, #0x78a
  41018c:	97ffde81 	bl	407b90 <assert_print>
  410190:	aa1303e0 	mov	x0, x19
  410194:	52805941 	mov	w1, #0x2ca                 	// #714
  410198:	97ffdea8 	bl	407c38 <assert_post_action>
  41019c:	52805942 	mov	w2, #0x2ca                 	// #714
  4101a0:	17ffffdd 	b	410114 <k_work_queue_start+0x48>
  4101a4:	91034260 	add	x0, x19, #0xd0
	list->tail = NULL;
  4101a8:	a90c7e7f 	stp	xzr, xzr, [x19, #192]
  4101ac:	2a0303e7 	mov	w7, w3
  4101b0:	a90d0260 	stp	x0, x0, [x19, #208]
  4101b4:	91038260 	add	x0, x19, #0xe0
  4101b8:	aa0403f4 	mov	x20, x4
  4101bc:	a90e0260 	stp	x0, x0, [x19, #224]

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
  4101c0:	b4000344 	cbz	x4, 410228 <k_work_queue_start+0x15c>
  4101c4:	39402080 	ldrb	w0, [x4, #8]
		flags |= K_WORK_QUEUE_NO_YIELD;
  4101c8:	7100001f 	cmp	w0, #0x0
  4101cc:	52802020 	mov	w0, #0x101                 	// #257
  4101d0:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
	*flagp = flags;
  4101d4:	b900f260 	str	w0, [x19, #240]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  4101d8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  4101dc:	b90003ff 	str	wzr, [sp]
  4101e0:	f90007e0 	str	x0, [sp, #8]
  4101e4:	f0ffffe3 	adrp	x3, 40f000 <z_impl_k_mutex_lock+0x200>
  4101e8:	aa1303e4 	mov	x4, x19
  4101ec:	91299063 	add	x3, x3, #0xa64
  4101f0:	aa1303e0 	mov	x0, x19
  4101f4:	d2800006 	mov	x6, #0x0                   	// #0
  4101f8:	d2800005 	mov	x5, #0x0                   	// #0
  4101fc:	97fff880 	bl	40e3fc <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
  410200:	b40000b4 	cbz	x20, 410214 <k_work_queue_start+0x148>
  410204:	f9400281 	ldr	x1, [x20]
  410208:	b4000061 	cbz	x1, 410214 <k_work_queue_start+0x148>
	return z_impl_k_thread_name_set(thread, str);
  41020c:	aa1303e0 	mov	x0, x19
  410210:	97fff806 	bl	40e228 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
  410214:	aa1303e0 	mov	x0, x19
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
  410218:	a9417bfd 	ldp	x29, x30, [sp, #16]
  41021c:	a94253f3 	ldp	x19, x20, [sp, #32]
  410220:	9100c3ff 	add	sp, sp, #0x30
  410224:	17fff814 	b	40e274 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
  410228:	52800020 	mov	w0, #0x1                   	// #1
  41022c:	17ffffea 	b	4101d4 <k_work_queue_start+0x108>

0000000000410230 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
  410230:	79403401 	ldrh	w1, [x0, #26]
  410234:	7101fc3f 	cmp	w1, #0x7f
  410238:	54000248 	b.hi	410280 <sliceable+0x50>  // b.pmore
	int ret = slice_ticks;
  41023c:	b00000e1 	adrp	x1, 42d000 <args_struct>
  410240:	b94c0c21 	ldr	w1, [x1, #3084]
		&& slice_time(thread) != 0
  410244:	340001a1 	cbz	w1, 410278 <sliceable+0x48>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
  410248:	b00000e1 	adrp	x1, 42d000 <args_struct>
  41024c:	39c06802 	ldrsb	w2, [x0, #26]
  410250:	b94c0821 	ldr	w1, [x1, #3080]
  410254:	6b01005f 	cmp	w2, w1
  410258:	5400014b 	b.lt	410280 <sliceable+0x50>  // b.tstop
		&& !z_is_thread_prevented_from_running(thread)
  41025c:	39406401 	ldrb	w1, [x0, #25]
  410260:	f240103f 	tst	x1, #0x1f
  410264:	540000e1 	b.ne	410280 <sliceable+0x50>  // b.any
		&& !z_is_idle_thread_object(thread);
  410268:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  41026c:	f946fc21 	ldr	x1, [x1, #3576]
  410270:	eb01001f 	cmp	x0, x1
  410274:	1a9f07e1 	cset	w1, ne  // ne = any
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
  410278:	12000020 	and	w0, w1, #0x1
  41027c:	d65f03c0 	ret
		&& !z_is_idle_thread_object(thread);
  410280:	52800001 	mov	w1, #0x0                   	// #0
  410284:	17fffffd 	b	410278 <sliceable+0x48>

0000000000410288 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  410288:	b4000160 	cbz	x0, 4102b4 <slice_timeout+0x2c>
  41028c:	b00000e1 	adrp	x1, 42d000 <args_struct>
  410290:	9125e021 	add	x1, x1, #0x978
  410294:	eb01001f 	cmp	x0, x1
  410298:	540000e3 	b.cc	4102b4 <slice_timeout+0x2c>  // b.lo, b.ul, b.last
  41029c:	91008022 	add	x2, x1, #0x20
  4102a0:	eb02001f 	cmp	x0, x2
  4102a4:	54000082 	b.cs	4102b4 <slice_timeout+0x2c>  // b.hs, b.nlast
  4102a8:	cb010000 	sub	x0, x0, x1
  4102ac:	f240101f 	tst	x0, #0x1f
  4102b0:	540002a0 	b.eq	410304 <slice_timeout+0x7c>  // b.none
{
  4102b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  4102b8:	528038e3 	mov	w3, #0x1c7                 	// #455
  4102bc:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
{
  4102c0:	910003fd 	mov	x29, sp
  4102c4:	f9000bf3 	str	x19, [sp, #16]
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  4102c8:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  4102cc:	9112ca73 	add	x19, x19, #0x4b2
  4102d0:	91135021 	add	x1, x1, #0x4d4
  4102d4:	aa1303e2 	mov	x2, x19
  4102d8:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4102dc:	911e2800 	add	x0, x0, #0x78a
  4102e0:	97ffde2c 	bl	407b90 <assert_print>
  4102e4:	aa1303e0 	mov	x0, x19
  4102e8:	528038e1 	mov	w1, #0x1c7                 	// #455
  4102ec:	97ffde53 	bl	407c38 <assert_post_action>
  4102f0:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4102f4:	aa1303e1 	mov	x1, x19
  4102f8:	911f2000 	add	x0, x0, #0x7c8
  4102fc:	528038e2 	mov	w2, #0x1c7                 	// #455
  410300:	97ffe840 	bl	40a400 <posix_print_error_and_exit>

	slice_expired[cpu] = true;
  410304:	93459000 	sbfx	x0, x0, #5, #32
  410308:	d00000e1 	adrp	x1, 42e000 <irq_prio+0xf>
  41030c:	91046021 	add	x1, x1, #0x118
  410310:	52800022 	mov	w2, #0x1                   	// #1
  410314:	38206822 	strb	w2, [x1, x0]
  410318:	d65f03c0 	ret

000000000041031c <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
  41031c:	39c06802 	ldrsb	w2, [x0, #26]
	int32_t b2 = thread_2->base.prio;
  410320:	39c06821 	ldrsb	w1, [x1, #26]
		return b2 - b1;
  410324:	4b020020 	sub	w0, w1, w2
  410328:	6b01005f 	cmp	w2, w1
}
  41032c:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  410330:	d65f03c0 	ret

0000000000410334 <z_reset_time_slice>:
		flag_ipi();
	}
}

void z_reset_time_slice(struct k_thread *curr)
{
  410334:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int cpu = _current_cpu->id;
  410338:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
{
  41033c:	910003fd 	mov	x29, sp
	int cpu = _current_cpu->id;
  410340:	f9472c21 	ldr	x1, [x1, #3672]
{
  410344:	a90153f3 	stp	x19, x20, [sp, #16]
  410348:	aa0003f4 	mov	x20, x0
  41034c:	f90013f5 	str	x21, [sp, #32]

	z_abort_timeout(&slice_timeouts[cpu]);
  410350:	b00000e0 	adrp	x0, 42d000 <args_struct>
  410354:	9125e000 	add	x0, x0, #0x978
  410358:	39408033 	ldrb	w19, [x1, #32]
	int cpu = _current_cpu->id;
  41035c:	39408035 	ldrb	w21, [x1, #32]
	z_abort_timeout(&slice_timeouts[cpu]);
  410360:	8b131413 	add	x19, x0, x19, lsl #5
  410364:	aa1303e0 	mov	x0, x19
  410368:	94000a17 	bl	412bc4 <z_abort_timeout>
	slice_expired[cpu] = false;
  41036c:	d00000e0 	adrp	x0, 42e000 <irq_prio+0xf>
  410370:	91046000 	add	x0, x0, #0x118
  410374:	3835c81f 	strb	wzr, [x0, w21, sxtw]
	if (sliceable(curr)) {
  410378:	aa1403e0 	mov	x0, x20
  41037c:	97ffffad 	bl	410230 <sliceable>
  410380:	72001c1f 	tst	w0, #0xff
  410384:	54000180 	b.eq	4103b4 <z_reset_time_slice+0x80>  // b.none
	int ret = slice_ticks;
  410388:	b00000e0 	adrp	x0, 42d000 <args_struct>
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  41038c:	90000001 	adrp	x1, 410000 <z_work_submit_to_queue+0xd0>
			      K_TICKS(slice_time(curr) - 1));
	}
}
  410390:	f94013f5 	ldr	x21, [sp, #32]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  410394:	910a2021 	add	x1, x1, #0x288
			      K_TICKS(slice_time(curr) - 1));
  410398:	b94c0c02 	ldr	w2, [x0, #3084]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  41039c:	aa1303e0 	mov	x0, x19
}
  4103a0:	a94153f3 	ldp	x19, x20, [sp, #16]
			      K_TICKS(slice_time(curr) - 1));
  4103a4:	51000442 	sub	w2, w2, #0x1
}
  4103a8:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  4103ac:	93407c42 	sxtw	x2, w2
  4103b0:	14000973 	b	41297c <z_add_timeout>
}
  4103b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4103b8:	f94013f5 	ldr	x21, [sp, #32]
  4103bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4103c0:	d65f03c0 	ret

00000000004103c4 <z_unpend_thread_no_timeout>:
	z_mark_thread_as_not_pending(thread);
	thread->base.pended_on = NULL;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
  4103c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4103c8:	910003fd 	mov	x29, sp
  4103cc:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4103d0:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  4103d4:	aa0003f4 	mov	x20, x0
  4103d8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4103dc:	97ffe6f3 	bl	409fa8 <posix_irq_lock>
  4103e0:	2a0003f5 	mov	w21, w0
  4103e4:	f947ca76 	ldr	x22, [x19, #3984]
  4103e8:	aa1603e0 	mov	x0, x22
  4103ec:	97fff896 	bl	40e644 <z_spin_lock_valid>
  4103f0:	72001c1f 	tst	w0, #0xff
  4103f4:	540002c1 	b.ne	41044c <z_unpend_thread_no_timeout+0x88>  // b.any
  4103f8:	b0000033 	adrp	x19, 415000 <random_data+0xca4>
  4103fc:	91334a73 	add	x19, x19, #0xcd2
  410400:	aa1303e2 	mov	x2, x19
  410404:	52801283 	mov	w3, #0x94                  	// #148
  410408:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  41040c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410410:	9133fc21 	add	x1, x1, #0xcff
  410414:	911e2800 	add	x0, x0, #0x78a
  410418:	97ffddde 	bl	407b90 <assert_print>
  41041c:	aa1603e1 	mov	x1, x22
  410420:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410424:	91345000 	add	x0, x0, #0xd14
  410428:	97ffddda 	bl	407b90 <assert_print>
  41042c:	52801281 	mov	w1, #0x94                  	// #148
  410430:	aa1303e0 	mov	x0, x19
  410434:	97ffde01 	bl	407c38 <assert_post_action>
  410438:	aa1303e1 	mov	x1, x19
  41043c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410440:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410444:	911f2000 	add	x0, x0, #0x7c8
  410448:	97ffe7ee 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  41044c:	aa1603e0 	mov	x0, x22
  410450:	97fff895 	bl	40e6a4 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		if (thread->base.pended_on != NULL) {
  410454:	f9400a80 	ldr	x0, [x20, #16]
  410458:	b4000060 	cbz	x0, 410464 <z_unpend_thread_no_timeout+0xa0>
			unpend_thread_no_timeout(thread);
  41045c:	aa1403e0 	mov	x0, x20
  410460:	940000f5 	bl	410834 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410464:	f947ca73 	ldr	x19, [x19, #3984]
  410468:	aa1303e0 	mov	x0, x19
  41046c:	97fff881 	bl	40e670 <z_spin_unlock_valid>
  410470:	72001c1f 	tst	w0, #0xff
  410474:	54000281 	b.ne	4104c4 <z_unpend_thread_no_timeout+0x100>  // b.any
  410478:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  41047c:	91334a94 	add	x20, x20, #0xcd2
  410480:	aa1403e2 	mov	x2, x20
  410484:	52801863 	mov	w3, #0xc3                  	// #195
  410488:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  41048c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410490:	9134b021 	add	x1, x1, #0xd2c
  410494:	911e2800 	add	x0, x0, #0x78a
  410498:	97ffddbe 	bl	407b90 <assert_print>
  41049c:	aa1303e1 	mov	x1, x19
  4104a0:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  4104a4:	91350c00 	add	x0, x0, #0xd43
  4104a8:	97ffddba 	bl	407b90 <assert_print>
  4104ac:	52801861 	mov	w1, #0xc3                  	// #195
  4104b0:	aa1403e0 	mov	x0, x20
  4104b4:	97ffdde1 	bl	407c38 <assert_post_action>
  4104b8:	aa1403e1 	mov	x1, x20
  4104bc:	52801862 	mov	w2, #0xc3                  	// #195
  4104c0:	17ffffe0 	b	410440 <z_unpend_thread_no_timeout+0x7c>
	posix_irq_unlock(key);
  4104c4:	2a1503e0 	mov	w0, w21
		}
	}
}
  4104c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4104cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4104d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4104d4:	17ffe6b7 	b	409fb0 <posix_irq_unlock>

00000000004104d8 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
  4104d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return _kernel.cpus[0].nested != 0U;
  4104dc:	f00000c2 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  4104e0:	910003fd 	mov	x29, sp
  4104e4:	f9472c42 	ldr	x2, [x2, #3672]
  4104e8:	a90153f3 	stp	x19, x20, [sp, #16]
  4104ec:	2a0103f3 	mov	w19, w1
  4104f0:	aa0003f4 	mov	x20, x0
	if (resched(key.key) && need_swap()) {
  4104f4:	b9400041 	ldr	w1, [x2]
  4104f8:	2a010261 	orr	w1, w19, w1
  4104fc:	35000421 	cbnz	w1, 410580 <z_reschedule+0xa8>
  410500:	f9400841 	ldr	x1, [x2, #16]
  410504:	f9401443 	ldr	x3, [x2, #40]
  410508:	eb01007f 	cmp	x3, x1
  41050c:	540003a0 	b.eq	410580 <z_reschedule+0xa8>  // b.none
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410510:	97fff858 	bl	40e670 <z_spin_unlock_valid>
  410514:	72001c1f 	tst	w0, #0xff
  410518:	540002c1 	b.ne	410570 <z_reschedule+0x98>  // b.any
  41051c:	b0000033 	adrp	x19, 415000 <random_data+0xca4>
  410520:	91334a73 	add	x19, x19, #0xcd2
  410524:	aa1303e2 	mov	x2, x19
  410528:	52801c43 	mov	w3, #0xe2                  	// #226
  41052c:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  410530:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410534:	9134b021 	add	x1, x1, #0xd2c
  410538:	911e2800 	add	x0, x0, #0x78a
  41053c:	97ffdd95 	bl	407b90 <assert_print>
  410540:	aa1403e1 	mov	x1, x20
  410544:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410548:	91350c00 	add	x0, x0, #0xd43
  41054c:	97ffdd91 	bl	407b90 <assert_print>
  410550:	aa1303e0 	mov	x0, x19
  410554:	52801c41 	mov	w1, #0xe2                  	// #226
  410558:	97ffddb8 	bl	407c38 <assert_post_action>
  41055c:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410560:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410564:	aa1303e1 	mov	x1, x19
  410568:	911f2000 	add	x0, x0, #0x7c8
  41056c:	97ffe7a5 	bl	40a400 <posix_print_error_and_exit>
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
  410570:	a94153f3 	ldp	x19, x20, [sp, #16]
	ret = arch_swap(key);
  410574:	52800000 	mov	w0, #0x0                   	// #0
  410578:	a8c27bfd 	ldp	x29, x30, [sp], #32
  41057c:	17ffe361 	b	409300 <arch_swap>
  410580:	aa1403e0 	mov	x0, x20
  410584:	97fff83b 	bl	40e670 <z_spin_unlock_valid>
  410588:	72001c1f 	tst	w0, #0xff
  41058c:	54000261 	b.ne	4105d8 <z_reschedule+0x100>  // b.any
  410590:	b0000033 	adrp	x19, 415000 <random_data+0xca4>
  410594:	91334a73 	add	x19, x19, #0xcd2
  410598:	aa1303e2 	mov	x2, x19
  41059c:	52801863 	mov	w3, #0xc3                  	// #195
  4105a0:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  4105a4:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4105a8:	9134b021 	add	x1, x1, #0xd2c
  4105ac:	911e2800 	add	x0, x0, #0x78a
  4105b0:	97ffdd78 	bl	407b90 <assert_print>
  4105b4:	aa1403e1 	mov	x1, x20
  4105b8:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  4105bc:	91350c00 	add	x0, x0, #0xd43
  4105c0:	97ffdd74 	bl	407b90 <assert_print>
  4105c4:	aa1303e0 	mov	x0, x19
  4105c8:	52801861 	mov	w1, #0xc3                  	// #195
  4105cc:	97ffdd9b 	bl	407c38 <assert_post_action>
  4105d0:	52801862 	mov	w2, #0xc3                  	// #195
  4105d4:	17ffffe3 	b	410560 <z_reschedule+0x88>
  4105d8:	2a1303e0 	mov	w0, w19
  4105dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4105e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4105e4:	17ffe673 	b	409fb0 <posix_irq_unlock>

00000000004105e8 <z_reschedule_irqlock>:
  4105e8:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4105ec:	f9472c21 	ldr	x1, [x1, #3672]

void z_reschedule_irqlock(uint32_t key)
{
	if (resched(key)) {
  4105f0:	b9400021 	ldr	w1, [x1]
  4105f4:	2a010001 	orr	w1, w0, w1
  4105f8:	35000061 	cbnz	w1, 410604 <z_reschedule_irqlock+0x1c>
  4105fc:	52800000 	mov	w0, #0x0                   	// #0
  410600:	17ffe340 	b	409300 <arch_swap>
  410604:	17ffe66b 	b	409fb0 <posix_irq_unlock>

0000000000410608 <z_reschedule_unlocked>:
{
  410608:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  41060c:	910003fd 	mov	x29, sp
	return posix_irq_lock();
  410610:	97ffe666 	bl	409fa8 <posix_irq_lock>
}
  410614:	a8c17bfd 	ldp	x29, x30, [sp], #16
	(void) z_reschedule_irqlock(arch_irq_lock());
  410618:	17fffff4 	b	4105e8 <z_reschedule_irqlock>

000000000041061c <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
  41061c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410620:	910003fd 	mov	x29, sp
  410624:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410628:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  41062c:	97ffe65f 	bl	409fa8 <posix_irq_lock>
  410630:	f947ca73 	ldr	x19, [x19, #3984]
  410634:	2a0003f4 	mov	w20, w0
  410638:	aa1303e0 	mov	x0, x19
  41063c:	97fff802 	bl	40e644 <z_spin_lock_valid>
  410640:	72001c1f 	tst	w0, #0xff
  410644:	54000281 	b.ne	410694 <k_sched_lock+0x78>  // b.any
  410648:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  41064c:	91334a94 	add	x20, x20, #0xcd2
  410650:	aa1403e2 	mov	x2, x20
  410654:	52801283 	mov	w3, #0x94                  	// #148
  410658:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  41065c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410660:	9133fc21 	add	x1, x1, #0xcff
  410664:	911e2800 	add	x0, x0, #0x78a
  410668:	97ffdd4a 	bl	407b90 <assert_print>
  41066c:	aa1303e1 	mov	x1, x19
  410670:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410674:	91345000 	add	x0, x0, #0xd14
  410678:	97ffdd46 	bl	407b90 <assert_print>
  41067c:	aa1403e0 	mov	x0, x20
  410680:	52801281 	mov	w1, #0x94                  	// #148
  410684:	97ffdd6d 	bl	407c38 <assert_post_action>
  410688:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41068c:	aa1403e1 	mov	x1, x20
  410690:	14000018 	b	4106f0 <k_sched_lock+0xd4>
	z_spin_lock_set_owner(l);
  410694:	aa1303e0 	mov	x0, x19
  410698:	97fff803 	bl	40e6a4 <z_spin_lock_set_owner>
  41069c:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4106a0:	f9472c21 	ldr	x1, [x1, #3672]
	__ASSERT(!arch_is_in_isr(), "");
  4106a4:	b9400020 	ldr	w0, [x1]
  4106a8:	340002a0 	cbz	w0, 4106fc <k_sched_lock+0xe0>
  4106ac:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  4106b0:	9119b673 	add	x19, x19, #0x66d
  4106b4:	aa1303e2 	mov	x2, x19
  4106b8:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  4106bc:	91089021 	add	x1, x1, #0x224
  4106c0:	52801fa3 	mov	w3, #0xfd                  	// #253
  4106c4:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4106c8:	911e2800 	add	x0, x0, #0x78a
  4106cc:	97ffdd31 	bl	407b90 <assert_print>
  4106d0:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  4106d4:	9135a400 	add	x0, x0, #0xd69
  4106d8:	97ffdd2e 	bl	407b90 <assert_print>
  4106dc:	aa1303e0 	mov	x0, x19
  4106e0:	52801fa1 	mov	w1, #0xfd                  	// #253
  4106e4:	97ffdd55 	bl	407c38 <assert_post_action>
  4106e8:	52801fa2 	mov	w2, #0xfd                  	// #253
  4106ec:	aa1303e1 	mov	x1, x19
  4106f0:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4106f4:	911f2000 	add	x0, x0, #0x7c8
  4106f8:	97ffe742 	bl	40a400 <posix_print_error_and_exit>
	__ASSERT(_current->base.sched_locked != 1U, "");
  4106fc:	f9400820 	ldr	x0, [x1, #16]
  410700:	39406c01 	ldrb	w1, [x0, #27]
  410704:	7100043f 	cmp	w1, #0x1
  410708:	54000241 	b.ne	410750 <k_sched_lock+0x134>  // b.any
  41070c:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  410710:	9119b673 	add	x19, x19, #0x66d
  410714:	aa1303e2 	mov	x2, x19
  410718:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  41071c:	911a6021 	add	x1, x1, #0x698
  410720:	52801fc3 	mov	w3, #0xfe                  	// #254
  410724:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410728:	911e2800 	add	x0, x0, #0x78a
  41072c:	97ffdd19 	bl	407b90 <assert_print>
  410730:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410734:	9135a400 	add	x0, x0, #0xd69
  410738:	97ffdd16 	bl	407b90 <assert_print>
  41073c:	aa1303e0 	mov	x0, x19
  410740:	52801fc1 	mov	w1, #0xfe                  	// #254
  410744:	97ffdd3d 	bl	407c38 <assert_post_action>
  410748:	52801fc2 	mov	w2, #0xfe                  	// #254
  41074c:	17ffffe8 	b	4106ec <k_sched_lock+0xd0>
	--_current->base.sched_locked;
  410750:	51000421 	sub	w1, w1, #0x1
  410754:	39006c01 	strb	w1, [x0, #27]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410758:	aa1303e0 	mov	x0, x19
  41075c:	97fff7c5 	bl	40e670 <z_spin_unlock_valid>
  410760:	72001c1f 	tst	w0, #0xff
  410764:	54000261 	b.ne	4107b0 <k_sched_lock+0x194>  // b.any
  410768:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  41076c:	91334a94 	add	x20, x20, #0xcd2
  410770:	aa1403e2 	mov	x2, x20
  410774:	52801863 	mov	w3, #0xc3                  	// #195
  410778:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  41077c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410780:	9134b021 	add	x1, x1, #0xd2c
  410784:	911e2800 	add	x0, x0, #0x78a
  410788:	97ffdd02 	bl	407b90 <assert_print>
  41078c:	aa1303e1 	mov	x1, x19
  410790:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410794:	91350c00 	add	x0, x0, #0xd43
  410798:	97ffdcfe 	bl	407b90 <assert_print>
  41079c:	aa1403e0 	mov	x0, x20
  4107a0:	52801861 	mov	w1, #0xc3                  	// #195
  4107a4:	97ffdd25 	bl	407c38 <assert_post_action>
  4107a8:	52801862 	mov	w2, #0xc3                  	// #195
  4107ac:	17ffffb8 	b	41068c <k_sched_lock+0x70>
	posix_irq_unlock(key);
  4107b0:	2a1403e0 	mov	w0, w20
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
  4107b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4107b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4107bc:	17ffe5fd 	b	409fb0 <posix_irq_unlock>

00000000004107c0 <z_priq_dumb_remove>:
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4107c0:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4107c4:	f946fc00 	ldr	x0, [x0, #3576]
  4107c8:	eb00003f 	cmp	x1, x0
  4107cc:	540002a1 	b.ne	410820 <z_priq_dumb_remove+0x60>  // b.any
{
  4107d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4107d4:	52808f63 	mov	w3, #0x47b                 	// #1147
  4107d8:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
{
  4107dc:	910003fd 	mov	x29, sp
  4107e0:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4107e4:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  4107e8:	9112ca73 	add	x19, x19, #0x4b2
  4107ec:	911b2421 	add	x1, x1, #0x6c9
  4107f0:	aa1303e2 	mov	x2, x19
  4107f4:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4107f8:	911e2800 	add	x0, x0, #0x78a
  4107fc:	97ffdce5 	bl	407b90 <assert_print>
  410800:	aa1303e0 	mov	x0, x19
  410804:	52808f61 	mov	w1, #0x47b                 	// #1147
  410808:	97ffdd0c 	bl	407c38 <assert_post_action>
  41080c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410810:	aa1303e1 	mov	x1, x19
  410814:	911f2000 	add	x0, x0, #0x7c8
  410818:	52808f62 	mov	w2, #0x47b                 	// #1147
  41081c:	97ffe6f9 	bl	40a400 <posix_print_error_and_exit>
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
  410820:	a9400820 	ldp	x0, x2, [x1]
	sys_dnode_t *const next = node->next;

	prev->next = next;
  410824:	f9000040 	str	x0, [x2]
	next->prev = prev;
  410828:	f9000402 	str	x2, [x0, #8]
	node->prev = NULL;
  41082c:	a9007c3f 	stp	xzr, xzr, [x1]
  410830:	d65f03c0 	ret

0000000000410834 <unpend_thread_no_timeout>:
{
  410834:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410838:	910003fd 	mov	x29, sp
  41083c:	f9000bf3 	str	x19, [sp, #16]
  410840:	aa0003f3 	mov	x19, x0
  410844:	f9400800 	ldr	x0, [x0, #16]
	__ASSERT_NO_MSG(thread->base.pended_on);
  410848:	b5000240 	cbnz	x0, 410890 <unpend_thread_no_timeout+0x5c>
  41084c:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  410850:	9112ca73 	add	x19, x19, #0x4b2
  410854:	aa1303e2 	mov	x2, x19
  410858:	528058a3 	mov	w3, #0x2c5                 	// #709
  41085c:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  410860:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410864:	911ba821 	add	x1, x1, #0x6ea
  410868:	911e2800 	add	x0, x0, #0x78a
  41086c:	97ffdcc9 	bl	407b90 <assert_print>
  410870:	aa1303e0 	mov	x0, x19
  410874:	528058a1 	mov	w1, #0x2c5                 	// #709
  410878:	97ffdcf0 	bl	407c38 <assert_post_action>
  41087c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410880:	aa1303e1 	mov	x1, x19
  410884:	911f2000 	add	x0, x0, #0x7c8
  410888:	528058a2 	mov	w2, #0x2c5                 	// #709
  41088c:	97ffe6dd 	bl	40a400 <posix_print_error_and_exit>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
  410890:	aa1303e1 	mov	x1, x19
  410894:	97ffffcb 	bl	4107c0 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  410898:	39406660 	ldrb	w0, [x19, #25]
	thread->base.pended_on = NULL;
  41089c:	f9000a7f 	str	xzr, [x19, #16]
  4108a0:	121e7800 	and	w0, w0, #0xfffffffd
  4108a4:	39006660 	strb	w0, [x19, #25]
}
  4108a8:	f9400bf3 	ldr	x19, [sp, #16]
  4108ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4108b0:	d65f03c0 	ret

00000000004108b4 <z_unpend_thread>:
{
  4108b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4108b8:	910003fd 	mov	x29, sp
  4108bc:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4108c0:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  4108c4:	aa0003f4 	mov	x20, x0
  4108c8:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  4108cc:	97ffe5b7 	bl	409fa8 <posix_irq_lock>
  4108d0:	2a0003f5 	mov	w21, w0
  4108d4:	f947ca76 	ldr	x22, [x19, #3984]
  4108d8:	aa1603e0 	mov	x0, x22
  4108dc:	97fff75a 	bl	40e644 <z_spin_lock_valid>
  4108e0:	72001c1f 	tst	w0, #0xff
  4108e4:	540002c1 	b.ne	41093c <z_unpend_thread+0x88>  // b.any
  4108e8:	b0000033 	adrp	x19, 415000 <random_data+0xca4>
  4108ec:	91334a73 	add	x19, x19, #0xcd2
  4108f0:	aa1303e2 	mov	x2, x19
  4108f4:	52801283 	mov	w3, #0x94                  	// #148
  4108f8:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  4108fc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410900:	9133fc21 	add	x1, x1, #0xcff
  410904:	911e2800 	add	x0, x0, #0x78a
  410908:	97ffdca2 	bl	407b90 <assert_print>
  41090c:	aa1603e1 	mov	x1, x22
  410910:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410914:	91345000 	add	x0, x0, #0xd14
  410918:	97ffdc9e 	bl	407b90 <assert_print>
  41091c:	52801281 	mov	w1, #0x94                  	// #148
  410920:	aa1303e0 	mov	x0, x19
  410924:	97ffdcc5 	bl	407c38 <assert_post_action>
  410928:	aa1303e1 	mov	x1, x19
  41092c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410930:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410934:	911f2000 	add	x0, x0, #0x7c8
  410938:	97ffe6b2 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  41093c:	aa1603e0 	mov	x0, x22
  410940:	97fff759 	bl	40e6a4 <z_spin_lock_set_owner>
		if (thread->base.pended_on != NULL) {
  410944:	f9400a80 	ldr	x0, [x20, #16]
  410948:	b4000060 	cbz	x0, 410954 <z_unpend_thread+0xa0>
			unpend_thread_no_timeout(thread);
  41094c:	aa1403e0 	mov	x0, x20
  410950:	97ffffb9 	bl	410834 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410954:	f947ca73 	ldr	x19, [x19, #3984]
  410958:	aa1303e0 	mov	x0, x19
  41095c:	97fff745 	bl	40e670 <z_spin_unlock_valid>
  410960:	72001c1f 	tst	w0, #0xff
  410964:	54000281 	b.ne	4109b4 <z_unpend_thread+0x100>  // b.any
  410968:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  41096c:	91334a94 	add	x20, x20, #0xcd2
  410970:	aa1403e2 	mov	x2, x20
  410974:	52801863 	mov	w3, #0xc3                  	// #195
  410978:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  41097c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410980:	9134b021 	add	x1, x1, #0xd2c
  410984:	911e2800 	add	x0, x0, #0x78a
  410988:	97ffdc82 	bl	407b90 <assert_print>
  41098c:	aa1303e1 	mov	x1, x19
  410990:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410994:	91350c00 	add	x0, x0, #0xd43
  410998:	97ffdc7e 	bl	407b90 <assert_print>
  41099c:	52801861 	mov	w1, #0xc3                  	// #195
  4109a0:	aa1403e0 	mov	x0, x20
  4109a4:	97ffdca5 	bl	407c38 <assert_post_action>
  4109a8:	aa1403e1 	mov	x1, x20
  4109ac:	52801862 	mov	w2, #0xc3                  	// #195
  4109b0:	17ffffe0 	b	410930 <z_unpend_thread+0x7c>
	posix_irq_unlock(key);
  4109b4:	2a1503e0 	mov	w0, w21
  4109b8:	97ffe57e 	bl	409fb0 <posix_irq_unlock>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  4109bc:	9100a280 	add	x0, x20, #0x28
}
  4109c0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4109c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4109c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4109cc:	1400087e 	b	412bc4 <z_abort_timeout>

00000000004109d0 <z_priq_dumb_best>:
	return list->head == list;
  4109d0:	f9400001 	ldr	x1, [x0]
	sys_dlist_remove(&thread->base.qnode_dlist);
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
  4109d4:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
  4109d8:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
  4109dc:	d65f03c0 	ret

00000000004109e0 <update_cache>:
{
  4109e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4109e4:	910003fd 	mov	x29, sp
  4109e8:	a90153f3 	stp	x19, x20, [sp, #16]
	return _priq_run_best(curr_cpu_runq());
  4109ec:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
{
  4109f0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4109f4:	2a0003f5 	mov	w21, w0
	return _priq_run_best(curr_cpu_runq());
  4109f8:	f9472e76 	ldr	x22, [x19, #3672]
  4109fc:	9100c2c0 	add	x0, x22, #0x30
  410a00:	97fffff4 	bl	4109d0 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
  410a04:	b5000340 	cbnz	x0, 410a6c <update_cache+0x8c>
  410a08:	f9400ed4 	ldr	x20, [x22, #24]
	__ASSERT(_current != NULL, "");
  410a0c:	f9472e60 	ldr	x0, [x19, #3672]
  410a10:	f9400801 	ldr	x1, [x0, #16]
	if (preempt_ok != 0) {
  410a14:	350003d5 	cbnz	w21, 410a8c <update_cache+0xac>
	__ASSERT(_current != NULL, "");
  410a18:	b50002e1 	cbnz	x1, 410a74 <update_cache+0x94>
  410a1c:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  410a20:	9112ca73 	add	x19, x19, #0x4b2
  410a24:	aa1303e2 	mov	x2, x19
  410a28:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  410a2c:	911c0421 	add	x1, x1, #0x701
  410a30:	52801143 	mov	w3, #0x8a                  	// #138
  410a34:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410a38:	911e2800 	add	x0, x0, #0x78a
  410a3c:	97ffdc55 	bl	407b90 <assert_print>
  410a40:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410a44:	9135a400 	add	x0, x0, #0xd69
  410a48:	97ffdc52 	bl	407b90 <assert_print>
  410a4c:	aa1303e0 	mov	x0, x19
  410a50:	52801141 	mov	w1, #0x8a                  	// #138
  410a54:	97ffdc79 	bl	407c38 <assert_post_action>
  410a58:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410a5c:	aa1303e1 	mov	x1, x19
  410a60:	911f2000 	add	x0, x0, #0x7c8
  410a64:	52801142 	mov	w2, #0x8a                  	// #138
  410a68:	97ffe666 	bl	40a400 <posix_print_error_and_exit>
  410a6c:	aa0003f4 	mov	x20, x0
  410a70:	17ffffe7 	b	410a0c <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
  410a74:	39406420 	ldrb	w0, [x1, #25]
  410a78:	f240101f 	tst	x0, #0x1f
  410a7c:	54000081 	b.ne	410a8c <update_cache+0xac>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
  410a80:	79403420 	ldrh	w0, [x1, #26]
  410a84:	7101fc1f 	cmp	w0, #0x7f
  410a88:	540000c8 	b.hi	410aa0 <update_cache+0xc0>  // b.pmore
		if (thread != _current) {
  410a8c:	eb01029f 	cmp	x20, x1
  410a90:	54000060 	b.eq	410a9c <update_cache+0xbc>  // b.none
			z_reset_time_slice(thread);
  410a94:	aa1403e0 	mov	x0, x20
  410a98:	97fffe27 	bl	410334 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
  410a9c:	aa1403e1 	mov	x1, x20
  410aa0:	f9472e73 	ldr	x19, [x19, #3672]
  410aa4:	f9001661 	str	x1, [x19, #40]
}
  410aa8:	a94153f3 	ldp	x19, x20, [sp, #16]
  410aac:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410ab0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410ab4:	d65f03c0 	ret

0000000000410ab8 <move_thread_to_end_of_prio_q>:
{
  410ab8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410abc:	910003fd 	mov	x29, sp
  410ac0:	a90153f3 	stp	x19, x20, [sp, #16]
  410ac4:	aa0003f3 	mov	x19, x0
  410ac8:	a9025bf5 	stp	x21, x22, [sp, #32]
  410acc:	f00000d5 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
	if (z_is_thread_queued(thread)) {
  410ad0:	39c06661 	ldrsb	w1, [x19, #25]
	return (thread->base.thread_state & state) != 0U;
  410ad4:	39406400 	ldrb	w0, [x0, #25]
  410ad8:	36f800e1 	tbz	w1, #31, 410af4 <move_thread_to_end_of_prio_q+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  410adc:	12001800 	and	w0, w0, #0x7f
  410ae0:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  410ae4:	f9472ea0 	ldr	x0, [x21, #3672]
  410ae8:	aa1303e1 	mov	x1, x19
  410aec:	9100c000 	add	x0, x0, #0x30
  410af0:	97ffff34 	bl	4107c0 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  410af4:	39406660 	ldrb	w0, [x19, #25]
  410af8:	32196000 	orr	w0, w0, #0xffffff80
  410afc:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410b00:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  410b04:	f946fc00 	ldr	x0, [x0, #3576]
  410b08:	eb00027f 	cmp	x19, x0
  410b0c:	54000241 	b.ne	410b54 <move_thread_to_end_of_prio_q+0x9c>  // b.any
  410b10:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  410b14:	9112ca73 	add	x19, x19, #0x4b2
  410b18:	aa1303e2 	mov	x2, x19
  410b1c:	52801783 	mov	w3, #0xbc                  	// #188
  410b20:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  410b24:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410b28:	911b2421 	add	x1, x1, #0x6c9
  410b2c:	911e2800 	add	x0, x0, #0x78a
  410b30:	97ffdc18 	bl	407b90 <assert_print>
  410b34:	aa1303e0 	mov	x0, x19
  410b38:	52801781 	mov	w1, #0xbc                  	// #188
  410b3c:	97ffdc3f 	bl	407c38 <assert_post_action>
  410b40:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410b44:	aa1303e1 	mov	x1, x19
  410b48:	911f2000 	add	x0, x0, #0x7c8
  410b4c:	52801782 	mov	w2, #0xbc                  	// #188
  410b50:	97ffe62c 	bl	40a400 <posix_print_error_and_exit>
  410b54:	f9472eb6 	ldr	x22, [x21, #3672]
  410b58:	aa1603e0 	mov	x0, x22
  410b5c:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  410b60:	eb00029f 	cmp	x20, x0
  410b64:	54000261 	b.ne	410bb0 <move_thread_to_end_of_prio_q+0xf8>  // b.any
	sys_dnode_t *const tail = list->tail;
  410b68:	f9472ea0 	ldr	x0, [x21, #3672]
	node->next = list;
  410b6c:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  410b70:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  410b74:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  410b78:	f9000033 	str	x19, [x1]
	list->tail = node;
  410b7c:	f9001c13 	str	x19, [x0, #56]
	update_cache(thread == _current);
  410b80:	f9472eb5 	ldr	x21, [x21, #3672]
  410b84:	f9400aa0 	ldr	x0, [x21, #16]
}
  410b88:	a9425bf5 	ldp	x21, x22, [sp, #32]
	update_cache(thread == _current);
  410b8c:	eb13001f 	cmp	x0, x19
}
  410b90:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  410b94:	1a9f17e0 	cset	w0, eq  // eq = none
}
  410b98:	a8c37bfd 	ldp	x29, x30, [sp], #48
	update_cache(thread == _current);
  410b9c:	17ffff91 	b	4109e0 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  410ba0:	f9401ec0 	ldr	x0, [x22, #56]
  410ba4:	eb14001f 	cmp	x0, x20
  410ba8:	54fffe00 	b.eq	410b68 <move_thread_to_end_of_prio_q+0xb0>  // b.none
  410bac:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  410bb0:	b4fffdd4 	cbz	x20, 410b68 <move_thread_to_end_of_prio_q+0xb0>
		if (z_sched_prio_cmp(thread, t) > 0) {
  410bb4:	aa1403e1 	mov	x1, x20
  410bb8:	aa1303e0 	mov	x0, x19
  410bbc:	97fffdd8 	bl	41031c <z_sched_prio_cmp>
  410bc0:	7100001f 	cmp	w0, #0x0
  410bc4:	54fffeed 	b.le	410ba0 <move_thread_to_end_of_prio_q+0xe8>
	sys_dnode_t *const prev = successor->prev;
  410bc8:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  410bcc:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  410bd0:	f9000013 	str	x19, [x0]
	successor->prev = node;
  410bd4:	f9000693 	str	x19, [x20, #8]
}
  410bd8:	17ffffea 	b	410b80 <move_thread_to_end_of_prio_q+0xc8>

0000000000410bdc <z_time_slice>:
{
  410bdc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410be0:	910003fd 	mov	x29, sp
  410be4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410be8:	f00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  410bec:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  410bf0:	97ffe4ee 	bl	409fa8 <posix_irq_lock>
  410bf4:	2a0003f6 	mov	w22, w0
  410bf8:	f947ca95 	ldr	x21, [x20, #3984]
  410bfc:	aa1503e0 	mov	x0, x21
  410c00:	97fff691 	bl	40e644 <z_spin_lock_valid>
  410c04:	72001c1f 	tst	w0, #0xff
  410c08:	540002c1 	b.ne	410c60 <z_time_slice+0x84>  // b.any
  410c0c:	b0000033 	adrp	x19, 415000 <random_data+0xca4>
  410c10:	91334a73 	add	x19, x19, #0xcd2
  410c14:	aa1303e2 	mov	x2, x19
  410c18:	52801283 	mov	w3, #0x94                  	// #148
  410c1c:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  410c20:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410c24:	9133fc21 	add	x1, x1, #0xcff
  410c28:	911e2800 	add	x0, x0, #0x78a
  410c2c:	97ffdbd9 	bl	407b90 <assert_print>
  410c30:	aa1503e1 	mov	x1, x21
  410c34:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410c38:	91345000 	add	x0, x0, #0xd14
  410c3c:	97ffdbd5 	bl	407b90 <assert_print>
  410c40:	aa1303e0 	mov	x0, x19
  410c44:	52801281 	mov	w1, #0x94                  	// #148
  410c48:	97ffdbfc 	bl	407c38 <assert_post_action>
  410c4c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410c50:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410c54:	aa1303e1 	mov	x1, x19
  410c58:	911f2000 	add	x0, x0, #0x7c8
  410c5c:	97ffe5e9 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410c60:	aa1503e0 	mov	x0, x21
  410c64:	97fff690 	bl	40e6a4 <z_spin_lock_set_owner>
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  410c68:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  410c6c:	d00000e2 	adrp	x2, 42e000 <irq_prio+0xf>
  410c70:	91046042 	add	x2, x2, #0x118
  410c74:	f9472c21 	ldr	x1, [x1, #3672]
  410c78:	39408020 	ldrb	w0, [x1, #32]
  410c7c:	38606840 	ldrb	w0, [x2, x0]
  410c80:	340001a0 	cbz	w0, 410cb4 <z_time_slice+0xd8>
	struct k_thread *curr = _current;
  410c84:	f9400833 	ldr	x19, [x1, #16]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  410c88:	aa1303e0 	mov	x0, x19
  410c8c:	97fffd69 	bl	410230 <sliceable>
  410c90:	72001c1f 	tst	w0, #0xff
  410c94:	54000100 	b.eq	410cb4 <z_time_slice+0xd8>  // b.none
		if (!z_is_thread_prevented_from_running(curr)) {
  410c98:	39406660 	ldrb	w0, [x19, #25]
  410c9c:	f240101f 	tst	x0, #0x1f
  410ca0:	54000061 	b.ne	410cac <z_time_slice+0xd0>  // b.any
			move_thread_to_end_of_prio_q(curr);
  410ca4:	aa1303e0 	mov	x0, x19
  410ca8:	97ffff84 	bl	410ab8 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
  410cac:	aa1303e0 	mov	x0, x19
  410cb0:	97fffda1 	bl	410334 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410cb4:	f947ca94 	ldr	x20, [x20, #3984]
  410cb8:	aa1403e0 	mov	x0, x20
  410cbc:	97fff66d 	bl	40e670 <z_spin_unlock_valid>
  410cc0:	72001c1f 	tst	w0, #0xff
  410cc4:	54000261 	b.ne	410d10 <z_time_slice+0x134>  // b.any
  410cc8:	b0000033 	adrp	x19, 415000 <random_data+0xca4>
  410ccc:	91334a73 	add	x19, x19, #0xcd2
  410cd0:	aa1303e2 	mov	x2, x19
  410cd4:	52801863 	mov	w3, #0xc3                  	// #195
  410cd8:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  410cdc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410ce0:	9134b021 	add	x1, x1, #0xd2c
  410ce4:	911e2800 	add	x0, x0, #0x78a
  410ce8:	97ffdbaa 	bl	407b90 <assert_print>
  410cec:	aa1403e1 	mov	x1, x20
  410cf0:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410cf4:	91350c00 	add	x0, x0, #0xd43
  410cf8:	97ffdba6 	bl	407b90 <assert_print>
  410cfc:	aa1303e0 	mov	x0, x19
  410d00:	52801861 	mov	w1, #0xc3                  	// #195
  410d04:	97ffdbcd 	bl	407c38 <assert_post_action>
  410d08:	52801862 	mov	w2, #0xc3                  	// #195
  410d0c:	17ffffd1 	b	410c50 <z_time_slice+0x74>
	posix_irq_unlock(key);
  410d10:	2a1603e0 	mov	w0, w22
}
  410d14:	a94153f3 	ldp	x19, x20, [sp, #16]
  410d18:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410d1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410d20:	17ffe4a4 	b	409fb0 <posix_irq_unlock>

0000000000410d24 <ready_thread>:
{
  410d24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410d28:	910003fd 	mov	x29, sp
  410d2c:	a90153f3 	stp	x19, x20, [sp, #16]
  410d30:	aa0003f3 	mov	x19, x0
  410d34:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  410d38:	39c06661 	ldrsb	w1, [x19, #25]
  410d3c:	39406400 	ldrb	w0, [x0, #25]
  410d40:	37f807a1 	tbnz	w1, #31, 410e34 <ready_thread+0x110>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  410d44:	f240101f 	tst	x0, #0x1f
  410d48:	54000761 	b.ne	410e34 <ready_thread+0x110>  // b.any
  410d4c:	f9401661 	ldr	x1, [x19, #40]
  410d50:	b5000721 	cbnz	x1, 410e34 <ready_thread+0x110>
	thread->base.thread_state |= _THREAD_QUEUED;
  410d54:	32196000 	orr	w0, w0, #0xffffff80
  410d58:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410d5c:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  410d60:	f946fc00 	ldr	x0, [x0, #3576]
  410d64:	eb00027f 	cmp	x19, x0
  410d68:	54000241 	b.ne	410db0 <ready_thread+0x8c>  // b.any
  410d6c:	d0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  410d70:	9112ca73 	add	x19, x19, #0x4b2
  410d74:	aa1303e2 	mov	x2, x19
  410d78:	52801783 	mov	w3, #0xbc                  	// #188
  410d7c:	d0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  410d80:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410d84:	911b2421 	add	x1, x1, #0x6c9
  410d88:	911e2800 	add	x0, x0, #0x78a
  410d8c:	97ffdb81 	bl	407b90 <assert_print>
  410d90:	aa1303e0 	mov	x0, x19
  410d94:	52801781 	mov	w1, #0xbc                  	// #188
  410d98:	97ffdba8 	bl	407c38 <assert_post_action>
  410d9c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410da0:	aa1303e1 	mov	x1, x19
  410da4:	911f2000 	add	x0, x0, #0x7c8
  410da8:	52801782 	mov	w2, #0xbc                  	// #188
  410dac:	97ffe595 	bl	40a400 <posix_print_error_and_exit>
	return list->head == list;
  410db0:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  410db4:	aa0003f5 	mov	x21, x0
  410db8:	f9472c16 	ldr	x22, [x0, #3672]
  410dbc:	aa1603e1 	mov	x1, x22
  410dc0:	f8430c34 	ldr	x20, [x1, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  410dc4:	eb01029f 	cmp	x20, x1
  410dc8:	54000201 	b.ne	410e08 <ready_thread+0xe4>  // b.any
	sys_dnode_t *const tail = list->tail;
  410dcc:	f9472ea0 	ldr	x0, [x21, #3672]
	node->next = list;
  410dd0:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  410dd4:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  410dd8:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  410ddc:	f9000033 	str	x19, [x1]
	list->tail = node;
  410de0:	f9001c13 	str	x19, [x0, #56]
}
  410de4:	a94153f3 	ldp	x19, x20, [sp, #16]
		update_cache(0);
  410de8:	52800000 	mov	w0, #0x0                   	// #0
}
  410dec:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410df0:	a8c37bfd 	ldp	x29, x30, [sp], #48
		update_cache(0);
  410df4:	17fffefb 	b	4109e0 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  410df8:	f9401ec0 	ldr	x0, [x22, #56]
  410dfc:	eb14001f 	cmp	x0, x20
  410e00:	54fffe60 	b.eq	410dcc <ready_thread+0xa8>  // b.none
  410e04:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  410e08:	b4fffe34 	cbz	x20, 410dcc <ready_thread+0xa8>
		if (z_sched_prio_cmp(thread, t) > 0) {
  410e0c:	aa1403e1 	mov	x1, x20
  410e10:	aa1303e0 	mov	x0, x19
  410e14:	97fffd42 	bl	41031c <z_sched_prio_cmp>
  410e18:	7100001f 	cmp	w0, #0x0
  410e1c:	54fffeed 	b.le	410df8 <ready_thread+0xd4>
	sys_dnode_t *const prev = successor->prev;
  410e20:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  410e24:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  410e28:	f9000013 	str	x19, [x0]
	successor->prev = node;
  410e2c:	f9000693 	str	x19, [x20, #8]
}
  410e30:	17ffffed 	b	410de4 <ready_thread+0xc0>
}
  410e34:	a94153f3 	ldp	x19, x20, [sp, #16]
  410e38:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410e3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410e40:	d65f03c0 	ret

0000000000410e44 <z_ready_thread>:
{
  410e44:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410e48:	910003fd 	mov	x29, sp
  410e4c:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410e50:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  410e54:	f90013f5 	str	x21, [sp, #32]
  410e58:	aa0003f5 	mov	x21, x0
	return posix_irq_lock();
  410e5c:	97ffe453 	bl	409fa8 <posix_irq_lock>
  410e60:	2a0003f4 	mov	w20, w0
  410e64:	f947ca73 	ldr	x19, [x19, #3984]
  410e68:	aa1303e0 	mov	x0, x19
  410e6c:	97fff5f6 	bl	40e644 <z_spin_lock_valid>
  410e70:	72001c1f 	tst	w0, #0xff
  410e74:	540002c1 	b.ne	410ecc <z_ready_thread+0x88>  // b.any
  410e78:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  410e7c:	91334a94 	add	x20, x20, #0xcd2
  410e80:	aa1403e2 	mov	x2, x20
  410e84:	52801283 	mov	w3, #0x94                  	// #148
  410e88:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  410e8c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410e90:	9133fc21 	add	x1, x1, #0xcff
  410e94:	911e2800 	add	x0, x0, #0x78a
  410e98:	97ffdb3e 	bl	407b90 <assert_print>
  410e9c:	aa1303e1 	mov	x1, x19
  410ea0:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410ea4:	91345000 	add	x0, x0, #0xd14
  410ea8:	97ffdb3a 	bl	407b90 <assert_print>
  410eac:	aa1403e0 	mov	x0, x20
  410eb0:	52801281 	mov	w1, #0x94                  	// #148
  410eb4:	97ffdb61 	bl	407c38 <assert_post_action>
  410eb8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410ebc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410ec0:	aa1403e1 	mov	x1, x20
  410ec4:	911f2000 	add	x0, x0, #0x7c8
  410ec8:	97ffe54e 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410ecc:	aa1303e0 	mov	x0, x19
  410ed0:	97fff5f5 	bl	40e6a4 <z_spin_lock_set_owner>
			ready_thread(thread);
  410ed4:	aa1503e0 	mov	x0, x21
  410ed8:	97ffff93 	bl	410d24 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410edc:	aa1303e0 	mov	x0, x19
  410ee0:	97fff5e4 	bl	40e670 <z_spin_unlock_valid>
  410ee4:	72001c1f 	tst	w0, #0xff
  410ee8:	54000261 	b.ne	410f34 <z_ready_thread+0xf0>  // b.any
  410eec:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  410ef0:	91334a94 	add	x20, x20, #0xcd2
  410ef4:	aa1403e2 	mov	x2, x20
  410ef8:	52801863 	mov	w3, #0xc3                  	// #195
  410efc:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  410f00:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410f04:	9134b021 	add	x1, x1, #0xd2c
  410f08:	911e2800 	add	x0, x0, #0x78a
  410f0c:	97ffdb21 	bl	407b90 <assert_print>
  410f10:	aa1303e1 	mov	x1, x19
  410f14:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410f18:	91350c00 	add	x0, x0, #0xd43
  410f1c:	97ffdb1d 	bl	407b90 <assert_print>
  410f20:	aa1403e0 	mov	x0, x20
  410f24:	52801861 	mov	w1, #0xc3                  	// #195
  410f28:	97ffdb44 	bl	407c38 <assert_post_action>
  410f2c:	52801862 	mov	w2, #0xc3                  	// #195
  410f30:	17ffffe3 	b	410ebc <z_ready_thread+0x78>
	posix_irq_unlock(key);
  410f34:	2a1403e0 	mov	w0, w20
}
  410f38:	a94153f3 	ldp	x19, x20, [sp, #16]
  410f3c:	f94013f5 	ldr	x21, [sp, #32]
  410f40:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410f44:	17ffe41b 	b	409fb0 <posix_irq_unlock>

0000000000410f48 <z_sched_start>:
{
  410f48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410f4c:	910003fd 	mov	x29, sp
  410f50:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410f54:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  410f58:	aa0003f4 	mov	x20, x0
  410f5c:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  410f60:	97ffe412 	bl	409fa8 <posix_irq_lock>
  410f64:	f947ca73 	ldr	x19, [x19, #3984]
  410f68:	2a0003f5 	mov	w21, w0
  410f6c:	aa1303e0 	mov	x0, x19
  410f70:	97fff5b5 	bl	40e644 <z_spin_lock_valid>
  410f74:	72001c1f 	tst	w0, #0xff
  410f78:	540002c1 	b.ne	410fd0 <z_sched_start+0x88>  // b.any
  410f7c:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  410f80:	91334a94 	add	x20, x20, #0xcd2
  410f84:	aa1403e2 	mov	x2, x20
  410f88:	52801283 	mov	w3, #0x94                  	// #148
  410f8c:	b0000021 	adrp	x1, 415000 <random_data+0xca4>
  410f90:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410f94:	9133fc21 	add	x1, x1, #0xcff
  410f98:	911e2800 	add	x0, x0, #0x78a
  410f9c:	97ffdafd 	bl	407b90 <assert_print>
  410fa0:	aa1303e1 	mov	x1, x19
  410fa4:	b0000020 	adrp	x0, 415000 <random_data+0xca4>
  410fa8:	91345000 	add	x0, x0, #0xd14
  410fac:	97ffdaf9 	bl	407b90 <assert_print>
  410fb0:	aa1403e0 	mov	x0, x20
  410fb4:	52801281 	mov	w1, #0x94                  	// #148
  410fb8:	97ffdb20 	bl	407c38 <assert_post_action>
  410fbc:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410fc0:	90000020 	adrp	x0, 414000 <dlc_table.0+0x78d>
  410fc4:	aa1403e1 	mov	x1, x20
  410fc8:	911f2000 	add	x0, x0, #0x7c8
  410fcc:	97ffe50d 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410fd0:	aa1303e0 	mov	x0, x19
  410fd4:	97fff5b4 	bl	40e6a4 <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
  410fd8:	39406680 	ldrb	w0, [x20, #25]
	if (z_has_thread_started(thread)) {
  410fdc:	37100380 	tbnz	w0, #2, 41104c <z_sched_start+0x104>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410fe0:	aa1303e0 	mov	x0, x19
  410fe4:	97fff5a3 	bl	40e670 <z_spin_unlock_valid>
  410fe8:	72001c1f 	tst	w0, #0xff
  410fec:	54000261 	b.ne	411038 <z_sched_start+0xf0>  // b.any
  410ff0:	b0000034 	adrp	x20, 415000 <random_data+0xca4>
  410ff4:	91334a94 	add	x20, x20, #0xcd2
  410ff8:	aa1403e2 	mov	x2, x20
  410ffc:	52801863 	mov	w3, #0xc3                  	// #195
  411000:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411004:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411008:	9134b021 	add	x1, x1, #0xd2c
  41100c:	911e2800 	add	x0, x0, #0x78a
  411010:	97ffdae0 	bl	407b90 <assert_print>
  411014:	aa1303e1 	mov	x1, x19
  411018:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  41101c:	91350c00 	add	x0, x0, #0xd43
  411020:	97ffdadc 	bl	407b90 <assert_print>
  411024:	aa1403e0 	mov	x0, x20
  411028:	52801861 	mov	w1, #0xc3                  	// #195
  41102c:	97ffdb03 	bl	407c38 <assert_post_action>
  411030:	52801862 	mov	w2, #0xc3                  	// #195
  411034:	17ffffe3 	b	410fc0 <z_sched_start+0x78>
	posix_irq_unlock(key);
  411038:	2a1503e0 	mov	w0, w21
}
  41103c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411040:	f94013f5 	ldr	x21, [sp, #32]
  411044:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411048:	17ffe3da 	b	409fb0 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
  41104c:	121d7800 	and	w0, w0, #0xfffffffb
  411050:	39006680 	strb	w0, [x20, #25]
	ready_thread(thread);
  411054:	aa1403e0 	mov	x0, x20
  411058:	97ffff33 	bl	410d24 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  41105c:	2a1503e1 	mov	w1, w21
  411060:	aa1303e0 	mov	x0, x19
}
  411064:	a94153f3 	ldp	x19, x20, [sp, #16]
  411068:	f94013f5 	ldr	x21, [sp, #32]
  41106c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&sched_spinlock, key);
  411070:	17fffd1a 	b	4104d8 <z_reschedule>

0000000000411074 <z_sched_wake_thread>:
{
  411074:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  411078:	910003fd 	mov	x29, sp
  41107c:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411080:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  411084:	aa0003f3 	mov	x19, x0
  411088:	a9025bf5 	stp	x21, x22, [sp, #32]
  41108c:	f9001bf7 	str	x23, [sp, #48]
  411090:	12001c37 	and	w23, w1, #0xff
	return posix_irq_lock();
  411094:	97ffe3c5 	bl	409fa8 <posix_irq_lock>
  411098:	2a0003f6 	mov	w22, w0
  41109c:	f947ca95 	ldr	x21, [x20, #3984]
  4110a0:	aa1503e0 	mov	x0, x21
  4110a4:	97fff568 	bl	40e644 <z_spin_lock_valid>
  4110a8:	72001c1f 	tst	w0, #0xff
  4110ac:	540002c1 	b.ne	411104 <z_sched_wake_thread+0x90>  // b.any
  4110b0:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  4110b4:	91334a73 	add	x19, x19, #0xcd2
  4110b8:	aa1303e2 	mov	x2, x19
  4110bc:	52801283 	mov	w3, #0x94                  	// #148
  4110c0:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  4110c4:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4110c8:	9133fc21 	add	x1, x1, #0xcff
  4110cc:	911e2800 	add	x0, x0, #0x78a
  4110d0:	97ffdab0 	bl	407b90 <assert_print>
  4110d4:	aa1503e1 	mov	x1, x21
  4110d8:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  4110dc:	91345000 	add	x0, x0, #0xd14
  4110e0:	97ffdaac 	bl	407b90 <assert_print>
  4110e4:	aa1303e0 	mov	x0, x19
  4110e8:	52801281 	mov	w1, #0x94                  	// #148
  4110ec:	97ffdad3 	bl	407c38 <assert_post_action>
  4110f0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4110f4:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4110f8:	aa1303e1 	mov	x1, x19
  4110fc:	911f2000 	add	x0, x0, #0x7c8
  411100:	97ffe4c0 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411104:	aa1503e0 	mov	x0, x21
  411108:	97fff567 	bl	40e6a4 <z_spin_lock_set_owner>
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  41110c:	39422260 	ldrb	w0, [x19, #136]
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
  411110:	39406661 	ldrb	w1, [x19, #25]
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  411114:	34000060 	cbz	w0, 411120 <z_sched_wake_thread+0xac>
		thread->no_wake_on_timeout = false;
  411118:	3902227f 	strb	wzr, [x19, #136]
		if (do_nothing) {
  41111c:	35000237 	cbnz	w23, 411160 <z_sched_wake_thread+0xec>
		if (!killed) {
  411120:	52800500 	mov	w0, #0x28                  	// #40
  411124:	6a00003f 	tst	w1, w0
  411128:	540001c1 	b.ne	411160 <z_sched_wake_thread+0xec>  // b.any
			if (thread->base.pended_on != NULL) {
  41112c:	f9400a60 	ldr	x0, [x19, #16]
  411130:	b4000060 	cbz	x0, 41113c <z_sched_wake_thread+0xc8>
				unpend_thread_no_timeout(thread);
  411134:	aa1303e0 	mov	x0, x19
  411138:	97fffdbf 	bl	410834 <unpend_thread_no_timeout>
  41113c:	39406662 	ldrb	w2, [x19, #25]
  411140:	710002ff 	cmp	w23, #0x0
  411144:	12800281 	mov	w1, #0xffffffeb            	// #-21
			ready_thread(thread);
  411148:	aa1303e0 	mov	x0, x19
  41114c:	0a010041 	and	w1, w2, w1
  411150:	121d7842 	and	w2, w2, #0xfffffffb
  411154:	1a810042 	csel	w2, w2, w1, eq  // eq = none
  411158:	39006662 	strb	w2, [x19, #25]
  41115c:	97fffef2 	bl	410d24 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411160:	f947ca94 	ldr	x20, [x20, #3984]
  411164:	aa1403e0 	mov	x0, x20
  411168:	97fff542 	bl	40e670 <z_spin_unlock_valid>
  41116c:	72001c1f 	tst	w0, #0xff
  411170:	54000261 	b.ne	4111bc <z_sched_wake_thread+0x148>  // b.any
  411174:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  411178:	91334a73 	add	x19, x19, #0xcd2
  41117c:	aa1303e2 	mov	x2, x19
  411180:	52801863 	mov	w3, #0xc3                  	// #195
  411184:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411188:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  41118c:	9134b021 	add	x1, x1, #0xd2c
  411190:	911e2800 	add	x0, x0, #0x78a
  411194:	97ffda7f 	bl	407b90 <assert_print>
  411198:	aa1403e1 	mov	x1, x20
  41119c:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  4111a0:	91350c00 	add	x0, x0, #0xd43
  4111a4:	97ffda7b 	bl	407b90 <assert_print>
  4111a8:	aa1303e0 	mov	x0, x19
  4111ac:	52801861 	mov	w1, #0xc3                  	// #195
  4111b0:	97ffdaa2 	bl	407c38 <assert_post_action>
  4111b4:	52801862 	mov	w2, #0xc3                  	// #195
  4111b8:	17ffffcf 	b	4110f4 <z_sched_wake_thread+0x80>
	posix_irq_unlock(key);
  4111bc:	2a1603e0 	mov	w0, w22
}
  4111c0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4111c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4111c8:	f9401bf7 	ldr	x23, [sp, #48]
  4111cc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4111d0:	17ffe378 	b	409fb0 <posix_irq_unlock>

00000000004111d4 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
  4111d4:	d100a000 	sub	x0, x0, #0x28
  4111d8:	52800021 	mov	w1, #0x1                   	// #1
  4111dc:	17ffffa6 	b	411074 <z_sched_wake_thread>

00000000004111e0 <unready_thread>:
{
  4111e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4111e4:	910003fd 	mov	x29, sp
  4111e8:	a90153f3 	stp	x19, x20, [sp, #16]
  4111ec:	aa0003f3 	mov	x19, x0
	return (thread->base.thread_state & state) != 0U;
  4111f0:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  4111f4:	39406400 	ldrb	w0, [x0, #25]
	if (z_is_thread_queued(thread)) {
  4111f8:	39c06661 	ldrsb	w1, [x19, #25]
  4111fc:	36f800e1 	tbz	w1, #31, 411218 <unready_thread+0x38>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411200:	12001800 	and	w0, w0, #0x7f
  411204:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411208:	f9472e80 	ldr	x0, [x20, #3672]
  41120c:	aa1303e1 	mov	x1, x19
  411210:	9100c000 	add	x0, x0, #0x30
  411214:	97fffd6b 	bl	4107c0 <z_priq_dumb_remove>
	update_cache(thread == _current);
  411218:	f9472e94 	ldr	x20, [x20, #3672]
  41121c:	f9400a80 	ldr	x0, [x20, #16]
  411220:	eb13001f 	cmp	x0, x19
}
  411224:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  411228:	1a9f17e0 	cset	w0, eq  // eq = none
}
  41122c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	update_cache(thread == _current);
  411230:	17fffdec 	b	4109e0 <update_cache>

0000000000411234 <add_to_waitq_locked>:
{
  411234:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411238:	910003fd 	mov	x29, sp
  41123c:	a90153f3 	stp	x19, x20, [sp, #16]
  411240:	aa0003f3 	mov	x19, x0
  411244:	aa0103f4 	mov	x20, x1
  411248:	f90013f5 	str	x21, [sp, #32]
	unready_thread(thread);
  41124c:	97ffffe5 	bl	4111e0 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
  411250:	39406660 	ldrb	w0, [x19, #25]
  411254:	321f0000 	orr	w0, w0, #0x2
  411258:	39006660 	strb	w0, [x19, #25]
	if (wait_q != NULL) {
  41125c:	b40003d4 	cbz	x20, 4112d4 <add_to_waitq_locked+0xa0>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411260:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
		thread->base.pended_on = wait_q;
  411264:	f9000a74 	str	x20, [x19, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411268:	f946fc00 	ldr	x0, [x0, #3576]
  41126c:	eb00027f 	cmp	x19, x0
  411270:	54000241 	b.ne	4112b8 <add_to_waitq_locked+0x84>  // b.any
  411274:	b0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  411278:	9112ca73 	add	x19, x19, #0x4b2
  41127c:	aa1303e2 	mov	x2, x19
  411280:	52801783 	mov	w3, #0xbc                  	// #188
  411284:	b0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  411288:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  41128c:	911b2421 	add	x1, x1, #0x6c9
  411290:	911e2800 	add	x0, x0, #0x78a
  411294:	97ffda3f 	bl	407b90 <assert_print>
  411298:	aa1303e0 	mov	x0, x19
  41129c:	52801781 	mov	w1, #0xbc                  	// #188
  4112a0:	97ffda66 	bl	407c38 <assert_post_action>
  4112a4:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4112a8:	aa1303e1 	mov	x1, x19
  4112ac:	911f2000 	add	x0, x0, #0x7c8
  4112b0:	52801782 	mov	w2, #0xbc                  	// #188
  4112b4:	97ffe453 	bl	40a400 <posix_print_error_and_exit>
	return list->head == list;
  4112b8:	f9400295 	ldr	x21, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4112bc:	eb15029f 	cmp	x20, x21
  4112c0:	540001a1 	b.ne	4112f4 <add_to_waitq_locked+0xc0>  // b.any
	sys_dnode_t *const tail = list->tail;
  4112c4:	f9400680 	ldr	x0, [x20, #8]
	node->prev = tail;
  4112c8:	a9000274 	stp	x20, x0, [x19]
	tail->next = node;
  4112cc:	f9000013 	str	x19, [x0]
	list->tail = node;
  4112d0:	f9000693 	str	x19, [x20, #8]
}
  4112d4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4112d8:	f94013f5 	ldr	x21, [sp, #32]
  4112dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4112e0:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
  4112e4:	f9400680 	ldr	x0, [x20, #8]
  4112e8:	eb15001f 	cmp	x0, x21
  4112ec:	54fffec0 	b.eq	4112c4 <add_to_waitq_locked+0x90>  // b.none
  4112f0:	f94002b5 	ldr	x21, [x21]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  4112f4:	b4fffe95 	cbz	x21, 4112c4 <add_to_waitq_locked+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
  4112f8:	aa1503e1 	mov	x1, x21
  4112fc:	aa1303e0 	mov	x0, x19
  411300:	97fffc07 	bl	41031c <z_sched_prio_cmp>
  411304:	7100001f 	cmp	w0, #0x0
  411308:	54fffeed 	b.le	4112e4 <add_to_waitq_locked+0xb0>
	sys_dnode_t *const prev = successor->prev;
  41130c:	f94006a0 	ldr	x0, [x21, #8]
	node->prev = prev;
  411310:	a9000275 	stp	x21, x0, [x19]
	prev->next = node;
  411314:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411318:	f90006b3 	str	x19, [x21, #8]
}
  41131c:	17ffffee 	b	4112d4 <add_to_waitq_locked+0xa0>

0000000000411320 <pend_locked>:
{
  411320:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411324:	910003fd 	mov	x29, sp
  411328:	a90153f3 	stp	x19, x20, [sp, #16]
  41132c:	aa0203f3 	mov	x19, x2
  411330:	aa0003f4 	mov	x20, x0
	add_to_waitq_locked(thread, wait_q);
  411334:	97ffffc0 	bl	411234 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  411338:	b100067f 	cmn	x19, #0x1
  41133c:	54000100 	b.eq	41135c <pend_locked+0x3c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  411340:	aa1303e2 	mov	x2, x19
  411344:	9100a280 	add	x0, x20, #0x28
  411348:	d00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
}
  41134c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411350:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411354:	f9472421 	ldr	x1, [x1, #3656]
  411358:	14000589 	b	41297c <z_add_timeout>
  41135c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411360:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411364:	d65f03c0 	ret

0000000000411368 <z_pend_curr>:
{
  411368:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  41136c:	910003fd 	mov	x29, sp
  411370:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  411374:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  411378:	f947ca73 	ldr	x19, [x19, #3984]
{
  41137c:	a9025bf5 	stp	x21, x22, [sp, #32]
  411380:	f9001bf7 	str	x23, [sp, #48]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  411384:	eb13001f 	cmp	x0, x19
  411388:	54000201 	b.ne	4113c8 <z_pend_curr+0x60>  // b.any
  41138c:	b0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  411390:	9112ca73 	add	x19, x19, #0x4b2
  411394:	aa1303e2 	mov	x2, x19
  411398:	52806a43 	mov	w3, #0x352                 	// #850
  41139c:	b0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  4113a0:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4113a4:	911ca021 	add	x1, x1, #0x728
  4113a8:	911e2800 	add	x0, x0, #0x78a
  4113ac:	97ffd9f9 	bl	407b90 <assert_print>
  4113b0:	aa1303e0 	mov	x0, x19
  4113b4:	52806a41 	mov	w1, #0x352                 	// #850
  4113b8:	97ffda20 	bl	407c38 <assert_post_action>
  4113bc:	52806a42 	mov	w2, #0x352                 	// #850
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4113c0:	aa1303e1 	mov	x1, x19
  4113c4:	1400001c 	b	411434 <z_pend_curr+0xcc>
  4113c8:	aa0003f4 	mov	x20, x0
  4113cc:	2a0103f5 	mov	w21, w1
  4113d0:	aa0203f6 	mov	x22, x2
  4113d4:	aa0303f7 	mov	x23, x3
	return posix_irq_lock();
  4113d8:	97ffe2f4 	bl	409fa8 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4113dc:	aa1303e0 	mov	x0, x19
  4113e0:	97fff499 	bl	40e644 <z_spin_lock_valid>
  4113e4:	72001c1f 	tst	w0, #0xff
  4113e8:	540002c1 	b.ne	411440 <z_pend_curr+0xd8>  // b.any
  4113ec:	90000034 	adrp	x20, 415000 <random_data+0xca4>
  4113f0:	91334a94 	add	x20, x20, #0xcd2
  4113f4:	aa1403e2 	mov	x2, x20
  4113f8:	52801283 	mov	w3, #0x94                  	// #148
  4113fc:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411400:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411404:	9133fc21 	add	x1, x1, #0xcff
  411408:	911e2800 	add	x0, x0, #0x78a
  41140c:	97ffd9e1 	bl	407b90 <assert_print>
  411410:	aa1303e1 	mov	x1, x19
  411414:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411418:	91345000 	add	x0, x0, #0xd14
  41141c:	97ffd9dd 	bl	407b90 <assert_print>
  411420:	aa1403e0 	mov	x0, x20
  411424:	52801281 	mov	w1, #0x94                  	// #148
  411428:	97ffda04 	bl	407c38 <assert_post_action>
  41142c:	52801282 	mov	w2, #0x94                  	// #148
  411430:	aa1403e1 	mov	x1, x20
  411434:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411438:	911f2000 	add	x0, x0, #0x7c8
  41143c:	97ffe3f1 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411440:	aa1303e0 	mov	x0, x19
  411444:	97fff498 	bl	40e6a4 <z_spin_lock_set_owner>
	pend_locked(_current, wait_q, timeout);
  411448:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  41144c:	aa1703e2 	mov	x2, x23
  411450:	aa1603e1 	mov	x1, x22
  411454:	f9472c00 	ldr	x0, [x0, #3672]
  411458:	f9400800 	ldr	x0, [x0, #16]
  41145c:	97ffffb1 	bl	411320 <pend_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411460:	aa1403e0 	mov	x0, x20
  411464:	97fff483 	bl	40e670 <z_spin_unlock_valid>
  411468:	72001c1f 	tst	w0, #0xff
  41146c:	54000261 	b.ne	4114b8 <z_pend_curr+0x150>  // b.any
  411470:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  411474:	91334a73 	add	x19, x19, #0xcd2
  411478:	aa1303e2 	mov	x2, x19
  41147c:	52801c43 	mov	w3, #0xe2                  	// #226
  411480:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411484:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411488:	9134b021 	add	x1, x1, #0xd2c
  41148c:	911e2800 	add	x0, x0, #0x78a
  411490:	97ffd9c0 	bl	407b90 <assert_print>
  411494:	aa1403e1 	mov	x1, x20
  411498:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  41149c:	91350c00 	add	x0, x0, #0xd43
  4114a0:	97ffd9bc 	bl	407b90 <assert_print>
  4114a4:	aa1303e0 	mov	x0, x19
  4114a8:	52801c41 	mov	w1, #0xe2                  	// #226
  4114ac:	97ffd9e3 	bl	407c38 <assert_post_action>
  4114b0:	52801c42 	mov	w2, #0xe2                  	// #226
  4114b4:	17ffffc3 	b	4113c0 <z_pend_curr+0x58>
  4114b8:	aa1303e0 	mov	x0, x19
  4114bc:	97fff46d 	bl	40e670 <z_spin_unlock_valid>
  4114c0:	72001c1f 	tst	w0, #0xff
  4114c4:	54000261 	b.ne	411510 <z_pend_curr+0x1a8>  // b.any
  4114c8:	90000034 	adrp	x20, 415000 <random_data+0xca4>
  4114cc:	91334a94 	add	x20, x20, #0xcd2
  4114d0:	aa1403e2 	mov	x2, x20
  4114d4:	52801c43 	mov	w3, #0xe2                  	// #226
  4114d8:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  4114dc:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4114e0:	9134b021 	add	x1, x1, #0xd2c
  4114e4:	911e2800 	add	x0, x0, #0x78a
  4114e8:	97ffd9aa 	bl	407b90 <assert_print>
  4114ec:	aa1303e1 	mov	x1, x19
  4114f0:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  4114f4:	91350c00 	add	x0, x0, #0xd43
  4114f8:	97ffd9a6 	bl	407b90 <assert_print>
  4114fc:	aa1403e0 	mov	x0, x20
  411500:	52801c41 	mov	w1, #0xe2                  	// #226
  411504:	97ffd9cd 	bl	407c38 <assert_post_action>
  411508:	52801c42 	mov	w2, #0xe2                  	// #226
  41150c:	17ffffc9 	b	411430 <z_pend_curr+0xc8>
  411510:	2a1503e0 	mov	w0, w21
}
  411514:	a94153f3 	ldp	x19, x20, [sp, #16]
  411518:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41151c:	f9401bf7 	ldr	x23, [sp, #48]
  411520:	a8c47bfd 	ldp	x29, x30, [sp], #64
  411524:	17ffdf77 	b	409300 <arch_swap>

0000000000411528 <z_set_prio>:
{
  411528:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  41152c:	910003fd 	mov	x29, sp
  411530:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411534:	d00000d8 	adrp	x24, 42b000 <__FRAME_END__+0xff4c>
  411538:	a90153f3 	stp	x19, x20, [sp, #16]
  41153c:	aa0003f3 	mov	x19, x0
  411540:	a9025bf5 	stp	x21, x22, [sp, #32]
  411544:	2a0103f5 	mov	w21, w1
  411548:	f90023f9 	str	x25, [sp, #64]
  41154c:	97ffe297 	bl	409fa8 <posix_irq_lock>
  411550:	f947cb19 	ldr	x25, [x24, #3984]
  411554:	2a0003f7 	mov	w23, w0
  411558:	aa1903e0 	mov	x0, x25
  41155c:	97fff43a 	bl	40e644 <z_spin_lock_valid>
  411560:	72001c16 	ands	w22, w0, #0xff
  411564:	540002c1 	b.ne	4115bc <z_set_prio+0x94>  // b.any
  411568:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  41156c:	91334a73 	add	x19, x19, #0xcd2
  411570:	aa1303e2 	mov	x2, x19
  411574:	52801283 	mov	w3, #0x94                  	// #148
  411578:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  41157c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411580:	9133fc21 	add	x1, x1, #0xcff
  411584:	911e2800 	add	x0, x0, #0x78a
  411588:	97ffd982 	bl	407b90 <assert_print>
  41158c:	aa1903e1 	mov	x1, x25
  411590:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411594:	91345000 	add	x0, x0, #0xd14
  411598:	97ffd97e 	bl	407b90 <assert_print>
  41159c:	aa1303e0 	mov	x0, x19
  4115a0:	52801281 	mov	w1, #0x94                  	// #148
  4115a4:	97ffd9a5 	bl	407c38 <assert_post_action>
  4115a8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4115ac:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4115b0:	aa1303e1 	mov	x1, x19
  4115b4:	911f2000 	add	x0, x0, #0x7c8
  4115b8:	97ffe392 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4115bc:	aa1903e0 	mov	x0, x25
  4115c0:	97fff439 	bl	40e6a4 <z_spin_lock_set_owner>
	uint8_t state = thread->base.thread_state;
  4115c4:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  4115c8:	13001eb5 	sxtb	w21, w21
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  4115cc:	f240101f 	tst	x0, #0x1f
  4115d0:	54000a61 	b.ne	41171c <z_set_prio+0x1f4>  // b.any
		if (need_sched) {
  4115d4:	f9401661 	ldr	x1, [x19, #40]
  4115d8:	b5000a21 	cbnz	x1, 41171c <z_set_prio+0x1f4>
	_priq_run_remove(thread_runq(thread), thread);
  4115dc:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4115e0:	12001800 	and	w0, w0, #0x7f
  4115e4:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4115e8:	aa1303e1 	mov	x1, x19
  4115ec:	f9472e99 	ldr	x25, [x20, #3672]
  4115f0:	9100c320 	add	x0, x25, #0x30
  4115f4:	97fffc73 	bl	4107c0 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  4115f8:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  4115fc:	39006a75 	strb	w21, [x19, #26]
	thread->base.thread_state |= _THREAD_QUEUED;
  411600:	aa1403f5 	mov	x21, x20
  411604:	32196000 	orr	w0, w0, #0xffffff80
  411608:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  41160c:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  411610:	f946fc00 	ldr	x0, [x0, #3576]
  411614:	eb00027f 	cmp	x19, x0
  411618:	540001e1 	b.ne	411654 <z_set_prio+0x12c>  // b.any
  41161c:	b0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  411620:	9112ca73 	add	x19, x19, #0x4b2
  411624:	aa1303e2 	mov	x2, x19
  411628:	52801783 	mov	w3, #0xbc                  	// #188
  41162c:	b0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  411630:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411634:	911b2421 	add	x1, x1, #0x6c9
  411638:	911e2800 	add	x0, x0, #0x78a
  41163c:	97ffd955 	bl	407b90 <assert_print>
  411640:	aa1303e0 	mov	x0, x19
  411644:	52801781 	mov	w1, #0xbc                  	// #188
  411648:	97ffd97c 	bl	407c38 <assert_post_action>
  41164c:	52801782 	mov	w2, #0xbc                  	// #188
  411650:	17ffffd7 	b	4115ac <z_set_prio+0x84>
	return list->head == list;
  411654:	aa1903e0 	mov	x0, x25
  411658:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  41165c:	eb00029f 	cmp	x20, x0
  411660:	54000481 	b.ne	4116f0 <z_set_prio+0x1c8>  // b.any
	sys_dnode_t *const tail = list->tail;
  411664:	f9472ea2 	ldr	x2, [x21, #3672]
	node->next = list;
  411668:	9100c041 	add	x1, x2, #0x30
	sys_dnode_t *const tail = list->tail;
  41166c:	f9401c40 	ldr	x0, [x2, #56]
	node->prev = tail;
  411670:	a9000261 	stp	x1, x0, [x19]
	tail->next = node;
  411674:	f9000013 	str	x19, [x0]
	list->tail = node;
  411678:	f9001c53 	str	x19, [x2, #56]
			update_cache(1);
  41167c:	52800020 	mov	w0, #0x1                   	// #1
  411680:	97fffcd8 	bl	4109e0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411684:	f947cb18 	ldr	x24, [x24, #3984]
  411688:	aa1803e0 	mov	x0, x24
  41168c:	97fff3f9 	bl	40e670 <z_spin_unlock_valid>
  411690:	72001c1f 	tst	w0, #0xff
  411694:	540004a1 	b.ne	411728 <z_set_prio+0x200>  // b.any
  411698:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  41169c:	91334a73 	add	x19, x19, #0xcd2
  4116a0:	aa1303e2 	mov	x2, x19
  4116a4:	52801863 	mov	w3, #0xc3                  	// #195
  4116a8:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  4116ac:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4116b0:	9134b021 	add	x1, x1, #0xd2c
  4116b4:	911e2800 	add	x0, x0, #0x78a
  4116b8:	97ffd936 	bl	407b90 <assert_print>
  4116bc:	aa1803e1 	mov	x1, x24
  4116c0:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  4116c4:	91350c00 	add	x0, x0, #0xd43
  4116c8:	97ffd932 	bl	407b90 <assert_print>
  4116cc:	aa1303e0 	mov	x0, x19
  4116d0:	52801861 	mov	w1, #0xc3                  	// #195
  4116d4:	97ffd959 	bl	407c38 <assert_post_action>
  4116d8:	52801862 	mov	w2, #0xc3                  	// #195
  4116dc:	17ffffb4 	b	4115ac <z_set_prio+0x84>
	return (node == list->tail) ? NULL : node->next;
  4116e0:	f9401f20 	ldr	x0, [x25, #56]
  4116e4:	eb00029f 	cmp	x20, x0
  4116e8:	54fffbe0 	b.eq	411664 <z_set_prio+0x13c>  // b.none
  4116ec:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  4116f0:	b4fffbb4 	cbz	x20, 411664 <z_set_prio+0x13c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  4116f4:	aa1403e1 	mov	x1, x20
  4116f8:	aa1303e0 	mov	x0, x19
  4116fc:	97fffb08 	bl	41031c <z_sched_prio_cmp>
  411700:	7100001f 	cmp	w0, #0x0
  411704:	54fffeed 	b.le	4116e0 <z_set_prio+0x1b8>
	sys_dnode_t *const prev = successor->prev;
  411708:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  41170c:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  411710:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411714:	f9000693 	str	x19, [x20, #8]
}
  411718:	17ffffd9 	b	41167c <z_set_prio+0x154>
			thread->base.prio = prio;
  41171c:	52800016 	mov	w22, #0x0                   	// #0
  411720:	39006a75 	strb	w21, [x19, #26]
  411724:	17ffffd8 	b	411684 <z_set_prio+0x15c>
	posix_irq_unlock(key);
  411728:	2a1703e0 	mov	w0, w23
  41172c:	97ffe221 	bl	409fb0 <posix_irq_unlock>
}
  411730:	2a1603e0 	mov	w0, w22
  411734:	a94153f3 	ldp	x19, x20, [sp, #16]
  411738:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41173c:	a94363f7 	ldp	x23, x24, [sp, #48]
  411740:	f94023f9 	ldr	x25, [sp, #64]
  411744:	a8c57bfd 	ldp	x29, x30, [sp], #80
  411748:	d65f03c0 	ret

000000000041174c <z_impl_k_thread_suspend>:
{
  41174c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411750:	910003fd 	mov	x29, sp
  411754:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411758:	d00000d5 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
  41175c:	a90153f3 	stp	x19, x20, [sp, #16]
  411760:	aa0003f3 	mov	x19, x0
	return z_abort_timeout(&thread->base.timeout);
  411764:	9100a000 	add	x0, x0, #0x28
  411768:	94000517 	bl	412bc4 <z_abort_timeout>
	return posix_irq_lock();
  41176c:	97ffe20f 	bl	409fa8 <posix_irq_lock>
  411770:	2a0003f6 	mov	w22, w0
  411774:	f947cab4 	ldr	x20, [x21, #3984]
  411778:	aa1403e0 	mov	x0, x20
  41177c:	97fff3b2 	bl	40e644 <z_spin_lock_valid>
  411780:	72001c1f 	tst	w0, #0xff
  411784:	540002c1 	b.ne	4117dc <z_impl_k_thread_suspend+0x90>  // b.any
  411788:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  41178c:	91334a73 	add	x19, x19, #0xcd2
  411790:	aa1303e2 	mov	x2, x19
  411794:	52801283 	mov	w3, #0x94                  	// #148
  411798:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  41179c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4117a0:	9133fc21 	add	x1, x1, #0xcff
  4117a4:	911e2800 	add	x0, x0, #0x78a
  4117a8:	97ffd8fa 	bl	407b90 <assert_print>
  4117ac:	aa1403e1 	mov	x1, x20
  4117b0:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  4117b4:	91345000 	add	x0, x0, #0xd14
  4117b8:	97ffd8f6 	bl	407b90 <assert_print>
  4117bc:	aa1303e0 	mov	x0, x19
  4117c0:	52801281 	mov	w1, #0x94                  	// #148
  4117c4:	97ffd91d 	bl	407c38 <assert_post_action>
  4117c8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4117cc:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4117d0:	aa1303e1 	mov	x1, x19
  4117d4:	911f2000 	add	x0, x0, #0x7c8
  4117d8:	97ffe30a 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4117dc:	aa1403e0 	mov	x0, x20
  4117e0:	97fff3b1 	bl	40e6a4 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
  4117e4:	39c06661 	ldrsb	w1, [x19, #25]
  4117e8:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
	return (thread->base.thread_state & state) != 0U;
  4117ec:	39406660 	ldrb	w0, [x19, #25]
  4117f0:	36f800e1 	tbz	w1, #31, 41180c <z_impl_k_thread_suspend+0xc0>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4117f4:	12001800 	and	w0, w0, #0x7f
  4117f8:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4117fc:	f9472e80 	ldr	x0, [x20, #3672]
  411800:	aa1303e1 	mov	x1, x19
  411804:	9100c000 	add	x0, x0, #0x30
  411808:	97fffbee 	bl	4107c0 <z_priq_dumb_remove>
		update_cache(thread == _current);
  41180c:	f9472e94 	ldr	x20, [x20, #3672]
	thread->base.thread_state |= _THREAD_SUSPENDED;
  411810:	39406660 	ldrb	w0, [x19, #25]
  411814:	321c0000 	orr	w0, w0, #0x10
  411818:	39006660 	strb	w0, [x19, #25]
  41181c:	f9400a80 	ldr	x0, [x20, #16]
  411820:	eb13001f 	cmp	x0, x19
  411824:	1a9f17e0 	cset	w0, eq  // eq = none
  411828:	97fffc6e 	bl	4109e0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41182c:	f947cab5 	ldr	x21, [x21, #3984]
  411830:	aa1503e0 	mov	x0, x21
  411834:	97fff38f 	bl	40e670 <z_spin_unlock_valid>
  411838:	72001c1f 	tst	w0, #0xff
  41183c:	54000261 	b.ne	411888 <z_impl_k_thread_suspend+0x13c>  // b.any
  411840:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  411844:	91334a73 	add	x19, x19, #0xcd2
  411848:	aa1303e2 	mov	x2, x19
  41184c:	52801863 	mov	w3, #0xc3                  	// #195
  411850:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411854:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411858:	9134b021 	add	x1, x1, #0xd2c
  41185c:	911e2800 	add	x0, x0, #0x78a
  411860:	97ffd8cc 	bl	407b90 <assert_print>
  411864:	aa1503e1 	mov	x1, x21
  411868:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  41186c:	91350c00 	add	x0, x0, #0xd43
  411870:	97ffd8c8 	bl	407b90 <assert_print>
  411874:	aa1303e0 	mov	x0, x19
  411878:	52801861 	mov	w1, #0xc3                  	// #195
  41187c:	97ffd8ef 	bl	407c38 <assert_post_action>
  411880:	52801862 	mov	w2, #0xc3                  	// #195
  411884:	17ffffd2 	b	4117cc <z_impl_k_thread_suspend+0x80>
	posix_irq_unlock(key);
  411888:	2a1603e0 	mov	w0, w22
  41188c:	97ffe1c9 	bl	409fb0 <posix_irq_unlock>
	if (thread == _current) {
  411890:	f9400a80 	ldr	x0, [x20, #16]
  411894:	eb13001f 	cmp	x0, x19
  411898:	540000a1 	b.ne	4118ac <z_impl_k_thread_suspend+0x160>  // b.any
}
  41189c:	a94153f3 	ldp	x19, x20, [sp, #16]
  4118a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4118a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule_unlocked();
  4118a8:	17fffb58 	b	410608 <z_reschedule_unlocked>
}
  4118ac:	a94153f3 	ldp	x19, x20, [sp, #16]
  4118b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4118b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4118b8:	d65f03c0 	ret

00000000004118bc <k_sched_unlock>:
{
  4118bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4118c0:	910003fd 	mov	x29, sp
  4118c4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4118c8:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
	return posix_irq_lock();
  4118cc:	97ffe1b7 	bl	409fa8 <posix_irq_lock>
  4118d0:	f947ca73 	ldr	x19, [x19, #3984]
  4118d4:	2a0003f4 	mov	w20, w0
  4118d8:	aa1303e0 	mov	x0, x19
  4118dc:	97fff35a 	bl	40e644 <z_spin_lock_valid>
  4118e0:	72001c1f 	tst	w0, #0xff
  4118e4:	54000281 	b.ne	411934 <k_sched_unlock+0x78>  // b.any
  4118e8:	90000034 	adrp	x20, 415000 <random_data+0xca4>
  4118ec:	91334a94 	add	x20, x20, #0xcd2
  4118f0:	aa1403e2 	mov	x2, x20
  4118f4:	52801283 	mov	w3, #0x94                  	// #148
  4118f8:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  4118fc:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411900:	9133fc21 	add	x1, x1, #0xcff
  411904:	911e2800 	add	x0, x0, #0x78a
  411908:	97ffd8a2 	bl	407b90 <assert_print>
  41190c:	aa1303e1 	mov	x1, x19
  411910:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411914:	91345000 	add	x0, x0, #0xd14
  411918:	97ffd89e 	bl	407b90 <assert_print>
  41191c:	aa1403e0 	mov	x0, x20
  411920:	52801281 	mov	w1, #0x94                  	// #148
  411924:	97ffd8c5 	bl	407c38 <assert_post_action>
  411928:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41192c:	aa1403e1 	mov	x1, x20
  411930:	14000019 	b	411994 <k_sched_unlock+0xd8>
	z_spin_lock_set_owner(l);
  411934:	aa1303e0 	mov	x0, x19
  411938:	97fff35b 	bl	40e6a4 <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0U, "");
  41193c:	d00000c2 	adrp	x2, 42b000 <__FRAME_END__+0xff4c>
  411940:	f9472c42 	ldr	x2, [x2, #3672]
  411944:	f9400840 	ldr	x0, [x2, #16]
  411948:	39406c01 	ldrb	w1, [x0, #27]
  41194c:	350002a1 	cbnz	w1, 4119a0 <k_sched_unlock+0xe4>
  411950:	b0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  411954:	9112ca73 	add	x19, x19, #0x4b2
  411958:	aa1303e2 	mov	x2, x19
  41195c:	b0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  411960:	911d7c21 	add	x1, x1, #0x75f
  411964:	52807d63 	mov	w3, #0x3eb                 	// #1003
  411968:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  41196c:	911e2800 	add	x0, x0, #0x78a
  411970:	97ffd888 	bl	407b90 <assert_print>
  411974:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411978:	9135a400 	add	x0, x0, #0xd69
  41197c:	97ffd885 	bl	407b90 <assert_print>
  411980:	aa1303e0 	mov	x0, x19
  411984:	52807d61 	mov	w1, #0x3eb                 	// #1003
  411988:	97ffd8ac 	bl	407c38 <assert_post_action>
  41198c:	52807d62 	mov	w2, #0x3eb                 	// #1003
  411990:	aa1303e1 	mov	x1, x19
  411994:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411998:	911f2000 	add	x0, x0, #0x7c8
  41199c:	97ffe299 	bl	40a400 <posix_print_error_and_exit>
		__ASSERT(!arch_is_in_isr(), "");
  4119a0:	b9400042 	ldr	w2, [x2]
  4119a4:	34000242 	cbz	w2, 4119ec <k_sched_unlock+0x130>
  4119a8:	b0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  4119ac:	9112ca73 	add	x19, x19, #0x4b2
  4119b0:	aa1303e2 	mov	x2, x19
  4119b4:	b0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  4119b8:	91089021 	add	x1, x1, #0x224
  4119bc:	52807d83 	mov	w3, #0x3ec                 	// #1004
  4119c0:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4119c4:	911e2800 	add	x0, x0, #0x78a
  4119c8:	97ffd872 	bl	407b90 <assert_print>
  4119cc:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  4119d0:	9135a400 	add	x0, x0, #0xd69
  4119d4:	97ffd86f 	bl	407b90 <assert_print>
  4119d8:	aa1303e0 	mov	x0, x19
  4119dc:	52807d81 	mov	w1, #0x3ec                 	// #1004
  4119e0:	97ffd896 	bl	407c38 <assert_post_action>
  4119e4:	52807d82 	mov	w2, #0x3ec                 	// #1004
  4119e8:	17ffffea 	b	411990 <k_sched_unlock+0xd4>
		++_current->base.sched_locked;
  4119ec:	11000421 	add	w1, w1, #0x1
  4119f0:	39006c01 	strb	w1, [x0, #27]
		update_cache(0);
  4119f4:	52800000 	mov	w0, #0x0                   	// #0
  4119f8:	97fffbfa 	bl	4109e0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4119fc:	aa1303e0 	mov	x0, x19
  411a00:	97fff31c 	bl	40e670 <z_spin_unlock_valid>
  411a04:	72001c1f 	tst	w0, #0xff
  411a08:	54000261 	b.ne	411a54 <k_sched_unlock+0x198>  // b.any
  411a0c:	90000034 	adrp	x20, 415000 <random_data+0xca4>
  411a10:	91334a94 	add	x20, x20, #0xcd2
  411a14:	aa1403e2 	mov	x2, x20
  411a18:	52801863 	mov	w3, #0xc3                  	// #195
  411a1c:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411a20:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411a24:	9134b021 	add	x1, x1, #0xd2c
  411a28:	911e2800 	add	x0, x0, #0x78a
  411a2c:	97ffd859 	bl	407b90 <assert_print>
  411a30:	aa1303e1 	mov	x1, x19
  411a34:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411a38:	91350c00 	add	x0, x0, #0xd43
  411a3c:	97ffd855 	bl	407b90 <assert_print>
  411a40:	aa1403e0 	mov	x0, x20
  411a44:	52801861 	mov	w1, #0xc3                  	// #195
  411a48:	97ffd87c 	bl	407c38 <assert_post_action>
  411a4c:	52801862 	mov	w2, #0xc3                  	// #195
  411a50:	17ffffb7 	b	41192c <k_sched_unlock+0x70>
	posix_irq_unlock(key);
  411a54:	2a1403e0 	mov	w0, w20
  411a58:	97ffe156 	bl	409fb0 <posix_irq_unlock>
}
  411a5c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411a60:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
  411a64:	17fffae9 	b	410608 <z_reschedule_unlocked>

0000000000411a68 <z_unpend1_no_timeout>:
{
  411a68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411a6c:	910003fd 	mov	x29, sp
  411a70:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411a74:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  411a78:	aa0003f4 	mov	x20, x0
  411a7c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  411a80:	97ffe14a 	bl	409fa8 <posix_irq_lock>
  411a84:	2a0003f5 	mov	w21, w0
  411a88:	f947ca76 	ldr	x22, [x19, #3984]
  411a8c:	aa1603e0 	mov	x0, x22
  411a90:	97fff2ed 	bl	40e644 <z_spin_lock_valid>
  411a94:	72001c1f 	tst	w0, #0xff
  411a98:	540002c1 	b.ne	411af0 <z_unpend1_no_timeout+0x88>  // b.any
  411a9c:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  411aa0:	91334a73 	add	x19, x19, #0xcd2
  411aa4:	aa1303e2 	mov	x2, x19
  411aa8:	52801283 	mov	w3, #0x94                  	// #148
  411aac:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411ab0:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411ab4:	9133fc21 	add	x1, x1, #0xcff
  411ab8:	911e2800 	add	x0, x0, #0x78a
  411abc:	97ffd835 	bl	407b90 <assert_print>
  411ac0:	aa1603e1 	mov	x1, x22
  411ac4:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411ac8:	91345000 	add	x0, x0, #0xd14
  411acc:	97ffd831 	bl	407b90 <assert_print>
  411ad0:	52801281 	mov	w1, #0x94                  	// #148
  411ad4:	aa1303e0 	mov	x0, x19
  411ad8:	97ffd858 	bl	407c38 <assert_post_action>
  411adc:	aa1303e1 	mov	x1, x19
  411ae0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411ae4:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411ae8:	911f2000 	add	x0, x0, #0x7c8
  411aec:	97ffe245 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411af0:	aa1603e0 	mov	x0, x22
  411af4:	97fff2ec 	bl	40e6a4 <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  411af8:	aa1403e0 	mov	x0, x20
  411afc:	97fffbb5 	bl	4109d0 <z_priq_dumb_best>
  411b00:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  411b04:	b4000040 	cbz	x0, 411b0c <z_unpend1_no_timeout+0xa4>
			unpend_thread_no_timeout(thread);
  411b08:	97fffb4b 	bl	410834 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411b0c:	f947ca73 	ldr	x19, [x19, #3984]
  411b10:	aa1303e0 	mov	x0, x19
  411b14:	97fff2d7 	bl	40e670 <z_spin_unlock_valid>
  411b18:	72001c1f 	tst	w0, #0xff
  411b1c:	54000281 	b.ne	411b6c <z_unpend1_no_timeout+0x104>  // b.any
  411b20:	90000034 	adrp	x20, 415000 <random_data+0xca4>
  411b24:	91334a94 	add	x20, x20, #0xcd2
  411b28:	aa1403e2 	mov	x2, x20
  411b2c:	52801863 	mov	w3, #0xc3                  	// #195
  411b30:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411b34:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411b38:	9134b021 	add	x1, x1, #0xd2c
  411b3c:	911e2800 	add	x0, x0, #0x78a
  411b40:	97ffd814 	bl	407b90 <assert_print>
  411b44:	aa1303e1 	mov	x1, x19
  411b48:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411b4c:	91350c00 	add	x0, x0, #0xd43
  411b50:	97ffd810 	bl	407b90 <assert_print>
  411b54:	52801861 	mov	w1, #0xc3                  	// #195
  411b58:	aa1403e0 	mov	x0, x20
  411b5c:	97ffd837 	bl	407c38 <assert_post_action>
  411b60:	aa1403e1 	mov	x1, x20
  411b64:	52801862 	mov	w2, #0xc3                  	// #195
  411b68:	17ffffdf 	b	411ae4 <z_unpend1_no_timeout+0x7c>
	posix_irq_unlock(key);
  411b6c:	2a1503e0 	mov	w0, w21
  411b70:	97ffe110 	bl	409fb0 <posix_irq_unlock>
}
  411b74:	aa1403e0 	mov	x0, x20
  411b78:	a94153f3 	ldp	x19, x20, [sp, #16]
  411b7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411b80:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411b84:	d65f03c0 	ret

0000000000411b88 <z_unpend_first_thread>:
{
  411b88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411b8c:	910003fd 	mov	x29, sp
  411b90:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411b94:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  411b98:	aa0003f4 	mov	x20, x0
  411b9c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  411ba0:	97ffe102 	bl	409fa8 <posix_irq_lock>
  411ba4:	2a0003f5 	mov	w21, w0
  411ba8:	f947ca76 	ldr	x22, [x19, #3984]
  411bac:	aa1603e0 	mov	x0, x22
  411bb0:	97fff2a5 	bl	40e644 <z_spin_lock_valid>
  411bb4:	72001c1f 	tst	w0, #0xff
  411bb8:	540002c1 	b.ne	411c10 <z_unpend_first_thread+0x88>  // b.any
  411bbc:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  411bc0:	91334a73 	add	x19, x19, #0xcd2
  411bc4:	aa1303e2 	mov	x2, x19
  411bc8:	52801283 	mov	w3, #0x94                  	// #148
  411bcc:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411bd0:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411bd4:	9133fc21 	add	x1, x1, #0xcff
  411bd8:	911e2800 	add	x0, x0, #0x78a
  411bdc:	97ffd7ed 	bl	407b90 <assert_print>
  411be0:	aa1603e1 	mov	x1, x22
  411be4:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411be8:	91345000 	add	x0, x0, #0xd14
  411bec:	97ffd7e9 	bl	407b90 <assert_print>
  411bf0:	52801281 	mov	w1, #0x94                  	// #148
  411bf4:	aa1303e0 	mov	x0, x19
  411bf8:	97ffd810 	bl	407c38 <assert_post_action>
  411bfc:	aa1303e1 	mov	x1, x19
  411c00:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411c04:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411c08:	911f2000 	add	x0, x0, #0x7c8
  411c0c:	97ffe1fd 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411c10:	aa1603e0 	mov	x0, x22
  411c14:	97fff2a4 	bl	40e6a4 <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  411c18:	aa1403e0 	mov	x0, x20
  411c1c:	97fffb6d 	bl	4109d0 <z_priq_dumb_best>
  411c20:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  411c24:	b4000080 	cbz	x0, 411c34 <z_unpend_first_thread+0xac>
			unpend_thread_no_timeout(thread);
  411c28:	97fffb03 	bl	410834 <unpend_thread_no_timeout>
  411c2c:	9100a280 	add	x0, x20, #0x28
  411c30:	940003e5 	bl	412bc4 <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411c34:	f947ca73 	ldr	x19, [x19, #3984]
  411c38:	aa1303e0 	mov	x0, x19
  411c3c:	97fff28d 	bl	40e670 <z_spin_unlock_valid>
  411c40:	72001c1f 	tst	w0, #0xff
  411c44:	54000281 	b.ne	411c94 <z_unpend_first_thread+0x10c>  // b.any
  411c48:	90000034 	adrp	x20, 415000 <random_data+0xca4>
  411c4c:	91334a94 	add	x20, x20, #0xcd2
  411c50:	aa1403e2 	mov	x2, x20
  411c54:	52801863 	mov	w3, #0xc3                  	// #195
  411c58:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411c5c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411c60:	9134b021 	add	x1, x1, #0xd2c
  411c64:	911e2800 	add	x0, x0, #0x78a
  411c68:	97ffd7ca 	bl	407b90 <assert_print>
  411c6c:	aa1303e1 	mov	x1, x19
  411c70:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411c74:	91350c00 	add	x0, x0, #0xd43
  411c78:	97ffd7c6 	bl	407b90 <assert_print>
  411c7c:	52801861 	mov	w1, #0xc3                  	// #195
  411c80:	aa1403e0 	mov	x0, x20
  411c84:	97ffd7ed 	bl	407c38 <assert_post_action>
  411c88:	aa1403e1 	mov	x1, x20
  411c8c:	52801862 	mov	w2, #0xc3                  	// #195
  411c90:	17ffffdd 	b	411c04 <z_unpend_first_thread+0x7c>
	posix_irq_unlock(key);
  411c94:	2a1503e0 	mov	w0, w21
  411c98:	97ffe0c6 	bl	409fb0 <posix_irq_unlock>
}
  411c9c:	aa1403e0 	mov	x0, x20
  411ca0:	a94153f3 	ldp	x19, x20, [sp, #16]
  411ca4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411ca8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411cac:	d65f03c0 	ret

0000000000411cb0 <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
  411cb0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411cb4:	910003fd 	mov	x29, sp
  411cb8:	a90153f3 	stp	x19, x20, [sp, #16]
  411cbc:	aa0003f4 	mov	x20, x0
	int need_sched = 0;
  411cc0:	52800000 	mov	w0, #0x0                   	// #0
	return list->head == list;
  411cc4:	f9400293 	ldr	x19, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411cc8:	eb13029f 	cmp	x20, x19
  411ccc:	54000040 	b.eq	411cd4 <z_unpend_all+0x24>  // b.none
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
  411cd0:	b5000093 	cbnz	x19, 411ce0 <z_unpend_all+0x30>
		z_ready_thread(thread);
		need_sched = 1;
	}

	return need_sched;
}
  411cd4:	a94153f3 	ldp	x19, x20, [sp, #16]
  411cd8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411cdc:	d65f03c0 	ret
		z_unpend_thread(thread);
  411ce0:	aa1303e0 	mov	x0, x19
  411ce4:	97fffaf4 	bl	4108b4 <z_unpend_thread>
		z_ready_thread(thread);
  411ce8:	aa1303e0 	mov	x0, x19
  411cec:	97fffc56 	bl	410e44 <z_ready_thread>
		need_sched = 1;
  411cf0:	52800020 	mov	w0, #0x1                   	// #1
  411cf4:	17fffff4 	b	411cc4 <z_unpend_all+0x14>

0000000000411cf8 <init_ready_q>:
#elif defined(CONFIG_SCHED_MULTIQ)
	for (int i = 0; i < ARRAY_SIZE(_kernel.ready_q.runq.queues); i++) {
		sys_dlist_init(&rq->runq.queues[i]);
	}
#else
	sys_dlist_init(&rq->runq);
  411cf8:	91002001 	add	x1, x0, #0x8
	list->tail = (sys_dnode_t *)list;
  411cfc:	a9008401 	stp	x1, x1, [x0, #8]
#endif
}
  411d00:	d65f03c0 	ret

0000000000411d04 <z_sched_init>:
#ifdef CONFIG_SCHED_CPU_MASK_PIN_ONLY
	for (int i = 0; i < CONFIG_MP_MAX_NUM_CPUS; i++) {
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
  411d04:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  411d08:	f9472c00 	ldr	x0, [x0, #3672]
  411d0c:	9100a000 	add	x0, x0, #0x28
  411d10:	17fffffa 	b	411cf8 <init_ready_q>

0000000000411d14 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
  411d14:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  411d18:	d00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  411d1c:	910003fd 	mov	x29, sp
  411d20:	a9025bf5 	stp	x21, x22, [sp, #32]
  411d24:	f9472c35 	ldr	x21, [x1, #3672]
  411d28:	a90153f3 	stp	x19, x20, [sp, #16]
  411d2c:	a90363f7 	stp	x23, x24, [sp, #48]
  411d30:	f90023f9 	str	x25, [sp, #64]
	__ASSERT(!arch_is_in_isr(), "");
  411d34:	b94002a0 	ldr	w0, [x21]
  411d38:	340002a0 	cbz	w0, 411d8c <z_impl_k_yield+0x78>
  411d3c:	b0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  411d40:	9112ca73 	add	x19, x19, #0x4b2
  411d44:	aa1303e2 	mov	x2, x19
  411d48:	b0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  411d4c:	91089021 	add	x1, x1, #0x224
  411d50:	5280ae23 	mov	w3, #0x571                 	// #1393
  411d54:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411d58:	911e2800 	add	x0, x0, #0x78a
  411d5c:	97ffd78d 	bl	407b90 <assert_print>
  411d60:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411d64:	9135a400 	add	x0, x0, #0xd69
  411d68:	97ffd78a 	bl	407b90 <assert_print>
  411d6c:	aa1303e0 	mov	x0, x19
  411d70:	5280ae21 	mov	w1, #0x571                 	// #1393
  411d74:	97ffd7b1 	bl	407c38 <assert_post_action>
  411d78:	5280ae22 	mov	w2, #0x571                 	// #1393
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411d7c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411d80:	aa1303e1 	mov	x1, x19
  411d84:	911f2000 	add	x0, x0, #0x7c8
  411d88:	97ffe19e 	bl	40a400 <posix_print_error_and_exit>
  411d8c:	d00000d7 	adrp	x23, 42b000 <__FRAME_END__+0xff4c>
  411d90:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  411d94:	97ffe085 	bl	409fa8 <posix_irq_lock>
  411d98:	2a0003f8 	mov	w24, w0
  411d9c:	f947caf9 	ldr	x25, [x23, #3984]
  411da0:	aa1903e0 	mov	x0, x25
  411da4:	97fff228 	bl	40e644 <z_spin_lock_valid>
  411da8:	72001c1f 	tst	w0, #0xff
  411dac:	54000261 	b.ne	411df8 <z_impl_k_yield+0xe4>  // b.any
  411db0:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  411db4:	91334a73 	add	x19, x19, #0xcd2
  411db8:	aa1303e2 	mov	x2, x19
  411dbc:	52801283 	mov	w3, #0x94                  	// #148
  411dc0:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411dc4:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411dc8:	9133fc21 	add	x1, x1, #0xcff
  411dcc:	911e2800 	add	x0, x0, #0x78a
  411dd0:	97ffd770 	bl	407b90 <assert_print>
  411dd4:	aa1903e1 	mov	x1, x25
  411dd8:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411ddc:	91345000 	add	x0, x0, #0xd14
  411de0:	97ffd76c 	bl	407b90 <assert_print>
  411de4:	aa1303e0 	mov	x0, x19
  411de8:	52801281 	mov	w1, #0x94                  	// #148
  411dec:	97ffd793 	bl	407c38 <assert_post_action>
  411df0:	52801282 	mov	w2, #0x94                  	// #148
  411df4:	17ffffe2 	b	411d7c <z_impl_k_yield+0x68>
	z_spin_lock_set_owner(l);
  411df8:	aa1903e0 	mov	x0, x25
  411dfc:	97fff22a 	bl	40e6a4 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
  411e00:	f9400aa1 	ldr	x1, [x21, #16]
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411e04:	39406420 	ldrb	w0, [x1, #25]
  411e08:	12001800 	and	w0, w0, #0x7f
  411e0c:	39006420 	strb	w0, [x1, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411e10:	9100c2a0 	add	x0, x21, #0x30
  411e14:	97fffa6b 	bl	4107c0 <z_priq_dumb_remove>
	}
	queue_thread(_current);
  411e18:	f9400ab3 	ldr	x19, [x21, #16]
	thread->base.thread_state |= _THREAD_QUEUED;
  411e1c:	39406660 	ldrb	w0, [x19, #25]
  411e20:	32196000 	orr	w0, w0, #0xffffff80
  411e24:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411e28:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  411e2c:	f946fc00 	ldr	x0, [x0, #3576]
  411e30:	eb00027f 	cmp	x19, x0
  411e34:	540001e1 	b.ne	411e70 <z_impl_k_yield+0x15c>  // b.any
  411e38:	b0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  411e3c:	9112ca73 	add	x19, x19, #0x4b2
  411e40:	aa1303e2 	mov	x2, x19
  411e44:	52801783 	mov	w3, #0xbc                  	// #188
  411e48:	b0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  411e4c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411e50:	911b2421 	add	x1, x1, #0x6c9
  411e54:	911e2800 	add	x0, x0, #0x78a
  411e58:	97ffd74e 	bl	407b90 <assert_print>
  411e5c:	aa1303e0 	mov	x0, x19
  411e60:	52801781 	mov	w1, #0xbc                  	// #188
  411e64:	97ffd775 	bl	407c38 <assert_post_action>
  411e68:	52801782 	mov	w2, #0xbc                  	// #188
  411e6c:	17ffffc4 	b	411d7c <z_impl_k_yield+0x68>
	return list->head == list;
  411e70:	aa1503e0 	mov	x0, x21
  411e74:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411e78:	eb00029f 	cmp	x20, x0
  411e7c:	54000481 	b.ne	411f0c <z_impl_k_yield+0x1f8>  // b.any
	sys_dnode_t *const tail = list->tail;
  411e80:	f9472ec1 	ldr	x1, [x22, #3672]
	node->next = list;
  411e84:	9100c022 	add	x2, x1, #0x30
	sys_dnode_t *const tail = list->tail;
  411e88:	f9401c20 	ldr	x0, [x1, #56]
	node->prev = tail;
  411e8c:	a9000262 	stp	x2, x0, [x19]
	tail->next = node;
  411e90:	f9000013 	str	x19, [x0]
	list->tail = node;
  411e94:	f9001c33 	str	x19, [x1, #56]
	update_cache(1);
  411e98:	52800020 	mov	w0, #0x1                   	// #1
  411e9c:	97fffad1 	bl	4109e0 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411ea0:	f947caf7 	ldr	x23, [x23, #3984]
  411ea4:	aa1703e0 	mov	x0, x23
  411ea8:	97fff1f2 	bl	40e670 <z_spin_unlock_valid>
  411eac:	72001c1f 	tst	w0, #0xff
  411eb0:	54000441 	b.ne	411f38 <z_impl_k_yield+0x224>  // b.any
  411eb4:	90000033 	adrp	x19, 415000 <random_data+0xca4>
  411eb8:	91334a73 	add	x19, x19, #0xcd2
  411ebc:	aa1303e2 	mov	x2, x19
  411ec0:	52801c43 	mov	w3, #0xe2                  	// #226
  411ec4:	90000021 	adrp	x1, 415000 <random_data+0xca4>
  411ec8:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411ecc:	9134b021 	add	x1, x1, #0xd2c
  411ed0:	911e2800 	add	x0, x0, #0x78a
  411ed4:	97ffd72f 	bl	407b90 <assert_print>
  411ed8:	aa1703e1 	mov	x1, x23
  411edc:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411ee0:	91350c00 	add	x0, x0, #0xd43
  411ee4:	97ffd72b 	bl	407b90 <assert_print>
  411ee8:	aa1303e0 	mov	x0, x19
  411eec:	52801c41 	mov	w1, #0xe2                  	// #226
  411ef0:	97ffd752 	bl	407c38 <assert_post_action>
  411ef4:	52801c42 	mov	w2, #0xe2                  	// #226
  411ef8:	17ffffa1 	b	411d7c <z_impl_k_yield+0x68>
	return (node == list->tail) ? NULL : node->next;
  411efc:	f9401ea0 	ldr	x0, [x21, #56]
  411f00:	eb14001f 	cmp	x0, x20
  411f04:	54fffbe0 	b.eq	411e80 <z_impl_k_yield+0x16c>  // b.none
  411f08:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  411f0c:	b4fffbb4 	cbz	x20, 411e80 <z_impl_k_yield+0x16c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  411f10:	aa1403e1 	mov	x1, x20
  411f14:	aa1303e0 	mov	x0, x19
  411f18:	97fff901 	bl	41031c <z_sched_prio_cmp>
  411f1c:	7100001f 	cmp	w0, #0x0
  411f20:	54fffeed 	b.le	411efc <z_impl_k_yield+0x1e8>
	sys_dnode_t *const prev = successor->prev;
  411f24:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  411f28:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  411f2c:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411f30:	f9000693 	str	x19, [x20, #8]
}
  411f34:	17ffffd9 	b	411e98 <z_impl_k_yield+0x184>
  411f38:	2a1803e0 	mov	w0, w24
	z_swap(&sched_spinlock, key);
}
  411f3c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411f40:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411f44:	a94363f7 	ldp	x23, x24, [sp, #48]
  411f48:	f94023f9 	ldr	x25, [sp, #64]
  411f4c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  411f50:	17ffdcec 	b	409300 <arch_swap>

0000000000411f54 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
  411f54:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  411f58:	910003fd 	mov	x29, sp
  411f5c:	a90153f3 	stp	x19, x20, [sp, #16]
  411f60:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  411f64:	a9025bf5 	stp	x21, x22, [sp, #32]
  411f68:	aa0003f6 	mov	x22, x0
  411f6c:	f9472e80 	ldr	x0, [x20, #3672]
  411f70:	f9001bf7 	str	x23, [sp, #48]
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
  411f74:	b9400000 	ldr	w0, [x0]
  411f78:	340002a0 	cbz	w0, 411fcc <z_tick_sleep+0x78>
  411f7c:	b0000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  411f80:	9112ca73 	add	x19, x19, #0x4b2
  411f84:	aa1303e2 	mov	x2, x19
  411f88:	b0000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  411f8c:	91089021 	add	x1, x1, #0x224
  411f90:	5280b1a3 	mov	w3, #0x58d                 	// #1421
  411f94:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411f98:	911e2800 	add	x0, x0, #0x78a
  411f9c:	97ffd6fd 	bl	407b90 <assert_print>
  411fa0:	90000020 	adrp	x0, 415000 <random_data+0xca4>
  411fa4:	9135a400 	add	x0, x0, #0xd69
  411fa8:	97ffd6fa 	bl	407b90 <assert_print>
  411fac:	aa1303e0 	mov	x0, x19
  411fb0:	5280b1a1 	mov	w1, #0x58d                 	// #1421
  411fb4:	97ffd721 	bl	407c38 <assert_post_action>
  411fb8:	5280b1a2 	mov	w2, #0x58d                 	// #1421
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411fbc:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  411fc0:	aa1303e1 	mov	x1, x19
  411fc4:	911f2000 	add	x0, x0, #0x7c8
  411fc8:	97ffe10e 	bl	40a400 <posix_print_error_and_exit>

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
  411fcc:	b5000116 	cbnz	x22, 411fec <z_tick_sleep+0x98>
	z_impl_k_yield();
  411fd0:	97ffff51 	bl	411d14 <z_impl_k_yield>
		k_yield();
		return 0;
  411fd4:	52800000 	mov	w0, #0x0                   	// #0
		return ticks;
	}
#endif

	return 0;
}
  411fd8:	a94153f3 	ldp	x19, x20, [sp, #16]
  411fdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411fe0:	f9401bf7 	ldr	x23, [sp, #48]
  411fe4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  411fe8:	d65f03c0 	ret
	if (Z_TICK_ABS(ticks) <= 0) {
  411fec:	b1000adf 	cmn	x22, #0x2
  411ff0:	540003ab 	b.lt	412064 <z_tick_sleep+0x110>  // b.tstop
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
  411ff4:	940003fe 	bl	412fec <sys_clock_tick_get_32>
  411ff8:	0b160013 	add	w19, w0, w22
  411ffc:	d00000d5 	adrp	x21, 42b000 <__FRAME_END__+0xff4c>
  412000:	97ffdfea 	bl	409fa8 <posix_irq_lock>
  412004:	2a0003f7 	mov	w23, w0
  412008:	f947cab5 	ldr	x21, [x21, #3984]
  41200c:	aa1503e0 	mov	x0, x21
  412010:	97fff18d 	bl	40e644 <z_spin_lock_valid>
  412014:	72001c1f 	tst	w0, #0xff
  412018:	540002c1 	b.ne	412070 <z_tick_sleep+0x11c>  // b.any
  41201c:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412020:	91334a73 	add	x19, x19, #0xcd2
  412024:	aa1303e2 	mov	x2, x19
  412028:	52801283 	mov	w3, #0x94                  	// #148
  41202c:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412030:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412034:	9133fc21 	add	x1, x1, #0xcff
  412038:	911e2800 	add	x0, x0, #0x78a
  41203c:	97ffd6d5 	bl	407b90 <assert_print>
  412040:	aa1503e1 	mov	x1, x21
  412044:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412048:	91345000 	add	x0, x0, #0xd14
  41204c:	97ffd6d1 	bl	407b90 <assert_print>
  412050:	aa1303e0 	mov	x0, x19
  412054:	52801281 	mov	w1, #0x94                  	// #148
  412058:	97ffd6f8 	bl	407c38 <assert_post_action>
  41205c:	52801282 	mov	w2, #0x94                  	// #148
  412060:	17ffffd7 	b	411fbc <z_tick_sleep+0x68>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
  412064:	12800033 	mov	w19, #0xfffffffe            	// #-2
  412068:	4b160273 	sub	w19, w19, w22
  41206c:	17ffffe4 	b	411ffc <z_tick_sleep+0xa8>
	z_spin_lock_set_owner(l);
  412070:	aa1503e0 	mov	x0, x21
  412074:	97fff18c 	bl	40e6a4 <z_spin_lock_set_owner>
	unready_thread(_current);
  412078:	f9472e94 	ldr	x20, [x20, #3672]
  41207c:	f9400a80 	ldr	x0, [x20, #16]
  412080:	97fffc58 	bl	4111e0 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  412084:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  412088:	aa1603e2 	mov	x2, x22
	z_add_thread_timeout(_current, timeout);
  41208c:	f9400a80 	ldr	x0, [x20, #16]
  412090:	f9472421 	ldr	x1, [x1, #3656]
  412094:	9100a000 	add	x0, x0, #0x28
  412098:	94000239 	bl	41297c <z_add_timeout>
	z_mark_thread_as_suspended(_current);
  41209c:	f9400a82 	ldr	x2, [x20, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4120a0:	aa1503e0 	mov	x0, x21
  4120a4:	39406441 	ldrb	w1, [x2, #25]
  4120a8:	321c0021 	orr	w1, w1, #0x10
  4120ac:	39006441 	strb	w1, [x2, #25]
  4120b0:	97fff170 	bl	40e670 <z_spin_unlock_valid>
  4120b4:	72001c1f 	tst	w0, #0xff
  4120b8:	54000261 	b.ne	412104 <z_tick_sleep+0x1b0>  // b.any
  4120bc:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  4120c0:	91334a73 	add	x19, x19, #0xcd2
  4120c4:	aa1303e2 	mov	x2, x19
  4120c8:	52801c43 	mov	w3, #0xe2                  	// #226
  4120cc:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  4120d0:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4120d4:	9134b021 	add	x1, x1, #0xd2c
  4120d8:	911e2800 	add	x0, x0, #0x78a
  4120dc:	97ffd6ad 	bl	407b90 <assert_print>
  4120e0:	aa1503e1 	mov	x1, x21
  4120e4:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  4120e8:	91350c00 	add	x0, x0, #0xd43
  4120ec:	97ffd6a9 	bl	407b90 <assert_print>
  4120f0:	aa1303e0 	mov	x0, x19
  4120f4:	52801c41 	mov	w1, #0xe2                  	// #226
  4120f8:	97ffd6d0 	bl	407c38 <assert_post_action>
  4120fc:	52801c42 	mov	w2, #0xe2                  	// #226
  412100:	17ffffaf 	b	411fbc <z_tick_sleep+0x68>
  412104:	2a1703e0 	mov	w0, w23
  412108:	97ffdc7e 	bl	409300 <arch_swap>
	return (thread->base.thread_state & state) != 0U;
  41210c:	f9400a80 	ldr	x0, [x20, #16]
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
  412110:	39406400 	ldrb	w0, [x0, #25]
  412114:	36200240 	tbz	w0, #4, 41215c <z_tick_sleep+0x208>
  412118:	90000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  41211c:	9112ca73 	add	x19, x19, #0x4b2
  412120:	aa1303e2 	mov	x2, x19
  412124:	90000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  412128:	911e4021 	add	x1, x1, #0x790
  41212c:	5280b523 	mov	w3, #0x5a9                 	// #1449
  412130:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412134:	911e2800 	add	x0, x0, #0x78a
  412138:	97ffd696 	bl	407b90 <assert_print>
  41213c:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412140:	9135a400 	add	x0, x0, #0xd69
  412144:	97ffd693 	bl	407b90 <assert_print>
  412148:	aa1303e0 	mov	x0, x19
  41214c:	5280b521 	mov	w1, #0x5a9                 	// #1449
  412150:	97ffd6ba 	bl	407c38 <assert_post_action>
  412154:	5280b522 	mov	w2, #0x5a9                 	// #1449
  412158:	17ffff99 	b	411fbc <z_tick_sleep+0x68>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
  41215c:	940003a4 	bl	412fec <sys_clock_tick_get_32>
  412160:	cb204260 	sub	x0, x19, w0, uxtw
		return ticks;
  412164:	f100001f 	cmp	x0, #0x0
  412168:	1a9fc000 	csel	w0, w0, wzr, gt
  41216c:	17ffff9b 	b	411fd8 <z_tick_sleep+0x84>

0000000000412170 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
  412170:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  412174:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  412178:	910003fd 	mov	x29, sp
  41217c:	f9472c21 	ldr	x1, [x1, #3672]
  412180:	f9000bf3 	str	x19, [sp, #16]
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
  412184:	b9400022 	ldr	w2, [x1]
  412188:	340002a2 	cbz	w2, 4121dc <z_impl_k_sleep+0x6c>
  41218c:	90000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  412190:	9112ca73 	add	x19, x19, #0x4b2
  412194:	aa1303e2 	mov	x2, x19
  412198:	90000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  41219c:	91089021 	add	x1, x1, #0x224
  4121a0:	5280b703 	mov	w3, #0x5b8                 	// #1464
  4121a4:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4121a8:	911e2800 	add	x0, x0, #0x78a
  4121ac:	97ffd679 	bl	407b90 <assert_print>
  4121b0:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  4121b4:	9135a400 	add	x0, x0, #0xd69
  4121b8:	97ffd676 	bl	407b90 <assert_print>
  4121bc:	aa1303e0 	mov	x0, x19
  4121c0:	5280b701 	mov	w1, #0x5b8                 	// #1464
  4121c4:	97ffd69d 	bl	407c38 <assert_post_action>
  4121c8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4121cc:	aa1303e1 	mov	x1, x19
  4121d0:	911f2000 	add	x0, x0, #0x7c8
  4121d4:	5280b702 	mov	w2, #0x5b8                 	// #1464
  4121d8:	97ffe08a 	bl	40a400 <posix_print_error_and_exit>
  4121dc:	aa0003f3 	mov	x19, x0

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4121e0:	b100041f 	cmn	x0, #0x1
  4121e4:	540000e1 	b.ne	412200 <z_impl_k_sleep+0x90>  // b.any
		k_thread_suspend(_current);
  4121e8:	f9400820 	ldr	x0, [x1, #16]
	z_impl_k_thread_suspend(thread);
  4121ec:	97fffd58 	bl	41174c <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
  4121f0:	2a1303e0 	mov	w0, w19
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
  4121f4:	f9400bf3 	ldr	x19, [sp, #16]
  4121f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4121fc:	d65f03c0 	ret
	ticks = z_tick_sleep(ticks);
  412200:	97ffff55 	bl	411f54 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
  412204:	52800141 	mov	w1, #0xa                   	// #10
  412208:	1b017c00 	mul	w0, w0, w1
	return ret;
  41220c:	17fffffa 	b	4121f4 <z_impl_k_sleep+0x84>

0000000000412210 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
  412210:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  412214:	f9472c00 	ldr	x0, [x0, #3672]
  412218:	f9400800 	ldr	x0, [x0, #16]
  41221c:	d65f03c0 	ret

0000000000412220 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
  412220:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412224:	910003fd 	mov	x29, sp
  412228:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41222c:	b00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xff4c>
  412230:	aa0003f3 	mov	x19, x0
  412234:	a9025bf5 	stp	x21, x22, [sp, #32]
  412238:	f9001bf7 	str	x23, [sp, #48]
  41223c:	97ffdf5b 	bl	409fa8 <posix_irq_lock>
  412240:	f947ca96 	ldr	x22, [x20, #3984]
  412244:	2a0003f5 	mov	w21, w0
  412248:	aa1603e0 	mov	x0, x22
  41224c:	97fff0fe 	bl	40e644 <z_spin_lock_valid>
  412250:	72001c1f 	tst	w0, #0xff
  412254:	540002c1 	b.ne	4122ac <z_thread_abort+0x8c>  // b.any
  412258:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  41225c:	91334a73 	add	x19, x19, #0xcd2
  412260:	aa1303e2 	mov	x2, x19
  412264:	52801283 	mov	w3, #0x94                  	// #148
  412268:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  41226c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412270:	9133fc21 	add	x1, x1, #0xcff
  412274:	911e2800 	add	x0, x0, #0x78a
  412278:	97ffd646 	bl	407b90 <assert_print>
  41227c:	aa1603e1 	mov	x1, x22
  412280:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412284:	91345000 	add	x0, x0, #0xd14
  412288:	97ffd642 	bl	407b90 <assert_print>
  41228c:	aa1303e0 	mov	x0, x19
  412290:	52801281 	mov	w1, #0x94                  	// #148
  412294:	97ffd669 	bl	407c38 <assert_post_action>
  412298:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41229c:	aa1303e1 	mov	x1, x19
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
  4122a0:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4122a4:	911f2000 	add	x0, x0, #0x7c8
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
  4122a8:	97ffe056 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4122ac:	aa1603e0 	mov	x0, x22
  4122b0:	97fff0fd 	bl	40e6a4 <z_spin_lock_set_owner>
	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
  4122b4:	39406260 	ldrb	w0, [x19, #24]
  4122b8:	36000580 	tbz	w0, #0, 412368 <z_thread_abort+0x148>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4122bc:	aa1603e0 	mov	x0, x22
  4122c0:	97fff0ec 	bl	40e670 <z_spin_unlock_valid>
  4122c4:	72001c1f 	tst	w0, #0xff
  4122c8:	54000261 	b.ne	412314 <z_thread_abort+0xf4>  // b.any
  4122cc:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  4122d0:	91334a73 	add	x19, x19, #0xcd2
  4122d4:	aa1303e2 	mov	x2, x19
  4122d8:	52801863 	mov	w3, #0xc3                  	// #195
  4122dc:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  4122e0:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4122e4:	9134b021 	add	x1, x1, #0xd2c
  4122e8:	911e2800 	add	x0, x0, #0x78a
  4122ec:	97ffd629 	bl	407b90 <assert_print>
  4122f0:	f947ca81 	ldr	x1, [x20, #3984]
  4122f4:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  4122f8:	91350c00 	add	x0, x0, #0xd43
  4122fc:	97ffd625 	bl	407b90 <assert_print>
  412300:	aa1303e0 	mov	x0, x19
  412304:	52801861 	mov	w1, #0xc3                  	// #195
  412308:	97ffd64c 	bl	407c38 <assert_post_action>
  41230c:	52801862 	mov	w2, #0xc3                  	// #195
  412310:	17ffffe3 	b	41229c <z_thread_abort+0x7c>
	posix_irq_unlock(key);
  412314:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborting essential thread %p", thread);
  412318:	90000034 	adrp	x20, 416000 <__func__.0+0xb3f>
  41231c:	97ffdf25 	bl	409fb0 <posix_irq_unlock>
  412320:	9112ca94 	add	x20, x20, #0x4b2
  412324:	aa1403e2 	mov	x2, x20
  412328:	5280d9c3 	mov	w3, #0x6ce                 	// #1742
  41232c:	90000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  412330:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412334:	9122f821 	add	x1, x1, #0x8be
  412338:	911e2800 	add	x0, x0, #0x78a
  41233c:	97ffd615 	bl	407b90 <assert_print>
  412340:	aa1303e1 	mov	x1, x19
  412344:	90000020 	adrp	x0, 416000 <__func__.0+0xb3f>
  412348:	911f4000 	add	x0, x0, #0x7d0
  41234c:	97ffd611 	bl	407b90 <assert_print>
  412350:	5280d9c1 	mov	w1, #0x6ce                 	// #1742
  412354:	aa1403e0 	mov	x0, x20
  412358:	97ffd638 	bl	407c38 <assert_post_action>
  41235c:	aa1403e1 	mov	x1, x20
  412360:	5280d9c2 	mov	w2, #0x6ce                 	// #1742
  412364:	17ffffcf 	b	4122a0 <z_thread_abort+0x80>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  412368:	39406661 	ldrb	w1, [x19, #25]
  41236c:	36180161 	tbz	w1, #3, 412398 <z_thread_abort+0x178>
  412370:	aa1603e0 	mov	x0, x22
  412374:	97fff0bf 	bl	40e670 <z_spin_unlock_valid>
  412378:	72001c1f 	tst	w0, #0xff
  41237c:	54fffa80 	b.eq	4122cc <z_thread_abort+0xac>  // b.none
  412380:	2a1503e0 	mov	w0, w21
	}
	k_spin_unlock(&sched_spinlock, key);
}
  412384:	a94153f3 	ldp	x19, x20, [sp, #16]
  412388:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41238c:	f9401bf7 	ldr	x23, [sp, #48]
  412390:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412394:	17ffdf07 	b	409fb0 <posix_irq_unlock>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  412398:	121a7820 	and	w0, w1, #0xffffffdf
  41239c:	321d0002 	orr	w2, w0, #0x8
		if (z_is_thread_queued(thread)) {
  4123a0:	37380600 	tbnz	w0, #7, 412460 <z_thread_abort+0x240>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  4123a4:	39006662 	strb	w2, [x19, #25]
		if (thread->base.pended_on != NULL) {
  4123a8:	f9400a60 	ldr	x0, [x19, #16]
  4123ac:	b4000060 	cbz	x0, 4123b8 <z_thread_abort+0x198>
			unpend_thread_no_timeout(thread);
  4123b0:	aa1303e0 	mov	x0, x19
  4123b4:	97fff920 	bl	410834 <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  4123b8:	91018277 	add	x23, x19, #0x60
	return z_abort_timeout(&thread->base.timeout);
  4123bc:	9100a260 	add	x0, x19, #0x28
  4123c0:	94000201 	bl	412bc4 <z_abort_timeout>
	return list->head == list;
  4123c4:	f9403276 	ldr	x22, [x19, #96]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4123c8:	eb1702df 	cmp	x22, x23
  4123cc:	54000040 	b.eq	4123d4 <z_thread_abort+0x1b4>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  4123d0:	b50005d6 	cbnz	x22, 412488 <z_thread_abort+0x268>
		update_cache(1);
  4123d4:	52800020 	mov	w0, #0x1                   	// #1
  4123d8:	97fff982 	bl	4109e0 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
  4123dc:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4123e0:	f9472c00 	ldr	x0, [x0, #3672]
  4123e4:	f9400801 	ldr	x1, [x0, #16]
  4123e8:	eb13003f 	cmp	x1, x19
  4123ec:	54000821 	b.ne	4124f0 <z_thread_abort+0x2d0>  // b.any
  4123f0:	b9400000 	ldr	w0, [x0]
  4123f4:	350007e0 	cbnz	w0, 4124f0 <z_thread_abort+0x2d0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4123f8:	f947ca94 	ldr	x20, [x20, #3984]
  4123fc:	d0000017 	adrp	x23, 414000 <dlc_table.0+0x78d>
  412400:	d0000016 	adrp	x22, 414000 <dlc_table.0+0x78d>
  412404:	aa1403e0 	mov	x0, x20
  412408:	97fff09a 	bl	40e670 <z_spin_unlock_valid>
  41240c:	72001c1f 	tst	w0, #0xff
  412410:	540004c1 	b.ne	4124a8 <z_thread_abort+0x288>  // b.any
  412414:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412418:	91334a73 	add	x19, x19, #0xcd2
  41241c:	aa1303e2 	mov	x2, x19
  412420:	52801c43 	mov	w3, #0xe2                  	// #226
  412424:	911e2ae0 	add	x0, x23, #0x78a
  412428:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  41242c:	9134b021 	add	x1, x1, #0xd2c
  412430:	97ffd5d8 	bl	407b90 <assert_print>
  412434:	aa1403e1 	mov	x1, x20
  412438:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  41243c:	91350c00 	add	x0, x0, #0xd43
  412440:	97ffd5d4 	bl	407b90 <assert_print>
  412444:	aa1303e0 	mov	x0, x19
  412448:	52801c41 	mov	w1, #0xe2                  	// #226
  41244c:	97ffd5fb 	bl	407c38 <assert_post_action>
  412450:	52801c42 	mov	w2, #0xe2                  	// #226
		__ASSERT(false, "aborted _current back from dead");
  412454:	aa1303e1 	mov	x1, x19
  412458:	911f22c0 	add	x0, x22, #0x7c8
  41245c:	17ffff93 	b	4122a8 <z_thread_abort+0x88>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  412460:	52800be0 	mov	w0, #0x5f                  	// #95
  412464:	0a000021 	and	w1, w1, w0
	_priq_run_remove(thread_runq(thread), thread);
  412468:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  41246c:	321d0021 	orr	w1, w1, #0x8
  412470:	39006661 	strb	w1, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  412474:	aa1303e1 	mov	x1, x19
  412478:	f9472c00 	ldr	x0, [x0, #3672]
  41247c:	9100c000 	add	x0, x0, #0x30
  412480:	97fff8d0 	bl	4107c0 <z_priq_dumb_remove>
}
  412484:	17ffffc9 	b	4123a8 <z_thread_abort+0x188>
		unpend_thread_no_timeout(thread);
  412488:	aa1603e0 	mov	x0, x22
  41248c:	97fff8ea 	bl	410834 <unpend_thread_no_timeout>
  412490:	9100a2c0 	add	x0, x22, #0x28
  412494:	940001cc 	bl	412bc4 <z_abort_timeout>
	thread->callee_saved.retval = value;
  412498:	b9004edf 	str	wzr, [x22, #76]
		ready_thread(thread);
  41249c:	aa1603e0 	mov	x0, x22
  4124a0:	97fffa21 	bl	410d24 <ready_thread>
  4124a4:	17ffffc8 	b	4123c4 <z_thread_abort+0x1a4>
  4124a8:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborted _current back from dead");
  4124ac:	90000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  4124b0:	97ffdb94 	bl	409300 <arch_swap>
  4124b4:	9112ca73 	add	x19, x19, #0x4b2
  4124b8:	aa1303e2 	mov	x2, x19
  4124bc:	90000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  4124c0:	9122f821 	add	x1, x1, #0x8be
  4124c4:	5280e083 	mov	w3, #0x704                 	// #1796
  4124c8:	911e2ae0 	add	x0, x23, #0x78a
  4124cc:	97ffd5b1 	bl	407b90 <assert_print>
  4124d0:	90000020 	adrp	x0, 416000 <__func__.0+0xb3f>
  4124d4:	911fbc00 	add	x0, x0, #0x7ef
  4124d8:	97ffd5ae 	bl	407b90 <assert_print>
  4124dc:	aa1303e0 	mov	x0, x19
  4124e0:	5280e081 	mov	w1, #0x704                 	// #1796
  4124e4:	97ffd5d5 	bl	407c38 <assert_post_action>
  4124e8:	5280e082 	mov	w2, #0x704                 	// #1796
  4124ec:	17ffffda 	b	412454 <z_thread_abort+0x234>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4124f0:	f947ca80 	ldr	x0, [x20, #3984]
  4124f4:	17ffffa0 	b	412374 <z_thread_abort+0x154>

00000000004124f8 <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
  4124f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4124fc:	910003fd 	mov	x29, sp
  412500:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412504:	b00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  412508:	aa0003f4 	mov	x20, x0
  41250c:	a9025bf5 	stp	x21, x22, [sp, #32]
  412510:	aa0103f5 	mov	x21, x1
  412514:	f9001bf7 	str	x23, [sp, #48]
	return posix_irq_lock();
  412518:	97ffdea4 	bl	409fa8 <posix_irq_lock>
  41251c:	f947ca76 	ldr	x22, [x19, #3984]
  412520:	2a0003f7 	mov	w23, w0
  412524:	aa1603e0 	mov	x0, x22
  412528:	97fff047 	bl	40e644 <z_spin_lock_valid>
  41252c:	72001c1f 	tst	w0, #0xff
  412530:	540002c1 	b.ne	412588 <z_impl_k_thread_join+0x90>  // b.any
  412534:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412538:	91334a73 	add	x19, x19, #0xcd2
  41253c:	aa1303e2 	mov	x2, x19
  412540:	52801283 	mov	w3, #0x94                  	// #148
  412544:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412548:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  41254c:	9133fc21 	add	x1, x1, #0xcff
  412550:	911e2800 	add	x0, x0, #0x78a
  412554:	97ffd58f 	bl	407b90 <assert_print>
  412558:	aa1603e1 	mov	x1, x22
  41255c:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412560:	91345000 	add	x0, x0, #0xd14
  412564:	97ffd58b 	bl	407b90 <assert_print>
  412568:	aa1303e0 	mov	x0, x19
  41256c:	52801281 	mov	w1, #0x94                  	// #148
  412570:	97ffd5b2 	bl	407c38 <assert_post_action>
  412574:	52801282 	mov	w2, #0x94                  	// #148
		ret = -EBUSY;
	} else if ((thread == _current) ||
		   (thread->base.pended_on == &_current->join_queue)) {
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  412578:	aa1303e1 	mov	x1, x19
  41257c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412580:	911f2000 	add	x0, x0, #0x7c8
  412584:	97ffdf9f 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412588:	aa1603e0 	mov	x0, x22
  41258c:	97fff046 	bl	40e6a4 <z_spin_lock_set_owner>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  412590:	39406680 	ldrb	w0, [x20, #25]
  412594:	371808c0 	tbnz	w0, #3, 4126ac <z_impl_k_thread_join+0x1b4>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  412598:	b4000bb5 	cbz	x21, 41270c <z_impl_k_thread_join+0x214>
	} else if ((thread == _current) ||
  41259c:	b00000d6 	adrp	x22, 42b000 <__FRAME_END__+0xff4c>
  4125a0:	f9472ed6 	ldr	x22, [x22, #3672]
  4125a4:	f9400ac0 	ldr	x0, [x22, #16]
  4125a8:	eb14001f 	cmp	x0, x20
  4125ac:	54000b40 	b.eq	412714 <z_impl_k_thread_join+0x21c>  // b.none
  4125b0:	f9400a82 	ldr	x2, [x20, #16]
		   (thread->base.pended_on == &_current->join_queue)) {
  4125b4:	91018001 	add	x1, x0, #0x60
	} else if ((thread == _current) ||
  4125b8:	eb01005f 	cmp	x2, x1
  4125bc:	54000ac0 	b.eq	412714 <z_impl_k_thread_join+0x21c>  // b.none
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  4125c0:	b94002c1 	ldr	w1, [x22]
  4125c4:	34000241 	cbz	w1, 41260c <z_impl_k_thread_join+0x114>
  4125c8:	90000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  4125cc:	9112ca73 	add	x19, x19, #0x4b2
  4125d0:	aa1303e2 	mov	x2, x19
  4125d4:	90000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  4125d8:	91089021 	add	x1, x1, #0x224
  4125dc:	5280e483 	mov	w3, #0x724                 	// #1828
  4125e0:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4125e4:	911e2800 	add	x0, x0, #0x78a
  4125e8:	97ffd56a 	bl	407b90 <assert_print>
  4125ec:	90000020 	adrp	x0, 416000 <__func__.0+0xb3f>
  4125f0:	91204400 	add	x0, x0, #0x811
  4125f4:	97ffd567 	bl	407b90 <assert_print>
  4125f8:	aa1303e0 	mov	x0, x19
  4125fc:	5280e481 	mov	w1, #0x724                 	// #1828
  412600:	97ffd58e 	bl	407c38 <assert_post_action>
  412604:	5280e482 	mov	w2, #0x724                 	// #1828
  412608:	17ffffdc 	b	412578 <z_impl_k_thread_join+0x80>
		add_to_waitq_locked(_current, &thread->join_queue);
  41260c:	91018281 	add	x1, x20, #0x60
  412610:	97fffb09 	bl	411234 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  412614:	b10006bf 	cmn	x21, #0x1
  412618:	540000e0 	b.eq	412634 <z_impl_k_thread_join+0x13c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  41261c:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  412620:	aa1503e2 	mov	x2, x21
		add_thread_timeout(_current, timeout);
  412624:	f9400ac0 	ldr	x0, [x22, #16]
  412628:	f9472421 	ldr	x1, [x1, #3656]
  41262c:	9100a000 	add	x0, x0, #0x28
  412630:	940000d3 	bl	41297c <z_add_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412634:	f947ca73 	ldr	x19, [x19, #3984]
  412638:	aa1303e0 	mov	x0, x19
  41263c:	97fff00d 	bl	40e670 <z_spin_unlock_valid>
  412640:	72001c1f 	tst	w0, #0xff
  412644:	54000281 	b.ne	412694 <z_impl_k_thread_join+0x19c>  // b.any
  412648:	f0000014 	adrp	x20, 415000 <random_data+0xca4>
  41264c:	91334a94 	add	x20, x20, #0xcd2
  412650:	aa1403e2 	mov	x2, x20
  412654:	52801c43 	mov	w3, #0xe2                  	// #226
  412658:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  41265c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412660:	9134b021 	add	x1, x1, #0xd2c
  412664:	911e2800 	add	x0, x0, #0x78a
  412668:	97ffd54a 	bl	407b90 <assert_print>
  41266c:	aa1303e1 	mov	x1, x19
  412670:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412674:	91350c00 	add	x0, x0, #0xd43
  412678:	97ffd546 	bl	407b90 <assert_print>
  41267c:	aa1403e0 	mov	x0, x20
  412680:	52801c41 	mov	w1, #0xe2                  	// #226
  412684:	97ffd56d 	bl	407c38 <assert_post_action>
  412688:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41268c:	aa1403e1 	mov	x1, x20
  412690:	17ffffbb 	b	41257c <z_impl_k_thread_join+0x84>
  412694:	2a1703e0 	mov	w0, w23

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
  412698:	a94153f3 	ldp	x19, x20, [sp, #16]
  41269c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4126a0:	f9401bf7 	ldr	x23, [sp, #48]
  4126a4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4126a8:	17ffdb16 	b	409300 <arch_swap>
		ret = 0;
  4126ac:	52800014 	mov	w20, #0x0                   	// #0
  4126b0:	f947ca73 	ldr	x19, [x19, #3984]
  4126b4:	aa1303e0 	mov	x0, x19
  4126b8:	97ffefee 	bl	40e670 <z_spin_unlock_valid>
  4126bc:	72001c1f 	tst	w0, #0xff
  4126c0:	540002e1 	b.ne	41271c <z_impl_k_thread_join+0x224>  // b.any
  4126c4:	f0000014 	adrp	x20, 415000 <random_data+0xca4>
  4126c8:	91334a94 	add	x20, x20, #0xcd2
  4126cc:	aa1403e2 	mov	x2, x20
  4126d0:	52801863 	mov	w3, #0xc3                  	// #195
  4126d4:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  4126d8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4126dc:	9134b021 	add	x1, x1, #0xd2c
  4126e0:	911e2800 	add	x0, x0, #0x78a
  4126e4:	97ffd52b 	bl	407b90 <assert_print>
  4126e8:	aa1303e1 	mov	x1, x19
  4126ec:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  4126f0:	91350c00 	add	x0, x0, #0xd43
  4126f4:	97ffd527 	bl	407b90 <assert_print>
  4126f8:	aa1403e0 	mov	x0, x20
  4126fc:	52801861 	mov	w1, #0xc3                  	// #195
  412700:	97ffd54e 	bl	407c38 <assert_post_action>
  412704:	52801862 	mov	w2, #0xc3                  	// #195
  412708:	17ffffe1 	b	41268c <z_impl_k_thread_join+0x194>
		ret = -EBUSY;
  41270c:	128001f4 	mov	w20, #0xfffffff0            	// #-16
  412710:	17ffffe8 	b	4126b0 <z_impl_k_thread_join+0x1b8>
		ret = -EDEADLK;
  412714:	12800454 	mov	w20, #0xffffffdd            	// #-35
  412718:	17ffffe6 	b	4126b0 <z_impl_k_thread_join+0x1b8>
	posix_irq_unlock(key);
  41271c:	2a1703e0 	mov	w0, w23
  412720:	97ffde24 	bl	409fb0 <posix_irq_unlock>
}
  412724:	2a1403e0 	mov	w0, w20
  412728:	a94153f3 	ldp	x19, x20, [sp, #16]
  41272c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412730:	f9401bf7 	ldr	x23, [sp, #48]
  412734:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412738:	d65f03c0 	ret

000000000041273c <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
  41273c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  412740:	910003fd 	mov	x29, sp
  412744:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412748:	b00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xff4c>
  41274c:	aa0003f4 	mov	x20, x0
  412750:	a9025bf5 	stp	x21, x22, [sp, #32]
  412754:	a90363f7 	stp	x23, x24, [sp, #48]
  412758:	2a0103f8 	mov	w24, w1
  41275c:	aa0203f7 	mov	x23, x2
  412760:	f90023f9 	str	x25, [sp, #64]
	return posix_irq_lock();
  412764:	97ffde11 	bl	409fa8 <posix_irq_lock>
  412768:	f947ca79 	ldr	x25, [x19, #3984]
  41276c:	2a0003f6 	mov	w22, w0
  412770:	aa1903e0 	mov	x0, x25
  412774:	97ffefb4 	bl	40e644 <z_spin_lock_valid>
  412778:	72001c15 	ands	w21, w0, #0xff
  41277c:	540002c1 	b.ne	4127d4 <z_sched_wake+0x98>  // b.any
  412780:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412784:	91334a73 	add	x19, x19, #0xcd2
  412788:	aa1303e2 	mov	x2, x19
  41278c:	52801283 	mov	w3, #0x94                  	// #148
  412790:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412794:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412798:	9133fc21 	add	x1, x1, #0xcff
  41279c:	911e2800 	add	x0, x0, #0x78a
  4127a0:	97ffd4fc 	bl	407b90 <assert_print>
  4127a4:	aa1903e1 	mov	x1, x25
  4127a8:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  4127ac:	91345000 	add	x0, x0, #0xd14
  4127b0:	97ffd4f8 	bl	407b90 <assert_print>
  4127b4:	52801281 	mov	w1, #0x94                  	// #148
  4127b8:	aa1303e0 	mov	x0, x19
  4127bc:	97ffd51f 	bl	407c38 <assert_post_action>
  4127c0:	aa1303e1 	mov	x1, x19
  4127c4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4127c8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4127cc:	911f2000 	add	x0, x0, #0x7c8
  4127d0:	97ffdf0c 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4127d4:	aa1903e0 	mov	x0, x25
  4127d8:	97ffefb3 	bl	40e6a4 <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
  4127dc:	aa1403e0 	mov	x0, x20
  4127e0:	97fff87c 	bl	4109d0 <z_priq_dumb_best>
  4127e4:	aa0003f4 	mov	x20, x0

		if (thread != NULL) {
  4127e8:	b4000400 	cbz	x0, 412868 <z_sched_wake+0x12c>
	thread->base.swap_data = data;
  4127ec:	f9001017 	str	x23, [x0, #32]
  4127f0:	b9004c18 	str	w24, [x0, #76]
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
  4127f4:	97fff810 	bl	410834 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
  4127f8:	9100a280 	add	x0, x20, #0x28
  4127fc:	940000f2 	bl	412bc4 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
  412800:	aa1403e0 	mov	x0, x20
  412804:	97fff948 	bl	410d24 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412808:	f947ca73 	ldr	x19, [x19, #3984]
  41280c:	aa1303e0 	mov	x0, x19
  412810:	97ffef98 	bl	40e670 <z_spin_unlock_valid>
  412814:	72001c1f 	tst	w0, #0xff
  412818:	540002c1 	b.ne	412870 <z_sched_wake+0x134>  // b.any
  41281c:	f0000014 	adrp	x20, 415000 <random_data+0xca4>
  412820:	91334a94 	add	x20, x20, #0xcd2
  412824:	aa1403e2 	mov	x2, x20
  412828:	52801863 	mov	w3, #0xc3                  	// #195
  41282c:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412830:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412834:	9134b021 	add	x1, x1, #0xd2c
  412838:	911e2800 	add	x0, x0, #0x78a
  41283c:	97ffd4d5 	bl	407b90 <assert_print>
  412840:	aa1303e1 	mov	x1, x19
  412844:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412848:	91350c00 	add	x0, x0, #0xd43
  41284c:	97ffd4d1 	bl	407b90 <assert_print>
  412850:	52801861 	mov	w1, #0xc3                  	// #195
  412854:	aa1403e0 	mov	x0, x20
  412858:	97ffd4f8 	bl	407c38 <assert_post_action>
  41285c:	aa1403e1 	mov	x1, x20
  412860:	52801862 	mov	w2, #0xc3                  	// #195
  412864:	17ffffd9 	b	4127c8 <z_sched_wake+0x8c>
	bool ret = false;
  412868:	52800015 	mov	w21, #0x0                   	// #0
  41286c:	17ffffe7 	b	412808 <z_sched_wake+0xcc>
	posix_irq_unlock(key);
  412870:	2a1603e0 	mov	w0, w22
  412874:	97ffddcf 	bl	409fb0 <posix_irq_unlock>
			ret = true;
		}
	}

	return ret;
}
  412878:	2a1503e0 	mov	w0, w21
  41287c:	a94153f3 	ldp	x19, x20, [sp, #16]
  412880:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412884:	a94363f7 	ldp	x23, x24, [sp, #48]
  412888:	f94023f9 	ldr	x25, [sp, #64]
  41288c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  412890:	d65f03c0 	ret

0000000000412894 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
  412894:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  412898:	910003fd 	mov	x29, sp
  41289c:	f9000bf3 	str	x19, [sp, #16]
  4128a0:	aa0403f3 	mov	x19, x4
	int ret = z_pend_curr(lock, key, wait_q, timeout);
  4128a4:	97fffab1 	bl	411368 <z_pend_curr>

	if (data != NULL) {
  4128a8:	b40000d3 	cbz	x19, 4128c0 <z_sched_wait+0x2c>
		*data = _current->base.swap_data;
  4128ac:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  4128b0:	f9472c21 	ldr	x1, [x1, #3672]
  4128b4:	f9400821 	ldr	x1, [x1, #16]
  4128b8:	f9401021 	ldr	x1, [x1, #32]
  4128bc:	f9000261 	str	x1, [x19]
	}
	return ret;
}
  4128c0:	f9400bf3 	ldr	x19, [sp, #16]
  4128c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4128c8:	d65f03c0 	ret

00000000004128cc <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
  4128cc:	f00000c0 	adrp	x0, 42d000 <args_struct>
  4128d0:	b94c1000 	ldr	w0, [x0, #3088]
  4128d4:	35000040 	cbnz	w0, 4128dc <elapsed+0x10>
  4128d8:	17ffeaf3 	b	40d4a4 <sys_clock_elapsed>
}
  4128dc:	52800000 	mov	w0, #0x0                   	// #0
  4128e0:	d65f03c0 	ret

00000000004128e4 <next_timeout>:

static int32_t next_timeout(void)
{
  4128e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
  4128e8:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
  4128ec:	910fa001 	add	x1, x0, #0x3e8
  4128f0:	910003fd 	mov	x29, sp
  4128f4:	f9000bf3 	str	x19, [sp, #16]
  4128f8:	f941f413 	ldr	x19, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4128fc:	eb01027f 	cmp	x19, x1
  412900:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
  412904:	97fffff2 	bl	4128cc <elapsed>
	int32_t ret;

	if ((to == NULL) ||
  412908:	b4000173 	cbz	x19, 412934 <next_timeout+0x50>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
  41290c:	f9400e61 	ldr	x1, [x19, #24]
  412910:	cb20c021 	sub	x1, x1, w0, sxtw
	if ((to == NULL) ||
  412914:	b2407be0 	mov	x0, #0x7fffffff            	// #2147483647
  412918:	eb00003f 	cmp	x1, x0
  41291c:	5400006c 	b.gt	412928 <next_timeout+0x44>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
  412920:	f100003f 	cmp	x1, #0x0
  412924:	9a9fa020 	csel	x0, x1, xzr, ge  // ge = tcont
	}

	return ret;
}
  412928:	f9400bf3 	ldr	x19, [sp, #16]
  41292c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412930:	d65f03c0 	ret
		ret = MAX_WAIT;
  412934:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
  412938:	17fffffc 	b	412928 <next_timeout+0x44>

000000000041293c <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  41293c:	b4000160 	cbz	x0, 412968 <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
  412940:	d00000c1 	adrp	x1, 42c000 <__dso_handle>
  412944:	f941f821 	ldr	x1, [x1, #1008]
  412948:	eb01001f 	cmp	x0, x1
  41294c:	540000e0 	b.eq	412968 <remove_timeout+0x2c>  // b.none
  412950:	f9400001 	ldr	x1, [x0]
	if (next(t) != NULL) {
  412954:	b40000a1 	cbz	x1, 412968 <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
  412958:	f9400c03 	ldr	x3, [x0, #24]
  41295c:	f9400c22 	ldr	x2, [x1, #24]
  412960:	8b030042 	add	x2, x2, x3
  412964:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
  412968:	a9400801 	ldp	x1, x2, [x0]
	prev->next = next;
  41296c:	f9000041 	str	x1, [x2]
	next->prev = prev;
  412970:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
  412974:	a9007c1f 	stp	xzr, xzr, [x0]
}
  412978:	d65f03c0 	ret

000000000041297c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  41297c:	b100045f 	cmn	x2, #0x1
  412980:	54001200 	b.eq	412bc0 <z_add_timeout+0x244>  // b.none
{
  412984:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412988:	910003fd 	mov	x29, sp
  41298c:	a90153f3 	stp	x19, x20, [sp, #16]
  412990:	aa0003f3 	mov	x19, x0
  412994:	a9025bf5 	stp	x21, x22, [sp, #32]
  412998:	f9001bf7 	str	x23, [sp, #48]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
  41299c:	f9400000 	ldr	x0, [x0]
  4129a0:	b40002a0 	cbz	x0, 4129f4 <z_add_timeout+0x78>
  4129a4:	90000033 	adrp	x19, 416000 <__func__.0+0xb3f>
  4129a8:	91209a73 	add	x19, x19, #0x826
  4129ac:	aa1303e2 	mov	x2, x19
  4129b0:	90000021 	adrp	x1, 416000 <__func__.0+0xb3f>
  4129b4:	91212821 	add	x1, x1, #0x84a
  4129b8:	52800bc3 	mov	w3, #0x5e                  	// #94
  4129bc:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4129c0:	911e2800 	add	x0, x0, #0x78a
  4129c4:	97ffd473 	bl	407b90 <assert_print>
  4129c8:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  4129cc:	9135a400 	add	x0, x0, #0xd69
  4129d0:	97ffd470 	bl	407b90 <assert_print>
  4129d4:	aa1303e0 	mov	x0, x19
  4129d8:	52800bc1 	mov	w1, #0x5e                  	// #94
  4129dc:	97ffd497 	bl	407c38 <assert_post_action>
  4129e0:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4129e4:	aa1303e1 	mov	x1, x19
  4129e8:	911f2000 	add	x0, x0, #0x7c8
  4129ec:	52800bc2 	mov	w2, #0x5e                  	// #94
  4129f0:	97ffde84 	bl	40a400 <posix_print_error_and_exit>
	to->fn = fn;
  4129f4:	f9000a61 	str	x1, [x19, #16]
  4129f8:	aa0203f4 	mov	x20, x2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4129fc:	f00000d5 	adrp	x21, 42d000 <args_struct>
  412a00:	912682b7 	add	x23, x21, #0x9a0
	return posix_irq_lock();
  412a04:	97ffdd69 	bl	409fa8 <posix_irq_lock>
  412a08:	2a0003f6 	mov	w22, w0
  412a0c:	aa1703e0 	mov	x0, x23
  412a10:	97ffef0d 	bl	40e644 <z_spin_lock_valid>
  412a14:	72001c1f 	tst	w0, #0xff
  412a18:	540002c1 	b.ne	412a70 <z_add_timeout+0xf4>  // b.any
  412a1c:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412a20:	91334a73 	add	x19, x19, #0xcd2
  412a24:	aa1303e2 	mov	x2, x19
  412a28:	52801283 	mov	w3, #0x94                  	// #148
  412a2c:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412a30:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412a34:	9133fc21 	add	x1, x1, #0xcff
  412a38:	911e2800 	add	x0, x0, #0x78a
  412a3c:	97ffd455 	bl	407b90 <assert_print>
  412a40:	aa1703e1 	mov	x1, x23
  412a44:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412a48:	91345000 	add	x0, x0, #0xd14
  412a4c:	97ffd451 	bl	407b90 <assert_print>
  412a50:	aa1303e0 	mov	x0, x19
  412a54:	52801281 	mov	w1, #0x94                  	// #148
  412a58:	97ffd478 	bl	407c38 <assert_post_action>
  412a5c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412a60:	aa1303e1 	mov	x1, x19
  412a64:	911f2000 	add	x0, x0, #0x7c8
  412a68:	52801282 	mov	w2, #0x94                  	// #148
  412a6c:	97ffde65 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412a70:	aa1703e0 	mov	x0, x23
  412a74:	97ffef0c 	bl	40e6a4 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
  412a78:	b1000a9f 	cmn	x20, #0x2
  412a7c:	5400028c 	b.gt	412acc <z_add_timeout+0x150>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
  412a80:	f00000c0 	adrp	x0, 42d000 <args_struct>
  412a84:	92800023 	mov	x3, #0xfffffffffffffffe    	// #-2
  412a88:	f944cc00 	ldr	x0, [x0, #2456]
  412a8c:	cb000063 	sub	x3, x3, x0
  412a90:	cb140062 	sub	x2, x3, x20

			to->dticks = MAX(1, ticks);
  412a94:	f100005f 	cmp	x2, #0x0
  412a98:	9a9fc442 	csinc	x2, x2, xzr, gt
	return list->head == list;
  412a9c:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
  412aa0:	910fa001 	add	x1, x0, #0x3e8
  412aa4:	f9000e62 	str	x2, [x19, #24]
  412aa8:	f941f402 	ldr	x2, [x0, #1000]
	sys_dnode_t *const tail = list->tail;
  412aac:	f9400424 	ldr	x4, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412ab0:	eb01005f 	cmp	x2, x1
  412ab4:	540001e1 	b.ne	412af0 <z_add_timeout+0x174>  // b.any
	node->next = list;
  412ab8:	910fa001 	add	x1, x0, #0x3e8
	node->prev = tail;
  412abc:	a9001261 	stp	x1, x4, [x19]
	tail->next = node;
  412ac0:	f9000093 	str	x19, [x4]
	list->tail = node;
  412ac4:	f9000433 	str	x19, [x1, #8]
}
  412ac8:	14000015 	b	412b1c <z_add_timeout+0x1a0>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
  412acc:	91000694 	add	x20, x20, #0x1
  412ad0:	97ffff7f 	bl	4128cc <elapsed>
  412ad4:	8b20c282 	add	x2, x20, w0, sxtw
  412ad8:	17fffff1 	b	412a9c <z_add_timeout+0x120>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
  412adc:	cb030021 	sub	x1, x1, x3
  412ae0:	f9000e61 	str	x1, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
  412ae4:	eb02009f 	cmp	x4, x2
  412ae8:	54fffe80 	b.eq	412ab8 <z_add_timeout+0x13c>  // b.none
  412aec:	f9400042 	ldr	x2, [x2]
		for (t = first(); t != NULL; t = next(t)) {
  412af0:	b4fffe42 	cbz	x2, 412ab8 <z_add_timeout+0x13c>
			if (t->dticks > to->dticks) {
  412af4:	f9400c43 	ldr	x3, [x2, #24]
  412af8:	f9400e61 	ldr	x1, [x19, #24]
  412afc:	eb01007f 	cmp	x3, x1
  412b00:	54fffeed 	b.le	412adc <z_add_timeout+0x160>
				t->dticks -= to->dticks;
  412b04:	cb010063 	sub	x3, x3, x1
  412b08:	f9000c43 	str	x3, [x2, #24]
	sys_dnode_t *const prev = successor->prev;
  412b0c:	f9400441 	ldr	x1, [x2, #8]
	node->prev = prev;
  412b10:	a9000662 	stp	x2, x1, [x19]
	prev->next = node;
  412b14:	f9000033 	str	x19, [x1]
	successor->prev = node;
  412b18:	f9000453 	str	x19, [x2, #8]
	return list->head == list;
  412b1c:	910fa001 	add	x1, x0, #0x3e8
  412b20:	f941f400 	ldr	x0, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412b24:	eb01001f 	cmp	x0, x1
  412b28:	540000c0 	b.eq	412b40 <z_add_timeout+0x1c4>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
  412b2c:	eb00027f 	cmp	x19, x0
  412b30:	54000081 	b.ne	412b40 <z_add_timeout+0x1c4>  // b.any
			sys_clock_set_timeout(next_timeout(), false);
  412b34:	97ffff6c 	bl	4128e4 <next_timeout>
  412b38:	52800001 	mov	w1, #0x0                   	// #0
  412b3c:	97ffea51 	bl	40d480 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412b40:	912682b5 	add	x21, x21, #0x9a0
  412b44:	aa1503e0 	mov	x0, x21
  412b48:	97ffeeca 	bl	40e670 <z_spin_unlock_valid>
  412b4c:	72001c1f 	tst	w0, #0xff
  412b50:	540002c1 	b.ne	412ba8 <z_add_timeout+0x22c>  // b.any
  412b54:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412b58:	91334a73 	add	x19, x19, #0xcd2
  412b5c:	aa1303e2 	mov	x2, x19
  412b60:	52801863 	mov	w3, #0xc3                  	// #195
  412b64:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412b68:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412b6c:	9134b021 	add	x1, x1, #0xd2c
  412b70:	911e2800 	add	x0, x0, #0x78a
  412b74:	97ffd407 	bl	407b90 <assert_print>
  412b78:	aa1503e1 	mov	x1, x21
  412b7c:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412b80:	91350c00 	add	x0, x0, #0xd43
  412b84:	97ffd403 	bl	407b90 <assert_print>
  412b88:	aa1303e0 	mov	x0, x19
  412b8c:	52801861 	mov	w1, #0xc3                  	// #195
  412b90:	97ffd42a 	bl	407c38 <assert_post_action>
  412b94:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412b98:	aa1303e1 	mov	x1, x19
  412b9c:	911f2000 	add	x0, x0, #0x7c8
  412ba0:	52801862 	mov	w2, #0xc3                  	// #195
  412ba4:	97ffde17 	bl	40a400 <posix_print_error_and_exit>
	posix_irq_unlock(key);
  412ba8:	2a1603e0 	mov	w0, w22
		}
	}
}
  412bac:	a94153f3 	ldp	x19, x20, [sp, #16]
  412bb0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412bb4:	f9401bf7 	ldr	x23, [sp, #48]
  412bb8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412bbc:	17ffdcfd 	b	409fb0 <posix_irq_unlock>
  412bc0:	d65f03c0 	ret

0000000000412bc4 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
  412bc4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412bc8:	910003fd 	mov	x29, sp
  412bcc:	a90153f3 	stp	x19, x20, [sp, #16]
  412bd0:	aa0003f4 	mov	x20, x0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412bd4:	f00000d3 	adrp	x19, 42d000 <args_struct>
  412bd8:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  412bdc:	97ffdcf3 	bl	409fa8 <posix_irq_lock>
  412be0:	91268276 	add	x22, x19, #0x9a0
  412be4:	2a0003f5 	mov	w21, w0
  412be8:	aa1603e0 	mov	x0, x22
  412bec:	97ffee96 	bl	40e644 <z_spin_lock_valid>
  412bf0:	72001c1f 	tst	w0, #0xff
  412bf4:	540002c1 	b.ne	412c4c <z_abort_timeout+0x88>  // b.any
  412bf8:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412bfc:	91334a73 	add	x19, x19, #0xcd2
  412c00:	aa1303e2 	mov	x2, x19
  412c04:	52801283 	mov	w3, #0x94                  	// #148
  412c08:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412c0c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412c10:	9133fc21 	add	x1, x1, #0xcff
  412c14:	911e2800 	add	x0, x0, #0x78a
  412c18:	97ffd3de 	bl	407b90 <assert_print>
  412c1c:	aa1603e1 	mov	x1, x22
  412c20:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412c24:	91345000 	add	x0, x0, #0xd14
  412c28:	97ffd3da 	bl	407b90 <assert_print>
  412c2c:	aa1303e0 	mov	x0, x19
  412c30:	52801281 	mov	w1, #0x94                  	// #148
  412c34:	97ffd401 	bl	407c38 <assert_post_action>
  412c38:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412c3c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412c40:	aa1303e1 	mov	x1, x19
  412c44:	911f2000 	add	x0, x0, #0x7c8
  412c48:	97ffddee 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412c4c:	aa1603e0 	mov	x0, x22
  412c50:	97ffee95 	bl	40e6a4 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
  412c54:	f9400280 	ldr	x0, [x20]
  412c58:	b4000360 	cbz	x0, 412cc4 <z_abort_timeout+0x100>
			remove_timeout(to);
			ret = 0;
  412c5c:	52800016 	mov	w22, #0x0                   	// #0
			remove_timeout(to);
  412c60:	aa1403e0 	mov	x0, x20
  412c64:	97ffff36 	bl	41293c <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412c68:	91268274 	add	x20, x19, #0x9a0
  412c6c:	aa1403e0 	mov	x0, x20
  412c70:	97ffee80 	bl	40e670 <z_spin_unlock_valid>
  412c74:	72001c1f 	tst	w0, #0xff
  412c78:	540002a1 	b.ne	412ccc <z_abort_timeout+0x108>  // b.any
  412c7c:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412c80:	91334a73 	add	x19, x19, #0xcd2
  412c84:	aa1303e2 	mov	x2, x19
  412c88:	52801863 	mov	w3, #0xc3                  	// #195
  412c8c:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412c90:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412c94:	9134b021 	add	x1, x1, #0xd2c
  412c98:	911e2800 	add	x0, x0, #0x78a
  412c9c:	97ffd3bd 	bl	407b90 <assert_print>
  412ca0:	aa1403e1 	mov	x1, x20
  412ca4:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412ca8:	91350c00 	add	x0, x0, #0xd43
  412cac:	97ffd3b9 	bl	407b90 <assert_print>
  412cb0:	aa1303e0 	mov	x0, x19
  412cb4:	52801861 	mov	w1, #0xc3                  	// #195
  412cb8:	97ffd3e0 	bl	407c38 <assert_post_action>
  412cbc:	52801862 	mov	w2, #0xc3                  	// #195
  412cc0:	17ffffdf 	b	412c3c <z_abort_timeout+0x78>
	int ret = -EINVAL;
  412cc4:	128002b6 	mov	w22, #0xffffffea            	// #-22
  412cc8:	17ffffe8 	b	412c68 <z_abort_timeout+0xa4>
	posix_irq_unlock(key);
  412ccc:	2a1503e0 	mov	w0, w21
  412cd0:	97ffdcb8 	bl	409fb0 <posix_irq_unlock>
		}
	}

	return ret;
}
  412cd4:	2a1603e0 	mov	w0, w22
  412cd8:	a94153f3 	ldp	x19, x20, [sp, #16]
  412cdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412ce0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  412ce4:	d65f03c0 	ret

0000000000412ce8 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
  412ce8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  412cec:	910003fd 	mov	x29, sp
  412cf0:	a90153f3 	stp	x19, x20, [sp, #16]
  412cf4:	2a0003f3 	mov	w19, w0
  412cf8:	a9025bf5 	stp	x21, x22, [sp, #32]
  412cfc:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412d00:	f00000d7 	adrp	x23, 42d000 <args_struct>
  412d04:	912682f6 	add	x22, x23, #0x9a0
  412d08:	a9046bf9 	stp	x25, x26, [sp, #64]
  412d0c:	f9002bfb 	str	x27, [sp, #80]
	return posix_irq_lock();
  412d10:	97ffdca6 	bl	409fa8 <posix_irq_lock>
  412d14:	2a0003f4 	mov	w20, w0
  412d18:	aa1603e0 	mov	x0, x22
  412d1c:	97ffee4a 	bl	40e644 <z_spin_lock_valid>
  412d20:	72001c1f 	tst	w0, #0xff
  412d24:	540002c1 	b.ne	412d7c <sys_clock_announce+0x94>  // b.any
  412d28:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412d2c:	91334a73 	add	x19, x19, #0xcd2
  412d30:	aa1303e2 	mov	x2, x19
  412d34:	52801283 	mov	w3, #0x94                  	// #148
  412d38:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412d3c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412d40:	9133fc21 	add	x1, x1, #0xcff
  412d44:	911e2800 	add	x0, x0, #0x78a
  412d48:	97ffd392 	bl	407b90 <assert_print>
  412d4c:	912682e1 	add	x1, x23, #0x9a0
  412d50:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412d54:	91345000 	add	x0, x0, #0xd14
  412d58:	97ffd38e 	bl	407b90 <assert_print>
  412d5c:	aa1303e0 	mov	x0, x19
  412d60:	52801281 	mov	w1, #0x94                  	// #148
  412d64:	97ffd3b5 	bl	407c38 <assert_post_action>
  412d68:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412d6c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412d70:	aa1303e1 	mov	x1, x19
  412d74:	911f2000 	add	x0, x0, #0x7c8
  412d78:	97ffdda2 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412d7c:	aa1603e0 	mov	x0, x22
  412d80:	97ffee49 	bl	40e6a4 <z_spin_lock_set_owner>
	return list->head == list;
  412d84:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
  412d88:	f00000d8 	adrp	x24, 42d000 <args_struct>
  412d8c:	910fa01a 	add	x26, x0, #0x3e8
  412d90:	f00000d9 	adrp	x25, 42d000 <args_struct>
  412d94:	b90c1313 	str	w19, [x24, #3088]
  412d98:	f941f413 	ldr	x19, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412d9c:	eb1a027f 	cmp	x19, x26
  412da0:	54000740 	b.eq	412e88 <sys_clock_announce+0x1a0>  // b.none

	struct _timeout *t = first();

	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
  412da4:	9130431b 	add	x27, x24, #0xc10
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
  412da8:	f944cf20 	ldr	x0, [x25, #2456]
	     (t != NULL) && (t->dticks <= announce_remaining);
  412dac:	b9400361 	ldr	w1, [x27]
  412db0:	b40006d3 	cbz	x19, 412e88 <sys_clock_announce+0x1a0>
  412db4:	f9400e75 	ldr	x21, [x19, #24]
  412db8:	93407c22 	sxtw	x2, w1
  412dbc:	eb21c2bf 	cmp	x21, w1, sxtw
  412dc0:	5400008d 	b.le	412dd0 <sys_clock_announce+0xe8>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
  412dc4:	cb0202b5 	sub	x21, x21, x2
  412dc8:	f9000e75 	str	x21, [x19, #24]
  412dcc:	1400002f 	b	412e88 <sys_clock_announce+0x1a0>
		t->dticks = 0;
  412dd0:	f9000e7f 	str	xzr, [x19, #24]
		curr_tick += dt;
  412dd4:	8b35c000 	add	x0, x0, w21, sxtw
  412dd8:	f904cf20 	str	x0, [x25, #2456]
		remove_timeout(t);
  412ddc:	aa1303e0 	mov	x0, x19
  412de0:	97fffed7 	bl	41293c <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412de4:	aa1603e0 	mov	x0, x22
  412de8:	97ffee22 	bl	40e670 <z_spin_unlock_valid>
  412dec:	72001c1f 	tst	w0, #0xff
  412df0:	54000261 	b.ne	412e3c <sys_clock_announce+0x154>  // b.any
  412df4:	f0000013 	adrp	x19, 415000 <random_data+0xca4>
  412df8:	91334a73 	add	x19, x19, #0xcd2
  412dfc:	aa1303e2 	mov	x2, x19
  412e00:	52801863 	mov	w3, #0xc3                  	// #195
  412e04:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412e08:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412e0c:	9134b021 	add	x1, x1, #0xd2c
  412e10:	911e2800 	add	x0, x0, #0x78a
  412e14:	97ffd35f 	bl	407b90 <assert_print>
  412e18:	912682e1 	add	x1, x23, #0x9a0
  412e1c:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412e20:	91350c00 	add	x0, x0, #0xd43
  412e24:	97ffd35b 	bl	407b90 <assert_print>
  412e28:	aa1303e0 	mov	x0, x19
  412e2c:	52801861 	mov	w1, #0xc3                  	// #195
  412e30:	97ffd382 	bl	407c38 <assert_post_action>
  412e34:	52801862 	mov	w2, #0xc3                  	// #195
  412e38:	17ffffcd 	b	412d6c <sys_clock_announce+0x84>
	posix_irq_unlock(key);
  412e3c:	2a1403e0 	mov	w0, w20
  412e40:	97ffdc5c 	bl	409fb0 <posix_irq_unlock>
		t->fn(t);
  412e44:	f9400a61 	ldr	x1, [x19, #16]
  412e48:	aa1303e0 	mov	x0, x19
  412e4c:	d63f0020 	blr	x1
	return posix_irq_lock();
  412e50:	97ffdc56 	bl	409fa8 <posix_irq_lock>
  412e54:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412e58:	aa1603e0 	mov	x0, x22
  412e5c:	97ffedfa 	bl	40e644 <z_spin_lock_valid>
  412e60:	72001c1f 	tst	w0, #0xff
  412e64:	54fff620 	b.eq	412d28 <sys_clock_announce+0x40>  // b.none
	z_spin_lock_set_owner(l);
  412e68:	aa1603e0 	mov	x0, x22
  412e6c:	97ffee0e 	bl	40e6a4 <z_spin_lock_set_owner>
		announce_remaining -= dt;
  412e70:	b9400360 	ldr	w0, [x27]
	return list->head == list;
  412e74:	f9400353 	ldr	x19, [x26]
  412e78:	4b150000 	sub	w0, w0, w21
  412e7c:	b9000360 	str	w0, [x27]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412e80:	eb1a027f 	cmp	x19, x26
  412e84:	54fff921 	b.ne	412da8 <sys_clock_announce+0xc0>  // b.any
	}

	curr_tick += announce_remaining;
  412e88:	f944cf21 	ldr	x1, [x25, #2456]
  412e8c:	b98c1300 	ldrsw	x0, [x24, #3088]
	announce_remaining = 0;
  412e90:	b90c131f 	str	wzr, [x24, #3088]
	curr_tick += announce_remaining;
  412e94:	8b010000 	add	x0, x0, x1
  412e98:	f904cf20 	str	x0, [x25, #2456]

	sys_clock_set_timeout(next_timeout(), false);
  412e9c:	97fffe92 	bl	4128e4 <next_timeout>
  412ea0:	52800001 	mov	w1, #0x0                   	// #0
  412ea4:	97ffe977 	bl	40d480 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412ea8:	912682e0 	add	x0, x23, #0x9a0
  412eac:	97ffedf1 	bl	40e670 <z_spin_unlock_valid>
  412eb0:	72001c1f 	tst	w0, #0xff
  412eb4:	54fffa00 	b.eq	412df4 <sys_clock_announce+0x10c>  // b.none
	posix_irq_unlock(key);
  412eb8:	2a1403e0 	mov	w0, w20
  412ebc:	97ffdc3d 	bl	409fb0 <posix_irq_unlock>
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
  412ec0:	a94153f3 	ldp	x19, x20, [sp, #16]
  412ec4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412ec8:	a94363f7 	ldp	x23, x24, [sp, #48]
  412ecc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  412ed0:	f9402bfb 	ldr	x27, [sp, #80]
  412ed4:	a8c67bfd 	ldp	x29, x30, [sp], #96
	z_time_slice();
  412ed8:	17fff741 	b	410bdc <z_time_slice>

0000000000412edc <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
  412edc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412ee0:	910003fd 	mov	x29, sp
  412ee4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412ee8:	f00000d3 	adrp	x19, 42d000 <args_struct>
  412eec:	91268273 	add	x19, x19, #0x9a0
  412ef0:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  412ef4:	97ffdc2d 	bl	409fa8 <posix_irq_lock>
  412ef8:	2a0003f5 	mov	w21, w0
  412efc:	aa1303e0 	mov	x0, x19
  412f00:	97ffedd1 	bl	40e644 <z_spin_lock_valid>
  412f04:	72001c1f 	tst	w0, #0xff
  412f08:	540002c1 	b.ne	412f60 <sys_clock_tick_get+0x84>  // b.any
  412f0c:	f0000014 	adrp	x20, 415000 <random_data+0xca4>
  412f10:	91334a94 	add	x20, x20, #0xcd2
  412f14:	aa1403e2 	mov	x2, x20
  412f18:	52801283 	mov	w3, #0x94                  	// #148
  412f1c:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412f20:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412f24:	9133fc21 	add	x1, x1, #0xcff
  412f28:	911e2800 	add	x0, x0, #0x78a
  412f2c:	97ffd319 	bl	407b90 <assert_print>
  412f30:	aa1303e1 	mov	x1, x19
  412f34:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412f38:	91345000 	add	x0, x0, #0xd14
  412f3c:	97ffd315 	bl	407b90 <assert_print>
  412f40:	aa1403e0 	mov	x0, x20
  412f44:	52801281 	mov	w1, #0x94                  	// #148
  412f48:	97ffd33c 	bl	407c38 <assert_post_action>
  412f4c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412f50:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412f54:	aa1403e1 	mov	x1, x20
  412f58:	911f2000 	add	x0, x0, #0x7c8
  412f5c:	97ffdd29 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412f60:	aa1303e0 	mov	x0, x19
  412f64:	97ffedd0 	bl	40e6a4 <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
  412f68:	97fffe59 	bl	4128cc <elapsed>
  412f6c:	f00000c1 	adrp	x1, 42d000 <args_struct>
  412f70:	f944cc21 	ldr	x1, [x1, #2456]
  412f74:	8b20c034 	add	x20, x1, w0, sxtw
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412f78:	aa1303e0 	mov	x0, x19
  412f7c:	97ffedbd 	bl	40e670 <z_spin_unlock_valid>
  412f80:	72001c1f 	tst	w0, #0xff
  412f84:	54000261 	b.ne	412fd0 <sys_clock_tick_get+0xf4>  // b.any
  412f88:	f0000014 	adrp	x20, 415000 <random_data+0xca4>
  412f8c:	91334a94 	add	x20, x20, #0xcd2
  412f90:	aa1403e2 	mov	x2, x20
  412f94:	52801863 	mov	w3, #0xc3                  	// #195
  412f98:	f0000001 	adrp	x1, 415000 <random_data+0xca4>
  412f9c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  412fa0:	9134b021 	add	x1, x1, #0xd2c
  412fa4:	911e2800 	add	x0, x0, #0x78a
  412fa8:	97ffd2fa 	bl	407b90 <assert_print>
  412fac:	aa1303e1 	mov	x1, x19
  412fb0:	f0000000 	adrp	x0, 415000 <random_data+0xca4>
  412fb4:	91350c00 	add	x0, x0, #0xd43
  412fb8:	97ffd2f6 	bl	407b90 <assert_print>
  412fbc:	aa1403e0 	mov	x0, x20
  412fc0:	52801861 	mov	w1, #0xc3                  	// #195
  412fc4:	97ffd31d 	bl	407c38 <assert_post_action>
  412fc8:	52801862 	mov	w2, #0xc3                  	// #195
  412fcc:	17ffffe1 	b	412f50 <sys_clock_tick_get+0x74>
	posix_irq_unlock(key);
  412fd0:	2a1503e0 	mov	w0, w21
  412fd4:	97ffdbf7 	bl	409fb0 <posix_irq_unlock>
	}
	return t;
}
  412fd8:	aa1403e0 	mov	x0, x20
  412fdc:	a94153f3 	ldp	x19, x20, [sp, #16]
  412fe0:	f94013f5 	ldr	x21, [sp, #32]
  412fe4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  412fe8:	d65f03c0 	ret

0000000000412fec <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
  412fec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  412ff0:	910003fd 	mov	x29, sp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
  412ff4:	97ffffba 	bl	412edc <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
  412ff8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  412ffc:	d65f03c0 	ret

0000000000413000 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
  413000:	17ffffb7 	b	412edc <sys_clock_tick_get>

0000000000413004 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
  413004:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  413008:	910003fd 	mov	x29, sp
  41300c:	f9000bf3 	str	x19, [sp, #16]
  413010:	aa0003f3 	mov	x19, x0
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  413014:	b100041f 	cmn	x0, #0x1
  413018:	54000180 	b.eq	413048 <sys_clock_timeout_end_calc+0x44>  // b.none
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  41301c:	b5000080 	cbnz	x0, 41302c <sys_clock_timeout_end_calc+0x28>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
  413020:	f9400bf3 	ldr	x19, [sp, #16]
  413024:	a8c27bfd 	ldp	x29, x30, [sp], #32
		return sys_clock_tick_get();
  413028:	17ffffad 	b	412edc <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
  41302c:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
  413030:	eb130000 	subs	x0, x0, x19
  413034:	540000a5 	b.pl	413048 <sys_clock_timeout_end_calc+0x44>  // b.nfrst
		return sys_clock_tick_get() + MAX(1, dt);
  413038:	97ffffa9 	bl	412edc <sys_clock_tick_get>
  41303c:	f100027f 	cmp	x19, #0x0
  413040:	9a9fc673 	csinc	x19, x19, xzr, gt
  413044:	8b000260 	add	x0, x19, x0
}
  413048:	f9400bf3 	ldr	x19, [sp, #16]
  41304c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  413050:	d65f03c0 	ret

0000000000413054 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  413054:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  413058:	910003fd 	mov	x29, sp
  41305c:	a90153f3 	stp	x19, x20, [sp, #16]
  413060:	aa0003f3 	mov	x19, x0
  413064:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  413068:	97ffdbd0 	bl	409fa8 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41306c:	d00000d6 	adrp	x22, 42d000 <args_struct>
  413070:	9126a2d5 	add	x21, x22, #0x9a8
  413074:	2a0003f4 	mov	w20, w0
  413078:	aa1503e0 	mov	x0, x21
  41307c:	97ffed72 	bl	40e644 <z_spin_lock_valid>
  413080:	72001c1f 	tst	w0, #0xff
  413084:	540002c1 	b.ne	4130dc <z_timer_expiration_handler+0x88>  // b.any
  413088:	d0000013 	adrp	x19, 415000 <random_data+0xca4>
  41308c:	91334a73 	add	x19, x19, #0xcd2
  413090:	aa1303e2 	mov	x2, x19
  413094:	52801283 	mov	w3, #0x94                  	// #148
  413098:	d0000001 	adrp	x1, 415000 <random_data+0xca4>
  41309c:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4130a0:	9133fc21 	add	x1, x1, #0xcff
  4130a4:	911e2800 	add	x0, x0, #0x78a
  4130a8:	97ffd2ba 	bl	407b90 <assert_print>
  4130ac:	9126a2c1 	add	x1, x22, #0x9a8
  4130b0:	d0000000 	adrp	x0, 415000 <random_data+0xca4>
  4130b4:	91345000 	add	x0, x0, #0xd14
  4130b8:	97ffd2b6 	bl	407b90 <assert_print>
  4130bc:	aa1303e0 	mov	x0, x19
  4130c0:	52801281 	mov	w1, #0x94                  	// #148
  4130c4:	97ffd2dd 	bl	407c38 <assert_post_action>
  4130c8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4130cc:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4130d0:	aa1303e1 	mov	x1, x19
  4130d4:	911f2000 	add	x0, x0, #0x7c8
  4130d8:	97ffdcca 	bl	40a400 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4130dc:	aa1503e0 	mov	x0, x21
  4130e0:	97ffed71 	bl	40e6a4 <z_spin_lock_set_owner>
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
  4130e4:	f9400260 	ldr	x0, [x19]
  4130e8:	b40002e0 	cbz	x0, 413144 <z_timer_expiration_handler+0xf0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4130ec:	aa1503e0 	mov	x0, x21
  4130f0:	97ffed60 	bl	40e670 <z_spin_unlock_valid>
  4130f4:	72001c1f 	tst	w0, #0xff
  4130f8:	540008e1 	b.ne	413214 <z_timer_expiration_handler+0x1c0>  // b.any
  4130fc:	d0000013 	adrp	x19, 415000 <random_data+0xca4>
  413100:	91334a73 	add	x19, x19, #0xcd2
  413104:	aa1303e2 	mov	x2, x19
  413108:	52801863 	mov	w3, #0xc3                  	// #195
  41310c:	d0000001 	adrp	x1, 415000 <random_data+0xca4>
  413110:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  413114:	9134b021 	add	x1, x1, #0xd2c
  413118:	911e2800 	add	x0, x0, #0x78a
  41311c:	97ffd29d 	bl	407b90 <assert_print>
  413120:	9126a2c1 	add	x1, x22, #0x9a8
  413124:	d0000000 	adrp	x0, 415000 <random_data+0xca4>
  413128:	91350c00 	add	x0, x0, #0xd43
  41312c:	97ffd299 	bl	407b90 <assert_print>
  413130:	aa1303e0 	mov	x0, x19
  413134:	52801861 	mov	w1, #0xc3                  	// #195
  413138:	97ffd2c0 	bl	407c38 <assert_post_action>
  41313c:	52801862 	mov	w2, #0xc3                  	// #195
  413140:	17ffffe3 	b	4130cc <z_timer_expiration_handler+0x78>

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
  413144:	f9402260 	ldr	x0, [x19, #64]
  413148:	91000401 	add	x1, x0, #0x1
  41314c:	f100043f 	cmp	x1, #0x1
  413150:	54000249 	b.ls	413198 <z_timer_expiration_handler+0x144>  // b.plast
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		k_timeout_t next = timer->period;

		/* see note about z_add_timeout() in z_impl_k_timer_start() */
		next.ticks = MAX(next.ticks - 1, 0);
  413154:	f100001f 	cmp	x0, #0x0
  413158:	9a9fc400 	csinc	x0, x0, xzr, gt
  41315c:	d1000415 	sub	x21, x0, #0x1
	return z_impl_k_uptime_ticks();
  413160:	97ffffa8 	bl	413000 <z_impl_k_uptime_ticks>
		 * we "should" have run.  Requires absolute timeouts.
		 * (Note offset by one: we're nominally at the
		 * beginning of a tick, so need to defeat the "round
		 * down" behavior on timeout addition).
		 */
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
  413164:	91000400 	add	x0, x0, #0x1
  413168:	8b150000 	add	x0, x0, x21
  41316c:	f100001f 	cmp	x0, #0x0
  413170:	540004ed 	b.le	41320c <z_timer_expiration_handler+0x1b8>
  413174:	97ffffa3 	bl	413000 <z_impl_k_uptime_ticks>
  413178:	91000400 	add	x0, x0, #0x1
  41317c:	8b150000 	add	x0, x0, x21
  413180:	92800022 	mov	x2, #0xfffffffffffffffe    	// #-2
  413184:	cb000042 	sub	x2, x2, x0
#endif
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  413188:	900000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
  41318c:	aa1303e0 	mov	x0, x19
  413190:	f947d821 	ldr	x1, [x1, #4016]
  413194:	97fffdfa 	bl	41297c <z_add_timeout>
			      next);
	}

	/* update timer's status */
	timer->status += 1U;
  413198:	b9404a60 	ldr	w0, [x19, #72]
  41319c:	11000400 	add	w0, w0, #0x1
  4131a0:	b9004a60 	str	w0, [x19, #72]

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  4131a4:	f9401a60 	ldr	x0, [x19, #48]
  4131a8:	b4000260 	cbz	x0, 4131f4 <z_timer_expiration_handler+0x1a0>
  4131ac:	9126a2d5 	add	x21, x22, #0x9a8
  4131b0:	aa1503e0 	mov	x0, x21
  4131b4:	97ffed2f 	bl	40e670 <z_spin_unlock_valid>
  4131b8:	72001c1f 	tst	w0, #0xff
  4131bc:	54fffa00 	b.eq	4130fc <z_timer_expiration_handler+0xa8>  // b.none
	posix_irq_unlock(key);
  4131c0:	2a1403e0 	mov	w0, w20
  4131c4:	97ffdb7b 	bl	409fb0 <posix_irq_unlock>
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
  4131c8:	f9401a61 	ldr	x1, [x19, #48]
  4131cc:	aa1303e0 	mov	x0, x19
  4131d0:	d63f0020 	blr	x1
	return posix_irq_lock();
  4131d4:	97ffdb75 	bl	409fa8 <posix_irq_lock>
  4131d8:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4131dc:	aa1503e0 	mov	x0, x21
  4131e0:	97ffed19 	bl	40e644 <z_spin_lock_valid>
  4131e4:	72001c1f 	tst	w0, #0xff
  4131e8:	54fff500 	b.eq	413088 <z_timer_expiration_handler+0x34>  // b.none
	z_spin_lock_set_owner(l);
  4131ec:	aa1503e0 	mov	x0, x21
  4131f0:	97ffed2d 	bl	40e6a4 <z_spin_lock_set_owner>
	return list->head == list;
  4131f4:	f8420e75 	ldr	x21, [x19, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4131f8:	eb1302bf 	cmp	x21, x19
  4131fc:	54000040 	b.eq	413204 <z_timer_expiration_handler+0x1b0>  // b.none
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
  413200:	b5000155 	cbnz	x21, 413228 <z_timer_expiration_handler+0x1d4>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413204:	9126a2c0 	add	x0, x22, #0x9a8
  413208:	17ffffba 	b	4130f0 <z_timer_expiration_handler+0x9c>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
  41320c:	92800022 	mov	x2, #0xfffffffffffffffe    	// #-2
  413210:	17ffffde 	b	413188 <z_timer_expiration_handler+0x134>
	posix_irq_unlock(key);
  413214:	2a1403e0 	mov	w0, w20
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
  413218:	a94153f3 	ldp	x19, x20, [sp, #16]
  41321c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413220:	a8c37bfd 	ldp	x29, x30, [sp], #48
  413224:	17ffdb63 	b	409fb0 <posix_irq_unlock>
	z_unpend_thread_no_timeout(thread);
  413228:	aa1503e0 	mov	x0, x21
  41322c:	97fff466 	bl	4103c4 <z_unpend_thread_no_timeout>
  413230:	b9004ebf 	str	wzr, [x21, #76]
  413234:	9126a2c0 	add	x0, x22, #0x9a8
  413238:	97ffed0e 	bl	40e670 <z_spin_unlock_valid>
  41323c:	72001c1f 	tst	w0, #0xff
  413240:	54fff5e0 	b.eq	4130fc <z_timer_expiration_handler+0xa8>  // b.none
  413244:	2a1403e0 	mov	w0, w20
  413248:	97ffdb5a 	bl	409fb0 <posix_irq_unlock>
	z_ready_thread(thread);
  41324c:	aa1503e0 	mov	x0, x21
}
  413250:	a94153f3 	ldp	x19, x20, [sp, #16]
  413254:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413258:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_ready_thread(thread);
  41325c:	17fff6fa 	b	410e44 <z_ready_thread>

0000000000413260 <k_timer_init>:
	node->prev = NULL;
  413260:	a9007c1f 	stp	xzr, xzr, [x0]
void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
	timer->stop_fn = stop_fn;
  413264:	a9030801 	stp	x1, x2, [x0, #48]
	sys_dlist_init(&w->waitq);
  413268:	91008001 	add	x1, x0, #0x20
	list->tail = (sys_dnode_t *)list;
  41326c:	a9020401 	stp	x1, x1, [x0, #32]
	timer->status = 0U;
  413270:	b900481f 	str	wzr, [x0, #72]

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
  413274:	f900281f 	str	xzr, [x0, #80]

	z_object_init(timer);
}
  413278:	d65f03c0 	ret

000000000041327c <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
  41327c:	b100043f 	cmn	x1, #0x1
  413280:	54000320 	b.eq	4132e4 <z_impl_k_timer_start+0x68>  // b.none
{
  413284:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  413288:	910003fd 	mov	x29, sp
  41328c:	a90153f3 	stp	x19, x20, [sp, #16]
  413290:	aa0003f4 	mov	x20, x0
  413294:	aa0103f3 	mov	x19, x1
  413298:	f90013f5 	str	x21, [sp, #32]
  41329c:	aa0203f5 	mov	x21, x2
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
  4132a0:	b100083f 	cmn	x1, #0x2
  4132a4:	5400008d 	b.le	4132b4 <z_impl_k_timer_start+0x38>
		duration.ticks = MAX(duration.ticks - 1, 0);
  4132a8:	f100003f 	cmp	x1, #0x0
  4132ac:	9a9fc433 	csinc	x19, x1, xzr, gt
  4132b0:	d1000673 	sub	x19, x19, #0x1
	}

	(void)z_abort_timeout(&timer->timeout);
  4132b4:	aa1403e0 	mov	x0, x20
  4132b8:	97fffe43 	bl	412bc4 <z_abort_timeout>
	timer->period = period;
  4132bc:	f9002295 	str	x21, [x20, #64]
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  4132c0:	aa1303e2 	mov	x2, x19
	timer->status = 0U;
  4132c4:	b9004a9f 	str	wzr, [x20, #72]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  4132c8:	aa1403e0 	mov	x0, x20
  4132cc:	900000c1 	adrp	x1, 42b000 <__FRAME_END__+0xff4c>
		     duration);
}
  4132d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4132d4:	f94013f5 	ldr	x21, [sp, #32]
  4132d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  4132dc:	f947d821 	ldr	x1, [x1, #4016]
  4132e0:	17fffda7 	b	41297c <z_add_timeout>
  4132e4:	d65f03c0 	ret

00000000004132e8 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
  4132e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4132ec:	910003fd 	mov	x29, sp
  4132f0:	f9000bf3 	str	x19, [sp, #16]
  4132f4:	aa0003f3 	mov	x19, x0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
  4132f8:	97fffe33 	bl	412bc4 <z_abort_timeout>

	if (inactive) {
  4132fc:	350001a0 	cbnz	w0, 413330 <z_impl_k_timer_stop+0x48>
		return;
	}

	if (timer->stop_fn != NULL) {
  413300:	f9401e61 	ldr	x1, [x19, #56]
  413304:	b4000061 	cbz	x1, 413310 <z_impl_k_timer_stop+0x28>
		timer->stop_fn(timer);
  413308:	aa1303e0 	mov	x0, x19
  41330c:	d63f0020 	blr	x1
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
  413310:	91008260 	add	x0, x19, #0x20
  413314:	97fff9d5 	bl	411a68 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
  413318:	b40000c0 	cbz	x0, 413330 <z_impl_k_timer_stop+0x48>
			z_ready_thread(pending_thread);
  41331c:	97fff6ca 	bl	410e44 <z_ready_thread>
	return posix_irq_lock();
  413320:	97ffdb22 	bl	409fa8 <posix_irq_lock>
			z_reschedule_unlocked();
		}
	}
}
  413324:	f9400bf3 	ldr	x19, [sp, #16]
  413328:	a8c27bfd 	ldp	x29, x30, [sp], #32
	(void) z_reschedule_irqlock(arch_irq_lock());
  41332c:	17fff4af 	b	4105e8 <z_reschedule_irqlock>
  413330:	f9400bf3 	ldr	x19, [sp, #16]
  413334:	a8c27bfd 	ldp	x29, x30, [sp], #32
  413338:	d65f03c0 	ret

000000000041333c <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
  41333c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  413340:	910003fd 	mov	x29, sp
  413344:	a90153f3 	stp	x19, x20, [sp, #16]
  413348:	aa0003f4 	mov	x20, x0
  41334c:	a9025bf5 	stp	x21, x22, [sp, #32]
  413350:	2a0103f5 	mov	w21, w1
  413354:	f9001bf7 	str	x23, [sp, #48]
	struct z_poller *poller = event->poller;
  413358:	f9400813 	ldr	x19, [x0, #16]
	int retcode = 0;

	if (poller != NULL) {
  41335c:	b4000113 	cbz	x19, 41337c <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
  413360:	39400660 	ldrb	w0, [x19, #1]
  413364:	7100041f 	cmp	w0, #0x1
  413368:	540004c1 	b.ne	413400 <signal_poll_event+0xc4>  // b.any
	if (!z_is_thread_pending(thread)) {
  41336c:	385a9260 	ldurb	w0, [x19, #-87]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
  413370:	d101c276 	sub	x22, x19, #0x70
  413374:	37080160 	tbnz	w0, #1, 4133a0 <signal_poll_event+0x64>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
  413378:	3900027f 	strb	wzr, [x19]
	event->state |= state;
  41337c:	f9400e80 	ldr	x0, [x20, #24]
	event->poller = NULL;
  413380:	f9000a9f 	str	xzr, [x20, #16]
	event->state |= state;
  413384:	d34e5000 	ubfx	x0, x0, #14, #7
  413388:	2a0002b5 	orr	w21, w21, w0
  41338c:	b9401a80 	ldr	w0, [x20, #24]
  413390:	33121aa0 	bfi	w0, w21, #14, #7
  413394:	b9001a80 	str	w0, [x20, #24]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
  413398:	52800000 	mov	w0, #0x0                   	// #0
  41339c:	14000006 	b	4133b4 <signal_poll_event+0x78>
	if (z_is_thread_timeout_expired(thread)) {
  4133a0:	f94022c0 	ldr	x0, [x22, #64]
  4133a4:	b100081f 	cmn	x0, #0x2
  4133a8:	54000101 	b.ne	4133c8 <signal_poll_event+0x8c>  // b.any
		return -EAGAIN;
  4133ac:	12800140 	mov	w0, #0xfffffff5            	// #-11
		poller->is_polling = false;
  4133b0:	3900027f 	strb	wzr, [x19]
}
  4133b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4133b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4133bc:	f9401bf7 	ldr	x23, [sp, #48]
  4133c0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4133c4:	d65f03c0 	ret
	z_unpend_thread(thread);
  4133c8:	aa1603e0 	mov	x0, x22
  4133cc:	97fff53a 	bl	4108b4 <z_unpend_thread>
	arch_thread_return_value_set(thread,
  4133d0:	710022bf 	cmp	w21, #0x8
  4133d4:	12800060 	mov	w0, #0xfffffffc            	// #-4
  4133d8:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  4133dc:	b9004ec0 	str	w0, [x22, #76]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  4133e0:	394066c0 	ldrb	w0, [x22, #25]
  4133e4:	f240101f 	tst	x0, #0x1f
  4133e8:	54fffc81 	b.ne	413378 <signal_poll_event+0x3c>  // b.any
	if (!z_is_thread_ready(thread)) {
  4133ec:	f85b8260 	ldur	x0, [x19, #-72]
  4133f0:	b5fffc40 	cbnz	x0, 413378 <signal_poll_event+0x3c>
	z_ready_thread(thread);
  4133f4:	aa1603e0 	mov	x0, x22
  4133f8:	97fff693 	bl	410e44 <z_ready_thread>
		poller->is_polling = false;
  4133fc:	17ffffdf 	b	413378 <signal_poll_event+0x3c>
		} else if (poller->mode == MODE_TRIGGERED) {
  413400:	7100081f 	cmp	w0, #0x2
  413404:	54fffba1 	b.ne	413378 <signal_poll_event+0x3c>  // b.any
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
  413408:	39400260 	ldrb	w0, [x19]
  41340c:	34fffb80 	cbz	w0, 41337c <signal_poll_event+0x40>
  413410:	f85f8277 	ldur	x23, [x19, #-8]
  413414:	d100a276 	sub	x22, x19, #0x28
  413418:	b4fffb17 	cbz	x23, 413378 <signal_poll_event+0x3c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
  41341c:	91008260 	add	x0, x19, #0x20
  413420:	97fffde9 	bl	412bc4 <z_abort_timeout>
		twork->poll_result = 0;
  413424:	b900427f 	str	wzr, [x19, #64]
		z_work_submit_to_queue(work_q, &twork->work);
  413428:	aa1603e1 	mov	x1, x22
  41342c:	aa1703e0 	mov	x0, x23
  413430:	97fff2c0 	bl	40ff30 <z_work_submit_to_queue>
		poller->is_polling = false;
  413434:	17ffffd1 	b	413378 <signal_poll_event+0x3c>

0000000000413438 <z_handle_obj_poll_events>:
{
  413438:	aa0003e2 	mov	x2, x0
	return list->head == list;
  41343c:	f9400000 	ldr	x0, [x0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
  413440:	eb00005f 	cmp	x2, x0
  413444:	540000c0 	b.eq	41345c <z_handle_obj_poll_events+0x24>  // b.none
	sys_dnode_t *const prev = node->prev;
  413448:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
  41344c:	f9000062 	str	x2, [x3]
	next->prev = prev;
  413450:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
  413454:	a9007c1f 	stp	xzr, xzr, [x0]
		(void) signal_poll_event(poll_event, state);
  413458:	17ffffb9 	b	41333c <signal_poll_event>
}
  41345c:	d65f03c0 	ret

0000000000413460 <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
  413460:	b4000080 	cbz	x0, 413470 <k_free+0x10>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
  413464:	d1002001 	sub	x1, x0, #0x8
  413468:	f85f8000 	ldur	x0, [x0, #-8]
  41346c:	17ffea2f 	b	40dd28 <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
  413470:	d65f03c0 	ret

0000000000413474 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
  413474:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  413478:	910003fd 	mov	x29, sp
  41347c:	a90153f3 	stp	x19, x20, [sp, #16]
  413480:	aa0103f4 	mov	x20, x1
  413484:	f90013f5 	str	x21, [sp, #32]
  413488:	aa0003f5 	mov	x21, x0
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
  41348c:	97ffeb61 	bl	40e210 <k_is_in_isr>
  413490:	72001c1f 	tst	w0, #0xff
  413494:	54000521 	b.ne	413538 <z_thread_aligned_alloc+0xc4>  // b.any
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
  413498:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  41349c:	f9472c00 	ldr	x0, [x0, #3672]
  4134a0:	f9400800 	ldr	x0, [x0, #16]
  4134a4:	f9405813 	ldr	x19, [x0, #176]
	}

	if (heap != NULL) {
  4134a8:	b40004b3 	cbz	x19, 41353c <z_thread_aligned_alloc+0xc8>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
  4134ac:	b1002282 	adds	x2, x20, #0x8
  4134b0:	54000442 	b.cs	413538 <z_thread_aligned_alloc+0xc4>  // b.hs, b.nlast
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
  4134b4:	b27d02a1 	orr	x1, x21, #0x8
  4134b8:	aa1303e0 	mov	x0, x19
  4134bc:	d2800003 	mov	x3, #0x0                   	// #0
  4134c0:	97ffe99a 	bl	40db28 <k_heap_aligned_alloc>
	if (mem == NULL) {
  4134c4:	b40003a0 	cbz	x0, 413538 <z_thread_aligned_alloc+0xc4>
	*heap_ref = heap;
  4134c8:	f9000013 	str	x19, [x0]
	mem = ++heap_ref;
  4134cc:	91002013 	add	x19, x0, #0x8
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
  4134d0:	b4000375 	cbz	x21, 41353c <z_thread_aligned_alloc+0xc8>
  4134d4:	d10006a0 	sub	x0, x21, #0x1
  4134d8:	ea00027f 	tst	x19, x0
  4134dc:	54000300 	b.eq	41353c <z_thread_aligned_alloc+0xc8>  // b.none
  4134e0:	f0000014 	adrp	x20, 416000 <__func__.0+0xb3f>
  4134e4:	9121aa94 	add	x20, x20, #0x86a
  4134e8:	528004a3 	mov	w3, #0x25                  	// #37
  4134ec:	aa1403e2 	mov	x2, x20
  4134f0:	f0000001 	adrp	x1, 416000 <__func__.0+0xb3f>
  4134f4:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  4134f8:	91223821 	add	x1, x1, #0x88e
  4134fc:	911e2800 	add	x0, x0, #0x78a
  413500:	97ffd1a4 	bl	407b90 <assert_print>
  413504:	aa1503e2 	mov	x2, x21
  413508:	aa1303e1 	mov	x1, x19
  41350c:	f0000000 	adrp	x0, 416000 <__func__.0+0xb3f>
  413510:	91230000 	add	x0, x0, #0x8c0
  413514:	97ffd19f 	bl	407b90 <assert_print>
  413518:	aa1403e0 	mov	x0, x20
  41351c:	528004a1 	mov	w1, #0x25                  	// #37
  413520:	97ffd1c6 	bl	407c38 <assert_post_action>
  413524:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x78d>
  413528:	aa1403e1 	mov	x1, x20
  41352c:	911f2000 	add	x0, x0, #0x7c8
  413530:	528004a2 	mov	w2, #0x25                  	// #37
  413534:	97ffdbb3 	bl	40a400 <posix_print_error_and_exit>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
  413538:	d2800013 	mov	x19, #0x0                   	// #0
	}

	return ret;
}
  41353c:	aa1303e0 	mov	x0, x19
  413540:	a94153f3 	ldp	x19, x20, [sp, #16]
  413544:	f94013f5 	ldr	x21, [sp, #32]
  413548:	a8c37bfd 	ldp	x29, x30, [sp], #48
  41354c:	d65f03c0 	ret

0000000000413550 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
  413550:	f0000000 	adrp	x0, 416000 <__func__.0+0xb3f>
  413554:	9123a000 	add	x0, x0, #0x8e8
  413558:	17ffcbd1 	b	40649c <printk>

000000000041355c <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
  41355c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  413560:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
	struct k_work_queue_config cfg = {
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
  413564:	d2808002 	mov	x2, #0x400                 	// #1024
{
  413568:	910003fd 	mov	x29, sp
  41356c:	f9476800 	ldr	x0, [x0, #3792]
	k_work_queue_start(&k_sys_work_q,
  413570:	910063e4 	add	x4, sp, #0x18
  413574:	12800003 	mov	w3, #0xffffffff            	// #-1
{
  413578:	f9400001 	ldr	x1, [x0]
  41357c:	f90017e1 	str	x1, [sp, #40]
  413580:	d2800001 	mov	x1, #0x0                   	// #0
	struct k_work_queue_config cfg = {
  413584:	f0000000 	adrp	x0, 416000 <__func__.0+0xb3f>
  413588:	9124ac00 	add	x0, x0, #0x92b
  41358c:	f9000fe0 	str	x0, [sp, #24]
	k_work_queue_start(&k_sys_work_q,
  413590:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  413594:	f00000e1 	adrp	x1, 432000 <ztest_thread_stack+0x190>
  413598:	9135c021 	add	x1, x1, #0xd70
	struct k_work_queue_config cfg = {
  41359c:	390083ff 	strb	wzr, [sp, #32]
	k_work_queue_start(&k_sys_work_q,
  4135a0:	f947f400 	ldr	x0, [x0, #4072]
  4135a4:	97fff2ca 	bl	4100cc <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
  4135a8:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0xff4c>
  4135ac:	f9476800 	ldr	x0, [x0, #3792]
  4135b0:	f94017e2 	ldr	x2, [sp, #40]
  4135b4:	f9400001 	ldr	x1, [x0]
  4135b8:	eb010042 	subs	x2, x2, x1
  4135bc:	d2800001 	mov	x1, #0x0                   	// #0
  4135c0:	54000040 	b.eq	4135c8 <k_sys_work_q_init+0x6c>  // b.none
  4135c4:	97ffb757 	bl	401320 <__stack_chk_fail@plt>
  4135c8:	52800000 	mov	w0, #0x0                   	// #0
  4135cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4135d0:	d65f03c0 	ret

Disassembly of section .fini:

00000000004135d4 <_fini>:
  4135d4:	d503201f 	nop
  4135d8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4135dc:	910003fd 	mov	x29, sp
  4135e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4135e4:	d65f03c0 	ret
