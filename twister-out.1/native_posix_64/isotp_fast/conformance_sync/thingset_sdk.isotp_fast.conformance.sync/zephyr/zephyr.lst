
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section .init:

0000000000401138 <_init>:
  401138:	d503201f 	nop
  40113c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  401140:	910003fd 	mov	x29, sp
  401144:	940003db 	bl	4020b0 <call_weak_fn>
  401148:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40114c:	d65f03c0 	ret

Disassembly of section .plt:

0000000000401150 <.plt>:
  401150:	a9bf7bf0 	stp	x16, x30, [sp, #-16]!
  401154:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401158:	f9461611 	ldr	x17, [x16, #3112]
  40115c:	9130a210 	add	x16, x16, #0xc28
  401160:	d61f0220 	br	x17
  401164:	d503201f 	nop
  401168:	d503201f 	nop
  40116c:	d503201f 	nop

0000000000401170 <memcpy@plt>:
  401170:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401174:	f9461a11 	ldr	x17, [x16, #3120]
  401178:	9130c210 	add	x16, x16, #0xc30
  40117c:	d61f0220 	br	x17

0000000000401180 <getcwd@plt>:
  401180:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401184:	f9461e11 	ldr	x17, [x16, #3128]
  401188:	9130e210 	add	x16, x16, #0xc38
  40118c:	d61f0220 	br	x17

0000000000401190 <strtoul@plt>:
  401190:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401194:	f9462211 	ldr	x17, [x16, #3136]
  401198:	91310210 	add	x16, x16, #0xc40
  40119c:	d61f0220 	br	x17

00000000004011a0 <strlen@plt>:
  4011a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4011a4:	f9462611 	ldr	x17, [x16, #3144]
  4011a8:	91312210 	add	x16, x16, #0xc48
  4011ac:	d61f0220 	br	x17

00000000004011b0 <exit@plt>:
  4011b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4011b4:	f9462a11 	ldr	x17, [x16, #3152]
  4011b8:	91314210 	add	x16, x16, #0xc50
  4011bc:	d61f0220 	br	x17

00000000004011c0 <__libc_start_main@plt>:
  4011c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4011c4:	f9462e11 	ldr	x17, [x16, #3160]
  4011c8:	91316210 	add	x16, x16, #0xc58
  4011cc:	d61f0220 	br	x17

00000000004011d0 <strtoll@plt>:
  4011d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4011d4:	f9463211 	ldr	x17, [x16, #3168]
  4011d8:	91318210 	add	x16, x16, #0xc60
  4011dc:	d61f0220 	br	x17

00000000004011e0 <strnlen@plt>:
  4011e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4011e4:	f9463611 	ldr	x17, [x16, #3176]
  4011e8:	9131a210 	add	x16, x16, #0xc68
  4011ec:	d61f0220 	br	x17

00000000004011f0 <strtod@plt>:
  4011f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4011f4:	f9463a11 	ldr	x17, [x16, #3184]
  4011f8:	9131c210 	add	x16, x16, #0xc70
  4011fc:	d61f0220 	br	x17

0000000000401200 <__sigsetjmp@plt>:
  401200:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401204:	f9463e11 	ldr	x17, [x16, #3192]
  401208:	9131e210 	add	x16, x16, #0xc78
  40120c:	d61f0220 	br	x17

0000000000401210 <__cxa_finalize@plt>:
  401210:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401214:	f9464211 	ldr	x17, [x16, #3200]
  401218:	91320210 	add	x16, x16, #0xc80
  40121c:	d61f0220 	br	x17

0000000000401220 <clock_gettime@plt>:
  401220:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401224:	f9464611 	ldr	x17, [x16, #3208]
  401228:	91322210 	add	x16, x16, #0xc88
  40122c:	d61f0220 	br	x17

0000000000401230 <setvbuf@plt>:
  401230:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401234:	f9464a11 	ldr	x17, [x16, #3216]
  401238:	91324210 	add	x16, x16, #0xc90
  40123c:	d61f0220 	br	x17

0000000000401240 <snprintf@plt>:
  401240:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401244:	f9464e11 	ldr	x17, [x16, #3224]
  401248:	91326210 	add	x16, x16, #0xc98
  40124c:	d61f0220 	br	x17

0000000000401250 <__memcpy_chk@plt>:
  401250:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401254:	f9465211 	ldr	x17, [x16, #3232]
  401258:	91328210 	add	x16, x16, #0xca0
  40125c:	d61f0220 	br	x17

0000000000401260 <__snprintf_chk@plt>:
  401260:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401264:	f9465611 	ldr	x17, [x16, #3240]
  401268:	9132a210 	add	x16, x16, #0xca8
  40126c:	d61f0220 	br	x17

0000000000401270 <strtok_r@plt>:
  401270:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401274:	f9465a11 	ldr	x17, [x16, #3248]
  401278:	9132c210 	add	x16, x16, #0xcb0
  40127c:	d61f0220 	br	x17

0000000000401280 <sigemptyset@plt>:
  401280:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401284:	f9465e11 	ldr	x17, [x16, #3256]
  401288:	9132e210 	add	x16, x16, #0xcb8
  40128c:	d61f0220 	br	x17

0000000000401290 <strncmp@plt>:
  401290:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401294:	f9466211 	ldr	x17, [x16, #3264]
  401298:	91330210 	add	x16, x16, #0xcc0
  40129c:	d61f0220 	br	x17

00000000004012a0 <memset@plt>:
  4012a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4012a4:	f9466611 	ldr	x17, [x16, #3272]
  4012a8:	91332210 	add	x16, x16, #0xcc8
  4012ac:	d61f0220 	br	x17

00000000004012b0 <sleep@plt>:
  4012b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4012b4:	f9466a11 	ldr	x17, [x16, #3280]
  4012b8:	91334210 	add	x16, x16, #0xcd0
  4012bc:	d61f0220 	br	x17

00000000004012c0 <__vfprintf_chk@plt>:
  4012c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4012c4:	f9466e11 	ldr	x17, [x16, #3288]
  4012c8:	91336210 	add	x16, x16, #0xcd8
  4012cc:	d61f0220 	br	x17

00000000004012d0 <calloc@plt>:
  4012d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4012d4:	f9467211 	ldr	x17, [x16, #3296]
  4012d8:	91338210 	add	x16, x16, #0xce0
  4012dc:	d61f0220 	br	x17

00000000004012e0 <pthread_cond_broadcast@plt>:
  4012e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4012e4:	f9467611 	ldr	x17, [x16, #3304]
  4012e8:	9133a210 	add	x16, x16, #0xce8
  4012ec:	d61f0220 	br	x17

00000000004012f0 <strcasecmp@plt>:
  4012f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4012f4:	f9467a11 	ldr	x17, [x16, #3312]
  4012f8:	9133c210 	add	x16, x16, #0xcf0
  4012fc:	d61f0220 	br	x17

0000000000401300 <realloc@plt>:
  401300:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401304:	f9467e11 	ldr	x17, [x16, #3320]
  401308:	9133e210 	add	x16, x16, #0xcf8
  40130c:	d61f0220 	br	x17

0000000000401310 <strdup@plt>:
  401310:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401314:	f9468211 	ldr	x17, [x16, #3328]
  401318:	91340210 	add	x16, x16, #0xd00
  40131c:	d61f0220 	br	x17

0000000000401320 <__stack_chk_fail@plt>:
  401320:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401324:	f9468611 	ldr	x17, [x16, #3336]
  401328:	91342210 	add	x16, x16, #0xd08
  40132c:	d61f0220 	br	x17

0000000000401330 <sigaction@plt>:
  401330:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401334:	f9468a11 	ldr	x17, [x16, #3344]
  401338:	91344210 	add	x16, x16, #0xd10
  40133c:	d61f0220 	br	x17

0000000000401340 <__gmon_start__@plt>:
  401340:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401344:	f9468e11 	ldr	x17, [x16, #3352]
  401348:	91346210 	add	x16, x16, #0xd18
  40134c:	d61f0220 	br	x17

0000000000401350 <__getauxval@plt>:
  401350:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401354:	f9469211 	ldr	x17, [x16, #3360]
  401358:	91348210 	add	x16, x16, #0xd20
  40135c:	d61f0220 	br	x17

0000000000401360 <abort@plt>:
  401360:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401364:	f9469611 	ldr	x17, [x16, #3368]
  401368:	9134a210 	add	x16, x16, #0xd28
  40136c:	d61f0220 	br	x17

0000000000401370 <pthread_exit@plt>:
  401370:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401374:	f9469a11 	ldr	x17, [x16, #3376]
  401378:	9134c210 	add	x16, x16, #0xd30
  40137c:	d61f0220 	br	x17

0000000000401380 <memcmp@plt>:
  401380:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401384:	f9469e11 	ldr	x17, [x16, #3384]
  401388:	9134e210 	add	x16, x16, #0xd38
  40138c:	d61f0220 	br	x17

0000000000401390 <__fprintf_chk@plt>:
  401390:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401394:	f946a211 	ldr	x17, [x16, #3392]
  401398:	91350210 	add	x16, x16, #0xd40
  40139c:	d61f0220 	br	x17

00000000004013a0 <strcmp@plt>:
  4013a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4013a4:	f946a611 	ldr	x17, [x16, #3400]
  4013a8:	91352210 	add	x16, x16, #0xd48
  4013ac:	d61f0220 	br	x17

00000000004013b0 <__ctype_b_loc@plt>:
  4013b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4013b4:	f946aa11 	ldr	x17, [x16, #3408]
  4013b8:	91354210 	add	x16, x16, #0xd50
  4013bc:	d61f0220 	br	x17

00000000004013c0 <pthread_detach@plt>:
  4013c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4013c4:	f946ae11 	ldr	x17, [x16, #3416]
  4013c8:	91356210 	add	x16, x16, #0xd58
  4013cc:	d61f0220 	br	x17

00000000004013d0 <strtol@plt>:
  4013d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4013d4:	f946b211 	ldr	x17, [x16, #3424]
  4013d8:	91358210 	add	x16, x16, #0xd60
  4013dc:	d61f0220 	br	x17

00000000004013e0 <free@plt>:
  4013e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4013e4:	f946b611 	ldr	x17, [x16, #3432]
  4013e8:	9135a210 	add	x16, x16, #0xd68
  4013ec:	d61f0220 	br	x17

00000000004013f0 <pthread_cond_wait@plt>:
  4013f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4013f4:	f946ba11 	ldr	x17, [x16, #3440]
  4013f8:	9135c210 	add	x16, x16, #0xd70
  4013fc:	d61f0220 	br	x17

0000000000401400 <nanosleep@plt>:
  401400:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401404:	f946be11 	ldr	x17, [x16, #3448]
  401408:	9135e210 	add	x16, x16, #0xd78
  40140c:	d61f0220 	br	x17

0000000000401410 <__pthread_unwind_next@plt>:
  401410:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401414:	f946c211 	ldr	x17, [x16, #3456]
  401418:	91360210 	add	x16, x16, #0xd80
  40141c:	d61f0220 	br	x17

0000000000401420 <strtoull@plt>:
  401420:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401424:	f946c611 	ldr	x17, [x16, #3464]
  401428:	91362210 	add	x16, x16, #0xd88
  40142c:	d61f0220 	br	x17

0000000000401430 <pthread_create@plt>:
  401430:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401434:	f946ca11 	ldr	x17, [x16, #3472]
  401438:	91364210 	add	x16, x16, #0xd90
  40143c:	d61f0220 	br	x17

0000000000401440 <isatty@plt>:
  401440:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401444:	f946ce11 	ldr	x17, [x16, #3480]
  401448:	91366210 	add	x16, x16, #0xd98
  40144c:	d61f0220 	br	x17

0000000000401450 <strncpy@plt>:
  401450:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401454:	f946d211 	ldr	x17, [x16, #3488]
  401458:	91368210 	add	x16, x16, #0xda0
  40145c:	d61f0220 	br	x17

0000000000401460 <__pthread_register_cancel@plt>:
  401460:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401464:	f946d611 	ldr	x17, [x16, #3496]
  401468:	9136a210 	add	x16, x16, #0xda8
  40146c:	d61f0220 	br	x17

0000000000401470 <pthread_self@plt>:
  401470:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401474:	f946da11 	ldr	x17, [x16, #3504]
  401478:	9136c210 	add	x16, x16, #0xdb0
  40147c:	d61f0220 	br	x17

0000000000401480 <pthread_cancel@plt>:
  401480:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401484:	f946de11 	ldr	x17, [x16, #3512]
  401488:	9136e210 	add	x16, x16, #0xdb8
  40148c:	d61f0220 	br	x17

0000000000401490 <pthread_mutex_lock@plt>:
  401490:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  401494:	f946e211 	ldr	x17, [x16, #3520]
  401498:	91370210 	add	x16, x16, #0xdc0
  40149c:	d61f0220 	br	x17

00000000004014a0 <pthread_mutex_unlock@plt>:
  4014a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0xfd74>
  4014a4:	f946e611 	ldr	x17, [x16, #3528]
  4014a8:	91372210 	add	x16, x16, #0xdc8
  4014ac:	d61f0220 	br	x17

Disassembly of section .text:

00000000004014c0 <init_have_lse_atomics>:
  4014c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4014c4:	d2800200 	mov	x0, #0x10                  	// #16
  4014c8:	910003fd 	mov	x29, sp
  4014cc:	97ffffa1 	bl	401350 <__getauxval@plt>
  4014d0:	53082000 	ubfx	w0, w0, #8, #1
  4014d4:	b0000161 	adrp	x1, 42e000 <stdout_buff+0x2>
  4014d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4014dc:	39040020 	strb	w0, [x1, #256]
  4014e0:	d65f03c0 	ret
  4014e4:	d503201f 	nop
  4014e8:	d503201f 	nop
  4014ec:	d503201f 	nop
  4014f0:	d503201f 	nop
  4014f4:	d503201f 	nop
  4014f8:	d503201f 	nop
  4014fc:	d503201f 	nop

0000000000401500 <_start>:
  401500:	d503201f 	nop
  401504:	d280001d 	mov	x29, #0x0                   	// #0
  401508:	d280001e 	mov	x30, #0x0                   	// #0
  40150c:	aa0003e5 	mov	x5, x0
  401510:	f94003e1 	ldr	x1, [sp]
  401514:	910023e2 	add	x2, sp, #0x8
  401518:	910003e6 	mov	x6, sp
  40151c:	d0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  401520:	f947a000 	ldr	x0, [x0, #3904]
  401524:	d2800003 	mov	x3, #0x0                   	// #0
  401528:	d2800004 	mov	x4, #0x0                   	// #0
  40152c:	97ffff25 	bl	4011c0 <__libc_start_main@plt>
  401530:	97ffff8c 	bl	401360 <abort@plt>
  401534:	d503201f 	nop
  401538:	d503201f 	nop
  40153c:	d503201f 	nop

0000000000401540 <deregister_tm_clones>:
  401540:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  401544:	91106000 	add	x0, x0, #0x418
  401548:	f0000141 	adrp	x1, 42c000 <__dso_handle>
  40154c:	91106021 	add	x1, x1, #0x418
  401550:	eb00003f 	cmp	x1, x0
  401554:	540000c0 	b.eq	40156c <deregister_tm_clones+0x2c>  // b.none
  401558:	d0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40155c:	f946f021 	ldr	x1, [x1, #3552]
  401560:	b4000061 	cbz	x1, 40156c <deregister_tm_clones+0x2c>
  401564:	aa0103f0 	mov	x16, x1
  401568:	d61f0200 	br	x16
  40156c:	d65f03c0 	ret

0000000000401570 <register_tm_clones>:
  401570:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  401574:	91106000 	add	x0, x0, #0x418
  401578:	f0000141 	adrp	x1, 42c000 <__dso_handle>
  40157c:	91106021 	add	x1, x1, #0x418
  401580:	cb000021 	sub	x1, x1, x0
  401584:	d37ffc22 	lsr	x2, x1, #63
  401588:	8b810c41 	add	x1, x2, x1, asr #3
  40158c:	9341fc21 	asr	x1, x1, #1
  401590:	b40000c1 	cbz	x1, 4015a8 <register_tm_clones+0x38>
  401594:	d0000142 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
  401598:	f947dc42 	ldr	x2, [x2, #4024]
  40159c:	b4000062 	cbz	x2, 4015a8 <register_tm_clones+0x38>
  4015a0:	aa0203f0 	mov	x16, x2
  4015a4:	d61f0200 	br	x16
  4015a8:	d65f03c0 	ret
  4015ac:	d503201f 	nop

00000000004015b0 <__do_global_dtors_aux>:
  4015b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4015b4:	910003fd 	mov	x29, sp
  4015b8:	f9000bf3 	str	x19, [sp, #16]
  4015bc:	90000173 	adrp	x19, 42d000 <counter_period>
  4015c0:	396ff260 	ldrb	w0, [x19, #3068]
  4015c4:	35000140 	cbnz	w0, 4015ec <__do_global_dtors_aux+0x3c>
  4015c8:	d0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4015cc:	f9470c00 	ldr	x0, [x0, #3608]
  4015d0:	b4000080 	cbz	x0, 4015e0 <__do_global_dtors_aux+0x30>
  4015d4:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  4015d8:	f9400000 	ldr	x0, [x0]
  4015dc:	97ffff0d 	bl	401210 <__cxa_finalize@plt>
  4015e0:	97ffffd8 	bl	401540 <deregister_tm_clones>
  4015e4:	52800020 	mov	w0, #0x1                   	// #1
  4015e8:	392ff260 	strb	w0, [x19, #3068]
  4015ec:	f9400bf3 	ldr	x19, [sp, #16]
  4015f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4015f4:	d65f03c0 	ret
  4015f8:	d503201f 	nop
  4015fc:	d503201f 	nop

0000000000401600 <frame_dummy>:
  401600:	17ffffdc 	b	401570 <register_tm_clones>
  401604:	d503201f 	nop
  401608:	d503201f 	nop
  40160c:	d503201f 	nop

0000000000401610 <__aarch64_ldadd8_acq_rel>:
  401610:	d503245f 	bti	c
  401614:	b0000170 	adrp	x16, 42e000 <stdout_buff+0x2>
  401618:	39440210 	ldrb	w16, [x16, #256]
  40161c:	34000070 	cbz	w16, 401628 <__aarch64_ldadd8_acq_rel+0x18>
  401620:	f8e00020 	ldaddal	x0, x0, [x1]
  401624:	d65f03c0 	ret
  401628:	aa0003f0 	mov	x16, x0
  40162c:	c85ffc20 	ldaxr	x0, [x1]
  401630:	8b100011 	add	x17, x0, x16
  401634:	c80ffc31 	stlxr	w15, x17, [x1]
  401638:	35ffffaf 	cbnz	w15, 40162c <__aarch64_ldadd8_acq_rel+0x1c>
  40163c:	d65f03c0 	ret

0000000000401640 <__divtf3>:
  401640:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  401644:	910003fd 	mov	x29, sp
  401648:	3d8007e0 	str	q0, [sp, #16]
  40164c:	3d800be1 	str	q1, [sp, #32]
  401650:	a94103e1 	ldp	x1, x0, [sp, #16]
  401654:	a9420fe6 	ldp	x6, x3, [sp, #32]
  401658:	d53b440c 	mrs	x12, fpcr
  40165c:	d37ffc04 	lsr	x4, x0, #63
  401660:	d340bc02 	ubfx	x2, x0, #0, #48
  401664:	12001c8d 	and	w13, w4, #0xff
  401668:	aa0403ea 	mov	x10, x4
  40166c:	d370f808 	ubfx	x8, x0, #48, #15
  401670:	34001ee8 	cbz	w8, 401a4c <__divtf3+0x40c>
  401674:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401678:	6b04011f 	cmp	w8, w4
  40167c:	540020c0 	b.eq	401a94 <__divtf3+0x454>  // b.none
  401680:	92403d08 	and	x8, x8, #0xffff
  401684:	93c1f442 	extr	x2, x2, x1, #61
  401688:	9287ffce 	mov	x14, #0xffffffffffffc001    	// #-16383
  40168c:	d37df021 	lsl	x1, x1, #3
  401690:	8b0e0108 	add	x8, x8, x14
  401694:	b24d0045 	orr	x5, x2, #0x8000000000000
  401698:	d2800010 	mov	x16, #0x0                   	// #0
  40169c:	d2800002 	mov	x2, #0x0                   	// #0
  4016a0:	52800000 	mov	w0, #0x0                   	// #0
  4016a4:	d37ffc64 	lsr	x4, x3, #63
  4016a8:	d340bc67 	ubfx	x7, x3, #0, #48
  4016ac:	12001c8f 	and	w15, w4, #0xff
  4016b0:	aa0403e9 	mov	x9, x4
  4016b4:	d370f864 	ubfx	x4, x3, #48, #15
  4016b8:	34001a04 	cbz	w4, 4019f8 <__divtf3+0x3b8>
  4016bc:	528fffeb 	mov	w11, #0x7fff                	// #32767
  4016c0:	6b0b009f 	cmp	w4, w11
  4016c4:	54001f80 	b.eq	401ab4 <__divtf3+0x474>  // b.none
  4016c8:	9287ffcb 	mov	x11, #0xffffffffffffc001    	// #-16383
  4016cc:	92403c84 	and	x4, x4, #0xffff
  4016d0:	8b0b0084 	add	x4, x4, x11
  4016d4:	93c6f4e7 	extr	x7, x7, x6, #61
  4016d8:	4a0f01ab 	eor	w11, w13, w15
  4016dc:	b24d00e7 	orr	x7, x7, #0x8000000000000
  4016e0:	cb040108 	sub	x8, x8, x4
  4016e4:	d37df0c6 	lsl	x6, x6, #3
  4016e8:	92401d6e 	and	x14, x11, #0xff
  4016ec:	d2800003 	mov	x3, #0x0                   	// #0
  4016f0:	f100245f 	cmp	x2, #0x9
  4016f4:	5400046c 	b.gt	401780 <__divtf3+0x140>
  4016f8:	f1001c5f 	cmp	x2, #0x7
  4016fc:	54002bcc 	b.gt	401c74 <__divtf3+0x634>
  401700:	f1000c5f 	cmp	x2, #0x3
  401704:	540000e0 	b.eq	401720 <__divtf3+0xe0>  // b.none
  401708:	5400050d 	b.le	4017a8 <__divtf3+0x168>
  40170c:	f100145f 	cmp	x2, #0x5
  401710:	54000400 	b.eq	401790 <__divtf3+0x150>  // b.none
  401714:	5400080d 	b.le	401814 <__divtf3+0x1d4>
  401718:	f100185f 	cmp	x2, #0x6
  40171c:	54000640 	b.eq	4017e4 <__divtf3+0x1a4>  // b.none
  401720:	f100047f 	cmp	x3, #0x1
  401724:	54002780 	b.eq	401c14 <__divtf3+0x5d4>  // b.none
  401728:	b40000a3 	cbz	x3, 40173c <__divtf3+0xfc>
  40172c:	f100087f 	cmp	x3, #0x2
  401730:	54003260 	b.eq	401d7c <__divtf3+0x73c>  // b.none
  401734:	f1000c7f 	cmp	x3, #0x3
  401738:	54003160 	b.eq	401d64 <__divtf3+0x724>  // b.none
  40173c:	d287ffe1 	mov	x1, #0x3fff                	// #16383
  401740:	8b010104 	add	x4, x8, x1
  401744:	f100009f 	cmp	x4, #0x0
  401748:	5400222d 	b.le	401b8c <__divtf3+0x54c>
  40174c:	f24008df 	tst	x6, #0x7
  401750:	540026c1 	b.ne	401c28 <__divtf3+0x5e8>  // b.any
  401754:	1200012b 	and	w11, w9, #0x1
  401758:	b6a00067 	tbz	x7, #52, 401764 <__divtf3+0x124>
  40175c:	924bf8e7 	and	x7, x7, #0xffefffffffffffff
  401760:	91401104 	add	x4, x8, #0x4, lsl #12
  401764:	d28fffc2 	mov	x2, #0x7ffe                	// #32766
  401768:	eb02009f 	cmp	x4, x2
  40176c:	54002cec 	b.gt	401d08 <__divtf3+0x6c8>
  401770:	d343c8e5 	ubfx	x5, x7, #3, #48
  401774:	93c60ce1 	extr	x1, x7, x6, #3
  401778:	12003884 	and	w4, w4, #0x7fff
  40177c:	1400001d 	b	4017f0 <__divtf3+0x1b0>
  401780:	f1002c5f 	cmp	x2, #0xb
  401784:	54001c4c 	b.gt	401b0c <__divtf3+0x4cc>
  401788:	f100285f 	cmp	x2, #0xa
  40178c:	54fffca1 	b.ne	401720 <__divtf3+0xe0>  // b.any
  401790:	5280000b 	mov	w11, #0x0                   	// #0
  401794:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401798:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40179c:	52800020 	mov	w0, #0x1                   	// #1
  4017a0:	528fffe4 	mov	w4, #0x7fff                	// #32767
  4017a4:	14000013 	b	4017f0 <__divtf3+0x1b0>
  4017a8:	f100045f 	cmp	x2, #0x1
  4017ac:	54000181 	b.ne	4017dc <__divtf3+0x19c>  // b.any
  4017b0:	d2800002 	mov	x2, #0x0                   	// #0
  4017b4:	9e670040 	fmov	d0, x2
  4017b8:	d34101ce 	lsl	x14, x14, #63
  4017bc:	321f0000 	orr	w0, w0, #0x2
  4017c0:	b25039c3 	orr	x3, x14, #0x7fff000000000000
  4017c4:	9eaf0060 	fmov	v0.d[1], x3
  4017c8:	3d8007e0 	str	q0, [sp, #16]
  4017cc:	9400021d 	bl	402040 <__sfp_handle_exceptions>
  4017d0:	3dc007e0 	ldr	q0, [sp, #16]
  4017d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4017d8:	d65f03c0 	ret
  4017dc:	f100085f 	cmp	x2, #0x2
  4017e0:	540001e1 	b.ne	40181c <__divtf3+0x1dc>  // b.any
  4017e4:	52800004 	mov	w4, #0x0                   	// #0
  4017e8:	d2800005 	mov	x5, #0x0                   	// #0
  4017ec:	d2800001 	mov	x1, #0x0                   	// #0
  4017f0:	d2800003 	mov	x3, #0x0                   	// #0
  4017f4:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  4017f8:	b340bca3 	bfxil	x3, x5, #0, #48
  4017fc:	9e670020 	fmov	d0, x1
  401800:	b3503c83 	bfi	x3, x4, #48, #16
  401804:	9eaf0060 	fmov	v0.d[1], x3
  401808:	35fffe00 	cbnz	w0, 4017c8 <__divtf3+0x188>
  40180c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  401810:	d65f03c0 	ret
  401814:	f100105f 	cmp	x2, #0x4
  401818:	54fffe60 	b.eq	4017e4 <__divtf3+0x1a4>  // b.none
  40181c:	eb0700bf 	cmp	x5, x7
  401820:	54000068 	b.hi	40182c <__divtf3+0x1ec>  // b.pmore
  401824:	fa4100c2 	ccmp	x6, x1, #0x2, eq  // eq = none
  401828:	54002da8 	b.hi	401ddc <__divtf3+0x79c>  // b.pmore
  40182c:	d341fca3 	lsr	x3, x5, #1
  401830:	93c104a2 	extr	x2, x5, x1, #1
  401834:	d3410021 	lsl	x1, x1, #63
  401838:	d354cce9 	ubfx	x9, x7, #20, #32
  40183c:	93c6d0e4 	extr	x4, x7, x6, #52
  401840:	92407c8a 	and	x10, x4, #0xffffffff
  401844:	d374ccc5 	lsl	x5, x6, #12
  401848:	9ac90867 	udiv	x7, x3, x9
  40184c:	9b098ce3 	msub	x3, x7, x9, x3
  401850:	9b077d46 	mul	x6, x10, x7
  401854:	93c28063 	extr	x3, x3, x2, #32
  401858:	eb0300df 	cmp	x6, x3
  40185c:	540000c9 	b.ls	401874 <__divtf3+0x234>  // b.plast
  401860:	ab030083 	adds	x3, x4, x3
  401864:	d10004ed 	sub	x13, x7, #0x1
  401868:	fa4330c0 	ccmp	x6, x3, #0x0, cc  // cc = lo, ul, last
  40186c:	54003088 	b.hi	401e7c <__divtf3+0x83c>  // b.pmore
  401870:	aa0d03e7 	mov	x7, x13
  401874:	cb060063 	sub	x3, x3, x6
  401878:	9ac90866 	udiv	x6, x3, x9
  40187c:	9b098cc3 	msub	x3, x6, x9, x3
  401880:	9b067d50 	mul	x16, x10, x6
  401884:	b3607c62 	bfi	x2, x3, #32, #32
  401888:	eb02021f 	cmp	x16, x2
  40188c:	540000c9 	b.ls	4018a4 <__divtf3+0x264>  // b.plast
  401890:	ab020082 	adds	x2, x4, x2
  401894:	d10004c3 	sub	x3, x6, #0x1
  401898:	fa423200 	ccmp	x16, x2, #0x0, cc  // cc = lo, ul, last
  40189c:	54002ea8 	b.hi	401e70 <__divtf3+0x830>  // b.pmore
  4018a0:	aa0303e6 	mov	x6, x3
  4018a4:	aa0780d1 	orr	x17, x6, x7, lsl #32
  4018a8:	92407caf 	and	x15, x5, #0xffffffff
  4018ac:	92407e27 	and	x7, x17, #0xffffffff
  4018b0:	d360fcad 	lsr	x13, x5, #32
  4018b4:	d360fe26 	lsr	x6, x17, #32
  4018b8:	cb100042 	sub	x2, x2, x16
  4018bc:	d2c00032 	mov	x18, #0x100000000           	// #4294967296
  4018c0:	9b0f7ce3 	mul	x3, x7, x15
  4018c4:	9b0f7cde 	mul	x30, x6, x15
  4018c8:	9b0779a7 	madd	x7, x13, x7, x30
  4018cc:	92407c70 	and	x16, x3, #0xffffffff
  4018d0:	9b0d7cc6 	mul	x6, x6, x13
  4018d4:	8b4380e3 	add	x3, x7, x3, lsr #32
  4018d8:	8b1200c7 	add	x7, x6, x18
  4018dc:	eb0303df 	cmp	x30, x3
  4018e0:	9a8680e6 	csel	x6, x7, x6, hi  // hi = pmore
  4018e4:	8b038210 	add	x16, x16, x3, lsl #32
  4018e8:	8b4380c3 	add	x3, x6, x3, lsr #32
  4018ec:	eb03005f 	cmp	x2, x3
  4018f0:	54001ca3 	b.cc	401c84 <__divtf3+0x644>  // b.lo, b.ul, b.last
  4018f4:	fa500022 	ccmp	x1, x16, #0x2, eq  // eq = none
  4018f8:	aa1103e7 	mov	x7, x17
  4018fc:	54001c43 	b.cc	401c84 <__divtf3+0x644>  // b.lo, b.ul, b.last
  401900:	eb100021 	subs	x1, x1, x16
  401904:	da030042 	sbc	x2, x2, x3
  401908:	eb02009f 	cmp	x4, x2
  40190c:	54002be0 	b.eq	401e88 <__divtf3+0x848>  // b.none
  401910:	9ac90846 	udiv	x6, x2, x9
  401914:	9b0988c2 	msub	x2, x6, x9, x2
  401918:	9b067d43 	mul	x3, x10, x6
  40191c:	93c18042 	extr	x2, x2, x1, #32
  401920:	eb02007f 	cmp	x3, x2
  401924:	540000c9 	b.ls	40193c <__divtf3+0x2fc>  // b.plast
  401928:	ab020082 	adds	x2, x4, x2
  40192c:	d10004cb 	sub	x11, x6, #0x1
  401930:	fa423060 	ccmp	x3, x2, #0x0, cc  // cc = lo, ul, last
  401934:	540030e8 	b.hi	401f50 <__divtf3+0x910>  // b.pmore
  401938:	aa0b03e6 	mov	x6, x11
  40193c:	cb030042 	sub	x2, x2, x3
  401940:	9ac90843 	udiv	x3, x2, x9
  401944:	9b098869 	msub	x9, x3, x9, x2
  401948:	9b037d4a 	mul	x10, x10, x3
  40194c:	b3607d21 	bfi	x1, x9, #32, #32
  401950:	eb01015f 	cmp	x10, x1
  401954:	540000c9 	b.ls	40196c <__divtf3+0x32c>  // b.plast
  401958:	ab010081 	adds	x1, x4, x1
  40195c:	d1000462 	sub	x2, x3, #0x1
  401960:	fa413140 	ccmp	x10, x1, #0x0, cc  // cc = lo, ul, last
  401964:	54002f08 	b.hi	401f44 <__divtf3+0x904>  // b.pmore
  401968:	aa0203e3 	mov	x3, x2
  40196c:	aa068066 	orr	x6, x3, x6, lsl #32
  401970:	cb0a0021 	sub	x1, x1, x10
  401974:	92407cc3 	and	x3, x6, #0xffffffff
  401978:	d2c0002b 	mov	x11, #0x100000000           	// #4294967296
  40197c:	d360fcca 	lsr	x10, x6, #32
  401980:	9b037de2 	mul	x2, x15, x3
  401984:	9b0f7d4f 	mul	x15, x10, x15
  401988:	9b033da3 	madd	x3, x13, x3, x15
  40198c:	92407c49 	and	x9, x2, #0xffffffff
  401990:	9b0a7dad 	mul	x13, x13, x10
  401994:	8b428062 	add	x2, x3, x2, lsr #32
  401998:	8b0b01a3 	add	x3, x13, x11
  40199c:	eb0201ff 	cmp	x15, x2
  4019a0:	9a8d806d 	csel	x13, x3, x13, hi  // hi = pmore
  4019a4:	8b028123 	add	x3, x9, x2, lsl #32
  4019a8:	8b4281a2 	add	x2, x13, x2, lsr #32
  4019ac:	eb02003f 	cmp	x1, x2
  4019b0:	54002042 	b.cs	401db8 <__divtf3+0x778>  // b.hs, b.nlast
  4019b4:	ab010089 	adds	x9, x4, x1
  4019b8:	d10004ca 	sub	x10, x6, #0x1
  4019bc:	aa0903e1 	mov	x1, x9
  4019c0:	540000a2 	b.cs	4019d4 <__divtf3+0x394>  // b.hs, b.nlast
  4019c4:	eb02013f 	cmp	x9, x2
  4019c8:	54002823 	b.cc	401ecc <__divtf3+0x88c>  // b.lo, b.ul, b.last
  4019cc:	fa4300a2 	ccmp	x5, x3, #0x2, eq  // eq = none
  4019d0:	540027e3 	b.cc	401ecc <__divtf3+0x88c>  // b.lo, b.ul, b.last
  4019d4:	eb0300bf 	cmp	x5, x3
  4019d8:	aa0a03e6 	mov	x6, x10
  4019dc:	1a9f07e9 	cset	w9, ne  // ne = any
  4019e0:	7100013f 	cmp	w9, #0x0
  4019e4:	aa0e03e9 	mov	x9, x14
  4019e8:	fa420020 	ccmp	x1, x2, #0x0, eq  // eq = none
  4019ec:	b24000c1 	orr	x1, x6, #0x1
  4019f0:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  4019f4:	17ffff52 	b	40173c <__divtf3+0xfc>
  4019f8:	aa0700c3 	orr	x3, x6, x7
  4019fc:	b4000b63 	cbz	x3, 401b68 <__divtf3+0x528>
  401a00:	b4001707 	cbz	x7, 401ce0 <__divtf3+0x6a0>
  401a04:	dac010e3 	clz	x3, x7
  401a08:	d1003c64 	sub	x4, x3, #0xf
  401a0c:	11000c8e 	add	w14, w4, #0x3
  401a10:	528007ab 	mov	w11, #0x3d                  	// #61
  401a14:	4b040164 	sub	w4, w11, w4
  401a18:	9ace20e7 	lsl	x7, x7, x14
  401a1c:	9ac424c4 	lsr	x4, x6, x4
  401a20:	aa070087 	orr	x7, x4, x7
  401a24:	9ace20c6 	lsl	x6, x6, x14
  401a28:	8b080064 	add	x4, x3, x8
  401a2c:	4a0f01ab 	eor	w11, w13, w15
  401a30:	d287fde8 	mov	x8, #0x3fef                	// #16367
  401a34:	92401d6e 	and	x14, x11, #0xff
  401a38:	8b080088 	add	x8, x4, x8
  401a3c:	d2800003 	mov	x3, #0x0                   	// #0
  401a40:	f100245f 	cmp	x2, #0x9
  401a44:	54ffe5ad 	b.le	4016f8 <__divtf3+0xb8>
  401a48:	17ffff4e 	b	401780 <__divtf3+0x140>
  401a4c:	aa020025 	orr	x5, x1, x2
  401a50:	b4000805 	cbz	x5, 401b50 <__divtf3+0x510>
  401a54:	b4001342 	cbz	x2, 401cbc <__divtf3+0x67c>
  401a58:	dac01040 	clz	x0, x2
  401a5c:	d1003c05 	sub	x5, x0, #0xf
  401a60:	11000ca7 	add	w7, w5, #0x3
  401a64:	528007a4 	mov	w4, #0x3d                  	// #61
  401a68:	4b050084 	sub	w4, w4, w5
  401a6c:	9ac72042 	lsl	x2, x2, x7
  401a70:	9ac42424 	lsr	x4, x1, x4
  401a74:	aa020085 	orr	x5, x4, x2
  401a78:	9ac72021 	lsl	x1, x1, x7
  401a7c:	9287fdc8 	mov	x8, #0xffffffffffffc011    	// #-16367
  401a80:	d2800002 	mov	x2, #0x0                   	// #0
  401a84:	cb000108 	sub	x8, x8, x0
  401a88:	d2800010 	mov	x16, #0x0                   	// #0
  401a8c:	52800000 	mov	w0, #0x0                   	// #0
  401a90:	17ffff05 	b	4016a4 <__divtf3+0x64>
  401a94:	aa020025 	orr	x5, x1, x2
  401a98:	b50004e5 	cbnz	x5, 401b34 <__divtf3+0x4f4>
  401a9c:	d2800001 	mov	x1, #0x0                   	// #0
  401aa0:	d2800102 	mov	x2, #0x8                   	// #8
  401aa4:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401aa8:	d2800050 	mov	x16, #0x2                   	// #2
  401aac:	52800000 	mov	w0, #0x0                   	// #0
  401ab0:	17fffefd 	b	4016a4 <__divtf3+0x64>
  401ab4:	928fffc3 	mov	x3, #0xffffffffffff8001    	// #-32767
  401ab8:	8b030108 	add	x8, x8, x3
  401abc:	aa0700c3 	orr	x3, x6, x7
  401ac0:	b4000303 	cbz	x3, 401b20 <__divtf3+0x4e0>
  401ac4:	f25100ff 	tst	x7, #0x800000000000
  401ac8:	b2400442 	orr	x2, x2, #0x3
  401acc:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
  401ad0:	d2800063 	mov	x3, #0x3                   	// #3
  401ad4:	4a0f01ab 	eor	w11, w13, w15
  401ad8:	92401d6e 	and	x14, x11, #0xff
  401adc:	f100245f 	cmp	x2, #0x9
  401ae0:	54ffe0cd 	b.le	4016f8 <__divtf3+0xb8>
  401ae4:	f1003c5f 	cmp	x2, #0xf
  401ae8:	54ffe4c1 	b.ne	401780 <__divtf3+0x140>  // b.any
  401aec:	b6780ba5 	tbz	x5, #47, 401c60 <__divtf3+0x620>
  401af0:	b7780b87 	tbnz	x7, #47, 401c60 <__divtf3+0x620>
  401af4:	b25100e5 	orr	x5, x7, #0x800000000000
  401af8:	2a0f03eb 	mov	w11, w15
  401afc:	9240bca5 	and	x5, x5, #0xffffffffffff
  401b00:	aa0603e1 	mov	x1, x6
  401b04:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401b08:	17ffff3a 	b	4017f0 <__divtf3+0x1b0>
  401b0c:	aa0503e7 	mov	x7, x5
  401b10:	aa0103e6 	mov	x6, x1
  401b14:	aa0a03e9 	mov	x9, x10
  401b18:	aa1003e3 	mov	x3, x16
  401b1c:	17ffff01 	b	401720 <__divtf3+0xe0>
  401b20:	b27f0042 	orr	x2, x2, #0x2
  401b24:	d2800007 	mov	x7, #0x0                   	// #0
  401b28:	d2800006 	mov	x6, #0x0                   	// #0
  401b2c:	d2800043 	mov	x3, #0x2                   	// #2
  401b30:	17ffffe9 	b	401ad4 <__divtf3+0x494>
  401b34:	d36ffc40 	lsr	x0, x2, #47
  401b38:	aa0203e5 	mov	x5, x2
  401b3c:	52000000 	eor	w0, w0, #0x1
  401b40:	d2800182 	mov	x2, #0xc                   	// #12
  401b44:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401b48:	d2800070 	mov	x16, #0x3                   	// #3
  401b4c:	17fffed6 	b	4016a4 <__divtf3+0x64>
  401b50:	d2800001 	mov	x1, #0x0                   	// #0
  401b54:	d2800082 	mov	x2, #0x4                   	// #4
  401b58:	d2800008 	mov	x8, #0x0                   	// #0
  401b5c:	d2800030 	mov	x16, #0x1                   	// #1
  401b60:	52800000 	mov	w0, #0x0                   	// #0
  401b64:	17fffed0 	b	4016a4 <__divtf3+0x64>
  401b68:	4a0f01ab 	eor	w11, w13, w15
  401b6c:	b2400042 	orr	x2, x2, #0x1
  401b70:	92401d6e 	and	x14, x11, #0xff
  401b74:	d2800007 	mov	x7, #0x0                   	// #0
  401b78:	d2800006 	mov	x6, #0x0                   	// #0
  401b7c:	d2800023 	mov	x3, #0x1                   	// #1
  401b80:	f100245f 	cmp	x2, #0x9
  401b84:	54ffdbad 	b.le	4016f8 <__divtf3+0xb8>
  401b88:	17fffefe 	b	401780 <__divtf3+0x140>
  401b8c:	d2800021 	mov	x1, #0x1                   	// #1
  401b90:	cb040024 	sub	x4, x1, x4
  401b94:	1200012b 	and	w11, w9, #0x1
  401b98:	f101d09f 	cmp	x4, #0x74
  401b9c:	5400102c 	b.gt	401da0 <__divtf3+0x760>
  401ba0:	f100fc9f 	cmp	x4, #0x3f
  401ba4:	5400126d 	b.le	401df0 <__divtf3+0x7b0>
  401ba8:	52801001 	mov	w1, #0x80                  	// #128
  401bac:	4b040021 	sub	w1, w1, w4
  401bb0:	f101009f 	cmp	x4, #0x40
  401bb4:	51010084 	sub	w4, w4, #0x40
  401bb8:	9ac120e1 	lsl	x1, x7, x1
  401bbc:	aa0100c1 	orr	x1, x6, x1
  401bc0:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  401bc4:	9ac424e1 	lsr	x1, x7, x4
  401bc8:	f10000df 	cmp	x6, #0x0
  401bcc:	9a9f07e2 	cset	x2, ne  // ne = any
  401bd0:	aa010041 	orr	x1, x2, x1
  401bd4:	f2400825 	ands	x5, x1, #0x7
  401bd8:	54001260 	b.eq	401e24 <__divtf3+0x7e4>  // b.none
  401bdc:	d2800005 	mov	x5, #0x0                   	// #0
  401be0:	926a058c 	and	x12, x12, #0xc00000
  401be4:	321c0000 	orr	w0, w0, #0x10
  401be8:	f150019f 	cmp	x12, #0x400, lsl #12
  401bec:	54001800 	b.eq	401eec <__divtf3+0x8ac>  // b.none
  401bf0:	f160019f 	cmp	x12, #0x800, lsl #12
  401bf4:	54001c80 	b.eq	401f84 <__divtf3+0x944>  // b.none
  401bf8:	b4001b8c 	cbz	x12, 401f68 <__divtf3+0x928>
  401bfc:	b7981805 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401c00:	321d0000 	orr	w0, w0, #0x8
  401c04:	93c10ca1 	extr	x1, x5, x1, #3
  401c08:	52800004 	mov	w4, #0x0                   	// #0
  401c0c:	d343c8a5 	ubfx	x5, x5, #3, #48
  401c10:	1400004b 	b	401d3c <__divtf3+0x6fc>
  401c14:	1200012b 	and	w11, w9, #0x1
  401c18:	52800004 	mov	w4, #0x0                   	// #0
  401c1c:	d2800005 	mov	x5, #0x0                   	// #0
  401c20:	d2800001 	mov	x1, #0x0                   	// #0
  401c24:	17fffef3 	b	4017f0 <__divtf3+0x1b0>
  401c28:	926a0581 	and	x1, x12, #0xc00000
  401c2c:	321c0000 	orr	w0, w0, #0x10
  401c30:	f150003f 	cmp	x1, #0x400, lsl #12
  401c34:	540017c0 	b.eq	401f2c <__divtf3+0x8ec>  // b.none
  401c38:	f160003f 	cmp	x1, #0x800, lsl #12
  401c3c:	540010e0 	b.eq	401e58 <__divtf3+0x818>  // b.none
  401c40:	b5ffd8a1 	cbnz	x1, 401754 <__divtf3+0x114>
  401c44:	92400cc1 	and	x1, x6, #0xf
  401c48:	1200012b 	and	w11, w9, #0x1
  401c4c:	f100103f 	cmp	x1, #0x4
  401c50:	54ffd840 	b.eq	401758 <__divtf3+0x118>  // b.none
  401c54:	b10010c6 	adds	x6, x6, #0x4
  401c58:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401c5c:	17fffebf 	b	401758 <__divtf3+0x118>
  401c60:	b25100a5 	orr	x5, x5, #0x800000000000
  401c64:	2a0d03eb 	mov	w11, w13
  401c68:	9240bca5 	and	x5, x5, #0xffffffffffff
  401c6c:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401c70:	17fffee0 	b	4017f0 <__divtf3+0x1b0>
  401c74:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401c78:	d2800005 	mov	x5, #0x0                   	// #0
  401c7c:	d2800001 	mov	x1, #0x0                   	// #0
  401c80:	17fffedc 	b	4017f0 <__divtf3+0x1b0>
  401c84:	ab050026 	adds	x6, x1, x5
  401c88:	d1000627 	sub	x7, x17, #0x1
  401c8c:	9a040042 	adc	x2, x2, x4
  401c90:	9a9f37f2 	cset	x18, cs  // cs = hs, nlast
  401c94:	aa0603e1 	mov	x1, x6
  401c98:	eb02009f 	cmp	x4, x2
  401c9c:	540007a2 	b.cs	401d90 <__divtf3+0x750>  // b.hs, b.nlast
  401ca0:	eb02007f 	cmp	x3, x2
  401ca4:	54000969 	b.ls	401dd0 <__divtf3+0x790>  // b.plast
  401ca8:	ab0600a6 	adds	x6, x5, x6
  401cac:	d1000a27 	sub	x7, x17, #0x2
  401cb0:	aa0603e1 	mov	x1, x6
  401cb4:	9a040042 	adc	x2, x2, x4
  401cb8:	17ffff12 	b	401900 <__divtf3+0x2c0>
  401cbc:	dac01020 	clz	x0, x1
  401cc0:	9100c405 	add	x5, x0, #0x31
  401cc4:	91010000 	add	x0, x0, #0x40
  401cc8:	f100f0bf 	cmp	x5, #0x3c
  401ccc:	54ffecad 	b.le	401a60 <__divtf3+0x420>
  401cd0:	5100f4a5 	sub	w5, w5, #0x3d
  401cd4:	9ac52025 	lsl	x5, x1, x5
  401cd8:	d2800001 	mov	x1, #0x0                   	// #0
  401cdc:	17ffff68 	b	401a7c <__divtf3+0x43c>
  401ce0:	dac010c3 	clz	x3, x6
  401ce4:	9100c464 	add	x4, x3, #0x31
  401ce8:	91010063 	add	x3, x3, #0x40
  401cec:	f100f09f 	cmp	x4, #0x3c
  401cf0:	54ffe8ed 	b.le	401a0c <__divtf3+0x3cc>
  401cf4:	5100f484 	sub	w4, w4, #0x3d
  401cf8:	9ac420c4 	lsl	x4, x6, x4
  401cfc:	d2800006 	mov	x6, #0x0                   	// #0
  401d00:	aa0403e7 	mov	x7, x4
  401d04:	17ffff49 	b	401a28 <__divtf3+0x3e8>
  401d08:	926a0581 	and	x1, x12, #0xc00000
  401d0c:	f150003f 	cmp	x1, #0x400, lsl #12
  401d10:	54001000 	b.eq	401f10 <__divtf3+0x8d0>  // b.none
  401d14:	f160003f 	cmp	x1, #0x800, lsl #12
  401d18:	54000920 	b.eq	401e3c <__divtf3+0x7fc>  // b.none
  401d1c:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d20:	d2800005 	mov	x5, #0x0                   	// #0
  401d24:	b4000081 	cbz	x1, 401d34 <__divtf3+0x6f4>
  401d28:	2a0203e4 	mov	w4, w2
  401d2c:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401d30:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  401d34:	52800282 	mov	w2, #0x14                  	// #20
  401d38:	2a020000 	orr	w0, w0, w2
  401d3c:	d2800003 	mov	x3, #0x0                   	// #0
  401d40:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  401d44:	b340bca3 	bfxil	x3, x5, #0, #48
  401d48:	9e670020 	fmov	d0, x1
  401d4c:	b3503c83 	bfi	x3, x4, #48, #16
  401d50:	9eaf0060 	fmov	v0.d[1], x3
  401d54:	3d8007e0 	str	q0, [sp, #16]
  401d58:	940000ba 	bl	402040 <__sfp_handle_exceptions>
  401d5c:	3dc007e0 	ldr	q0, [sp, #16]
  401d60:	17fffe9d 	b	4017d4 <__divtf3+0x194>
  401d64:	b25100e5 	orr	x5, x7, #0x800000000000
  401d68:	1200012b 	and	w11, w9, #0x1
  401d6c:	9240bca5 	and	x5, x5, #0xffffffffffff
  401d70:	aa0603e1 	mov	x1, x6
  401d74:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d78:	17fffe9e 	b	4017f0 <__divtf3+0x1b0>
  401d7c:	1200012b 	and	w11, w9, #0x1
  401d80:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d84:	d2800005 	mov	x5, #0x0                   	// #0
  401d88:	d2800001 	mov	x1, #0x0                   	// #0
  401d8c:	17fffe99 	b	4017f0 <__divtf3+0x1b0>
  401d90:	f100025f 	cmp	x18, #0x0
  401d94:	fa420080 	ccmp	x4, x2, #0x0, eq  // eq = none
  401d98:	54ffdb41 	b.ne	401900 <__divtf3+0x2c0>  // b.any
  401d9c:	17ffffc1 	b	401ca0 <__divtf3+0x660>
  401da0:	aa0700c1 	orr	x1, x6, x7
  401da4:	b5000861 	cbnz	x1, 401eb0 <__divtf3+0x870>
  401da8:	321d0000 	orr	w0, w0, #0x8
  401dac:	52800004 	mov	w4, #0x0                   	// #0
  401db0:	d2800005 	mov	x5, #0x0                   	// #0
  401db4:	17ffffe2 	b	401d3c <__divtf3+0x6fc>
  401db8:	f100007f 	cmp	x3, #0x0
  401dbc:	1a9f07e9 	cset	w9, ne  // ne = any
  401dc0:	7100013f 	cmp	w9, #0x0
  401dc4:	fa421020 	ccmp	x1, x2, #0x0, ne  // ne = any
  401dc8:	54ffe0c1 	b.ne	4019e0 <__divtf3+0x3a0>  // b.any
  401dcc:	17fffefa 	b	4019b4 <__divtf3+0x374>
  401dd0:	fa460200 	ccmp	x16, x6, #0x0, eq  // eq = none
  401dd4:	54ffd969 	b.ls	401900 <__divtf3+0x2c0>  // b.plast
  401dd8:	17ffffb4 	b	401ca8 <__divtf3+0x668>
  401ddc:	aa0103e2 	mov	x2, x1
  401de0:	d1000508 	sub	x8, x8, #0x1
  401de4:	aa0503e3 	mov	x3, x5
  401de8:	d2800001 	mov	x1, #0x0                   	// #0
  401dec:	17fffe93 	b	401838 <__divtf3+0x1f8>
  401df0:	52800801 	mov	w1, #0x40                  	// #64
  401df4:	4b040021 	sub	w1, w1, w4
  401df8:	9ac424c3 	lsr	x3, x6, x4
  401dfc:	9ac120c6 	lsl	x6, x6, x1
  401e00:	f10000df 	cmp	x6, #0x0
  401e04:	9a9f07e2 	cset	x2, ne  // ne = any
  401e08:	9ac120e1 	lsl	x1, x7, x1
  401e0c:	aa030021 	orr	x1, x1, x3
  401e10:	9ac424e5 	lsr	x5, x7, x4
  401e14:	aa020021 	orr	x1, x1, x2
  401e18:	f240083f 	tst	x1, #0x7
  401e1c:	54ffee21 	b.ne	401be0 <__divtf3+0x5a0>  // b.any
  401e20:	b7980b85 	tbnz	x5, #51, 401f90 <__divtf3+0x950>
  401e24:	52800004 	mov	w4, #0x0                   	// #0
  401e28:	93c10ca1 	extr	x1, x5, x1, #3
  401e2c:	d343c8a5 	ubfx	x5, x5, #3, #48
  401e30:	365fce0c 	tbz	w12, #11, 4017f0 <__divtf3+0x1b0>
  401e34:	321d0000 	orr	w0, w0, #0x8
  401e38:	17ffffc1 	b	401d3c <__divtf3+0x6fc>
  401e3c:	f100013f 	cmp	x9, #0x0
  401e40:	528fffe1 	mov	w1, #0x7fff                	// #32767
  401e44:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401e48:	1a810044 	csel	w4, w2, w1, eq  // eq = none
  401e4c:	9a9f00a5 	csel	x5, x5, xzr, eq  // eq = none
  401e50:	da9f13e1 	csetm	x1, eq  // eq = none
  401e54:	17ffffb8 	b	401d34 <__divtf3+0x6f4>
  401e58:	5280000b 	mov	w11, #0x0                   	// #0
  401e5c:	b4ffc7e9 	cbz	x9, 401758 <__divtf3+0x118>
  401e60:	b10020c6 	adds	x6, x6, #0x8
  401e64:	5280002b 	mov	w11, #0x1                   	// #1
  401e68:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401e6c:	17fffe3b 	b	401758 <__divtf3+0x118>
  401e70:	d10008c6 	sub	x6, x6, #0x2
  401e74:	8b040042 	add	x2, x2, x4
  401e78:	17fffe8b 	b	4018a4 <__divtf3+0x264>
  401e7c:	d10008e7 	sub	x7, x7, #0x2
  401e80:	8b040063 	add	x3, x3, x4
  401e84:	17fffe7c 	b	401874 <__divtf3+0x234>
  401e88:	d287ffe2 	mov	x2, #0x3fff                	// #16383
  401e8c:	8b020104 	add	x4, x8, x2
  401e90:	aa0e03e9 	mov	x9, x14
  401e94:	92800006 	mov	x6, #0xffffffffffffffff    	// #-1
  401e98:	f100009f 	cmp	x4, #0x0
  401e9c:	54ffec6c 	b.gt	401c28 <__divtf3+0x5e8>
  401ea0:	d2800021 	mov	x1, #0x1                   	// #1
  401ea4:	cb040024 	sub	x4, x1, x4
  401ea8:	f101d09f 	cmp	x4, #0x74
  401eac:	54ffe7ad 	b.le	401ba0 <__divtf3+0x560>
  401eb0:	926a058c 	and	x12, x12, #0xc00000
  401eb4:	321c0000 	orr	w0, w0, #0x10
  401eb8:	f150019f 	cmp	x12, #0x400, lsl #12
  401ebc:	54000500 	b.eq	401f5c <__divtf3+0x91c>  // b.none
  401ec0:	f160019f 	cmp	x12, #0x800, lsl #12
  401ec4:	9a9f0121 	csel	x1, x9, xzr, eq  // eq = none
  401ec8:	17ffffb8 	b	401da8 <__divtf3+0x768>
  401ecc:	d37ff8aa 	lsl	x10, x5, #1
  401ed0:	d10008c6 	sub	x6, x6, #0x2
  401ed4:	eb0a00bf 	cmp	x5, x10
  401ed8:	9a849481 	cinc	x1, x4, hi  // hi = pmore
  401edc:	eb0a007f 	cmp	x3, x10
  401ee0:	8b010121 	add	x1, x9, x1
  401ee4:	1a9f07e9 	cset	w9, ne  // ne = any
  401ee8:	17fffebe 	b	4019e0 <__divtf3+0x3a0>
  401eec:	b5000069 	cbnz	x9, 401ef8 <__divtf3+0x8b8>
  401ef0:	b1002021 	adds	x1, x1, #0x8
  401ef4:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  401ef8:	b69fe845 	tbz	x5, #51, 401c00 <__divtf3+0x5c0>
  401efc:	321d0000 	orr	w0, w0, #0x8
  401f00:	52800024 	mov	w4, #0x1                   	// #1
  401f04:	d2800005 	mov	x5, #0x0                   	// #0
  401f08:	d2800001 	mov	x1, #0x0                   	// #0
  401f0c:	17ffff8c 	b	401d3c <__divtf3+0x6fc>
  401f10:	f100013f 	cmp	x9, #0x0
  401f14:	528fffe1 	mov	w1, #0x7fff                	// #32767
  401f18:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401f1c:	1a811044 	csel	w4, w2, w1, ne  // ne = any
  401f20:	9a9f10a5 	csel	x5, x5, xzr, ne  // ne = any
  401f24:	da9f03e1 	csetm	x1, ne  // ne = any
  401f28:	17ffff83 	b	401d34 <__divtf3+0x6f4>
  401f2c:	5280002b 	mov	w11, #0x1                   	// #1
  401f30:	b5ffc149 	cbnz	x9, 401758 <__divtf3+0x118>
  401f34:	b10020c6 	adds	x6, x6, #0x8
  401f38:	5280000b 	mov	w11, #0x0                   	// #0
  401f3c:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401f40:	17fffe06 	b	401758 <__divtf3+0x118>
  401f44:	d1000863 	sub	x3, x3, #0x2
  401f48:	8b040021 	add	x1, x1, x4
  401f4c:	17fffe88 	b	40196c <__divtf3+0x32c>
  401f50:	d10008c6 	sub	x6, x6, #0x2
  401f54:	8b040042 	add	x2, x2, x4
  401f58:	17fffe79 	b	40193c <__divtf3+0x2fc>
  401f5c:	d2800021 	mov	x1, #0x1                   	// #1
  401f60:	cb090021 	sub	x1, x1, x9
  401f64:	17ffff91 	b	401da8 <__divtf3+0x768>
  401f68:	92400c22 	and	x2, x1, #0xf
  401f6c:	f100105f 	cmp	x2, #0x4
  401f70:	54fffc40 	b.eq	401ef8 <__divtf3+0x8b8>  // b.none
  401f74:	b1001021 	adds	x1, x1, #0x4
  401f78:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  401f7c:	b79ffc05 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401f80:	17ffff20 	b	401c00 <__divtf3+0x5c0>
  401f84:	b5fffb69 	cbnz	x9, 401ef0 <__divtf3+0x8b0>
  401f88:	b79ffba5 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401f8c:	17ffff1d 	b	401c00 <__divtf3+0x5c0>
  401f90:	321c0000 	orr	w0, w0, #0x10
  401f94:	17ffffda 	b	401efc <__divtf3+0x8bc>
  401f98:	d503201f 	nop
  401f9c:	d503201f 	nop

0000000000401fa0 <__floatunditf>:
  401fa0:	b40002a0 	cbz	x0, 401ff4 <__floatunditf+0x54>
  401fa4:	dac01001 	clz	x1, x0
  401fa8:	528807c2 	mov	w2, #0x403e                	// #16446
  401fac:	4b010042 	sub	w2, w2, w1
  401fb0:	d2880de3 	mov	x3, #0x406f                	// #16495
  401fb4:	12003844 	and	w4, w2, #0x7fff
  401fb8:	cb22c062 	sub	x2, x3, w2, sxtw
  401fbc:	f100fc5f 	cmp	x2, #0x3f
  401fc0:	540002ac 	b.gt	402014 <__floatunditf+0x74>
  401fc4:	1100c423 	add	w3, w1, #0x31
  401fc8:	528001e2 	mov	w2, #0xf                   	// #15
  401fcc:	4b010041 	sub	w1, w2, w1
  401fd0:	9ac12401 	lsr	x1, x0, x1
  401fd4:	9240bc21 	and	x1, x1, #0xffffffffffff
  401fd8:	9ac32000 	lsl	x0, x0, x3
  401fdc:	d2800003 	mov	x3, #0x0                   	// #0
  401fe0:	b340bc23 	bfxil	x3, x1, #0, #48
  401fe4:	9e670000 	fmov	d0, x0
  401fe8:	b3503c83 	bfi	x3, x4, #48, #16
  401fec:	9eaf0060 	fmov	v0.d[1], x3
  401ff0:	d65f03c0 	ret
  401ff4:	d2800001 	mov	x1, #0x0                   	// #0
  401ff8:	d2800003 	mov	x3, #0x0                   	// #0
  401ffc:	b340bc23 	bfxil	x3, x1, #0, #48
  402000:	9e670000 	fmov	d0, x0
  402004:	52800004 	mov	w4, #0x0                   	// #0
  402008:	b3503c83 	bfi	x3, x4, #48, #16
  40200c:	9eaf0060 	fmov	v0.d[1], x3
  402010:	d65f03c0 	ret
  402014:	51003c21 	sub	w1, w1, #0xf
  402018:	d2800003 	mov	x3, #0x0                   	// #0
  40201c:	9ac12001 	lsl	x1, x0, x1
  402020:	9240bc21 	and	x1, x1, #0xffffffffffff
  402024:	d2800000 	mov	x0, #0x0                   	// #0
  402028:	9e670000 	fmov	d0, x0
  40202c:	b340bc23 	bfxil	x3, x1, #0, #48
  402030:	b3503c83 	bfi	x3, x4, #48, #16
  402034:	9eaf0060 	fmov	v0.d[1], x3
  402038:	d65f03c0 	ret
  40203c:	d503201f 	nop

0000000000402040 <__sfp_handle_exceptions>:
  402040:	36000080 	tbz	w0, #0, 402050 <__sfp_handle_exceptions+0x10>
  402044:	0f000401 	movi	v1.2s, #0x0
  402048:	1e211820 	fdiv	s0, s1, s1
  40204c:	d53b4421 	mrs	x1, fpsr
  402050:	360800a0 	tbz	w0, #1, 402064 <__sfp_handle_exceptions+0x24>
  402054:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
  402058:	0f000402 	movi	v2.2s, #0x0
  40205c:	1e221820 	fdiv	s0, s1, s2
  402060:	d53b4421 	mrs	x1, fpsr
  402064:	36100100 	tbz	w0, #2, 402084 <__sfp_handle_exceptions+0x44>
  402068:	5298b5c2 	mov	w2, #0xc5ae                	// #50606
  40206c:	12b01001 	mov	w1, #0x7f7fffff            	// #2139095039
  402070:	72ae93a2 	movk	w2, #0x749d, lsl #16
  402074:	1e270021 	fmov	s1, w1
  402078:	1e270042 	fmov	s2, w2
  40207c:	1e222820 	fadd	s0, s1, s2
  402080:	d53b4421 	mrs	x1, fpsr
  402084:	36180080 	tbz	w0, #3, 402094 <__sfp_handle_exceptions+0x54>
  402088:	0f044401 	movi	v1.2s, #0x80, lsl #16
  40208c:	1e210820 	fmul	s0, s1, s1
  402090:	d53b4421 	mrs	x1, fpsr
  402094:	362000c0 	tbz	w0, #4, 4020ac <__sfp_handle_exceptions+0x6c>
  402098:	12b01000 	mov	w0, #0x7f7fffff            	// #2139095039
  40209c:	1e2e1002 	fmov	s2, #1.000000000000000000e+00
  4020a0:	1e270001 	fmov	s1, w0
  4020a4:	1e223820 	fsub	s0, s1, s2
  4020a8:	d53b4420 	mrs	x0, fpsr
  4020ac:	d65f03c0 	ret

00000000004020b0 <call_weak_fn>:
  4020b0:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4020b4:	f9476400 	ldr	x0, [x0, #3784]
  4020b8:	b4000040 	cbz	x0, 4020c0 <call_weak_fn+0x10>
  4020bc:	17fffca1 	b	401340 <__gmon_start__@plt>
  4020c0:	d65f03c0 	ret

00000000004020c4 <_OffsetAbsSyms>:
#include <zephyr/kernel.h>
#include <kernel_arch_data.h>
#include <gen_offset.h>
#include <kernel_offsets.h>

GEN_ABS_SYM_END
  4020c4:	d65f03c0 	ret

00000000004020c8 <get_send_ctx>:
/* list of currently in-flight receive contexts */
static sys_slist_t isotp_recv_ctx_list;

static int get_send_ctx(struct isotp_fast_ctx *ctx, isotp_fast_msg_id recipient_addr,
                        struct isotp_fast_send_ctx **sctx)
{
  4020c8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4020cc:	910003fd 	mov	x29, sp
  4020d0:	f9001bf7 	str	x23, [sp, #48]
  4020d4:	aa0003f7 	mov	x23, x0
  4020d8:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4020dc:	a9025bf5 	stp	x21, x22, [sp, #32]
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  4020e0:	d0000156 	adrp	x22, 42c000 <__dso_handle>
  4020e4:	f9476800 	ldr	x0, [x0, #3792]
  4020e8:	a90153f3 	stp	x19, x20, [sp, #16]
  4020ec:	2a0103f4 	mov	w20, w1
  4020f0:	f9456ac3 	ldr	x3, [x22, #2768]
  4020f4:	f9400001 	ldr	x1, [x0]
  4020f8:	f90027e1 	str	x1, [sp, #72]
  4020fc:	d2800001 	mov	x1, #0x0                   	// #0
  402100:	aa0203f5 	mov	x21, x2
    return (isotp_fast_node_id)(frame->id & ISOTP_FIXED_ADDR_SA_MASK);
}

static inline isotp_fast_node_id isotp_fast_get_addr_recipient(isotp_fast_msg_id addr)
{
    return (isotp_fast_node_id)((addr & ISOTP_FIXED_ADDR_TA_MASK) >> ISOTP_FIXED_ADDR_TA_POS);
  402104:	d3483e80 	ubfx	x0, x20, #8, #8
    isotp_fast_node_id recipient_id = isotp_fast_get_addr_recipient(recipient_addr);
    struct isotp_fast_send_ctx *context;

    SYS_SLIST_FOR_EACH_CONTAINER(&isotp_send_ctx_list, context, node)
  402108:	f90023e3 	str	x3, [sp, #64]
  40210c:	b50003e3 	cbnz	x3, 402188 <get_send_ctx+0xc0>
            *sctx = context;
            return 0;
        }
    }

    int err = k_mem_slab_alloc(&isotp_send_ctx_slab, (void **)&context, K_NO_WAIT);
  402110:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  402114:	910103e1 	add	x1, sp, #0x40
  402118:	d2800002 	mov	x2, #0x0                   	// #0
  40211c:	f947f000 	ldr	x0, [x0, #4064]
  402120:	94002fe7 	bl	40e0bc <k_mem_slab_alloc>
  402124:	2a0003f3 	mov	w19, w0
    if (err != 0) {
  402128:	35000540 	cbnz	w0, 4021d0 <get_send_ctx+0x108>
        return ISOTP_NO_CTX_LEFT;
    }
    *sctx = context;
  40212c:	f94023e0 	ldr	x0, [sp, #64]
  402130:	f90002a0 	str	x0, [x21]
    context->ctx = ctx;
    context->recipient_addr = recipient_addr;
    context->error = 0;
    k_work_init(&context->work, receive_work_handler);
  402134:	90000001 	adrp	x1, 402000 <__floatunditf+0x60>
  402138:	913a6021 	add	x1, x1, #0xe98
  40213c:	91006000 	add	x0, x0, #0x18
    context->ctx = ctx;
  402140:	f81f0017 	stur	x23, [x0, #-16]
    context->recipient_addr = recipient_addr;
  402144:	b81f8014 	stur	w20, [x0, #-8]
    context->error = 0;
  402148:	3902ac1f 	strb	wzr, [x0, #171]
    k_work_init(&context->work, receive_work_handler);
  40214c:	940037ae 	bl	410004 <k_work_init>
    k_timer_init(&context->timer, receive_timeout_handler, NULL);
  402150:	f94023e0 	ldr	x0, [sp, #64]
  402154:	d2800002 	mov	x2, #0x0                   	// #0
  402158:	90000001 	adrp	x1, 402000 <__floatunditf+0x60>
  40215c:	910ff021 	add	x1, x1, #0x3fc
  402160:	9100e000 	add	x0, x0, #0x38
  402164:	9400449e 	bl	4133dc <k_timer_init>
    sys_slist_append(&isotp_send_ctx_list, &context->node);
  402168:	f94023e0 	ldr	x0, [sp, #64]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
  40216c:	912b42c1 	add	x1, x22, #0xad0
	parent->next = child;
  402170:	f900001f 	str	xzr, [x0]
	return list->tail;
  402174:	f9400422 	ldr	x2, [x1, #8]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
  402178:	b5000262 	cbnz	x2, 4021c4 <get_send_ctx+0xfc>
	list->head = node;
  40217c:	f9056ac0 	str	x0, [x22, #2768]
	list->tail = node;
  402180:	f9000420 	str	x0, [x1, #8]
}
  402184:	14000006 	b	40219c <get_send_ctx+0xd4>
        if (isotp_fast_get_addr_recipient(context->recipient_addr) == recipient_id) {
  402188:	39404461 	ldrb	w1, [x3, #17]
  40218c:	6b00003f 	cmp	w1, w0
  402190:	54000161 	b.ne	4021bc <get_send_ctx+0xf4>  // b.any
            return 0;
  402194:	52800013 	mov	w19, #0x0                   	// #0
            *sctx = context;
  402198:	f90002a3 	str	x3, [x21]
    LOG_DBG("Created new send context for recipient %x", recipient_addr);

    return 0;
}
  40219c:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4021a0:	f9476800 	ldr	x0, [x0, #3792]
  4021a4:	f94027e2 	ldr	x2, [sp, #72]
  4021a8:	f9400001 	ldr	x1, [x0]
  4021ac:	eb010042 	subs	x2, x2, x1
  4021b0:	d2800001 	mov	x1, #0x0                   	// #0
  4021b4:	54000120 	b.eq	4021d8 <get_send_ctx+0x110>  // b.none
  4021b8:	97fffc5a 	bl	401320 <__stack_chk_fail@plt>
	return node->next;
  4021bc:	f9400063 	ldr	x3, [x3]
  4021c0:	17ffffd2 	b	402108 <get_send_ctx+0x40>
	parent->next = child;
  4021c4:	f9000040 	str	x0, [x2]
	list->tail = node;
  4021c8:	f9000420 	str	x0, [x1, #8]
}
  4021cc:	17fffff4 	b	40219c <get_send_ctx+0xd4>
        return ISOTP_NO_CTX_LEFT;
  4021d0:	12800193 	mov	w19, #0xfffffff3            	// #-13
  4021d4:	17fffff2 	b	40219c <get_send_ctx+0xd4>
}
  4021d8:	2a1303e0 	mov	w0, w19
  4021dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4021e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4021e4:	f9401bf7 	ldr	x23, [sp, #48]
  4021e8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4021ec:	d65f03c0 	ret

00000000004021f0 <k_timer_stop>:
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_TIMER_STOP);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_stop(timer);
  4021f0:	1400449d 	b	413464 <z_impl_k_timer_stop>

00000000004021f4 <notify_waiting_receiver>:
    }
}

#ifdef CONFIG_ISOTP_FAST_BLOCKING_RECEIVE
static void notify_waiting_receiver(struct isotp_fast_recv_ctx *rctx)
{
  4021f4:	aa0003e2 	mov	x2, x0
	return list->head;
  4021f8:	f9400400 	ldr	x0, [x0, #8]
  4021fc:	f9402001 	ldr	x1, [x0, #64]
    struct isotp_fast_recv_await_ctx *awaiter;
    SYS_SLIST_FOR_EACH_CONTAINER(&rctx->ctx->wait_recv_list, awaiter, node)
  402200:	b40002a1 	cbz	x1, 402254 <notify_waiting_receiver+0x60>
    {
        if ((awaiter->sender.id & awaiter->sender.mask)
            == (rctx->sender_addr & awaiter->sender.mask)) {
  402204:	b9401044 	ldr	w4, [x2, #16]
        if ((awaiter->sender.id & awaiter->sender.mask)
  402208:	f9400423 	ldr	x3, [x1, #8]
  40220c:	d360f060 	ubfx	x0, x3, #32, #29
  402210:	0a030003 	and	w3, w0, w3
            == (rctx->sender_addr & awaiter->sender.mask)) {
  402214:	0a040000 	and	w0, w0, w4
        if ((awaiter->sender.id & awaiter->sender.mask)
  402218:	6b00007f 	cmp	w3, w0
  40221c:	54000181 	b.ne	40224c <notify_waiting_receiver+0x58>  // b.any
            LOG_DBG("Matched waiting receiver %x:%x to sender %x", awaiter->sender.id,
                    awaiter->sender.mask, rctx->sender_addr);
            awaiter->rctx = rctx;
  402220:	f9002022 	str	x2, [x1, #64]
            rctx->pending = true;
  402224:	52800020 	mov	w0, #0x1                   	// #1
  402228:	39093c40 	strb	w0, [x2, #591]
/**
 * @internal
 */
static inline unsigned int z_impl_k_sem_count_get(struct k_sem *sem)
{
	return sem->count;
  40222c:	91006020 	add	x0, x1, #0x18
            if (k_sem_count_get(&awaiter->sem) == 0) {
  402230:	b9401001 	ldr	w1, [x0, #16]
  402234:	35000041 	cbnz	w1, 40223c <notify_waiting_receiver+0x48>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
  402238:	1400357e 	b	40f830 <z_impl_k_sem_give>
                k_sem_give(&awaiter->sem);
            }
            else if (rctx->error) {
  40223c:	39c92c40 	ldrsb	w0, [x2, #587]
  402240:	340000a0 	cbz	w0, 402254 <notify_waiting_receiver+0x60>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MSGQ_PURGE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_msgq_purge(msgq);
  402244:	91028040 	add	x0, x2, #0xa0
  402248:	1400330e 	b	40ee80 <z_impl_k_msgq_purge>
	return node->next;
  40224c:	f9400021 	ldr	x1, [x1]
    SYS_SLIST_FOR_EACH_CONTAINER(&rctx->ctx->wait_recv_list, awaiter, node)
  402250:	b5fffdc1 	cbnz	x1, 402208 <notify_waiting_receiver+0x14>
            return;
        }
    }

    LOG_DBG("No matching receiver for sender %x", rctx->sender_addr);
}
  402254:	d65f03c0 	ret

0000000000402258 <can_bytes_to_dlc>:
	       num_bytes <= 20 ? 11 :
	       num_bytes <= 24 ? 12 :
	       num_bytes <= 32 ? 13 :
	       num_bytes <= 48 ? 14 :
	       15;
}
  402258:	d65f03c0 	ret

000000000040225c <z_log_msg_runtime_create.constprop.0>:
 *
 * @param fmt String.
 *
 * @param ... String arguments.
 */
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40225c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  402260:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  402264:	12001c42 	and	w2, w2, #0xff
  402268:	910003fd 	mov	x29, sp
  40226c:	f9476800 	ldr	x0, [x0, #3792]
  402270:	3d8023e0 	str	q0, [sp, #128]
  402274:	3d8027e1 	str	q1, [sp, #144]
  402278:	3d802be2 	str	q2, [sp, #160]
  40227c:	3d802fe3 	str	q3, [sp, #176]
  402280:	3d8033e4 	str	q4, [sp, #192]
  402284:	3d8037e5 	str	q5, [sp, #208]
  402288:	3d803be6 	str	q6, [sp, #224]
  40228c:	3d803fe7 	str	q7, [sp, #240]
  402290:	f90087e7 	str	x7, [sp, #264]
  402294:	f9400003 	ldr	x3, [x0]
  402298:	f9003fe3 	str	x3, [sp, #120]
  40229c:	d2800003 	mov	x3, #0x0                   	// #0
					     size_t dlen, uint32_t package_flags,
					     const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
  4022a0:	910443e0 	add	x0, sp, #0x110
  4022a4:	a90383e0 	stp	x0, x0, [sp, #56]
  4022a8:	910403e0 	add	x0, sp, #0x100
  4022ac:	9100e3e3 	add	x3, sp, #0x38
  4022b0:	f90027e0 	str	x0, [sp, #72]
  4022b4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  4022b8:	b90053e0 	str	w0, [sp, #80]
  4022bc:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  4022c0:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  4022c4:	910163e0 	add	x0, sp, #0x58
  4022c8:	ad400460 	ldp	q0, q1, [x3]
  4022cc:	ad000400 	stp	q0, q1, [x0]
		va_end(parm7.val);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_runtime_vcreate(domain_id, source, level, data, dlen, package_flags, fmt, ap);
  4022d0:	ad400400 	ldp	q0, q1, [x0]
  4022d4:	910043e7 	add	x7, sp, #0x10
  4022d8:	52800000 	mov	w0, #0x0                   	// #0
  4022dc:	52800005 	mov	w5, #0x0                   	// #0
  4022e0:	d2800004 	mov	x4, #0x0                   	// #0
  4022e4:	d2800003 	mov	x3, #0x0                   	// #0
  4022e8:	ad0004e0 	stp	q0, q1, [x7]
  4022ec:	94001868 	bl	40848c <z_impl_z_log_msg_runtime_vcreate>
				   data, dlen, package_flags, fmt, ap);
	va_end(ap);
}
  4022f0:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4022f4:	f9476800 	ldr	x0, [x0, #3792]
  4022f8:	f9403fe2 	ldr	x2, [sp, #120]
  4022fc:	f9400001 	ldr	x1, [x0]
  402300:	eb010042 	subs	x2, x2, x1
  402304:	d2800001 	mov	x1, #0x0                   	// #0
  402308:	54000040 	b.eq	402310 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40230c:	97fffc05 	bl	401320 <__stack_chk_fail@plt>
  402310:	a8d17bfd 	ldp	x29, x30, [sp], #272
  402314:	d65f03c0 	ret

0000000000402318 <send_timeout_handler>:

    send_state_machine(sctx);
}

static void send_timeout_handler(struct k_timer *timer)
{
  402318:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40231c:	910003fd 	mov	x29, sp
  402320:	f9000bf3 	str	x19, [sp, #16]
  402324:	aa0003f3 	mov	x19, x0
    struct isotp_fast_send_ctx *sctx = CONTAINER_OF(timer, struct isotp_fast_send_ctx, timer);

    if (sctx->state != ISOTP_TX_SEND_CF) {
  402328:	f9404400 	ldr	x0, [x0, #136]
  40232c:	530c4c00 	ubfx	w0, w0, #12, #8
  402330:	7100101f 	cmp	w0, #0x4
  402334:	54000240 	b.eq	40237c <send_timeout_handler+0x64>  // b.none
        LOG_ERR("Timed out waiting for FC frame");
  402338:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40233c:	52800000 	mov	w0, #0x0                   	// #0
  402340:	b0000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  402344:	52800005 	mov	w5, #0x0                   	// #0
  402348:	f9478821 	ldr	x1, [x1, #3856]
  40234c:	912094c6 	add	x6, x6, #0x825
  402350:	d2800004 	mov	x4, #0x0                   	// #0
  402354:	d2800003 	mov	x3, #0x0                   	// #0
  402358:	52800022 	mov	w2, #0x1                   	// #1
  40235c:	97ffffc0 	bl	40225c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  402360:	b9408a61 	ldr	w1, [x19, #136]
  402364:	52900000 	mov	w0, #0x8000                	// #32768
  402368:	72bfc000 	movk	w0, #0xfe00, lsl #16
  40236c:	12005c21 	and	w1, w1, #0xffffff
  402370:	120c5c21 	and	w1, w1, #0xfff00fff
  402374:	2a000021 	orr	w1, w1, w0
  402378:	b9008a61 	str	w1, [x19, #136]
        send_report_error(sctx, ISOTP_N_TIMEOUT_BS);
    }

    k_work_submit(&sctx->work);
  40237c:	d1008260 	sub	x0, x19, #0x20
}
  402380:	f9400bf3 	ldr	x19, [sp, #16]
  402384:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&sctx->work);
  402388:	140037ac 	b	410238 <k_work_submit>

000000000040238c <receive_can_tx>:
    if (error != 0) {
  40238c:	34000361 	cbz	w1, 4023f8 <receive_can_tx+0x6c>
{
  402390:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402394:	2a0103e7 	mov	w7, w1
        LOG_ERR("Error sending FC frame (%d)", error);
  402398:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
{
  40239c:	910003fd 	mov	x29, sp
        LOG_ERR("Error sending FC frame (%d)", error);
  4023a0:	f9478821 	ldr	x1, [x1, #3856]
{
  4023a4:	f9000bf3 	str	x19, [sp, #16]
  4023a8:	aa0203f3 	mov	x19, x2
        LOG_ERR("Error sending FC frame (%d)", error);
  4023ac:	52800005 	mov	w5, #0x0                   	// #0
  4023b0:	d2800004 	mov	x4, #0x0                   	// #0
  4023b4:	d2800003 	mov	x3, #0x0                   	// #0
  4023b8:	52800000 	mov	w0, #0x0                   	// #0
  4023bc:	52800022 	mov	w2, #0x1                   	// #1
  4023c0:	b0000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  4023c4:	912110c6 	add	x6, x6, #0x844
  4023c8:	97ffffa5 	bl	40225c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  4023cc:	b9424a61 	ldr	w1, [x19, #584]
  4023d0:	528e0000 	mov	w0, #0x7000                	// #28672
  4023d4:	72bee000 	movk	w0, #0xf700, lsl #16
  4023d8:	12005c21 	and	w1, w1, #0xffffff
  4023dc:	120c5c21 	and	w1, w1, #0xfff00fff
  4023e0:	2a000021 	orr	w1, w1, w0
  4023e4:	b9024a61 	str	w1, [x19, #584]
        k_work_submit(&rctx->work);
  4023e8:	91006260 	add	x0, x19, #0x18
}
  4023ec:	f9400bf3 	ldr	x19, [sp, #16]
  4023f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
        k_work_submit(&rctx->work);
  4023f4:	14003791 	b	410238 <k_work_submit>
  4023f8:	d65f03c0 	ret

00000000004023fc <receive_timeout_handler>:
{
  4023fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402400:	910003fd 	mov	x29, sp
  402404:	f9000bf3 	str	x19, [sp, #16]
  402408:	aa0003f3 	mov	x19, x0
    switch (rctx->state) {
  40240c:	f9410800 	ldr	x0, [x0, #528]
  402410:	530c4c00 	ubfx	w0, w0, #12, #8
  402414:	71000c1f 	cmp	w0, #0x3
  402418:	54000300 	b.eq	402478 <receive_timeout_handler+0x7c>  // b.none
  40241c:	7100141f 	cmp	w0, #0x5
  402420:	54000241 	b.ne	402468 <receive_timeout_handler+0x6c>  // b.any
            LOG_ERR("Timeout while waiting for CF");
  402424:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  402428:	52800000 	mov	w0, #0x0                   	// #0
  40242c:	b0000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  402430:	52800005 	mov	w5, #0x0                   	// #0
  402434:	f9478821 	ldr	x1, [x1, #3856]
  402438:	912180c6 	add	x6, x6, #0x860
  40243c:	d2800004 	mov	x4, #0x0                   	// #0
  402440:	d2800003 	mov	x3, #0x0                   	// #0
  402444:	52800022 	mov	w2, #0x1                   	// #1
  402448:	97ffff85 	bl	40225c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  40244c:	b9421260 	ldr	w0, [x19, #528]
  402450:	528e0001 	mov	w1, #0x7000                	// #28672
  402454:	72bfa001 	movk	w1, #0xfd00, lsl #16
  402458:	12005c00 	and	w0, w0, #0xffffff
  40245c:	120c5c00 	and	w0, w0, #0xfff00fff
  402460:	2a010000 	orr	w0, w0, w1
  402464:	b9021260 	str	w0, [x19, #528]
    k_work_submit(&rctx->work);
  402468:	d1008260 	sub	x0, x19, #0x20
}
  40246c:	f9400bf3 	ldr	x19, [sp, #16]
  402470:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&rctx->work);
  402474:	14003771 	b	410238 <k_work_submit>
            rctx->state = ISOTP_RX_STATE_SEND_WAIT;
  402478:	79442260 	ldrh	w0, [x19, #528]
  40247c:	91084261 	add	x1, x19, #0x210
  402480:	12002c00 	and	w0, w0, #0xfff
  402484:	32130400 	orr	w0, w0, #0x6000
  402488:	79042260 	strh	w0, [x19, #528]
  40248c:	aa0103e0 	mov	x0, x1
  402490:	39400821 	ldrb	w1, [x1, #2]
  402494:	121c6c21 	and	w1, w1, #0xfffffff0
  402498:	39000801 	strb	w1, [x0, #2]
            break;
  40249c:	17fffff3 	b	402468 <receive_timeout_handler+0x6c>

00000000004024a0 <sys_slist_find_and_remove.isra.0>:
	return list->head;
  4024a0:	f9400002 	ldr	x2, [x0]
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  4024a4:	d2800003 	mov	x3, #0x0                   	// #0
  4024a8:	b4000162 	cbz	x2, 4024d4 <sys_slist_find_and_remove.isra.0+0x34>
  4024ac:	eb01005f 	cmp	x2, x1
  4024b0:	54000201 	b.ne	4024f0 <sys_slist_find_and_remove.isra.0+0x50>  // b.any
	return node->next;
  4024b4:	f9400022 	ldr	x2, [x1]
Z_GENLIST_REMOVE(slist, snode)
  4024b8:	b5000103 	cbnz	x3, 4024d8 <sys_slist_find_and_remove.isra.0+0x38>
  4024bc:	f9400403 	ldr	x3, [x0, #8]
	list->head = node;
  4024c0:	f9000002 	str	x2, [x0]
Z_GENLIST_REMOVE(slist, snode)
  4024c4:	eb03003f 	cmp	x1, x3
  4024c8:	54000041 	b.ne	4024d0 <sys_slist_find_and_remove.isra.0+0x30>  // b.any
	list->tail = node;
  4024cc:	f9000402 	str	x2, [x0, #8]
	parent->next = child;
  4024d0:	f900003f 	str	xzr, [x1]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  4024d4:	d65f03c0 	ret
	parent->next = child;
  4024d8:	f9000062 	str	x2, [x3]
Z_GENLIST_REMOVE(slist, snode)
  4024dc:	f9400402 	ldr	x2, [x0, #8]
  4024e0:	eb02003f 	cmp	x1, x2
  4024e4:	54ffff61 	b.ne	4024d0 <sys_slist_find_and_remove.isra.0+0x30>  // b.any
	list->tail = node;
  4024e8:	f9000403 	str	x3, [x0, #8]
}
  4024ec:	17fffff9 	b	4024d0 <sys_slist_find_and_remove.isra.0+0x30>
	return node->next;
  4024f0:	aa0203e3 	mov	x3, x2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  4024f4:	f9400042 	ldr	x2, [x2]
  4024f8:	17ffffec 	b	4024a8 <sys_slist_find_and_remove.isra.0+0x8>

00000000004024fc <free_send_ctx>:
{
  4024fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402500:	910003fd 	mov	x29, sp
  402504:	f9000bf3 	str	x19, [sp, #16]
  402508:	aa0003f3 	mov	x19, x0
    k_timer_stop(&(*ctx)->timer);
  40250c:	f9400000 	ldr	x0, [x0]
  402510:	9100e000 	add	x0, x0, #0x38
  402514:	97ffff37 	bl	4021f0 <k_timer_stop>
    sys_slist_find_and_remove(&isotp_send_ctx_list, &(*ctx)->node);
  402518:	f9400261 	ldr	x1, [x19]
  40251c:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  402520:	912b4000 	add	x0, x0, #0xad0
  402524:	97ffffdf 	bl	4024a0 <sys_slist_find_and_remove.isra.0>
    k_mem_slab_free(&isotp_send_ctx_slab, (void **)ctx);
  402528:	aa1303e1 	mov	x1, x19
  40252c:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
}
  402530:	f9400bf3 	ldr	x19, [sp, #16]
  402534:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_send_ctx_slab, (void **)ctx);
  402538:	f947f000 	ldr	x0, [x0, #4064]
  40253c:	14002f3e 	b	40e234 <k_mem_slab_free>

0000000000402540 <send_can_tx_callback>:
{
  402540:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402544:	910003fd 	mov	x29, sp
    sctx->backlog--;
  402548:	39434c40 	ldrb	w0, [x2, #211]
{
  40254c:	f9000bf3 	str	x19, [sp, #16]
  402550:	aa0203f3 	mov	x19, x2
    sctx->backlog--;
  402554:	51000400 	sub	w0, w0, #0x1
  402558:	39034c40 	strb	w0, [x2, #211]
	z_impl_k_sem_give(sem);
  40255c:	91024040 	add	x0, x2, #0x90
  402560:	940034b4 	bl	40f830 <z_impl_k_sem_give>
    if (sctx->state == ISOTP_TX_WAIT_BACKLOG) {
  402564:	f9406260 	ldr	x0, [x19, #192]
  402568:	530c4c00 	ubfx	w0, w0, #12, #8
  40256c:	7100181f 	cmp	w0, #0x6
  402570:	54000181 	b.ne	4025a0 <send_can_tx_callback+0x60>  // b.any
        if (sctx->backlog > 0) {
  402574:	39434e60 	ldrb	w0, [x19, #211]
  402578:	350001c0 	cbnz	w0, 4025b0 <send_can_tx_callback+0x70>
        sctx->state = ISOTP_TX_WAIT_FIN;
  40257c:	79418260 	ldrh	w0, [x19, #192]
  402580:	91030261 	add	x1, x19, #0xc0
  402584:	12002c00 	and	w0, w0, #0xfff
  402588:	32140800 	orr	w0, w0, #0x7000
  40258c:	79018260 	strh	w0, [x19, #192]
  402590:	aa0103e0 	mov	x0, x1
  402594:	39400821 	ldrb	w1, [x1, #2]
  402598:	121c6c21 	and	w1, w1, #0xfffffff0
  40259c:	39000801 	strb	w1, [x0, #2]
    k_work_submit(&sctx->work);
  4025a0:	91006260 	add	x0, x19, #0x18
}
  4025a4:	f9400bf3 	ldr	x19, [sp, #16]
  4025a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&sctx->work);
  4025ac:	14003723 	b	410238 <k_work_submit>
}
  4025b0:	f9400bf3 	ldr	x19, [sp, #16]
  4025b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4025b8:	d65f03c0 	ret

00000000004025bc <free_recv_ctx>:
{
  4025bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4025c0:	910003fd 	mov	x29, sp
  4025c4:	f9000bf3 	str	x19, [sp, #16]
  4025c8:	aa0003f3 	mov	x19, x0
    k_timer_stop(&(*rctx)->timer);
  4025cc:	f9400000 	ldr	x0, [x0]
  4025d0:	9100e000 	add	x0, x0, #0x38
  4025d4:	97ffff07 	bl	4021f0 <k_timer_stop>
    sys_slist_find_and_remove(&isotp_recv_ctx_list, &(*rctx)->node);
  4025d8:	f9400261 	ldr	x1, [x19]
  4025dc:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  4025e0:	912b0000 	add	x0, x0, #0xac0
  4025e4:	97ffffaf 	bl	4024a0 <sys_slist_find_and_remove.isra.0>
    net_buf_unref((*rctx)->buffer);
  4025e8:	f9400260 	ldr	x0, [x19]
  4025ec:	f9404800 	ldr	x0, [x0, #144]
  4025f0:	940028ce 	bl	40c928 <net_buf_unref>
    k_msgq_purge(&(*rctx)->recv_queue);
  4025f4:	f9400260 	ldr	x0, [x19]
  4025f8:	91028000 	add	x0, x0, #0xa0
	z_impl_k_msgq_purge(msgq);
  4025fc:	94003221 	bl	40ee80 <z_impl_k_msgq_purge>
    k_msgq_cleanup(&(*rctx)->recv_queue);
  402600:	f9400260 	ldr	x0, [x19]
  402604:	91028000 	add	x0, x0, #0xa0
  402608:	940030b6 	bl	40e8e0 <k_msgq_cleanup>
    k_mem_slab_free(&isotp_recv_ctx_slab, (void **)rctx);
  40260c:	aa1303e1 	mov	x1, x19
  402610:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
}
  402614:	f9400bf3 	ldr	x19, [sp, #16]
  402618:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_recv_ctx_slab, (void **)rctx);
  40261c:	f9479c00 	ldr	x0, [x0, #3896]
  402620:	14002f05 	b	40e234 <k_mem_slab_free>

0000000000402624 <free_recv_await_ctx>:
    return ISOTP_N_OK;
}

#ifdef CONFIG_ISOTP_FAST_BLOCKING_RECEIVE
static void free_recv_await_ctx(struct isotp_fast_ctx *ctx, struct isotp_fast_recv_await_ctx **actx)
{
  402624:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    sys_slist_find_and_remove(&ctx->wait_recv_list, &(*actx)->node);
  402628:	91010000 	add	x0, x0, #0x40
{
  40262c:	910003fd 	mov	x29, sp
  402630:	f9000bf3 	str	x19, [sp, #16]
  402634:	aa0103f3 	mov	x19, x1
    sys_slist_find_and_remove(&ctx->wait_recv_list, &(*actx)->node);
  402638:	f9400021 	ldr	x1, [x1]
  40263c:	97ffff99 	bl	4024a0 <sys_slist_find_and_remove.isra.0>
    if ((*actx)->rctx) {
  402640:	f9400260 	ldr	x0, [x19]
  402644:	f9402001 	ldr	x1, [x0, #64]
  402648:	b4000061 	cbz	x1, 402654 <free_recv_await_ctx+0x30>
        free_recv_ctx(&(*actx)->rctx);
  40264c:	91010000 	add	x0, x0, #0x40
  402650:	97ffffdb 	bl	4025bc <free_recv_ctx>
    }
    k_mem_slab_free(&isotp_recv_await_ctx_slab, (void **)actx);
  402654:	aa1303e1 	mov	x1, x19
  402658:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
}
  40265c:	f9400bf3 	ldr	x19, [sp, #16]
  402660:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_recv_await_ctx_slab, (void **)actx);
  402664:	f947b800 	ldr	x0, [x0, #3952]
  402668:	14002ef3 	b	40e234 <k_mem_slab_free>

000000000040266c <send_work_handler>:
{
  40266c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  402670:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  402674:	910003fd 	mov	x29, sp
  402678:	f9476821 	ldr	x1, [x1, #3792]
  40267c:	a90153f3 	stp	x19, x20, [sp, #16]
    struct isotp_fast_send_ctx *sctx = CONTAINER_OF(work, struct isotp_fast_send_ctx, work);
  402680:	d1006013 	sub	x19, x0, #0x18
{
  402684:	a9025bf5 	stp	x21, x22, [sp, #32]
  402688:	a90363f7 	stp	x23, x24, [sp, #48]
  40268c:	a9046bf9 	stp	x25, x26, [sp, #64]
  402690:	a90573fb 	stp	x27, x28, [sp, #80]
  402694:	f9400022 	ldr	x2, [x1]
  402698:	f9003fe2 	str	x2, [sp, #120]
  40269c:	d2800002 	mov	x2, #0x0                   	// #0
    send_state_machine(sctx);
  4026a0:	f90033f3 	str	x19, [sp, #96]
    switch (sctx->state) {
  4026a4:	f9406261 	ldr	x1, [x19, #192]
  4026a8:	530c4c21 	ubfx	w1, w1, #12, #8
  4026ac:	51000821 	sub	w1, w1, #0x2
  4026b0:	7100183f 	cmp	w1, #0x6
  4026b4:	54001de8 	b.hi	402a70 <send_work_handler+0x404>  // b.pmore
  4026b8:	b0000082 	adrp	x2, 413000 <sys_clock_announce+0x19c>
  4026bc:	911e4042 	add	x2, x2, #0x790
  4026c0:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  4026c4:	10000061 	adr	x1, 4026d0 <send_work_handler+0x64>
  4026c8:	8b22a822 	add	x2, x1, w2, sxth #2
  4026cc:	d61f0040 	br	x2
    frame->id = addr;
  4026d0:	b9401262 	ldr	w2, [x19, #16]
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  4026d4:	52800119 	mov	w25, #0x8                   	// #8
    frame->id = addr;
  4026d8:	b9406be1 	ldr	w1, [sp, #104]

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len,
  4026dc:	d28000c3 	mov	x3, #0x6                   	// #6
    prepare_frame(&frame, sctx->ctx, sctx->recipient_addr);
  4026e0:	f9400678 	ldr	x24, [x19, #8]
    frame->id = addr;
  4026e4:	33007041 	bfxil	w1, w2, #0, #29
  4026e8:	b9006be1 	str	w1, [sp, #104]
    uint16_t len = sctx->rem_len;
  4026ec:	a94b8276 	ldp	x22, x0, [x19, #184]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  4026f0:	f9400b01 	ldr	x1, [x24, #16]
  4026f4:	39400821 	ldrb	w1, [x1, #2]
    uint16_t len = sctx->rem_len;
  4026f8:	12002c14 	and	w20, w0, #0xfff
  4026fc:	d3402c15 	ubfx	x21, x0, #0, #12
        frame.data[index++] = ISOTP_PCI_TYPE_FF | (len >> 8);
  402700:	53082c00 	ubfx	w0, w0, #8, #4
  402704:	321c0000 	orr	w0, w0, #0x10
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402708:	7100229f 	cmp	w20, #0x8
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  40270c:	d341fc21 	lsr	x1, x1, #1
        frame.data[index++] = ISOTP_PCI_TYPE_FF | (len >> 8);
  402710:	3901c3e0 	strb	w0, [sp, #112]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402714:	121e0021 	and	w1, w1, #0x4
    sctx->sn = 1;
  402718:	39434a60 	ldrb	w0, [x19, #210]
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  40271c:	1a9992b5 	csel	w21, w21, w25, ls  // ls = plast
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402720:	32000021 	orr	w1, w1, #0x1
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402724:	12003eb5 	and	w21, w21, #0xffff
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402728:	3901b7e1 	strb	w1, [sp, #109]
    sctx->sn = 1;
  40272c:	52800021 	mov	w1, #0x1                   	// #1
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402730:	51000ab7 	sub	w23, w21, #0x2
    sctx->sn = 1;
  402734:	33000c20 	bfxil	w0, w1, #0, #4
  402738:	39034a60 	strb	w0, [x19, #210]
    memcpy(&frame.data[index], sctx->data, size);
  40273c:	92403ef7 	and	x23, x23, #0xffff
  402740:	aa1603e1 	mov	x1, x22
  402744:	aa1703e2 	mov	x2, x23
  402748:	9101cbe0 	add	x0, sp, #0x72
        frame.data[index++] = len & 0xFF;
  40274c:	3901c7f4 	strb	w20, [sp, #113]
  402750:	97fffac0 	bl	401250 <__memcpy_chk@plt>
    sctx->rem_len -= size;
  402754:	79418260 	ldrh	w0, [x19, #192]
  402758:	11000a94 	add	w20, w20, #0x2
  40275c:	4b150294 	sub	w20, w20, w21
    sctx->data += size;
  402760:	8b1702d6 	add	x22, x22, x23
    frame.dlc = can_bytes_to_dlc(CAN_MAX_DLEN);
  402764:	3901b3f9 	strb	w25, [sp, #108]
    sctx->rem_len -= size;
  402768:	33002e80 	bfxil	w0, w20, #0, #12
    sctx->data += size;
  40276c:	f9005e76 	str	x22, [x19, #184]
    sctx->rem_len -= size;
  402770:	79018260 	strh	w0, [x19, #192]
    ret = can_send(sctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), send_can_tx_callback,
  402774:	f9400300 	ldr	x0, [x24]
		union { uintptr_t x; void * val; } parm4 = { .val = user_data };
		return (int) arch_syscall_invoke5(parm0.x, parm1.x, parm2.x, parm3.x, parm4.x, K_SYSCALL_CAN_SEND);
	}
#endif
	compiler_barrier();
	return z_impl_can_send(dev, frame, timeout, callback, user_data);
  402778:	d2800c82 	mov	x2, #0x64                  	// #100
  40277c:	aa1303e4 	mov	x4, x19
  402780:	9101a3e1 	add	x1, sp, #0x68
  402784:	90000003 	adrp	x3, 402000 <__floatunditf+0x60>
  402788:	91150063 	add	x3, x3, #0x540
  40278c:	94002944 	bl	40cc9c <z_impl_can_send>
            k_timer_start(&sctx->timer, K_MSEC(ISOTP_BS_TIMEOUT_MS), K_NO_WAIT);
  402790:	f94033e0 	ldr	x0, [sp, #96]
  402794:	9100e000 	add	x0, x0, #0x38
	z_impl_k_timer_start(timer, duration, period);
  402798:	d2800002 	mov	x2, #0x0                   	// #0
  40279c:	d2800c81 	mov	x1, #0x64                  	// #100
  4027a0:	94004316 	bl	4133f8 <z_impl_k_timer_start>
                    sctx->state = ISOTP_TX_WAIT_FC;
  4027a4:	f94033e1 	ldr	x1, [sp, #96]
  4027a8:	79418020 	ldrh	w0, [x1, #192]
  4027ac:	12002c00 	and	w0, w0, #0xfff
  4027b0:	32140400 	orr	w0, w0, #0x3000
  4027b4:	14000047 	b	4028d0 <send_work_handler+0x264>
  4027b8:	90000015 	adrp	x21, 402000 <__floatunditf+0x60>
  4027bc:	9101a3f7 	add	x23, sp, #0x68
  4027c0:	9101c7f8 	add	x24, sp, #0x71
  4027c4:	911502b5 	add	x21, x21, #0x540
    len = MIN(sctx->rem_len, CAN_MAX_DLEN - index);
  4027c8:	528000f6 	mov	w22, #0x7                   	// #7
            k_timer_stop(&sctx->timer);
  4027cc:	91008000 	add	x0, x0, #0x20
  4027d0:	97fffe88 	bl	4021f0 <k_timer_stop>
                ret = send_cf(sctx);
  4027d4:	f94033f3 	ldr	x19, [sp, #96]
  4027d8:	d28000e3 	mov	x3, #0x7                   	// #7
    frame->id = addr;
  4027dc:	b9406be0 	ldr	w0, [sp, #104]
  4027e0:	b9401261 	ldr	w1, [x19, #16]
    prepare_frame(&frame, sctx->ctx, sctx->recipient_addr);
  4027e4:	f940067b 	ldr	x27, [x19, #8]
    frame->id = addr;
  4027e8:	33007020 	bfxil	w0, w1, #0, #29
  4027ec:	b9006be0 	str	w0, [sp, #104]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  4027f0:	f9400b60 	ldr	x0, [x27, #16]
  4027f4:	39400800 	ldrb	w0, [x0, #2]
  4027f8:	d341fc00 	lsr	x0, x0, #1
  4027fc:	121e0000 	and	w0, w0, #0x4
  402800:	32000000 	orr	w0, w0, #0x1
  402804:	3901b7e0 	strb	w0, [sp, #109]
    frame.data[index++] = ISOTP_PCI_TYPE_CF | sctx->sn;
  402808:	f9406a60 	ldr	x0, [x19, #208]
  40280c:	d3504c00 	ubfx	x0, x0, #16, #4
  402810:	321b0000 	orr	w0, w0, #0x20
  402814:	3901c3e0 	strb	w0, [sp, #112]
  402818:	aa1803e0 	mov	x0, x24
    len = MIN(sctx->rem_len, CAN_MAX_DLEN - index);
  40281c:	a94bd27a 	ldp	x26, x20, [x19, #184]
  402820:	12002e94 	and	w20, w20, #0xfff
  402824:	aa1a03e1 	mov	x1, x26
  402828:	71001e9f 	cmp	w20, #0x7
  40282c:	1a969299 	csel	w25, w20, w22, ls  // ls = plast
    memcpy(&frame.data[index], sctx->data, len);
  402830:	2a1903fc 	mov	w28, w25
    sctx->rem_len -= len;
  402834:	4b190294 	sub	w20, w20, w25
  402838:	aa1c03e2 	mov	x2, x28
  40283c:	97fffa85 	bl	401250 <__memcpy_chk@plt>
  402840:	79418260 	ldrh	w0, [x19, #192]
    sctx->data += len;
  402844:	8b1c035a 	add	x26, x26, x28
  402848:	f9005e7a 	str	x26, [x19, #184]
    sctx->rem_len -= len;
  40284c:	33002e80 	bfxil	w0, w20, #0, #12
  402850:	79018260 	strh	w0, [x19, #192]
    frame.dlc = can_bytes_to_dlc(len + index);
  402854:	11000720 	add	w0, w25, #0x1
  402858:	97fffe80 	bl	402258 <can_bytes_to_dlc>
  40285c:	3901b3e0 	strb	w0, [sp, #108]
    ret = can_send(sctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), send_can_tx_callback,
  402860:	f9400360 	ldr	x0, [x27]
  402864:	d2800c82 	mov	x2, #0x64                  	// #100
  402868:	aa1303e4 	mov	x4, x19
  40286c:	aa1503e3 	mov	x3, x21
  402870:	aa1703e1 	mov	x1, x23
  402874:	9400290a 	bl	40cc9c <z_impl_can_send>
  402878:	2a0003f4 	mov	w20, w0
    if (ret == 0) {
  40287c:	7100001f 	cmp	w0, #0x0
  402880:	35000ca0 	cbnz	w0, 402a14 <send_work_handler+0x3a8>
        sctx->sn++;
  402884:	f9406a60 	ldr	x0, [x19, #208]
  402888:	39434a61 	ldrb	w1, [x19, #210]
  40288c:	d3504c00 	ubfx	x0, x0, #16, #4
  402890:	11000400 	add	w0, w0, #0x1
  402894:	33000c01 	bfxil	w1, w0, #0, #4
        sctx->bs--;
  402898:	39434660 	ldrb	w0, [x19, #209]
        sctx->sn++;
  40289c:	39034a61 	strb	w1, [x19, #210]
        sctx->bs--;
  4028a0:	51000400 	sub	w0, w0, #0x1
  4028a4:	39034660 	strb	w0, [x19, #209]
        sctx->backlog++;
  4028a8:	39434e60 	ldrb	w0, [x19, #211]
  4028ac:	11000400 	add	w0, w0, #0x1
  4028b0:	39034e60 	strb	w0, [x19, #211]
    ret = ret ? ret : sctx->rem_len;
  4028b4:	f9406260 	ldr	x0, [x19, #192]
                if (!ret) {
  4028b8:	f2402c1f 	tst	x0, #0xfff
  4028bc:	54000141 	b.ne	4028e4 <send_work_handler+0x278>  // b.any
                    sctx->state = ISOTP_TX_WAIT_BACKLOG;
  4028c0:	f94033e1 	ldr	x1, [sp, #96]
  4028c4:	79418020 	ldrh	w0, [x1, #192]
  4028c8:	12002c00 	and	w0, w0, #0xfff
  4028cc:	32130400 	orr	w0, w0, #0x6000
            sctx->state = ISOTP_TX_SEND_CF;
  4028d0:	79018020 	strh	w0, [x1, #192]
  4028d4:	39430820 	ldrb	w0, [x1, #194]
  4028d8:	121c6c00 	and	w0, w0, #0xfffffff0
  4028dc:	39030820 	strb	w0, [x1, #194]
            break;
  4028e0:	14000064 	b	402a70 <send_work_handler+0x404>
                if (sctx->ctx->opts->bs && !sctx->bs) {
  4028e4:	f94033e0 	ldr	x0, [sp, #96]
  4028e8:	f9400401 	ldr	x1, [x0, #8]
  4028ec:	f9400821 	ldr	x1, [x1, #16]
  4028f0:	39400021 	ldrb	w1, [x1]
  4028f4:	340000e1 	cbz	w1, 402910 <send_work_handler+0x2a4>
  4028f8:	39434401 	ldrb	w1, [x0, #209]
  4028fc:	350000a1 	cbnz	w1, 402910 <send_work_handler+0x2a4>
  402900:	d2800002 	mov	x2, #0x0                   	// #0
  402904:	9100e000 	add	x0, x0, #0x38
  402908:	d2800c81 	mov	x1, #0x64                  	// #100
  40290c:	17ffffa5 	b	4027a0 <send_work_handler+0x134>
                else if (sctx->stmin) {
  402910:	39435001 	ldrb	w1, [x0, #212]
  402914:	34000161 	cbz	w1, 402940 <send_work_handler+0x2d4>
                    sctx->state = ISOTP_TX_WAIT_ST;
  402918:	79418001 	ldrh	w1, [x0, #192]
  40291c:	91030002 	add	x2, x0, #0xc0
  402920:	528a0003 	mov	w3, #0x5000                	// #20480
  402924:	12002c21 	and	w1, w1, #0xfff
  402928:	2a030021 	orr	w1, w1, w3
  40292c:	79018001 	strh	w1, [x0, #192]
  402930:	39430800 	ldrb	w0, [x0, #194]
  402934:	121c6c00 	and	w0, w0, #0xfffffff0
  402938:	39000840 	strb	w0, [x2, #2]
                    break;
  40293c:	1400004d 	b	402a70 <send_work_handler+0x404>
	return z_impl_k_sem_take(sem, timeout);
  402940:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  402944:	91024000 	add	x0, x0, #0x90
  402948:	940033f1 	bl	40f90c <z_impl_k_sem_take>
            } while (ret > 0);
  40294c:	17ffffa2 	b	4027d4 <send_work_handler+0x168>
            k_timer_start(&sctx->timer, stmin_to_timeout(sctx->stmin), K_NO_WAIT);
  402950:	39435261 	ldrb	w1, [x19, #212]
  402954:	91008000 	add	x0, x0, #0x20
    if (stmin > ISOTP_STMIN_MAX || (stmin > ISOTP_STMIN_MS_MAX && stmin < ISOTP_STMIN_US_BEGIN)) {
  402958:	51020022 	sub	w2, w1, #0x80
  40295c:	12001c42 	and	w2, w2, #0xff
  402960:	7101c05f 	cmp	w2, #0x70
  402964:	52801f42 	mov	w2, #0xfa                  	// #250
  402968:	7a428022 	ccmp	w1, w2, #0x2, hi  // hi = pmore
  40296c:	540001c8 	b.hi	4029a4 <send_work_handler+0x338>  // b.pmore
    if (stmin >= ISOTP_STMIN_US_BEGIN) {
  402970:	7103c03f 	cmp	w1, #0xf0
  402974:	540001c8 	b.hi	4029ac <send_work_handler+0x340>  // b.pmore
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
  402978:	11002421 	add	w1, w1, #0x9
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
  40297c:	d2800142 	mov	x2, #0xa                   	// #10
		t += off;
  402980:	92401c21 	and	x1, x1, #0xff
			return t / ((uint64_t)from_hz / to_hz);
  402984:	9ac20821 	udiv	x1, x1, x2
	z_impl_k_timer_start(timer, duration, period);
  402988:	d2800002 	mov	x2, #0x0                   	// #0
  40298c:	9400429b 	bl	4133f8 <z_impl_k_timer_start>
            sctx->state = ISOTP_TX_SEND_CF;
  402990:	f94033e1 	ldr	x1, [sp, #96]
  402994:	79418020 	ldrh	w0, [x1, #192]
  402998:	12002c00 	and	w0, w0, #0xfff
  40299c:	32120000 	orr	w0, w0, #0x4000
  4029a0:	17ffffcc 	b	4028d0 <send_work_handler+0x264>
        return K_MSEC(ISOTP_STMIN_MS_MAX);
  4029a4:	d28001a1 	mov	x1, #0xd                   	// #13
  4029a8:	17fffff8 	b	402988 <send_work_handler+0x31c>
        return K_USEC((stmin + 1 - ISOTP_STMIN_US_BEGIN) * 100U);
  4029ac:	d2800021 	mov	x1, #0x1                   	// #1
  4029b0:	17fffff6 	b	402988 <send_work_handler+0x31c>
            sctx->ctx->sent_callback(sctx->error, sctx->cb_arg);
  4029b4:	f9400660 	ldr	x0, [x19, #8]
  4029b8:	f9406661 	ldr	x1, [x19, #200]
  4029bc:	f9401802 	ldr	x2, [x0, #48]
  4029c0:	39c30e60 	ldrsb	w0, [x19, #195]
            sctx->ctx->sent_callback(ISOTP_N_OK, sctx->cb_arg);
  4029c4:	d63f0040 	blr	x2
            sctx->state = ISOTP_TX_STATE_RESET;
  4029c8:	f94033e0 	ldr	x0, [sp, #96]
  4029cc:	91030002 	add	x2, x0, #0xc0
  4029d0:	79418001 	ldrh	w1, [x0, #192]
  4029d4:	12002c21 	and	w1, w1, #0xfff
  4029d8:	79018001 	strh	w1, [x0, #192]
  4029dc:	39430800 	ldrb	w0, [x0, #194]
  4029e0:	121c6c00 	and	w0, w0, #0xfffffff0
  4029e4:	39000840 	strb	w0, [x2, #2]
            free_send_ctx(&sctx);
  4029e8:	910183e0 	add	x0, sp, #0x60
  4029ec:	97fffec4 	bl	4024fc <free_send_ctx>
}
  4029f0:	14000020 	b	402a70 <send_work_handler+0x404>
            k_timer_stop(&sctx->timer);
  4029f4:	91008000 	add	x0, x0, #0x20
  4029f8:	97fffdfe 	bl	4021f0 <k_timer_stop>
            sctx->ctx->sent_callback(ISOTP_N_OK, sctx->cb_arg);
  4029fc:	f94033e0 	ldr	x0, [sp, #96]
  402a00:	f9400401 	ldr	x1, [x0, #8]
  402a04:	f9401822 	ldr	x2, [x1, #48]
  402a08:	f9406401 	ldr	x1, [x0, #200]
  402a0c:	52800000 	mov	w0, #0x0                   	// #0
  402a10:	17ffffed 	b	4029c4 <send_work_handler+0x358>
                if (ret < 0) {
  402a14:	54fff68a 	b.ge	4028e4 <send_work_handler+0x278>  // b.tcont
                    LOG_ERR("Failed to send CF");
  402a18:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  402a1c:	52800022 	mov	w2, #0x1                   	// #1
  402a20:	52800000 	mov	w0, #0x0                   	// #0
  402a24:	b0000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  402a28:	f9478821 	ldr	x1, [x1, #3856]
  402a2c:	9121f4c6 	add	x6, x6, #0x87d
  402a30:	52800005 	mov	w5, #0x0                   	// #0
  402a34:	d2800004 	mov	x4, #0x0                   	// #0
  402a38:	d2800003 	mov	x3, #0x0                   	// #0
  402a3c:	97fffe08 	bl	40225c <z_log_msg_runtime_create.constprop.0>
                    send_report_error(sctx, ret == -EAGAIN ? ISOTP_N_TIMEOUT_A : ISOTP_N_ERROR);
  402a40:	f94033e1 	ldr	x1, [sp, #96]
  402a44:	31002e9f 	cmn	w20, #0xb
  402a48:	12800102 	mov	w2, #0xfffffff7            	// #-9
  402a4c:	5a9f1042 	csinv	w2, w2, wzr, ne  // ne = any
    sctx->state = ISOTP_TX_ERR;
  402a50:	79418020 	ldrh	w0, [x1, #192]
    sctx->error = err;
  402a54:	39030c22 	strb	w2, [x1, #195]
    sctx->state = ISOTP_TX_ERR;
  402a58:	12002c00 	and	w0, w0, #0xfff
  402a5c:	32114000 	orr	w0, w0, #0xffff8000
  402a60:	79018020 	strh	w0, [x1, #192]
  402a64:	39430820 	ldrb	w0, [x1, #194]
  402a68:	121c6c00 	and	w0, w0, #0xfffffff0
  402a6c:	39030820 	strb	w0, [x1, #194]
}
  402a70:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  402a74:	f9476800 	ldr	x0, [x0, #3792]
  402a78:	f9403fe2 	ldr	x2, [sp, #120]
  402a7c:	f9400001 	ldr	x1, [x0]
  402a80:	eb010042 	subs	x2, x2, x1
  402a84:	d2800001 	mov	x1, #0x0                   	// #0
  402a88:	54000040 	b.eq	402a90 <send_work_handler+0x424>  // b.none
  402a8c:	97fffa25 	bl	401320 <__stack_chk_fail@plt>
  402a90:	a94153f3 	ldp	x19, x20, [sp, #16]
  402a94:	a9425bf5 	ldp	x21, x22, [sp, #32]
  402a98:	a94363f7 	ldp	x23, x24, [sp, #48]
  402a9c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  402aa0:	a94573fb 	ldp	x27, x28, [sp, #80]
  402aa4:	a8c87bfd 	ldp	x29, x30, [sp], #128
  402aa8:	d65f03c0 	ret

0000000000402aac <receive_state_machine>:
{
  402aac:	d100c3ff 	sub	sp, sp, #0x30
  402ab0:	a9017bfd 	stp	x29, x30, [sp, #16]
  402ab4:	910043fd 	add	x29, sp, #0x10
    switch (rctx->state) {
  402ab8:	f9412407 	ldr	x7, [x0, #584]
{
  402abc:	f90017e0 	str	x0, [sp, #40]
    switch (rctx->state) {
  402ac0:	530c4ce1 	ubfx	w1, w7, #12, #8
  402ac4:	51000421 	sub	w1, w1, #0x1
  402ac8:	71001c3f 	cmp	w1, #0x7
  402acc:	540001e8 	b.hi	402b08 <receive_state_machine+0x5c>  // b.pmore
  402ad0:	b0000082 	adrp	x2, 413000 <sys_clock_announce+0x19c>
  402ad4:	911e8042 	add	x2, x2, #0x7a0
  402ad8:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  402adc:	10000061 	adr	x1, 402ae8 <receive_state_machine+0x3c>
  402ae0:	8b22a822 	add	x2, x1, w2, sxth #2
  402ae4:	d61f0040 	br	x2
            rctx->state = ISOTP_RX_STATE_RECYCLE;
  402ae8:	128fffe1 	mov	w1, #0xffff8000            	// #-32768
  402aec:	79049001 	strh	w1, [x0, #584]
  402af0:	39492801 	ldrb	w1, [x0, #586]
  402af4:	121c6c21 	and	w1, w1, #0xfffffff0
  402af8:	39092801 	strb	w1, [x0, #586]
            notify_waiting_receiver(rctx);
  402afc:	97fffdbe 	bl	4021f4 <notify_waiting_receiver>
            receive_state_machine(rctx);
  402b00:	f94017e0 	ldr	x0, [sp, #40]
                receive_state_machine(rctx);
  402b04:	97ffffea 	bl	402aac <receive_state_machine>
}
  402b08:	a9417bfd 	ldp	x29, x30, [sp, #16]
  402b0c:	9100c3ff 	add	sp, sp, #0x30
  402b10:	d65f03c0 	ret
            if (rctx->ctx->opts->bs == 0
  402b14:	f9400401 	ldr	x1, [x0, #8]
  402b18:	f9400821 	ldr	x1, [x1, #16]
  402b1c:	39400021 	ldrb	w1, [x1]
  402b20:	35000321 	cbnz	w1, 402b84 <receive_state_machine+0xd8>
                && rctx->rem_len > CONFIG_ISOTP_FAST_RX_MAX_PACKET_COUNT * (CAN_MAX_DLEN - 1))
  402b24:	12002ce7 	and	w7, w7, #0xfff
  402b28:	710460ff 	cmp	w7, #0x118
  402b2c:	540002c9 	b.ls	402b84 <receive_state_machine+0xd8>  // b.plast
                LOG_ERR("Pkt length is %d but buffer has only %d bytes", rctx->rem_len,
  402b30:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  402b34:	52802300 	mov	w0, #0x118                 	// #280
  402b38:	b90003e0 	str	w0, [sp]
  402b3c:	52800022 	mov	w2, #0x1                   	// #1
  402b40:	f9478821 	ldr	x1, [x1, #3856]
  402b44:	52800000 	mov	w0, #0x0                   	// #0
  402b48:	b0000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  402b4c:	52800005 	mov	w5, #0x0                   	// #0
  402b50:	91223cc6 	add	x6, x6, #0x88f
  402b54:	d2800004 	mov	x4, #0x0                   	// #0
  402b58:	d2800003 	mov	x3, #0x0                   	// #0
  402b5c:	97fffdc0 	bl	40225c <z_log_msg_runtime_create.constprop.0>
                receive_report_error(rctx, ISOTP_N_BUFFER_OVERFLW);
  402b60:	f94017e0 	ldr	x0, [sp, #40]
    rctx->state = ISOTP_RX_STATE_ERR;
  402b64:	528e0002 	mov	w2, #0x7000                	// #28672
  402b68:	72bf0002 	movk	w2, #0xf800, lsl #16
  402b6c:	b9424801 	ldr	w1, [x0, #584]
  402b70:	12005c21 	and	w1, w1, #0xffffff
  402b74:	120c5c21 	and	w1, w1, #0xfff00fff
  402b78:	2a020021 	orr	w1, w1, w2
  402b7c:	b9024801 	str	w1, [x0, #584]
  402b80:	17ffffe1 	b	402b04 <receive_state_machine+0x58>
            notify_waiting_receiver(rctx);
  402b84:	97fffd9c 	bl	4021f4 <notify_waiting_receiver>
            if (rctx->ctx->opts->bs) {
  402b88:	f94017e0 	ldr	x0, [sp, #40]
  402b8c:	f9400401 	ldr	x1, [x0, #8]
  402b90:	f9400821 	ldr	x1, [x1, #16]
  402b94:	39400021 	ldrb	w1, [x1]
  402b98:	34000041 	cbz	w1, 402ba0 <receive_state_machine+0xf4>
                rctx->bs = rctx->ctx->opts->bs;
  402b9c:	39093401 	strb	w1, [x0, #589]
            rctx->wft = ISOTP_WFT_FIRST;
  402ba0:	12800001 	mov	w1, #0xffffffff            	// #-1
  402ba4:	39093001 	strb	w1, [x0, #588]
            rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402ba8:	79449001 	ldrh	w1, [x0, #584]
  402bac:	91092002 	add	x2, x0, #0x248
  402bb0:	12002c21 	and	w1, w1, #0xfff
  402bb4:	32140421 	orr	w1, w1, #0x3000
  402bb8:	79049001 	strh	w1, [x0, #584]
  402bbc:	39492800 	ldrb	w0, [x0, #586]
  402bc0:	121c6c00 	and	w0, w0, #0xfffffff0
  402bc4:	39000840 	strb	w0, [x2, #2]
            k_timer_stop(&rctx->timer);
  402bc8:	f94017e0 	ldr	x0, [sp, #40]
  402bcc:	9100e000 	add	x0, x0, #0x38
  402bd0:	97fffd88 	bl	4021f0 <k_timer_stop>
            notify_waiting_receiver(rctx);
  402bd4:	f94017e0 	ldr	x0, [sp, #40]
  402bd8:	97fffd87 	bl	4021f4 <notify_waiting_receiver>
            rctx->state = ISOTP_RX_STATE_SEND_FC;
  402bdc:	f94017e1 	ldr	x1, [sp, #40]
  402be0:	79449020 	ldrh	w0, [x1, #584]
  402be4:	12002c00 	and	w0, w0, #0xfff
  402be8:	32120000 	orr	w0, w0, #0x4000
  402bec:	79049020 	strh	w0, [x1, #584]
  402bf0:	39492820 	ldrb	w0, [x1, #586]
  402bf4:	121c6c00 	and	w0, w0, #0xfffffff0
  402bf8:	39092820 	strb	w0, [x1, #586]
            receive_send_fc(rctx, ISOTP_PCI_FS_CTS);
  402bfc:	f94017e0 	ldr	x0, [sp, #40]
  402c00:	52800001 	mov	w1, #0x0                   	// #0
  402c04:	9400005c 	bl	402d74 <receive_send_fc>
            k_timer_start(&rctx->timer, K_MSEC(ISOTP_CR_TIMEOUT_MS), K_NO_WAIT);
  402c08:	f94017e0 	ldr	x0, [sp, #40]
  402c0c:	9100e000 	add	x0, x0, #0x38
  402c10:	d2800c81 	mov	x1, #0x64                  	// #100
  402c14:	d2800002 	mov	x2, #0x0                   	// #0
  402c18:	940041f8 	bl	4133f8 <z_impl_k_timer_start>
            rctx->state = ISOTP_RX_STATE_WAIT_CF;
  402c1c:	f94017e1 	ldr	x1, [sp, #40]
  402c20:	528a0003 	mov	w3, #0x5000                	// #20480
  402c24:	79449020 	ldrh	w0, [x1, #584]
  402c28:	12002c00 	and	w0, w0, #0xfff
  402c2c:	2a030000 	orr	w0, w0, w3
                rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402c30:	79049020 	strh	w0, [x1, #584]
  402c34:	39492820 	ldrb	w0, [x1, #586]
  402c38:	121c6c00 	and	w0, w0, #0xfffffff0
  402c3c:	39092820 	strb	w0, [x1, #586]
                break;
  402c40:	17ffffb2 	b	402b08 <receive_state_machine+0x5c>
            if (++rctx->wft < CONFIG_ISOTP_WFTMAX) {
  402c44:	39493007 	ldrb	w7, [x0, #588]
  402c48:	110004e7 	add	w7, w7, #0x1
  402c4c:	12001ce7 	and	w7, w7, #0xff
  402c50:	39093007 	strb	w7, [x0, #588]
  402c54:	710024ff 	cmp	w7, #0x9
  402c58:	540001a8 	b.hi	402c8c <receive_state_machine+0x1e0>  // b.pmore
                receive_send_fc(rctx, ISOTP_PCI_FS_WAIT);
  402c5c:	52800021 	mov	w1, #0x1                   	// #1
  402c60:	94000045 	bl	402d74 <receive_send_fc>
                k_timer_start(&rctx->timer, K_MSEC(ISOTP_ALLOC_TIMEOUT_MS), K_NO_WAIT);
  402c64:	f94017e0 	ldr	x0, [sp, #40]
  402c68:	9100e000 	add	x0, x0, #0x38
  402c6c:	d2800b41 	mov	x1, #0x5a                  	// #90
  402c70:	d2800002 	mov	x2, #0x0                   	// #0
  402c74:	940041e1 	bl	4133f8 <z_impl_k_timer_start>
                rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402c78:	f94017e1 	ldr	x1, [sp, #40]
  402c7c:	79449020 	ldrh	w0, [x1, #584]
  402c80:	12002c00 	and	w0, w0, #0xfff
  402c84:	32140400 	orr	w0, w0, #0x3000
  402c88:	17ffffea 	b	402c30 <receive_state_machine+0x184>
            LOG_ERR("Sent %d wait frames. Giving up to alloc now", rctx->wft);
  402c8c:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  402c90:	52800022 	mov	w2, #0x1                   	// #1
  402c94:	52800000 	mov	w0, #0x0                   	// #0
  402c98:	b0000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  402c9c:	f9478821 	ldr	x1, [x1, #3856]
  402ca0:	9122f4c6 	add	x6, x6, #0x8bd
  402ca4:	52800005 	mov	w5, #0x0                   	// #0
  402ca8:	d2800004 	mov	x4, #0x0                   	// #0
  402cac:	d2800003 	mov	x3, #0x0                   	// #0
  402cb0:	97fffd6b 	bl	40225c <z_log_msg_runtime_create.constprop.0>
            receive_report_error(rctx, ISOTP_N_BUFFER_OVERFLW);
  402cb4:	f94017e1 	ldr	x1, [sp, #40]
    rctx->state = ISOTP_RX_STATE_ERR;
  402cb8:	528e0002 	mov	w2, #0x7000                	// #28672
  402cbc:	72bf0002 	movk	w2, #0xf800, lsl #16
  402cc0:	b9424820 	ldr	w0, [x1, #584]
  402cc4:	12005c00 	and	w0, w0, #0xffffff
  402cc8:	120c5c00 	and	w0, w0, #0xfff00fff
  402ccc:	2a020000 	orr	w0, w0, w2
  402cd0:	b9024820 	str	w0, [x1, #584]
            k_timer_stop(&rctx->timer);
  402cd4:	f94017e0 	ldr	x0, [sp, #40]
  402cd8:	9100e000 	add	x0, x0, #0x38
  402cdc:	97fffd45 	bl	4021f0 <k_timer_stop>
            if (rctx->ctx->recv_error_callback) {
  402ce0:	f94017e0 	ldr	x0, [sp, #40]
  402ce4:	f9400401 	ldr	x1, [x0, #8]
  402ce8:	f9401423 	ldr	x3, [x1, #40]
  402cec:	b40000a3 	cbz	x3, 402d00 <receive_state_machine+0x254>
                rctx->ctx->recv_error_callback(rctx->error, rctx->sender_addr,
  402cf0:	f9401022 	ldr	x2, [x1, #32]
  402cf4:	b9401001 	ldr	w1, [x0, #16]
  402cf8:	39492c00 	ldrb	w0, [x0, #587]
  402cfc:	d63f0060 	blr	x3
            notify_waiting_receiver(rctx);
  402d00:	f94017e0 	ldr	x0, [sp, #40]
  402d04:	97fffd3c 	bl	4021f4 <notify_waiting_receiver>
            if (rctx->error == ISOTP_N_BUFFER_OVERFLW) {
  402d08:	f94017e0 	ldr	x0, [sp, #40]
  402d0c:	39c92c01 	ldrsb	w1, [x0, #587]
  402d10:	3100203f 	cmn	w1, #0x8
  402d14:	54000061 	b.ne	402d20 <receive_state_machine+0x274>  // b.any
                receive_send_fc(rctx, ISOTP_PCI_FS_OVFLW);
  402d18:	52800041 	mov	w1, #0x2                   	// #2
  402d1c:	94000016 	bl	402d74 <receive_send_fc>
    if ((*rctx)->pending) {
  402d20:	f94017e0 	ldr	x0, [sp, #40]
  402d24:	39493c00 	ldrb	w0, [x0, #591]
  402d28:	35000060 	cbnz	w0, 402d34 <receive_state_machine+0x288>
    free_recv_ctx(rctx);
  402d2c:	9100a3e0 	add	x0, sp, #0x28
  402d30:	97fffe23 	bl	4025bc <free_recv_ctx>
            notify_waiting_receiver(rctx);
  402d34:	f94017e0 	ldr	x0, [sp, #40]
  402d38:	97fffd2f 	bl	4021f4 <notify_waiting_receiver>
            rctx->state = ISOTP_RX_STATE_UNBOUND;
  402d3c:	f94017e1 	ldr	x1, [sp, #40]
  402d40:	128dffe3 	mov	w3, #0xffff9000            	// #-28672
  402d44:	79449020 	ldrh	w0, [x1, #584]
  402d48:	12002c00 	and	w0, w0, #0xfff
  402d4c:	2a030000 	orr	w0, w0, w3
  402d50:	79049020 	strh	w0, [x1, #584]
  402d54:	39492820 	ldrb	w0, [x1, #586]
  402d58:	121c6c00 	and	w0, w0, #0xfffffff0
  402d5c:	39092820 	strb	w0, [x1, #586]
    if ((*rctx)->pending) {
  402d60:	39493c20 	ldrb	w0, [x1, #591]
  402d64:	35ffed20 	cbnz	w0, 402b08 <receive_state_machine+0x5c>
    free_recv_ctx(rctx);
  402d68:	9100a3e0 	add	x0, sp, #0x28
  402d6c:	97fffe14 	bl	4025bc <free_recv_ctx>
}
  402d70:	17ffff66 	b	402b08 <receive_state_machine+0x5c>

0000000000402d74 <receive_send_fc>:
{
  402d74:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    *data++ = ISOTP_PCI_TYPE_FC | fs;
  402d78:	321c0421 	orr	w1, w1, #0x30
{
  402d7c:	910003fd 	mov	x29, sp
  402d80:	f9000bf3 	str	x19, [sp, #16]
  402d84:	aa0003f3 	mov	x19, x0
  402d88:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  402d8c:	f9476800 	ldr	x0, [x0, #3792]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  402d90:	f9400663 	ldr	x3, [x19, #8]
{
  402d94:	f9400002 	ldr	x2, [x0]
  402d98:	f9001fe2 	str	x2, [sp, #56]
  402d9c:	d2800002 	mov	x2, #0x0                   	// #0
              | ((rctx->sender_addr & 0xFF) << 8)
  402da0:	79402262 	ldrh	w2, [x19, #16]
        .id = (rctx->sender_addr & 0xFFFF0000) | ((rctx->sender_addr & 0xFF00) >> 8)
  402da4:	b9401260 	ldr	w0, [x19, #16]
              | ((rctx->sender_addr & 0xFF) << 8)
  402da8:	5ac00442 	rev16	w2, w2
    struct can_frame frame = {
  402dac:	a902ffff 	stp	xzr, xzr, [sp, #40]
              | ((rctx->sender_addr & 0xFF) << 8)
  402db0:	12003c42 	and	w2, w2, #0xffff
        .id = (rctx->sender_addr & 0xFFFF0000) | ((rctx->sender_addr & 0xFF00) >> 8)
  402db4:	12103c00 	and	w0, w0, #0xffff0000
              | ((rctx->sender_addr & 0xFF) << 8)
  402db8:	2a020000 	orr	w0, w0, w2
    struct can_frame frame = {
  402dbc:	52800002 	mov	w2, #0x0                   	// #0
  402dc0:	33007002 	bfxil	w2, w0, #0, #29
  402dc4:	b9002be2 	str	w2, [sp, #40]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  402dc8:	f9400862 	ldr	x2, [x3, #16]
  402dcc:	39400840 	ldrb	w0, [x2, #2]
    *data++ = ISOTP_PCI_TYPE_FC | fs;
  402dd0:	3900c3e1 	strb	w1, [sp, #48]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  402dd4:	d341fc00 	lsr	x0, x0, #1
  402dd8:	121e0000 	and	w0, w0, #0x4
  402ddc:	32000000 	orr	w0, w0, #0x1
    struct can_frame frame = {
  402de0:	3900b7e0 	strb	w0, [sp, #45]
    *data++ = rctx->ctx->opts->bs;
  402de4:	39400040 	ldrb	w0, [x2]
  402de8:	3900c7e0 	strb	w0, [sp, #49]
    *data++ = rctx->ctx->opts->stmin;
  402dec:	39400440 	ldrb	w0, [x2, #1]
  402df0:	3900cbe0 	strb	w0, [sp, #50]
    frame.dlc = can_bytes_to_dlc(payload_len);
  402df4:	52800060 	mov	w0, #0x3                   	// #3
  402df8:	3900b3e0 	strb	w0, [sp, #44]
    ret = can_send(rctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), receive_can_tx, rctx);
  402dfc:	f9400060 	ldr	x0, [x3]
  402e00:	90000003 	adrp	x3, 402000 <__floatunditf+0x60>
  402e04:	aa1303e4 	mov	x4, x19
  402e08:	910e3063 	add	x3, x3, #0x38c
  402e0c:	9100a3e1 	add	x1, sp, #0x28
  402e10:	d2800c82 	mov	x2, #0x64                  	// #100
  402e14:	940027a2 	bl	40cc9c <z_impl_can_send>
    if (ret) {
  402e18:	340002a0 	cbz	w0, 402e6c <receive_send_fc+0xf8>
        LOG_ERR("Can't send FC, (%d)", ret);
  402e1c:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  402e20:	2a0003e7 	mov	w7, w0
  402e24:	b0000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  402e28:	52800000 	mov	w0, #0x0                   	// #0
  402e2c:	f9478821 	ldr	x1, [x1, #3856]
  402e30:	9123a4c6 	add	x6, x6, #0x8e9
  402e34:	52800005 	mov	w5, #0x0                   	// #0
  402e38:	d2800004 	mov	x4, #0x0                   	// #0
  402e3c:	d2800003 	mov	x3, #0x0                   	// #0
  402e40:	52800022 	mov	w2, #0x1                   	// #1
  402e44:	97fffd06 	bl	40225c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  402e48:	b9424a60 	ldr	w0, [x19, #584]
  402e4c:	528e0001 	mov	w1, #0x7000                	// #28672
  402e50:	72bfe001 	movk	w1, #0xff00, lsl #16
  402e54:	12005c00 	and	w0, w0, #0xffffff
  402e58:	120c5c00 	and	w0, w0, #0xfff00fff
  402e5c:	2a010000 	orr	w0, w0, w1
  402e60:	b9024a60 	str	w0, [x19, #584]
        receive_state_machine(rctx);
  402e64:	aa1303e0 	mov	x0, x19
  402e68:	97ffff11 	bl	402aac <receive_state_machine>
}
  402e6c:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  402e70:	f9476800 	ldr	x0, [x0, #3792]
  402e74:	f9401fe2 	ldr	x2, [sp, #56]
  402e78:	f9400001 	ldr	x1, [x0]
  402e7c:	eb010042 	subs	x2, x2, x1
  402e80:	d2800001 	mov	x1, #0x0                   	// #0
  402e84:	54000040 	b.eq	402e8c <receive_send_fc+0x118>  // b.none
  402e88:	97fff926 	bl	401320 <__stack_chk_fail@plt>
  402e8c:	f9400bf3 	ldr	x19, [sp, #16]
  402e90:	a8c47bfd 	ldp	x29, x30, [sp], #64
  402e94:	d65f03c0 	ret

0000000000402e98 <receive_work_handler>:
    receive_state_machine(rctx);
  402e98:	d1006000 	sub	x0, x0, #0x18
  402e9c:	17ffff04 	b	402aac <receive_state_machine>

0000000000402ea0 <can_rx_callback>:
{
  402ea0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  402ea4:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  402ea8:	910003fd 	mov	x29, sp
  402eac:	a90153f3 	stp	x19, x20, [sp, #16]
  402eb0:	a9025bf5 	stp	x21, x22, [sp, #32]
  402eb4:	aa0103f5 	mov	x21, x1
  402eb8:	aa0203f6 	mov	x22, x2
  402ebc:	a90363f7 	stp	x23, x24, [sp, #48]
  402ec0:	f9476800 	ldr	x0, [x0, #3792]
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402ec4:	b9400033 	ldr	w19, [x1]
{
  402ec8:	f90023f9 	str	x25, [sp, #64]
  402ecc:	f9400001 	ldr	x1, [x0]
  402ed0:	f90037e1 	str	x1, [sp, #104]
  402ed4:	d2800001 	mov	x1, #0x0                   	// #0
    if ((frame->data[index++] & ISOTP_PCI_TYPE_MASK) == ISOTP_PCI_TYPE_FC) {
  402ed8:	394022a0 	ldrb	w0, [x21, #8]
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402edc:	d3407273 	ubfx	x19, x19, #0, #29
    if ((frame->data[index++] & ISOTP_PCI_TYPE_MASK) == ISOTP_PCI_TYPE_FC) {
  402ee0:	121c0c00 	and	w0, w0, #0xf0
  402ee4:	7100c01f 	cmp	w0, #0x30
  402ee8:	54001061 	b.ne	4030f4 <can_rx_callback+0x254>  // b.any
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402eec:	53181e60 	ubfiz	w0, w19, #8, #8
  402ef0:	d3483e61 	ubfx	x1, x19, #8, #8
    isotp_fast_msg_id sender_id =
  402ef4:	2a000021 	orr	w1, w1, w0
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402ef8:	12103e73 	and	w19, w19, #0xffff0000
        if (get_send_ctx(ctx, sender_id, &sctx) != 0) {
  402efc:	910183e2 	add	x2, sp, #0x60
  402f00:	2a130021 	orr	w1, w1, w19
  402f04:	aa1603e0 	mov	x0, x22
  402f08:	97fffc70 	bl	4020c8 <get_send_ctx>
  402f0c:	35001680 	cbnz	w0, 4031dc <can_rx_callback+0x33c>
        send_can_rx(sctx, frame);
  402f10:	f94033f3 	ldr	x19, [sp, #96]
    if (sctx->state == ISOTP_TX_WAIT_FC) {
  402f14:	f9406260 	ldr	x0, [x19, #192]
  402f18:	530c4c00 	ubfx	w0, w0, #12, #8
  402f1c:	71000c1f 	cmp	w0, #0x3
  402f20:	54000d61 	b.ne	4030cc <can_rx_callback+0x22c>  // b.any
        k_timer_stop(&sctx->timer);
  402f24:	9100e274 	add	x20, x19, #0x38
  402f28:	aa1403e0 	mov	x0, x20
  402f2c:	97fffcb1 	bl	4021f0 <k_timer_stop>
    if ((*data & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_FC) {
  402f30:	394022a1 	ldrb	w1, [x21, #8]
  402f34:	121c0c20 	and	w0, w1, #0xf0
  402f38:	7100c01f 	cmp	w0, #0x30
  402f3c:	54000220 	b.eq	402f80 <can_rx_callback+0xe0>  // b.none
        LOG_ERR("Got unexpected PDU expected FC");
  402f40:	b0000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  402f44:	9123f4c6 	add	x6, x6, #0x8fd
        LOG_ERR("Got unexpected PDU");
  402f48:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  402f4c:	52800000 	mov	w0, #0x0                   	// #0
  402f50:	52800005 	mov	w5, #0x0                   	// #0
  402f54:	d2800004 	mov	x4, #0x0                   	// #0
  402f58:	f9478821 	ldr	x1, [x1, #3856]
  402f5c:	d2800003 	mov	x3, #0x0                   	// #0
  402f60:	52800022 	mov	w2, #0x1                   	// #1
  402f64:	97fffcbe 	bl	40225c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  402f68:	b940c260 	ldr	w0, [x19, #192]
  402f6c:	52900001 	mov	w1, #0x8000                	// #32768
  402f70:	72bf4001 	movk	w1, #0xfa00, lsl #16
  402f74:	12005c00 	and	w0, w0, #0xffffff
  402f78:	120c5c00 	and	w0, w0, #0xfff00fff
  402f7c:	1400004b 	b	4030a8 <can_rx_callback+0x208>
    switch (*data++ & ISOTP_PCI_FS_MASK) {
  402f80:	12000c21 	and	w1, w1, #0xf
  402f84:	7100043f 	cmp	w1, #0x1
  402f88:	540003a0 	b.eq	402ffc <can_rx_callback+0x15c>  // b.none
  402f8c:	7100083f 	cmp	w1, #0x2
  402f90:	540006e0 	b.eq	40306c <can_rx_callback+0x1cc>  // b.none
  402f94:	35000901 	cbnz	w1, 4030b4 <can_rx_callback+0x214>
            sctx->state = ISOTP_TX_SEND_CF;
  402f98:	79418260 	ldrh	w0, [x19, #192]
  402f9c:	91030261 	add	x1, x19, #0xc0
  402fa0:	12002c00 	and	w0, w0, #0xfff
  402fa4:	32120000 	orr	w0, w0, #0x4000
  402fa8:	79018260 	strh	w0, [x19, #192]
  402fac:	aa0103e0 	mov	x0, x1
  402fb0:	39400821 	ldrb	w1, [x1, #2]
  402fb4:	121c6c21 	and	w1, w1, #0xfffffff0
  402fb8:	39000801 	strb	w1, [x0, #2]
            sctx->wft = 0;
  402fbc:	3903427f 	strb	wzr, [x19, #208]
            sctx->backlog = 0;
  402fc0:	39034e7f 	strb	wzr, [x19, #211]
	z_impl_k_sem_reset(sem);
  402fc4:	91024260 	add	x0, x19, #0x90
  402fc8:	940032c2 	bl	40fad0 <z_impl_k_sem_reset>
            sctx->bs = *data++;
  402fcc:	394026a0 	ldrb	w0, [x21, #9]
  402fd0:	39034660 	strb	w0, [x19, #209]
            sctx->stmin = *data++;
  402fd4:	39402aa0 	ldrb	w0, [x21, #10]
  402fd8:	39035260 	strb	w0, [x19, #212]
    k_work_submit(&sctx->work);
  402fdc:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  402fe0:	f9476800 	ldr	x0, [x0, #3792]
  402fe4:	f94037e2 	ldr	x2, [sp, #104]
  402fe8:	f9400001 	ldr	x1, [x0]
  402fec:	eb010042 	subs	x2, x2, x1
  402ff0:	d2800001 	mov	x1, #0x0                   	// #0
  402ff4:	54000720 	b.eq	4030d8 <can_rx_callback+0x238>  // b.none
}
  402ff8:	97fff8ca 	bl	401320 <__stack_chk_fail@plt>
	z_impl_k_timer_start(timer, duration, period);
  402ffc:	d2800002 	mov	x2, #0x0                   	// #0
  403000:	aa1403e0 	mov	x0, x20
  403004:	d2800c81 	mov	x1, #0x64                  	// #100
  403008:	940040fc 	bl	4133f8 <z_impl_k_timer_start>
            if (sctx->wft >= CONFIG_ISOTP_WFTMAX) {
  40300c:	39434260 	ldrb	w0, [x19, #208]
  403010:	7100241f 	cmp	w0, #0x9
  403014:	54000249 	b.ls	40305c <can_rx_callback+0x1bc>  // b.plast
                LOG_WRN("Got too many wait frames");
  403018:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40301c:	52800000 	mov	w0, #0x0                   	// #0
  403020:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  403024:	52800005 	mov	w5, #0x0                   	// #0
  403028:	f9478821 	ldr	x1, [x1, #3856]
  40302c:	912470c6 	add	x6, x6, #0x91c
  403030:	d2800004 	mov	x4, #0x0                   	// #0
  403034:	d2800003 	mov	x3, #0x0                   	// #0
  403038:	52800042 	mov	w2, #0x2                   	// #2
  40303c:	97fffc88 	bl	40225c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  403040:	b940c260 	ldr	w0, [x19, #192]
  403044:	52900001 	mov	w1, #0x8000                	// #32768
  403048:	72bf2001 	movk	w1, #0xf900, lsl #16
  40304c:	12005c00 	and	w0, w0, #0xffffff
  403050:	120c5c00 	and	w0, w0, #0xfff00fff
  403054:	2a010000 	orr	w0, w0, w1
  403058:	b900c260 	str	w0, [x19, #192]
            sctx->wft++;
  40305c:	39434260 	ldrb	w0, [x19, #208]
  403060:	11000400 	add	w0, w0, #0x1
  403064:	39034260 	strb	w0, [x19, #208]
            break;
  403068:	17ffffdd 	b	402fdc <can_rx_callback+0x13c>
            LOG_ERR("Got overflow FC frame");
  40306c:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  403070:	52800000 	mov	w0, #0x0                   	// #0
  403074:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  403078:	52800005 	mov	w5, #0x0                   	// #0
  40307c:	f9478821 	ldr	x1, [x1, #3856]
  403080:	9124d4c6 	add	x6, x6, #0x935
  403084:	d2800004 	mov	x4, #0x0                   	// #0
  403088:	d2800003 	mov	x3, #0x0                   	// #0
  40308c:	52800022 	mov	w2, #0x1                   	// #1
  403090:	97fffc73 	bl	40225c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  403094:	b940c260 	ldr	w0, [x19, #192]
  403098:	52900001 	mov	w1, #0x8000                	// #32768
  40309c:	72bf0001 	movk	w1, #0xf800, lsl #16
  4030a0:	12005c00 	and	w0, w0, #0xffffff
  4030a4:	120c5c00 	and	w0, w0, #0xfff00fff
  4030a8:	2a010000 	orr	w0, w0, w1
  4030ac:	b900c260 	str	w0, [x19, #192]
}
  4030b0:	17ffffcb 	b	402fdc <can_rx_callback+0x13c>
    sctx->state = ISOTP_TX_ERR;
  4030b4:	b940c260 	ldr	w0, [x19, #192]
  4030b8:	52900001 	mov	w1, #0x8000                	// #32768
  4030bc:	72bf6001 	movk	w1, #0xfb00, lsl #16
  4030c0:	12005c00 	and	w0, w0, #0xffffff
  4030c4:	120c5c00 	and	w0, w0, #0xfff00fff
  4030c8:	17fffff8 	b	4030a8 <can_rx_callback+0x208>
        LOG_ERR("Got unexpected PDU");
  4030cc:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  4030d0:	91252cc6 	add	x6, x6, #0x94b
  4030d4:	17ffff9d 	b	402f48 <can_rx_callback+0xa8>
    k_work_submit(&sctx->work);
  4030d8:	91006260 	add	x0, x19, #0x18
}
  4030dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4030e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4030e4:	a94363f7 	ldp	x23, x24, [sp, #48]
  4030e8:	f94023f9 	ldr	x25, [sp, #64]
  4030ec:	a8c77bfd 	ldp	x29, x30, [sp], #112
    k_work_submit(&sctx->work);
  4030f0:	14003452 	b	410238 <k_work_submit>
	return list->head;
  4030f4:	b0000157 	adrp	x23, 42c000 <__dso_handle>
    return (isotp_fast_node_id)(addr & ISOTP_FIXED_ADDR_SA_MASK);
  4030f8:	12001e60 	and	w0, w19, #0xff
  4030fc:	f94562f4 	ldr	x20, [x23, #2752]
    SYS_SLIST_FOR_EACH_CONTAINER(&isotp_recv_ctx_list, context, node)
  403100:	f90033f4 	str	x20, [sp, #96]
  403104:	b50002b4 	cbnz	x20, 403158 <can_rx_callback+0x2b8>
    int err = k_mem_slab_alloc(&isotp_recv_ctx_slab, (void **)&context, K_NO_WAIT);
  403108:	90000154 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  40310c:	910183f8 	add	x24, sp, #0x60
  403110:	aa1803e1 	mov	x1, x24
  403114:	d2800002 	mov	x2, #0x0                   	// #0
  403118:	f9479e94 	ldr	x20, [x20, #3896]
  40311c:	aa1403e0 	mov	x0, x20
  403120:	94002be7 	bl	40e0bc <k_mem_slab_alloc>
  403124:	2a0003e7 	mov	w7, w0
    if (err != 0) {
  403128:	34000780 	cbz	w0, 403218 <can_rx_callback+0x378>
        LOG_ERR("No space for receive context - error %d.", err);
  40312c:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  403130:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  403134:	52800005 	mov	w5, #0x0                   	// #0
  403138:	9125b8c6 	add	x6, x6, #0x96e
  40313c:	f9478821 	ldr	x1, [x1, #3856]
  403140:	d2800004 	mov	x4, #0x0                   	// #0
  403144:	d2800003 	mov	x3, #0x0                   	// #0
  403148:	52800022 	mov	w2, #0x1                   	// #1
  40314c:	52800000 	mov	w0, #0x0                   	// #0
  403150:	97fffc43 	bl	40225c <z_log_msg_runtime_create.constprop.0>
        return ISOTP_NO_CTX_LEFT;
  403154:	14000018 	b	4031b4 <can_rx_callback+0x314>
        if (isotp_fast_get_addr_sender(context->sender_addr) == sender_id) {
  403158:	39404281 	ldrb	w1, [x20, #16]
  40315c:	6b01001f 	cmp	w0, w1
  403160:	54000581 	b.ne	403210 <can_rx_callback+0x370>  // b.any
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf * __must_check net_buf_alloc(struct net_buf_pool *pool,
							  k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
  403164:	d2800001 	mov	x1, #0x0                   	// #0
  403168:	b0000140 	adrp	x0, 42c000 <__dso_handle>
  40316c:	9124a000 	add	x0, x0, #0x928
            *rctx = context;
  403170:	f9002ff4 	str	x20, [sp, #88]
  403174:	940025e8 	bl	40c914 <net_buf_alloc_fixed>
            context->frag = net_buf_alloc(&isotp_rx_pool, K_NO_WAIT);
  403178:	f9004e80 	str	x0, [x20, #152]
            if (context->frag == NULL) {
  40317c:	f94033e0 	ldr	x0, [sp, #96]
  403180:	f9404c00 	ldr	x0, [x0, #152]
  403184:	b5000b60 	cbnz	x0, 4032f0 <can_rx_callback+0x450>
                LOG_ERR("No free buffers");
  403188:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40318c:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  403190:	912578c6 	add	x6, x6, #0x95e
  403194:	52800005 	mov	w5, #0x0                   	// #0
  403198:	f9478821 	ldr	x1, [x1, #3856]
  40319c:	d2800004 	mov	x4, #0x0                   	// #0
  4031a0:	d2800003 	mov	x3, #0x0                   	// #0
  4031a4:	52800022 	mov	w2, #0x1                   	// #1
  4031a8:	97fffc2d 	bl	40225c <z_log_msg_runtime_create.constprop.0>
                free_recv_ctx(rctx);
  4031ac:	910163e0 	add	x0, sp, #0x58
  4031b0:	97fffd03 	bl	4025bc <free_recv_ctx>
            LOG_ERR("RX buffer full");
  4031b4:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  4031b8:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  4031bc:	52800005 	mov	w5, #0x0                   	// #0
  4031c0:	912690c6 	add	x6, x6, #0x9a4
  4031c4:	f9478821 	ldr	x1, [x1, #3856]
  4031c8:	d2800004 	mov	x4, #0x0                   	// #0
  4031cc:	d2800003 	mov	x3, #0x0                   	// #0
  4031d0:	52800022 	mov	w2, #0x1                   	// #1
  4031d4:	52800000 	mov	w0, #0x0                   	// #0
  4031d8:	97fffc21 	bl	40225c <z_log_msg_runtime_create.constprop.0>
}
  4031dc:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4031e0:	f9476800 	ldr	x0, [x0, #3792]
  4031e4:	f94037e2 	ldr	x2, [sp, #104]
  4031e8:	f9400001 	ldr	x1, [x0]
  4031ec:	eb010042 	subs	x2, x2, x1
  4031f0:	d2800001 	mov	x1, #0x0                   	// #0
  4031f4:	54fff021 	b.ne	402ff8 <can_rx_callback+0x158>  // b.any
  4031f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4031fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403200:	a94363f7 	ldp	x23, x24, [sp, #48]
  403204:	f94023f9 	ldr	x25, [sp, #64]
  403208:	a8c77bfd 	ldp	x29, x30, [sp], #112
  40320c:	d65f03c0 	ret
	return node->next;
  403210:	f9400294 	ldr	x20, [x20]
  403214:	17ffffbb 	b	403100 <can_rx_callback+0x260>
    context->buffer = net_buf_alloc(&isotp_rx_pool, K_NO_WAIT);
  403218:	f94033f9 	ldr	x25, [sp, #96]
  40321c:	d2800001 	mov	x1, #0x0                   	// #0
  403220:	b0000140 	adrp	x0, 42c000 <__dso_handle>
  403224:	9124a000 	add	x0, x0, #0x928
  403228:	940025bb 	bl	40c914 <net_buf_alloc_fixed>
  40322c:	f9004b20 	str	x0, [x25, #144]
    if (!context->buffer) {
  403230:	f94033e0 	ldr	x0, [sp, #96]
  403234:	f9404801 	ldr	x1, [x0, #144]
  403238:	b50001e1 	cbnz	x1, 403274 <can_rx_callback+0x3d4>
        k_mem_slab_free(&isotp_recv_ctx_slab, (void **)&context);
  40323c:	aa1803e1 	mov	x1, x24
  403240:	aa1403e0 	mov	x0, x20
  403244:	94002bfc 	bl	40e234 <k_mem_slab_free>
        LOG_ERR("No net bufs.");
  403248:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40324c:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  403250:	52800005 	mov	w5, #0x0                   	// #0
  403254:	91265cc6 	add	x6, x6, #0x997
  403258:	f9478821 	ldr	x1, [x1, #3856]
  40325c:	d2800004 	mov	x4, #0x0                   	// #0
  403260:	d2800003 	mov	x3, #0x0                   	// #0
  403264:	52800022 	mov	w2, #0x1                   	// #1
  403268:	52800000 	mov	w0, #0x0                   	// #0
  40326c:	97fffbfc 	bl	40225c <z_log_msg_runtime_create.constprop.0>
        return ISOTP_NO_NET_BUF_LEFT;
  403270:	17ffffd1 	b	4031b4 <can_rx_callback+0x314>
    context->frag = context->buffer;
  403274:	f9004c01 	str	x1, [x0, #152]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  403278:	52800503 	mov	w3, #0x28                  	// #40
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  40327c:	b9424801 	ldr	w1, [x0, #584]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  403280:	d2800102 	mov	x2, #0x8                   	// #8
    context->ctx = ctx;
  403284:	f9000416 	str	x22, [x0, #8]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  403288:	12005c21 	and	w1, w1, #0xffffff
    context->sender_addr = sender_addr;
  40328c:	b9001013 	str	w19, [x0, #16]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  403290:	120c5c21 	and	w1, w1, #0xfff00fff
  403294:	b9024801 	str	w1, [x0, #584]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  403298:	91042001 	add	x1, x0, #0x108
    *rctx = context;
  40329c:	f9002fe0 	str	x0, [sp, #88]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  4032a0:	91028000 	add	x0, x0, #0xa0
  4032a4:	94002d82 	bl	40e8ac <k_msgq_init>
    k_work_init(&context->work, receive_work_handler);
  4032a8:	f94033e0 	ldr	x0, [sp, #96]
  4032ac:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  4032b0:	913a6021 	add	x1, x1, #0xe98
  4032b4:	91006000 	add	x0, x0, #0x18
  4032b8:	94003353 	bl	410004 <k_work_init>
    k_timer_init(&context->timer, receive_timeout_handler, NULL);
  4032bc:	f94033e0 	ldr	x0, [sp, #96]
  4032c0:	d2800002 	mov	x2, #0x0                   	// #0
  4032c4:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  4032c8:	910ff021 	add	x1, x1, #0x3fc
  4032cc:	9100e000 	add	x0, x0, #0x38
  4032d0:	94004043 	bl	4133dc <k_timer_init>
    sys_slist_append(&isotp_recv_ctx_list, &context->node);
  4032d4:	f94033e0 	ldr	x0, [sp, #96]
	return list->tail;
  4032d8:	912b02e1 	add	x1, x23, #0xac0
	parent->next = child;
  4032dc:	f900001f 	str	xzr, [x0]
	return list->tail;
  4032e0:	f9400422 	ldr	x2, [x1, #8]
Z_GENLIST_APPEND(slist, snode)
  4032e4:	b50001a2 	cbnz	x2, 403318 <can_rx_callback+0x478>
	list->head = node;
  4032e8:	f90562e0 	str	x0, [x23, #2752]
	list->tail = node;
  4032ec:	f9000420 	str	x0, [x1, #8]
        receive_can_rx(rctx, frame);
  4032f0:	f9402ff3 	ldr	x19, [sp, #88]
    switch (rctx->state) {
  4032f4:	f9412660 	ldr	x0, [x19, #584]
  4032f8:	530c4c01 	ubfx	w1, w0, #12, #8
  4032fc:	72141c1f 	tst	w0, #0xff000
  403300:	54000120 	b.eq	403324 <can_rx_callback+0x484>  // b.none
  403304:	7100143f 	cmp	w1, #0x5
  403308:	54000a00 	b.eq	403448 <can_rx_callback+0x5a8>  // b.none
    k_work_submit(&rctx->work);
  40330c:	91006260 	add	x0, x19, #0x18
  403310:	940033ca 	bl	410238 <k_work_submit>
  403314:	17ffffb2 	b	4031dc <can_rx_callback+0x33c>
	parent->next = child;
  403318:	f9000040 	str	x0, [x2]
	list->tail = node;
  40331c:	f9000420 	str	x0, [x1, #8]
  403320:	17fffff4 	b	4032f0 <can_rx_callback+0x450>
    switch (frame->data[index] & ISOTP_PCI_TYPE_MASK) {
  403324:	394022a0 	ldrb	w0, [x21, #8]
  403328:	721c0c01 	ands	w1, w0, #0xf0
  40332c:	540005a0 	b.eq	4033e0 <can_rx_callback+0x540>  // b.none
  403330:	7100403f 	cmp	w1, #0x10
  403334:	54fffec1 	b.ne	40330c <can_rx_callback+0x46c>  // b.any
            if (frame->dlc != ISOTP_FF_DL_MIN) {
  403338:	394012a1 	ldrb	w1, [x21, #4]
  40333c:	7100203f 	cmp	w1, #0x8
  403340:	54fffe61 	b.ne	40330c <can_rx_callback+0x46c>  // b.any
    len = ((pci & ISOTP_PCI_FF_DL_UPPER_MASK) << 8) | data[1];
  403344:	394026a1 	ldrb	w1, [x21, #9]
  403348:	53180c00 	ubfiz	w0, w0, #8, #4
  40334c:	2a010000 	orr	w0, w0, w1
    if (!len) {
  403350:	35000060 	cbnz	w0, 40335c <can_rx_callback+0x4bc>
        len = UNALIGNED_GET((uint32_t *)data);
  403354:	b9400aa0 	ldr	w0, [x21, #8]
  403358:	5ac00800 	rev	w0, w0
            rctx->state = ISOTP_RX_STATE_PROCESS_FF;
  40335c:	91092261 	add	x1, x19, #0x248
  403360:	12002c00 	and	w0, w0, #0xfff
  403364:	32130000 	orr	w0, w0, #0x2000
  403368:	79049260 	strh	w0, [x19, #584]
  40336c:	aa0103e0 	mov	x0, x1
            payload_len = CAN_MAX_DLEN - index;
  403370:	528000d4 	mov	w20, #0x6                   	// #6
            rctx->state = ISOTP_RX_STATE_PROCESS_FF;
  403374:	39400821 	ldrb	w1, [x1, #2]
  403378:	121c6c21 	and	w1, w1, #0xfffffff0
  40337c:	39000801 	strb	w1, [x0, #2]
            rctx->sn_expected = 1;
  403380:	52800021 	mov	w1, #0x1                   	// #1
  403384:	39493a60 	ldrb	w0, [x19, #590]
  403388:	33000c20 	bfxil	w0, w1, #0, #4
            index += 2;
  40338c:	52800041 	mov	w1, #0x2                   	// #2
            rctx->sn_expected = 1;
  403390:	39093a60 	strb	w0, [x19, #590]
 * @return The original tail of the buffer.
 */
static inline void *net_buf_add_mem(struct net_buf *buf, const void *mem,
				    size_t len)
{
	return net_buf_simple_add_mem(&buf->b, mem, len);
  403394:	f9404e60 	ldr	x0, [x19, #152]
    net_buf_add_mem(rctx->frag, &frame->data[index], payload_len);
  403398:	11002021 	add	w1, w1, #0x8
  40339c:	92401e82 	and	x2, x20, #0xff
  4033a0:	8b21c2a1 	add	x1, x21, w1, sxtw
  4033a4:	91006000 	add	x0, x0, #0x18
  4033a8:	940025cf 	bl	40cae4 <net_buf_simple_add_mem>
    rctx->rem_len -= payload_len;
  4033ac:	f9412660 	ldr	x0, [x19, #584]
  4033b0:	79449261 	ldrh	w1, [x19, #584]
  4033b4:	4b140000 	sub	w0, w0, w20
  4033b8:	12002c00 	and	w0, w0, #0xfff
  4033bc:	33002c01 	bfxil	w1, w0, #0, #12
  4033c0:	79049261 	strh	w1, [x19, #584]
    int *p_rem_len = net_buf_user_data(rctx->frag);
  4033c4:	aa1303e1 	mov	x1, x19
  4033c8:	f8498c22 	ldr	x2, [x1, #152]!
    *p_rem_len = rctx->rem_len;
  4033cc:	b9003040 	str	w0, [x2, #48]
	return z_impl_k_msgq_put(msgq, data, timeout);
  4033d0:	d2800002 	mov	x2, #0x0                   	// #0
  4033d4:	91028260 	add	x0, x19, #0xa0
  4033d8:	94002d57 	bl	40e934 <z_impl_k_msgq_put>
    LOG_DBG("Enqueued item; remaining length %d, queue size %d", *p_rem_len,
  4033dc:	17ffffcc 	b	40330c <can_rx_callback+0x46c>
            rctx->rem_len = receive_get_sf_length(frame->data, &index);
  4033e0:	79449261 	ldrh	w1, [x19, #584]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  4033e4:	71001c1f 	cmp	w0, #0x7
            rctx->rem_len = receive_get_sf_length(frame->data, &index);
  4033e8:	33002c01 	bfxil	w1, w0, #0, #12
  4033ec:	79049261 	strh	w1, [x19, #584]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  4033f0:	528000e1 	mov	w1, #0x7                   	// #7
  4033f4:	1a819000 	csel	w0, w0, w1, ls  // ls = plast
            if (payload_len > can_dlc_to_bytes(frame->dlc)) {
  4033f8:	394012a1 	ldrb	w1, [x21, #4]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  4033fc:	12001c14 	and	w20, w0, #0xff
	return dlc > 0x0F ? 64 : dlc_table[dlc];
  403400:	71003c3f 	cmp	w1, #0xf
  403404:	540000c8 	b.hi	40341c <can_rx_callback+0x57c>  // b.pmore
            if (payload_len > can_dlc_to_bytes(frame->dlc)) {
  403408:	90000080 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  40340c:	9127cc00 	add	x0, x0, #0x9f3
  403410:	3861c800 	ldrb	w0, [x0, w1, sxtw]
  403414:	6b14001f 	cmp	w0, w20
  403418:	54fff7a3 	b.cc	40330c <can_rx_callback+0x46c>  // b.lo, b.ul, b.last
            rctx->state = ISOTP_RX_STATE_PROCESS_SF;
  40341c:	79449260 	ldrh	w0, [x19, #584]
  403420:	91092261 	add	x1, x19, #0x248
  403424:	12002c00 	and	w0, w0, #0xfff
  403428:	32140000 	orr	w0, w0, #0x1000
  40342c:	79049260 	strh	w0, [x19, #584]
  403430:	aa0103e0 	mov	x0, x1
  403434:	39400821 	ldrb	w1, [x1, #2]
  403438:	121c6c21 	and	w1, w1, #0xfffffff0
  40343c:	39000801 	strb	w1, [x0, #2]
    (*index)++;
  403440:	52800021 	mov	w1, #0x1                   	// #1
            break;
  403444:	17ffffd4 	b	403394 <can_rx_callback+0x4f4>
    if ((frame->data[index] & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_CF) {
  403448:	394022a0 	ldrb	w0, [x21, #8]
  40344c:	121c0c00 	and	w0, w0, #0xf0
  403450:	7100801f 	cmp	w0, #0x20
  403454:	540001e0 	b.eq	403490 <can_rx_callback+0x5f0>  // b.none
    rctx->state = ISOTP_RX_STATE_ERR;
  403458:	b9424a60 	ldr	w0, [x19, #584]
  40345c:	528e0001 	mov	w1, #0x7000                	// #28672
  403460:	72bf4001 	movk	w1, #0xfa00, lsl #16
  403464:	12005c00 	and	w0, w0, #0xffffff
  403468:	120c5c00 	and	w0, w0, #0xfff00fff
  40346c:	2a010000 	orr	w0, w0, w1
  403470:	b9024a60 	str	w0, [x19, #584]
        k_work_submit(&rctx->work); // to dispatch complete message
  403474:	91006260 	add	x0, x19, #0x18
  403478:	94003370 	bl	410238 <k_work_submit>
            if (rctx->state == ISOTP_RX_STATE_WAIT_CF) {
  40347c:	f9412660 	ldr	x0, [x19, #584]
  403480:	530c4c00 	ubfx	w0, w0, #12, #8
  403484:	7100141f 	cmp	w0, #0x5
  403488:	54fff421 	b.ne	40330c <can_rx_callback+0x46c>  // b.any
  40348c:	17ffff54 	b	4031dc <can_rx_callback+0x33c>
	z_impl_k_timer_start(timer, duration, period);
  403490:	d2800002 	mov	x2, #0x0                   	// #0
  403494:	9100e260 	add	x0, x19, #0x38
  403498:	d2800c81 	mov	x1, #0x64                  	// #100
  40349c:	94003fd7 	bl	4133f8 <z_impl_k_timer_start>
    if ((frame->data[index++] & ISOTP_PCI_SN_MASK) != rctx->sn_expected++) {
  4034a0:	f9412660 	ldr	x0, [x19, #584]
  4034a4:	39493a62 	ldrb	w2, [x19, #590]
  4034a8:	394022a1 	ldrb	w1, [x21, #8]
  4034ac:	d370cc00 	ubfx	x0, x0, #48, #4
  4034b0:	11000403 	add	w3, w0, #0x1
  4034b4:	12000c21 	and	w1, w1, #0xf
  4034b8:	33000c62 	bfxil	w2, w3, #0, #4
  4034bc:	39093a62 	strb	w2, [x19, #590]
  4034c0:	6b00003f 	cmp	w1, w0
  4034c4:	54000220 	b.eq	403508 <can_rx_callback+0x668>  // b.none
        LOG_ERR("Sequence number mismatch");
  4034c8:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  4034cc:	52800000 	mov	w0, #0x0                   	// #0
  4034d0:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  4034d4:	52800005 	mov	w5, #0x0                   	// #0
  4034d8:	f9478821 	ldr	x1, [x1, #3856]
  4034dc:	9126ccc6 	add	x6, x6, #0x9b3
  4034e0:	d2800004 	mov	x4, #0x0                   	// #0
  4034e4:	d2800003 	mov	x3, #0x0                   	// #0
  4034e8:	52800022 	mov	w2, #0x1                   	// #1
  4034ec:	97fffb5c 	bl	40225c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  4034f0:	b9424a60 	ldr	w0, [x19, #584]
  4034f4:	528e0001 	mov	w1, #0x7000                	// #28672
  4034f8:	72bf8001 	movk	w1, #0xfc00, lsl #16
  4034fc:	12005c00 	and	w0, w0, #0xffffff
  403500:	120c5c00 	and	w0, w0, #0xfff00fff
  403504:	17ffffda 	b	40346c <can_rx_callback+0x5cc>
    data_len = MIN(rctx->rem_len, can_dlc_to_bytes(frame->dlc) - index);
  403508:	f9412662 	ldr	x2, [x19, #584]
  40350c:	394012a1 	ldrb	w1, [x21, #4]
  403510:	12002c42 	and	w2, w2, #0xfff
  403514:	71003c3f 	cmp	w1, #0xf
  403518:	54000488 	b.hi	4035a8 <can_rx_callback+0x708>  // b.pmore
  40351c:	90000080 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  403520:	9127cc00 	add	x0, x0, #0x9f3
  403524:	3861c801 	ldrb	w1, [x0, w1, sxtw]
  403528:	51000421 	sub	w1, w1, #0x1
  40352c:	6b01005f 	cmp	w2, w1
  403530:	f9404e60 	ldr	x0, [x19, #152]
  403534:	1a82a034 	csel	w20, w1, w2, ge  // ge = tcont
  403538:	1a82a022 	csel	w2, w1, w2, ge  // ge = tcont
  40353c:	910026a1 	add	x1, x21, #0x9
  403540:	91006000 	add	x0, x0, #0x18
  403544:	94002568 	bl	40cae4 <net_buf_simple_add_mem>
    rctx->rem_len -= data_len;
  403548:	f9412660 	ldr	x0, [x19, #584]
  40354c:	79449261 	ldrh	w1, [x19, #584]
  403550:	4b140000 	sub	w0, w0, w20
  403554:	12002c00 	and	w0, w0, #0xfff
  403558:	33002c01 	bfxil	w1, w0, #0, #12
  40355c:	79049261 	strh	w1, [x19, #584]
    int *p_rem_len = net_buf_user_data(rctx->frag);
  403560:	aa1303e1 	mov	x1, x19
  403564:	f8498c22 	ldr	x2, [x1, #152]!
    *p_rem_len = rctx->rem_len;
  403568:	b9003040 	str	w0, [x2, #48]
	return z_impl_k_msgq_put(msgq, data, timeout);
  40356c:	d2800002 	mov	x2, #0x0                   	// #0
  403570:	91028260 	add	x0, x19, #0xa0
  403574:	94002cf0 	bl	40e934 <z_impl_k_msgq_put>
    if (rctx->rem_len == 0) {
  403578:	79449261 	ldrh	w1, [x19, #584]
  40357c:	12002c20 	and	w0, w1, #0xfff
  403580:	f2402c3f 	tst	x1, #0xfff
  403584:	54000161 	b.ne	4035b0 <can_rx_callback+0x710>  // b.any
        rctx->state = ISOTP_RX_STATE_RECYCLE;
  403588:	91092261 	add	x1, x19, #0x248
  40358c:	32114000 	orr	w0, w0, #0xffff8000
  403590:	79049260 	strh	w0, [x19, #584]
  403594:	aa0103e0 	mov	x0, x1
  403598:	39400821 	ldrb	w1, [x1, #2]
  40359c:	121c6c21 	and	w1, w1, #0xfffffff0
  4035a0:	39000801 	strb	w1, [x0, #2]
  4035a4:	17ffffb4 	b	403474 <can_rx_callback+0x5d4>
  4035a8:	52800801 	mov	w1, #0x40                  	// #64
  4035ac:	17ffffdf 	b	403528 <can_rx_callback+0x688>
    if (rctx->ctx->opts->bs && !--rctx->bs) {
  4035b0:	f9400662 	ldr	x2, [x19, #8]
  4035b4:	f9400841 	ldr	x1, [x2, #16]
  4035b8:	39400021 	ldrb	w1, [x1]
  4035bc:	34fff601 	cbz	w1, 40347c <can_rx_callback+0x5dc>
  4035c0:	39493661 	ldrb	w1, [x19, #589]
  4035c4:	51000421 	sub	w1, w1, #0x1
  4035c8:	12001c21 	and	w1, w1, #0xff
  4035cc:	39093661 	strb	w1, [x19, #589]
  4035d0:	35fff561 	cbnz	w1, 40347c <can_rx_callback+0x5dc>
        rctx->bs = rctx->ctx->opts->bs;
  4035d4:	f9400841 	ldr	x1, [x2, #16]
        rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  4035d8:	32140400 	orr	w0, w0, #0x3000
        rctx->bs = rctx->ctx->opts->bs;
  4035dc:	39400021 	ldrb	w1, [x1]
  4035e0:	39093661 	strb	w1, [x19, #589]
        rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  4035e4:	91092261 	add	x1, x19, #0x248
  4035e8:	79049260 	strh	w0, [x19, #584]
  4035ec:	aa0103e0 	mov	x0, x1
  4035f0:	39400821 	ldrb	w1, [x1, #2]
  4035f4:	121c6c21 	and	w1, w1, #0xfffffff0
  4035f8:	39000801 	strb	w1, [x0, #2]
            if (rctx->state == ISOTP_RX_STATE_WAIT_CF) {
  4035fc:	17ffff44 	b	40330c <can_rx_callback+0x46c>

0000000000403600 <isotp_fast_bind>:
{
  403600:	d10143ff 	sub	sp, sp, #0x50
  403604:	a9017bfd 	stp	x29, x30, [sp, #16]
  403608:	910043fd 	add	x29, sp, #0x10
  40360c:	f90013f3 	str	x19, [sp, #32]
  403610:	aa0003f3 	mov	x19, x0
  403614:	aa0103e0 	mov	x0, x1
  403618:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40361c:	f9476821 	ldr	x1, [x1, #3792]
  403620:	f9400028 	ldr	x8, [x1]
  403624:	f90027e8 	str	x8, [sp, #72]
  403628:	d2800008 	mov	x8, #0x0                   	// #0
	list->head = NULL;
  40362c:	b0000141 	adrp	x1, 42c000 <__dso_handle>
  403630:	912b4028 	add	x8, x1, #0xad0
    ctx->recv_callback = recv_callback;
  403634:	a9011263 	stp	x3, x4, [x19, #16]
  403638:	f905683f 	str	xzr, [x1, #2768]
  40363c:	b0000141 	adrp	x1, 42c000 <__dso_handle>
	list->tail = NULL;
  403640:	f900051f 	str	xzr, [x8, #8]
	list->head = NULL;
  403644:	912b0028 	add	x8, x1, #0xac0
  403648:	f905603f 	str	xzr, [x1, #2752]
    filter->id = my_addr;
  40364c:	f9401fe1 	ldr	x1, [sp, #56]
	list->tail = NULL;
  403650:	f900051f 	str	xzr, [x8, #8]
    ctx->can_dev = can_dev;
  403654:	f9000260 	str	x0, [x19]
    ctx->recv_error_callback = recv_error_callback;
  403658:	a9021a65 	stp	x5, x6, [x19, #32]
    filter->id = my_addr;
  40365c:	92030821 	and	x1, x1, #0xe0000000e0000000
    ctx->sent_callback = sent_callback;
  403660:	f9001a67 	str	x7, [x19, #48]
    ctx->my_addr = my_addr;
  403664:	b9003a62 	str	w2, [x19, #56]
    filter->id = my_addr;
  403668:	92407042 	and	x2, x2, #0x1fffffff
  40366c:	a9047e7f 	stp	xzr, xzr, [x19, #64]
  403670:	b2584442 	orr	x2, x2, #0x3ffff0000000000
  403674:	aa010042 	orr	x2, x2, x1
                    | ((opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FILTER_FDF : 0);
  403678:	39400861 	ldrb	w1, [x3, #2]
	return api->add_rx_filter(dev, callback, user_data, filter);
  40367c:	9100e3e3 	add	x3, sp, #0x38
    filter->id = my_addr;
  403680:	f9001fe2 	str	x2, [sp, #56]
                    | ((opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FILTER_FDF : 0);
  403684:	528000a2 	mov	w2, #0x5                   	// #5
  403688:	121d0021 	and	w1, w1, #0x8
  40368c:	2a020021 	orr	w1, w1, w2
    filter->flags = CAN_FILTER_DATA | CAN_FILTER_IDE
  403690:	390103e1 	strb	w1, [sp, #64]
  403694:	f9400801 	ldr	x1, [x0, #16]
  403698:	aa1303e2 	mov	x2, x19
  40369c:	f9401824 	ldr	x4, [x1, #48]
  4036a0:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  4036a4:	913a8021 	add	x1, x1, #0xea0
  4036a8:	d63f0080 	blr	x4
    ctx->filter_id = can_add_rx_filter(ctx->can_dev, can_rx_callback, ctx, &filter);
  4036ac:	b9000a60 	str	w0, [x19, #8]
    LOG_INF("Successfully bound to %x:%x", filter.id, filter.mask);
  4036b0:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  4036b4:	52800062 	mov	w2, #0x3                   	// #3
  4036b8:	f9401fe7 	ldr	x7, [sp, #56]
  4036bc:	90000086 	adrp	x6, 413000 <sys_clock_announce+0x19c>
  4036c0:	f9478821 	ldr	x1, [x1, #3856]
  4036c4:	912730c6 	add	x6, x6, #0x9cc
  4036c8:	d360f0e0 	ubfx	x0, x7, #32, #29
  4036cc:	b90003e0 	str	w0, [sp]
  4036d0:	120070e7 	and	w7, w7, #0x1fffffff
  4036d4:	52800000 	mov	w0, #0x0                   	// #0
  4036d8:	52800005 	mov	w5, #0x0                   	// #0
  4036dc:	d2800004 	mov	x4, #0x0                   	// #0
  4036e0:	d2800003 	mov	x3, #0x0                   	// #0
  4036e4:	97fffade 	bl	40225c <z_log_msg_runtime_create.constprop.0>
}
  4036e8:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4036ec:	f9476800 	ldr	x0, [x0, #3792]
  4036f0:	f94027e2 	ldr	x2, [sp, #72]
  4036f4:	f9400001 	ldr	x1, [x0]
  4036f8:	eb010042 	subs	x2, x2, x1
  4036fc:	d2800001 	mov	x1, #0x0                   	// #0
  403700:	54000040 	b.eq	403708 <isotp_fast_bind+0x108>  // b.none
  403704:	97fff707 	bl	401320 <__stack_chk_fail@plt>
  403708:	52800000 	mov	w0, #0x0                   	// #0
  40370c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  403710:	f94013f3 	ldr	x19, [sp, #32]
  403714:	910143ff 	add	sp, sp, #0x50
  403718:	d65f03c0 	ret

000000000040371c <isotp_fast_unbind>:
#endif

int isotp_fast_unbind(struct isotp_fast_ctx *ctx)
{
  40371c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  403720:	910003fd 	mov	x29, sp
  403724:	a90153f3 	stp	x19, x20, [sp, #16]
  403728:	aa0003f3 	mov	x19, x0
  40372c:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403730:	f90013f5 	str	x21, [sp, #32]
  403734:	f9476800 	ldr	x0, [x0, #3792]
  403738:	f9400001 	ldr	x1, [x0]
  40373c:	f9001fe1 	str	x1, [sp, #56]
  403740:	d2800001 	mov	x1, #0x0                   	// #0
    if (ctx->filter_id >= 0 && ctx->can_dev) {
  403744:	b9400a61 	ldr	w1, [x19, #8]
  403748:	37f800c1 	tbnz	w1, #31, 403760 <isotp_fast_unbind+0x44>
  40374c:	f9400260 	ldr	x0, [x19]
  403750:	b4000080 	cbz	x0, 403760 <isotp_fast_unbind+0x44>
	return api->remove_rx_filter(dev, filter_id);
  403754:	f9400802 	ldr	x2, [x0, #16]
  403758:	f9401c42 	ldr	x2, [x2, #56]
  40375c:	d63f0040 	blr	x2
	return list->head;
  403760:	f9402260 	ldr	x0, [x19, #64]
    }

#ifdef CONFIG_ISOTP_FAST_BLOCKING_RECEIVE
    struct isotp_fast_recv_await_ctx *actx;
    struct isotp_fast_recv_await_ctx *next;
    SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&ctx->wait_recv_list, actx, next, node)
  403764:	b5000120 	cbnz	x0, 403788 <isotp_fast_unbind+0x6c>
    {
        free_recv_await_ctx(ctx, &actx);
    }
#endif
    return ISOTP_N_OK;
}
  403768:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40376c:	f9476800 	ldr	x0, [x0, #3792]
  403770:	f9401fe2 	ldr	x2, [sp, #56]
  403774:	f9400001 	ldr	x1, [x0]
  403778:	eb010042 	subs	x2, x2, x1
  40377c:	d2800001 	mov	x1, #0x0                   	// #0
  403780:	540001c0 	b.eq	4037b8 <isotp_fast_unbind+0x9c>  // b.none
  403784:	97fff6e7 	bl	401320 <__stack_chk_fail@plt>
    SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&ctx->wait_recv_list, actx, next, node)
  403788:	f9001be0 	str	x0, [sp, #48]
        free_recv_await_ctx(ctx, &actx);
  40378c:	9100c3f5 	add	x21, sp, #0x30
	return node->next;
  403790:	f9400014 	ldr	x20, [x0]
    SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&ctx->wait_recv_list, actx, next, node)
  403794:	f9401be0 	ldr	x0, [sp, #48]
  403798:	b4fffe80 	cbz	x0, 403768 <isotp_fast_unbind+0x4c>
        free_recv_await_ctx(ctx, &actx);
  40379c:	aa1503e1 	mov	x1, x21
  4037a0:	aa1303e0 	mov	x0, x19
  4037a4:	97fffba0 	bl	402624 <free_recv_await_ctx>
    SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&ctx->wait_recv_list, actx, next, node)
  4037a8:	f9001bf4 	str	x20, [sp, #48]
  4037ac:	b4ffff54 	cbz	x20, 403794 <isotp_fast_unbind+0x78>
  4037b0:	f9400294 	ldr	x20, [x20]
  4037b4:	17fffff8 	b	403794 <isotp_fast_unbind+0x78>
}
  4037b8:	52800000 	mov	w0, #0x0                   	// #0
  4037bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4037c0:	f94013f5 	ldr	x21, [sp, #32]
  4037c4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4037c8:	d65f03c0 	ret

00000000004037cc <isotp_fast_recv>:

#ifdef CONFIG_ISOTP_FAST_BLOCKING_RECEIVE
int isotp_fast_recv(struct isotp_fast_ctx *ctx, struct can_filter sender, uint8_t *buf, size_t size,
                    k_timeout_t timeout)
{
  4037cc:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  4037d0:	910003fd 	mov	x29, sp
  4037d4:	a90153f3 	stp	x19, x20, [sp, #16]
  4037d8:	aa0003f4 	mov	x20, x0
  4037dc:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4037e0:	f90033e1 	str	x1, [sp, #96]
  4037e4:	d360f033 	ubfx	x19, x1, #32, #29
  4037e8:	f9476800 	ldr	x0, [x0, #3792]
  4037ec:	a9025bf5 	stp	x21, x22, [sp, #32]
  4037f0:	b94063f5 	ldr	w21, [sp, #96]
  4037f4:	a90363f7 	stp	x23, x24, [sp, #48]
  4037f8:	aa0303f6 	mov	x22, x3
  4037fc:	aa0403f7 	mov	x23, x4
  403800:	a9046bf9 	stp	x25, x26, [sp, #64]
  403804:	aa0503f8 	mov	x24, x5
  403808:	d34072b5 	ubfx	x21, x21, #0, #29
  40380c:	a90573fb 	stp	x27, x28, [sp, #80]
  403810:	b9006be2 	str	w2, [sp, #104]
  403814:	f9400002 	ldr	x2, [x0]
  403818:	f90047e2 	str	x2, [sp, #136]
  40381c:	d2800002 	mov	x2, #0x0                   	// #0
	return list->head;
  403820:	f9402280 	ldr	x0, [x20, #64]
    /* first try to find in-flight context */
    bool found = false;
    struct isotp_fast_recv_await_ctx *actx;
    SYS_SLIST_FOR_EACH_CONTAINER(&ctx->wait_recv_list, actx, node)
  403824:	f9003fe0 	str	x0, [sp, #120]
  403828:	b5000580 	cbnz	x0, 4038d8 <isotp_fast_recv+0x10c>

    int ret;
    if (!found) {
        /* create a new context */
        LOG_DBG("Creating new await context matching sender %x:%x", sender.id, sender.mask);
        int err = k_mem_slab_alloc(&isotp_recv_await_ctx_slab, (void **)&actx, K_NO_WAIT);
  40382c:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403830:	9101e3f9 	add	x25, sp, #0x78
  403834:	aa1903e1 	mov	x1, x25
  403838:	d2800002 	mov	x2, #0x0                   	// #0
  40383c:	f947b800 	ldr	x0, [x0, #3952]
  403840:	94002a1f 	bl	40e0bc <k_mem_slab_alloc>
        if (err != 0) {
  403844:	350007c0 	cbnz	w0, 40393c <isotp_fast_recv+0x170>
            return ISOTP_NO_CTX_LEFT;
        }

        actx->sender = sender;
  403848:	f9403fe0 	ldr	x0, [sp, #120]
  40384c:	f94033e1 	ldr	x1, [sp, #96]
  403850:	f9000401 	str	x1, [x0, #8]
  403854:	b9406be1 	ldr	w1, [sp, #104]
  403858:	b9001001 	str	w1, [x0, #16]
	return z_impl_k_sem_init(sem, initial_count, limit);
  40385c:	52800001 	mov	w1, #0x0                   	// #0
  403860:	91006000 	add	x0, x0, #0x18
  403864:	52800022 	mov	w2, #0x1                   	// #1
  403868:	94002fe7 	bl	40f804 <z_impl_k_sem_init>
        k_sem_init(&actx->sem, 0, 1);
        sys_slist_append(&ctx->wait_recv_list, &actx->node);
  40386c:	f9403fe0 	ldr	x0, [sp, #120]
	parent->next = child;
  403870:	f900001f 	str	xzr, [x0]
	return list->tail;
  403874:	f9402681 	ldr	x1, [x20, #72]
Z_GENLIST_APPEND(slist, snode)
  403878:	b5000421 	cbnz	x1, 4038fc <isotp_fast_recv+0x130>
	list->tail = node;
  40387c:	a9040280 	stp	x0, x0, [x20, #64]
	return list->head;
  403880:	b0000140 	adrp	x0, 42c000 <__dso_handle>
  403884:	f9456006 	ldr	x6, [x0, #2752]

        /* try to find matching receive context in case there is already one pending */
        struct isotp_fast_recv_ctx *rctx;
        bool wait = true;
        SYS_SLIST_FOR_EACH_CONTAINER(&isotp_recv_ctx_list, rctx, node)
  403888:	b4000446 	cbz	x6, 403910 <isotp_fast_recv+0x144>
        {
            if ((sender.id & sender.mask) == (rctx->sender_addr & sender.mask) && !rctx->pending) {
  40388c:	0a150275 	and	w21, w19, w21
  403890:	b94010c0 	ldr	w0, [x6, #16]
  403894:	0a000260 	and	w0, w19, w0
  403898:	6b0002bf 	cmp	w21, w0
  40389c:	54000361 	b.ne	403908 <isotp_fast_recv+0x13c>  // b.any
  4038a0:	39493cc0 	ldrb	w0, [x6, #591]
  4038a4:	35000320 	cbnz	w0, 403908 <isotp_fast_recv+0x13c>
                LOG_DBG("Matched await context %x:%x to sender %x", sender.id, sender.mask,
                        rctx->sender_addr);
                actx->rctx = rctx;
  4038a8:	f9403fe0 	ldr	x0, [sp, #120]
  4038ac:	f9002006 	str	x6, [x0, #64]
                rctx->pending = true;
  4038b0:	52800020 	mov	w0, #0x1                   	// #1
  4038b4:	39093cc0 	strb	w0, [x6, #591]
            }
            LOG_DBG("Matched; processing message");
        }
    }

    if (actx->rctx->error != 0) {
  4038b8:	f9403fe0 	ldr	x0, [sp, #120]
  4038bc:	f9402000 	ldr	x0, [x0, #64]
  4038c0:	39c92c13 	ldrsb	w19, [x0, #587]
  4038c4:	34000873 	cbz	w19, 4039d0 <isotp_fast_recv+0x204>
    int rem_len = 0;
    while ((ret = k_msgq_get(&actx->rctx->recv_queue, &frag, timeout)) == 0) {
        if (actx->rctx->error != 0) {
            LOG_DBG("Error %d occurred", actx->rctx->error);
            ret = actx->rctx->error;
            free_recv_await_ctx(ctx, &actx);
  4038c8:	9101e3e1 	add	x1, sp, #0x78
  4038cc:	aa1403e0 	mov	x0, x20
  4038d0:	97fffb55 	bl	402624 <free_recv_await_ctx>
            return ret;
  4038d4:	1400001b 	b	403940 <isotp_fast_recv+0x174>
        if (actx->sender.id == sender.id && actx->sender.mask == sender.mask) {
  4038d8:	f9400401 	ldr	x1, [x0, #8]
  4038dc:	d3407022 	ubfx	x2, x1, #0, #29
  4038e0:	6b15005f 	cmp	w2, w21
  4038e4:	54000081 	b.ne	4038f4 <isotp_fast_recv+0x128>  // b.any
  4038e8:	d360f021 	ubfx	x1, x1, #32, #29
  4038ec:	6b13003f 	cmp	w1, w19
  4038f0:	54fffe40 	b.eq	4038b8 <isotp_fast_recv+0xec>  // b.none
	return node->next;
  4038f4:	f9400000 	ldr	x0, [x0]
  4038f8:	17ffffcb 	b	403824 <isotp_fast_recv+0x58>
	parent->next = child;
  4038fc:	f9000020 	str	x0, [x1]
	list->tail = node;
  403900:	f9002680 	str	x0, [x20, #72]
}
  403904:	17ffffdf 	b	403880 <isotp_fast_recv+0xb4>
	return node->next;
  403908:	f94000c6 	ldr	x6, [x6]
        SYS_SLIST_FOR_EACH_CONTAINER(&isotp_recv_ctx_list, rctx, node)
  40390c:	b5fffc26 	cbnz	x6, 403890 <isotp_fast_recv+0xc4>
            ret = k_sem_take(&actx->sem, timeout);
  403910:	f9403fe0 	ldr	x0, [sp, #120]
  403914:	91006000 	add	x0, x0, #0x18
	return z_impl_k_sem_take(sem, timeout);
  403918:	aa1803e1 	mov	x1, x24
  40391c:	94002ffc 	bl	40f90c <z_impl_k_sem_take>
            if (ret == -EAGAIN) {
  403920:	31002c1f 	cmn	w0, #0xb
  403924:	54fffca1 	b.ne	4038b8 <isotp_fast_recv+0xec>  // b.any
                free_recv_await_ctx(ctx, &actx);
  403928:	aa1903e1 	mov	x1, x25
    actx->rctx->pending = false;
    if (rem_len == 0) {
        free_recv_await_ctx(ctx, &actx);
    }
    if (ret == -EAGAIN) {
        free_recv_await_ctx(ctx, &actx);
  40392c:	aa1403e0 	mov	x0, x20
        LOG_DBG("Timed out waiting on more packets");
        return ISOTP_RECV_TIMEOUT;
  403930:	128001b3 	mov	w19, #0xfffffff2            	// #-14
        free_recv_await_ctx(ctx, &actx);
  403934:	97fffb3c 	bl	402624 <free_recv_await_ctx>
        return ISOTP_RECV_TIMEOUT;
  403938:	14000002 	b	403940 <isotp_fast_recv+0x174>
            return ISOTP_NO_CTX_LEFT;
  40393c:	12800193 	mov	w19, #0xfffffff3            	// #-13
    }
    return pos;
}
  403940:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403944:	f9476800 	ldr	x0, [x0, #3792]
  403948:	f94047e2 	ldr	x2, [sp, #136]
  40394c:	f9400001 	ldr	x1, [x0]
  403950:	eb010042 	subs	x2, x2, x1
  403954:	d2800001 	mov	x1, #0x0                   	// #0
  403958:	54000680 	b.eq	403a28 <isotp_fast_recv+0x25c>  // b.none
  40395c:	97fff671 	bl	401320 <__stack_chk_fail@plt>
        if (actx->rctx->error != 0) {
  403960:	f9403fe0 	ldr	x0, [sp, #120]
  403964:	f9402000 	ldr	x0, [x0, #64]
  403968:	39c92c00 	ldrsb	w0, [x0, #587]
  40396c:	34000060 	cbz	w0, 403978 <isotp_fast_recv+0x1ac>
            ret = actx->rctx->error;
  403970:	2a0003f3 	mov	w19, w0
  403974:	17ffffd5 	b	4038c8 <isotp_fast_recv+0xfc>
        rem_len = *(int *)net_buf_user_data(frag);
  403978:	f94043fc 	ldr	x28, [sp, #128]
        int len = MIN(frag->len, size - pos);
  40397c:	cb33c2f5 	sub	x21, x23, w19, sxtw
  403980:	79404380 	ldrh	w0, [x28, #32]
  403984:	f9400f81 	ldr	x1, [x28, #24]
  403988:	eb0002bf 	cmp	x21, x0
  40398c:	9a8092b5 	csel	x21, x21, x0, ls  // ls = plast
        rem_len = *(int *)net_buf_user_data(frag);
  403990:	b940339b 	ldr	w27, [x28, #48]
  403994:	aa1503e2 	mov	x2, x21
  403998:	aa1603e0 	mov	x0, x22
        pos += len;
  40399c:	0b150273 	add	w19, w19, w21
  4039a0:	97fff5f4 	bl	401170 <memcpy@plt>
        net_buf_unref(frag);
  4039a4:	aa1c03e0 	mov	x0, x28
        buf += len;
  4039a8:	8b1502d6 	add	x22, x22, x21
        net_buf_unref(frag);
  4039ac:	940023df 	bl	40c928 <net_buf_unref>
        if (size - pos < (CAN_MAX_DLEN - 1) && rem_len > (CAN_MAX_DLEN - 1)) {
  4039b0:	cb33c2e0 	sub	x0, x23, w19, sxtw
  4039b4:	f100181f 	cmp	x0, #0x6
  4039b8:	54000068 	b.hi	4039c4 <isotp_fast_recv+0x1f8>  // b.pmore
  4039bc:	71001f7f 	cmp	w27, #0x7
  4039c0:	540001e8 	b.hi	4039fc <isotp_fast_recv+0x230>  // b.pmore
        if (rem_len == 0) {
  4039c4:	350000db 	cbnz	w27, 4039dc <isotp_fast_recv+0x210>
    while ((ret = k_msgq_get(&actx->rctx->recv_queue, &frag, timeout)) == 0) {
  4039c8:	52800019 	mov	w25, #0x0                   	// #0
  4039cc:	1400000c 	b	4039fc <isotp_fast_recv+0x230>
	return z_impl_k_msgq_get(msgq, data, timeout);
  4039d0:	910203fa 	add	x26, sp, #0x80
    int rem_len = 0;
  4039d4:	5280001b 	mov	w27, #0x0                   	// #0
    int pos = 0;
  4039d8:	52800013 	mov	w19, #0x0                   	// #0
    while ((ret = k_msgq_get(&actx->rctx->recv_queue, &frag, timeout)) == 0) {
  4039dc:	f9403fe0 	ldr	x0, [sp, #120]
  4039e0:	f9402000 	ldr	x0, [x0, #64]
  4039e4:	91028000 	add	x0, x0, #0xa0
  4039e8:	aa1803e2 	mov	x2, x24
  4039ec:	aa1a03e1 	mov	x1, x26
  4039f0:	94002c77 	bl	40ebcc <z_impl_k_msgq_get>
  4039f4:	2a0003f9 	mov	w25, w0
  4039f8:	34fffb40 	cbz	w0, 403960 <isotp_fast_recv+0x194>
    actx->rctx->pending = false;
  4039fc:	f9403fe0 	ldr	x0, [sp, #120]
  403a00:	f9402000 	ldr	x0, [x0, #64]
  403a04:	39093c1f 	strb	wzr, [x0, #591]
    if (rem_len == 0) {
  403a08:	3500009b 	cbnz	w27, 403a18 <isotp_fast_recv+0x24c>
        free_recv_await_ctx(ctx, &actx);
  403a0c:	9101e3e1 	add	x1, sp, #0x78
  403a10:	aa1403e0 	mov	x0, x20
  403a14:	97fffb04 	bl	402624 <free_recv_await_ctx>
    if (ret == -EAGAIN) {
  403a18:	31002f3f 	cmn	w25, #0xb
  403a1c:	54fff921 	b.ne	403940 <isotp_fast_recv+0x174>  // b.any
        free_recv_await_ctx(ctx, &actx);
  403a20:	9101e3e1 	add	x1, sp, #0x78
  403a24:	17ffffc2 	b	40392c <isotp_fast_recv+0x160>
}
  403a28:	2a1303e0 	mov	w0, w19
  403a2c:	a94153f3 	ldp	x19, x20, [sp, #16]
  403a30:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403a34:	a94363f7 	ldp	x23, x24, [sp, #48]
  403a38:	a9446bf9 	ldp	x25, x26, [sp, #64]
  403a3c:	a94573fb 	ldp	x27, x28, [sp, #80]
  403a40:	a8c97bfd 	ldp	x29, x30, [sp], #144
  403a44:	d65f03c0 	ret

0000000000403a48 <isotp_fast_send>:
#endif /* CONFIG_ISOTP_FAST_BLOCKING_RECEIVE */

int isotp_fast_send(struct isotp_fast_ctx *ctx, const uint8_t *data, size_t len,
                    const isotp_fast_node_id their_id, void *cb_arg)
{
  403a48:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    const isotp_fast_msg_id recipient_addr = (ctx->my_addr & 0xFFFF0000)
                                             | (isotp_fast_get_addr_recipient(ctx->my_addr))
                                             | (their_id << ISOTP_FIXED_ADDR_TA_POS);
  403a4c:	53181c63 	ubfiz	w3, w3, #8, #8
{
  403a50:	910003fd 	mov	x29, sp
  403a54:	a90363f7 	stp	x23, x24, [sp, #48]
  403a58:	aa0403f7 	mov	x23, x4
  403a5c:	90000144 	adrp	x4, 42b000 <__FRAME_END__+0xfd74>
  403a60:	a90153f3 	stp	x19, x20, [sp, #16]
  403a64:	aa0203f3 	mov	x19, x2
  403a68:	f9476884 	ldr	x4, [x4, #3792]
  403a6c:	a9025bf5 	stp	x21, x22, [sp, #32]
  403a70:	f90023f9 	str	x25, [sp, #64]
  403a74:	aa0003f9 	mov	x25, x0
  403a78:	f9400085 	ldr	x5, [x4]
  403a7c:	f90037e5 	str	x5, [sp, #104]
  403a80:	d2800005 	mov	x5, #0x0                   	// #0
    const isotp_fast_msg_id recipient_addr = (ctx->my_addr & 0xFFFF0000)
  403a84:	b9403804 	ldr	w4, [x0, #56]
  403a88:	12103c96 	and	w22, w4, #0xffff0000
  403a8c:	2a0302d6 	orr	w22, w22, w3
  403a90:	d3483c84 	ubfx	x4, x4, #8, #8
  403a94:	2a0402d6 	orr	w22, w22, w4
    if (len <= (CAN_MAX_DLEN - ISOTP_FAST_SF_LEN_BYTE)) {
  403a98:	f1001c5f 	cmp	x2, #0x7
  403a9c:	540004a8 	b.hi	403b30 <isotp_fast_send+0xe8>  // b.pmore
        struct can_frame frame = {
  403aa0:	52800000 	mov	w0, #0x0                   	// #0
            .dlc = can_bytes_to_dlc(len + ISOTP_FAST_SF_LEN_BYTE),
  403aa4:	12001c53 	and	w19, w2, #0xff
        struct can_frame frame = {
  403aa8:	330072c0 	bfxil	w0, w22, #0, #29
  403aac:	a905ffff 	stp	xzr, xzr, [sp, #88]
  403ab0:	b9005be0 	str	w0, [sp, #88]
            .dlc = can_bytes_to_dlc(len + ISOTP_FAST_SF_LEN_BYTE),
  403ab4:	11000660 	add	w0, w19, #0x1
  403ab8:	97fff9e8 	bl	402258 <can_bytes_to_dlc>
        struct can_frame frame = {
  403abc:	390173e0 	strb	w0, [sp, #92]
            .id = recipient_addr,
            .flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  403ac0:	f9400b20 	ldr	x0, [x25, #16]
  403ac4:	39400803 	ldrb	w3, [x0, #2]
  403ac8:	910187e0 	add	x0, sp, #0x61
        }
        else {
            frame.data[0] = (uint8_t)len;
        }
#else
        frame.data[0] = (uint8_t)len;
  403acc:	390183f3 	strb	w19, [sp, #96]
            .flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  403ad0:	d341fc63 	lsr	x3, x3, #1
  403ad4:	121e0063 	and	w3, w3, #0x4
  403ad8:	32000063 	orr	w3, w3, #0x1
        struct can_frame frame = {
  403adc:	390177e3 	strb	w3, [sp, #93]
  403ae0:	d28000e3 	mov	x3, #0x7                   	// #7
  403ae4:	97fff5db 	bl	401250 <__memcpy_chk@plt>
#endif
        memcpy(&frame.data[index], data, len);
        int ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), NULL, NULL);
  403ae8:	f9400320 	ldr	x0, [x25]
  403aec:	d2800c82 	mov	x2, #0x64                  	// #100
  403af0:	910163e1 	add	x1, sp, #0x58
  403af4:	d2800004 	mov	x4, #0x0                   	// #0
  403af8:	d2800003 	mov	x3, #0x0                   	// #0
  403afc:	94002468 	bl	40cc9c <z_impl_can_send>
        ctx->sent_callback(ret, cb_arg);
        return ISOTP_N_OK;
  403b00:	52800015 	mov	w21, #0x0                   	// #0
        ctx->sent_callback(ret, cb_arg);
  403b04:	f9401b22 	ldr	x2, [x25, #48]
  403b08:	aa1703e1 	mov	x1, x23
  403b0c:	d63f0040 	blr	x2
        k_timer_init(&context->timer, send_timeout_handler, NULL);

        k_work_submit(&context->work);
    }
    return ISOTP_N_OK;
  403b10:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403b14:	f9476800 	ldr	x0, [x0, #3792]
  403b18:	f94037e2 	ldr	x2, [sp, #104]
  403b1c:	f9400001 	ldr	x1, [x0]
  403b20:	eb010042 	subs	x2, x2, x1
  403b24:	d2800001 	mov	x1, #0x0                   	// #0
  403b28:	54000640 	b.eq	403bf0 <isotp_fast_send+0x1a8>  // b.none
  403b2c:	97fff5fd 	bl	401320 <__stack_chk_fail@plt>
        if (len > ISOTP_FAST_MAX_LEN) {
  403b30:	f13ffc5f 	cmp	x2, #0xfff
  403b34:	54000568 	b.hi	403be0 <isotp_fast_send+0x198>  // b.pmore
  403b38:	aa0103f8 	mov	x24, x1
        int ret = get_send_ctx(ctx, recipient_addr, &context);
  403b3c:	910143e2 	add	x2, sp, #0x50
  403b40:	2a1603e1 	mov	w1, w22
  403b44:	97fff961 	bl	4020c8 <get_send_ctx>
  403b48:	2a0003f5 	mov	w21, w0
        if (ret) {
  403b4c:	350004e0 	cbnz	w0, 403be8 <isotp_fast_send+0x1a0>
        context->ctx = ctx;
  403b50:	f9402bf4 	ldr	x20, [sp, #80]
        context->state = ISOTP_TX_SEND_FF;
  403b54:	12002e73 	and	w19, w19, #0xfff
  403b58:	32130273 	orr	w19, w19, #0x2000
        context->ctx = ctx;
  403b5c:	f9000699 	str	x25, [x20, #8]
        context->recipient_addr = recipient_addr;
  403b60:	b9001296 	str	w22, [x20, #16]
        context->data = data;
  403b64:	f9005e98 	str	x24, [x20, #184]
        context->bs = ctx->opts->bs;
  403b68:	f9400b20 	ldr	x0, [x25, #16]
  403b6c:	39400000 	ldrb	w0, [x0]
  403b70:	39034680 	strb	w0, [x20, #209]
        context->stmin = ctx->opts->stmin;
  403b74:	f9400b20 	ldr	x0, [x25, #16]
  403b78:	39400400 	ldrb	w0, [x0, #1]
  403b7c:	39035280 	strb	w0, [x20, #212]
        context->rem_len = len;
  403b80:	aa1403e0 	mov	x0, x20
  403b84:	784c0c01 	ldrh	w1, [x0, #192]!
        context->state = ISOTP_TX_SEND_FF;
  403b88:	79018293 	strh	w19, [x20, #192]
  403b8c:	39400801 	ldrb	w1, [x0, #2]
  403b90:	121c6c21 	and	w1, w1, #0xfffffff0
  403b94:	39000801 	strb	w1, [x0, #2]
        context->cb_arg = cb_arg;
  403b98:	f9006697 	str	x23, [x20, #200]
	return z_impl_k_sem_init(sem, initial_count, limit);
  403b9c:	52800022 	mov	w2, #0x1                   	// #1
        k_work_init(&context->work, send_work_handler);
  403ba0:	91006293 	add	x19, x20, #0x18
  403ba4:	91024280 	add	x0, x20, #0x90
  403ba8:	52800001 	mov	w1, #0x0                   	// #0
  403bac:	94002f16 	bl	40f804 <z_impl_k_sem_init>
  403bb0:	aa1303e0 	mov	x0, x19
  403bb4:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  403bb8:	9119b021 	add	x1, x1, #0x66c
  403bbc:	94003112 	bl	410004 <k_work_init>
        k_timer_init(&context->timer, send_timeout_handler, NULL);
  403bc0:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  403bc4:	910c6021 	add	x1, x1, #0x318
  403bc8:	d2800002 	mov	x2, #0x0                   	// #0
  403bcc:	9100e280 	add	x0, x20, #0x38
  403bd0:	94003e03 	bl	4133dc <k_timer_init>
        k_work_submit(&context->work);
  403bd4:	aa1303e0 	mov	x0, x19
  403bd8:	94003198 	bl	410238 <k_work_submit>
    return ISOTP_N_OK;
  403bdc:	17ffffcd 	b	403b10 <isotp_fast_send+0xc8>
            return ISOTP_N_BUFFER_OVERFLW;
  403be0:	128000f5 	mov	w21, #0xfffffff8            	// #-8
  403be4:	17ffffcb 	b	403b10 <isotp_fast_send+0xc8>
            return ISOTP_NO_NET_BUF_LEFT;
  403be8:	12800155 	mov	w21, #0xfffffff5            	// #-11
  403bec:	17ffffc9 	b	403b10 <isotp_fast_send+0xc8>
  403bf0:	2a1503e0 	mov	w0, w21
  403bf4:	a94153f3 	ldp	x19, x20, [sp, #16]
  403bf8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403bfc:	a94363f7 	ldp	x23, x24, [sp, #48]
  403c00:	f94023f9 	ldr	x25, [sp, #64]
  403c04:	a8c77bfd 	ldp	x29, x30, [sp], #112
  403c08:	d65f03c0 	ret

0000000000403c0c <isotp_fast_recv_handler>:
    return isotp_fast_recv(&ctx, sender, buf, size, timeout);
}

void isotp_fast_recv_handler(struct net_buf *buffer, int rem_len, isotp_fast_msg_id sender_addr,
                             void *arg)
{}
  403c0c:	d65f03c0 	ret

0000000000403c10 <isotp_fast_recv_error_handler>:

void isotp_fast_recv_error_handler(int8_t error, isotp_fast_msg_id sender_addr, void *arg)
  403c10:	d65f03c0 	ret

0000000000403c14 <blocking_recv>:
    return isotp_fast_recv(&ctx, sender, buf, size, timeout);
  403c14:	aa0003e3 	mov	x3, x0
  403c18:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
{
  403c1c:	d10043ff 	sub	sp, sp, #0x10
    return isotp_fast_recv(&ctx, sender, buf, size, timeout);
  403c20:	aa0203e5 	mov	x5, x2
  403c24:	f9471000 	ldr	x0, [x0, #3616]
  403c28:	aa0103e4 	mov	x4, x1
}
  403c2c:	910043ff 	add	sp, sp, #0x10
    return isotp_fast_recv(&ctx, sender, buf, size, timeout);
  403c30:	d2800001 	mov	x1, #0x0                   	// #0
  403c34:	d2800002 	mov	x2, #0x0                   	// #0
  403c38:	17fffee5 	b	4037cc <isotp_fast_recv>

0000000000403c3c <k_uptime_get>:
{
  403c3c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  403c40:	910003fd 	mov	x29, sp
	return z_impl_k_uptime_ticks();
  403c44:	94003d4e 	bl	41317c <z_impl_k_uptime_ticks>
}
  403c48:	d2800141 	mov	x1, #0xa                   	// #10
  403c4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  403c50:	9b017c00 	mul	x0, x0, x1
  403c54:	d65f03c0 	ret

0000000000403c58 <can_bytes_to_dlc>:
{
  403c58:	12001c00 	and	w0, w0, #0xff
	return num_bytes <= 8  ? num_bytes :
  403c5c:	7100201f 	cmp	w0, #0x8
  403c60:	540001c9 	b.ls	403c98 <can_bytes_to_dlc+0x40>  // b.plast
  403c64:	7100301f 	cmp	w0, #0xc
  403c68:	540001a9 	b.ls	403c9c <can_bytes_to_dlc+0x44>  // b.plast
  403c6c:	7100401f 	cmp	w0, #0x10
  403c70:	540001a9 	b.ls	403ca4 <can_bytes_to_dlc+0x4c>  // b.plast
  403c74:	7100501f 	cmp	w0, #0x14
  403c78:	540001a9 	b.ls	403cac <can_bytes_to_dlc+0x54>  // b.plast
  403c7c:	7100601f 	cmp	w0, #0x18
  403c80:	540001a9 	b.ls	403cb4 <can_bytes_to_dlc+0x5c>  // b.plast
  403c84:	7100801f 	cmp	w0, #0x20
  403c88:	540001a9 	b.ls	403cbc <can_bytes_to_dlc+0x64>  // b.plast
  403c8c:	7100c01f 	cmp	w0, #0x30
  403c90:	1a9f97e0 	cset	w0, hi  // hi = pmore
  403c94:	11003800 	add	w0, w0, #0xe
}
  403c98:	d65f03c0 	ret
	return num_bytes <= 8  ? num_bytes :
  403c9c:	52800120 	mov	w0, #0x9                   	// #9
  403ca0:	17fffffe 	b	403c98 <can_bytes_to_dlc+0x40>
  403ca4:	52800140 	mov	w0, #0xa                   	// #10
  403ca8:	17fffffc 	b	403c98 <can_bytes_to_dlc+0x40>
  403cac:	52800160 	mov	w0, #0xb                   	// #11
  403cb0:	17fffffa 	b	403c98 <can_bytes_to_dlc+0x40>
  403cb4:	52800180 	mov	w0, #0xc                   	// #12
  403cb8:	17fffff8 	b	403c98 <can_bytes_to_dlc+0x40>
  403cbc:	528001a0 	mov	w0, #0xd                   	// #13
  403cc0:	17fffff6 	b	403c98 <can_bytes_to_dlc+0x40>

0000000000403cc4 <prepare_cf_frames.constprop.0>:
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);

    return filter_id;
}

static void prepare_cf_frames(struct frame_desired *frames, size_t frames_cnt, const uint8_t *data,
  403cc4:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
                              size_t data_len)
{
    int i;
    const uint8_t *data_ptr = data;
  403cc8:	b0000082 	adrp	x2, 414000 <dlc_table.0+0x60d>
  403ccc:	91134042 	add	x2, x2, #0x4d0
static void prepare_cf_frames(struct frame_desired *frames, size_t frames_cnt, const uint8_t *data,
  403cd0:	d2800023 	mov	x3, #0x1                   	// #1
  403cd4:	f947bc21 	ldr	x1, [x1, #3960]
    const uint8_t *data_ptr = data;
  403cd8:	91001842 	add	x2, x2, #0x6
    size_t remaining_length = data_len;

    for (i = 0; i < frames_cnt && remaining_length; i++) {
        frames[i].data[0] = CF_PCI_BYTE_1 | ((i + 1) & 0x0F);
        frames[i].length = CAN_DL;
  403cdc:	52800105 	mov	w5, #0x8                   	// #8
        frames[i].data[0] = CF_PCI_BYTE_1 | ((i + 1) & 0x0F);
  403ce0:	12000c64 	and	w4, w3, #0xf
        frames[i].length = CAN_DL;
  403ce4:	39002025 	strb	w5, [x1, #8]
        frames[i].data[0] = CF_PCI_BYTE_1 | ((i + 1) & 0x0F);
  403ce8:	321b0084 	orr	w4, w4, #0x20
  403cec:	39000024 	strb	w4, [x1]
  403cf0:	b9400044 	ldr	w4, [x2]
  403cf4:	b8001024 	stur	w4, [x1, #1]
  403cf8:	b8403044 	ldur	w4, [x2, #3]
  403cfc:	b9000424 	str	w4, [x1, #4]
        memcpy(&des_frames[i].data[1], data_ptr, DATA_SIZE_CF);

        if (remaining_length < DATA_SIZE_CF) {
  403d00:	f100181f 	cmp	x0, #0x6
  403d04:	54000088 	b.hi	403d14 <prepare_cf_frames.constprop.0+0x50>  // b.pmore
            frames[i].length = remaining_length + 1;
  403d08:	11000400 	add	w0, w0, #0x1
  403d0c:	39002020 	strb	w0, [x1, #8]
            remaining_length = 0;
  403d10:	d2800000 	mov	x0, #0x0                   	// #0
        }

        remaining_length -= DATA_SIZE_CF;
  403d14:	91000463 	add	x3, x3, #0x1
  403d18:	d1001c00 	sub	x0, x0, #0x7
        data_ptr += DATA_SIZE_CF;
  403d1c:	91001c42 	add	x2, x2, #0x7
    for (i = 0; i < frames_cnt && remaining_length; i++) {
  403d20:	91002421 	add	x1, x1, #0x9
  403d24:	f1009c7f 	cmp	x3, #0x27
  403d28:	54000040 	b.eq	403d30 <prepare_cf_frames.constprop.0+0x6c>  // b.none
  403d2c:	b5fffda0 	cbnz	x0, 403ce0 <prepare_cf_frames.constprop.0+0x1c>
    }
}
  403d30:	d65f03c0 	ret

0000000000403d34 <z_zassert.constprop.0>:

#define z_zexpect(cond, default_msg, file, line, func, msg, ...) z_zexpect_(cond, file, line)

#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  403d34:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  403d38:	910003fd 	mov	x29, sp
  403d3c:	a9025bf5 	stp	x21, x22, [sp, #32]
  403d40:	aa0103f6 	mov	x22, x1
  403d44:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  403d48:	a90153f3 	stp	x19, x20, [sp, #16]
  403d4c:	f9476821 	ldr	x1, [x1, #3792]
  403d50:	f9001bf7 	str	x23, [sp, #48]
  403d54:	3d8027e0 	str	q0, [sp, #144]
			     const char *func, const char *msg, ...)
{
	if (cond == false) {
  403d58:	72001c17 	ands	w23, w0, #0xff
static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  403d5c:	3d802be1 	str	q1, [sp, #160]
  403d60:	3d802fe2 	str	q2, [sp, #176]
  403d64:	3d8033e3 	str	q3, [sp, #192]
  403d68:	3d8037e4 	str	q4, [sp, #208]
  403d6c:	3d803be5 	str	q5, [sp, #224]
  403d70:	3d803fe6 	str	q6, [sp, #240]
  403d74:	3d8043e7 	str	q7, [sp, #256]
  403d78:	a9111fe6 	stp	x6, x7, [sp, #272]
  403d7c:	f9400022 	ldr	x2, [x1]
  403d80:	f90047e2 	str	x2, [sp, #136]
  403d84:	d2800002 	mov	x2, #0x0                   	// #0
	if (cond == false) {
  403d88:	54000401 	b.ne	403e08 <z_zassert.constprop.0+0xd4>  // b.any
		va_list vargs;

		va_start(vargs, msg);
  403d8c:	910483e0 	add	x0, sp, #0x120
  403d90:	a90683e0 	stp	x0, x0, [sp, #104]
  403d94:	910443e0 	add	x0, sp, #0x110
  403d98:	f9003fe0 	str	x0, [sp, #120]
  403d9c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  403da0:	b90083e0 	str	w0, [sp, #128]
  403da4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  403da8:	aa0503f3 	mov	x19, x5
  403dac:	2a0303f4 	mov	w20, w3
  403db0:	aa0403f5 	mov	x21, x4
  403db4:	b90087e0 	str	w0, [sp, #132]
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n", ztest_relative_filename(file),
  403db8:	90000080 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  403dbc:	91280c00 	add	x0, x0, #0xa03
  403dc0:	94002118 	bl	40c220 <ztest_relative_filename>
  403dc4:	aa0003e1 	mov	x1, x0
  403dc8:	aa1603e4 	mov	x4, x22
  403dcc:	aa1503e3 	mov	x3, x21
  403dd0:	2a1403e2 	mov	w2, w20
  403dd4:	90000080 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  403dd8:	9129a800 	add	x0, x0, #0xa6a
  403ddc:	94000a0f 	bl	406618 <printk>
		      line, func, default_msg);
		vprintk(msg, vargs);
  403de0:	9101a3e0 	add	x0, sp, #0x68
  403de4:	910103e1 	add	x1, sp, #0x40
  403de8:	ad400400 	ldp	q0, q1, [x0]
  403dec:	aa1303e0 	mov	x0, x19
  403df0:	ad000420 	stp	q0, q1, [x1]
  403df4:	94000a00 	bl	4065f4 <vprintk>
		printk("\n");
  403df8:	d0000080 	adrp	x0, 415000 <random_data+0xb30>
  403dfc:	913b7800 	add	x0, x0, #0xede
  403e00:	94000a06 	bl	406618 <printk>
		va_end(vargs);
		ztest_test_fail();
  403e04:	94001de6 	bl	40b59c <ztest_test_fail>
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n", ztest_relative_filename(file),
		      line, func);
	}
#endif
	return true;
}
  403e08:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403e0c:	f9476800 	ldr	x0, [x0, #3792]
  403e10:	f94047e2 	ldr	x2, [sp, #136]
  403e14:	f9400001 	ldr	x1, [x0]
  403e18:	eb010042 	subs	x2, x2, x1
  403e1c:	d2800001 	mov	x1, #0x0                   	// #0
  403e20:	54000040 	b.eq	403e28 <z_zassert.constprop.0+0xf4>  // b.none
  403e24:	97fff53f 	bl	401320 <__stack_chk_fail@plt>
  403e28:	2a1703e0 	mov	w0, w23
  403e2c:	a94153f3 	ldp	x19, x20, [sp, #16]
  403e30:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403e34:	f9401bf7 	ldr	x23, [sp, #48]
  403e38:	a8d27bfd 	ldp	x29, x30, [sp], #288
  403e3c:	d65f03c0 	ret

0000000000403e40 <get_sf_ignore.constprop.0>:
static void get_sf_ignore(struct isotp_fast_ctx *recv_ctx)
  403e40:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403e44:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403e48:	d2800282 	mov	x2, #0x14                  	// #20
static void get_sf_ignore(struct isotp_fast_ctx *recv_ctx)
  403e4c:	910003fd 	mov	x29, sp
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403e50:	f9471400 	ldr	x0, [x0, #3624]
  403e54:	d2801001 	mov	x1, #0x80                  	// #128
  403e58:	97ffff6f 	bl	403c14 <blocking_recv>
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "recv returned %d", ret);
  403e5c:	3100381f 	cmn	w0, #0xe
}
  403e60:	a8c17bfd 	ldp	x29, x30, [sp], #16
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403e64:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "recv returned %d", ret);
  403e68:	90000085 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  403e6c:	1a9f17e0 	cset	w0, eq  // eq = none
  403e70:	912a48a5 	add	x5, x5, #0xa92
  403e74:	b0000084 	adrp	x4, 414000 <dlc_table.0+0x60d>
  403e78:	528008e3 	mov	w3, #0x47                  	// #71
  403e7c:	910b1c84 	add	x4, x4, #0x2c7
  403e80:	90000082 	adrp	x2, 413000 <sys_clock_announce+0x19c>
  403e84:	90000081 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  403e88:	91280c42 	add	x2, x2, #0xa03
  403e8c:	912a8c21 	add	x1, x1, #0xaa3
  403e90:	17ffffa9 	b	403d34 <z_zassert.constprop.0>

0000000000403e94 <send_test_data.constprop.0>:
static void send_test_data(const uint8_t *data, size_t len)
  403e94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403e98:	aa0003e2 	mov	x2, x0
  403e9c:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
static void send_test_data(const uint8_t *data, size_t len)
  403ea0:	910003fd 	mov	x29, sp
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403ea4:	f9471000 	ldr	x0, [x0, #3616]
  403ea8:	d2800004 	mov	x4, #0x0                   	// #0
  403eac:	52800023 	mov	w3, #0x1                   	// #1
  403eb0:	b0000081 	adrp	x1, 414000 <dlc_table.0+0x60d>
  403eb4:	91134021 	add	x1, x1, #0x4d0
  403eb8:	97fffee4 	bl	403a48 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  403ebc:	7100001f 	cmp	w0, #0x0
}
  403ec0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403ec4:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  403ec8:	90000085 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  403ecc:	1a9f17e0 	cset	w0, eq  // eq = none
  403ed0:	912b24a5 	add	x5, x5, #0xac9
  403ed4:	b0000084 	adrp	x4, 414000 <dlc_table.0+0x60d>
  403ed8:	528009e3 	mov	w3, #0x4f                  	// #79
  403edc:	91097884 	add	x4, x4, #0x25e
  403ee0:	90000082 	adrp	x2, 413000 <sys_clock_announce+0x19c>
  403ee4:	90000081 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  403ee8:	91280c42 	add	x2, x2, #0xa03
  403eec:	912b6821 	add	x1, x1, #0xada
  403ef0:	17ffff91 	b	403d34 <z_zassert.constprop.0>

0000000000403ef4 <add_rx_msgq.constprop.0>:
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403ef4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  403ef8:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403efc:	92407000 	and	x0, x0, #0x1fffffff
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403f00:	910003fd 	mov	x29, sp
  403f04:	f9476821 	ldr	x1, [x1, #3792]
  403f08:	a90153f3 	stp	x19, x20, [sp, #16]
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403f0c:	b2607000 	orr	x0, x0, #0x1fffffff00000000
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403f10:	f90013f5 	str	x21, [sp, #32]
  403f14:	f9400022 	ldr	x2, [x1]
  403f18:	f90027e2 	str	x2, [sp, #72]
  403f1c:	d2800002 	mov	x2, #0x0                   	// #0
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403f20:	b90043ff 	str	wzr, [sp, #64]
  403f24:	f9001fe0 	str	x0, [sp, #56]
  403f28:	528000a0 	mov	w0, #0x5                   	// #5
  403f2c:	390103e0 	strb	w0, [sp, #64]
		union { uintptr_t x; const struct can_filter * val; } parm2 = { .val = filter };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_CAN_ADD_RX_FILTER_MSGQ);
	}
#endif
	compiler_barrier();
	return z_impl_can_add_rx_filter_msgq(dev, msgq, filter);
  403f30:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  403f34:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403f38:	9100e3e2 	add	x2, sp, #0x38
    zassert_not_equal(filter_id, -ENOSPC, "Filter full");
  403f3c:	b0000095 	adrp	x21, 414000 <dlc_table.0+0x60d>
  403f40:	f947e021 	ldr	x1, [x1, #4032]
  403f44:	910c26b5 	add	x21, x21, #0x309
  403f48:	f9472400 	ldr	x0, [x0, #3656]
  403f4c:	90000094 	adrp	x20, 413000 <sys_clock_announce+0x19c>
  403f50:	91280e94 	add	x20, x20, #0xa03
  403f54:	9400238d 	bl	40cd88 <z_impl_can_add_rx_filter_msgq>
  403f58:	3100701f 	cmn	w0, #0x1c
  403f5c:	2a0003f3 	mov	w19, w0
  403f60:	aa1503e4 	mov	x4, x21
  403f64:	1a9f07e0 	cset	w0, ne  // ne = any
  403f68:	aa1403e2 	mov	x2, x20
  403f6c:	52801563 	mov	w3, #0xab                  	// #171
  403f70:	90000085 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  403f74:	90000081 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  403f78:	912bbca5 	add	x5, x5, #0xaef
  403f7c:	912bec21 	add	x1, x1, #0xafb
  403f80:	97ffff6d 	bl	403d34 <z_zassert.constprop.0>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  403f84:	2a3303e0 	mvn	w0, w19
  403f88:	aa1403e2 	mov	x2, x20
  403f8c:	2a1303e6 	mov	w6, w19
  403f90:	aa1503e4 	mov	x4, x21
  403f94:	531f7c00 	lsr	w0, w0, #31
  403f98:	90000085 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  403f9c:	52801583 	mov	w3, #0xac                  	// #172
  403fa0:	912c60a5 	add	x5, x5, #0xb18
  403fa4:	90000081 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  403fa8:	912cd021 	add	x1, x1, #0xb34
  403fac:	97ffff62 	bl	403d34 <z_zassert.constprop.0>
}
  403fb0:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403fb4:	f9476800 	ldr	x0, [x0, #3792]
  403fb8:	f94027e2 	ldr	x2, [sp, #72]
  403fbc:	f9400001 	ldr	x1, [x0]
  403fc0:	eb010042 	subs	x2, x2, x1
  403fc4:	d2800001 	mov	x1, #0x0                   	// #0
  403fc8:	54000040 	b.eq	403fd0 <add_rx_msgq.constprop.0+0xdc>  // b.none
  403fcc:	97fff4d5 	bl	401320 <__stack_chk_fail@plt>
  403fd0:	2a1303e0 	mov	w0, w19
  403fd4:	a94153f3 	ldp	x19, x20, [sp, #16]
  403fd8:	f94013f5 	ldr	x21, [sp, #32]
  403fdc:	a8c57bfd 	ldp	x29, x30, [sp], #80
  403fe0:	d65f03c0 	ret

0000000000403fe4 <send_frame_series>:
{
  403fe4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  403fe8:	910003fd 	mov	x29, sp
  403fec:	a90153f3 	stp	x19, x20, [sp, #16]
  403ff0:	aa0003f3 	mov	x19, x0
  403ff4:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  403ff8:	a9025bf5 	stp	x21, x22, [sp, #32]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403ffc:	90000096 	adrp	x22, 413000 <sys_clock_announce+0x19c>
  404000:	2a0103f5 	mov	w21, w1
{
  404004:	f9476800 	ldr	x0, [x0, #3792]
  404008:	a90363f7 	stp	x23, x24, [sp, #48]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  40400c:	912b6ad6 	add	x22, x22, #0xada
{
  404010:	a9046bf9 	stp	x25, x26, [sp, #64]
	return z_impl_can_send(dev, frame, timeout, callback, user_data);
  404014:	f000013a 	adrp	x26, 42b000 <__FRAME_END__+0xfd74>
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  404018:	f0000079 	adrp	x25, 413000 <sys_clock_announce+0x19c>
{
  40401c:	f9400003 	ldr	x3, [x0]
  404020:	f90037e3 	str	x3, [sp, #104]
  404024:	d2800003 	mov	x3, #0x0                   	// #0
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  404028:	52800000 	mov	w0, #0x0                   	// #0
  40402c:	f947275a 	ldr	x26, [x26, #3656]
  404030:	33007040 	bfxil	w0, w2, #0, #29
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  404034:	90000098 	adrp	x24, 414000 <dlc_table.0+0x60d>
  404038:	f0000077 	adrp	x23, 413000 <sys_clock_announce+0x19c>
  40403c:	912d4339 	add	x25, x25, #0xb50
  404040:	910b5718 	add	x24, x24, #0x2d5
  404044:	91280ef7 	add	x23, x23, #0xa03
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  404048:	a905ffff 	stp	xzr, xzr, [sp, #88]
    for (i = 0; i < length; i++) {
  40404c:	52800014 	mov	w20, #0x0                   	// #0
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  404050:	b9005be0 	str	w0, [sp, #88]
  404054:	52800020 	mov	w0, #0x1                   	// #1
  404058:	390177e0 	strb	w0, [sp, #93]
        frame.dlc = can_bytes_to_dlc(desired->length);
  40405c:	39402262 	ldrb	w2, [x19, #8]
  404060:	aa1303e1 	mov	x1, x19
  404064:	d2800103 	mov	x3, #0x8                   	// #8
  404068:	2a0203e0 	mov	w0, w2
  40406c:	97fffefb 	bl	403c58 <can_bytes_to_dlc>
  404070:	92401c42 	and	x2, x2, #0xff
  404074:	390173e0 	strb	w0, [sp, #92]
  404078:	910183e0 	add	x0, sp, #0x60
  40407c:	97fff475 	bl	401250 <__memcpy_chk@plt>
  404080:	d2800004 	mov	x4, #0x0                   	// #0
  404084:	910163e1 	add	x1, sp, #0x58
  404088:	d2800003 	mov	x3, #0x0                   	// #0
  40408c:	d2800642 	mov	x2, #0x32                  	// #50
  404090:	aa1a03e0 	mov	x0, x26
  404094:	94002302 	bl	40cc9c <z_impl_can_send>
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  404098:	7100001f 	cmp	w0, #0x0
  40409c:	2a0003e7 	mov	w7, w0
  4040a0:	2a1403e6 	mov	w6, w20
  4040a4:	aa1903e5 	mov	x5, x25
  4040a8:	aa1803e4 	mov	x4, x24
  4040ac:	aa1703e2 	mov	x2, x23
  4040b0:	aa1603e1 	mov	x1, x22
  4040b4:	1a9f17e0 	cset	w0, eq  // eq = none
  4040b8:	52800fa3 	mov	w3, #0x7d                  	// #125
    for (i = 0; i < length; i++) {
  4040bc:	11000694 	add	w20, w20, #0x1
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  4040c0:	97ffff1d 	bl	403d34 <z_zassert.constprop.0>
        desired++;
  4040c4:	91002673 	add	x19, x19, #0x9
    for (i = 0; i < length; i++) {
  4040c8:	6b1402bf 	cmp	w21, w20
  4040cc:	54fffc81 	b.ne	40405c <send_frame_series+0x78>  // b.any
}
  4040d0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4040d4:	f9476800 	ldr	x0, [x0, #3792]
  4040d8:	f94037e2 	ldr	x2, [sp, #104]
  4040dc:	f9400001 	ldr	x1, [x0]
  4040e0:	eb010042 	subs	x2, x2, x1
  4040e4:	d2800001 	mov	x1, #0x0                   	// #0
  4040e8:	54000040 	b.eq	4040f0 <send_frame_series+0x10c>  // b.none
  4040ec:	97fff48d 	bl	401320 <__stack_chk_fail@plt>
  4040f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4040f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4040f8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4040fc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  404100:	a8c77bfd 	ldp	x29, x30, [sp], #112
  404104:	d65f03c0 	ret

0000000000404108 <_isotp_fast_conformance_sync_test_receive_timeouts_wrapper>:
    zassert_equal(ret, 0, "Timeout too late");
    time_diff = k_uptime_get_32() - start_time;
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
}

ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  404108:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40410c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
    ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
    memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
    ff_frame.length = DATA_SIZE_FF + 2;

    send_frame_series(&ff_frame, 1, rx_addr);
  404110:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  404114:	910003fd 	mov	x29, sp
  404118:	f9476800 	ldr	x0, [x0, #3792]
  40411c:	a90153f3 	stp	x19, x20, [sp, #16]
    send_frame_series(&ff_frame, 1, rx_addr);
  404120:	72a31b42 	movk	w2, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  404124:	a9025bf5 	stp	x21, x22, [sp, #32]
    start_time = k_uptime_get_32();

    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  404128:	f0000135 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  40412c:	90000094 	adrp	x20, 414000 <dlc_table.0+0x60d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  404130:	f9400001 	ldr	x1, [x0]
  404134:	f90027e1 	str	x1, [sp, #72]
  404138:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  40413c:	52820220 	mov	w0, #0x1011                	// #4113
  404140:	790073e0 	strh	w0, [sp, #56]
  404144:	90000080 	adrp	x0, 414000 <dlc_table.0+0x60d>
  404148:	91134000 	add	x0, x0, #0x4d0
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  40414c:	910f8e94 	add	x20, x20, #0x3e3
  404150:	f0000073 	adrp	x19, 413000 <sys_clock_announce+0x19c>
  404154:	91280e73 	add	x19, x19, #0xa03
  404158:	b9400001 	ldr	w1, [x0]
  40415c:	79400800 	ldrh	w0, [x0, #4]
  404160:	79007fe0 	strh	w0, [sp, #62]
    ff_frame.length = DATA_SIZE_FF + 2;
  404164:	52800100 	mov	w0, #0x8                   	// #8
  404168:	390103e0 	strb	w0, [sp, #64]
    send_frame_series(&ff_frame, 1, rx_addr);
  40416c:	9100e3e0 	add	x0, sp, #0x38
  404170:	b803a3e1 	stur	w1, [sp, #58]
  404174:	d2800021 	mov	x1, #0x1                   	// #1
  404178:	97ffff9b 	bl	403fe4 <send_frame_series>
	return (uint32_t)k_uptime_get();
  40417c:	97fffeb0 	bl	403c3c <k_uptime_get>
  404180:	aa0003f6 	mov	x22, x0
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  404184:	f94716b5 	ldr	x21, [x21, #3624]
  404188:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  40418c:	d2801001 	mov	x1, #0x80                  	// #128
  404190:	aa1503e0 	mov	x0, x21
  404194:	97fffea0 	bl	403c14 <blocking_recv>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  404198:	7100181f 	cmp	w0, #0x6
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  40419c:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  4041a0:	aa1403e4 	mov	x4, x20
  4041a4:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4041a8:	912dc8a5 	add	x5, x5, #0xb72
  4041ac:	528044a3 	mov	w3, #0x225                 	// #549
  4041b0:	1a9f17e0 	cset	w0, eq  // eq = none
  4041b4:	aa1303e2 	mov	x2, x19
  4041b8:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4041bc:	912e5421 	add	x1, x1, #0xb95
  4041c0:	97fffedd 	bl	403d34 <z_zassert.constprop.0>
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  4041c4:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  4041c8:	d2801001 	mov	x1, #0x80                  	// #128
  4041cc:	aa1503e0 	mov	x0, x21
  4041d0:	97fffe91 	bl	403c14 <blocking_recv>
    zassert_equal(ret, ISOTP_N_TIMEOUT_CR, "Expected timeout but got %d", ret);
  4041d4:	31000c1f 	cmn	w0, #0x3
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  4041d8:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_TIMEOUT_CR, "Expected timeout but got %d", ret);
  4041dc:	aa1403e4 	mov	x4, x20
  4041e0:	aa1303e2 	mov	x2, x19
  4041e4:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4041e8:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4041ec:	912ed4a5 	add	x5, x5, #0xbb5
  4041f0:	912f4421 	add	x1, x1, #0xbd1
  4041f4:	528044e3 	mov	w3, #0x227                 	// #551
  4041f8:	1a9f17e0 	cset	w0, eq  // eq = none
  4041fc:	97fffece 	bl	403d34 <z_zassert.constprop.0>
  404200:	97fffe8f 	bl	403c3c <k_uptime_get>

    time_diff = k_uptime_get_32() - start_time;
  404204:	4b160016 	sub	w22, w0, w22
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  404208:	710f9edf 	cmp	w22, #0x3e7
  40420c:	2a1603e6 	mov	w6, w22
  404210:	aa1403e4 	mov	x4, x20
  404214:	aa1303e2 	mov	x2, x19
  404218:	1a9f97e0 	cset	w0, hi  // hi = pmore
  40421c:	52804543 	mov	w3, #0x22a                 	// #554
  404220:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  404224:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404228:	912fdca5 	add	x5, x5, #0xbf7
  40422c:	91304021 	add	x1, x1, #0xc10
  404230:	97fffec1 	bl	403d34 <z_zassert.constprop.0>
    zassert_true(time_diff <= BS_TIMEOUT_UPPER_MS, "Timeout too slow (%dms)", time_diff);
  404234:	711132df 	cmp	w22, #0x44c
  404238:	aa1303e2 	mov	x2, x19
  40423c:	1a9f87e0 	cset	w0, ls  // ls = plast
  404240:	2a1603e6 	mov	w6, w22
  404244:	aa1403e4 	mov	x4, x20
  404248:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  40424c:	52804563 	mov	w3, #0x22b                 	// #555
  404250:	9130f0a5 	add	x5, x5, #0xc3c
  404254:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404258:	91315021 	add	x1, x1, #0xc54
  40425c:	97fffeb6 	bl	403d34 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  404260:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  404264:	f9476800 	ldr	x0, [x0, #3792]
  404268:	f94027e2 	ldr	x2, [sp, #72]
  40426c:	f9400001 	ldr	x1, [x0]
  404270:	eb010042 	subs	x2, x2, x1
  404274:	d2800001 	mov	x1, #0x0                   	// #0
  404278:	54000040 	b.eq	404280 <_isotp_fast_conformance_sync_test_receive_timeouts_wrapper+0x178>  // b.none
  40427c:	97fff429 	bl	401320 <__stack_chk_fail@plt>
  404280:	a94153f3 	ldp	x19, x20, [sp, #16]
  404284:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404288:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40428c:	d65f03c0 	ret

0000000000404290 <isotp_fast_conformance_before>:

    return NULL;
}

void isotp_fast_conformance_before(void *)
{
  404290:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  404294:	910003fd 	mov	x29, sp
  404298:	f9000bf3 	str	x19, [sp, #16]
	return api->start(dev);
  40429c:	f0000133 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  4042a0:	f9472673 	ldr	x19, [x19, #3656]
  4042a4:	f9400a60 	ldr	x0, [x19, #16]
  4042a8:	f9400401 	ldr	x1, [x0, #8]
  4042ac:	aa1303e0 	mov	x0, x19
  4042b0:	d63f0020 	blr	x1
    int ret = can_start(can_dev);
    zassert_equal(ret, 0, "Failed to start CAN controller [%d]", ret);
  4042b4:	7100001f 	cmp	w0, #0x0
  4042b8:	2a0003e6 	mov	w6, w0
  4042bc:	52805c23 	mov	w3, #0x2e1                 	// #737
  4042c0:	1a9f17e0 	cset	w0, eq  // eq = none
  4042c4:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4042c8:	90000084 	adrp	x4, 414000 <dlc_table.0+0x60d>
  4042cc:	913200a5 	add	x5, x5, #0xc80
  4042d0:	91088c84 	add	x4, x4, #0x223
  4042d4:	f0000062 	adrp	x2, 413000 <sys_clock_announce+0x19c>
  4042d8:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4042dc:	91280c42 	add	x2, x2, #0xa03
  4042e0:	912b6821 	add	x1, x1, #0xada
  4042e4:	97fffe94 	bl	403d34 <z_zassert.constprop.0>

    filter_id = -1;
  4042e8:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4042ec:	12800001 	mov	w1, #0xffffffff            	// #-1
  4042f0:	f947b000 	ldr	x0, [x0, #3936]
  4042f4:	b9000001 	str	w1, [x0]
	z_impl_k_msgq_purge(msgq);
  4042f8:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4042fc:	f947e000 	ldr	x0, [x0, #4032]
  404300:	94002ae0 	bl	40ee80 <z_impl_k_msgq_purge>
    k_msgq_purge(&frame_msgq);

    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  404304:	aa1303e1 	mov	x1, x19
  404308:	f0000127 	adrp	x7, 42b000 <__FRAME_END__+0xfd74>
  40430c:	f0000126 	adrp	x6, 42b000 <__FRAME_END__+0xfd74>
  404310:	f0000124 	adrp	x4, 42b000 <__FRAME_END__+0xfd74>
  404314:	f0000123 	adrp	x3, 42b000 <__FRAME_END__+0xfd74>
  404318:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
                    isotp_fast_recv_error_handler, isotp_fast_sent_handler);
}
  40431c:	f9400bf3 	ldr	x19, [sp, #16]
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  404320:	52804022 	mov	w2, #0x201                 	// #513
}
  404324:	a8c27bfd 	ldp	x29, x30, [sp], #32
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  404328:	d2800005 	mov	x5, #0x0                   	// #0
  40432c:	f947c4e7 	ldr	x7, [x7, #3976]
  404330:	72a31b42 	movk	w2, #0x18da, lsl #16
  404334:	f947c0c6 	ldr	x6, [x6, #3968]
  404338:	f9470484 	ldr	x4, [x4, #3592]
  40433c:	f947a863 	ldr	x3, [x3, #3920]
  404340:	f9471000 	ldr	x0, [x0, #3616]
  404344:	17fffcaf 	b	403600 <isotp_fast_bind>

0000000000404348 <k_msgq_get.constprop.0>:
static inline int k_msgq_get(struct k_msgq * msgq, void * data, k_timeout_t timeout)
  404348:	aa0103e2 	mov	x2, x1
	return z_impl_k_msgq_get(msgq, data, timeout);
  40434c:	aa0003e1 	mov	x1, x0
  404350:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  404354:	f947e000 	ldr	x0, [x0, #4032]
  404358:	14002a1d 	b	40ebcc <z_impl_k_msgq_get>

000000000040435c <isotp_fast_sent_handler>:
    zassert_equal(result, expected_err_nr, "Unexpected error nr. expect: %d, got %d",
  40435c:	6b00003f 	cmp	w1, w0
{
  404360:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  404364:	2a0003e7 	mov	w7, w0
  404368:	910003fd 	mov	x29, sp
  40436c:	aa0103e6 	mov	x6, x1
    zassert_equal(result, expected_err_nr, "Unexpected error nr. expect: %d, got %d",
  404370:	1a9f17e0 	cset	w0, eq  // eq = none
  404374:	52800323 	mov	w3, #0x19                  	// #25
  404378:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  40437c:	90000084 	adrp	x4, 414000 <dlc_table.0+0x60d>
  404380:	913290a5 	add	x5, x5, #0xca4
  404384:	910dc084 	add	x4, x4, #0x370
  404388:	f0000062 	adrp	x2, 413000 <sys_clock_announce+0x19c>
  40438c:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404390:	91280c42 	add	x2, x2, #0xa03
  404394:	91333021 	add	x1, x1, #0xccc
  404398:	97fffe67 	bl	403d34 <z_zassert.constprop.0>
	z_impl_k_sem_give(sem);
  40439c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
}
  4043a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4043a4:	f947f800 	ldr	x0, [x0, #4080]
  4043a8:	14002d22 	b	40f830 <z_impl_k_sem_give>

00000000004043ac <isotp_fast_conformance_setup>:
{
  4043ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  4043b0:	528059c3 	mov	w3, #0x2ce                 	// #718
  4043b4:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
{
  4043b8:	910003fd 	mov	x29, sp
  4043bc:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  4043c0:	90000094 	adrp	x20, 414000 <dlc_table.0+0x60d>
  4043c4:	f0000073 	adrp	x19, 413000 <sys_clock_announce+0x19c>
  4043c8:	91090694 	add	x20, x20, #0x241
  4043cc:	91280e73 	add	x19, x19, #0xa03
  4043d0:	9133c8a5 	add	x5, x5, #0xcf2
  4043d4:	aa1403e4 	mov	x4, x20
  4043d8:	aa1303e2 	mov	x2, x19
  4043dc:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4043e0:	52800020 	mov	w0, #0x1                   	// #1
  4043e4:	91342c21 	add	x1, x1, #0xd0b
{
  4043e8:	f90013f5 	str	x21, [sp, #32]
    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  4043ec:	97fffe52 	bl	403d34 <z_zassert.constprop.0>
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
  4043f0:	f0000135 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
  4043f4:	f94726b5 	ldr	x21, [x21, #3656]
  4043f8:	aa1503e0 	mov	x0, x21
  4043fc:	940024b5 	bl	40d6d0 <z_device_is_ready>
    zassert_true(device_is_ready(can_dev), "CAN device not ready");
  404400:	aa1403e4 	mov	x4, x20
  404404:	aa1303e2 	mov	x2, x19
  404408:	52805a03 	mov	w3, #0x2d0                 	// #720
  40440c:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  404410:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404414:	91351ca5 	add	x5, x5, #0xd47
  404418:	91357021 	add	x1, x1, #0xd5c
  40441c:	97fffe46 	bl	403d34 <z_zassert.constprop.0>
	return api->set_mode(dev, mode);
  404420:	f9400aa0 	ldr	x0, [x21, #16]
  404424:	52800021 	mov	w1, #0x1                   	// #1
  404428:	f9400c02 	ldr	x2, [x0, #24]
  40442c:	aa1503e0 	mov	x0, x21
  404430:	d63f0040 	blr	x2
    zassert_equal(ret, 0, "Failed to set loopback mode [%d]", ret);
  404434:	7100001f 	cmp	w0, #0x0
  404438:	2a0003e6 	mov	w6, w0
  40443c:	aa1403e4 	mov	x4, x20
  404440:	aa1303e2 	mov	x2, x19
  404444:	1a9f17e0 	cset	w0, eq  // eq = none
  404448:	52805ae3 	mov	w3, #0x2d7                 	// #727
  40444c:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  404450:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404454:	913600a5 	add	x5, x5, #0xd80
  404458:	912b6821 	add	x1, x1, #0xada
  40445c:	97fffe36 	bl	403d34 <z_zassert.constprop.0>
	return z_impl_k_sem_init(sem, initial_count, limit);
  404460:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  404464:	52800022 	mov	w2, #0x1                   	// #1
  404468:	52800001 	mov	w1, #0x0                   	// #0
  40446c:	f947f800 	ldr	x0, [x0, #4080]
  404470:	94002ce5 	bl	40f804 <z_impl_k_sem_init>
}
  404474:	d2800000 	mov	x0, #0x0                   	// #0
  404478:	a94153f3 	ldp	x19, x20, [sp, #16]
  40447c:	f94013f5 	ldr	x21, [sp, #32]
  404480:	a8c37bfd 	ldp	x29, x30, [sp], #48
  404484:	d65f03c0 	ret

0000000000404488 <isotp_fast_conformance_after>:

void isotp_fast_conformance_after(void *)
{
  404488:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    isotp_fast_unbind(&ctx);
  40448c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
{
  404490:	910003fd 	mov	x29, sp
    isotp_fast_unbind(&ctx);
  404494:	f9471000 	ldr	x0, [x0, #3616]
{
  404498:	f9000bf3 	str	x19, [sp, #16]
    isotp_fast_unbind(&ctx);
  40449c:	97fffca0 	bl	40371c <isotp_fast_unbind>
	z_impl_k_msgq_purge(msgq);
  4044a0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4044a4:	f0000133 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  4044a8:	f947e000 	ldr	x0, [x0, #4032]
  4044ac:	94002a75 	bl	40ee80 <z_impl_k_msgq_purge>

    k_msgq_purge(&frame_msgq);
    if (filter_id >= 0) {
  4044b0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4044b4:	f947b000 	ldr	x0, [x0, #3936]
  4044b8:	b9400001 	ldr	w1, [x0]
  4044bc:	37f800a1 	tbnz	w1, #31, 4044d0 <isotp_fast_conformance_after+0x48>
	return api->remove_rx_filter(dev, filter_id);
  4044c0:	f9472660 	ldr	x0, [x19, #3656]
  4044c4:	f9400802 	ldr	x2, [x0, #16]
  4044c8:	f9401c42 	ldr	x2, [x2, #56]
  4044cc:	d63f0040 	blr	x2
	return api->stop(dev);
  4044d0:	f9472660 	ldr	x0, [x19, #3656]
        can_remove_rx_filter(can_dev, filter_id);
    }
    can_stop(can_dev);
}
  4044d4:	f9400bf3 	ldr	x19, [sp, #16]
  4044d8:	f9400801 	ldr	x1, [x0, #16]
  4044dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4044e0:	f9400821 	ldr	x1, [x1, #16]
  4044e4:	aa0103f0 	mov	x16, x1
  4044e8:	d61f0200 	br	x16

00000000004044ec <_isotp_fast_conformance_sync_test_send_timeouts_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_timeouts)
  4044ec:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  4044f0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4044f4:	910003fd 	mov	x29, sp
  4044f8:	f9476800 	ldr	x0, [x0, #3792]
  4044fc:	a90153f3 	stp	x19, x20, [sp, #16]
  404500:	a9025bf5 	stp	x21, x22, [sp, #32]
  404504:	a90363f7 	stp	x23, x24, [sp, #48]
  404508:	a9046bf9 	stp	x25, x26, [sp, #64]
  40450c:	a90573fb 	stp	x27, x28, [sp, #80]
  404510:	f9400001 	ldr	x1, [x0]
  404514:	f9004fe1 	str	x1, [sp, #152]
  404518:	d2800001 	mov	x1, #0x0                   	// #0
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  40451c:	52810600 	mov	w0, #0x830                 	// #2096
  404520:	790113e0 	strh	w0, [sp, #136]
    fc_cts_frame.length = DATA_SIZE_FC;
  404524:	52800060 	mov	w0, #0x3                   	// #3
    fc_cts_frame.data[2] = FC_PCI_BYTE_3(0);
  404528:	39022bff 	strb	wzr, [sp, #138]
    fc_cts_frame.length = DATA_SIZE_FC;
  40452c:	390243e0 	strb	w0, [sp, #144]
	z_impl_k_sem_reset(sem);
  404530:	f0000135 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
    isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  404534:	f000013a 	adrp	x26, 42b000 <__FRAME_END__+0xfd74>
  404538:	9000009b 	adrp	x27, 414000 <dlc_table.0+0x60d>
  40453c:	9113437b 	add	x27, x27, #0x4d0
  404540:	f947fab5 	ldr	x21, [x21, #4080]
  404544:	aa1503e0 	mov	x0, x21
  404548:	94002d62 	bl	40fad0 <z_impl_k_sem_reset>
  40454c:	97fffdbc 	bl	403c3c <k_uptime_get>
  404550:	aa0003fc 	mov	x28, x0
  404554:	f947135a 	ldr	x26, [x26, #3616]
  404558:	aa1b03e1 	mov	x1, x27
  40455c:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  404560:	52800023 	mov	w3, #0x1                   	// #1
  404564:	aa1a03e0 	mov	x0, x26
  404568:	d2808002 	mov	x2, #0x400                 	// #1024
  40456c:	97fffd37 	bl	403a48 <isotp_fast_send>
	return z_impl_k_sem_take(sem, timeout);
  404570:	d2800dc1 	mov	x1, #0x6e                  	// #110
  404574:	aa1503e0 	mov	x0, x21
  404578:	94002ce5 	bl	40f90c <z_impl_k_sem_take>
  40457c:	2a0003f6 	mov	w22, w0
  404580:	97fffdaf 	bl	403c3c <k_uptime_get>
    zassert_equal(ret, 0, "Timeout too late");
  404584:	f0000079 	adrp	x25, 413000 <sys_clock_announce+0x19c>
  404588:	710002df 	cmp	w22, #0x0
  40458c:	91368739 	add	x25, x25, #0xda1
  404590:	90000094 	adrp	x20, 414000 <dlc_table.0+0x60d>
  404594:	f0000073 	adrp	x19, 413000 <sys_clock_announce+0x19c>
  404598:	91105694 	add	x20, x20, #0x415
  40459c:	91280e73 	add	x19, x19, #0xa03
  4045a0:	f0000078 	adrp	x24, 413000 <sys_clock_announce+0x19c>
  4045a4:	912b6b18 	add	x24, x24, #0xada
    time_diff = k_uptime_get_32() - start_time;
  4045a8:	4b1c001c 	sub	w28, w0, w28
    zassert_equal(ret, 0, "Timeout too late");
  4045ac:	aa1903e5 	mov	x5, x25
  4045b0:	aa1403e4 	mov	x4, x20
  4045b4:	aa1303e2 	mov	x2, x19
  4045b8:	aa1803e1 	mov	x1, x24
  4045bc:	1a9f17e0 	cset	w0, eq  // eq = none
  4045c0:	52803e23 	mov	w3, #0x1f1                 	// #497
  4045c4:	97fffddc 	bl	403d34 <z_zassert.constprop.0>
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4045c8:	710f9f9f 	cmp	w28, #0x3e7
  4045cc:	f0000077 	adrp	x23, 413000 <sys_clock_announce+0x19c>
  4045d0:	f0000076 	adrp	x22, 413000 <sys_clock_announce+0x19c>
  4045d4:	912fdef7 	add	x23, x23, #0xbf7
  4045d8:	913042d6 	add	x22, x22, #0xc10
  4045dc:	2a1c03e6 	mov	w6, w28
  4045e0:	aa1703e5 	mov	x5, x23
  4045e4:	aa1403e4 	mov	x4, x20
  4045e8:	aa1303e2 	mov	x2, x19
  4045ec:	aa1603e1 	mov	x1, x22
  4045f0:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4045f4:	52803e43 	mov	w3, #0x1f2                 	// #498
  4045f8:	97fffdcf 	bl	403d34 <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  4045fc:	aa1503e0 	mov	x0, x21
  404600:	94002d34 	bl	40fad0 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  404604:	aa1b03e1 	mov	x1, x27
  404608:	aa1a03e0 	mov	x0, x26
  40460c:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  404610:	52800023 	mov	w3, #0x1                   	// #1
  404614:	d2808002 	mov	x2, #0x400                 	// #1024
  404618:	97fffd0c 	bl	403a48 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  40461c:	f0000068 	adrp	x8, 413000 <sys_clock_announce+0x19c>
  404620:	7100001f 	cmp	w0, #0x0
  404624:	912b2508 	add	x8, x8, #0xac9
  404628:	f0000067 	adrp	x7, 413000 <sys_clock_announce+0x19c>
  40462c:	9136c8e7 	add	x7, x7, #0xdb2
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  404630:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404634:	aa0703e1 	mov	x1, x7
  404638:	aa0803e5 	mov	x5, x8
  40463c:	aa1403e4 	mov	x4, x20
  404640:	1a9f17e0 	cset	w0, eq  // eq = none
  404644:	52803f03 	mov	w3, #0x1f8                 	// #504
  404648:	aa1303e2 	mov	x2, x19
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  40464c:	910223fc 	add	x28, sp, #0x88
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404650:	a90723e7 	stp	x7, x8, [sp, #112]
  404654:	97fffdb8 	bl	403d34 <z_zassert.constprop.0>
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  404658:	aa1c03e0 	mov	x0, x28
  40465c:	52804022 	mov	w2, #0x201                 	// #513
  404660:	72a31b42 	movk	w2, #0x18da, lsl #16
  404664:	d2800021 	mov	x1, #0x1                   	// #1
  404668:	97fffe5f 	bl	403fe4 <send_frame_series>
  40466c:	97fffd74 	bl	403c3c <k_uptime_get>
  404670:	f90037e0 	str	x0, [sp, #104]
	return z_impl_k_sem_take(sem, timeout);
  404674:	d2800dc1 	mov	x1, #0x6e                  	// #110
  404678:	aa1503e0 	mov	x0, x21
  40467c:	94002ca4 	bl	40f90c <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Timeout too late");
  404680:	7100001f 	cmp	w0, #0x0
  404684:	aa1903e5 	mov	x5, x25
  404688:	aa1403e4 	mov	x4, x20
  40468c:	aa1303e2 	mov	x2, x19
  404690:	aa1803e1 	mov	x1, x24
  404694:	52803fc3 	mov	w3, #0x1fe                 	// #510
  404698:	1a9f17e0 	cset	w0, eq  // eq = none
  40469c:	97fffda6 	bl	403d34 <z_zassert.constprop.0>
  4046a0:	97fffd67 	bl	403c3c <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  4046a4:	f94037e6 	ldr	x6, [sp, #104]
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4046a8:	aa1703e5 	mov	x5, x23
  4046ac:	aa1403e4 	mov	x4, x20
  4046b0:	aa1303e2 	mov	x2, x19
    time_diff = k_uptime_get_32() - start_time;
  4046b4:	4b060006 	sub	w6, w0, w6
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4046b8:	aa1603e1 	mov	x1, x22
  4046bc:	710f9cdf 	cmp	w6, #0x3e7
  4046c0:	52804023 	mov	w3, #0x201                 	// #513
  4046c4:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4046c8:	97fffd9b 	bl	403d34 <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  4046cc:	aa1503e0 	mov	x0, x21
  4046d0:	94002d00 	bl	40fad0 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  4046d4:	aa1b03e1 	mov	x1, x27
  4046d8:	aa1a03e0 	mov	x0, x26
  4046dc:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  4046e0:	52800023 	mov	w3, #0x1                   	// #1
  4046e4:	d2808002 	mov	x2, #0x400                 	// #1024
  4046e8:	97fffcd8 	bl	403a48 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  4046ec:	a94723e7 	ldp	x7, x8, [sp, #112]
  4046f0:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  4046f4:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  4046f8:	aa1403e4 	mov	x4, x20
  4046fc:	aa1303e2 	mov	x2, x19
  404700:	1a9f17e0 	cset	w0, eq  // eq = none
  404704:	528040e3 	mov	w3, #0x207                 	// #519
  404708:	aa0803e5 	mov	x5, x8
  40470c:	aa0703e1 	mov	x1, x7
  404710:	97fffd89 	bl	403d34 <z_zassert.constprop.0>
	return z_impl_k_sem_take(sem, timeout);
  404714:	d2800a01 	mov	x1, #0x50                  	// #80
  404718:	aa1503e0 	mov	x0, x21
  40471c:	94002c7c 	bl	40f90c <z_impl_k_sem_take>
    zassert_equal(ret, -EAGAIN, "Timeout too early");
  404720:	31002c1f 	cmn	w0, #0xb
  404724:	aa1403e4 	mov	x4, x20
  404728:	1a9f17e0 	cset	w0, eq  // eq = none
  40472c:	52804143 	mov	w3, #0x20a                 	// #522
  404730:	aa1303e2 	mov	x2, x19
  404734:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  404738:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  40473c:	913740a5 	add	x5, x5, #0xdd0
  404740:	91378821 	add	x1, x1, #0xde2
  404744:	97fffd7c 	bl	403d34 <z_zassert.constprop.0>
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404748:	52800600 	mov	w0, #0x30                  	// #48
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  40474c:	52804022 	mov	w2, #0x201                 	// #513
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404750:	390223e0 	strb	w0, [sp, #136]
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  404754:	aa1c03e0 	mov	x0, x28
  404758:	72a31b42 	movk	w2, #0x18da, lsl #16
  40475c:	d2800021 	mov	x1, #0x1                   	// #1
  404760:	97fffe21 	bl	403fe4 <send_frame_series>
  404764:	97fffd36 	bl	403c3c <k_uptime_get>
  404768:	aa0003fa 	mov	x26, x0
  40476c:	d2800dc1 	mov	x1, #0x6e                  	// #110
  404770:	aa1503e0 	mov	x0, x21
  404774:	94002c66 	bl	40f90c <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Timeout too late");
  404778:	7100001f 	cmp	w0, #0x0
  40477c:	aa1903e5 	mov	x5, x25
  404780:	aa1403e4 	mov	x4, x20
  404784:	aa1303e2 	mov	x2, x19
  404788:	aa1803e1 	mov	x1, x24
  40478c:	52804223 	mov	w3, #0x211                 	// #529
  404790:	1a9f17e0 	cset	w0, eq  // eq = none
  404794:	97fffd68 	bl	403d34 <z_zassert.constprop.0>
  404798:	97fffd29 	bl	403c3c <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  40479c:	4b1a0006 	sub	w6, w0, w26
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4047a0:	710f9cdf 	cmp	w6, #0x3e7
  4047a4:	aa1303e2 	mov	x2, x19
  4047a8:	aa1603e1 	mov	x1, x22
  4047ac:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4047b0:	aa1703e5 	mov	x5, x23
  4047b4:	aa1403e4 	mov	x4, x20
  4047b8:	52804263 	mov	w3, #0x213                 	// #531
  4047bc:	97fffd5e 	bl	403d34 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_timeouts)
  4047c0:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4047c4:	f9476800 	ldr	x0, [x0, #3792]
  4047c8:	f9404fe2 	ldr	x2, [sp, #152]
  4047cc:	f9400001 	ldr	x1, [x0]
  4047d0:	eb010042 	subs	x2, x2, x1
  4047d4:	d2800001 	mov	x1, #0x0                   	// #0
  4047d8:	54000040 	b.eq	4047e0 <_isotp_fast_conformance_sync_test_send_timeouts_wrapper+0x2f4>  // b.none
  4047dc:	97fff2d1 	bl	401320 <__stack_chk_fail@plt>
  4047e0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4047e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4047e8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4047ec:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4047f0:	a94573fb 	ldp	x27, x28, [sp, #80]
  4047f4:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  4047f8:	d65f03c0 	ret

00000000004047fc <check_data>:
{
  4047fc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  404800:	910003fd 	mov	x29, sp
  404804:	a90153f3 	stp	x19, x20, [sp, #16]
  404808:	aa0003f4 	mov	x20, x0
  40480c:	aa0203f3 	mov	x19, x2
  404810:	a9025bf5 	stp	x21, x22, [sp, #32]
  404814:	aa0103f5 	mov	x21, x1
  404818:	a90363f7 	stp	x23, x24, [sp, #48]
    ret = memcmp(frame, desired, length);
  40481c:	97fff2d9 	bl	401380 <memcmp@plt>
  404820:	2a0003f6 	mov	w22, w0
    if (ret) {
  404824:	340002a0 	cbz	w0, 404878 <check_data+0x7c>
int filter_id;

static void print_hex(const uint8_t *ptr, size_t len)
{
    while (len--) {
        printk("%02x ", *ptr++);
  404828:	f0000077 	adrp	x23, 413000 <sys_clock_announce+0x19c>
  40482c:	8b1302b8 	add	x24, x21, x19
  404830:	913836f7 	add	x23, x23, #0xe0d
        printk("desired bytes:\n");
  404834:	f0000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  404838:	9137f400 	add	x0, x0, #0xdfd
  40483c:	94000777 	bl	406618 <printk>
    while (len--) {
  404840:	eb1802bf 	cmp	x21, x24
  404844:	54000261 	b.ne	404890 <check_data+0x94>  // b.any
        printk("\nreceived (%zu bytes):\n", length);
  404848:	aa1303e1 	mov	x1, x19
        printk("%02x ", *ptr++);
  40484c:	f0000075 	adrp	x21, 413000 <sys_clock_announce+0x19c>
  404850:	8b130293 	add	x19, x20, x19
  404854:	913836b5 	add	x21, x21, #0xe0d
  404858:	f0000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  40485c:	91384c00 	add	x0, x0, #0xe13
  404860:	9400076e 	bl	406618 <printk>
    while (len--) {
  404864:	eb13029f 	cmp	x20, x19
  404868:	540001c1 	b.ne	4048a0 <check_data+0xa4>  // b.any
        printk("\n");
  40486c:	b0000080 	adrp	x0, 415000 <random_data+0xb30>
  404870:	913b7800 	add	x0, x0, #0xede
  404874:	94000769 	bl	406618 <printk>
}
  404878:	2a1603e0 	mov	w0, w22
  40487c:	a94153f3 	ldp	x19, x20, [sp, #16]
  404880:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404884:	a94363f7 	ldp	x23, x24, [sp, #48]
  404888:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40488c:	d65f03c0 	ret
        printk("%02x ", *ptr++);
  404890:	384016a1 	ldrb	w1, [x21], #1
  404894:	aa1703e0 	mov	x0, x23
  404898:	94000760 	bl	406618 <printk>
  40489c:	17ffffe9 	b	404840 <check_data+0x44>
  4048a0:	38401681 	ldrb	w1, [x20], #1
  4048a4:	aa1503e0 	mov	x0, x21
  4048a8:	9400075c 	bl	406618 <printk>
  4048ac:	17ffffee 	b	404864 <check_data+0x68>

00000000004048b0 <check_frame_series.constprop.0>:
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  4048b0:	d10303ff 	sub	sp, sp, #0xc0
  4048b4:	a9047bfd 	stp	x29, x30, [sp, #64]
  4048b8:	910103fd 	add	x29, sp, #0x40
  4048bc:	a90553f3 	stp	x19, x20, [sp, #80]
  4048c0:	aa0003f3 	mov	x19, x0
  4048c4:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4048c8:	a9065bf5 	stp	x21, x22, [sp, #96]
    for (i = 0; i < length; i++) {
  4048cc:	52800014 	mov	w20, #0x0                   	// #0
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  4048d0:	f9476800 	ldr	x0, [x0, #3792]
  4048d4:	a90763f7 	stp	x23, x24, [sp, #112]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  4048d8:	f0000078 	adrp	x24, 413000 <sys_clock_announce+0x19c>
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  4048dc:	a9086bf9 	stp	x25, x26, [sp, #128]
  4048e0:	2a0103f7 	mov	w23, w1
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  4048e4:	9138af18 	add	x24, x24, #0xe2b
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  4048e8:	a90973fb 	stp	x27, x28, [sp, #144]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  4048ec:	9000009b 	adrp	x27, 414000 <dlc_table.0+0x60d>
  4048f0:	f000007c 	adrp	x28, 413000 <sys_clock_announce+0x19c>
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  4048f4:	f9400002 	ldr	x2, [x0]
  4048f8:	f9005fe2 	str	x2, [sp, #184]
  4048fc:	d2800002 	mov	x2, #0x0                   	// #0
        zassert_equal(can_dlc_to_bytes(frame.dlc),
  404900:	910bbb76 	add	x22, x27, #0x2ee
  404904:	91280f95 	add	x21, x28, #0xa03
        ret = k_msgq_get(msgq, &frame, K_MSEC(500));
  404908:	9102a3f9 	add	x25, sp, #0xa8
  40490c:	d2800641 	mov	x1, #0x32                  	// #50
  404910:	aa1903e0 	mov	x0, x25
  404914:	97fffe8d 	bl	404348 <k_msgq_get.constprop.0>
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404918:	7100001f 	cmp	w0, #0x0
        ret = k_msgq_get(msgq, &frame, K_MSEC(500));
  40491c:	2a0003e7 	mov	w7, w0
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404920:	2a1403e6 	mov	w6, w20
  404924:	aa1803e5 	mov	x5, x24
  404928:	910bbb64 	add	x4, x27, #0x2ee
  40492c:	91280f82 	add	x2, x28, #0xa03
  404930:	1a9f17e0 	cset	w0, eq  // eq = none
  404934:	f000007a 	adrp	x26, 413000 <sys_clock_announce+0x19c>
  404938:	52801143 	mov	w3, #0x8a                  	// #138
  40493c:	912b6b41 	add	x1, x26, #0xada
  404940:	97fffcfd 	bl	403d34 <z_zassert.constprop.0>
        zassert_equal(can_dlc_to_bytes(frame.dlc),
  404944:	3942b3e1 	ldrb	w1, [sp, #172]
	return dlc > 0x0F ? 64 : dlc_table[dlc];
  404948:	71003c3f 	cmp	w1, #0xf
  40494c:	540009e8 	b.hi	404a88 <check_frame_series.constprop.0+0x1d8>  // b.pmore
  404950:	90000080 	adrp	x0, 414000 <dlc_table.0+0x60d>
  404954:	9112f400 	add	x0, x0, #0x4bd
  404958:	3861c801 	ldrb	w1, [x0, w1, sxtw]
  40495c:	39402267 	ldrb	w7, [x19, #8]
  404960:	2a0703e0 	mov	w0, w7
  404964:	97fffcbd 	bl	403c58 <can_bytes_to_dlc>
  404968:	12001c00 	and	w0, w0, #0xff
  40496c:	71003c1f 	cmp	w0, #0xf
  404970:	54000908 	b.hi	404a90 <check_frame_series.constprop.0+0x1e0>  // b.pmore
  404974:	90000082 	adrp	x2, 414000 <dlc_table.0+0x60d>
  404978:	9112f442 	add	x2, x2, #0x4bd
  40497c:	3860c840 	ldrb	w0, [x2, w0, sxtw]
  404980:	6b01001f 	cmp	w0, w1
  404984:	b90003e1 	str	w1, [sp]
  404988:	2a1403e6 	mov	w6, w20
  40498c:	aa1603e4 	mov	x4, x22
  404990:	1a9f17e0 	cset	w0, eq  // eq = none
  404994:	528011e3 	mov	w3, #0x8f                  	// #143
  404998:	aa1503e2 	mov	x2, x21
  40499c:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4049a0:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4049a4:	913948a5 	add	x5, x5, #0xe52
  4049a8:	913a0821 	add	x1, x1, #0xe82
  4049ac:	97fffce2 	bl	403d34 <z_zassert.constprop.0>
        ret = check_data(frame.data, desired->data, desired->length);
  4049b0:	39402262 	ldrb	w2, [x19, #8]
  4049b4:	aa1303e1 	mov	x1, x19
  4049b8:	9102c3e0 	add	x0, sp, #0xb0
    for (i = 0; i < length; i++) {
  4049bc:	11000694 	add	w20, w20, #0x1
        desired++;
  4049c0:	91002673 	add	x19, x19, #0x9
        ret = check_data(frame.data, desired->data, desired->length);
  4049c4:	97ffff8e 	bl	4047fc <check_data>
        zassert_equal(ret, 0, "Data differ");
  4049c8:	7100001f 	cmp	w0, #0x0
  4049cc:	aa1603e4 	mov	x4, x22
  4049d0:	aa1503e2 	mov	x2, x21
  4049d4:	912b6b41 	add	x1, x26, #0xada
  4049d8:	1a9f17e0 	cset	w0, eq  // eq = none
  4049dc:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4049e0:	528012a3 	mov	w3, #0x95                  	// #149
  4049e4:	913b84a5 	add	x5, x5, #0xee1
  4049e8:	97fffcd3 	bl	403d34 <z_zassert.constprop.0>
    for (i = 0; i < length; i++) {
  4049ec:	6b17029f 	cmp	w20, w23
  4049f0:	54fff8c1 	b.ne	404908 <check_frame_series.constprop.0+0x58>  // b.any
    ret = k_msgq_get(msgq, &frame, K_MSEC(200));
  4049f4:	d2800281 	mov	x1, #0x14                  	// #20
  4049f8:	aa1903e0 	mov	x0, x25
  4049fc:	97fffe53 	bl	404348 <k_msgq_get.constprop.0>
    zassert_equal(ret, -EAGAIN,
  404a00:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(msgq, &frame, K_MSEC(200));
  404a04:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN,
  404a08:	3942dfe0 	ldrb	w0, [sp, #183]
  404a0c:	b90033e0 	str	w0, [sp, #48]
  404a10:	aa1503e2 	mov	x2, x21
  404a14:	3942dbe0 	ldrb	w0, [sp, #182]
  404a18:	aa1603e4 	mov	x4, x22
  404a1c:	b9002be0 	str	w0, [sp, #40]
  404a20:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  404a24:	3942d7e0 	ldrb	w0, [sp, #181]
  404a28:	913bb4a5 	add	x5, x5, #0xeed
  404a2c:	b90023e0 	str	w0, [sp, #32]
  404a30:	52801343 	mov	w3, #0x9a                  	// #154
  404a34:	3942d3e0 	ldrb	w0, [sp, #180]
  404a38:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404a3c:	b9001be0 	str	w0, [sp, #24]
  404a40:	91378821 	add	x1, x1, #0xde2
  404a44:	3942cfe0 	ldrb	w0, [sp, #179]
  404a48:	3942c3e7 	ldrb	w7, [sp, #176]
  404a4c:	b90013e0 	str	w0, [sp, #16]
  404a50:	3942cbe0 	ldrb	w0, [sp, #178]
  404a54:	b9000be0 	str	w0, [sp, #8]
  404a58:	3942c7e0 	ldrb	w0, [sp, #177]
  404a5c:	b90003e0 	str	w0, [sp]
  404a60:	1a9f17e0 	cset	w0, eq  // eq = none
  404a64:	97fffcb4 	bl	403d34 <z_zassert.constprop.0>
}
  404a68:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  404a6c:	f9476800 	ldr	x0, [x0, #3792]
  404a70:	f9405fe2 	ldr	x2, [sp, #184]
  404a74:	f9400001 	ldr	x1, [x0]
  404a78:	eb010042 	subs	x2, x2, x1
  404a7c:	d2800001 	mov	x1, #0x0                   	// #0
  404a80:	540000c0 	b.eq	404a98 <check_frame_series.constprop.0+0x1e8>  // b.none
  404a84:	97fff227 	bl	401320 <__stack_chk_fail@plt>
  404a88:	52800801 	mov	w1, #0x40                  	// #64
  404a8c:	17ffffb4 	b	40495c <check_frame_series.constprop.0+0xac>
  404a90:	52800800 	mov	w0, #0x40                  	// #64
  404a94:	17ffffbb 	b	404980 <check_frame_series.constprop.0+0xd0>
  404a98:	a9447bfd 	ldp	x29, x30, [sp, #64]
  404a9c:	a94553f3 	ldp	x19, x20, [sp, #80]
  404aa0:	a9465bf5 	ldp	x21, x22, [sp, #96]
  404aa4:	a94763f7 	ldp	x23, x24, [sp, #112]
  404aa8:	a9486bf9 	ldp	x25, x26, [sp, #128]
  404aac:	a94973fb 	ldp	x27, x28, [sp, #144]
  404ab0:	910303ff 	add	sp, sp, #0xc0
  404ab4:	d65f03c0 	ret

0000000000404ab8 <_isotp_fast_conformance_sync_test_stmin_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404ab8:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  404abc:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  404ac0:	910003fd 	mov	x29, sp
  404ac4:	f9476800 	ldr	x0, [x0, #3792]
  404ac8:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404acc:	90000094 	adrp	x20, 414000 <dlc_table.0+0x60d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404ad0:	a9025bf5 	stp	x21, x22, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404ad4:	910ef294 	add	x20, x20, #0x3bc
  404ad8:	f0000073 	adrp	x19, 413000 <sys_clock_announce+0x19c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404adc:	a90363f7 	stp	x23, x24, [sp, #48]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404ae0:	91280e73 	add	x19, x19, #0xa03
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404ae4:	910223f6 	add	x22, sp, #0x88
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404ae8:	a9046bf9 	stp	x25, x26, [sp, #64]
    send_frame_series(&fc_frame, 1, tx_addr);
  404aec:	9101a3fa 	add	x26, sp, #0x68
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404af0:	f0000079 	adrp	x25, 413000 <sys_clock_announce+0x19c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404af4:	f9002bfb 	str	x27, [sp, #80]
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404af8:	913ce339 	add	x25, x25, #0xf38
  404afc:	f0000075 	adrp	x21, 413000 <sys_clock_announce+0x19c>
  404b00:	912b6ab5 	add	x21, x21, #0xada
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404b04:	f9400001 	ldr	x1, [x0]
  404b08:	f9004fe1 	str	x1, [sp, #152]
  404b0c:	d2800001 	mov	x1, #0x0                   	// #0
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  404b10:	f0000078 	adrp	x24, 413000 <sys_clock_announce+0x19c>
  404b14:	913d6318 	add	x24, x24, #0xf58
        ztest_test_skip();
  404b18:	94001abc 	bl	40b608 <ztest_test_skip>
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SIZE_FF + DATA_SIZE_CF * 4);
  404b1c:	52844200 	mov	w0, #0x2210                	// #8720
  404b20:	7900f3e0 	strh	w0, [sp, #120]
  404b24:	90000080 	adrp	x0, 414000 <dlc_table.0+0x60d>
  404b28:	91134000 	add	x0, x0, #0x4d0
  404b2c:	b9400001 	ldr	w1, [x0]
  404b30:	79400800 	ldrh	w0, [x0, #4]
  404b34:	7900ffe0 	strh	w0, [sp, #126]
    ff_frame.length = DATA_SIZE_FF + 2;
  404b38:	52800100 	mov	w0, #0x8                   	// #8
  404b3c:	390203e0 	strb	w0, [sp, #128]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404b40:	52804600 	mov	w0, #0x230                 	// #560
  404b44:	7900d3e0 	strh	w0, [sp, #104]
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_1);
  404b48:	528000a0 	mov	w0, #0x5                   	// #5
  404b4c:	3901abe0 	strb	w0, [sp, #106]
    fc_frame.length = DATA_SIZE_FC;
  404b50:	52800060 	mov	w0, #0x3                   	// #3
  404b54:	3901c3e0 	strb	w0, [sp, #112]
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  404b58:	52804020 	mov	w0, #0x201                 	// #513
  404b5c:	b807a3e1 	stur	w1, [sp, #122]
  404b60:	72a31b40 	movk	w0, #0x18da, lsl #16
  404b64:	97fffce4 	bl	403ef4 <add_rx_msgq.constprop.0>
  404b68:	2a0003e6 	mov	w6, w0
  404b6c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404b70:	aa1403e4 	mov	x4, x20
  404b74:	aa1303e2 	mov	x2, x19
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  404b78:	f947b000 	ldr	x0, [x0, #3936]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404b7c:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  404b80:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404b84:	912c60a5 	add	x5, x5, #0xb18
  404b88:	912cd021 	add	x1, x1, #0xb34
  404b8c:	528048a3 	mov	w3, #0x245                 	// #581
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  404b90:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  404b94:	2a2603e0 	mvn	w0, w6
  404b98:	531f7c00 	lsr	w0, w0, #31
  404b9c:	97fffc66 	bl	403d34 <z_zassert.constprop.0>
    send_test_data(random_data, DATA_SIZE_FF + DATA_SIZE_CF * 4);
  404ba0:	d2800440 	mov	x0, #0x22                  	// #34
  404ba4:	97fffcbc 	bl	403e94 <send_test_data.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404ba8:	9101e3e0 	add	x0, sp, #0x78
  404bac:	d2800021 	mov	x1, #0x1                   	// #1
  404bb0:	97ffff40 	bl	4048b0 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, tx_addr);
  404bb4:	52802042 	mov	w2, #0x102                 	// #258
  404bb8:	aa1a03e0 	mov	x0, x26
  404bbc:	72a31b42 	movk	w2, #0x18da, lsl #16
  404bc0:	d2800021 	mov	x1, #0x1                   	// #1
  404bc4:	97fffd08 	bl	403fe4 <send_frame_series>
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404bc8:	d2800141 	mov	x1, #0xa                   	// #10
  404bcc:	aa1603e0 	mov	x0, x22
  404bd0:	97fffdde 	bl	404348 <k_msgq_get.constprop.0>
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404bd4:	7100001f 	cmp	w0, #0x0
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404bd8:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404bdc:	aa1903e5 	mov	x5, x25
  404be0:	aa1403e4 	mov	x4, x20
  404be4:	aa1303e2 	mov	x2, x19
  404be8:	aa1503e1 	mov	x1, x21
  404bec:	528049c3 	mov	w3, #0x24e                 	// #590
  404bf0:	1a9f17e0 	cset	w0, eq  // eq = none
  404bf4:	97fffc50 	bl	403d34 <z_zassert.constprop.0>
  404bf8:	97fffc11 	bl	403c3c <k_uptime_get>
  404bfc:	aa0003fb 	mov	x27, x0
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(STMIN_VAL_1 + STMIN_UPPER_TOLERANCE));
  404c00:	d2800021 	mov	x1, #0x1                   	// #1
  404c04:	aa1603e0 	mov	x0, x22
  404c08:	97fffdd0 	bl	404348 <k_msgq_get.constprop.0>
  404c0c:	2a0003f7 	mov	w23, w0
  404c10:	97fffc0b 	bl	403c3c <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  404c14:	4b1b001b 	sub	w27, w0, w27
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  404c18:	710002ff 	cmp	w23, #0x0
  404c1c:	2a1703e7 	mov	w7, w23
  404c20:	aa1803e5 	mov	x5, x24
  404c24:	aa1403e4 	mov	x4, x20
  404c28:	aa1303e2 	mov	x2, x19
  404c2c:	aa1503e1 	mov	x1, x21
  404c30:	1a9f17e0 	cset	w0, eq  // eq = none
  404c34:	52800146 	mov	w6, #0xa                   	// #10
  404c38:	52804a63 	mov	w3, #0x253                 	// #595
  404c3c:	97fffc3e 	bl	403d34 <z_zassert.constprop.0>
    zassert_true(time_diff >= STMIN_VAL_1, "STmin too short (%dms)", time_diff);
  404c40:	7100137f 	cmp	w27, #0x4
  404c44:	f0000077 	adrp	x23, 413000 <sys_clock_announce+0x19c>
  404c48:	913e12f7 	add	x23, x23, #0xf84
  404c4c:	2a1b03e6 	mov	w6, w27
  404c50:	aa1703e5 	mov	x5, x23
  404c54:	aa1403e4 	mov	x4, x20
  404c58:	1a9f97e0 	cset	w0, hi  // hi = pmore
  404c5c:	52804aa3 	mov	w3, #0x255                 	// #597
  404c60:	aa1303e2 	mov	x2, x19
  404c64:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404c68:	913e6c21 	add	x1, x1, #0xf9b
  404c6c:	97fffc32 	bl	403d34 <z_zassert.constprop.0>
    send_frame_series(&fc_frame, 1, tx_addr);
  404c70:	52802042 	mov	w2, #0x102                 	// #258
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_2);
  404c74:	52800640 	mov	w0, #0x32                  	// #50
    send_frame_series(&fc_frame, 1, tx_addr);
  404c78:	72a31b42 	movk	w2, #0x18da, lsl #16
  404c7c:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_2);
  404c80:	3901abe0 	strb	w0, [sp, #106]
    send_frame_series(&fc_frame, 1, tx_addr);
  404c84:	aa1a03e0 	mov	x0, x26
  404c88:	97fffcd7 	bl	403fe4 <send_frame_series>
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404c8c:	d2800141 	mov	x1, #0xa                   	// #10
  404c90:	aa1603e0 	mov	x0, x22
  404c94:	97fffdad 	bl	404348 <k_msgq_get.constprop.0>
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404c98:	7100001f 	cmp	w0, #0x0
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(100));
  404c9c:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  404ca0:	aa1903e5 	mov	x5, x25
  404ca4:	aa1403e4 	mov	x4, x20
  404ca8:	aa1303e2 	mov	x2, x19
  404cac:	aa1503e1 	mov	x1, x21
  404cb0:	52804b63 	mov	w3, #0x25b                 	// #603
  404cb4:	1a9f17e0 	cset	w0, eq  // eq = none
  404cb8:	97fffc1f 	bl	403d34 <z_zassert.constprop.0>
  404cbc:	97fffbe0 	bl	403c3c <k_uptime_get>
  404cc0:	aa0003fa 	mov	x26, x0
    ret = k_msgq_get(&frame_msgq, &raw_frame, K_MSEC(STMIN_VAL_2 + STMIN_UPPER_TOLERANCE));
  404cc4:	d28000c1 	mov	x1, #0x6                   	// #6
  404cc8:	aa1603e0 	mov	x0, x22
  404ccc:	97fffd9f 	bl	404348 <k_msgq_get.constprop.0>
  404cd0:	2a0003f9 	mov	w25, w0
  404cd4:	97fffbda 	bl	403c3c <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  404cd8:	4b1a001a 	sub	w26, w0, w26
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  404cdc:	7100033f 	cmp	w25, #0x0
  404ce0:	2a1903e7 	mov	w7, w25
  404ce4:	aa1803e5 	mov	x5, x24
  404ce8:	aa1403e4 	mov	x4, x20
  404cec:	aa1303e2 	mov	x2, x19
  404cf0:	aa1503e1 	mov	x1, x21
  404cf4:	1a9f17e0 	cset	w0, eq  // eq = none
  404cf8:	528006e6 	mov	w6, #0x37                  	// #55
  404cfc:	52804c03 	mov	w3, #0x260                 	// #608
  404d00:	97fffc0d 	bl	403d34 <z_zassert.constprop.0>
    zassert_true(time_diff >= STMIN_VAL_2, "STmin too short (%dms)", time_diff);
  404d04:	7100c75f 	cmp	w26, #0x31
  404d08:	aa1303e2 	mov	x2, x19
  404d0c:	1a9f97e0 	cset	w0, hi  // hi = pmore
  404d10:	2a1a03e6 	mov	w6, w26
  404d14:	aa1703e5 	mov	x5, x23
  404d18:	aa1403e4 	mov	x4, x20
  404d1c:	52804c43 	mov	w3, #0x262                 	// #610
  404d20:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404d24:	913efc21 	add	x1, x1, #0xfbf
  404d28:	97fffc03 	bl	403d34 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  404d2c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  404d30:	f9476800 	ldr	x0, [x0, #3792]
  404d34:	f9404fe2 	ldr	x2, [sp, #152]
  404d38:	f9400001 	ldr	x1, [x0]
  404d3c:	eb010042 	subs	x2, x2, x1
  404d40:	d2800001 	mov	x1, #0x0                   	// #0
  404d44:	54000040 	b.eq	404d4c <_isotp_fast_conformance_sync_test_stmin_wrapper+0x294>  // b.none
  404d48:	97fff176 	bl	401320 <__stack_chk_fail@plt>
  404d4c:	a94153f3 	ldp	x19, x20, [sp, #16]
  404d50:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404d54:	a94363f7 	ldp	x23, x24, [sp, #48]
  404d58:	a9446bf9 	ldp	x25, x26, [sp, #64]
  404d5c:	f9402bfb 	ldr	x27, [sp, #80]
  404d60:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  404d64:	d65f03c0 	ret

0000000000404d68 <_isotp_fast_conformance_sync_test_sender_fc_errors_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  404d68:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  404d6c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  404d70:	910003fd 	mov	x29, sp
  404d74:	f9476800 	ldr	x0, [x0, #3792]
  404d78:	a90153f3 	stp	x19, x20, [sp, #16]
  404d7c:	90000093 	adrp	x19, 414000 <dlc_table.0+0x60d>
  404d80:	91134273 	add	x19, x19, #0x4d0
  404d84:	a9025bf5 	stp	x21, x22, [sp, #32]
  404d88:	9101e3f5 	add	x21, sp, #0x78
  404d8c:	a90363f7 	stp	x23, x24, [sp, #48]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404d90:	f0000137 	adrp	x23, 42b000 <__FRAME_END__+0xfd74>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  404d94:	a9046bf9 	stp	x25, x26, [sp, #64]
  404d98:	a90573fb 	stp	x27, x28, [sp, #80]
  404d9c:	f9400001 	ldr	x1, [x0]
  404da0:	f9004fe1 	str	x1, [sp, #152]
  404da4:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  404da8:	52820220 	mov	w0, #0x1011                	// #4113
  404dac:	7900f3e0 	strh	w0, [sp, #120]
  404db0:	b9400260 	ldr	w0, [x19]
  404db4:	b807a3e0 	stur	w0, [sp, #122]
  404db8:	79400a60 	ldrh	w0, [x19, #4]
  404dbc:	7900ffe0 	strh	w0, [sp, #126]
    ff_frame.length = DATA_SIZE_FF + 2;
  404dc0:	52800100 	mov	w0, #0x8                   	// #8
  404dc4:	390203e0 	strb	w0, [sp, #128]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404dc8:	52802040 	mov	w0, #0x102                 	// #258
  404dcc:	72a31b40 	movk	w0, #0x18da, lsl #16
  404dd0:	97fffc49 	bl	403ef4 <add_rx_msgq.constprop.0>
  404dd4:	f947b2f7 	ldr	x23, [x23, #3936]
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  404dd8:	39022bff 	strb	wzr, [sp, #138]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404ddc:	b90002e0 	str	w0, [x23]
    fc_frame.data[0] = FC_PCI_BYTE_1(3);
  404de0:	52810660 	mov	w0, #0x833                 	// #2099
  404de4:	790113e0 	strh	w0, [sp, #136]
    fc_frame.length = DATA_SIZE_FC;
  404de8:	52800060 	mov	w0, #0x3                   	// #3
  404dec:	390243e0 	strb	w0, [sp, #144]
	z_impl_k_sem_reset(sem);
  404df0:	f0000138 	adrp	x24, 42b000 <__FRAME_END__+0xfd74>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404df4:	f0000134 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
    send_frame_series(&fc_frame, 1, rx_addr);
  404df8:	910223f9 	add	x25, sp, #0x88
  404dfc:	f947fb16 	ldr	x22, [x24, #4080]
  404e00:	aa1603e0 	mov	x0, x22
  404e04:	94002b33 	bl	40fad0 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404e08:	f9471294 	ldr	x20, [x20, #3616]
  404e0c:	aa1303e1 	mov	x1, x19
  404e10:	92800084 	mov	x4, #0xfffffffffffffffb    	// #-5
  404e14:	52800023 	mov	w3, #0x1                   	// #1
  404e18:	aa1403e0 	mov	x0, x20
  404e1c:	d2802202 	mov	x2, #0x110                 	// #272
  404e20:	97fffb0a 	bl	403a48 <isotp_fast_send>
  404e24:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404e28:	90000080 	adrp	x0, 414000 <dlc_table.0+0x60d>
  404e2c:	710000df 	cmp	w6, #0x0
  404e30:	910c541b 	add	x27, x0, #0x315
  404e34:	f0000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  404e38:	91280c1a 	add	x26, x0, #0xa03
  404e3c:	aa1b03e4 	mov	x4, x27
  404e40:	aa1a03e2 	mov	x2, x26
  404e44:	f0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  404e48:	912b24a5 	add	x5, x5, #0xac9
  404e4c:	52805463 	mov	w3, #0x2a3                 	// #675
  404e50:	1a9f17e0 	cset	w0, eq  // eq = none
  404e54:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404e58:	9136c821 	add	x1, x1, #0xdb2
  404e5c:	97fffbb6 	bl	403d34 <z_zassert.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404e60:	aa1503e0 	mov	x0, x21
  404e64:	d2800021 	mov	x1, #0x1                   	// #1
  404e68:	97fffe92 	bl	4048b0 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  404e6c:	52804022 	mov	w2, #0x201                 	// #513
  404e70:	aa1903e0 	mov	x0, x25
  404e74:	72a31b42 	movk	w2, #0x18da, lsl #16
  404e78:	d2800021 	mov	x1, #0x1                   	// #1
  404e7c:	97fffc5a 	bl	403fe4 <send_frame_series>
	return z_impl_k_sem_take(sem, timeout);
  404e80:	d2800281 	mov	x1, #0x14                  	// #20
  404e84:	aa1603e0 	mov	x0, x22
  404e88:	94002aa1 	bl	40f90c <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  404e8c:	f000007c 	adrp	x28, 413000 <sys_clock_announce+0x19c>
  404e90:	7100001f 	cmp	w0, #0x0
  404e94:	913f8f8b 	add	x11, x28, #0xfe3
  404e98:	f0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  404e9c:	912b682a 	add	x10, x1, #0xada
  404ea0:	aa0a03e1 	mov	x1, x10
  404ea4:	aa0b03e5 	mov	x5, x11
  404ea8:	aa1b03e4 	mov	x4, x27
  404eac:	aa1a03e2 	mov	x2, x26
  404eb0:	1a9f17e0 	cset	w0, eq  // eq = none
  404eb4:	52805503 	mov	w3, #0x2a8                 	// #680
  404eb8:	a9062fea 	stp	x10, x11, [sp, #96]
  404ebc:	97fffb9e 	bl	403d34 <z_zassert.constprop.0>
    can_remove_rx_filter(can_dev, filter_id);
  404ec0:	b94002e1 	ldr	w1, [x23]
	return api->remove_rx_filter(dev, filter_id);
  404ec4:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  404ec8:	f9472400 	ldr	x0, [x0, #3656]
  404ecc:	f9400802 	ldr	x2, [x0, #16]
  404ed0:	f9401c42 	ldr	x2, [x2, #56]
  404ed4:	d63f0040 	blr	x2
    ret = isotp_fast_send(&ctx, random_data, 5 * 1024, rx_node_id, NULL);
  404ed8:	aa1303e1 	mov	x1, x19
  404edc:	aa1403e0 	mov	x0, x20
  404ee0:	d2800004 	mov	x4, #0x0                   	// #0
  404ee4:	52800023 	mov	w3, #0x1                   	// #1
  404ee8:	d2828002 	mov	x2, #0x1400                	// #5120
  404eec:	97fffad7 	bl	403a48 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_BUFFER_OVERFLW, "Expected overflow but got %d", ret);
  404ef0:	3100201f 	cmn	w0, #0x8
    ret = isotp_fast_send(&ctx, random_data, 5 * 1024, rx_node_id, NULL);
  404ef4:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_BUFFER_OVERFLW, "Expected overflow but got %d", ret);
  404ef8:	aa1b03e4 	mov	x4, x27
  404efc:	aa1a03e2 	mov	x2, x26
  404f00:	90000085 	adrp	x5, 414000 <dlc_table.0+0x60d>
  404f04:	90000081 	adrp	x1, 414000 <dlc_table.0+0x60d>
  404f08:	910014a5 	add	x5, x5, #0x5
  404f0c:	91008821 	add	x1, x1, #0x22
  404f10:	1a9f17e0 	cset	w0, eq  // eq = none
  404f14:	528055c3 	mov	w3, #0x2ae                 	// #686
  404f18:	97fffb87 	bl	403d34 <z_zassert.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404f1c:	52802040 	mov	w0, #0x102                 	// #258
  404f20:	72a31b40 	movk	w0, #0x18da, lsl #16
  404f24:	97fffbf4 	bl	403ef4 <add_rx_msgq.constprop.0>
  404f28:	b90002e0 	str	w0, [x23]
	z_impl_k_sem_reset(sem);
  404f2c:	aa1603e0 	mov	x0, x22
  404f30:	94002ae8 	bl	40fad0 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404f34:	928000e4 	mov	x4, #0xfffffffffffffff8    	// #-8
  404f38:	52800023 	mov	w3, #0x1                   	// #1
  404f3c:	d2802202 	mov	x2, #0x110                 	// #272
  404f40:	aa1303e1 	mov	x1, x19
  404f44:	aa1403e0 	mov	x0, x20
  404f48:	97fffac0 	bl	403a48 <isotp_fast_send>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404f4c:	aa1503e0 	mov	x0, x21
  404f50:	d2800021 	mov	x1, #0x1                   	// #1
  404f54:	97fffe57 	bl	4048b0 <check_frame_series.constprop.0>
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_OVFLW);
  404f58:	52800640 	mov	w0, #0x32                  	// #50
    send_frame_series(&fc_frame, 1, rx_addr);
  404f5c:	52804022 	mov	w2, #0x201                 	// #513
  404f60:	72a31b42 	movk	w2, #0x18da, lsl #16
  404f64:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_OVFLW);
  404f68:	390223e0 	strb	w0, [sp, #136]
    send_frame_series(&fc_frame, 1, rx_addr);
  404f6c:	aa1903e0 	mov	x0, x25
  404f70:	97fffc1d 	bl	403fe4 <send_frame_series>
	return z_impl_k_sem_take(sem, timeout);
  404f74:	d2800281 	mov	x1, #0x14                  	// #20
  404f78:	aa1603e0 	mov	x0, x22
  404f7c:	94002a64 	bl	40f90c <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  404f80:	7100001f 	cmp	w0, #0x0
  404f84:	a9462fea 	ldp	x10, x11, [sp, #96]
  404f88:	aa1b03e4 	mov	x4, x27
  404f8c:	aa1a03e2 	mov	x2, x26
  404f90:	1a9f17e0 	cset	w0, eq  // eq = none
  404f94:	52805723 	mov	w3, #0x2b9                 	// #697
  404f98:	aa0b03e5 	mov	x5, x11
  404f9c:	aa0a03e1 	mov	x1, x10
  404fa0:	97fffb65 	bl	403d34 <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  404fa4:	aa1603e0 	mov	x0, x22
  404fa8:	94002aca 	bl	40fad0 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404fac:	928000c4 	mov	x4, #0xfffffffffffffff9    	// #-7
  404fb0:	52800023 	mov	w3, #0x1                   	// #1
  404fb4:	d2802202 	mov	x2, #0x110                 	// #272
  404fb8:	aa1303e1 	mov	x1, x19
  404fbc:	aa1403e0 	mov	x0, x20
  404fc0:	97fffaa2 	bl	403a48 <isotp_fast_send>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404fc4:	aa1503e0 	mov	x0, x21
  404fc8:	d2800021 	mov	x1, #0x1                   	// #1
        send_frame_series(&fc_frame, 1, rx_addr);
  404fcc:	52804034 	mov	w20, #0x201                 	// #513
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404fd0:	97fffe38 	bl	4048b0 <check_frame_series.constprop.0>
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_WAIT);
  404fd4:	52800620 	mov	w0, #0x31                  	// #49
  404fd8:	52800173 	mov	w19, #0xb                   	// #11
        send_frame_series(&fc_frame, 1, rx_addr);
  404fdc:	72a31b54 	movk	w20, #0x18da, lsl #16
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_WAIT);
  404fe0:	390223e0 	strb	w0, [sp, #136]
        send_frame_series(&fc_frame, 1, rx_addr);
  404fe4:	2a1403e2 	mov	w2, w20
  404fe8:	aa1903e0 	mov	x0, x25
  404fec:	d2800021 	mov	x1, #0x1                   	// #1
  404ff0:	97fffbfd 	bl	403fe4 <send_frame_series>
    for (i = 0; i < CONFIG_ISOTP_WFTMAX + 1; i++) {
  404ff4:	71000673 	subs	w19, w19, #0x1
  404ff8:	54ffff61 	b.ne	404fe4 <_isotp_fast_conformance_sync_test_sender_fc_errors_wrapper+0x27c>  // b.any
	return z_impl_k_sem_take(sem, timeout);
  404ffc:	f947fb00 	ldr	x0, [x24, #4080]
  405000:	d2800281 	mov	x1, #0x14                  	// #20
  405004:	94002a42 	bl	40f90c <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  405008:	7100001f 	cmp	w0, #0x0
  40500c:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405010:	910c5404 	add	x4, x0, #0x315
  405014:	d0000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  405018:	91280c02 	add	x2, x0, #0xa03
  40501c:	d0000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  405020:	913f8f85 	add	x5, x28, #0xfe3
  405024:	912b6801 	add	x1, x0, #0xada
  405028:	528058e3 	mov	w3, #0x2c7                 	// #711
  40502c:	1a9f17e0 	cset	w0, eq  // eq = none
  405030:	97fffb41 	bl	403d34 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  405034:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405038:	f9476800 	ldr	x0, [x0, #3792]
  40503c:	f9404fe2 	ldr	x2, [sp, #152]
  405040:	f9400001 	ldr	x1, [x0]
  405044:	eb010042 	subs	x2, x2, x1
  405048:	d2800001 	mov	x1, #0x0                   	// #0
  40504c:	54000040 	b.eq	405054 <_isotp_fast_conformance_sync_test_sender_fc_errors_wrapper+0x2ec>  // b.none
  405050:	97fff0b4 	bl	401320 <__stack_chk_fail@plt>
  405054:	a94153f3 	ldp	x19, x20, [sp, #16]
  405058:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40505c:	a94363f7 	ldp	x23, x24, [sp, #48]
  405060:	a9446bf9 	ldp	x25, x26, [sp, #64]
  405064:	a94573fb 	ldp	x27, x28, [sp, #80]
  405068:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  40506c:	d65f03c0 	ret

0000000000405070 <_isotp_fast_conformance_sync_test_receiver_fc_errors_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  405070:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  405074:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405078:	910003fd 	mov	x29, sp
  40507c:	f9476800 	ldr	x0, [x0, #3792]
  405080:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405084:	f0000074 	adrp	x20, 414000 <dlc_table.0+0x60d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  405088:	f9400001 	ldr	x1, [x0]
  40508c:	f90027e1 	str	x1, [sp, #72]
  405090:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  405094:	52820220 	mov	w0, #0x1011                	// #4113
  405098:	790043e0 	strh	w0, [sp, #32]
  40509c:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4050a0:	91134000 	add	x0, x0, #0x4d0
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  4050a4:	3900cbff 	strb	wzr, [sp, #50]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4050a8:	910e2294 	add	x20, x20, #0x388
  4050ac:	d0000073 	adrp	x19, 413000 <sys_clock_announce+0x19c>
  4050b0:	91280e73 	add	x19, x19, #0xa03
  4050b4:	b9400001 	ldr	w1, [x0]
  4050b8:	79400800 	ldrh	w0, [x0, #4]
  4050bc:	79004fe0 	strh	w0, [sp, #38]
    ff_frame.length = DATA_SIZE_FF + 2;
  4050c0:	52800100 	mov	w0, #0x8                   	// #8
  4050c4:	3900a3e0 	strb	w0, [sp, #40]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  4050c8:	52810600 	mov	w0, #0x830                 	// #2096
  4050cc:	790063e0 	strh	w0, [sp, #48]
    fc_frame.length = DATA_SIZE_FC;
  4050d0:	52800060 	mov	w0, #0x3                   	// #3
  4050d4:	3900e3e0 	strb	w0, [sp, #56]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4050d8:	52802040 	mov	w0, #0x102                 	// #258
  4050dc:	b80223e1 	stur	w1, [sp, #34]
  4050e0:	72a31b40 	movk	w0, #0x18da, lsl #16
  4050e4:	97fffb84 	bl	403ef4 <add_rx_msgq.constprop.0>
  4050e8:	2a0003e6 	mov	w6, w0
  4050ec:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4050f0:	aa1403e4 	mov	x4, x20
  4050f4:	52804ea3 	mov	w3, #0x275                 	// #629
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4050f8:	f947b000 	ldr	x0, [x0, #3936]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4050fc:	aa1303e2 	mov	x2, x19
  405100:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  405104:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  405108:	912c60a5 	add	x5, x5, #0xb18
  40510c:	912cd021 	add	x1, x1, #0xb34
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405110:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405114:	2a2603e0 	mvn	w0, w6
  405118:	531f7c00 	lsr	w0, w0, #31
  40511c:	97fffb06 	bl	403d34 <z_zassert.constprop.0>
    send_frame_series(&ff_frame, 1, rx_addr);
  405120:	52804022 	mov	w2, #0x201                 	// #513
  405124:	910083e0 	add	x0, sp, #0x20
  405128:	72a31b42 	movk	w2, #0x18da, lsl #16
  40512c:	d2800021 	mov	x1, #0x1                   	// #1
  405130:	97fffbad 	bl	403fe4 <send_frame_series>
    check_frame_series(&fc_frame, 1, &frame_msgq);
  405134:	9100c3e0 	add	x0, sp, #0x30
  405138:	d2800021 	mov	x1, #0x1                   	// #1
  40513c:	97fffddd 	bl	4048b0 <check_frame_series.constprop.0>
    ret = blocking_recv(tiny_buf, sizeof(tiny_buf), K_MSEC(200));
  405140:	d2800282 	mov	x2, #0x14                  	// #20
  405144:	d2800101 	mov	x1, #0x8                   	// #8
  405148:	910103e0 	add	x0, sp, #0x40
  40514c:	97fffab2 	bl	403c14 <blocking_recv>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  405150:	7100181f 	cmp	w0, #0x6
  405154:	aa1403e4 	mov	x4, x20
  405158:	aa1303e2 	mov	x2, x19
  40515c:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  405160:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  405164:	912dc8a5 	add	x5, x5, #0xb72
  405168:	912e5421 	add	x1, x1, #0xb95
  40516c:	52805043 	mov	w3, #0x282                 	// #642
    ret = blocking_recv(tiny_buf, sizeof(tiny_buf), K_MSEC(200));
  405170:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  405174:	1a9f17e0 	cset	w0, eq  // eq = none
  405178:	97fffaef 	bl	403d34 <z_zassert.constprop.0>
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), random_data + DATA_SIZE_FF,
  40517c:	d2807f40 	mov	x0, #0x3fa                 	// #1018
  405180:	97fffad1 	bl	403cc4 <prepare_cf_frames.constprop.0>
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  405184:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405188:	52800461 	mov	w1, #0x23                  	// #35
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  40518c:	52804022 	mov	w2, #0x201                 	// #513
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  405190:	f947bc00 	ldr	x0, [x0, #3960]
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  405194:	72a31b42 	movk	w2, #0x18da, lsl #16
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  405198:	39002401 	strb	w1, [x0, #9]
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  40519c:	d28004c1 	mov	x1, #0x26                  	// #38
  4051a0:	97fffb91 	bl	403fe4 <send_frame_series>
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  4051a4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4051a8:	d2800282 	mov	x2, #0x14                  	// #20
  4051ac:	d2801001 	mov	x1, #0x80                  	// #128
  4051b0:	f9471400 	ldr	x0, [x0, #3624]
  4051b4:	97fffa98 	bl	403c14 <blocking_recv>
    zassert_equal(ret, ISOTP_N_WRONG_SN, "Expected wrong SN but got %d", ret);
  4051b8:	3100101f 	cmn	w0, #0x4
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  4051bc:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_WRONG_SN, "Expected wrong SN but got %d", ret);
  4051c0:	aa1303e2 	mov	x2, x19
  4051c4:	1a9f17e0 	cset	w0, eq  // eq = none
  4051c8:	aa1403e4 	mov	x4, x20
  4051cc:	f0000065 	adrp	x5, 414000 <dlc_table.0+0x60d>
  4051d0:	52805163 	mov	w3, #0x28b                 	// #651
  4051d4:	910130a5 	add	x5, x5, #0x4c
  4051d8:	f0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4051dc:	9101a421 	add	x1, x1, #0x69
  4051e0:	97fffad5 	bl	403d34 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  4051e4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4051e8:	f9476800 	ldr	x0, [x0, #3792]
  4051ec:	f94027e2 	ldr	x2, [sp, #72]
  4051f0:	f9400001 	ldr	x1, [x0]
  4051f4:	eb010042 	subs	x2, x2, x1
  4051f8:	d2800001 	mov	x1, #0x0                   	// #0
  4051fc:	54000040 	b.eq	405204 <_isotp_fast_conformance_sync_test_receiver_fc_errors_wrapper+0x194>  // b.none
  405200:	97fff048 	bl	401320 <__stack_chk_fail@plt>
  405204:	a94153f3 	ldp	x19, x20, [sp, #16]
  405208:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40520c:	d65f03c0 	ret

0000000000405210 <_isotp_fast_conformance_sync_test_send_data_blocks_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  405210:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  405214:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405218:	910003fd 	mov	x29, sp
  40521c:	f9476800 	ldr	x0, [x0, #3792]
  405220:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405224:	f0000074 	adrp	x20, 414000 <dlc_table.0+0x60d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  405228:	a9025bf5 	stp	x21, x22, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40522c:	91122e94 	add	x20, x20, #0x48b
  405230:	d0000073 	adrp	x19, 413000 <sys_clock_announce+0x19c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  405234:	a90363f7 	stp	x23, x24, [sp, #48]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405238:	91280e73 	add	x19, x19, #0xa03
    check_frame_series(data_frame_ptr, fc_opts.bs, &frame_msgq);
  40523c:	d0000138 	adrp	x24, 42b000 <__FRAME_END__+0xfd74>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  405240:	f90023f9 	str	x25, [sp, #64]
    send_frame_series(&fc_frame, 1, rx_addr);
  405244:	910163f9 	add	x25, sp, #0x58
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405248:	9101e3f7 	add	x23, sp, #0x78
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  40524c:	d0000076 	adrp	x22, 413000 <sys_clock_announce+0x19c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  405250:	f9400001 	ldr	x1, [x0]
  405254:	f90047e1 	str	x1, [sp, #136]
  405258:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  40525c:	52820220 	mov	w0, #0x1011                	// #4113
  405260:	7900d3e0 	strh	w0, [sp, #104]
  405264:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405268:	91134000 	add	x0, x0, #0x4d0
    fc_frame.data[2] = FC_PCI_BYTE_3(0);
  40526c:	39016bff 	strb	wzr, [sp, #90]
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405270:	912ed6d6 	add	x22, x22, #0xbb5
  405274:	d0000075 	adrp	x21, 413000 <sys_clock_announce+0x19c>
  405278:	91378ab5 	add	x21, x21, #0xde2
  40527c:	b9400001 	ldr	w1, [x0]
  405280:	79400800 	ldrh	w0, [x0, #4]
  405284:	7900dfe0 	strh	w0, [sp, #110]
    ff_frame.length = DATA_SIZE_FF + 2;
  405288:	52800100 	mov	w0, #0x8                   	// #8
  40528c:	3901c3e0 	strb	w0, [sp, #112]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  405290:	52810600 	mov	w0, #0x830                 	// #2096
  405294:	7900b3e0 	strh	w0, [sp, #88]
    fc_frame.length = DATA_SIZE_FC;
  405298:	52800060 	mov	w0, #0x3                   	// #3
  40529c:	390183e0 	strb	w0, [sp, #96]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  4052a0:	d2802140 	mov	x0, #0x10a                 	// #266
  4052a4:	b806a3e1 	stur	w1, [sp, #106]
  4052a8:	97fffa87 	bl	403cc4 <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4052ac:	52802040 	mov	w0, #0x102                 	// #258
  4052b0:	72a31b40 	movk	w0, #0x18da, lsl #16
  4052b4:	97fffb10 	bl	403ef4 <add_rx_msgq.constprop.0>
  4052b8:	2a0003e6 	mov	w6, w0
  4052bc:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4052c0:	aa1403e4 	mov	x4, x20
  4052c4:	aa1303e2 	mov	x2, x19
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4052c8:	f947b000 	ldr	x0, [x0, #3936]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4052cc:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4052d0:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4052d4:	912c60a5 	add	x5, x5, #0xb18
  4052d8:	912cd021 	add	x1, x1, #0xb34
  4052dc:	52802ca3 	mov	w3, #0x165                 	// #357
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4052e0:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4052e4:	2a2603e0 	mvn	w0, w6
  4052e8:	531f7c00 	lsr	w0, w0, #31
  4052ec:	97fffa92 	bl	403d34 <z_zassert.constprop.0>
    send_test_data(random_data, DATA_SEND_LENGTH);
  4052f0:	d2802200 	mov	x0, #0x110                 	// #272
  4052f4:	97fffae8 	bl	403e94 <send_test_data.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  4052f8:	9101a3e0 	add	x0, sp, #0x68
  4052fc:	d2800021 	mov	x1, #0x1                   	// #1
  405300:	97fffd6c 	bl	4048b0 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  405304:	52804022 	mov	w2, #0x201                 	// #513
  405308:	aa1903e0 	mov	x0, x25
  40530c:	72a31b42 	movk	w2, #0x18da, lsl #16
  405310:	d2800021 	mov	x1, #0x1                   	// #1
  405314:	97fffb34 	bl	403fe4 <send_frame_series>
    check_frame_series(data_frame_ptr, fc_opts.bs, &frame_msgq);
  405318:	f947bf18 	ldr	x24, [x24, #3960]
  40531c:	d2800101 	mov	x1, #0x8                   	// #8
  405320:	aa1803e0 	mov	x0, x24
  405324:	97fffd63 	bl	4048b0 <check_frame_series.constprop.0>
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405328:	d28000a1 	mov	x1, #0x5                   	// #5
  40532c:	aa1703e0 	mov	x0, x23
  405330:	97fffc06 	bl	404348 <k_msgq_get.constprop.0>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405334:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405338:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  40533c:	aa1603e5 	mov	x5, x22
  405340:	aa1403e4 	mov	x4, x20
  405344:	1a9f17e0 	cset	w0, eq  // eq = none
  405348:	52802e43 	mov	w3, #0x172                 	// #370
  40534c:	aa1303e2 	mov	x2, x19
  405350:	aa1503e1 	mov	x1, x21
  405354:	97fffa78 	bl	403d34 <z_zassert.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  405358:	52804022 	mov	w2, #0x201                 	// #513
    fc_frame.data[1] = FC_PCI_BYTE_2(2);
  40535c:	52800040 	mov	w0, #0x2                   	// #2
    send_frame_series(&fc_frame, 1, rx_addr);
  405360:	72a31b42 	movk	w2, #0x18da, lsl #16
  405364:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[1] = FC_PCI_BYTE_2(2);
  405368:	390167e0 	strb	w0, [sp, #89]
    send_frame_series(&fc_frame, 1, rx_addr);
  40536c:	aa1903e0 	mov	x0, x25
  405370:	97fffb1d 	bl	403fe4 <send_frame_series>
    check_frame_series(data_frame_ptr, 2, &frame_msgq);
  405374:	91012300 	add	x0, x24, #0x48
  405378:	d2800041 	mov	x1, #0x2                   	// #2
  40537c:	97fffd4d 	bl	4048b0 <check_frame_series.constprop.0>
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405380:	d28000a1 	mov	x1, #0x5                   	// #5
  405384:	aa1703e0 	mov	x0, x23
  405388:	97fffbf0 	bl	404348 <k_msgq_get.constprop.0>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  40538c:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405390:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405394:	aa1603e5 	mov	x5, x22
  405398:	aa1403e4 	mov	x4, x20
  40539c:	1a9f17e0 	cset	w0, eq  // eq = none
  4053a0:	52802f83 	mov	w3, #0x17c                 	// #380
  4053a4:	aa1303e2 	mov	x2, x19
  4053a8:	aa1503e1 	mov	x1, x21
  4053ac:	97fffa62 	bl	403d34 <z_zassert.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  4053b0:	52804022 	mov	w2, #0x201                 	// #513
  4053b4:	aa1903e0 	mov	x0, x25
  4053b8:	72a31b42 	movk	w2, #0x18da, lsl #16
  4053bc:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[1] = FC_PCI_BYTE_2(0);
  4053c0:	390167ff 	strb	wzr, [sp, #89]
    send_frame_series(&fc_frame, 1, rx_addr);
  4053c4:	97fffb08 	bl	403fe4 <send_frame_series>
    check_frame_series(data_frame_ptr, DIV_ROUND_UP(remaining_length, DATA_SIZE_CF), &frame_msgq);
  4053c8:	91016b00 	add	x0, x24, #0x5a
  4053cc:	d2800381 	mov	x1, #0x1c                  	// #28
  4053d0:	97fffd38 	bl	4048b0 <check_frame_series.constprop.0>
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  4053d4:	d28000a1 	mov	x1, #0x5                   	// #5
  4053d8:	aa1703e0 	mov	x0, x23
  4053dc:	97fffbdb 	bl	404348 <k_msgq_get.constprop.0>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  4053e0:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  4053e4:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  4053e8:	aa1303e2 	mov	x2, x19
  4053ec:	aa1503e1 	mov	x1, x21
  4053f0:	1a9f17e0 	cset	w0, eq  // eq = none
  4053f4:	aa1603e5 	mov	x5, x22
  4053f8:	aa1403e4 	mov	x4, x20
  4053fc:	52803083 	mov	w3, #0x184                 	// #388
  405400:	97fffa4d 	bl	403d34 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data_blocks)
  405404:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405408:	f9476800 	ldr	x0, [x0, #3792]
  40540c:	f94047e2 	ldr	x2, [sp, #136]
  405410:	f9400001 	ldr	x1, [x0]
  405414:	eb010042 	subs	x2, x2, x1
  405418:	d2800001 	mov	x1, #0x0                   	// #0
  40541c:	54000040 	b.eq	405424 <_isotp_fast_conformance_sync_test_send_data_blocks_wrapper+0x214>  // b.none
  405420:	97ffefc0 	bl	401320 <__stack_chk_fail@plt>
  405424:	a94153f3 	ldp	x19, x20, [sp, #16]
  405428:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40542c:	a94363f7 	ldp	x23, x24, [sp, #48]
  405430:	f94023f9 	ldr	x25, [sp, #64]
  405434:	a8c97bfd 	ldp	x29, x30, [sp], #144
  405438:	d65f03c0 	ret

000000000040543c <_isotp_fast_conformance_sync_test_send_data_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data)
  40543c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  405440:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405444:	910003fd 	mov	x29, sp
  405448:	f9476800 	ldr	x0, [x0, #3792]
  40544c:	f9400001 	ldr	x1, [x0]
  405450:	f9001fe1 	str	x1, [sp, #56]
  405454:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  405458:	52820220 	mov	w0, #0x1011                	// #4113
  40545c:	790053e0 	strh	w0, [sp, #40]
  405460:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405464:	91134000 	add	x0, x0, #0x4d0
    fc_frame.data[2] = FC_PCI_BYTE_3(0);
  405468:	39006bff 	strb	wzr, [sp, #26]
  40546c:	b9400001 	ldr	w1, [x0]
  405470:	79400800 	ldrh	w0, [x0, #4]
  405474:	79005fe0 	strh	w0, [sp, #46]
    ff_frame.length = CAN_DL;
  405478:	52800100 	mov	w0, #0x8                   	// #8
  40547c:	3900c3e0 	strb	w0, [sp, #48]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  405480:	52800600 	mov	w0, #0x30                  	// #48
  405484:	790033e0 	strh	w0, [sp, #24]
    fc_frame.length = DATA_SIZE_FC;
  405488:	52800060 	mov	w0, #0x3                   	// #3
  40548c:	390083e0 	strb	w0, [sp, #32]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  405490:	d2802140 	mov	x0, #0x10a                 	// #266
  405494:	b802a3e1 	stur	w1, [sp, #42]
  405498:	97fffa0b 	bl	403cc4 <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  40549c:	52802040 	mov	w0, #0x102                 	// #258
  4054a0:	72a31b40 	movk	w0, #0x18da, lsl #16
  4054a4:	97fffa94 	bl	403ef4 <add_rx_msgq.constprop.0>
  4054a8:	2a0003e6 	mov	w6, w0
  4054ac:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4054b0:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4054b4:	f0000064 	adrp	x4, 414000 <dlc_table.0+0x60d>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4054b8:	f947b000 	ldr	x0, [x0, #3936]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4054bc:	912c60a5 	add	x5, x5, #0xb18
  4054c0:	9109b484 	add	x4, x4, #0x26d
  4054c4:	d0000062 	adrp	x2, 413000 <sys_clock_announce+0x19c>
  4054c8:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4054cc:	91280c42 	add	x2, x2, #0xa03
  4054d0:	912cd021 	add	x1, x1, #0xb34
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4054d4:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4054d8:	2a2603e0 	mvn	w0, w6
  4054dc:	528027c3 	mov	w3, #0x13e                 	// #318
  4054e0:	531f7c00 	lsr	w0, w0, #31
  4054e4:	97fffa14 	bl	403d34 <z_zassert.constprop.0>
    send_test_data(random_data, DATA_SEND_LENGTH);
  4054e8:	d2802200 	mov	x0, #0x110                 	// #272
  4054ec:	97fffa6a 	bl	403e94 <send_test_data.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  4054f0:	9100a3e0 	add	x0, sp, #0x28
  4054f4:	d2800021 	mov	x1, #0x1                   	// #1
  4054f8:	97fffcee 	bl	4048b0 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  4054fc:	52804022 	mov	w2, #0x201                 	// #513
  405500:	910063e0 	add	x0, sp, #0x18
  405504:	72a31b42 	movk	w2, #0x18da, lsl #16
  405508:	d2800021 	mov	x1, #0x1                   	// #1
  40550c:	97fffab6 	bl	403fe4 <send_frame_series>
    check_frame_series(des_frames, ARRAY_SIZE(des_frames), &frame_msgq);
  405510:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405514:	d28004c1 	mov	x1, #0x26                  	// #38
  405518:	f947bc00 	ldr	x0, [x0, #3960]
  40551c:	97fffce5 	bl	4048b0 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data)
  405520:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405524:	f9476800 	ldr	x0, [x0, #3792]
  405528:	f9401fe2 	ldr	x2, [sp, #56]
  40552c:	f9400001 	ldr	x1, [x0]
  405530:	eb010042 	subs	x2, x2, x1
  405534:	d2800001 	mov	x1, #0x0                   	// #0
  405538:	54000040 	b.eq	405540 <_isotp_fast_conformance_sync_test_send_data_wrapper+0x104>  // b.none
  40553c:	97ffef79 	bl	401320 <__stack_chk_fail@plt>
  405540:	a8c47bfd 	ldp	x29, x30, [sp], #64
  405544:	d65f03c0 	ret

0000000000405548 <_isotp_fast_conformance_sync_test_send_sf_fixed_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  405548:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40554c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405550:	910003fd 	mov	x29, sp
  405554:	f9476800 	ldr	x0, [x0, #3792]
  405558:	a90153f3 	stp	x19, x20, [sp, #16]
  40555c:	f0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  405560:	91134273 	add	x19, x19, #0x4d0
  405564:	f90013f5 	str	x21, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405568:	d0000074 	adrp	x20, 413000 <sys_clock_announce+0x19c>
  40556c:	f0000075 	adrp	x21, 414000 <dlc_table.0+0x60d>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  405570:	f9400001 	ldr	x1, [x0]
  405574:	f90027e1 	str	x1, [sp, #72]
  405578:	d2800001 	mov	x1, #0x0                   	// #0
    des_frame.data[0] = SF_PCI_BYTE_1;
  40557c:	528000e0 	mov	w0, #0x7                   	// #7
  405580:	3900e3e0 	strb	w0, [sp, #56]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405584:	91280e94 	add	x20, x20, #0xa03
  405588:	b9400260 	ldr	w0, [x19]
  40558c:	910a62b5 	add	x21, x21, #0x298
  405590:	b80393e0 	stur	w0, [sp, #57]
  405594:	b8403260 	ldur	w0, [x19, #3]
  405598:	b9003fe0 	str	w0, [sp, #60]
    des_frame.length = CAN_MAX_DLEN;
  40559c:	52800100 	mov	w0, #0x8                   	// #8
  4055a0:	390103e0 	strb	w0, [sp, #64]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4055a4:	52802040 	mov	w0, #0x102                 	// #258
  4055a8:	72a31b40 	movk	w0, #0x18da, lsl #16
  4055ac:	97fffa52 	bl	403ef4 <add_rx_msgq.constprop.0>
  4055b0:	2a0003e6 	mov	w6, w0
  4055b4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4055b8:	aa1503e4 	mov	x4, x21
  4055bc:	aa1403e2 	mov	x2, x20
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4055c0:	f947b000 	ldr	x0, [x0, #3936]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4055c4:	52802063 	mov	w3, #0x103                 	// #259
  4055c8:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4055cc:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4055d0:	912c60a5 	add	x5, x5, #0xb18
  4055d4:	912cd021 	add	x1, x1, #0xb34
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4055d8:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4055dc:	2a2603e0 	mvn	w0, w6
  4055e0:	531f7c00 	lsr	w0, w0, #31
  4055e4:	97fff9d4 	bl	403d34 <z_zassert.constprop.0>
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  4055e8:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4055ec:	aa1303e1 	mov	x1, x19
  4055f0:	d2800004 	mov	x4, #0x0                   	// #0
  4055f4:	52800023 	mov	w3, #0x1                   	// #1
  4055f8:	f9471000 	ldr	x0, [x0, #3616]
  4055fc:	d28000e2 	mov	x2, #0x7                   	// #7
  405600:	97fff912 	bl	403a48 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  405604:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  405608:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  40560c:	aa1403e2 	mov	x2, x20
  405610:	aa1503e4 	mov	x4, x21
  405614:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  405618:	912b24a5 	add	x5, x5, #0xac9
  40561c:	528020c3 	mov	w3, #0x106                 	// #262
  405620:	1a9f17e0 	cset	w0, eq  // eq = none
  405624:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  405628:	912b6821 	add	x1, x1, #0xada
  40562c:	97fff9c2 	bl	403d34 <z_zassert.constprop.0>
    check_frame_series(&des_frame, 1, &frame_msgq);
  405630:	9100e3e0 	add	x0, sp, #0x38
  405634:	d2800021 	mov	x1, #0x1                   	// #1
  405638:	97fffc9e 	bl	4048b0 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  40563c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405640:	f9476800 	ldr	x0, [x0, #3792]
  405644:	f94027e2 	ldr	x2, [sp, #72]
  405648:	f9400001 	ldr	x1, [x0]
  40564c:	eb010042 	subs	x2, x2, x1
  405650:	d2800001 	mov	x1, #0x0                   	// #0
  405654:	54000040 	b.eq	40565c <_isotp_fast_conformance_sync_test_send_sf_fixed_wrapper+0x114>  // b.none
  405658:	97ffef32 	bl	401320 <__stack_chk_fail@plt>
  40565c:	a94153f3 	ldp	x19, x20, [sp, #16]
  405660:	f94013f5 	ldr	x21, [sp, #32]
  405664:	a8c57bfd 	ldp	x29, x30, [sp], #80
  405668:	d65f03c0 	ret

000000000040566c <_isotp_fast_conformance_sync_test_send_sf_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf)
  40566c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  405670:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405674:	910003fd 	mov	x29, sp
  405678:	f9476800 	ldr	x0, [x0, #3792]
  40567c:	a90153f3 	stp	x19, x20, [sp, #16]
  405680:	f0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  405684:	91134273 	add	x19, x19, #0x4d0
  405688:	f9400001 	ldr	x1, [x0]
  40568c:	f9001fe1 	str	x1, [sp, #56]
  405690:	d2800001 	mov	x1, #0x0                   	// #0
    des_frame.data[0] = SF_PCI_BYTE_1;
  405694:	528000e0 	mov	w0, #0x7                   	// #7
  405698:	3900a3e0 	strb	w0, [sp, #40]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40569c:	d0000074 	adrp	x20, 413000 <sys_clock_announce+0x19c>
  4056a0:	91280e94 	add	x20, x20, #0xa03
  4056a4:	b9400260 	ldr	w0, [x19]
  4056a8:	b80293e0 	stur	w0, [sp, #41]
  4056ac:	b8403260 	ldur	w0, [x19, #3]
  4056b0:	b9002fe0 	str	w0, [sp, #44]
    des_frame.length = CAN_MAX_DLEN;
  4056b4:	52800100 	mov	w0, #0x8                   	// #8
  4056b8:	3900c3e0 	strb	w0, [sp, #48]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4056bc:	52802040 	mov	w0, #0x102                 	// #258
  4056c0:	72a31b40 	movk	w0, #0x18da, lsl #16
  4056c4:	97fffa0c 	bl	403ef4 <add_rx_msgq.constprop.0>
  4056c8:	2a0003e6 	mov	w6, w0
  4056cc:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4056d0:	aa1403e2 	mov	x2, x20
  4056d4:	52801aa3 	mov	w3, #0xd5                  	// #213
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4056d8:	f947b000 	ldr	x0, [x0, #3936]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4056dc:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  4056e0:	f0000064 	adrp	x4, 414000 <dlc_table.0+0x60d>
  4056e4:	912c60a5 	add	x5, x5, #0xb18
  4056e8:	910d1c84 	add	x4, x4, #0x347
  4056ec:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4056f0:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4056f4:	2a2603e0 	mvn	w0, w6
  4056f8:	912cd021 	add	x1, x1, #0xb34
  4056fc:	531f7c00 	lsr	w0, w0, #31
  405700:	97fff98d 	bl	403d34 <z_zassert.constprop.0>
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, NULL);
  405704:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405708:	aa1303e1 	mov	x1, x19
  40570c:	d2800004 	mov	x4, #0x0                   	// #0
  405710:	52800023 	mov	w3, #0x1                   	// #1
  405714:	f9471000 	ldr	x0, [x0, #3616]
  405718:	d28000e2 	mov	x2, #0x7                   	// #7
  40571c:	97fff8cb 	bl	403a48 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  405720:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, NULL);
  405724:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  405728:	aa1403e2 	mov	x2, x20
  40572c:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  405730:	f0000064 	adrp	x4, 414000 <dlc_table.0+0x60d>
  405734:	912b24a5 	add	x5, x5, #0xac9
  405738:	910c0484 	add	x4, x4, #0x301
  40573c:	52800663 	mov	w3, #0x33                  	// #51
  405740:	1a9f17e0 	cset	w0, eq  // eq = none
  405744:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  405748:	912b6821 	add	x1, x1, #0xada
  40574c:	97fff97a 	bl	403d34 <z_zassert.constprop.0>
    check_frame_series(&des_frame, 1, &frame_msgq);
  405750:	9100a3e0 	add	x0, sp, #0x28
  405754:	d2800021 	mov	x1, #0x1                   	// #1
  405758:	97fffc56 	bl	4048b0 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf)
  40575c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405760:	f9476800 	ldr	x0, [x0, #3792]
  405764:	f9401fe2 	ldr	x2, [sp, #56]
  405768:	f9400001 	ldr	x1, [x0]
  40576c:	eb010042 	subs	x2, x2, x1
  405770:	d2800001 	mov	x1, #0x0                   	// #0
  405774:	54000040 	b.eq	40577c <_isotp_fast_conformance_sync_test_send_sf_wrapper+0x110>  // b.none
  405778:	97ffeeea 	bl	401320 <__stack_chk_fail@plt>
  40577c:	a94153f3 	ldp	x19, x20, [sp, #16]
  405780:	a8c47bfd 	ldp	x29, x30, [sp], #64
  405784:	d65f03c0 	ret

0000000000405788 <receive_test_data.constprop.0>:
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  405788:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40578c:	910003fd 	mov	x29, sp
  405790:	a90153f3 	stp	x19, x20, [sp, #16]
   case no work is done at all.  We detect these problems by referring
   non-existing functions.  */
__fortify_function void *
__NTH (memset (void *__dest, int __ch, size_t __len))
{
  return __builtin___memset_chk (__dest, __ch, __len,
  405794:	d0000133 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  405798:	d0000074 	adrp	x20, 413000 <sys_clock_announce+0x19c>
  40579c:	f9471673 	ldr	x19, [x19, #3624]
  4057a0:	91280e94 	add	x20, x20, #0xa03
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4057a4:	a9025bf5 	stp	x21, x22, [sp, #32]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  4057a8:	f0000075 	adrp	x21, 414000 <dlc_table.0+0x60d>
  4057ac:	9111e6b5 	add	x21, x21, #0x479
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4057b0:	a90363f7 	stp	x23, x24, [sp, #48]
    const uint8_t *data_ptr = data;
  4057b4:	f0000077 	adrp	x23, 414000 <dlc_table.0+0x60d>
  4057b8:	911342f7 	add	x23, x23, #0x4d0
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4057bc:	a9046bf9 	stp	x25, x26, [sp, #64]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  4057c0:	f000007a 	adrp	x26, 414000 <dlc_table.0+0x60d>
  4057c4:	9102735a 	add	x26, x26, #0x9c
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4057c8:	f9002bfb 	str	x27, [sp, #80]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  4057cc:	f000007b 	adrp	x27, 414000 <dlc_table.0+0x60d>
  4057d0:	9102377b 	add	x27, x27, #0x8d
    size_t remaining_len = len;
  4057d4:	d2802219 	mov	x25, #0x110                 	// #272
  4057d8:	4f000400 	movi	v0.4s, #0x0
        recv_len = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  4057dc:	d2800c82 	mov	x2, #0x64                  	// #100
  4057e0:	d2801001 	mov	x1, #0x80                  	// #128
  4057e4:	aa1303e0 	mov	x0, x19
  4057e8:	ad000260 	stp	q0, q0, [x19]
  4057ec:	ad010260 	stp	q0, q0, [x19, #32]
  4057f0:	ad020260 	stp	q0, q0, [x19, #64]
  4057f4:	ad030260 	stp	q0, q0, [x19, #96]
  4057f8:	97fff907 	bl	403c14 <blocking_recv>
  4057fc:	93407c18 	sxtw	x24, w0
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  405800:	2a3803e0 	mvn	w0, w24
  405804:	2a1803e6 	mov	w6, w24
  405808:	aa1b03e5 	mov	x5, x27
  40580c:	aa1503e4 	mov	x4, x21
  405810:	aa1403e2 	mov	x2, x20
  405814:	aa1a03e1 	mov	x1, x26
  405818:	52800b83 	mov	w3, #0x5c                  	// #92
  40581c:	531f7c00 	lsr	w0, w0, #31
  405820:	97fff945 	bl	403d34 <z_zassert.constprop.0>
        zassert_true(remaining_len >= recv_len, "More data than expected");
  405824:	eb38c33f 	cmp	x25, w24, sxtw
  405828:	aa1503e4 	mov	x4, x21
  40582c:	f0000065 	adrp	x5, 414000 <dlc_table.0+0x60d>
  405830:	9102d4a5 	add	x5, x5, #0xb5
  405834:	52800bc3 	mov	w3, #0x5e                  	// #94
  405838:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
  40583c:	aa1403e2 	mov	x2, x20
  405840:	f0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  405844:	91033421 	add	x1, x1, #0xcd
  405848:	97fff93b 	bl	403d34 <z_zassert.constprop.0>
        ret = check_data(data_buf, data_ptr, recv_len);
  40584c:	aa1703e1 	mov	x1, x23
  405850:	aa1803e2 	mov	x2, x24
  405854:	aa1303e0 	mov	x0, x19
  405858:	97fffbe9 	bl	4047fc <check_data>
        zassert_equal(ret, 0, "Data differ");
  40585c:	7100001f 	cmp	w0, #0x0
  405860:	aa1503e4 	mov	x4, x21
  405864:	1a9f17e0 	cset	w0, eq  // eq = none
  405868:	aa1403e2 	mov	x2, x20
  40586c:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  405870:	52800c03 	mov	w3, #0x60                  	// #96
  405874:	913b84a5 	add	x5, x5, #0xee1
  405878:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  40587c:	912b6821 	add	x1, x1, #0xada
  405880:	97fff92d 	bl	403d34 <z_zassert.constprop.0>
        data_ptr += recv_len;
  405884:	8b1802f7 	add	x23, x23, x24
    } while (remaining_len);
  405888:	eb180339 	subs	x25, x25, x24
  40588c:	54fffa61 	b.ne	4057d8 <receive_test_data.constprop.0+0x50>  // b.any
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(50));
  405890:	aa1303e0 	mov	x0, x19
  405894:	d28000a2 	mov	x2, #0x5                   	// #5
  405898:	d2801001 	mov	x1, #0x80                  	// #128
  40589c:	97fff8de 	bl	403c14 <blocking_recv>
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4058a0:	aa1503e4 	mov	x4, x21
  4058a4:	aa1403e2 	mov	x2, x20
}
  4058a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4058ac:	3100381f 	cmn	w0, #0xe
}
  4058b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(50));
  4058b4:	2a0003e6 	mov	w6, w0
}
  4058b8:	a94363f7 	ldp	x23, x24, [sp, #48]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4058bc:	1a9f17e0 	cset	w0, eq  // eq = none
}
  4058c0:	a9446bf9 	ldp	x25, x26, [sp, #64]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4058c4:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
}
  4058c8:	f9402bfb 	ldr	x27, [sp, #80]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4058cc:	912ed4a5 	add	x5, x5, #0xbb5
}
  4058d0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4058d4:	52800d43 	mov	w3, #0x6a                  	// #106
  4058d8:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4058dc:	912a8c21 	add	x1, x1, #0xaa3
  4058e0:	17fff915 	b	403d34 <z_zassert.constprop.0>

00000000004058e4 <_isotp_fast_conformance_sync_test_receive_data_blocks_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  4058e4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  4058e8:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4058ec:	910003fd 	mov	x29, sp
  4058f0:	f9476800 	ldr	x0, [x0, #3792]
  4058f4:	a90153f3 	stp	x19, x20, [sp, #16]
  4058f8:	d0000133 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  4058fc:	a9025bf5 	stp	x21, x22, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405900:	f0000075 	adrp	x21, 414000 <dlc_table.0+0x60d>
  405904:	d0000076 	adrp	x22, 413000 <sys_clock_announce+0x19c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405908:	a90363f7 	stp	x23, x24, [sp, #48]
        check_frame_series(&fc_frame, 1, &frame_msgq);
  40590c:	910163f7 	add	x23, sp, #0x58
    while (remaining_frames) {
  405910:	d2800014 	mov	x20, #0x0                   	// #0
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405914:	f90023f9 	str	x25, [sp, #64]
            send_frame_series(data_frame_ptr, fc_opts.bs, rx_addr);
  405918:	52804039 	mov	w25, #0x201                 	// #513
  40591c:	72a31b59 	movk	w25, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405920:	f9400001 	ldr	x1, [x0]
  405924:	f90047e1 	str	x1, [sp, #136]
  405928:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  40592c:	52820220 	mov	w0, #0x1011                	// #4113
  405930:	7900d3e0 	strh	w0, [sp, #104]
  return __builtin___memcpy_chk (__dest, __src, __len,
  405934:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405938:	91134000 	add	x0, x0, #0x4d0
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  40593c:	39016bff 	strb	wzr, [sp, #90]
  405940:	b9400001 	ldr	w1, [x0]
  405944:	79400800 	ldrh	w0, [x0, #4]
  405948:	7900dfe0 	strh	w0, [sp, #110]
    ff_frame.length = DATA_SIZE_FF + 2;
  40594c:	52800100 	mov	w0, #0x8                   	// #8
  405950:	3901c3e0 	strb	w0, [sp, #112]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  405954:	52810600 	mov	w0, #0x830                 	// #2096
  405958:	7900b3e0 	strh	w0, [sp, #88]
    fc_frame.length = DATA_SIZE_FC;
  40595c:	52800060 	mov	w0, #0x3                   	// #3
  405960:	390183e0 	strb	w0, [sp, #96]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  405964:	d2802140 	mov	x0, #0x10a                 	// #266
  405968:	b806a3e1 	stur	w1, [sp, #106]
  40596c:	97fff8d6 	bl	403cc4 <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405970:	52802040 	mov	w0, #0x102                 	// #258
  405974:	72a31b40 	movk	w0, #0x18da, lsl #16
  405978:	97fff95f 	bl	403ef4 <add_rx_msgq.constprop.0>
  40597c:	2a0003e6 	mov	w6, w0
  405980:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405984:	911112a4 	add	x4, x21, #0x444
  405988:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  40598c:	f947b000 	ldr	x0, [x0, #3936]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405990:	912c60a5 	add	x5, x5, #0xb18
  405994:	91280ec2 	add	x2, x22, #0xa03
  405998:	52803863 	mov	w3, #0x1c3                 	// #451
  40599c:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  4059a0:	912cd021 	add	x1, x1, #0xb34
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4059a4:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4059a8:	2a2603e0 	mvn	w0, w6
  4059ac:	531f7c00 	lsr	w0, w0, #31
  4059b0:	97fff8e1 	bl	403d34 <z_zassert.constprop.0>
    send_frame_series(&ff_frame, 1, rx_addr);
  4059b4:	52804022 	mov	w2, #0x201                 	// #513
  4059b8:	9101a3e0 	add	x0, sp, #0x68
  4059bc:	72a31b42 	movk	w2, #0x18da, lsl #16
  4059c0:	d2800021 	mov	x1, #0x1                   	// #1
  4059c4:	97fff988 	bl	403fe4 <send_frame_series>
    while (remaining_frames) {
  4059c8:	f947be73 	ldr	x19, [x19, #3960]
  4059cc:	8b130298 	add	x24, x20, x19
        check_frame_series(&fc_frame, 1, &frame_msgq);
  4059d0:	aa1703e0 	mov	x0, x23
  4059d4:	d2800021 	mov	x1, #0x1                   	// #1
        if (remaining_frames >= fc_opts.bs) {
  4059d8:	91012294 	add	x20, x20, #0x48
        check_frame_series(&fc_frame, 1, &frame_msgq);
  4059dc:	97fffbb5 	bl	4048b0 <check_frame_series.constprop.0>
        if (remaining_frames >= fc_opts.bs) {
  4059e0:	f105a29f 	cmp	x20, #0x168
  4059e4:	540003a1 	b.ne	405a58 <_isotp_fast_conformance_sync_test_receive_data_blocks_wrapper+0x174>  // b.any
            send_frame_series(data_frame_ptr, remaining_frames, rx_addr);
  4059e8:	91048260 	add	x0, x19, #0x120
  4059ec:	52804022 	mov	w2, #0x201                 	// #513
  4059f0:	72a31b42 	movk	w2, #0x18da, lsl #16
  4059f4:	d28000c1 	mov	x1, #0x6                   	// #6
  4059f8:	97fff97b 	bl	403fe4 <send_frame_series>
    receive_test_data(&ctx, random_data, DATA_SEND_LENGTH, 0);
  4059fc:	97ffff63 	bl	405788 <receive_test_data.constprop.0>
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405a00:	d28000a1 	mov	x1, #0x5                   	// #5
  405a04:	9101e3e0 	add	x0, sp, #0x78
  405a08:	97fffa50 	bl	404348 <k_msgq_get.constprop.0>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405a0c:	31002c1f 	cmn	w0, #0xb
    ret = k_msgq_get(&frame_msgq, &dummy_frame, K_MSEC(50));
  405a10:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405a14:	91280ec2 	add	x2, x22, #0xa03
  405a18:	1a9f17e0 	cset	w0, eq  // eq = none
  405a1c:	911112a4 	add	x4, x21, #0x444
  405a20:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  405a24:	52803b83 	mov	w3, #0x1dc                 	// #476
  405a28:	912ed4a5 	add	x5, x5, #0xbb5
  405a2c:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  405a30:	91378821 	add	x1, x1, #0xde2
  405a34:	97fff8c0 	bl	403d34 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405a38:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405a3c:	f9476800 	ldr	x0, [x0, #3792]
  405a40:	f94047e2 	ldr	x2, [sp, #136]
  405a44:	f9400001 	ldr	x1, [x0]
  405a48:	eb010042 	subs	x2, x2, x1
  405a4c:	d2800001 	mov	x1, #0x0                   	// #0
  405a50:	540000e0 	b.eq	405a6c <_isotp_fast_conformance_sync_test_receive_data_blocks_wrapper+0x188>  // b.none
  405a54:	97ffee33 	bl	401320 <__stack_chk_fail@plt>
            send_frame_series(data_frame_ptr, fc_opts.bs, rx_addr);
  405a58:	2a1903e2 	mov	w2, w25
  405a5c:	aa1803e0 	mov	x0, x24
  405a60:	d2800101 	mov	x1, #0x8                   	// #8
  405a64:	97fff960 	bl	403fe4 <send_frame_series>
            remaining_frames -= fc_opts.bs;
  405a68:	17ffffd9 	b	4059cc <_isotp_fast_conformance_sync_test_receive_data_blocks_wrapper+0xe8>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405a6c:	a94153f3 	ldp	x19, x20, [sp, #16]
  405a70:	a9425bf5 	ldp	x21, x22, [sp, #32]
  405a74:	a94363f7 	ldp	x23, x24, [sp, #48]
  405a78:	f94023f9 	ldr	x25, [sp, #64]
  405a7c:	a8c97bfd 	ldp	x29, x30, [sp], #144
  405a80:	d65f03c0 	ret

0000000000405a84 <_isotp_fast_conformance_sync_test_receive_data_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data)
  405a84:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  405a88:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405a8c:	910003fd 	mov	x29, sp
  405a90:	f9476800 	ldr	x0, [x0, #3792]
  405a94:	f9400001 	ldr	x1, [x0]
  405a98:	f9001fe1 	str	x1, [sp, #56]
  405a9c:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  405aa0:	52820220 	mov	w0, #0x1011                	// #4113
  405aa4:	790053e0 	strh	w0, [sp, #40]
  405aa8:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405aac:	91134000 	add	x0, x0, #0x4d0
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  405ab0:	39006bff 	strb	wzr, [sp, #26]
  405ab4:	b9400001 	ldr	w1, [x0]
  405ab8:	79400800 	ldrh	w0, [x0, #4]
  405abc:	79005fe0 	strh	w0, [sp, #46]
    ff_frame.length = CAN_DL;
  405ac0:	52800100 	mov	w0, #0x8                   	// #8
  405ac4:	3900c3e0 	strb	w0, [sp, #48]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  405ac8:	52810600 	mov	w0, #0x830                 	// #2096
  405acc:	790033e0 	strh	w0, [sp, #24]
    fc_frame.length = DATA_SIZE_FC;
  405ad0:	52800060 	mov	w0, #0x3                   	// #3
  405ad4:	390083e0 	strb	w0, [sp, #32]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  405ad8:	d2802140 	mov	x0, #0x10a                 	// #266
  405adc:	b802a3e1 	stur	w1, [sp, #42]
  405ae0:	97fff879 	bl	403cc4 <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405ae4:	52802040 	mov	w0, #0x102                 	// #258
  405ae8:	72a31b40 	movk	w0, #0x18da, lsl #16
  405aec:	97fff902 	bl	403ef4 <add_rx_msgq.constprop.0>
  405af0:	d0000121 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
    send_frame_series(&ff_frame, 1, rx_addr);
  405af4:	52804022 	mov	w2, #0x201                 	// #513
  405af8:	72a31b42 	movk	w2, #0x18da, lsl #16
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405afc:	f947b021 	ldr	x1, [x1, #3936]
  405b00:	b9000020 	str	w0, [x1]
    send_frame_series(&ff_frame, 1, rx_addr);
  405b04:	9100a3e0 	add	x0, sp, #0x28
  405b08:	d2800021 	mov	x1, #0x1                   	// #1
  405b0c:	97fff936 	bl	403fe4 <send_frame_series>
    check_frame_series(&fc_frame, 1, &frame_msgq);
  405b10:	910063e0 	add	x0, sp, #0x18
  405b14:	d2800021 	mov	x1, #0x1                   	// #1
  405b18:	97fffb66 	bl	4048b0 <check_frame_series.constprop.0>
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  405b1c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405b20:	52804022 	mov	w2, #0x201                 	// #513
  405b24:	72a31b42 	movk	w2, #0x18da, lsl #16
  405b28:	d28004c1 	mov	x1, #0x26                  	// #38
  405b2c:	f947bc00 	ldr	x0, [x0, #3960]
  405b30:	97fff92d 	bl	403fe4 <send_frame_series>
    receive_test_data(&ctx, random_data, DATA_SEND_LENGTH, 0);
  405b34:	97ffff15 	bl	405788 <receive_test_data.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data)
  405b38:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405b3c:	f9476800 	ldr	x0, [x0, #3792]
  405b40:	f9401fe2 	ldr	x2, [sp, #56]
  405b44:	f9400001 	ldr	x1, [x0]
  405b48:	eb010042 	subs	x2, x2, x1
  405b4c:	d2800001 	mov	x1, #0x0                   	// #0
  405b50:	54000040 	b.eq	405b58 <_isotp_fast_conformance_sync_test_receive_data_wrapper+0xd4>  // b.none
  405b54:	97ffedf3 	bl	401320 <__stack_chk_fail@plt>
  405b58:	a8c47bfd 	ldp	x29, x30, [sp], #64
  405b5c:	d65f03c0 	ret

0000000000405b60 <get_sf.constprop.0>:
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  405b60:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  405b64:	d2800c82 	mov	x2, #0x64                  	// #100
  405b68:	d2801001 	mov	x1, #0x80                  	// #128
  return __builtin___memset_chk (__dest, __ch, __len,
  405b6c:	4f000400 	movi	v0.4s, #0x0
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  405b70:	910003fd 	mov	x29, sp
  405b74:	a90153f3 	stp	x19, x20, [sp, #16]
  405b78:	d0000133 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
    zassert_equal(ret, data_size, "recv returned %d", ret);
  405b7c:	d0000074 	adrp	x20, 413000 <sys_clock_announce+0x19c>
  405b80:	f9471673 	ldr	x19, [x19, #3624]
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  405b84:	f90013f5 	str	x21, [sp, #32]
    zassert_equal(ret, data_size, "recv returned %d", ret);
  405b88:	f0000075 	adrp	x21, 414000 <dlc_table.0+0x60d>
  405b8c:	910b9eb5 	add	x21, x21, #0x2e7
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  405b90:	aa1303e0 	mov	x0, x19
    zassert_equal(ret, data_size, "recv returned %d", ret);
  405b94:	91280e94 	add	x20, x20, #0xa03
  405b98:	ad000260 	stp	q0, q0, [x19]
  405b9c:	ad010260 	stp	q0, q0, [x19, #32]
  405ba0:	ad020260 	stp	q0, q0, [x19, #64]
  405ba4:	ad030260 	stp	q0, q0, [x19, #96]
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  405ba8:	97fff81b 	bl	403c14 <blocking_recv>
    zassert_equal(ret, data_size, "recv returned %d", ret);
  405bac:	71001c1f 	cmp	w0, #0x7
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  405bb0:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, data_size, "recv returned %d", ret);
  405bb4:	aa1503e4 	mov	x4, x21
  405bb8:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
  405bbc:	912a48a5 	add	x5, x5, #0xa92
  405bc0:	52800783 	mov	w3, #0x3c                  	// #60
  405bc4:	aa1403e2 	mov	x2, x20
  405bc8:	1a9f17e0 	cset	w0, eq  // eq = none
  405bcc:	f0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  405bd0:	9103c821 	add	x1, x1, #0xf2
  405bd4:	97fff858 	bl	403d34 <z_zassert.constprop.0>
    ret = check_data(data_buf, random_data, data_size);
  405bd8:	aa1303e0 	mov	x0, x19
  405bdc:	d28000e2 	mov	x2, #0x7                   	// #7
  405be0:	f0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  405be4:	91134021 	add	x1, x1, #0x4d0
  405be8:	97fffb05 	bl	4047fc <check_data>
    zassert_equal(ret, 0, "Data differ");
  405bec:	7100001f 	cmp	w0, #0x0
  405bf0:	aa1503e4 	mov	x4, x21
  405bf4:	aa1403e2 	mov	x2, x20
}
  405bf8:	a94153f3 	ldp	x19, x20, [sp, #16]
    zassert_equal(ret, 0, "Data differ");
  405bfc:	1a9f17e0 	cset	w0, eq  // eq = none
}
  405c00:	f94013f5 	ldr	x21, [sp, #32]
    zassert_equal(ret, 0, "Data differ");
  405c04:	d0000065 	adrp	x5, 413000 <sys_clock_announce+0x19c>
}
  405c08:	a8c37bfd 	ldp	x29, x30, [sp], #48
    zassert_equal(ret, 0, "Data differ");
  405c0c:	913b84a5 	add	x5, x5, #0xee1
  405c10:	528007e3 	mov	w3, #0x3f                  	// #63
  405c14:	d0000061 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  405c18:	912b6821 	add	x1, x1, #0xada
  405c1c:	17fff846 	b	403d34 <z_zassert.constprop.0>

0000000000405c20 <_isotp_fast_conformance_sync_test_receive_sf_fixed_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  405c20:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  405c24:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    send_frame_series(&single_frame, 1, rx_addr);
  405c28:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  405c2c:	910003fd 	mov	x29, sp
  405c30:	f9476800 	ldr	x0, [x0, #3792]
  405c34:	f9000bf3 	str	x19, [sp, #16]
  return __builtin___memcpy_chk (__dest, __src, __len,
  405c38:	9100a3f3 	add	x19, sp, #0x28
    send_frame_series(&single_frame, 1, rx_addr);
  405c3c:	72a31b42 	movk	w2, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  405c40:	f9400001 	ldr	x1, [x0]
  405c44:	f9001fe1 	str	x1, [sp, #56]
  405c48:	d2800001 	mov	x1, #0x0                   	// #0
    single_frame.data[0] = SF_PCI_BYTE_1;
  405c4c:	528000e0 	mov	w0, #0x7                   	// #7
  405c50:	3900a3e0 	strb	w0, [sp, #40]
  405c54:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405c58:	91134000 	add	x0, x0, #0x4d0
  405c5c:	b9400001 	ldr	w1, [x0]
  405c60:	b8403000 	ldur	w0, [x0, #3]
  405c64:	b80293e1 	stur	w1, [sp, #41]
    send_frame_series(&single_frame, 1, rx_addr);
  405c68:	d2800021 	mov	x1, #0x1                   	// #1
  405c6c:	b9002fe0 	str	w0, [sp, #44]
    single_frame.length = CAN_MAX_DLEN;
  405c70:	52800100 	mov	w0, #0x8                   	// #8
  405c74:	3900c3e0 	strb	w0, [sp, #48]
    send_frame_series(&single_frame, 1, rx_addr);
  405c78:	aa1303e0 	mov	x0, x19
  405c7c:	97fff8da 	bl	403fe4 <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  405c80:	97ffffb8 	bl	405b60 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | 0xFF);
  405c84:	aa1303e0 	mov	x0, x19
  405c88:	52805fe2 	mov	w2, #0x2ff                 	// #767
  405c8c:	72a31b42 	movk	w2, #0x18da, lsl #16
  405c90:	d2800021 	mov	x1, #0x1                   	// #1
  405c94:	97fff8d4 	bl	403fe4 <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  405c98:	97ffffb2 	bl	405b60 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | (7U << 26));
  405c9c:	aa1303e0 	mov	x0, x19
  405ca0:	52804022 	mov	w2, #0x201                 	// #513
  405ca4:	72a39b42 	movk	w2, #0x1cda, lsl #16
  405ca8:	d2800021 	mov	x1, #0x1                   	// #1
  405cac:	97fff8ce 	bl	403fe4 <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  405cb0:	97ffffac 	bl	405b60 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | 0xFF00);
  405cb4:	aa1303e0 	mov	x0, x19
  405cb8:	529fe022 	mov	w2, #0xff01                	// #65281
  405cbc:	72a31b42 	movk	w2, #0x18da, lsl #16
  405cc0:	d2800021 	mov	x1, #0x1                   	// #1
  405cc4:	97fff8c8 	bl	403fe4 <send_frame_series>
    get_sf_ignore(&ctx);
  405cc8:	97fff85e 	bl	403e40 <get_sf_ignore.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  405ccc:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405cd0:	f9476800 	ldr	x0, [x0, #3792]
  405cd4:	f9401fe2 	ldr	x2, [sp, #56]
  405cd8:	f9400001 	ldr	x1, [x0]
  405cdc:	eb010042 	subs	x2, x2, x1
  405ce0:	d2800001 	mov	x1, #0x0                   	// #0
  405ce4:	54000040 	b.eq	405cec <_isotp_fast_conformance_sync_test_receive_sf_fixed_wrapper+0xcc>  // b.none
  405ce8:	97ffed8e 	bl	401320 <__stack_chk_fail@plt>
  405cec:	f9400bf3 	ldr	x19, [sp, #16]
  405cf0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  405cf4:	d65f03c0 	ret

0000000000405cf8 <_isotp_fast_conformance_sync_test_receive_sf_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  405cf8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  405cfc:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
    send_frame_series(&single_frame, 1, rx_addr);
  405d00:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  405d04:	910003fd 	mov	x29, sp
  405d08:	f9476800 	ldr	x0, [x0, #3792]
  405d0c:	a90153f3 	stp	x19, x20, [sp, #16]
  405d10:	9100a3f3 	add	x19, sp, #0x28
  405d14:	f9400001 	ldr	x1, [x0]
  405d18:	f9001fe1 	str	x1, [sp, #56]
  405d1c:	d2800001 	mov	x1, #0x0                   	// #0
    single_frame.data[0] = SF_PCI_BYTE_1;
  405d20:	528000e0 	mov	w0, #0x7                   	// #7
  405d24:	3900a3e0 	strb	w0, [sp, #40]
  405d28:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405d2c:	91134000 	add	x0, x0, #0x4d0
    send_frame_series(&single_frame, 1, rx_addr);
  405d30:	72a31b42 	movk	w2, #0x18da, lsl #16
    single_frame.length = CAN_MAX_DLEN;
  405d34:	52800114 	mov	w20, #0x8                   	// #8
  405d38:	3900c3f4 	strb	w20, [sp, #48]
  405d3c:	b9400001 	ldr	w1, [x0]
  405d40:	b8403000 	ldur	w0, [x0, #3]
  405d44:	b80293e1 	stur	w1, [sp, #41]
    send_frame_series(&single_frame, 1, rx_addr);
  405d48:	d2800021 	mov	x1, #0x1                   	// #1
  405d4c:	b9002fe0 	str	w0, [sp, #44]
  405d50:	aa1303e0 	mov	x0, x19
  405d54:	97fff8a4 	bl	403fe4 <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  405d58:	97ffff82 	bl	405b60 <get_sf.constprop.0>
    single_frame.data[0] = SF_PCI_BYTE_LEN_8;
  405d5c:	3900a3f4 	strb	w20, [sp, #40]
    send_frame_series(&single_frame, 1, rx_addr);
  405d60:	aa1303e0 	mov	x0, x19
  405d64:	52804022 	mov	w2, #0x201                 	// #513
  405d68:	72a31b42 	movk	w2, #0x18da, lsl #16
  405d6c:	d2800021 	mov	x1, #0x1                   	// #1
  405d70:	97fff89d 	bl	403fe4 <send_frame_series>
    get_sf_ignore(&ctx);
  405d74:	97fff833 	bl	403e40 <get_sf_ignore.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  405d78:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405d7c:	f9476800 	ldr	x0, [x0, #3792]
  405d80:	f9401fe2 	ldr	x2, [sp, #56]
  405d84:	f9400001 	ldr	x1, [x0]
  405d88:	eb010042 	subs	x2, x2, x1
  405d8c:	d2800001 	mov	x1, #0x0                   	// #0
  405d90:	54000040 	b.eq	405d98 <_isotp_fast_conformance_sync_test_receive_sf_wrapper+0xa0>  // b.none
  405d94:	97ffed63 	bl	401320 <__stack_chk_fail@plt>
  405d98:	a94153f3 	ldp	x19, x20, [sp, #16]
  405d9c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  405da0:	d65f03c0 	ret

0000000000405da4 <cbvprintf_package>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
  405da4:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  405da8:	910003fd 	mov	x29, sp
  405dac:	a90153f3 	stp	x19, x20, [sp, #16]
  405db0:	aa0003f4 	mov	x20, x0
  405db4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  405db8:	a9025bf5 	stp	x21, x22, [sp, #32]
  405dbc:	aa0103f5 	mov	x21, x1
  405dc0:	f9476800 	ldr	x0, [x0, #3792]
  405dc4:	a90363f7 	stp	x23, x24, [sp, #48]
  405dc8:	a9046bf9 	stp	x25, x26, [sp, #64]
  405dcc:	a90573fb 	stp	x27, x28, [sp, #80]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
	bool is_str_arg = false;
	union cbprintf_package_hdr *pkg_hdr = packaged;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
  405dd0:	f2400a9c 	ands	x28, x20, #0x7
{
  405dd4:	f9400001 	ldr	x1, [x0]
  405dd8:	f90067e1 	str	x1, [sp, #200]
  405ddc:	d2800001 	mov	x1, #0x0                   	// #0
  405de0:	121e0040 	and	w0, w2, #0x4
  405de4:	b90083e0 	str	w0, [sp, #128]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
  405de8:	d3431441 	ubfx	x1, x2, #3, #3
  405dec:	29436488 	ldp	w8, w25, [x4, #24]
  405df0:	a940289b 	ldp	x27, x10, [x4]
  405df4:	f940088c 	ldr	x12, [x4, #16]
	if ((uintptr_t)packaged % sizeof(void *)) {
  405df8:	54003781 	b.ne	4064e8 <cbvprintf_package+0x744>  // b.any
  405dfc:	aa0303fa 	mov	x26, x3
  405e00:	11000421 	add	w1, w1, #0x1
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * multiple of pointer size for the above to preserve alignment.
	 *
	 * Refer to union cbprintf_package_hdr for more details.
	 */
	buf += sizeof(*pkg_hdr);
  405e04:	91002293 	add	x19, x20, #0x8
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
  405e08:	b5003754 	cbnz	x20, 4064f0 <cbvprintf_package+0x74c>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  405e0c:	92400ab5 	and	x21, x21, #0x7
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  405e10:	d2800100 	mov	x0, #0x8                   	// #8
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  405e14:	910022b3 	add	x19, x21, #0x8
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  405e18:	cb150015 	sub	x21, x0, x21
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
	align = VA_STACK_ALIGN(char *);
  405e1c:	52800118 	mov	w24, #0x8                   	// #8
					align = VA_STACK_ALIGN(int);
					size = sizeof(int);
				}
				continue;
			}
			switch (*fmt) {
  405e20:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  405e24:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  405e28:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  405e2c:	d000006b 	adrp	x11, 413000 <sys_clock_announce+0x19c>
	s = fmt--;
  405e30:	d1000749 	sub	x9, x26, #0x1
	size = sizeof(char *);
  405e34:	2a1803f6 	mov	w22, w24
			switch (*fmt) {
  405e38:	911f116b 	add	x11, x11, #0x7c4
  405e3c:	d0000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
	bool parsing = false;
  405e40:	52800017 	mov	w23, #0x0                   	// #0
			switch (*fmt) {
  405e44:	911ec000 	add	x0, x0, #0x7b0
	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
  405e48:	12800006 	mov	w6, #0xffffffff            	// #-1
	unsigned int s_ro_cnt = 0; /* number of ro strings */
  405e4c:	52800005 	mov	w5, #0x0                   	// #0
	unsigned int s_rw_cnt = 0; /* number of rw strings */
  405e50:	52800004 	mov	w4, #0x0                   	// #0
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
  405e54:	52800003 	mov	w3, #0x0                   	// #0
  405e58:	d280002d 	mov	x13, #0x1                   	// #1
			switch (*fmt) {
  405e5c:	f2c0004e 	movk	x14, #0x2, lsl #32
  405e60:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  405e64:	f2e06012 	movk	x18, #0x300, lsl #48
  405e68:	f90033e0 	str	x0, [sp, #96]

		/* copy va_list data over to our buffer */
		if (is_str_arg) {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
  405e6c:	b4000054 	cbz	x20, 405e74 <cbvprintf_package+0xd0>
				*(const char **)buf = s;
  405e70:	f900027a 	str	x26, [x19]
			}

			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);

			if (is_ro && !do_ro) {
  405e74:	721f0050 	ands	w16, w2, #0x2
  405e78:	7a400824 	ccmp	w1, #0x0, #0x4, eq  // eq = none
  405e7c:	54001aec 	b.gt	4061d8 <cbvprintf_package+0x434>
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
  405e80:	cb140260 	sub	x0, x19, x20
  405e84:	d342fc00 	lsr	x0, x0, #2
				 * In the do_ro case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
  405e88:	7101fc1f 	cmp	w0, #0x7f
  405e8c:	7a408a04 	ccmp	w16, #0x0, #0x4, hi  // hi = pmore
  405e90:	54001640 	b.eq	406158 <cbvprintf_package+0x3b4>  // b.none
					__ASSERT(false, "String with too many arguments");
  405e94:	f0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  405e98:	91234273 	add	x19, x19, #0x8d0
  405e9c:	aa1303e2 	mov	x2, x19
  405ea0:	b0000081 	adrp	x1, 416000 <__func__.0+0x9cb>
  405ea4:	9128c821 	add	x1, x1, #0xa32
  405ea8:	52804f63 	mov	w3, #0x27b                 	// #635
  405eac:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405eb0:	9123f800 	add	x0, x0, #0x8fe
  405eb4:	94000796 	bl	407d0c <assert_print>
  405eb8:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405ebc:	91246c00 	add	x0, x0, #0x91b
  405ec0:	94000793 	bl	407d0c <assert_print>
  405ec4:	aa1303e0 	mov	x0, x19
  405ec8:	52804f61 	mov	w1, #0x27b                 	// #635
  405ecc:	940007ba 	bl	407db4 <assert_post_action>
  405ed0:	52804f62 	mov	w2, #0x27b                 	// #635
					return -EINVAL;
				}

				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
					__ASSERT(false, "str_ptr_pos[] too small");
  405ed4:	f0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  405ed8:	aa1303e1 	mov	x1, x19
  405edc:	9124f000 	add	x0, x0, #0x93c
  405ee0:	940011a7 	bl	40a57c <posix_print_error_and_exit>
			switch (*fmt) {
  405ee4:	7101e91f 	cmp	w8, #0x7a
  405ee8:	540000e8 	b.hi	405f04 <cbvprintf_package+0x160>  // b.pmore
  405eec:	71019d1f 	cmp	w8, #0x67
  405ef0:	54000208 	b.hi	405f30 <cbvprintf_package+0x18c>  // b.pmore
  405ef4:	7100a91f 	cmp	w8, #0x2a
  405ef8:	54000408 	b.hi	405f78 <cbvprintf_package+0x1d4>  // b.pmore
  405efc:	71007d1f 	cmp	w8, #0x1f
  405f00:	540002e8 	b.hi	405f5c <cbvprintf_package+0x1b8>  // b.pmore
				parsing = false;
  405f04:	52800017 	mov	w23, #0x0                   	// #0
			if (*++fmt == '\0') {
  405f08:	38401d28 	ldrb	w8, [x9, #1]!
  405f0c:	340022a8 	cbz	w8, 406360 <cbvprintf_package+0x5bc>
			if (!parsing) {
  405f10:	35fffeb7 	cbnz	w23, 405ee4 <cbvprintf_package+0x140>
				if (*fmt == '%') {
  405f14:	7100951f 	cmp	w8, #0x25
  405f18:	54ffff81 	b.ne	405f08 <cbvprintf_package+0x164>  // b.any
					arg_idx++;
  405f1c:	110004c6 	add	w6, w6, #0x1
					parsing = true;
  405f20:	52800037 	mov	w23, #0x1                   	// #1
					align = VA_STACK_ALIGN(int);
  405f24:	52800118 	mov	w24, #0x8                   	// #8
					size = sizeof(int);
  405f28:	52800096 	mov	w22, #0x4                   	// #4
  405f2c:	17fffff7 	b	405f08 <cbvprintf_package+0x164>
			switch (*fmt) {
  405f30:	5101a108 	sub	w8, w8, #0x68
  405f34:	7100491f 	cmp	w8, #0x12
  405f38:	54fffe68 	b.hi	405f04 <cbvprintf_package+0x160>  // b.pmore
  405f3c:	f94033e7 	ldr	x7, [sp, #96]
  405f40:	386848e8 	ldrb	w8, [x7, w8, uxtw]
  405f44:	10000070 	adr	x16, 405f50 <cbvprintf_package+0x1ac>
  405f48:	8b288a08 	add	x8, x16, w8, sxtb #2
  405f4c:	d61f0100 	br	x8
  405f50:	52800118 	mov	w24, #0x8                   	// #8
  405f54:	2a1803f6 	mov	w22, w24
  405f58:	17ffffec 	b	405f08 <cbvprintf_package+0x164>
  405f5c:	51008108 	sub	w8, w8, #0x20
  405f60:	7100291f 	cmp	w8, #0xa
  405f64:	54fffd08 	b.hi	405f04 <cbvprintf_package+0x160>  // b.pmore
  405f68:	38684968 	ldrb	w8, [x11, w8, uxtw]
  405f6c:	10000070 	adr	x16, 405f78 <cbvprintf_package+0x1d4>
  405f70:	8b288a08 	add	x8, x16, w8, sxtb #2
  405f74:	d61f0100 	br	x8
  405f78:	5100ad08 	sub	w8, w8, #0x2b
  405f7c:	9ac821a8 	lsl	x8, x13, x8
  405f80:	ea0e011f 	tst	x8, x14
  405f84:	54fffc21 	b.ne	405f08 <cbvprintf_package+0x164>  // b.any
  405f88:	ea0f011f 	tst	x8, x15
  405f8c:	540003e1 	b.ne	406008 <cbvprintf_package+0x264>  // b.any
  405f90:	ea12011f 	tst	x8, x18
  405f94:	54fffb80 	b.eq	405f04 <cbvprintf_package+0x160>  // b.none
				if (fmt[-1] == 'l') {
  405f98:	385ff128 	ldurb	w8, [x9, #-1]
				parsing = false;
  405f9c:	52800017 	mov	w23, #0x0                   	// #0
				if (fmt[-1] == 'l') {
  405fa0:	7101b11f 	cmp	w8, #0x6c
  405fa4:	52800008 	mov	w8, #0x0                   	// #0
  405fa8:	54000061 	b.ne	405fb4 <cbvprintf_package+0x210>  // b.any
				align = VA_STACK_ALIGN(void *);
  405fac:	52800118 	mov	w24, #0x8                   	// #8
				size = sizeof(void *);
  405fb0:	2a1803f6 	mov	w22, w24
		buf = (void *) ROUND_UP(buf, align);
  405fb4:	2a1803f0 	mov	w16, w24
  405fb8:	d1000673 	sub	x19, x19, #0x1
  405fbc:	8b384273 	add	x19, x19, w24, uxtw
  405fc0:	cb1003f0 	neg	x16, x16
  405fc4:	8a100273 	and	x19, x19, x16
		if (buf0 != NULL && BUF_OFFSET + size > len) {
  405fc8:	b40000d4 	cbz	x20, 405fe0 <cbvprintf_package+0x23c>
  405fcc:	2a1603f0 	mov	w16, w22
  405fd0:	cb140210 	sub	x16, x16, x20
  405fd4:	8b130210 	add	x16, x16, x19
  405fd8:	eb15021f 	cmp	x16, x21
  405fdc:	54000408 	b.hi	40605c <cbvprintf_package+0x2b8>  // b.pmore
		if (is_str_arg) {
  405fe0:	34001488 	cbz	w8, 406270 <cbvprintf_package+0x4cc>
			s = va_arg(ap, char *);
  405fe4:	37f80a80 	tbnz	w0, #31, 406134 <cbvprintf_package+0x390>
  405fe8:	91003fdb 	add	x27, x30, #0xf
  405fec:	2a0003e8 	mov	w8, w0
  405ff0:	927df37b 	and	x27, x27, #0xfffffffffffffff8
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
  405ff4:	51000421 	sub	w1, w1, #0x1
			s = va_arg(ap, char *);
  405ff8:	f94003da 	ldr	x26, [x30]
  405ffc:	17ffff9c 	b	405e6c <cbvprintf_package+0xc8>
				arg_idx--;
  406000:	510004c6 	sub	w6, w6, #0x1
				continue;
  406004:	17ffffc0 	b	405f04 <cbvprintf_package+0x160>
				if (fmt[-1] == 'L') {
  406008:	385ff138 	ldurb	w24, [x9, #-1]
  40600c:	7101331f 	cmp	w24, #0x4c
  406010:	540004a1 	b.ne	4060a4 <cbvprintf_package+0x300>  // b.any
					v.ld = va_arg(ap, long double);
  406014:	37f80379 	tbnz	w25, #31, 406080 <cbvprintf_package+0x2dc>
  406018:	91003fc8 	add	x8, x30, #0xf
  40601c:	2a1903f7 	mov	w23, w25
  406020:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  406024:	9100411e 	add	x30, x8, #0x10
  406028:	a9404510 	ldp	x16, x17, [x8]
					size = sizeof(long double);
  40602c:	aa1e03e8 	mov	x8, x30
  406030:	52800216 	mov	w22, #0x10                  	// #16
				buf = (void *) ROUND_UP(buf, align);
  406034:	2a1603f9 	mov	w25, w22
  406038:	d1000673 	sub	x19, x19, #0x1
  40603c:	8b364273 	add	x19, x19, w22, uxtw
  406040:	cb1903fb 	neg	x27, x25
  406044:	8a1b0273 	and	x19, x19, x27
				if (buf0 != NULL) {
  406048:	b40005b4 	cbz	x20, 4060fc <cbvprintf_package+0x358>
					if (BUF_OFFSET + size > len) {
  40604c:	cb14033b 	sub	x27, x25, x20
  406050:	8b13037b 	add	x27, x27, x19
  406054:	eb15037f 	cmp	x27, x21
  406058:	54000489 	b.ls	4060e8 <cbvprintf_package+0x344>  // b.plast
			return -ENOSPC;
  40605c:	12800360 	mov	w0, #0xffffffe4            	// #-28
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
  406060:	b0000121 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  406064:	f9476821 	ldr	x1, [x1, #3792]
  406068:	f94067e3 	ldr	x3, [sp, #200]
  40606c:	f9400022 	ldr	x2, [x1]
  406070:	eb020063 	subs	x3, x3, x2
  406074:	d2800002 	mov	x2, #0x0                   	// #0
  406078:	54002420 	b.eq	4064fc <cbvprintf_package+0x758>  // b.none
  40607c:	97ffeca9 	bl	401320 <__stack_chk_fail@plt>
					v.ld = va_arg(ap, long double);
  406080:	11004337 	add	w23, w25, #0x10
  406084:	710002ff 	cmp	w23, #0x0
  406088:	540000ad 	b.le	40609c <cbvprintf_package+0x2f8>
  40608c:	91003fc8 	add	x8, x30, #0xf
  406090:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  406094:	9100411e 	add	x30, x8, #0x10
  406098:	17ffffe4 	b	406028 <cbvprintf_package+0x284>
  40609c:	8b39c188 	add	x8, x12, w25, sxtw
  4060a0:	17ffffe2 	b	406028 <cbvprintf_package+0x284>
					v.d = va_arg(ap, double);
  4060a4:	37f80119 	tbnz	w25, #31, 4060c4 <cbvprintf_package+0x320>
  4060a8:	91003fc8 	add	x8, x30, #0xf
  4060ac:	2a1903f7 	mov	w23, w25
  4060b0:	927df108 	and	x8, x8, #0xfffffffffffffff8
  4060b4:	d2800011 	mov	x17, #0x0                   	// #0
					size = sizeof(double);
  4060b8:	52800116 	mov	w22, #0x8                   	// #8
					v.d = va_arg(ap, double);
  4060bc:	f94003d0 	ldr	x16, [x30]
					size = sizeof(double);
  4060c0:	17ffffdd 	b	406034 <cbvprintf_package+0x290>
					v.d = va_arg(ap, double);
  4060c4:	11004337 	add	w23, w25, #0x10
  4060c8:	710002ff 	cmp	w23, #0x0
  4060cc:	5400008d 	b.le	4060dc <cbvprintf_package+0x338>
  4060d0:	91003fc8 	add	x8, x30, #0xf
  4060d4:	927df108 	and	x8, x8, #0xfffffffffffffff8
  4060d8:	17fffff7 	b	4060b4 <cbvprintf_package+0x310>
  4060dc:	aa1e03e8 	mov	x8, x30
  4060e0:	8b39c19e 	add	x30, x12, w25, sxtw
  4060e4:	17fffff4 	b	4060b4 <cbvprintf_package+0x310>
					} else if (fmt[-1] == 'L') {
  4060e8:	7101331f 	cmp	w24, #0x4c
  4060ec:	54000121 	b.ne	406110 <cbvprintf_package+0x36c>  // b.any
						*(long double *)buf = v.ld;
  4060f0:	9e670200 	fmov	d0, x16
  4060f4:	9eaf0220 	fmov	v0.d[1], x17
  4060f8:	3d800260 	str	q0, [x19]
				buf += size;
  4060fc:	8b190273 	add	x19, x19, x25
				continue;
  406100:	aa0803fe 	mov	x30, x8
  406104:	2a1703f9 	mov	w25, w23
  406108:	2a1603f8 	mov	w24, w22
  40610c:	17ffff7e 	b	405f04 <cbvprintf_package+0x160>
						*(double *)buf = v.d;
  406110:	f9000270 	str	x16, [x19]
  406114:	17fffffa 	b	4060fc <cbvprintf_package+0x358>
			switch (*fmt) {
  406118:	52800008 	mov	w8, #0x0                   	// #0
				parsing = false;
  40611c:	52800017 	mov	w23, #0x0                   	// #0
  406120:	17ffffa3 	b	405fac <cbvprintf_package+0x208>
				is_str_arg = true;
  406124:	2a1703e8 	mov	w8, w23
  406128:	17fffffd 	b	40611c <cbvprintf_package+0x378>
			switch (*fmt) {
  40612c:	52800008 	mov	w8, #0x0                   	// #0
  406130:	17ffffa1 	b	405fb4 <cbvprintf_package+0x210>
			s = va_arg(ap, char *);
  406134:	11002008 	add	w8, w0, #0x8
  406138:	7100011f 	cmp	w8, #0x0
  40613c:	5400008d 	b.le	40614c <cbvprintf_package+0x3a8>
  406140:	91003fdb 	add	x27, x30, #0xf
  406144:	927df37b 	and	x27, x27, #0xfffffffffffffff8
  406148:	17ffffab 	b	405ff4 <cbvprintf_package+0x250>
  40614c:	aa1e03fb 	mov	x27, x30
  406150:	8b20c15e 	add	x30, x10, w0, sxtw
  406154:	17ffffa8 	b	405ff4 <cbvprintf_package+0x250>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
  406158:	71003c7f 	cmp	w3, #0xf
  40615c:	54000249 	b.ls	4061a4 <cbvprintf_package+0x400>  // b.plast
					__ASSERT(false, "str_ptr_pos[] too small");
  406160:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  406164:	91234273 	add	x19, x19, #0x8d0
  406168:	aa1303e2 	mov	x2, x19
  40616c:	90000081 	adrp	x1, 416000 <__func__.0+0x9cb>
  406170:	9128c821 	add	x1, x1, #0xa32
  406174:	52805003 	mov	w3, #0x280                 	// #640
  406178:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40617c:	9123f800 	add	x0, x0, #0x8fe
  406180:	940006e3 	bl	407d0c <assert_print>
  406184:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406188:	91258400 	add	x0, x0, #0x961
  40618c:	940006e0 	bl	407d0c <assert_print>
  406190:	aa1303e0 	mov	x0, x19
  406194:	52805001 	mov	w1, #0x280                 	// #640
  406198:	94000707 	bl	407db4 <assert_post_action>
  40619c:	52805002 	mov	w2, #0x280                 	// #640
  4061a0:	17ffff4d 	b	405ed4 <cbvprintf_package+0x130>
				if (buf0 != NULL) {
  4061a4:	b4000274 	cbz	x20, 4061f0 <cbvprintf_package+0x44c>
					str_ptr_pos[s_idx] = s_ptr_idx;
  4061a8:	2a0303f0 	mov	w16, w3
  4061ac:	9102a3f1 	add	x17, sp, #0xa8
					str_ptr_arg[s_idx] = arg_idx;
  4061b0:	9102e3fe 	add	x30, sp, #0xb8
					str_ptr_pos[s_idx] = s_ptr_idx;
  4061b4:	12001c00 	and	w0, w0, #0xff
  4061b8:	38306a20 	strb	w0, [x17, x16]
					str_ptr_arg[s_idx] = arg_idx;
  4061bc:	38306bc6 	strb	w6, [x30, x16]
					if (is_ro) {
  4061c0:	7100003f 	cmp	w1, #0x0
  4061c4:	5400012d 	b.le	4061e8 <cbvprintf_package+0x444>
						s_ro_cnt++;
  4061c8:	110004a5 	add	w5, w5, #0x1
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
  4061cc:	32196000 	orr	w0, w0, #0xffffff80
  4061d0:	38306a20 	strb	w0, [x17, x16]
				s_idx++;
  4061d4:	11000463 	add	w3, w3, #0x1
			buf += sizeof(char *);
  4061d8:	91002273 	add	x19, x19, #0x8
			is_str_arg = false;
  4061dc:	2a0803e0 	mov	w0, w8
  4061e0:	aa1b03fe 	mov	x30, x27
  4061e4:	17ffff49 	b	405f08 <cbvprintf_package+0x164>
						s_rw_cnt++;
  4061e8:	11000484 	add	w4, w4, #0x1
  4061ec:	17fffffa 	b	4061d4 <cbvprintf_package+0x430>
				} else if (is_ro) {
  4061f0:	7100003f 	cmp	w1, #0x0
  4061f4:	5400006d 	b.le	406200 <cbvprintf_package+0x45c>
					len += 1;
  4061f8:	910006b5 	add	x21, x21, #0x1
  4061fc:	17fffff6 	b	4061d4 <cbvprintf_package+0x430>
				} else if (rws_pos_en) {
  406200:	b94083e0 	ldr	w0, [sp, #128]
					len += 2;
  406204:	91000ab5 	add	x21, x21, #0x2
				} else if (rws_pos_en) {
  406208:	35fffe60 	cbnz	w0, 4061d4 <cbvprintf_package+0x430>
					len += strlen(s) + 1 + 1;
  40620c:	aa1a03e0 	mov	x0, x26
  406210:	a906b3ea 	stp	x10, x12, [sp, #104]
  406214:	f9003fe9 	str	x9, [sp, #120]
  406218:	291093e3 	stp	w3, w4, [sp, #132]
  40621c:	29119be5 	stp	w5, w6, [sp, #140]
  406220:	2912a3e1 	stp	w1, w8, [sp, #148]
  406224:	b9009fe2 	str	w2, [sp, #156]
  406228:	97ffebde 	bl	4011a0 <strlen@plt>
  40622c:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  406230:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  406234:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  406238:	8b0002b5 	add	x21, x21, x0
  40623c:	295093e3 	ldp	w3, w4, [sp, #132]
  406240:	b0000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  406244:	29519be5 	ldp	w5, w6, [sp, #140]
  406248:	911f100b 	add	x11, x0, #0x7c4
  40624c:	2952a3e1 	ldp	w1, w8, [sp, #148]
  406250:	f2e06012 	movk	x18, #0x300, lsl #48
  406254:	b9409fe2 	ldr	w2, [sp, #156]
  406258:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  40625c:	f2c0004e 	movk	x14, #0x2, lsl #32
  406260:	d280002d 	mov	x13, #0x1                   	// #1
  406264:	a946b3ea 	ldp	x10, x12, [sp, #104]
  406268:	f9403fe9 	ldr	x9, [sp, #120]
  40626c:	17ffffda 	b	4061d4 <cbvprintf_package+0x430>
		} else if (size == sizeof(int)) {
  406270:	710012df 	cmp	w22, #0x4
  406274:	540002a1 	b.ne	4062c8 <cbvprintf_package+0x524>  // b.any
			int v = va_arg(ap, int);
  406278:	37f80160 	tbnz	w0, #31, 4062a4 <cbvprintf_package+0x500>
  40627c:	91002fc8 	add	x8, x30, #0xb
  406280:	2a0003f0 	mov	w16, w0
  406284:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  406288:	b4000074 	cbz	x20, 406294 <cbvprintf_package+0x4f0>
			int v = va_arg(ap, int);
  40628c:	b94003c0 	ldr	w0, [x30]
				*(int *)buf = v;
  406290:	b9000260 	str	w0, [x19]
			buf += sizeof(int);
  406294:	91001273 	add	x19, x19, #0x4
  406298:	2a1003e0 	mov	w0, w16
  40629c:	aa0803fe 	mov	x30, x8
  4062a0:	17ffff1a 	b	405f08 <cbvprintf_package+0x164>
			int v = va_arg(ap, int);
  4062a4:	11002010 	add	w16, w0, #0x8
  4062a8:	7100021f 	cmp	w16, #0x0
  4062ac:	5400008d 	b.le	4062bc <cbvprintf_package+0x518>
  4062b0:	91002fc8 	add	x8, x30, #0xb
  4062b4:	927df108 	and	x8, x8, #0xfffffffffffffff8
  4062b8:	17fffff4 	b	406288 <cbvprintf_package+0x4e4>
  4062bc:	aa1e03e8 	mov	x8, x30
  4062c0:	8b20c15e 	add	x30, x10, w0, sxtw
  4062c4:	17fffff1 	b	406288 <cbvprintf_package+0x4e4>
		} else if (size == sizeof(long)) {
  4062c8:	710022df 	cmp	w22, #0x8
  4062cc:	54000261 	b.ne	406318 <cbvprintf_package+0x574>  // b.any
			long v = va_arg(ap, long);
  4062d0:	37f80120 	tbnz	w0, #31, 4062f4 <cbvprintf_package+0x550>
  4062d4:	91003fc8 	add	x8, x30, #0xf
  4062d8:	2a0003f0 	mov	w16, w0
  4062dc:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  4062e0:	b4000074 	cbz	x20, 4062ec <cbvprintf_package+0x548>
			long v = va_arg(ap, long);
  4062e4:	f94003c0 	ldr	x0, [x30]
				*(long *)buf = v;
  4062e8:	f9000260 	str	x0, [x19]
			buf += sizeof(long);
  4062ec:	91002273 	add	x19, x19, #0x8
  4062f0:	17ffffea 	b	406298 <cbvprintf_package+0x4f4>
			long v = va_arg(ap, long);
  4062f4:	11002010 	add	w16, w0, #0x8
  4062f8:	7100021f 	cmp	w16, #0x0
  4062fc:	5400008d 	b.le	40630c <cbvprintf_package+0x568>
  406300:	91003fc8 	add	x8, x30, #0xf
  406304:	927df108 	and	x8, x8, #0xfffffffffffffff8
  406308:	17fffff6 	b	4062e0 <cbvprintf_package+0x53c>
  40630c:	aa1e03e8 	mov	x8, x30
  406310:	8b20c15e 	add	x30, x10, w0, sxtw
  406314:	17fffff3 	b	4062e0 <cbvprintf_package+0x53c>
			__ASSERT(false, "unexpected size %u", size);
  406318:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  40631c:	91234273 	add	x19, x19, #0x8d0
  406320:	aa1303e2 	mov	x2, x19
  406324:	528058a3 	mov	w3, #0x2c5                 	// #709
  406328:	90000081 	adrp	x1, 416000 <__func__.0+0x9cb>
  40632c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406330:	9128c821 	add	x1, x1, #0xa32
  406334:	9123f800 	add	x0, x0, #0x8fe
  406338:	94000675 	bl	407d0c <assert_print>
  40633c:	2a1603e1 	mov	w1, w22
  406340:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406344:	9125ec00 	add	x0, x0, #0x97b
  406348:	94000671 	bl	407d0c <assert_print>
  40634c:	aa1303e0 	mov	x0, x19
  406350:	528058a1 	mov	w1, #0x2c5                 	// #709
  406354:	94000698 	bl	407db4 <assert_post_action>
  406358:	528058a2 	mov	w2, #0x2c5                 	// #709
  40635c:	17fffede 	b	405ed4 <cbvprintf_package+0x130>
	if (BUF_OFFSET / sizeof(int) > 255) {
  406360:	cb140261 	sub	x1, x19, x20
  406364:	f10ffc3f 	cmp	x1, #0x3ff
  406368:	54000249 	b.ls	4063b0 <cbvprintf_package+0x60c>  // b.plast
		__ASSERT(false, "too many format args");
  40636c:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  406370:	91234273 	add	x19, x19, #0x8d0
  406374:	aa1303e2 	mov	x2, x19
  406378:	90000081 	adrp	x1, 416000 <__func__.0+0x9cb>
  40637c:	9128c821 	add	x1, x1, #0xa32
  406380:	52805a23 	mov	w3, #0x2d1                 	// #721
  406384:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406388:	9123f800 	add	x0, x0, #0x8fe
  40638c:	94000660 	bl	407d0c <assert_print>
  406390:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406394:	91264000 	add	x0, x0, #0x990
  406398:	9400065d 	bl	407d0c <assert_print>
  40639c:	aa1303e0 	mov	x0, x19
  4063a0:	52805a21 	mov	w1, #0x2d1                 	// #721
  4063a4:	94000684 	bl	407db4 <assert_post_action>
  4063a8:	52805a22 	mov	w2, #0x2d1                 	// #721
  4063ac:	17fffeca 	b	405ed4 <cbvprintf_package+0x130>
	if (buf0 == NULL) {
  4063b0:	b5000094 	cbnz	x20, 4063c0 <cbvprintf_package+0x61c>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
  4063b4:	510022a0 	sub	w0, w21, #0x8
  4063b8:	0b010000 	add	w0, w0, w1
  4063bc:	17ffff29 	b	406060 <cbvprintf_package+0x2bc>
	if (rws_pos_en) {
  4063c0:	b94083e0 	ldr	w0, [sp, #128]
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  4063c4:	d342fc21 	lsr	x1, x1, #2
	*(char **)buf0 = NULL;
  4063c8:	f900029f 	str	xzr, [x20]
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  4063cc:	12001c84 	and	w4, w4, #0xff
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  4063d0:	39000281 	strb	w1, [x20]
	if (rws_pos_en) {
  4063d4:	34000120 	cbz	w0, 4063f8 <cbvprintf_package+0x654>
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  4063d8:	39000e84 	strb	w4, [x20, #3]
	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
  4063dc:	39000a85 	strb	w5, [x20, #2]
	if (s_ro_cnt) {
  4063e0:	9102a3f8 	add	x24, sp, #0xa8
  4063e4:	35000265 	cbnz	w5, 406430 <cbvprintf_package+0x68c>
		if (BUF_OFFSET + 1 + size > len) {
  4063e8:	d2800036 	mov	x22, #0x1                   	// #1
			*buf++ = str_ptr_arg[i];
  4063ec:	9102e3f7 	add	x23, sp, #0xb8
		if (BUF_OFFSET + 1 + size > len) {
  4063f0:	cb1402d6 	sub	x22, x22, x20
  4063f4:	1400002d 	b	4064a8 <cbvprintf_package+0x704>
		pkg_hdr->desc.str_cnt = s_rw_cnt;
  4063f8:	39000684 	strb	w4, [x20, #1]
		pkg_hdr->desc.rw_str_cnt = 0;
  4063fc:	17fffff8 	b	4063dc <cbvprintf_package+0x638>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
  406400:	38e16b04 	ldrsb	w4, [x24, x1]
  406404:	38786820 	ldrb	w0, [x1, x24]
  406408:	36f800c4 	tbz	w4, #31, 406420 <cbvprintf_package+0x67c>
			if (BUF_OFFSET + 1 > len) {
  40640c:	8b020264 	add	x4, x19, x2
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
  406410:	12001800 	and	w0, w0, #0x7f
			if (BUF_OFFSET + 1 > len) {
  406414:	eb15009f 	cmp	x4, x21
  406418:	54ffe228 	b.hi	40605c <cbvprintf_package+0x2b8>  // b.pmore
			*buf++ = pos;
  40641c:	38001660 	strb	w0, [x19], #1
		for (i = 0; i < s_idx; i++) {
  406420:	91000421 	add	x1, x1, #0x1
  406424:	6b01007f 	cmp	w3, w1
  406428:	54fffec8 	b.hi	406400 <cbvprintf_package+0x65c>  // b.pmore
  40642c:	17ffffef 	b	4063e8 <cbvprintf_package+0x644>
			if (BUF_OFFSET + 1 > len) {
  406430:	d2800022 	mov	x2, #0x1                   	// #1
  406434:	d2800001 	mov	x1, #0x0                   	// #0
  406438:	cb140042 	sub	x2, x2, x20
  40643c:	17fffffa 	b	406424 <cbvprintf_package+0x680>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
  406440:	34000065 	cbz	w5, 40644c <cbvprintf_package+0x6a8>
  406444:	39c00300 	ldrsb	w0, [x24]
  406448:	37f802c0 	tbnz	w0, #31, 4064a0 <cbvprintf_package+0x6fc>
		if (rws_pos_en) {
  40644c:	b94083e0 	ldr	w0, [sp, #128]
  406450:	34000340 	cbz	w0, 4064b8 <cbvprintf_package+0x714>
			*buf++ = str_ptr_arg[i];
  406454:	38776b80 	ldrb	w0, [x28, x23]
  406458:	38001660 	strb	w0, [x19], #1
			size = 0;
  40645c:	52800000 	mov	w0, #0x0                   	// #0
		if (BUF_OFFSET + 1 + size > len) {
  406460:	2a0003f9 	mov	w25, w0
  406464:	8b204260 	add	x0, x19, w0, uxtw
  406468:	8b160000 	add	x0, x0, x22
  40646c:	b90063e3 	str	w3, [sp, #96]
  406470:	b9006be5 	str	w5, [sp, #104]
  406474:	eb15001f 	cmp	x0, x21
  406478:	54ffdf28 	b.hi	40605c <cbvprintf_package+0x2b8>  // b.pmore
		*buf++ = str_ptr_pos[i];
  40647c:	39400300 	ldrb	w0, [x24]
  406480:	aa1903e2 	mov	x2, x25
  406484:	38001660 	strb	w0, [x19], #1
  406488:	aa1a03e1 	mov	x1, x26
  40648c:	aa1303e0 	mov	x0, x19
  406490:	97ffeb38 	bl	401170 <memcpy@plt>
		buf += size;
  406494:	b94063e3 	ldr	w3, [sp, #96]
  406498:	8b190273 	add	x19, x19, x25
  40649c:	b9406be5 	ldr	w5, [sp, #104]
	for (i = 0; i < s_idx; i++) {
  4064a0:	9100079c 	add	x28, x28, #0x1
  4064a4:	91000718 	add	x24, x24, #0x1
  4064a8:	6b1c007f 	cmp	w3, w28
  4064ac:	54fffca8 	b.hi	406440 <cbvprintf_package+0x69c>  // b.pmore
	return BUF_OFFSET;
  4064b0:	4b140260 	sub	w0, w19, w20
  4064b4:	17fffeeb 	b	406060 <cbvprintf_package+0x2bc>
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
  4064b8:	39400300 	ldrb	w0, [x24]
  4064bc:	b90063e3 	str	w3, [sp, #96]
  4064c0:	b9006be5 	str	w5, [sp, #104]
  4064c4:	d37ef400 	lsl	x0, x0, #2
  4064c8:	f8606a9a 	ldr	x26, [x20, x0]
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
  4064cc:	f8206a9f 	str	xzr, [x20, x0]
			size = strlen(s) + 1;
  4064d0:	aa1a03e0 	mov	x0, x26
  4064d4:	97ffeb33 	bl	4011a0 <strlen@plt>
  4064d8:	b94063e3 	ldr	w3, [sp, #96]
  4064dc:	11000400 	add	w0, w0, #0x1
  4064e0:	b9406be5 	ldr	w5, [sp, #104]
  4064e4:	17ffffdf 	b	406460 <cbvprintf_package+0x6bc>
		return -EFAULT;
  4064e8:	128001a0 	mov	w0, #0xfffffff2            	// #-14
  4064ec:	17fffedd 	b	406060 <cbvprintf_package+0x2bc>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
  4064f0:	f1003ebf 	cmp	x21, #0xf
  4064f4:	54ffc948 	b.hi	405e1c <cbvprintf_package+0x78>  // b.pmore
  4064f8:	17fffed9 	b	40605c <cbvprintf_package+0x2b8>
}
  4064fc:	a94153f3 	ldp	x19, x20, [sp, #16]
  406500:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406504:	a94363f7 	ldp	x23, x24, [sp, #48]
  406508:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40650c:	a94573fb 	ldp	x27, x28, [sp, #80]
  406510:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  406514:	d65f03c0 	ret

0000000000406518 <cbpprintf_external>:
	uint8_t *buf = packaged;
	struct cbprintf_package_hdr_ext *hdr = packaged;
	char *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, rws_nbr, s_idx;

	if (buf == NULL) {
  406518:	b40005e3 	cbz	x3, 4065d4 <cbpprintf_external+0xbc>
{
  40651c:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  406520:	910003fd 	mov	x29, sp
  406524:	a90153f3 	stp	x19, x20, [sp, #16]
  406528:	aa0303f4 	mov	x20, x3
  40652c:	a9025bf5 	stp	x21, x22, [sp, #32]
  406530:	aa0003f6 	mov	x22, x0
  406534:	aa0103f5 	mov	x21, x1
  406538:	a90363f7 	stp	x23, x24, [sp, #48]
  40653c:	aa0203f7 	mov	x23, x2
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
  406540:	52800018 	mov	w24, #0x0                   	// #0
{
  406544:	f90023f9 	str	x25, [sp, #64]
	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
  406548:	39400c60 	ldrb	w0, [x3, #3]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  40654c:	39400073 	ldrb	w19, [x3]
	s_nbr     = hdr->hdr.desc.str_cnt;
  406550:	39400479 	ldrb	w25, [x3, #1]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  406554:	d37f1c00 	ubfiz	x0, x0, #1, #8
  406558:	8b334813 	add	x19, x0, w19, uxtw #2
  40655c:	39400860 	ldrb	w0, [x3, #2]
  406560:	8b000273 	add	x19, x19, x0
  406564:	8b130073 	add	x19, x3, x19
	for (i = 0; i < s_nbr; i++) {
  406568:	6b19031f 	cmp	w24, w25
  40656c:	54000223 	b.cc	4065b0 <cbpprintf_external+0x98>  // b.lo, b.ul, b.last
		/* move to next string */
		s += strlen(s) + 1;
	}

	/* Skip past the header */
	buf += sizeof(*hdr);
  406570:	91004280 	add	x0, x20, #0x10
	u.__ap.__gr_top = NULL;
  406574:	a9077fe0 	stp	x0, xzr, [sp, #112]
	return formatter(out, ctx, fmt, u.ap);
  406578:	910143e3 	add	x3, sp, #0x50
	u.__ap.__gr_offs = 0;
  40657c:	a9087fff 	stp	xzr, xzr, [sp, #128]
	return formatter(out, ctx, fmt, u.ap);
  406580:	aa1703e1 	mov	x1, x23
  406584:	aa1603e0 	mov	x0, x22
  406588:	ad4387e0 	ldp	q0, q1, [sp, #112]
  40658c:	ad000460 	stp	q0, q1, [x3]
  406590:	f9400682 	ldr	x2, [x20, #8]
  406594:	d63f02a0 	blr	x21

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
}
  406598:	a94153f3 	ldp	x19, x20, [sp, #16]
  40659c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4065a0:	a94363f7 	ldp	x23, x24, [sp, #48]
  4065a4:	f94023f9 	ldr	x25, [sp, #64]
  4065a8:	a8c97bfd 	ldp	x29, x30, [sp], #144
  4065ac:	d65f03c0 	ret
		ps = (char **)(buf + s_idx * sizeof(int));
  4065b0:	38401660 	ldrb	w0, [x19], #1
	for (i = 0; i < s_nbr; i++) {
  4065b4:	11000718 	add	w24, w24, #0x1
		ps = (char **)(buf + s_idx * sizeof(int));
  4065b8:	d37ef400 	lsl	x0, x0, #2
		*ps = s;
  4065bc:	f8206a93 	str	x19, [x20, x0]
		s += strlen(s) + 1;
  4065c0:	aa1303e0 	mov	x0, x19
  4065c4:	97ffeaf7 	bl	4011a0 <strlen@plt>
  4065c8:	91000400 	add	x0, x0, #0x1
  4065cc:	8b000273 	add	x19, x19, x0
	for (i = 0; i < s_nbr; i++) {
  4065d0:	17ffffe6 	b	406568 <cbpprintf_external+0x50>
		return -EINVAL;
  4065d4:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  4065d8:	d65f03c0 	ret

00000000004065dc <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  4065dc:	52800000 	mov	w0, #0x0                   	// #0
  4065e0:	d65f03c0 	ret

00000000004065e4 <__printk_hook_install>:
 * routine that outputs one ASCII character at a time.
 * @param fn putc routine to install
 */
void __printk_hook_install(int (*fn)(int c))
{
	_char_out = fn;
  4065e4:	b0000121 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  4065e8:	f947b421 	ldr	x1, [x1, #3944]
  4065ec:	f9000020 	str	x0, [x1]
}
  4065f0:	d65f03c0 	ret

00000000004065f4 <vprintk>:
	(void) ctx_p;
	return _char_out(c);
}

void vprintk(const char *fmt, va_list ap)
{
  4065f4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4065f8:	910003fd 	mov	x29, sp
	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		z_log_vprintk(fmt, ap);
  4065fc:	ad400420 	ldp	q0, q1, [x1]
  406600:	910043e2 	add	x2, sp, #0x10
  406604:	aa0203e1 	mov	x1, x2
  406608:	ad000440 	stp	q0, q1, [x2]
  40660c:	94000687 	bl	408028 <z_log_vprintk>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
  406610:	a8c37bfd 	ldp	x29, x30, [sp], #48
  406614:	d65f03c0 	ret

0000000000406618 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
  406618:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  40661c:	910003fd 	mov	x29, sp
  406620:	a90e8be1 	stp	x1, x2, [sp, #232]
  406624:	b0000121 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  406628:	f9476821 	ldr	x1, [x1, #3792]
  40662c:	3d801be0 	str	q0, [sp, #96]
  406630:	3d801fe1 	str	q1, [sp, #112]
  406634:	3d8023e2 	str	q2, [sp, #128]
  406638:	3d8027e3 	str	q3, [sp, #144]
  40663c:	3d802be4 	str	q4, [sp, #160]
  406640:	3d802fe5 	str	q5, [sp, #176]
  406644:	3d8033e6 	str	q6, [sp, #192]
  406648:	3d8037e7 	str	q7, [sp, #208]
  40664c:	a90f93e3 	stp	x3, x4, [sp, #248]
  406650:	a9109be5 	stp	x5, x6, [sp, #264]
  406654:	f9008fe7 	str	x7, [sp, #280]
  406658:	f9400022 	ldr	x2, [x1]
  40665c:	f9002fe2 	str	x2, [sp, #88]
  406660:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  406664:	910483e1 	add	x1, sp, #0x120
  406668:	a90387e1 	stp	x1, x1, [sp, #56]
  40666c:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  406670:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  406674:	f90027e1 	str	x1, [sp, #72]
  406678:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  40667c:	b90053e1 	str	w1, [sp, #80]
  406680:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  406684:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  406688:	910043e1 	add	x1, sp, #0x10
  40668c:	ad400440 	ldp	q0, q1, [x2]
  406690:	ad000420 	stp	q0, q1, [x1]
  406694:	97ffffd8 	bl	4065f4 <vprintk>

	va_end(ap);
}
  406698:	b0000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40669c:	f9476800 	ldr	x0, [x0, #3792]
  4066a0:	f9402fe2 	ldr	x2, [sp, #88]
  4066a4:	f9400001 	ldr	x1, [x0]
  4066a8:	eb010042 	subs	x2, x2, x1
  4066ac:	d2800001 	mov	x1, #0x0                   	// #0
  4066b0:	54000040 	b.eq	4066b8 <printk+0xa0>  // b.none
  4066b4:	97ffeb1b 	bl	401320 <__stack_chk_fail@plt>
  4066b8:	a8d27bfd 	ldp	x29, x30, [sp], #288
  4066bc:	d65f03c0 	ret

00000000004066c0 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  4066c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4066c4:	aa0003e4 	mov	x4, x0
  4066c8:	aa0103e0 	mov	x0, x1
  4066cc:	910003fd 	mov	x29, sp
  4066d0:	aa0203e1 	mov	x1, x2
  4066d4:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
  4066d8:	d63f0080 	blr	x4
	return z_impl_z_current_get();
  4066dc:	94002f2c 	bl	41238c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
  4066e0:	94000b3e 	bl	4093d8 <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  4066e4:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4066e8:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4066ec:	9126e021 	add	x1, x1, #0x9b8
  4066f0:	9124f000 	add	x0, x0, #0x93c
  4066f4:	528005a2 	mov	w2, #0x2d                  	// #45
  4066f8:	94000fa1 	bl	40a57c <posix_print_error_and_exit>

00000000004066fc <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
  4066fc:	d2800082 	mov	x2, #0x4                   	// #4
  406700:	8b214c41 	add	x1, x2, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  406704:	b8616800 	ldr	w0, [x0, x1]
}
  406708:	53017c00 	lsr	w0, w0, #1
  40670c:	d65f03c0 	ret

0000000000406710 <free_list_remove_bidx>:
		return ((uint32_t *)cmem)[f];
  406710:	8b214c04 	add	x4, x0, w1, uxtw #3
  406714:	b9400c83 	ldr	w3, [x4, #12]

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & BIT(bidx));

	if (next_free_chunk(h, c) == c) {
  406718:	6b03003f 	cmp	w1, w3
  40671c:	93407c41 	sxtw	x1, w2
  406720:	54000121 	b.ne	406744 <free_list_remove_bidx+0x34>  // b.any
		/* this is the last chunk */
		h->avail_buckets &= ~BIT(bidx);
  406724:	d2800023 	mov	x3, #0x1                   	// #1
		b->next = 0;
  406728:	91001021 	add	x1, x1, #0x4
		h->avail_buckets &= ~BIT(bidx);
  40672c:	9ac22062 	lsl	x2, x3, x2
  406730:	b9400c03 	ldr	w3, [x0, #12]
  406734:	0a220062 	bic	w2, w3, w2
  406738:	b9000c02 	str	w2, [x0, #12]
		b->next = 0;
  40673c:	b821781f 	str	wzr, [x0, x1, lsl #2]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes -= chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
  406740:	d65f03c0 	ret
		b->next = second;
  406744:	91001021 	add	x1, x1, #0x4
  406748:	b9400882 	ldr	w2, [x4, #8]
  40674c:	b8217803 	str	w3, [x0, x1, lsl #2]
		((uint32_t *)cmem)[f] = val;
  406750:	d2800181 	mov	x1, #0xc                   	// #12
  406754:	8b224c21 	add	x1, x1, w2, uxtw #3
  406758:	b8216803 	str	w3, [x0, x1]
  40675c:	d37d7c63 	ubfiz	x3, x3, #3, #32
  406760:	91002063 	add	x3, x3, #0x8
  406764:	b8236802 	str	w2, [x0, x3]
}
  406768:	17fffff6 	b	406740 <free_list_remove_bidx+0x30>

000000000040676c <alloc_chunk>:
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  40676c:	51000424 	sub	w4, w1, #0x1
	return 31 - __builtin_clz(usable_sz);
  406770:	528003e6 	mov	w6, #0x1f                  	// #31
  406774:	5ac01084 	clz	w4, w4

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
  406778:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40677c:	4b0400c6 	sub	w6, w6, w4
  406780:	910003fd 	mov	x29, sp
  406784:	8b26c808 	add	x8, x0, w6, sxtw #2
  406788:	aa0003e3 	mov	x3, x0
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
  40678c:	b940110a 	ldr	w10, [x8, #16]
  406790:	3400030a 	cbz	w10, 4067f0 <alloc_chunk+0x84>
  406794:	2a0103e7 	mov	w7, w1
  406798:	52800069 	mov	w9, #0x3                   	// #3
		return ((uint32_t *)cmem)[f];
  40679c:	d280018b 	mov	x11, #0xc                   	// #12
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
  4067a0:	b9401105 	ldr	w5, [x8, #16]
			if (chunk_size(h, c) >= sz) {
  4067a4:	aa0303e0 	mov	x0, x3
  4067a8:	2a0503e1 	mov	w1, w5
  4067ac:	97ffffd4 	bl	4066fc <chunk_size>
  4067b0:	6b07001f 	cmp	w0, w7
  4067b4:	54000103 	b.cc	4067d4 <alloc_chunk+0x68>  // b.lo, b.ul, b.last
				free_list_remove_bidx(h, c, bi);
  4067b8:	2a0603e2 	mov	w2, w6

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
  4067bc:	2a0503e1 	mov	w1, w5
  4067c0:	aa0303e0 	mov	x0, x3
  4067c4:	97ffffd3 	bl	406710 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
  4067c8:	2a0503e0 	mov	w0, w5
  4067cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4067d0:	d65f03c0 	ret
  4067d4:	8b254d65 	add	x5, x11, w5, uxtw #3
		} while (--i && b->next != first);
  4067d8:	71000529 	subs	w9, w9, #0x1
  4067dc:	b8656860 	ldr	w0, [x3, x5]
			b->next = next_free_chunk(h, c);
  4067e0:	b9001100 	str	w0, [x8, #16]
		} while (--i && b->next != first);
  4067e4:	54000060 	b.eq	4067f0 <alloc_chunk+0x84>  // b.none
  4067e8:	6b00015f 	cmp	w10, w0
  4067ec:	54fffda1 	b.ne	4067a0 <alloc_chunk+0x34>  // b.any
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
  4067f0:	52800400 	mov	w0, #0x20                  	// #32
  4067f4:	4b040000 	sub	w0, w0, w4
  4067f8:	d2800025 	mov	x5, #0x1                   	// #1
  4067fc:	9ac020a5 	lsl	x5, x5, x0
  406800:	b9400c60 	ldr	w0, [x3, #12]
  406804:	4b0503e5 	neg	w5, w5
	if (bmask != 0U) {
  406808:	6a0000a5 	ands	w5, w5, w0
  40680c:	54fffde0 	b.eq	4067c8 <alloc_chunk+0x5c>  // b.none
		int minbucket = __builtin_ctz(bmask);
  406810:	5ac000a2 	rbit	w2, w5
  406814:	5ac01042 	clz	w2, w2
		chunkid_t c = h->buckets[minbucket].next;
  406818:	8b22c860 	add	x0, x3, w2, sxtw #2
  40681c:	b9401005 	ldr	w5, [x0, #16]
  406820:	17ffffe7 	b	4067bc <alloc_chunk+0x50>

0000000000406824 <free_list_remove>:
{
  406824:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406828:	aa0003e3 	mov	x3, x0
  40682c:	2a0103e4 	mov	w4, w1
  406830:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  406834:	97ffffb2 	bl	4066fc <chunk_size>
	if (!solo_free_header(h, c)) {
  406838:	7100041f 	cmp	w0, #0x1
  40683c:	54000120 	b.eq	406860 <free_list_remove+0x3c>  // b.none
}
  406840:	a8c17bfd 	ldp	x29, x30, [sp], #16
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  406844:	51000402 	sub	w2, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  406848:	5ac01042 	clz	w2, w2
		free_list_remove_bidx(h, c, bidx);
  40684c:	528003e0 	mov	w0, #0x1f                  	// #31
  406850:	2a0403e1 	mov	w1, w4
  406854:	4b020002 	sub	w2, w0, w2
  406858:	aa0303e0 	mov	x0, x3
  40685c:	17ffffad 	b	406710 <free_list_remove_bidx>
}
  406860:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406864:	d65f03c0 	ret

0000000000406868 <free_list_add>:
{
  406868:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40686c:	aa0003e3 	mov	x3, x0
  406870:	2a0103e4 	mov	w4, w1
  406874:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  406878:	97ffffa1 	bl	4066fc <chunk_size>
	if (!solo_free_header(h, c)) {
  40687c:	7100041f 	cmp	w0, #0x1
  406880:	54000260 	b.eq	4068cc <free_list_add+0x64>  // b.none
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  406884:	51000400 	sub	w0, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  406888:	528003e1 	mov	w1, #0x1f                  	// #31
  40688c:	5ac01000 	clz	w0, w0
  406890:	4b000021 	sub	w1, w1, w0
	if (b->next == 0U) {
  406894:	d37d7c80 	ubfiz	x0, x4, #3, #32
  406898:	91002006 	add	x6, x0, #0x8
		((uint32_t *)cmem)[f] = val;
  40689c:	91003000 	add	x0, x0, #0xc
  4068a0:	8b21c867 	add	x7, x3, w1, sxtw #2
  4068a4:	b94010e5 	ldr	w5, [x7, #16]
  4068a8:	35000165 	cbnz	w5, 4068d4 <free_list_add+0x6c>
		h->avail_buckets |= BIT(bidx);
  4068ac:	d2800022 	mov	x2, #0x1                   	// #1
  4068b0:	9ac12042 	lsl	x2, x2, x1
  4068b4:	b9400c61 	ldr	w1, [x3, #12]
  4068b8:	2a020021 	orr	w1, w1, w2
  4068bc:	b9000c61 	str	w1, [x3, #12]
		b->next = c;
  4068c0:	b90010e4 	str	w4, [x7, #16]
  4068c4:	b8266864 	str	w4, [x3, x6]
  4068c8:	b8206864 	str	w4, [x3, x0]
}
  4068cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4068d0:	d65f03c0 	ret
		return ((uint32_t *)cmem)[f];
  4068d4:	d37d7ca1 	ubfiz	x1, x5, #3, #32
  4068d8:	91002021 	add	x1, x1, #0x8
  4068dc:	b8616862 	ldr	w2, [x3, x1]
		((uint32_t *)cmem)[f] = val;
  4068e0:	b8266862 	str	w2, [x3, x6]
  4068e4:	b8206865 	str	w5, [x3, x0]
  4068e8:	d2800180 	mov	x0, #0xc                   	// #12
  4068ec:	8b224c02 	add	x2, x0, w2, uxtw #3
  4068f0:	b8226864 	str	w4, [x3, x2]
  4068f4:	b8216864 	str	w4, [x3, x1]
  4068f8:	17fffff5 	b	4068cc <free_list_add+0x64>

00000000004068fc <merge_chunks>:
{
  4068fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406900:	2a0203e3 	mov	w3, w2
  406904:	aa0003e4 	mov	x4, x0
  406908:	910003fd 	mov	x29, sp
  40690c:	2a0103e6 	mov	w6, w1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
  406910:	97ffff7b 	bl	4066fc <chunk_size>
  406914:	2a0303e1 	mov	w1, w3
  406918:	2a0003e5 	mov	w5, w0
  40691c:	aa0403e0 	mov	x0, x4
  406920:	97ffff77 	bl	4066fc <chunk_size>
  406924:	0b0000a5 	add	w5, w5, w0
  406928:	d2800080 	mov	x0, #0x4                   	// #4
  40692c:	8b264c06 	add	x6, x0, w6, uxtw #3
	return c + chunk_size(h, c);
  406930:	2a0303e1 	mov	w1, w3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406934:	531f78a0 	lsl	w0, w5, #1
		((uint32_t *)cmem)[f] = val;
  406938:	b8266880 	str	w0, [x4, x6]
	return c + chunk_size(h, c);
  40693c:	aa0403e0 	mov	x0, x4
  406940:	97ffff6f 	bl	4066fc <chunk_size>
	void *cmem = &buf[c];
  406944:	0b000063 	add	w3, w3, w0
  406948:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  40694c:	b8236885 	str	w5, [x4, x3]
}
  406950:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406954:	d65f03c0 	ret

0000000000406958 <free_chunk>:
{
  406958:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40695c:	2a0103e8 	mov	w8, w1
  406960:	aa0003e7 	mov	x7, x0
  406964:	910003fd 	mov	x29, sp
	return c + chunk_size(h, c);
  406968:	97ffff65 	bl	4066fc <chunk_size>
  40696c:	0b000101 	add	w1, w8, w0
		return ((uint32_t *)cmem)[f];
  406970:	d2800080 	mov	x0, #0x4                   	// #4
  406974:	8b214c00 	add	x0, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  406978:	b86068e0 	ldr	w0, [x7, x0]
	if (!chunk_used(h, right_chunk(h, c))) {
  40697c:	37000140 	tbnz	w0, #0, 4069a4 <free_chunk+0x4c>
		free_list_remove(h, right_chunk(h, c));
  406980:	aa0703e0 	mov	x0, x7
  406984:	97ffffa8 	bl	406824 <free_list_remove>
	return c + chunk_size(h, c);
  406988:	2a0803e1 	mov	w1, w8
  40698c:	aa0703e0 	mov	x0, x7
  406990:	97ffff5b 	bl	4066fc <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
  406994:	0b000102 	add	w2, w8, w0
  406998:	2a0803e1 	mov	w1, w8
  40699c:	aa0703e0 	mov	x0, x7
  4069a0:	97ffffd7 	bl	4068fc <merge_chunks>
	void *cmem = &buf[c];
  4069a4:	d37d7d09 	ubfiz	x9, x8, #3, #32
		return ((uint32_t *)cmem)[f];
  4069a8:	d2800080 	mov	x0, #0x4                   	// #4
	return c - chunk_field(h, c, LEFT_SIZE);
  4069ac:	b86968e1 	ldr	w1, [x7, x9]
  4069b0:	4b010101 	sub	w1, w8, w1
		return ((uint32_t *)cmem)[f];
  4069b4:	8b214c00 	add	x0, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  4069b8:	b86068e0 	ldr	w0, [x7, x0]
	if (!chunk_used(h, left_chunk(h, c))) {
  4069bc:	37000140 	tbnz	w0, #0, 4069e4 <free_chunk+0x8c>
		free_list_remove(h, left_chunk(h, c));
  4069c0:	aa0703e0 	mov	x0, x7
  4069c4:	97ffff98 	bl	406824 <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
  4069c8:	b86968e1 	ldr	w1, [x7, x9]
		merge_chunks(h, left_chunk(h, c), c);
  4069cc:	2a0803e2 	mov	w2, w8
  4069d0:	aa0703e0 	mov	x0, x7
  4069d4:	4b010101 	sub	w1, w8, w1
  4069d8:	97ffffc9 	bl	4068fc <merge_chunks>
  4069dc:	b86968e0 	ldr	w0, [x7, x9]
  4069e0:	4b000108 	sub	w8, w8, w0
}
  4069e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free_list_add(h, c);
  4069e8:	2a0803e1 	mov	w1, w8
  4069ec:	aa0703e0 	mov	x0, x7
  4069f0:	17ffff9e 	b	406868 <free_list_add>

00000000004069f4 <split_chunks>:
{
  4069f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4069f8:	2a0203e3 	mov	w3, w2
  4069fc:	2a0103e5 	mov	w5, w1
  406a00:	aa0003e4 	mov	x4, x0
  406a04:	910003fd 	mov	x29, sp
	chunksz_t rsz = sz0 - lsz;
  406a08:	4b0300a6 	sub	w6, w5, w3
	chunksz_t sz0 = chunk_size(h, lc);
  406a0c:	97ffff3c 	bl	4066fc <chunk_size>
	chunksz_t rsz = sz0 - lsz;
  406a10:	0b0000c6 	add	w6, w6, w0
		((uint32_t *)cmem)[f] = val;
  406a14:	d2800080 	mov	x0, #0x4                   	// #4
	chunksz_t lsz = rc - lc;
  406a18:	4b050061 	sub	w1, w3, w5
  406a1c:	8b254c05 	add	x5, x0, w5, uxtw #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406a20:	531f7820 	lsl	w0, w1, #1
		((uint32_t *)cmem)[f] = val;
  406a24:	b8256880 	str	w0, [x4, x5]
	void *cmem = &buf[c];
  406a28:	d37d7c60 	ubfiz	x0, x3, #3, #32
		((uint32_t *)cmem)[f] = val;
  406a2c:	8b000082 	add	x2, x4, x0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406a30:	531f78c5 	lsl	w5, w6, #1
		((uint32_t *)cmem)[f] = val;
  406a34:	b9000445 	str	w5, [x2, #4]
  406a38:	b8206881 	str	w1, [x4, x0]
	return c + chunk_size(h, c);
  406a3c:	2a0303e1 	mov	w1, w3
  406a40:	aa0403e0 	mov	x0, x4
  406a44:	97ffff2e 	bl	4066fc <chunk_size>
	void *cmem = &buf[c];
  406a48:	0b000063 	add	w3, w3, w0
  406a4c:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  406a50:	b8236886 	str	w6, [x4, x3]
}
  406a54:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406a58:	d65f03c0 	ret

0000000000406a5c <sys_heap_free>:
	if (mem == NULL) {
  406a5c:	b4000901 	cbz	x1, 406b7c <sys_heap_free+0x120>
{
  406a60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406a64:	d1002023 	sub	x3, x1, #0x8
{
  406a68:	910003fd 	mov	x29, sp
  406a6c:	a90153f3 	stp	x19, x20, [sp, #16]
  406a70:	aa0103f3 	mov	x19, x1
	struct z_heap *h = heap->heap;
  406a74:	f9400004 	ldr	x4, [x0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406a78:	d2800100 	mov	x0, #0x8                   	// #8
  406a7c:	cb040063 	sub	x3, x3, x4
  406a80:	9ac00c63 	sdiv	x3, x3, x0
		return ((uint32_t *)cmem)[f];
  406a84:	8b234c86 	add	x6, x4, w3, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  406a88:	b94004c5 	ldr	w5, [x6, #4]
	__ASSERT(chunk_used(h, c),
  406a8c:	370002c5 	tbnz	w5, #0, 406ae4 <sys_heap_free+0x88>
  406a90:	d0000074 	adrp	x20, 414000 <dlc_table.0+0x60d>
  406a94:	91278694 	add	x20, x20, #0x9e1
  406a98:	aa1403e2 	mov	x2, x20
  406a9c:	528015e3 	mov	w3, #0xaf                  	// #175
  406aa0:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  406aa4:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406aa8:	91280821 	add	x1, x1, #0xa02
  406aac:	9123f800 	add	x0, x0, #0x8fe
  406ab0:	94000497 	bl	407d0c <assert_print>
  406ab4:	aa1303e1 	mov	x1, x19
  406ab8:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406abc:	91284c00 	add	x0, x0, #0xa13
  406ac0:	94000493 	bl	407d0c <assert_print>
  406ac4:	aa1403e0 	mov	x0, x20
  406ac8:	528015e1 	mov	w1, #0xaf                  	// #175
  406acc:	940004ba 	bl	407db4 <assert_post_action>
  406ad0:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406ad4:	aa1403e1 	mov	x1, x20
  406ad8:	9124f000 	add	x0, x0, #0x93c
  406adc:	528015e2 	mov	w2, #0xaf                  	// #175
  406ae0:	94000ea7 	bl	40a57c <posix_print_error_and_exit>
	return c + chunk_size(h, c);
  406ae4:	2a0303e1 	mov	w1, w3
  406ae8:	aa0403e0 	mov	x0, x4
  406aec:	97ffff04 	bl	4066fc <chunk_size>
  406af0:	0b030001 	add	w1, w0, w3
	void *cmem = &buf[c];
  406af4:	0b030000 	add	w0, w0, w3
  406af8:	d37df000 	lsl	x0, x0, #3
	return c - chunk_field(h, c, LEFT_SIZE);
  406afc:	b8606880 	ldr	w0, [x4, x0]
  406b00:	4b000021 	sub	w1, w1, w0
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
  406b04:	6b01007f 	cmp	w3, w1
  406b08:	540002c0 	b.eq	406b60 <sys_heap_free+0x104>  // b.none
  406b0c:	d0000074 	adrp	x20, 414000 <dlc_table.0+0x60d>
  406b10:	91278694 	add	x20, x20, #0x9e1
  406b14:	aa1403e2 	mov	x2, x20
  406b18:	528016e3 	mov	w3, #0xb7                  	// #183
  406b1c:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  406b20:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406b24:	91292c21 	add	x1, x1, #0xa4b
  406b28:	9123f800 	add	x0, x0, #0x8fe
  406b2c:	94000478 	bl	407d0c <assert_print>
  406b30:	aa1303e1 	mov	x1, x19
  406b34:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406b38:	9129c400 	add	x0, x0, #0xa71
  406b3c:	94000474 	bl	407d0c <assert_print>
  406b40:	aa1403e0 	mov	x0, x20
  406b44:	528016e1 	mov	w1, #0xb7                  	// #183
  406b48:	9400049b 	bl	407db4 <assert_post_action>
  406b4c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406b50:	aa1403e1 	mov	x1, x20
  406b54:	9124f000 	add	x0, x0, #0x93c
  406b58:	528016e2 	mov	w2, #0xb7                  	// #183
  406b5c:	94000e88 	bl	40a57c <posix_print_error_and_exit>
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
  406b60:	121f78a5 	and	w5, w5, #0xfffffffe
  406b64:	b90004c5 	str	w5, [x6, #4]
	free_chunk(h, c);
  406b68:	2a0303e1 	mov	w1, w3
  406b6c:	aa0403e0 	mov	x0, x4
}
  406b70:	a94153f3 	ldp	x19, x20, [sp, #16]
  406b74:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free_chunk(h, c);
  406b78:	17ffff78 	b	406958 <free_chunk>
  406b7c:	d65f03c0 	ret

0000000000406b80 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
	struct z_heap *h = heap->heap;
  406b80:	f940000d 	ldr	x13, [x0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
  406b84:	b50000c1 	cbnz	x1, 406b9c <sys_heap_alloc+0x1c>
		return NULL;
  406b88:	d2800000 	mov	x0, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  406b8c:	d65f03c0 	ret
		return NULL;
  406b90:	d2800000 	mov	x0, #0x0                   	// #0
}
  406b94:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406b98:	d65f03c0 	ret
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  406b9c:	b94009a0 	ldr	w0, [x13, #8]
	if (bytes == 0U || size_too_big(h, bytes)) {
  406ba0:	eb410c1f 	cmp	x0, x1, lsr #3
  406ba4:	54ffff29 	b.ls	406b88 <sys_heap_alloc+0x8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406ba8:	91003c21 	add	x1, x1, #0xf
{
  406bac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	chunkid_t c = alloc_chunk(h, chunk_sz);
  406bb0:	aa0d03e0 	mov	x0, x13
  406bb4:	d343fc2c 	lsr	x12, x1, #3
{
  406bb8:	910003fd 	mov	x29, sp
	chunkid_t c = alloc_chunk(h, chunk_sz);
  406bbc:	2a0c03e1 	mov	w1, w12
  406bc0:	97fffeeb 	bl	40676c <alloc_chunk>
  406bc4:	2a0003e8 	mov	w8, w0
	if (c == 0U) {
  406bc8:	34fffe40 	cbz	w0, 406b90 <sys_heap_alloc+0x10>
	if (chunk_size(h, c) > chunk_sz) {
  406bcc:	2a0003e1 	mov	w1, w0
  406bd0:	aa0d03e0 	mov	x0, x13
  406bd4:	97fffeca 	bl	4066fc <chunk_size>
  406bd8:	6b0c001f 	cmp	w0, w12
  406bdc:	54000129 	b.ls	406c00 <sys_heap_alloc+0x80>  // b.plast
		split_chunks(h, c, c + chunk_sz);
  406be0:	0b0c010c 	add	w12, w8, w12
  406be4:	2a0803e1 	mov	w1, w8
  406be8:	2a0c03e2 	mov	w2, w12
  406bec:	aa0d03e0 	mov	x0, x13
  406bf0:	97ffff81 	bl	4069f4 <split_chunks>
		free_list_add(h, c + chunk_sz);
  406bf4:	2a0c03e1 	mov	w1, w12
  406bf8:	aa0d03e0 	mov	x0, x13
  406bfc:	97ffff1b 	bl	406868 <free_list_add>
	void *cmem = &buf[c];
  406c00:	d37d7d08 	ubfiz	x8, x8, #3, #32
  406c04:	8b0801a1 	add	x1, x13, x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406c08:	91002108 	add	x8, x8, #0x8
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406c0c:	b9400420 	ldr	w0, [x1, #4]
  406c10:	32000000 	orr	w0, w0, #0x1
  406c14:	b9000420 	str	w0, [x1, #4]
  406c18:	8b0801a0 	add	x0, x13, x8
	return mem;
  406c1c:	17ffffde 	b	406b94 <sys_heap_alloc+0x14>

0000000000406c20 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
  406c20:	aa0203ec 	mov	x12, x2
  406c24:	91003c43 	add	x3, x2, #0xf
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
  406c28:	cb0103e2 	neg	x2, x1
  406c2c:	8a01004e 	and	x14, x2, x1
	struct z_heap *h = heap->heap;
  406c30:	f940000d 	ldr	x13, [x0]
	if (align != rew) {
  406c34:	ea22003f 	bics	xzr, x1, x2
  406c38:	54000400 	b.eq	406cb8 <sys_heap_aligned_alloc+0x98>  // b.none
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
  406c3c:	f10021df 	cmp	x14, #0x8
  406c40:	aa0e03ef 	mov	x15, x14
  406c44:	d2800100 	mov	x0, #0x8                   	// #8
  406c48:	9a8091c0 	csel	x0, x14, x0, ls  // ls = plast
		align -= rew;
  406c4c:	cb0e002e 	sub	x14, x1, x14
{
  406c50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  406c54:	d10005d2 	sub	x18, x14, #0x1
{
  406c58:	910003fd 	mov	x29, sp
  406c5c:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  406c60:	ea0e025f 	tst	x18, x14
  406c64:	54000380 	b.eq	406cd4 <sys_heap_aligned_alloc+0xb4>  // b.none
  406c68:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  406c6c:	91278673 	add	x19, x19, #0x9e1
  406c70:	aa1303e2 	mov	x2, x19
  406c74:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  406c78:	912ab421 	add	x1, x1, #0xaad
  406c7c:	52802883 	mov	w3, #0x144                 	// #324
  406c80:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406c84:	9123f800 	add	x0, x0, #0x8fe
  406c88:	94000421 	bl	407d0c <assert_print>
  406c8c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406c90:	912b2000 	add	x0, x0, #0xac8
  406c94:	9400041e 	bl	407d0c <assert_print>
  406c98:	aa1303e0 	mov	x0, x19
  406c9c:	52802881 	mov	w1, #0x144                 	// #324
  406ca0:	94000445 	bl	407db4 <assert_post_action>
  406ca4:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406ca8:	aa1303e1 	mov	x1, x19
  406cac:	9124f000 	add	x0, x0, #0x93c
  406cb0:	52802882 	mov	w2, #0x144                 	// #324
  406cb4:	94000e32 	bl	40a57c <posix_print_error_and_exit>
		if (align <= chunk_header_bytes(h)) {
  406cb8:	f100203f 	cmp	x1, #0x8
  406cbc:	54000068 	b.hi	406cc8 <sys_heap_aligned_alloc+0xa8>  // b.pmore
			return sys_heap_alloc(heap, bytes);
  406cc0:	aa0c03e1 	mov	x1, x12
  406cc4:	17ffffaf 	b	406b80 <sys_heap_alloc>
		rew = 0;
  406cc8:	d280000f 	mov	x15, #0x0                   	// #0
		gap = chunk_header_bytes(h);
  406ccc:	d2800100 	mov	x0, #0x8                   	// #8
  406cd0:	17ffffe0 	b	406c50 <sys_heap_aligned_alloc+0x30>

	if (bytes == 0 || size_too_big(h, bytes)) {
  406cd4:	b50000cc 	cbnz	x12, 406cec <sys_heap_aligned_alloc+0xcc>
		return NULL;
  406cd8:	d2800009 	mov	x9, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  406cdc:	aa0903e0 	mov	x0, x9
  406ce0:	f9400bf3 	ldr	x19, [sp, #16]
  406ce4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  406ce8:	d65f03c0 	ret
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  406cec:	b94009a1 	ldr	w1, [x13, #8]
	if (bytes == 0 || size_too_big(h, bytes)) {
  406cf0:	eb4c0c3f 	cmp	x1, x12, lsr #3
  406cf4:	54ffff29 	b.ls	406cd8 <sys_heap_aligned_alloc+0xb8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406cf8:	cb0001c1 	sub	x1, x14, x0
	chunkid_t c0 = alloc_chunk(h, padded_sz);
  406cfc:	aa0d03e0 	mov	x0, x13
  406d00:	8b030021 	add	x1, x1, x3
  406d04:	d3438821 	ubfx	x1, x1, #3, #32
  406d08:	97fffe99 	bl	40676c <alloc_chunk>
  406d0c:	2a0003e7 	mov	w7, w0
	if (c0 == 0) {
  406d10:	34fffe40 	cbz	w0, 406cd8 <sys_heap_aligned_alloc+0xb8>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406d14:	d37d7ce9 	ubfiz	x9, x7, #3, #32
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  406d18:	cb0e03ee 	neg	x14, x14
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406d1c:	91002129 	add	x9, x9, #0x8
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406d20:	d2800100 	mov	x0, #0x8                   	// #8
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  406d24:	8b0f0129 	add	x9, x9, x15
  406d28:	8b0901a9 	add	x9, x13, x9
  406d2c:	8b120129 	add	x9, x9, x18
  406d30:	8a0e0129 	and	x9, x9, x14
  406d34:	cb0f0129 	sub	x9, x9, x15
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406d38:	d100212a 	sub	x10, x9, #0x8
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  406d3c:	8b0c0128 	add	x8, x9, x12
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406d40:	cb0d014a 	sub	x10, x10, x13
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  406d44:	91001d08 	add	x8, x8, #0x7
  406d48:	927df108 	and	x8, x8, #0xfffffffffffffff8
	chunkid_t c_end = end - chunk_buf(h);
  406d4c:	cb0d0108 	sub	x8, x8, x13
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406d50:	9ac00d4a 	sdiv	x10, x10, x0
	chunkid_t c_end = end - chunk_buf(h);
  406d54:	9343fd08 	asr	x8, x8, #3
	if (c > c0) {
  406d58:	6b0a00ff 	cmp	w7, w10
  406d5c:	54000102 	b.cs	406d7c <sys_heap_aligned_alloc+0x15c>  // b.hs, b.nlast
		split_chunks(h, c0, c);
  406d60:	2a0a03e2 	mov	w2, w10
  406d64:	2a0703e1 	mov	w1, w7
  406d68:	aa0d03e0 	mov	x0, x13
  406d6c:	97ffff22 	bl	4069f4 <split_chunks>
		free_list_add(h, c0);
  406d70:	2a0703e1 	mov	w1, w7
  406d74:	aa0d03e0 	mov	x0, x13
  406d78:	97fffebc 	bl	406868 <free_list_add>
	return c + chunk_size(h, c);
  406d7c:	2a0a03e1 	mov	w1, w10
  406d80:	aa0d03e0 	mov	x0, x13
  406d84:	97fffe5e 	bl	4066fc <chunk_size>
  406d88:	0b0a0000 	add	w0, w0, w10
	if (right_chunk(h, c) > c_end) {
  406d8c:	6b00011f 	cmp	w8, w0
  406d90:	54000102 	b.cs	406db0 <sys_heap_aligned_alloc+0x190>  // b.hs, b.nlast
		split_chunks(h, c, c_end);
  406d94:	2a0803e2 	mov	w2, w8
  406d98:	2a0a03e1 	mov	w1, w10
  406d9c:	aa0d03e0 	mov	x0, x13
  406da0:	97ffff15 	bl	4069f4 <split_chunks>
		free_list_add(h, c_end);
  406da4:	2a0803e1 	mov	w1, w8
  406da8:	aa0d03e0 	mov	x0, x13
  406dac:	97fffeaf 	bl	406868 <free_list_add>
	void *cmem = &buf[c];
  406db0:	8b2a4daa 	add	x10, x13, w10, uxtw #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406db4:	b9400540 	ldr	w0, [x10, #4]
  406db8:	32000000 	orr	w0, w0, #0x1
  406dbc:	b9000540 	str	w0, [x10, #4]
  406dc0:	17ffffc7 	b	406cdc <sys_heap_aligned_alloc+0xbc>

0000000000406dc4 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
  406dc4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		/* Must fit in a 15 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
	} else {
		/* Must fit in a 31 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  406dc8:	b24087e3 	mov	x3, #0x3ffffffff           	// #17179869183
{
  406dcc:	910003fd 	mov	x29, sp
  406dd0:	a90153f3 	stp	x19, x20, [sp, #16]
  406dd4:	f90013f5 	str	x21, [sp, #32]
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  406dd8:	eb03005f 	cmp	x2, x3
  406ddc:	540002a9 	b.ls	406e30 <sys_heap_init+0x6c>  // b.plast
  406de0:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  406de4:	91278673 	add	x19, x19, #0x9e1
  406de8:	aa1303e2 	mov	x2, x19
  406dec:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  406df0:	912b9421 	add	x1, x1, #0xae5
  406df4:	52803dc3 	mov	w3, #0x1ee                 	// #494
  406df8:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406dfc:	9123f800 	add	x0, x0, #0x8fe
  406e00:	940003c3 	bl	407d0c <assert_print>
  406e04:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406e08:	912bfc00 	add	x0, x0, #0xaff
  406e0c:	940003c0 	bl	407d0c <assert_print>
  406e10:	aa1303e0 	mov	x0, x19
  406e14:	52803dc1 	mov	w1, #0x1ee                 	// #494
  406e18:	940003e7 	bl	407db4 <assert_post_action>
  406e1c:	52803dc2 	mov	w2, #0x1ee                 	// #494
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
  406e20:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406e24:	aa1303e1 	mov	x1, x19
  406e28:	9124f000 	add	x0, x0, #0x93c
  406e2c:	94000dd4 	bl	40a57c <posix_print_error_and_exit>
  406e30:	f100205f 	cmp	x2, #0x8
  406e34:	54000248 	b.hi	406e7c <sys_heap_init+0xb8>  // b.pmore
  406e38:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  406e3c:	91278673 	add	x19, x19, #0x9e1
  406e40:	aa1303e2 	mov	x2, x19
  406e44:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  406e48:	912c5821 	add	x1, x1, #0xb16
  406e4c:	52803e43 	mov	w3, #0x1f2                 	// #498
  406e50:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406e54:	9123f800 	add	x0, x0, #0x8fe
  406e58:	940003ad 	bl	407d0c <assert_print>
  406e5c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406e60:	912cdc00 	add	x0, x0, #0xb37
  406e64:	940003aa 	bl	407d0c <assert_print>
  406e68:	aa1303e0 	mov	x0, x19
  406e6c:	52803e41 	mov	w1, #0x1f2                 	// #498
  406e70:	940003d1 	bl	407db4 <assert_post_action>
  406e74:	52803e42 	mov	w2, #0x1f2                 	// #498
  406e78:	17ffffea 	b	406e20 <sys_heap_init+0x5c>
	bytes -= heap_footer_bytes(bytes);
  406e7c:	d1002042 	sub	x2, x2, #0x8

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  406e80:	91001c34 	add	x20, x1, #0x7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  406e84:	8b020033 	add	x19, x1, x2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  406e88:	927df294 	and	x20, x20, #0xfffffffffffffff8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  406e8c:	927df273 	and	x19, x19, #0xfffffffffffffff8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
  406e90:	cb140273 	sub	x19, x19, x20
  406e94:	d343fe73 	lsr	x19, x19, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
  406e98:	71000a7f 	cmp	w19, #0x2
  406e9c:	54000248 	b.hi	406ee4 <sys_heap_init+0x120>  // b.pmore
  406ea0:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  406ea4:	91278673 	add	x19, x19, #0x9e1
  406ea8:	aa1303e2 	mov	x2, x19
  406eac:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  406eb0:	912d4021 	add	x1, x1, #0xb50
  406eb4:	52803f63 	mov	w3, #0x1fb                 	// #507
  406eb8:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406ebc:	9123f800 	add	x0, x0, #0x8fe
  406ec0:	94000393 	bl	407d0c <assert_print>
  406ec4:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406ec8:	912cdc00 	add	x0, x0, #0xb37
  406ecc:	94000390 	bl	407d0c <assert_print>
  406ed0:	aa1303e0 	mov	x0, x19
  406ed4:	52803f61 	mov	w1, #0x1fb                 	// #507
  406ed8:	940003b7 	bl	407db4 <assert_post_action>
  406edc:	52803f62 	mov	w2, #0x1fb                 	// #507
  406ee0:	17ffffd0 	b	406e20 <sys_heap_init+0x5c>

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
  406ee4:	f9000014 	str	x20, [x0]
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  406ee8:	51000660 	sub	w0, w19, #0x1
	return 31 - __builtin_clz(usable_sz);
  406eec:	5ac01000 	clz	w0, w0
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406ef0:	52800495 	mov	w21, #0x24                  	// #36
  406ef4:	4b0002b5 	sub	w21, w21, w0
  406ef8:	d28000e1 	mov	x1, #0x7                   	// #7
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
  406efc:	29017e93 	stp	w19, wzr, [x20, #8]
  406f00:	8b35c835 	add	x21, x1, w21, sxtw #2
  406f04:	d343feb5 	lsr	x21, x21, #3

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
  406f08:	11000aa1 	add	w1, w21, #0x2
  406f0c:	6b13003f 	cmp	w1, w19
  406f10:	54000249 	b.ls	406f58 <sys_heap_init+0x194>  // b.plast
  406f14:	d0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  406f18:	91278673 	add	x19, x19, #0x9e1
  406f1c:	aa1303e2 	mov	x2, x19
  406f20:	d0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  406f24:	912de421 	add	x1, x1, #0xb79
  406f28:	52804183 	mov	w3, #0x20c                 	// #524
  406f2c:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406f30:	9123f800 	add	x0, x0, #0x8fe
  406f34:	94000376 	bl	407d0c <assert_print>
  406f38:	d0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  406f3c:	912cdc00 	add	x0, x0, #0xb37
  406f40:	94000373 	bl	407d0c <assert_print>
  406f44:	aa1303e0 	mov	x0, x19
  406f48:	52804181 	mov	w1, #0x20c                 	// #524
  406f4c:	9400039a 	bl	407db4 <assert_post_action>
  406f50:	52804182 	mov	w2, #0x20c                 	// #524
  406f54:	17ffffb3 	b	406e20 <sys_heap_init+0x5c>

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
  406f58:	52800402 	mov	w2, #0x20                  	// #32
  406f5c:	4b000042 	sub	w2, w2, w0
  406f60:	52800001 	mov	w1, #0x0                   	// #0
  406f64:	91004280 	add	x0, x20, #0x10
  406f68:	d37ef442 	lsl	x2, x2, #2
  406f6c:	97ffe8cd 	bl	4012a0 <memset@plt>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406f70:	531f7aa0 	lsl	w0, w21, #1
		((uint32_t *)cmem)[f] = val;
  406f74:	8b150e82 	add	x2, x20, x21, lsl #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406f78:	32000000 	orr	w0, w0, #0x1
	void *cmem = &buf[c];
  406f7c:	d37df2a1 	lsl	x1, x21, #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406f80:	2900029f 	stp	wzr, w0, [x20]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  406f84:	4b150260 	sub	w0, w19, w21
	void *cmem = &buf[c];
  406f88:	d37d7e73 	ubfiz	x19, x19, #3, #32
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406f8c:	531f7803 	lsl	w3, w0, #1
		((uint32_t *)cmem)[f] = val;
  406f90:	b9000443 	str	w3, [x2, #4]
  406f94:	b8216a95 	str	w21, [x20, x1]
  406f98:	8b130281 	add	x1, x20, x19
  406f9c:	b8336a80 	str	w0, [x20, x19]
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406fa0:	52800020 	mov	w0, #0x1                   	// #1
  406fa4:	b9000420 	str	w0, [x1, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
  406fa8:	2a1503e1 	mov	w1, w21
  406fac:	aa1403e0 	mov	x0, x20
}
  406fb0:	a94153f3 	ldp	x19, x20, [sp, #16]
  406fb4:	f94013f5 	ldr	x21, [sp, #32]
  406fb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	free_list_add(h, chunk0_size);
  406fbc:	17fffe2b 	b	406868 <free_list_add>

0000000000406fc0 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
  406fc0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  406fc4:	910003fd 	mov	x29, sp
  406fc8:	a90153f3 	stp	x19, x20, [sp, #16]
  406fcc:	aa0203f4 	mov	x20, x2
	size_t count = 0;
  406fd0:	d2800013 	mov	x19, #0x0                   	// #0
{
  406fd4:	a9025bf5 	stp	x21, x22, [sp, #32]
  406fd8:	aa0003f6 	mov	x22, x0
  406fdc:	aa0303f5 	mov	x21, x3
  406fe0:	f9001bf7 	str	x23, [sp, #48]
  406fe4:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
  406fe8:	8b130280 	add	x0, x20, x19
  406fec:	eb0002bf 	cmp	x21, x0
  406ff0:	54000148 	b.hi	407018 <outs+0x58>  // b.pmore
  406ff4:	b40000f5 	cbz	x21, 407010 <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
  406ff8:	2a1303e0 	mov	w0, w19
}
  406ffc:	a94153f3 	ldp	x19, x20, [sp, #16]
  407000:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407004:	f9401bf7 	ldr	x23, [sp, #48]
  407008:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40700c:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
  407010:	38736a80 	ldrb	w0, [x20, x19]
  407014:	34ffff20 	cbz	w0, 406ff8 <outs+0x38>
		int rc = out((int)*sp++, ctx);
  407018:	38736a80 	ldrb	w0, [x20, x19]
  40701c:	aa1703e1 	mov	x1, x23
  407020:	d63f02c0 	blr	x22
		if (rc < 0) {
  407024:	37fffec0 	tbnz	w0, #31, 406ffc <outs+0x3c>
		++count;
  407028:	91000673 	add	x19, x19, #0x1
  40702c:	17ffffef 	b	406fe8 <outs+0x28>

0000000000407030 <extract_decimal>:
{
  407030:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  407034:	910003fd 	mov	x29, sp
  407038:	a90153f3 	stp	x19, x20, [sp, #16]
  40703c:	aa0003f4 	mov	x20, x0
	const char *sp = *str;
  407040:	f9400013 	ldr	x19, [x0]
	while (isdigit((int)(unsigned char)*sp) != 0) {
  407044:	97ffe8db 	bl	4013b0 <__ctype_b_loc@plt>
		val = 10U * val + *sp++ - '0';
  407048:	d2800144 	mov	x4, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp) != 0) {
  40704c:	f9400002 	ldr	x2, [x0]
	size_t val = 0;
  407050:	d2800000 	mov	x0, #0x0                   	// #0
	while (isdigit((int)(unsigned char)*sp) != 0) {
  407054:	39400263 	ldrb	w3, [x19]
  407058:	78637841 	ldrh	w1, [x2, x3, lsl #1]
  40705c:	375800a1 	tbnz	w1, #11, 407070 <extract_decimal+0x40>
	*str = sp;
  407060:	f9000293 	str	x19, [x20]
}
  407064:	a94153f3 	ldp	x19, x20, [sp, #16]
  407068:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40706c:	d65f03c0 	ret
		val = 10U * val + *sp++ - '0';
  407070:	9b040c00 	madd	x0, x0, x4, x3
  407074:	91000673 	add	x19, x19, #0x1
  407078:	d100c000 	sub	x0, x0, #0x30
  40707c:	17fffff6 	b	407054 <extract_decimal+0x24>

0000000000407080 <encode_uint>:
{
  407080:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  407084:	910003fd 	mov	x29, sp
  407088:	a90153f3 	stp	x19, x20, [sp, #16]
  40708c:	aa0103f3 	mov	x19, x1
  407090:	aa0303f4 	mov	x20, x3
  407094:	a9025bf5 	stp	x21, x22, [sp, #32]
  407098:	aa0203f6 	mov	x22, x2
  40709c:	aa0003f5 	mov	x21, x0
	bool upcase = isupper((int)conv->specifier) != 0;
  4070a0:	97ffe8c4 	bl	4013b0 <__ctype_b_loc@plt>
  4070a4:	39400e62 	ldrb	w2, [x19, #3]
  4070a8:	f9400000 	ldr	x0, [x0]
  4070ac:	39400e61 	ldrb	w1, [x19, #3]
  4070b0:	78627802 	ldrh	w2, [x0, x2, lsl #1]
  4070b4:	12180042 	and	w2, w2, #0x100
	switch (specifier) {
  4070b8:	7101bc3f 	cmp	w1, #0x6f
  4070bc:	54000400 	b.eq	40713c <encode_uint+0xbc>  // b.none
  4070c0:	54000388 	b.hi	407130 <encode_uint+0xb0>  // b.pmore
		return 16;
  4070c4:	7101603f 	cmp	w1, #0x58
  4070c8:	d2800145 	mov	x5, #0xa                   	// #10
  4070cc:	d2800200 	mov	x0, #0x10                  	// #16
  4070d0:	9a8010a5 	csel	x5, x5, x0, ne  // ne = any
	char *bp = bps + (bpe - bps);
  4070d4:	aa1403e0 	mov	x0, x20
		unsigned int lsv = (unsigned int)(value % radix);
  4070d8:	9ac50aa3 	udiv	x3, x21, x5
  4070dc:	9b05d461 	msub	x1, x3, x5, x21
		*--bp = (lsv <= 9) ? ('0' + lsv)
  4070e0:	12001c24 	and	w4, w1, #0xff
  4070e4:	f100243f 	cmp	x1, #0x9
  4070e8:	54000328 	b.hi	40714c <encode_uint+0xcc>  // b.pmore
  4070ec:	1100c084 	add	w4, w4, #0x30
  4070f0:	12001c84 	and	w4, w4, #0xff
  4070f4:	381ffc04 	strb	w4, [x0, #-1]!
	} while ((value != 0) && (bps < bp));
  4070f8:	eb0502bf 	cmp	x21, x5
  4070fc:	fa562000 	ccmp	x0, x22, #0x0, cs  // cs = hs, nlast
  407100:	54000228 	b.hi	407144 <encode_uint+0xc4>  // b.pmore
	if (conv->flag_hash) {
  407104:	79400261 	ldrh	w1, [x19]
  407108:	362800c1 	tbz	w1, #5, 407120 <encode_uint+0xa0>
		if (radix == 8) {
  40710c:	f10020bf 	cmp	x5, #0x8
  407110:	540002c1 	b.ne	407168 <encode_uint+0xe8>  // b.any
			conv->altform_0 = true;
  407114:	39400a61 	ldrb	w1, [x19, #2]
  407118:	321d0021 	orr	w1, w1, #0x8
			conv->altform_0c = true;
  40711c:	39000a61 	strb	w1, [x19, #2]
}
  407120:	a94153f3 	ldp	x19, x20, [sp, #16]
  407124:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407128:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40712c:	d65f03c0 	ret
	switch (specifier) {
  407130:	121c7821 	and	w1, w1, #0xfffffff7
		return 16;
  407134:	7101c03f 	cmp	w1, #0x70
  407138:	17ffffe4 	b	4070c8 <encode_uint+0x48>
	switch (specifier) {
  40713c:	d2800105 	mov	x5, #0x8                   	// #8
  407140:	17ffffe5 	b	4070d4 <encode_uint+0x54>
		value /= radix;
  407144:	aa0303f5 	mov	x21, x3
  407148:	17ffffe4 	b	4070d8 <encode_uint+0x58>
		*--bp = (lsv <= 9) ? ('0' + lsv)
  40714c:	1100dc81 	add	w1, w4, #0x37
  407150:	11015c84 	add	w4, w4, #0x57
  407154:	12001c21 	and	w1, w1, #0xff
  407158:	12001c84 	and	w4, w4, #0xff
  40715c:	7100005f 	cmp	w2, #0x0
  407160:	1a810084 	csel	w4, w4, w1, eq  // eq = none
  407164:	17ffffe4 	b	4070f4 <encode_uint+0x74>
		} else if (radix == 16) {
  407168:	f10040bf 	cmp	x5, #0x10
  40716c:	54fffda1 	b.ne	407120 <encode_uint+0xa0>  // b.any
			conv->altform_0c = true;
  407170:	39400a61 	ldrb	w1, [x19, #2]
  407174:	321c0021 	orr	w1, w1, #0x10
  407178:	17ffffe9 	b	40711c <encode_uint+0x9c>

000000000040717c <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
  40717c:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  407180:	910003fd 	mov	x29, sp
  407184:	a9046bf9 	stp	x25, x26, [sp, #64]
  407188:	aa0003f9 	mov	x25, x0
  40718c:	90000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  407190:	a90153f3 	stp	x19, x20, [sp, #16]
  407194:	aa0103fa 	mov	x26, x1
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
  407198:	d2800013 	mov	x19, #0x0                   	// #0
{
  40719c:	a9025bf5 	stp	x21, x22, [sp, #32]
  4071a0:	aa0203f5 	mov	x21, x2
  4071a4:	a90363f7 	stp	x23, x24, [sp, #48]
  4071a8:	a90573fb 	stp	x27, x28, [sp, #80]
  4071ac:	f9476800 	ldr	x0, [x0, #3792]
  4071b0:	a940607c 	ldp	x28, x24, [x3]
  4071b4:	f9400001 	ldr	x1, [x0]
  4071b8:	f90067e1 	str	x1, [sp, #200]
  4071bc:	d2800001 	mov	x1, #0x0                   	// #0
  4071c0:	b940187b 	ldr	w27, [x3, #24]
  4071c4:	f9400860 	ldr	x0, [x3, #16]
  4071c8:	f9003be0 	str	x0, [sp, #112]
  4071cc:	b9401c60 	ldr	w0, [x3, #28]
  4071d0:	b90067e0 	str	w0, [sp, #100]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
  4071d4:	91031be0 	add	x0, sp, #0xc6
  4071d8:	f90037e0 	str	x0, [sp, #104]
  4071dc:	394002a0 	ldrb	w0, [x21]
  4071e0:	35000140 	cbnz	w0, 407208 <z_cbvprintf_impl+0x8c>
			OUTC(' ');
			--width;
		}
	}

	return count;
  4071e4:	2a1303e0 	mov	w0, w19
#undef OUTS
#undef OUTC
}
  4071e8:	90000121 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  4071ec:	f9476821 	ldr	x1, [x1, #3792]
  4071f0:	f94067e3 	ldr	x3, [sp, #200]
  4071f4:	f9400022 	ldr	x2, [x1]
  4071f8:	eb020063 	subs	x3, x3, x2
  4071fc:	d2800002 	mov	x2, #0x0                   	// #0
  407200:	54005780 	b.eq	407cf0 <z_cbvprintf_impl+0xb74>  // b.none
  407204:	97ffe847 	bl	401320 <__stack_chk_fail@plt>
			OUTC(*fp++);
  407208:	910006b4 	add	x20, x21, #0x1
		if (*fp != '%') {
  40720c:	7100941f 	cmp	w0, #0x25
  407210:	540000c0 	b.eq	407228 <z_cbvprintf_impl+0xac>  // b.none
			OUTC('%');
  407214:	aa1a03e1 	mov	x1, x26
  407218:	d63f0320 	blr	x25
  40721c:	37fffe60 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407220:	91000673 	add	x19, x19, #0x1
			break;
  407224:	14000140 	b	407724 <z_cbvprintf_impl+0x5a8>
		} state = {
  407228:	a9097fff 	stp	xzr, xzr, [sp, #144]
  40722c:	a90a7fff 	stp	xzr, xzr, [sp, #160]
	if (*sp == '%') {
  407230:	394006a0 	ldrb	w0, [x21, #1]
  407234:	7100941f 	cmp	w0, #0x25
  407238:	54000661 	b.ne	407304 <z_cbvprintf_impl+0x188>  // b.any
		conv->specifier = *sp++;
  40723c:	91000ab4 	add	x20, x21, #0x2
  407240:	39028fe0 	strb	w0, [sp, #163]
		if (conv->width_star) {
  407244:	794143e0 	ldrh	w0, [sp, #160]
  407248:	364021c0 	tbz	w0, #8, 407680 <z_cbvprintf_impl+0x504>
			width = va_arg(ap, int);
  40724c:	37f8205b 	tbnz	w27, #31, 407654 <z_cbvprintf_impl+0x4d8>
  407250:	91002f81 	add	x1, x28, #0xb
  407254:	aa1c03e0 	mov	x0, x28
  407258:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  40725c:	b9400016 	ldr	w22, [x0]
			if (width < 0) {
  407260:	36f800b6 	tbz	w22, #31, 407274 <z_cbvprintf_impl+0xf8>
				conv->flag_dash = true;
  407264:	794143e0 	ldrh	w0, [sp, #160]
				width = -width;
  407268:	4b1603f6 	neg	w22, w22
				conv->flag_dash = true;
  40726c:	321e0000 	orr	w0, w0, #0x4
  407270:	790143e0 	strh	w0, [sp, #160]
		if (conv->prec_star) {
  407274:	794143e0 	ldrh	w0, [sp, #160]
  407278:	36502220 	tbz	w0, #10, 4076bc <z_cbvprintf_impl+0x540>
			int arg = va_arg(ap, int);
  40727c:	37f820bb 	tbnz	w27, #31, 407690 <z_cbvprintf_impl+0x514>
  407280:	91002f81 	add	x1, x28, #0xb
  407284:	aa1c03e0 	mov	x0, x28
  407288:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  40728c:	b9400017 	ldr	w23, [x0]
			if (arg < 0) {
  407290:	36f800b7 	tbz	w23, #31, 4072a4 <z_cbvprintf_impl+0x128>
				conv->prec_present = false;
  407294:	794143e0 	ldrh	w0, [sp, #160]
		int precision = -1;
  407298:	12800017 	mov	w23, #0xffffffff            	// #-1
				conv->prec_present = false;
  40729c:	12167800 	and	w0, w0, #0xfffffdff
  4072a0:	790143e0 	strh	w0, [sp, #160]
		conv->pad0_value = 0;
  4072a4:	f80a43ff 	stur	xzr, [sp, #164]
			= (enum specifier_cat_enum)conv->specifier_cat;
  4072a8:	f94053e1 	ldr	x1, [sp, #160]
		enum specifier_cat_enum specifier_cat
  4072ac:	53104820 	ubfx	w0, w1, #16, #3
			= (enum length_mod_enum)conv->length_mod;
  4072b0:	530b3821 	ubfx	w1, w1, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
  4072b4:	7100041f 	cmp	w0, #0x1
  4072b8:	54002721 	b.ne	40779c <z_cbvprintf_impl+0x620>  // b.any
			switch (length_mod) {
  4072bc:	51000c22 	sub	w2, w1, #0x3
  4072c0:	7100105f 	cmp	w2, #0x4
  4072c4:	54002048 	b.hi	4076cc <z_cbvprintf_impl+0x550>  // b.pmore
  4072c8:	90000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  4072cc:	911f4000 	add	x0, x0, #0x7d0
  4072d0:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
  4072d4:	10000062 	adr	x2, 4072e0 <z_cbvprintf_impl+0x164>
  4072d8:	8b20a840 	add	x0, x2, w0, sxth #2
  4072dc:	d61f0000 	br	x0
		switch (*sp) {
  4072e0:	7100b43f 	cmp	w1, #0x2d
  4072e4:	540000a0 	b.eq	4072f8 <z_cbvprintf_impl+0x17c>  // b.none
  4072e8:	7100c03f 	cmp	w1, #0x30
  4072ec:	540001e1 	b.ne	407328 <z_cbvprintf_impl+0x1ac>  // b.any
			conv->flag_zero = true;
  4072f0:	321a0000 	orr	w0, w0, #0x40
  4072f4:	14000002 	b	4072fc <z_cbvprintf_impl+0x180>
			conv->flag_dash = true;
  4072f8:	321e0000 	orr	w0, w0, #0x4
			++sp;
  4072fc:	91000694 	add	x20, x20, #0x1
			conv->flag_zero = true;
  407300:	790143e0 	strh	w0, [sp, #160]
		switch (*sp) {
  407304:	39400281 	ldrb	w1, [x20]
  407308:	794143e0 	ldrh	w0, [sp, #160]
  40730c:	7100ac3f 	cmp	w1, #0x2b
  407310:	54000b00 	b.eq	407470 <z_cbvprintf_impl+0x2f4>  // b.none
  407314:	54fffe68 	b.hi	4072e0 <z_cbvprintf_impl+0x164>  // b.pmore
  407318:	7100803f 	cmp	w1, #0x20
  40731c:	54000ae0 	b.eq	407478 <z_cbvprintf_impl+0x2fc>  // b.none
  407320:	71008c3f 	cmp	w1, #0x23
  407324:	54000ae0 	b.eq	407480 <z_cbvprintf_impl+0x304>  // b.none
	if (conv->flag_zero && conv->flag_dash) {
  407328:	b940a3e1 	ldr	w1, [sp, #160]
  40732c:	52800882 	mov	w2, #0x44                  	// #68
  407330:	0a020021 	and	w1, w1, w2
  407334:	6b02003f 	cmp	w1, w2
  407338:	54000061 	b.ne	407344 <z_cbvprintf_impl+0x1c8>  // b.any
		conv->flag_zero = false;
  40733c:	12197800 	and	w0, w0, #0xffffffbf
  407340:	790143e0 	strh	w0, [sp, #160]
	conv->width_present = true;
  407344:	794143e0 	ldrh	w0, [sp, #160]
  407348:	f90047f4 	str	x20, [sp, #136]
  40734c:	32190001 	orr	w1, w0, #0x80
  407350:	790143e1 	strh	w1, [sp, #160]
	if (*sp == '*') {
  407354:	39400281 	ldrb	w1, [x20]
  407358:	7100a83f 	cmp	w1, #0x2a
  40735c:	54000961 	b.ne	407488 <z_cbvprintf_impl+0x30c>  // b.any
		return ++sp;
  407360:	91000694 	add	x20, x20, #0x1
		conv->width_star = true;
  407364:	32190400 	orr	w0, w0, #0x180
  407368:	790143e0 	strh	w0, [sp, #160]
	sp = extract_prec(conv, sp);
  40736c:	f90047f4 	str	x20, [sp, #136]
	conv->prec_present = (*sp == '.');
  407370:	39400280 	ldrb	w0, [x20]
  407374:	7100b81f 	cmp	w0, #0x2e
  407378:	794143e0 	ldrh	w0, [sp, #160]
  40737c:	1a9f17e1 	cset	w1, eq  // eq = none
  407380:	33170020 	bfi	w0, w1, #9, #1
  407384:	790143e0 	strh	w0, [sp, #160]
	if (!conv->prec_present) {
  407388:	54000121 	b.ne	4073ac <z_cbvprintf_impl+0x230>  // b.any
	++sp;
  40738c:	91000681 	add	x1, x20, #0x1
  407390:	f90047e1 	str	x1, [sp, #136]
	if (*sp == '*') {
  407394:	39400681 	ldrb	w1, [x20, #1]
  407398:	7100a83f 	cmp	w1, #0x2a
  40739c:	54000961 	b.ne	4074c8 <z_cbvprintf_impl+0x34c>  // b.any
		return ++sp;
  4073a0:	91000a94 	add	x20, x20, #0x2
		conv->prec_star = true;
  4073a4:	32160000 	orr	w0, w0, #0x400
  4073a8:	790143e0 	strh	w0, [sp, #160]
	switch (*sp) {
  4073ac:	aa1403e1 	mov	x1, x20
  4073b0:	38401420 	ldrb	w0, [x1], #1
  4073b4:	7101b01f 	cmp	w0, #0x6c
  4073b8:	54000d00 	b.eq	407558 <z_cbvprintf_impl+0x3dc>  // b.none
  4073bc:	54000a68 	b.hi	407508 <z_cbvprintf_impl+0x38c>  // b.pmore
  4073c0:	7101a01f 	cmp	w0, #0x68
  4073c4:	54000b00 	b.eq	407524 <z_cbvprintf_impl+0x3a8>  // b.none
  4073c8:	7101a81f 	cmp	w0, #0x6a
  4073cc:	54000d60 	b.eq	407578 <z_cbvprintf_impl+0x3fc>  // b.none
  4073d0:	7101301f 	cmp	w0, #0x4c
  4073d4:	54000de0 	b.eq	407590 <z_cbvprintf_impl+0x414>  // b.none
  4073d8:	aa1403e1 	mov	x1, x20
	conv->specifier = *sp++;
  4073dc:	aa0103f4 	mov	x20, x1
  4073e0:	38401682 	ldrb	w2, [x20], #1
  4073e4:	39028fe2 	strb	w2, [sp, #163]
	switch (conv->specifier) {
  4073e8:	7101a45f 	cmp	w2, #0x69
  4073ec:	54001028 	b.hi	4075f0 <z_cbvprintf_impl+0x474>  // b.pmore
  4073f0:	7101005f 	cmp	w2, #0x40
  4073f4:	54001069 	b.ls	407600 <z_cbvprintf_impl+0x484>  // b.plast
  4073f8:	51010441 	sub	w1, w2, #0x41
  4073fc:	d2800020 	mov	x0, #0x1                   	// #1
  407400:	d2800e23 	mov	x3, #0x71                  	// #113
  407404:	9ac12001 	lsl	x1, x0, x1
  407408:	f2c00e23 	movk	x3, #0x71, lsl #32
  40740c:	ea03003f 	tst	x1, x3
  407410:	54001021 	b.ne	407614 <z_cbvprintf_impl+0x498>  // b.any
  407414:	d2c02103 	mov	x3, #0x10800000000         	// #1133871366144
  407418:	ea03003f 	tst	x1, x3
  40741c:	540000c1 	b.ne	407434 <z_cbvprintf_impl+0x2b8>  // b.any
  407420:	d2a01000 	mov	x0, #0x800000              	// #8388608
  407424:	f2c00080 	movk	x0, #0x4, lsl #32
  407428:	ea00003f 	tst	x1, x0
  40742c:	54000ea0 	b.eq	407600 <z_cbvprintf_impl+0x484>  // b.none
  407430:	52800040 	mov	w0, #0x2                   	// #2
		conv->specifier_cat = SPECIFIER_SINT;
  407434:	39428be1 	ldrb	w1, [sp, #162]
  407438:	33000801 	bfxil	w1, w0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
  40743c:	794143e0 	ldrh	w0, [sp, #160]
		conv->specifier_cat = SPECIFIER_SINT;
  407440:	39028be1 	strb	w1, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  407444:	12150c01 	and	w1, w0, #0x7800
  407448:	7140103f 	cmp	w1, #0x4, lsl #12
  40744c:	54000061 	b.ne	407458 <z_cbvprintf_impl+0x2dc>  // b.any
			conv->invalid = true;
  407450:	32000000 	orr	w0, w0, #0x1
  407454:	790143e0 	strh	w0, [sp, #160]
		if (conv->specifier == 'c') {
  407458:	71018c5f 	cmp	w2, #0x63
  40745c:	54000d81 	b.ne	40760c <z_cbvprintf_impl+0x490>  // b.any
		if (conv->length_mod != LENGTH_NONE) {
  407460:	794143e0 	ldrh	w0, [sp, #160]
  407464:	72150c1f 	tst	w0, #0x7800
  407468:	1a9f07e0 	cset	w0, ne  // ne = any
  40746c:	1400006e 	b	407624 <z_cbvprintf_impl+0x4a8>
			conv->flag_plus = true;
  407470:	321d0000 	orr	w0, w0, #0x8
  407474:	17ffffa2 	b	4072fc <z_cbvprintf_impl+0x180>
			conv->flag_space = true;
  407478:	321c0000 	orr	w0, w0, #0x10
  40747c:	17ffffa0 	b	4072fc <z_cbvprintf_impl+0x180>
			conv->flag_hash = true;
  407480:	321b0000 	orr	w0, w0, #0x20
  407484:	17ffff9e 	b	4072fc <z_cbvprintf_impl+0x180>
	size_t width = extract_decimal(&sp);
  407488:	910223e0 	add	x0, sp, #0x88
  40748c:	97fffee9 	bl	407030 <extract_decimal>
	if (sp != wp) {
  407490:	f94047e1 	ldr	x1, [sp, #136]
  407494:	eb14003f 	cmp	x1, x20
  407498:	54fff6a0 	b.eq	40736c <z_cbvprintf_impl+0x1f0>  // b.none
		conv->width_value = width;
  40749c:	b900a7e0 	str	w0, [sp, #164]
				      || (width != (size_t)conv->width_value));
  4074a0:	37f80100 	tbnz	w0, #31, 4074c0 <z_cbvprintf_impl+0x344>
  4074a4:	eb20c01f 	cmp	x0, w0, sxtw
  4074a8:	1a9f07e2 	cset	w2, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
  4074ac:	794143e0 	ldrh	w0, [sp, #160]
  4074b0:	aa0103f4 	mov	x20, x1
  4074b4:	331f0040 	bfi	w0, w2, #1, #1
  4074b8:	790143e0 	strh	w0, [sp, #160]
  4074bc:	17ffffac 	b	40736c <z_cbvprintf_impl+0x1f0>
				      || (width != (size_t)conv->width_value));
  4074c0:	52800022 	mov	w2, #0x1                   	// #1
  4074c4:	17fffffa 	b	4074ac <z_cbvprintf_impl+0x330>
	size_t prec = extract_decimal(&sp);
  4074c8:	910223e0 	add	x0, sp, #0x88
  4074cc:	97fffed9 	bl	407030 <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
  4074d0:	f94053e1 	ldr	x1, [sp, #160]
	conv->prec_value = prec;
  4074d4:	b900abe0 	str	w0, [sp, #168]
	conv->unsupported |= ((conv->prec_value < 0)
  4074d8:	53010421 	ubfx	w1, w1, #1, #1
			      || (prec != (size_t)conv->prec_value));
  4074dc:	37f80120 	tbnz	w0, #31, 407500 <z_cbvprintf_impl+0x384>
  4074e0:	eb20c01f 	cmp	x0, w0, sxtw
  4074e4:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
  4074e8:	2a000020 	orr	w0, w1, w0
  4074ec:	794143e1 	ldrh	w1, [sp, #160]
	return sp;
  4074f0:	f94047f4 	ldr	x20, [sp, #136]
	conv->unsupported |= ((conv->prec_value < 0)
  4074f4:	331f0001 	bfi	w1, w0, #1, #1
  4074f8:	790143e1 	strh	w1, [sp, #160]
	return sp;
  4074fc:	17ffffac 	b	4073ac <z_cbvprintf_impl+0x230>
			      || (prec != (size_t)conv->prec_value));
  407500:	52800020 	mov	w0, #0x1                   	// #1
  407504:	17fffff9 	b	4074e8 <z_cbvprintf_impl+0x36c>
	switch (*sp) {
  407508:	7101d01f 	cmp	w0, #0x74
  40750c:	540003c0 	b.eq	407584 <z_cbvprintf_impl+0x408>  // b.none
  407510:	7101e81f 	cmp	w0, #0x7a
  407514:	54fff621 	b.ne	4073d8 <z_cbvprintf_impl+0x25c>  // b.any
		conv->length_mod = LENGTH_Z;
  407518:	794143e0 	ldrh	w0, [sp, #160]
  40751c:	528000c2 	mov	w2, #0x6                   	// #6
  407520:	1400000b 	b	40754c <z_cbvprintf_impl+0x3d0>
		if (*++sp == 'h') {
  407524:	39400680 	ldrb	w0, [x20, #1]
  407528:	7101a01f 	cmp	w0, #0x68
  40752c:	794143e0 	ldrh	w0, [sp, #160]
  407530:	540000c1 	b.ne	407548 <z_cbvprintf_impl+0x3cc>  // b.any
			conv->length_mod = LENGTH_HH;
  407534:	52800021 	mov	w1, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
  407538:	33150c20 	bfi	w0, w1, #11, #4
			++sp;
  40753c:	91000a81 	add	x1, x20, #0x2
			conv->length_mod = LENGTH_LL;
  407540:	790143e0 	strh	w0, [sp, #160]
			++sp;
  407544:	17ffffa6 	b	4073dc <z_cbvprintf_impl+0x260>
			conv->length_mod = LENGTH_H;
  407548:	52800042 	mov	w2, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
  40754c:	33150c40 	bfi	w0, w2, #11, #4
		conv->unsupported = true;
  407550:	790143e0 	strh	w0, [sp, #160]
		break;
  407554:	17ffffa2 	b	4073dc <z_cbvprintf_impl+0x260>
		if (*++sp == 'l') {
  407558:	39400680 	ldrb	w0, [x20, #1]
  40755c:	7101b01f 	cmp	w0, #0x6c
  407560:	794143e0 	ldrh	w0, [sp, #160]
  407564:	54000061 	b.ne	407570 <z_cbvprintf_impl+0x3f4>  // b.any
			conv->length_mod = LENGTH_LL;
  407568:	52800081 	mov	w1, #0x4                   	// #4
  40756c:	17fffff3 	b	407538 <z_cbvprintf_impl+0x3bc>
			conv->length_mod = LENGTH_L;
  407570:	52800062 	mov	w2, #0x3                   	// #3
  407574:	17fffff6 	b	40754c <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_J;
  407578:	794143e0 	ldrh	w0, [sp, #160]
  40757c:	528000a2 	mov	w2, #0x5                   	// #5
  407580:	17fffff3 	b	40754c <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_T;
  407584:	794143e0 	ldrh	w0, [sp, #160]
  407588:	528000e2 	mov	w2, #0x7                   	// #7
  40758c:	17fffff0 	b	40754c <z_cbvprintf_impl+0x3d0>
		conv->unsupported = true;
  407590:	794143e0 	ldrh	w0, [sp, #160]
  407594:	128f0042 	mov	w2, #0xffff87fd            	// #-30723
  407598:	0a020000 	and	w0, w0, w2
  40759c:	52880042 	mov	w2, #0x4002                	// #16386
  4075a0:	2a020000 	orr	w0, w0, w2
  4075a4:	17ffffeb 	b	407550 <z_cbvprintf_impl+0x3d4>
  4075a8:	d2800020 	mov	x0, #0x1                   	// #1
  4075ac:	9ac12000 	lsl	x0, x0, x1
	switch (conv->specifier) {
  4075b0:	d2809041 	mov	x1, #0x482                 	// #1154
  4075b4:	ea01001f 	tst	x0, x1
  4075b8:	54fff3c1 	b.ne	407430 <z_cbvprintf_impl+0x2b4>  // b.any
  4075bc:	d2800481 	mov	x1, #0x24                  	// #36
  4075c0:	ea01001f 	tst	x0, x1
  4075c4:	540003e1 	b.ne	407640 <z_cbvprintf_impl+0x4c4>  // b.any
  4075c8:	360001c0 	tbz	w0, #0, 407600 <z_cbvprintf_impl+0x484>
		conv->specifier_cat = SPECIFIER_PTR;
  4075cc:	39428be0 	ldrb	w0, [sp, #162]
  4075d0:	52800061 	mov	w1, #0x3                   	// #3
  4075d4:	33000820 	bfxil	w0, w1, #0, #3
  4075d8:	39028be0 	strb	w0, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  4075dc:	794143e0 	ldrh	w0, [sp, #160]
  4075e0:	12150c00 	and	w0, w0, #0x7800
  4075e4:	7140101f 	cmp	w0, #0x4, lsl #12
  4075e8:	1a9f17e0 	cset	w0, eq  // eq = none
  4075ec:	1400000e 	b	407624 <z_cbvprintf_impl+0x4a8>
	switch (conv->specifier) {
  4075f0:	5101b841 	sub	w1, w2, #0x6e
  4075f4:	12001c21 	and	w1, w1, #0xff
  4075f8:	7100283f 	cmp	w1, #0xa
  4075fc:	54fffd69 	b.ls	4075a8 <z_cbvprintf_impl+0x42c>  // b.plast
		conv->invalid = true;
  407600:	794143e0 	ldrh	w0, [sp, #160]
  407604:	32000000 	orr	w0, w0, #0x1
  407608:	790143e0 	strh	w0, [sp, #160]
	bool unsupported = false;
  40760c:	52800000 	mov	w0, #0x0                   	// #0
  407610:	14000005 	b	407624 <z_cbvprintf_impl+0x4a8>
		conv->specifier_cat = SPECIFIER_FP;
  407614:	39428be1 	ldrb	w1, [sp, #162]
  407618:	52800082 	mov	w2, #0x4                   	// #4
  40761c:	33000841 	bfxil	w1, w2, #0, #3
  407620:	39028be1 	strb	w1, [sp, #162]
	conv->unsupported |= unsupported;
  407624:	f94053e1 	ldr	x1, [sp, #160]
  407628:	d3410421 	ubfx	x1, x1, #1, #1
  40762c:	2a010000 	orr	w0, w0, w1
  407630:	794143e1 	ldrh	w1, [sp, #160]
  407634:	331f0001 	bfi	w1, w0, #1, #1
  407638:	790143e1 	strh	w1, [sp, #160]
	return sp;
  40763c:	17ffff02 	b	407244 <z_cbvprintf_impl+0xc8>
		conv->specifier_cat = SPECIFIER_PTR;
  407640:	39428be0 	ldrb	w0, [sp, #162]
  407644:	52800061 	mov	w1, #0x3                   	// #3
  407648:	33000820 	bfxil	w0, w1, #0, #3
  40764c:	39028be0 	strb	w0, [sp, #162]
  407650:	17ffff84 	b	407460 <z_cbvprintf_impl+0x2e4>
			width = va_arg(ap, int);
  407654:	11002361 	add	w1, w27, #0x8
  407658:	7100003f 	cmp	w1, #0x0
  40765c:	540000cd 	b.le	407674 <z_cbvprintf_impl+0x4f8>
  407660:	91002f82 	add	x2, x28, #0xb
  407664:	aa1c03e0 	mov	x0, x28
  407668:	2a0103fb 	mov	w27, w1
  40766c:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  407670:	17fffefb 	b	40725c <z_cbvprintf_impl+0xe0>
  407674:	8b3bc300 	add	x0, x24, w27, sxtw
  407678:	2a0103fb 	mov	w27, w1
  40767c:	17fffef8 	b	40725c <z_cbvprintf_impl+0xe0>
			width = conv->width_value;
  407680:	b940a7f6 	ldr	w22, [sp, #164]
  407684:	f279001f 	tst	x0, #0x80
  407688:	5a9f12d6 	csinv	w22, w22, wzr, ne  // ne = any
  40768c:	17fffefa 	b	407274 <z_cbvprintf_impl+0xf8>
			int arg = va_arg(ap, int);
  407690:	11002361 	add	w1, w27, #0x8
  407694:	7100003f 	cmp	w1, #0x0
  407698:	540000cd 	b.le	4076b0 <z_cbvprintf_impl+0x534>
  40769c:	91002f82 	add	x2, x28, #0xb
  4076a0:	aa1c03e0 	mov	x0, x28
  4076a4:	2a0103fb 	mov	w27, w1
  4076a8:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  4076ac:	17fffef8 	b	40728c <z_cbvprintf_impl+0x110>
  4076b0:	8b3bc300 	add	x0, x24, w27, sxtw
  4076b4:	2a0103fb 	mov	w27, w1
  4076b8:	17fffef5 	b	40728c <z_cbvprintf_impl+0x110>
			precision = conv->prec_value;
  4076bc:	b940abf7 	ldr	w23, [sp, #168]
  4076c0:	f277001f 	tst	x0, #0x200
  4076c4:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
  4076c8:	17fffef7 	b	4072a4 <z_cbvprintf_impl+0x128>
				value->sint = va_arg(ap, int);
  4076cc:	37f8031b 	tbnz	w27, #31, 40772c <z_cbvprintf_impl+0x5b0>
  4076d0:	91002f82 	add	x2, x28, #0xb
  4076d4:	2a1b03e3 	mov	w3, w27
  4076d8:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4076dc:	b9800380 	ldrsw	x0, [x28]
  4076e0:	f9004be0 	str	x0, [sp, #144]
				break;
  4076e4:	2a0303fb 	mov	w27, w3
  4076e8:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  4076ec:	7100043f 	cmp	w1, #0x1
  4076f0:	540004e1 	b.ne	40778c <z_cbvprintf_impl+0x610>  // b.any
				value->sint = (signed char)value->sint;
  4076f4:	93401c00 	sxtb	x0, w0
				value->uint = (unsigned short)value->uint;
  4076f8:	f9004be0 	str	x0, [sp, #144]
		if (conv->invalid || conv->unsupported) {
  4076fc:	b940a3e0 	ldr	w0, [sp, #160]
  407700:	f240041f 	tst	x0, #0x3
  407704:	540015a0 	b.eq	4079b8 <z_cbvprintf_impl+0x83c>  // b.none
			OUTS(sp, fp);
  407708:	aa1403e3 	mov	x3, x20
  40770c:	aa1503e2 	mov	x2, x21
  407710:	aa1a03e1 	mov	x1, x26
  407714:	aa1903e0 	mov	x0, x25
  407718:	97fffe2a 	bl	406fc0 <outs>
  40771c:	37ffd660 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407720:	8b20c273 	add	x19, x19, w0, sxtw
			continue;
  407724:	aa1403f5 	mov	x21, x20
  407728:	17fffead 	b	4071dc <z_cbvprintf_impl+0x60>
				value->sint = va_arg(ap, int);
  40772c:	11002363 	add	w3, w27, #0x8
  407730:	7100007f 	cmp	w3, #0x0
  407734:	5400008d 	b.le	407744 <z_cbvprintf_impl+0x5c8>
  407738:	91002f82 	add	x2, x28, #0xb
  40773c:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407740:	17ffffe7 	b	4076dc <z_cbvprintf_impl+0x560>
  407744:	aa1c03e2 	mov	x2, x28
  407748:	8b3bc31c 	add	x28, x24, w27, sxtw
  40774c:	17ffffe4 	b	4076dc <z_cbvprintf_impl+0x560>
					(sint_value_type)va_arg(ap, ptrdiff_t);
  407750:	37f800db 	tbnz	w27, #31, 407768 <z_cbvprintf_impl+0x5ec>
  407754:	91003f82 	add	x2, x28, #0xf
  407758:	2a1b03e3 	mov	w3, w27
  40775c:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407760:	f9400380 	ldr	x0, [x28]
  407764:	17ffffdf 	b	4076e0 <z_cbvprintf_impl+0x564>
  407768:	11002363 	add	w3, w27, #0x8
  40776c:	7100007f 	cmp	w3, #0x0
  407770:	5400008d 	b.le	407780 <z_cbvprintf_impl+0x604>
  407774:	91003f82 	add	x2, x28, #0xf
  407778:	927df042 	and	x2, x2, #0xfffffffffffffff8
  40777c:	17fffff9 	b	407760 <z_cbvprintf_impl+0x5e4>
  407780:	aa1c03e2 	mov	x2, x28
  407784:	8b3bc31c 	add	x28, x24, w27, sxtw
  407788:	17fffff6 	b	407760 <z_cbvprintf_impl+0x5e4>
			} else if (length_mod == LENGTH_H) {
  40778c:	7100083f 	cmp	w1, #0x2
  407790:	54fffb61 	b.ne	4076fc <z_cbvprintf_impl+0x580>  // b.any
				value->sint = (short)value->sint;
  407794:	93403c00 	sxth	x0, w0
  407798:	17ffffd8 	b	4076f8 <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_UINT) {
  40779c:	7100081f 	cmp	w0, #0x2
  4077a0:	540008c1 	b.ne	4078b8 <z_cbvprintf_impl+0x73c>  // b.any
			switch (length_mod) {
  4077a4:	51000c22 	sub	w2, w1, #0x3
  4077a8:	7100105f 	cmp	w2, #0x4
  4077ac:	540000e8 	b.hi	4077c8 <z_cbvprintf_impl+0x64c>  // b.pmore
  4077b0:	90000060 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  4077b4:	911f7000 	add	x0, x0, #0x7dc
  4077b8:	38624800 	ldrb	w0, [x0, w2, uxtw]
  4077bc:	10000062 	adr	x2, 4077c8 <z_cbvprintf_impl+0x64c>
  4077c0:	8b208840 	add	x0, x2, w0, sxtb #2
  4077c4:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
  4077c8:	37f8019b 	tbnz	w27, #31, 4077f8 <z_cbvprintf_impl+0x67c>
  4077cc:	91002f82 	add	x2, x28, #0xb
  4077d0:	2a1b03e3 	mov	w3, w27
  4077d4:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4077d8:	b9400380 	ldr	w0, [x28]
  4077dc:	f9004be0 	str	x0, [sp, #144]
				break;
  4077e0:	2a0303fb 	mov	w27, w3
  4077e4:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  4077e8:	7100043f 	cmp	w1, #0x1
  4077ec:	540005e1 	b.ne	4078a8 <z_cbvprintf_impl+0x72c>  // b.any
				value->uint = (unsigned char)value->uint;
  4077f0:	92401c00 	and	x0, x0, #0xff
  4077f4:	17ffffc1 	b	4076f8 <z_cbvprintf_impl+0x57c>
				value->uint = va_arg(ap, unsigned int);
  4077f8:	11002363 	add	w3, w27, #0x8
  4077fc:	7100007f 	cmp	w3, #0x0
  407800:	5400008d 	b.le	407810 <z_cbvprintf_impl+0x694>
  407804:	91002f82 	add	x2, x28, #0xb
  407808:	927df042 	and	x2, x2, #0xfffffffffffffff8
  40780c:	17fffff3 	b	4077d8 <z_cbvprintf_impl+0x65c>
  407810:	aa1c03e2 	mov	x2, x28
  407814:	8b3bc31c 	add	x28, x24, w27, sxtw
  407818:	17fffff0 	b	4077d8 <z_cbvprintf_impl+0x65c>
				if ((!WCHAR_IS_SIGNED)
  40781c:	39428fe0 	ldrb	w0, [sp, #163]
  407820:	71018c1f 	cmp	w0, #0x63
  407824:	54000ac1 	b.ne	40797c <z_cbvprintf_impl+0x800>  // b.any
					value->uint = (wchar_t)va_arg(ap,
  407828:	37f8011b 	tbnz	w27, #31, 407848 <z_cbvprintf_impl+0x6cc>
  40782c:	91002f80 	add	x0, x28, #0xb
  407830:	2a1b03e2 	mov	w2, w27
  407834:	927df000 	and	x0, x0, #0xfffffffffffffff8
  407838:	b9400383 	ldr	w3, [x28]
			value->ptr = va_arg(ap, void *);
  40783c:	2a0203fb 	mov	w27, w2
  407840:	f9004be3 	str	x3, [sp, #144]
  407844:	1400003e 	b	40793c <z_cbvprintf_impl+0x7c0>
					value->uint = (wchar_t)va_arg(ap,
  407848:	11002362 	add	w2, w27, #0x8
  40784c:	7100005f 	cmp	w2, #0x0
  407850:	5400008d 	b.le	407860 <z_cbvprintf_impl+0x6e4>
  407854:	91002f80 	add	x0, x28, #0xb
  407858:	927df000 	and	x0, x0, #0xfffffffffffffff8
  40785c:	17fffff7 	b	407838 <z_cbvprintf_impl+0x6bc>
  407860:	aa1c03e0 	mov	x0, x28
  407864:	8b3bc31c 	add	x28, x24, w27, sxtw
  407868:	17fffff4 	b	407838 <z_cbvprintf_impl+0x6bc>
					(uint_value_type)va_arg(ap, size_t);
  40786c:	37f800db 	tbnz	w27, #31, 407884 <z_cbvprintf_impl+0x708>
  407870:	91003f82 	add	x2, x28, #0xf
  407874:	2a1b03e3 	mov	w3, w27
  407878:	927df042 	and	x2, x2, #0xfffffffffffffff8
  40787c:	f9400380 	ldr	x0, [x28]
  407880:	17ffffd7 	b	4077dc <z_cbvprintf_impl+0x660>
  407884:	11002363 	add	w3, w27, #0x8
  407888:	7100007f 	cmp	w3, #0x0
  40788c:	5400008d 	b.le	40789c <z_cbvprintf_impl+0x720>
  407890:	91003f82 	add	x2, x28, #0xf
  407894:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407898:	17fffff9 	b	40787c <z_cbvprintf_impl+0x700>
  40789c:	aa1c03e2 	mov	x2, x28
  4078a0:	8b3bc31c 	add	x28, x24, w27, sxtw
  4078a4:	17fffff6 	b	40787c <z_cbvprintf_impl+0x700>
			} else if (length_mod == LENGTH_H) {
  4078a8:	7100083f 	cmp	w1, #0x2
  4078ac:	54fff281 	b.ne	4076fc <z_cbvprintf_impl+0x580>  // b.any
				value->uint = (unsigned short)value->uint;
  4078b0:	92403c00 	and	x0, x0, #0xffff
  4078b4:	17ffff91 	b	4076f8 <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_FP) {
  4078b8:	7100101f 	cmp	w0, #0x4
  4078bc:	540005c1 	b.ne	407974 <z_cbvprintf_impl+0x7f8>  // b.any
				value->ldbl = va_arg(ap, long double);
  4078c0:	b94067e0 	ldr	w0, [sp, #100]
			if (length_mod == LENGTH_UPPER_L) {
  4078c4:	7100203f 	cmp	w1, #0x8
  4078c8:	540002c1 	b.ne	407920 <z_cbvprintf_impl+0x7a4>  // b.any
				value->ldbl = va_arg(ap, long double);
  4078cc:	37f80120 	tbnz	w0, #31, 4078f0 <z_cbvprintf_impl+0x774>
  4078d0:	91003f80 	add	x0, x28, #0xf
  4078d4:	b94067e2 	ldr	w2, [sp, #100]
  4078d8:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  4078dc:	9100401c 	add	x28, x0, #0x10
  4078e0:	3dc00000 	ldr	q0, [x0]
  4078e4:	b90067e2 	str	w2, [sp, #100]
  4078e8:	3d8027e0 	str	q0, [sp, #144]
  4078ec:	17ffff84 	b	4076fc <z_cbvprintf_impl+0x580>
  4078f0:	b94067e0 	ldr	w0, [sp, #100]
  4078f4:	11004002 	add	w2, w0, #0x10
  4078f8:	7100005f 	cmp	w2, #0x0
  4078fc:	540000ad 	b.le	407910 <z_cbvprintf_impl+0x794>
  407900:	91003f80 	add	x0, x28, #0xf
  407904:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  407908:	9100401c 	add	x28, x0, #0x10
  40790c:	17fffff5 	b	4078e0 <z_cbvprintf_impl+0x764>
  407910:	f9403be3 	ldr	x3, [sp, #112]
  407914:	b94067e0 	ldr	w0, [sp, #100]
  407918:	8b20c060 	add	x0, x3, w0, sxtw
  40791c:	17fffff1 	b	4078e0 <z_cbvprintf_impl+0x764>
				value->dbl = va_arg(ap, double);
  407920:	37f80120 	tbnz	w0, #31, 407944 <z_cbvprintf_impl+0x7c8>
  407924:	91003f80 	add	x0, x28, #0xf
  407928:	b94067e2 	ldr	w2, [sp, #100]
  40792c:	927df000 	and	x0, x0, #0xfffffffffffffff8
  407930:	fd400380 	ldr	d0, [x28]
  407934:	b90067e2 	str	w2, [sp, #100]
  407938:	fd004be0 	str	d0, [sp, #144]
			value->ptr = va_arg(ap, void *);
  40793c:	aa0003fc 	mov	x28, x0
  407940:	17ffff6f 	b	4076fc <z_cbvprintf_impl+0x580>
				value->dbl = va_arg(ap, double);
  407944:	b94067e0 	ldr	w0, [sp, #100]
  407948:	11004002 	add	w2, w0, #0x10
  40794c:	7100005f 	cmp	w2, #0x0
  407950:	5400008d 	b.le	407960 <z_cbvprintf_impl+0x7e4>
  407954:	91003f80 	add	x0, x28, #0xf
  407958:	927df000 	and	x0, x0, #0xfffffffffffffff8
  40795c:	17fffff5 	b	407930 <z_cbvprintf_impl+0x7b4>
  407960:	f9403be4 	ldr	x4, [sp, #112]
  407964:	aa1c03e0 	mov	x0, x28
  407968:	b94067e3 	ldr	w3, [sp, #100]
  40796c:	8b23c09c 	add	x28, x4, w3, sxtw
  407970:	17fffff0 	b	407930 <z_cbvprintf_impl+0x7b4>
		} else if (specifier_cat == SPECIFIER_PTR) {
  407974:	71000c1f 	cmp	w0, #0x3
  407978:	54ffec21 	b.ne	4076fc <z_cbvprintf_impl+0x580>  // b.any
			value->ptr = va_arg(ap, void *);
  40797c:	37f800db 	tbnz	w27, #31, 407994 <z_cbvprintf_impl+0x818>
  407980:	91003f80 	add	x0, x28, #0xf
  407984:	2a1b03e2 	mov	w2, w27
  407988:	927df000 	and	x0, x0, #0xfffffffffffffff8
  40798c:	f9400383 	ldr	x3, [x28]
  407990:	17ffffab 	b	40783c <z_cbvprintf_impl+0x6c0>
  407994:	11002362 	add	w2, w27, #0x8
  407998:	7100005f 	cmp	w2, #0x0
  40799c:	5400008d 	b.le	4079ac <z_cbvprintf_impl+0x830>
  4079a0:	91003f80 	add	x0, x28, #0xf
  4079a4:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4079a8:	17fffff9 	b	40798c <z_cbvprintf_impl+0x810>
  4079ac:	aa1c03e0 	mov	x0, x28
  4079b0:	8b3bc31c 	add	x28, x24, w27, sxtw
  4079b4:	17fffff6 	b	40798c <z_cbvprintf_impl+0x810>
		switch (conv->specifier) {
  4079b8:	39428fe0 	ldrb	w0, [sp, #163]
  4079bc:	7101e01f 	cmp	w0, #0x78
  4079c0:	54ffeb28 	b.hi	407724 <z_cbvprintf_impl+0x5a8>  // b.pmore
  4079c4:	7101881f 	cmp	w0, #0x62
  4079c8:	540000e8 	b.hi	4079e4 <z_cbvprintf_impl+0x868>  // b.pmore
  4079cc:	7100941f 	cmp	w0, #0x25
  4079d0:	54ffc220 	b.eq	407214 <z_cbvprintf_impl+0x98>  // b.none
  4079d4:	7101601f 	cmp	w0, #0x58
  4079d8:	54ffea61 	b.ne	407724 <z_cbvprintf_impl+0x5a8>  // b.any
  4079dc:	52800006 	mov	w6, #0x0                   	// #0
  4079e0:	14000043 	b	407aec <z_cbvprintf_impl+0x970>
  4079e4:	51018c00 	sub	w0, w0, #0x63
  4079e8:	7100541f 	cmp	w0, #0x15
  4079ec:	54ffe9c8 	b.hi	407724 <z_cbvprintf_impl+0x5a8>  // b.pmore
  4079f0:	90000062 	adrp	x2, 413000 <sys_clock_announce+0x19c>
  4079f4:	911f9042 	add	x2, x2, #0x7e4
  4079f8:	78605842 	ldrh	w2, [x2, w0, uxtw #1]
  4079fc:	10000060 	adr	x0, 407a08 <z_cbvprintf_impl+0x88c>
  407a00:	8b22a802 	add	x2, x0, w2, sxth #2
  407a04:	d61f0040 	br	x2
			bps = (const char *)value->ptr;
  407a08:	f9404bf5 	ldr	x21, [sp, #144]
			if (precision >= 0) {
  407a0c:	37f80497 	tbnz	w23, #31, 407a9c <z_cbvprintf_impl+0x920>
				len = strnlen(bps, precision);
  407a10:	93407ee1 	sxtw	x1, w23
  407a14:	aa1503e0 	mov	x0, x21
  407a18:	97ffe5f2 	bl	4011e0 <strnlen@plt>
			bpe = bps + len;
  407a1c:	8b0002b7 	add	x23, x21, x0
		char sign = 0;
  407a20:	52800006 	mov	w6, #0x0                   	// #0
		if (bps == NULL) {
  407a24:	b4ffe815 	cbz	x21, 407724 <z_cbvprintf_impl+0x5a8>
		size_t nj_len = (bpe - bps);
  407a28:	cb1502e0 	sub	x0, x23, x21
		if (sign != 0) {
  407a2c:	34000046 	cbz	w6, 407a34 <z_cbvprintf_impl+0x8b8>
			nj_len += 1U;
  407a30:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
  407a34:	39428be2 	ldrb	w2, [sp, #162]
  407a38:	36200ce2 	tbz	w2, #4, 407bd4 <z_cbvprintf_impl+0xa58>
			nj_len += 2U;
  407a3c:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
  407a40:	b980a7e1 	ldrsw	x1, [sp, #164]
  407a44:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
  407a48:	36300062 	tbz	w2, #6, 407a54 <z_cbvprintf_impl+0x8d8>
			nj_len += conv->pad0_pre_exp;
  407a4c:	b980abe1 	ldrsw	x1, [sp, #168]
  407a50:	8b010000 	add	x0, x0, x1
		if (width > 0) {
  407a54:	710002df 	cmp	w22, #0x0
  407a58:	54000dad 	b.le	407c0c <z_cbvprintf_impl+0xa90>
			width -= (int)nj_len;
  407a5c:	4b0002d6 	sub	w22, w22, w0
			if (!conv->flag_dash) {
  407a60:	f94053e0 	ldr	x0, [sp, #160]
  407a64:	721e001f 	tst	w0, #0x4
  407a68:	54000d21 	b.ne	407c0c <z_cbvprintf_impl+0xa90>  // b.any
				if (conv->flag_zero) {
  407a6c:	794143e0 	ldrh	w0, [sp, #160]
  407a70:	36301280 	tbz	w0, #6, 407cc0 <z_cbvprintf_impl+0xb44>
					if (sign != 0) {
  407a74:	340012a6 	cbz	w6, 407cc8 <z_cbvprintf_impl+0xb4c>
						OUTC(sign);
  407a78:	aa1a03e1 	mov	x1, x26
  407a7c:	2a0603e0 	mov	w0, w6
  407a80:	d63f0320 	blr	x25
  407a84:	37ffbb20 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407a88:	91000673 	add	x19, x19, #0x1
					pad = '0';
  407a8c:	52800602 	mov	w2, #0x30                  	// #48
						OUTC(sign);
  407a90:	52800006 	mov	w6, #0x0                   	// #0
					pad = '0';
  407a94:	2a1603e0 	mov	w0, w22
  407a98:	1400005a 	b	407c00 <z_cbvprintf_impl+0xa84>
				len = strlen(bps);
  407a9c:	aa1503e0 	mov	x0, x21
  407aa0:	97ffe5c0 	bl	4011a0 <strlen@plt>
  407aa4:	17ffffde 	b	407a1c <z_cbvprintf_impl+0x8a0>
			bps = buf;
  407aa8:	9102c3f5 	add	x21, sp, #0xb0
			bpe = buf + 1;
  407aac:	9102c7f7 	add	x23, sp, #0xb1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  407ab0:	f9404be0 	ldr	x0, [sp, #144]
  407ab4:	3902c3e0 	strb	w0, [sp, #176]
			break;
  407ab8:	52800006 	mov	w6, #0x0                   	// #0
  407abc:	17ffffdb 	b	407a28 <z_cbvprintf_impl+0x8ac>
			if (conv->flag_plus) {
  407ac0:	794143e0 	ldrh	w0, [sp, #160]
			} else if (conv->flag_space) {
  407ac4:	d3441006 	ubfx	x6, x0, #4, #1
  407ac8:	f27d001f 	tst	x0, #0x8
  407acc:	52800560 	mov	w0, #0x2b                  	// #43
  407ad0:	531b68c6 	lsl	w6, w6, #5
  407ad4:	1a8000c6 	csel	w6, w6, w0, eq  // eq = none
			sint = value->sint;
  407ad8:	f9404be0 	ldr	x0, [sp, #144]
			if (sint < 0) {
  407adc:	b6f80080 	tbz	x0, #63, 407aec <z_cbvprintf_impl+0x970>
				value->uint = (uint_value_type)-sint;
  407ae0:	cb0003e0 	neg	x0, x0
				sign = '-';
  407ae4:	528005a6 	mov	w6, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
  407ae8:	f9004be0 	str	x0, [sp, #144]
			bps = encode_uint(value->uint, conv, buf, bpe);
  407aec:	f94037e3 	ldr	x3, [sp, #104]
  407af0:	9102c3e2 	add	x2, sp, #0xb0
  407af4:	f9404be0 	ldr	x0, [sp, #144]
  407af8:	910283e1 	add	x1, sp, #0xa0
  407afc:	b9007be6 	str	w6, [sp, #120]
  407b00:	97fffd60 	bl	407080 <encode_uint>
  407b04:	aa0003f5 	mov	x21, x0
  407b08:	b9407be6 	ldr	w6, [sp, #120]
			if (precision >= 0) {
  407b0c:	37f80157 	tbnz	w23, #31, 407b34 <z_cbvprintf_impl+0x9b8>
				size_t len = bpe - bps;
  407b10:	f94037e0 	ldr	x0, [sp, #104]
				conv->flag_zero = false;
  407b14:	794143e1 	ldrh	w1, [sp, #160]
				size_t len = bpe - bps;
  407b18:	cb150000 	sub	x0, x0, x21
				conv->flag_zero = false;
  407b1c:	12197821 	and	w1, w1, #0xffffffbf
  407b20:	790143e1 	strh	w1, [sp, #160]
				if (len < (size_t)precision) {
  407b24:	eb37c01f 	cmp	x0, w23, sxtw
  407b28:	54000062 	b.cs	407b34 <z_cbvprintf_impl+0x9b8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
  407b2c:	4b0002e0 	sub	w0, w23, w0
  407b30:	b900a7e0 	str	w0, [sp, #164]
		const char *bpe = buf + sizeof(buf);
  407b34:	f94037f7 	ldr	x23, [sp, #104]
  407b38:	17ffffbb 	b	407a24 <z_cbvprintf_impl+0x8a8>
			if (value->ptr != NULL) {
  407b3c:	f9404be0 	ldr	x0, [sp, #144]
  407b40:	b4000400 	cbz	x0, 407bc0 <z_cbvprintf_impl+0xa44>
				bps = encode_uint((uintptr_t)value->ptr, conv,
  407b44:	f94037e3 	ldr	x3, [sp, #104]
  407b48:	910283e1 	add	x1, sp, #0xa0
  407b4c:	9102c3e2 	add	x2, sp, #0xb0
  407b50:	97fffd4c 	bl	407080 <encode_uint>
  407b54:	aa0003f5 	mov	x21, x0
				conv->altform_0c = true;
  407b58:	794147e0 	ldrh	w0, [sp, #162]
  407b5c:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
  407b60:	52800006 	mov	w6, #0x0                   	// #0
				conv->altform_0c = true;
  407b64:	0a010000 	and	w0, w0, w1
  407b68:	528f0201 	mov	w1, #0x7810                	// #30736
  407b6c:	2a010000 	orr	w0, w0, w1
  407b70:	790147e0 	strh	w0, [sp, #162]
				goto prec_int_pad0;
  407b74:	17ffffe6 	b	407b0c <z_cbvprintf_impl+0x990>
				store_count(conv, value->ptr, count);
  407b78:	93407e60 	sxtw	x0, w19
  407b7c:	f9404be2 	ldr	x2, [sp, #144]
	switch ((enum length_mod_enum)conv->length_mod) {
  407b80:	71001c3f 	cmp	w1, #0x7
  407b84:	54ffdd08 	b.hi	407724 <z_cbvprintf_impl+0x5a8>  // b.pmore
  407b88:	90000063 	adrp	x3, 413000 <sys_clock_announce+0x19c>
  407b8c:	91204063 	add	x3, x3, #0x810
  407b90:	38614863 	ldrb	w3, [x3, w1, uxtw]
  407b94:	10000061 	adr	x1, 407ba0 <z_cbvprintf_impl+0xa24>
  407b98:	8b238823 	add	x3, x1, w3, sxtb #2
  407b9c:	d61f0060 	br	x3
		*(int *)dp = count;
  407ba0:	b9000040 	str	w0, [x2]
		break;
  407ba4:	17fffee0 	b	407724 <z_cbvprintf_impl+0x5a8>
		*(signed char *)dp = (signed char)count;
  407ba8:	39000053 	strb	w19, [x2]
		break;
  407bac:	17fffede 	b	407724 <z_cbvprintf_impl+0x5a8>
		*(short *)dp = (short)count;
  407bb0:	79000053 	strh	w19, [x2]
		break;
  407bb4:	17fffedc 	b	407724 <z_cbvprintf_impl+0x5a8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
  407bb8:	f9000040 	str	x0, [x2]
		break;
  407bbc:	17fffeda 	b	407724 <z_cbvprintf_impl+0x5a8>
			bps = "(nil)";
  407bc0:	b0000075 	adrp	x21, 414000 <dlc_table.0+0x60d>
			bpe = bps + 5;
  407bc4:	b0000077 	adrp	x23, 414000 <dlc_table.0+0x60d>
			bps = "(nil)";
  407bc8:	912e92b5 	add	x21, x21, #0xba4
			bpe = bps + 5;
  407bcc:	912ea6f7 	add	x23, x23, #0xba9
  407bd0:	17ffffba 	b	407ab8 <z_cbvprintf_impl+0x93c>
		} else if (conv->altform_0) {
  407bd4:	361ff362 	tbz	w2, #3, 407a40 <z_cbvprintf_impl+0x8c4>
			nj_len += 1U;
  407bd8:	91000400 	add	x0, x0, #0x1
  407bdc:	17ffff99 	b	407a40 <z_cbvprintf_impl+0x8c4>
  407be0:	290f1be2 	stp	w2, w6, [sp, #120]
					OUTC(pad);
  407be4:	aa1a03e1 	mov	x1, x26
  407be8:	2a0203e0 	mov	w0, w2
  407bec:	d63f0320 	blr	x25
  407bf0:	37ffafc0 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407bf4:	294f1be2 	ldp	w2, w6, [sp, #120]
  407bf8:	91000673 	add	x19, x19, #0x1
				while (width-- > 0) {
  407bfc:	2a1603e0 	mov	w0, w22
  407c00:	510006d6 	sub	w22, w22, #0x1
  407c04:	7100001f 	cmp	w0, #0x0
  407c08:	54fffecc 	b.gt	407be0 <z_cbvprintf_impl+0xa64>
		if (sign != 0) {
  407c0c:	340000c6 	cbz	w6, 407c24 <z_cbvprintf_impl+0xaa8>
			OUTC(sign);
  407c10:	aa1a03e1 	mov	x1, x26
  407c14:	2a0603e0 	mov	w0, w6
  407c18:	d63f0320 	blr	x25
  407c1c:	37ffae60 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407c20:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c | conv->altform_0) {
  407c24:	f94053e0 	ldr	x0, [sp, #160]
  407c28:	d3545001 	ubfx	x1, x0, #20, #1
  407c2c:	d3534c00 	ubfx	x0, x0, #19, #1
  407c30:	2a000020 	orr	w0, w1, w0
  407c34:	360000c0 	tbz	w0, #0, 407c4c <z_cbvprintf_impl+0xad0>
				OUTC('0');
  407c38:	aa1a03e1 	mov	x1, x26
  407c3c:	52800600 	mov	w0, #0x30                  	// #48
  407c40:	d63f0320 	blr	x25
  407c44:	37ffad20 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407c48:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c) {
  407c4c:	39428be0 	ldrb	w0, [sp, #162]
  407c50:	362000c0 	tbz	w0, #4, 407c68 <z_cbvprintf_impl+0xaec>
				OUTC(conv->specifier);
  407c54:	39428fe0 	ldrb	w0, [sp, #163]
  407c58:	aa1a03e1 	mov	x1, x26
  407c5c:	d63f0320 	blr	x25
  407c60:	37ffac40 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407c64:	91000673 	add	x19, x19, #0x1
			while (pad_len-- > 0) {
  407c68:	b940a7e2 	ldr	w2, [sp, #164]
  407c6c:	0b130042 	add	w2, w2, w19
  407c70:	4b130040 	sub	w0, w2, w19
  407c74:	7100001f 	cmp	w0, #0x0
  407c78:	540002cc 	b.gt	407cd0 <z_cbvprintf_impl+0xb54>
			OUTS(bps, bpe);
  407c7c:	aa1703e3 	mov	x3, x23
  407c80:	aa1503e2 	mov	x2, x21
  407c84:	aa1a03e1 	mov	x1, x26
  407c88:	aa1903e0 	mov	x0, x25
  407c8c:	97fffccd 	bl	406fc0 <outs>
  407c90:	37ffaac0 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407c94:	8b20c273 	add	x19, x19, w0, sxtw
		while (width > 0) {
  407c98:	0b1302d6 	add	w22, w22, w19
  407c9c:	4b1302c0 	sub	w0, w22, w19
  407ca0:	7100001f 	cmp	w0, #0x0
  407ca4:	54ffd40d 	b.le	407724 <z_cbvprintf_impl+0x5a8>
			OUTC(' ');
  407ca8:	aa1a03e1 	mov	x1, x26
  407cac:	52800400 	mov	w0, #0x20                  	// #32
  407cb0:	d63f0320 	blr	x25
  407cb4:	37ffa9a0 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407cb8:	91000673 	add	x19, x19, #0x1
			--width;
  407cbc:	17fffff8 	b	407c9c <z_cbvprintf_impl+0xb20>
				char pad = ' ';
  407cc0:	52800402 	mov	w2, #0x20                  	// #32
  407cc4:	17ffff74 	b	407a94 <z_cbvprintf_impl+0x918>
					pad = '0';
  407cc8:	52800602 	mov	w2, #0x30                  	// #48
  407ccc:	17ffff72 	b	407a94 <z_cbvprintf_impl+0x918>
  407cd0:	b9007be2 	str	w2, [sp, #120]
				OUTC('0');
  407cd4:	aa1a03e1 	mov	x1, x26
  407cd8:	52800600 	mov	w0, #0x30                  	// #48
  407cdc:	d63f0320 	blr	x25
  407ce0:	37ffa840 	tbnz	w0, #31, 4071e8 <z_cbvprintf_impl+0x6c>
  407ce4:	b9407be2 	ldr	w2, [sp, #120]
  407ce8:	91000673 	add	x19, x19, #0x1
  407cec:	17ffffe1 	b	407c70 <z_cbvprintf_impl+0xaf4>
}
  407cf0:	a94153f3 	ldp	x19, x20, [sp, #16]
  407cf4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407cf8:	a94363f7 	ldp	x23, x24, [sp, #48]
  407cfc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  407d00:	a94573fb 	ldp	x27, x28, [sp, #80]
  407d04:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  407d08:	d65f03c0 	ret

0000000000407d0c <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
  407d0c:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  407d10:	910003fd 	mov	x29, sp
  407d14:	a90e8be1 	stp	x1, x2, [sp, #232]
  407d18:	90000121 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  407d1c:	f9476821 	ldr	x1, [x1, #3792]
  407d20:	3d801be0 	str	q0, [sp, #96]
  407d24:	3d801fe1 	str	q1, [sp, #112]
  407d28:	3d8023e2 	str	q2, [sp, #128]
  407d2c:	3d8027e3 	str	q3, [sp, #144]
  407d30:	3d802be4 	str	q4, [sp, #160]
  407d34:	3d802fe5 	str	q5, [sp, #176]
  407d38:	3d8033e6 	str	q6, [sp, #192]
  407d3c:	3d8037e7 	str	q7, [sp, #208]
  407d40:	a90f93e3 	stp	x3, x4, [sp, #248]
  407d44:	a9109be5 	stp	x5, x6, [sp, #264]
  407d48:	f9008fe7 	str	x7, [sp, #280]
  407d4c:	f9400022 	ldr	x2, [x1]
  407d50:	f9002fe2 	str	x2, [sp, #88]
  407d54:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  407d58:	910483e1 	add	x1, sp, #0x120
  407d5c:	a90387e1 	stp	x1, x1, [sp, #56]
  407d60:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  407d64:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  407d68:	f90027e1 	str	x1, [sp, #72]
  407d6c:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  407d70:	b90053e1 	str	w1, [sp, #80]
  407d74:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  407d78:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  407d7c:	910043e1 	add	x1, sp, #0x10
  407d80:	ad400440 	ldp	q0, q1, [x2]
  407d84:	ad000420 	stp	q0, q1, [x1]
  407d88:	97fffa1b 	bl	4065f4 <vprintk>

	va_end(ap);
}
  407d8c:	90000120 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  407d90:	f9476800 	ldr	x0, [x0, #3792]
  407d94:	f9402fe2 	ldr	x2, [sp, #88]
  407d98:	f9400001 	ldr	x1, [x0]
  407d9c:	eb010042 	subs	x2, x2, x1
  407da0:	d2800001 	mov	x1, #0x0                   	// #0
  407da4:	54000040 	b.eq	407dac <assert_print+0xa0>  // b.none
  407da8:	97ffe55e 	bl	401320 <__stack_chk_fail@plt>
  407dac:	a8d27bfd 	ldp	x29, x30, [sp], #288
  407db0:	d65f03c0 	ret

0000000000407db4 <assert_post_action>:
{
  407db4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	k_panic();
  407db8:	52800562 	mov	w2, #0x2b                  	// #43
  407dbc:	b0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
{
  407dc0:	910003fd 	mov	x29, sp
	k_panic();
  407dc4:	912ea821 	add	x1, x1, #0xbaa
  407dc8:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  407dcc:	91244800 	add	x0, x0, #0x912
  407dd0:	97ffffcf 	bl	407d0c <assert_print>
}
  407dd4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	k_panic();
  407dd8:	d2800001 	mov	x1, #0x0                   	// #0
  407ddc:	52800080 	mov	w0, #0x4                   	// #4
  407de0:	14001687 	b	40d7fc <z_fatal_error>

0000000000407de4 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_EXPERIMENTAL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  407de4:	d65f03c0 	ret

0000000000407de8 <dummy_timestamp>:
static void msg_process(union log_msg_generic *msg);

static log_timestamp_t dummy_timestamp(void)
{
	return 0;
}
  407de8:	52800000 	mov	w0, #0x0                   	// #0
  407dec:	d65f03c0 	ret

0000000000407df0 <default_get_timestamp>:

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
  407df0:	140015fe 	b	40d5e8 <sys_clock_cycle_get_32>

0000000000407df4 <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  407df4:	f9400400 	ldr	x0, [x0, #8]
}
  407df8:	39402400 	ldrb	w0, [x0, #9]
  407dfc:	d65f03c0 	ret

0000000000407e00 <log_backend_is_ready>:
	if (backend->api->is_ready != NULL) {
  407e00:	f9400001 	ldr	x1, [x0]
  407e04:	f9401021 	ldr	x1, [x1, #32]
  407e08:	b4000061 	cbz	x1, 407e14 <log_backend_is_ready+0x14>
		return backend->api->is_ready(backend);
  407e0c:	aa0103f0 	mov	x16, x1
  407e10:	d61f0200 	br	x16
}
  407e14:	52800000 	mov	w0, #0x0                   	// #0
  407e18:	d65f03c0 	ret

0000000000407e1c <z_log_init.isra.0>:
	}

	return mask;
}

static uint32_t z_log_init(bool blocking, bool can_sleep)
  407e1c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  407e20:	910003fd 	mov	x29, sp
  407e24:	a9025bf5 	stp	x21, x22, [sp, #32]
	STRUCT_SECTION_COUNT(log_backend, &cnt);
  407e28:	90000136 	adrp	x22, 42b000 <__FRAME_END__+0xfd74>
  407e2c:	90000135 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
  407e30:	f947fed6 	ldr	x22, [x22, #4088]
  407e34:	a90153f3 	stp	x19, x20, [sp, #16]
  407e38:	f947aeb3 	ldr	x19, [x21, #3928]
  407e3c:	a9046bf9 	stp	x25, x26, [sp, #64]
  407e40:	12001c19 	and	w25, w0, #0xff
  407e44:	cb1302c0 	sub	x0, x22, x19
  407e48:	a90363f7 	stp	x23, x24, [sp, #48]
  407e4c:	d345fc00 	lsr	x0, x0, #5

	if (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY)) {
		return 0;
	}

	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
  407e50:	7100241f 	cmp	w0, #0x9
  407e54:	54000249 	b.ls	407e9c <z_log_init.isra.0+0x80>  // b.plast
  407e58:	b0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  407e5c:	912f3673 	add	x19, x19, #0xbcd
  407e60:	aa1303e2 	mov	x2, x19
  407e64:	52802323 	mov	w3, #0x119                 	// #281
  407e68:	b0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  407e6c:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  407e70:	912fe821 	add	x1, x1, #0xbfa
  407e74:	9123f800 	add	x0, x0, #0x8fe
  407e78:	97ffffa5 	bl	407d0c <assert_print>
  407e7c:	aa1303e0 	mov	x0, x19
  407e80:	52802321 	mov	w1, #0x119                 	// #281
  407e84:	97ffffcc 	bl	407db4 <assert_post_action>
  407e88:	52802322 	mov	w2, #0x119                 	// #281
		z_log_links_initiate();
	}


	/* Assign ids to backends. */
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407e8c:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  407e90:	aa1303e1 	mov	x1, x19
  407e94:	9124f000 	add	x0, x0, #0x93c
  407e98:	940009b9 	bl	40a57c <posix_print_error_and_exit>
  407e9c:	12001c37 	and	w23, w1, #0xff
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  407ea0:	d2800020 	mov	x0, #0x1                   	// #1
  407ea4:	b0000121 	adrp	x1, 42c000 <__dso_handle>
  407ea8:	912da021 	add	x1, x1, #0xb68
  407eac:	97ffe5d9 	bl	401610 <__aarch64_ldadd8_acq_rel>
	if (atomic_inc(&initialized) != 0) {
  407eb0:	b40005c0 	cbz	x0, 407f68 <z_log_init.isra.0+0x14c>
			}
		}
	}

	return mask;
}
  407eb4:	a94153f3 	ldp	x19, x20, [sp, #16]
  407eb8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407ebc:	a94363f7 	ldp	x23, x24, [sp, #48]
  407ec0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  407ec4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  407ec8:	d65f03c0 	ret
		if (backend->autostart) {
  407ecc:	39406260 	ldrb	w0, [x19, #24]
  407ed0:	340001e0 	cbz	w0, 407f0c <z_log_init.isra.0+0xf0>
	if (backend->api->init) {
  407ed4:	f9400260 	ldr	x0, [x19]
  407ed8:	f9400c01 	ldr	x1, [x0, #24]
  407edc:	b4000061 	cbz	x1, 407ee8 <z_log_init.isra.0+0xcc>
		backend->api->init(backend);
  407ee0:	aa1303e0 	mov	x0, x19
  407ee4:	d63f0020 	blr	x1
			if (log_backend_is_ready(backend) == 0) {
  407ee8:	aa1303e0 	mov	x0, x19
  407eec:	97ffffc5 	bl	407e00 <log_backend_is_ready>
  407ef0:	35000360 	cbnz	w0, 407f5c <z_log_init.isra.0+0x140>
				log_backend_enable(backend,
  407ef4:	f9400660 	ldr	x0, [x19, #8]
  407ef8:	52800082 	mov	w2, #0x4                   	// #4
  407efc:	f9400001 	ldr	x1, [x0]
  407f00:	aa1303e0 	mov	x0, x19
  407f04:	94000125 	bl	408398 <log_backend_enable>
			i++;
  407f08:	11000718 	add	w24, w24, #0x1
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407f0c:	91008273 	add	x19, x19, #0x20
  407f10:	eb16027f 	cmp	x19, x22
  407f14:	54000329 	b.ls	407f78 <z_log_init.isra.0+0x15c>  // b.plast
  407f18:	b0000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  407f1c:	912f3673 	add	x19, x19, #0xbcd
  407f20:	aa1303e2 	mov	x2, x19
  407f24:	b0000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  407f28:	91307821 	add	x1, x1, #0xc1e
  407f2c:	528024c3 	mov	w3, #0x126                 	// #294
  407f30:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  407f34:	9123f800 	add	x0, x0, #0x8fe
  407f38:	97ffff75 	bl	407d0c <assert_print>
  407f3c:	b0000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  407f40:	9130fc00 	add	x0, x0, #0xc3f
  407f44:	97ffff72 	bl	407d0c <assert_print>
  407f48:	aa1303e0 	mov	x0, x19
  407f4c:	528024c1 	mov	w1, #0x126                 	// #294
  407f50:	97ffff99 	bl	407db4 <assert_post_action>
  407f54:	528024c2 	mov	w2, #0x126                 	// #294
  407f58:	17ffffcd 	b	407e8c <z_log_init.isra.0+0x70>
				mask |= BIT(i);
  407f5c:	9ad82340 	lsl	x0, x26, x24
  407f60:	2a000294 	orr	w20, w20, w0
  407f64:	17ffffe9 	b	407f08 <z_log_init.isra.0+0xec>
	int i = 0;
  407f68:	52800018 	mov	w24, #0x0                   	// #0
	uint32_t mask = 0;
  407f6c:	52800014 	mov	w20, #0x0                   	// #0
				mask |= BIT(i);
  407f70:	d280003a 	mov	x26, #0x1                   	// #1
  407f74:	17ffffe7 	b	407f10 <z_log_init.isra.0+0xf4>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407f78:	54fffaa3 	b.cc	407ecc <z_log_init.isra.0+0xb0>  // b.lo, b.ul, b.last
	if (blocking) {
  407f7c:	34fff9d9 	cbz	w25, 407eb4 <z_log_init.isra.0+0x98>
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407f80:	f947aeb5 	ldr	x21, [x21, #3928]
		mask_cpy &= ~BIT(i);
  407f84:	d2800039 	mov	x25, #0x1                   	// #1
		while (mask) {
  407f88:	34fff974 	cbz	w20, 407eb4 <z_log_init.isra.0+0x98>
  407f8c:	2a1403f8 	mov	w24, w20
		uint32_t i = __builtin_ctz(mask_cpy);
  407f90:	5ac00280 	rbit	w0, w20
  407f94:	5ac01000 	clz	w0, w0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407f98:	d37b1416 	ubfiz	x22, x0, #5, #6
		mask_cpy &= ~BIT(i);
  407f9c:	9ac02321 	lsl	x1, x25, x0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407fa0:	8b1602b6 	add	x22, x21, x22
		mask_cpy &= ~BIT(i);
  407fa4:	2a2103fa 	mvn	w26, w1
  407fa8:	0a210294 	bic	w20, w20, w1
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407fac:	394062c1 	ldrb	w1, [x22, #24]
  407fb0:	34000181 	cbz	w1, 407fe0 <z_log_init.isra.0+0x1c4>
	STRUCT_SECTION_GET(log_backend, idx, &backend);
  407fb4:	937b7c00 	sbfiz	x0, x0, #5, #32
  407fb8:	8b150013 	add	x19, x0, x21
  407fbc:	aa1303e0 	mov	x0, x19
  407fc0:	97ffff90 	bl	407e00 <log_backend_is_ready>
  407fc4:	350000e0 	cbnz	w0, 407fe0 <z_log_init.isra.0+0x1c4>
			log_backend_enable(backend,
  407fc8:	f94006c0 	ldr	x0, [x22, #8]
			mask &= ~BIT(i);
  407fcc:	0a1a0318 	and	w24, w24, w26
			log_backend_enable(backend,
  407fd0:	52800082 	mov	w2, #0x4                   	// #4
  407fd4:	f9400001 	ldr	x1, [x0]
  407fd8:	aa1303e0 	mov	x0, x19
  407fdc:	940000ef 	bl	408398 <log_backend_enable>
	while (mask_cpy) {
  407fe0:	35fffd94 	cbnz	w20, 407f90 <z_log_init.isra.0+0x174>
			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
  407fe4:	34000077 	cbz	w23, 407ff0 <z_log_init.isra.0+0x1d4>
	return z_impl_k_sleep(timeout);
  407fe8:	d2800020 	mov	x0, #0x1                   	// #1
  407fec:	940028c0 	bl	4122ec <z_impl_k_sleep>
  407ff0:	2a1803f4 	mov	w20, w24
  407ff4:	17ffffe5 	b	407f88 <z_log_init.isra.0+0x16c>

0000000000407ff8 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(void)
{
  407ff8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
				COND_CODE_1(CONFIG_LOG_PROCESS_THREAD,
					K_MSEC(CONFIG_LOG_PROCESS_THREAD_STARTUP_DELAY_MS),
					K_NO_WAIT));
		k_thread_name_set(&logging_thread, "logging");
	} else {
		(void)z_log_init(false, false);
  407ffc:	52800001 	mov	w1, #0x0                   	// #0
  408000:	52800000 	mov	w0, #0x0                   	// #0
{
  408004:	910003fd 	mov	x29, sp
		(void)z_log_init(false, false);
  408008:	97ffff85 	bl	407e1c <z_log_init.isra.0>
	}

	return 0;
}
  40800c:	52800000 	mov	w0, #0x0                   	// #0
  408010:	a8c17bfd 	ldp	x29, x30, [sp], #16
  408014:	d65f03c0 	ret

0000000000408018 <log_format_func_t_get>:
}
  408018:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40801c:	91250021 	add	x1, x1, #0x940
  408020:	f8605820 	ldr	x0, [x1, w0, uxtw #3]
  408024:	d65f03c0 	ret

0000000000408028 <z_log_vprintk>:
{
  408028:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40802c:	aa0003e6 	mov	x6, x0
  408030:	910003fd 	mov	x29, sp
  408034:	ad400420 	ldp	q0, q1, [x1]
  408038:	9100c3e2 	add	x2, sp, #0x30
  40803c:	ad000440 	stp	q0, q1, [x2]
  408040:	ad400440 	ldp	q0, q1, [x2]
  408044:	910043e7 	add	x7, sp, #0x10
  408048:	52800005 	mov	w5, #0x0                   	// #0
  40804c:	d2800004 	mov	x4, #0x0                   	// #0
  408050:	d2800003 	mov	x3, #0x0                   	// #0
  408054:	52800002 	mov	w2, #0x0                   	// #0
  408058:	d2800001 	mov	x1, #0x0                   	// #0
  40805c:	52800000 	mov	w0, #0x0                   	// #0
  408060:	ad0004e0 	stp	q0, q1, [x7]
  408064:	9400010a 	bl	40848c <z_impl_z_log_msg_runtime_vcreate>
}
  408068:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40806c:	d65f03c0 	ret

0000000000408070 <log_set_timestamp_func>:
{
  408070:	aa0003e2 	mov	x2, x0
	if (timestamp_getter == NULL) {
  408074:	b4000140 	cbz	x0, 40809c <log_set_timestamp_func+0x2c>
{
  408078:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40807c:	2a0103e0 	mov	w0, w1
	timestamp_func = timestamp_getter;
  408080:	90000121 	adrp	x1, 42c000 <__dso_handle>
{
  408084:	910003fd 	mov	x29, sp
	timestamp_func = timestamp_getter;
  408088:	f9000822 	str	x2, [x1, #16]
		log_output_timestamp_freq_set(freq);
  40808c:	9400033c 	bl	408d7c <log_output_timestamp_freq_set>
	return 0;
  408090:	52800000 	mov	w0, #0x0                   	// #0
}
  408094:	a8c17bfd 	ldp	x29, x30, [sp], #16
  408098:	d65f03c0 	ret
		return -EINVAL;
  40809c:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  4080a0:	d65f03c0 	ret

00000000004080a4 <log_core_init>:
	panic_mode = false;
  4080a4:	b0000120 	adrp	x0, 42d000 <counter_period>
		log_set_timestamp_func(default_get_timestamp,
  4080a8:	52884801 	mov	w1, #0x4240                	// #16960
  4080ac:	72a001e1 	movk	w1, #0xf, lsl #16
	panic_mode = false;
  4080b0:	39374c1f 	strb	wzr, [x0, #3539]
	dropped_cnt = 0;
  4080b4:	90000120 	adrp	x0, 42c000 <__dso_handle>
  4080b8:	f905b01f 	str	xzr, [x0, #2912]
	buffered_cnt = 0;
  4080bc:	90000120 	adrp	x0, 42c000 <__dso_handle>
  4080c0:	f905ac1f 	str	xzr, [x0, #2904]
		log_set_timestamp_func(default_get_timestamp,
  4080c4:	f0ffffe0 	adrp	x0, 407000 <outs+0x40>
  4080c8:	9137c000 	add	x0, x0, #0xdf0
  4080cc:	17ffffe9 	b	408070 <log_set_timestamp_func>

00000000004080d0 <z_impl_log_panic>:
{
  4080d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4080d4:	910003fd 	mov	x29, sp
  4080d8:	f90013f5 	str	x21, [sp, #32]
	if (panic_mode) {
  4080dc:	b0000135 	adrp	x21, 42d000 <counter_period>
{
  4080e0:	a90153f3 	stp	x19, x20, [sp, #16]
	if (panic_mode) {
  4080e4:	39774ea0 	ldrb	w0, [x21, #3539]
  4080e8:	35000740 	cbnz	w0, 4081d0 <z_impl_log_panic+0x100>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4080ec:	f0000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  4080f0:	f0000114 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
	(void)z_log_init(true, false);
  4080f4:	52800001 	mov	w1, #0x0                   	// #0
  4080f8:	52800020 	mov	w0, #0x1                   	// #1
  4080fc:	97ffff48 	bl	407e1c <z_log_init.isra.0>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  408100:	f947ae73 	ldr	x19, [x19, #3928]
  408104:	f947fe94 	ldr	x20, [x20, #4088]
  408108:	eb14027f 	cmp	x19, x20
  40810c:	540005c9 	b.ls	4081c4 <z_impl_log_panic+0xf4>  // b.plast
  408110:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  408114:	912f3673 	add	x19, x19, #0xbcd
  408118:	aa1303e2 	mov	x2, x19
  40811c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408120:	91307821 	add	x1, x1, #0xc1e
  408124:	52803103 	mov	w3, #0x188                 	// #392
  408128:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40812c:	9123f800 	add	x0, x0, #0x8fe
  408130:	97fffef7 	bl	407d0c <assert_print>
  408134:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408138:	9130fc00 	add	x0, x0, #0xc3f
  40813c:	97fffef4 	bl	407d0c <assert_print>
  408140:	aa1303e0 	mov	x0, x19
  408144:	52803101 	mov	w1, #0x188                 	// #392
  408148:	97ffff1b 	bl	407db4 <assert_post_action>
  40814c:	52803102 	mov	w2, #0x188                 	// #392
  408150:	14000013 	b	40819c <z_impl_log_panic+0xcc>
		if (log_backend_is_active(backend)) {
  408154:	aa1303e0 	mov	x0, x19
  408158:	97ffff27 	bl	407df4 <log_backend_is_active>
  40815c:	72001c1f 	tst	w0, #0xff
  408160:	540002e0 	b.eq	4081bc <z_impl_log_panic+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  408164:	b5000253 	cbnz	x19, 4081ac <z_impl_log_panic+0xdc>
  408168:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  40816c:	91317a73 	add	x19, x19, #0xc5e
  408170:	aa1303e2 	mov	x2, x19
  408174:	52801a03 	mov	w3, #0xd0                  	// #208
  408178:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  40817c:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408180:	91325821 	add	x1, x1, #0xc96
  408184:	9123f800 	add	x0, x0, #0x8fe
  408188:	97fffee1 	bl	407d0c <assert_print>
  40818c:	aa1303e0 	mov	x0, x19
  408190:	52801a01 	mov	w1, #0xd0                  	// #208
  408194:	97ffff08 	bl	407db4 <assert_post_action>
  408198:	52801a02 	mov	w2, #0xd0                  	// #208
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  40819c:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4081a0:	aa1303e1 	mov	x1, x19
  4081a4:	9124f000 	add	x0, x0, #0x93c
  4081a8:	940008f5 	bl	40a57c <posix_print_error_and_exit>
	backend->api->panic(backend);
  4081ac:	f9400260 	ldr	x0, [x19]
  4081b0:	f9400801 	ldr	x1, [x0, #16]
  4081b4:	aa1303e0 	mov	x0, x19
  4081b8:	d63f0020 	blr	x1
  4081bc:	91008273 	add	x19, x19, #0x20
  4081c0:	17ffffd2 	b	408108 <z_impl_log_panic+0x38>
  4081c4:	54fffc83 	b.cc	408154 <z_impl_log_panic+0x84>  // b.lo, b.ul, b.last
	panic_mode = true;
  4081c8:	52800020 	mov	w0, #0x1                   	// #1
  4081cc:	39374ea0 	strb	w0, [x21, #3539]
}
  4081d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4081d4:	f94013f5 	ldr	x21, [sp, #32]
  4081d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4081dc:	d65f03c0 	ret

00000000004081e0 <z_log_notify_backend_enabled>:
}
  4081e0:	d65f03c0 	ret

00000000004081e4 <z_impl_log_process>:
  4081e4:	52800000 	mov	w0, #0x0                   	// #0
  4081e8:	d65f03c0 	ret

00000000004081ec <z_log_dropped>:
{
  4081ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4081f0:	90000121 	adrp	x1, 42c000 <__dso_handle>
  4081f4:	912d8021 	add	x1, x1, #0xb60
  4081f8:	910003fd 	mov	x29, sp
  4081fc:	f9000bf3 	str	x19, [sp, #16]
  408200:	12001c13 	and	w19, w0, #0xff
  408204:	d2800020 	mov	x0, #0x1                   	// #1
  408208:	97ffe502 	bl	401610 <__aarch64_ldadd8_acq_rel>
	if (buffered) {
  40820c:	340000b3 	cbz	w19, 408220 <z_log_dropped+0x34>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  408210:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408214:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  408218:	912d6021 	add	x1, x1, #0xb58
  40821c:	97ffe4fd 	bl	401610 <__aarch64_ldadd8_acq_rel>
}
  408220:	f9400bf3 	ldr	x19, [sp, #16]
  408224:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408228:	d65f03c0 	ret

000000000040822c <z_log_msg_commit>:
{
  40822c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  408230:	910003fd 	mov	x29, sp
  408234:	a90153f3 	stp	x19, x20, [sp, #16]
  408238:	aa0003f4 	mov	x20, x0
	msg->hdr.timestamp = timestamp_func();
  40823c:	90000120 	adrp	x0, 42c000 <__dso_handle>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  408240:	f0000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
{
  408244:	f90013f5 	str	x21, [sp, #32]
	msg->hdr.timestamp = timestamp_func();
  408248:	f9400800 	ldr	x0, [x0, #16]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  40824c:	f0000115 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
	msg->hdr.timestamp = timestamp_func();
  408250:	d63f0000 	blr	x0
  408254:	b9000680 	str	w0, [x20, #4]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  408258:	f947ae73 	ldr	x19, [x19, #3928]
  40825c:	f947feb5 	ldr	x21, [x21, #4088]
  408260:	eb15027f 	cmp	x19, x21
  408264:	540005e9 	b.ls	408320 <z_log_msg_commit+0xf4>  // b.plast
  408268:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  40826c:	912f3673 	add	x19, x19, #0xbcd
  408270:	aa1303e2 	mov	x2, x19
  408274:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408278:	91307821 	add	x1, x1, #0xc1e
  40827c:	528038a3 	mov	w3, #0x1c5                 	// #453
  408280:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408284:	9123f800 	add	x0, x0, #0x8fe
  408288:	97fffea1 	bl	407d0c <assert_print>
  40828c:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408290:	9130fc00 	add	x0, x0, #0xc3f
  408294:	97fffe9e 	bl	407d0c <assert_print>
  408298:	aa1303e0 	mov	x0, x19
  40829c:	528038a1 	mov	w1, #0x1c5                 	// #453
  4082a0:	97fffec5 	bl	407db4 <assert_post_action>
  4082a4:	528038a2 	mov	w2, #0x1c5                 	// #453
  4082a8:	14000013 	b	4082f4 <z_log_msg_commit+0xc8>
		if (log_backend_is_active(backend) &&
  4082ac:	aa1303e0 	mov	x0, x19
  4082b0:	97fffed1 	bl	407df4 <log_backend_is_active>
  4082b4:	72001c1f 	tst	w0, #0xff
  4082b8:	54000300 	b.eq	408318 <z_log_msg_commit+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  4082bc:	b5000253 	cbnz	x19, 408304 <z_log_msg_commit+0xd8>
  4082c0:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  4082c4:	91317a73 	add	x19, x19, #0xc5e
  4082c8:	aa1303e2 	mov	x2, x19
  4082cc:	52801643 	mov	w3, #0xb2                  	// #178
  4082d0:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4082d4:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4082d8:	91325821 	add	x1, x1, #0xc96
  4082dc:	9123f800 	add	x0, x0, #0x8fe
  4082e0:	97fffe8b 	bl	407d0c <assert_print>
  4082e4:	aa1303e0 	mov	x0, x19
  4082e8:	52801641 	mov	w1, #0xb2                  	// #178
  4082ec:	97fffeb2 	bl	407db4 <assert_post_action>
  4082f0:	52801642 	mov	w2, #0xb2                  	// #178
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4082f4:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4082f8:	aa1303e1 	mov	x1, x19
  4082fc:	9124f000 	add	x0, x0, #0x93c
  408300:	9400089f 	bl	40a57c <posix_print_error_and_exit>
	backend->api->process(backend, msg);
  408304:	f9400260 	ldr	x0, [x19]
  408308:	aa1403e1 	mov	x1, x20
  40830c:	f9400002 	ldr	x2, [x0]
  408310:	aa1303e0 	mov	x0, x19
  408314:	d63f0040 	blr	x2
  408318:	91008273 	add	x19, x19, #0x20
  40831c:	17ffffd1 	b	408260 <z_log_msg_commit+0x34>
  408320:	54fffc63 	b.cc	4082ac <z_log_msg_commit+0x80>  // b.lo, b.ul, b.last
}
  408324:	a94153f3 	ldp	x19, x20, [sp, #16]
  408328:	f94013f5 	ldr	x21, [sp, #32]
  40832c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  408330:	d65f03c0 	ret

0000000000408334 <z_log_get_tag>:
}
  408334:	d2800000 	mov	x0, #0x0                   	// #0
  408338:	d65f03c0 	ret

000000000040833c <log_src_cnt_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
  40833c:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  408340:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  408344:	f9475c00 	ldr	x0, [x0, #3768]
  408348:	f9472c21 	ldr	x1, [x1, #3672]
  40834c:	cb010000 	sub	x0, x0, x1
	if (z_log_is_local_domain(domain_id)) {
		return z_log_sources_count();
	}

	return link_source_count(domain_id);
}
  408350:	d3448c00 	ubfx	x0, x0, #4, #32
  408354:	d65f03c0 	ret

0000000000408358 <log_source_name_get>:

	return (const char *)cached;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t source_id)
{
  408358:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40835c:	910003fd 	mov	x29, sp
  408360:	f9000bf3 	str	x19, [sp, #16]
  408364:	2a0103f3 	mov	w19, w1
	if (z_log_is_local_domain(domain_id)) {
		if (source_id < log_src_cnt_get(domain_id)) {
  408368:	97fffff5 	bl	40833c <log_src_cnt_get>
  40836c:	6b13001f 	cmp	w0, w19
  408370:	54000109 	b.ls	408390 <log_source_name_get+0x38>  // b.plast
			return TYPE_SECTION_START(log_const)[source_id].name;
  408374:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  408378:	d37c7e73 	ubfiz	x19, x19, #4, #32
  40837c:	f9472c00 	ldr	x0, [x0, #3672]
  408380:	f8736800 	ldr	x0, [x0, x19]
			return NULL;
		}
	}

	return link_source_name_get(domain_id, source_id);
}
  408384:	f9400bf3 	ldr	x19, [sp, #16]
  408388:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40838c:	d65f03c0 	ret
			return NULL;
  408390:	d2800000 	mov	x0, #0x0                   	// #0
  408394:	17fffffc 	b	408384 <log_source_name_get+0x2c>

0000000000408398 <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
  408398:	f0000103 	adrp	x3, 42b000 <__FRAME_END__+0xfd74>
  40839c:	f947ac63 	ldr	x3, [x3, #3928]
  4083a0:	cb030003 	sub	x3, x0, x3
	__ASSERT_NO_MSG(backend != NULL);
  4083a4:	b50002a0 	cbnz	x0, 4083f8 <log_backend_enable+0x60>
{
  4083a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4083ac:	52801be3 	mov	w3, #0xdf                  	// #223
  4083b0:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4083b4:	910003fd 	mov	x29, sp
  4083b8:	f9000bf3 	str	x19, [sp, #16]
  4083bc:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  4083c0:	91317a73 	add	x19, x19, #0xc5e
  4083c4:	91325821 	add	x1, x1, #0xc96
  4083c8:	aa1303e2 	mov	x2, x19
  4083cc:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4083d0:	9123f800 	add	x0, x0, #0x8fe
  4083d4:	97fffe4e 	bl	407d0c <assert_print>
  4083d8:	aa1303e0 	mov	x0, x19
  4083dc:	52801be1 	mov	w1, #0xdf                  	// #223
  4083e0:	97fffe75 	bl	407db4 <assert_post_action>
  4083e4:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4083e8:	aa1303e1 	mov	x1, x19
  4083ec:	9124f000 	add	x0, x0, #0x93c
  4083f0:	52801be2 	mov	w2, #0xdf                  	// #223
  4083f4:	94000862 	bl	40a57c <posix_print_error_and_exit>
	backend->cb->id = id;
  4083f8:	f9400404 	ldr	x4, [x0, #8]
  4083fc:	9345fc63 	asr	x3, x3, #5
  408400:	11000463 	add	w3, w3, #0x1
  408404:	12001c63 	and	w3, w3, #0xff
  408408:	39002083 	strb	w3, [x4, #8]

	log_backend_id_set(backend, id);
	backend->cb->level = level;
  40840c:	f9400403 	ldr	x3, [x0, #8]
  408410:	39002862 	strb	w2, [x3, #10]
	backend->cb->ctx = ctx;
  408414:	f9400402 	ldr	x2, [x0, #8]
  408418:	f9000041 	str	x1, [x2]
	backend->cb->active = true;
  40841c:	52800021 	mov	w1, #0x1                   	// #1
  408420:	f9400400 	ldr	x0, [x0, #8]
  408424:	39002401 	strb	w1, [x0, #9]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
  408428:	17ffff6e 	b	4081e0 <z_log_notify_backend_enabled>

000000000040842c <z_log_msg_finalize>:
	 (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY) || log_backend_count_get() == 0))

void z_log_msg_finalize(struct log_msg *msg, const void *source,
			 const struct log_msg_desc desc, const void *data)
{
	if (!msg) {
  40842c:	b5000060 	cbnz	x0, 408438 <z_log_msg_finalize+0xc>
		z_log_dropped(false);
  408430:	52800000 	mov	w0, #0x0                   	// #0
  408434:	17ffff6e 	b	4081ec <z_log_dropped>
{
  408438:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40843c:	910003fd 	mov	x29, sp
  408440:	a90153f3 	stp	x19, x20, [sp, #16]
  408444:	aa0003f3 	mov	x19, x0
  408448:	2a0203f4 	mov	w20, w2
  40844c:	f90013f5 	str	x21, [sp, #32]
  408450:	aa0103f5 	mov	x21, x1
  408454:	aa0303e1 	mov	x1, x3

		return;
	}

	if (data) {
  408458:	b40000c3 	cbz	x3, 408470 <z_log_msg_finalize+0x44>
		uint8_t *d = msg->data + desc.package_len;
  40845c:	d3494e83 	ubfx	x3, x20, #9, #11
  408460:	91004000 	add	x0, x0, #0x10
  408464:	53147c42 	lsr	w2, w2, #20
  408468:	8b030000 	add	x0, x0, x3
  40846c:	97ffe341 	bl	401170 <memcpy@plt>

		memcpy(d, data, desc.data_len);
	}

	msg->hdr.desc = desc;
  408470:	b9000274 	str	w20, [x19]
	msg->hdr.source = source;
	z_log_msg_commit(msg);
  408474:	aa1303e0 	mov	x0, x19
	msg->hdr.source = source;
  408478:	f9000675 	str	x21, [x19, #8]
}
  40847c:	a94153f3 	ldp	x19, x20, [sp, #16]
  408480:	f94013f5 	ldr	x21, [sp, #32]
  408484:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_log_msg_commit(msg);
  408488:	17ffff69 	b	40822c <z_log_msg_commit>

000000000040848c <z_impl_z_log_msg_runtime_vcreate>:
#endif

void z_impl_z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				uint32_t package_flags, const char *fmt, va_list ap)
{
  40848c:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  408490:	910003fd 	mov	x29, sp
  408494:	a9046bf9 	stp	x25, x26, [sp, #64]
  408498:	12001c1a 	and	w26, w0, #0xff
  40849c:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4084a0:	a90153f3 	stp	x19, x20, [sp, #16]
  4084a4:	aa0103f4 	mov	x20, x1
  4084a8:	12001c53 	and	w19, w2, #0xff
  4084ac:	f9476800 	ldr	x0, [x0, #3792]
  4084b0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4084b4:	2a0503f9 	mov	w25, w5
  4084b8:	a90363f7 	stp	x23, x24, [sp, #48]
  4084bc:	aa0303f5 	mov	x21, x3
  4084c0:	d10043ff 	sub	sp, sp, #0x10
  4084c4:	f9400001 	ldr	x1, [x0]
  4084c8:	f9004fa1 	str	x1, [x29, #152]
  4084cc:	d2800001 	mov	x1, #0x0                   	// #0
  4084d0:	aa0403f8 	mov	x24, x4
  4084d4:	aa0603f6 	mov	x22, x6
  4084d8:	aa0703f7 	mov	x23, x7
	int plen;

	if (fmt) {
  4084dc:	b40003a6 	cbz	x6, 408550 <z_impl_z_log_msg_runtime_vcreate+0xc4>
		va_list ap2;

		va_copy(ap2, ap);
  4084e0:	ad4004e0 	ldp	q0, q1, [x7]
  4084e4:	9101e3a0 	add	x0, x29, #0x78
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  4084e8:	910143a4 	add	x4, x29, #0x50
  4084ec:	aa0603e3 	mov	x3, x6
  4084f0:	2a0503e2 	mov	w2, w5
  4084f4:	d2800201 	mov	x1, #0x10                  	// #16
		va_copy(ap2, ap);
  4084f8:	ad000400 	stp	q0, q1, [x0]
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  4084fc:	d2800000 	mov	x0, #0x0                   	// #0
  408500:	ad000480 	stp	q0, q1, [x4]
  408504:	97fff628 	bl	405da4 <cbvprintf_package>
					 package_flags, fmt, ap2);
		__ASSERT_NO_MSG(plen >= 0);
  408508:	36f80260 	tbz	w0, #31, 408554 <z_impl_z_log_msg_runtime_vcreate+0xc8>
  40850c:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  408510:	91340a73 	add	x19, x19, #0xd02
  408514:	aa1303e2 	mov	x2, x19
  408518:	52800ea3 	mov	w3, #0x75                  	// #117
  40851c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408520:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408524:	9134b821 	add	x1, x1, #0xd2e
  408528:	9123f800 	add	x0, x0, #0x8fe
  40852c:	97fffdf8 	bl	407d0c <assert_print>
  408530:	aa1303e0 	mov	x0, x19
  408534:	52800ea1 	mov	w1, #0x75                  	// #117
  408538:	97fffe1f 	bl	407db4 <assert_post_action>
  40853c:	52800ea2 	mov	w2, #0x75                  	// #117
		pkg = msg->data;
	}

	if (pkg && fmt) {
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
		__ASSERT_NO_MSG(plen >= 0);
  408540:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408544:	aa1303e1 	mov	x1, x19
  408548:	9124f000 	add	x0, x0, #0x93c
  40854c:	9400080c 	bl	40a57c <posix_print_error_and_exit>
		plen = 0;
  408550:	52800000 	mov	w0, #0x0                   	// #0
	struct log_msg_desc desc =
  408554:	531a0a73 	ubfiz	w19, w19, #6, #3
  408558:	531d0b5a 	ubfiz	w26, w26, #3, #3
  40855c:	53172802 	ubfiz	w2, w0, #9, #11
  408560:	2a1a0273 	orr	w19, w19, w26
  408564:	2a020273 	orr	w19, w19, w2
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  408568:	93407c01 	sxtw	x1, w0
	struct log_msg_desc desc =
  40856c:	2a185273 	orr	w19, w19, w24, lsl #20
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  408570:	91005f18 	add	x24, x24, #0x17
  408574:	8b20c300 	add	x0, x24, w0, sxtw
		msg = alloca(msg_wlen * sizeof(int));
  408578:	927df000 	and	x0, x0, #0xfffffffffffffff8
  40857c:	91003c00 	add	x0, x0, #0xf
  408580:	927cec02 	and	x2, x0, #0xfffffffffffffff0
  408584:	9270bc00 	and	x0, x0, #0xffffffffffff0000
  408588:	cb2063e0 	sub	x0, sp, x0
  40858c:	eb2063ff 	cmp	sp, x0
  408590:	54000080 	b.eq	4085a0 <z_impl_z_log_msg_runtime_vcreate+0x114>  // b.none
  408594:	d14043ff 	sub	sp, sp, #0x10, lsl #12
  408598:	f90203ff 	str	xzr, [sp, #1024]
  40859c:	17fffffc 	b	40858c <z_impl_z_log_msg_runtime_vcreate+0x100>
  4085a0:	92403c40 	and	x0, x2, #0xffff
  4085a4:	cb2063ff 	sub	sp, sp, x0
  4085a8:	f90003ff 	str	xzr, [sp]
  4085ac:	f110001f 	cmp	x0, #0x400
  4085b0:	54000043 	b.cc	4085b8 <z_impl_z_log_msg_runtime_vcreate+0x12c>  // b.lo, b.ul, b.last
  4085b4:	f90203ff 	str	xzr, [sp, #1024]
  4085b8:	910043f8 	add	x24, sp, #0x10
	if (pkg && fmt) {
  4085bc:	b40002f6 	cbz	x22, 408618 <z_impl_z_log_msg_runtime_vcreate+0x18c>
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
  4085c0:	ad4006e0 	ldp	q0, q1, [x23]
  4085c4:	910143a4 	add	x4, x29, #0x50
  4085c8:	aa1603e3 	mov	x3, x22
  4085cc:	2a1903e2 	mov	w2, w25
  4085d0:	91004300 	add	x0, x24, #0x10
  4085d4:	ad000480 	stp	q0, q1, [x4]
  4085d8:	97fff5f3 	bl	405da4 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
  4085dc:	36f801e0 	tbz	w0, #31, 408618 <z_impl_z_log_msg_runtime_vcreate+0x18c>
  4085e0:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  4085e4:	91340a73 	add	x19, x19, #0xd02
  4085e8:	aa1303e2 	mov	x2, x19
  4085ec:	528011e3 	mov	w3, #0x8f                  	// #143
  4085f0:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4085f4:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4085f8:	9134b821 	add	x1, x1, #0xd2e
  4085fc:	9123f800 	add	x0, x0, #0x8fe
  408600:	97fffdc3 	bl	407d0c <assert_print>
  408604:	aa1303e0 	mov	x0, x19
  408608:	528011e1 	mov	w1, #0x8f                  	// #143
  40860c:	97fffdea 	bl	407db4 <assert_post_action>
  408610:	528011e2 	mov	w2, #0x8f                  	// #143
  408614:	17ffffcb 	b	408540 <z_impl_z_log_msg_runtime_vcreate+0xb4>
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_msg(source, desc, pkg, data);
	}

	if (BACKENDS_IN_USE()) {
		z_log_msg_finalize(msg, source, desc, data);
  408618:	2a1303e2 	mov	w2, w19
  40861c:	aa1403e1 	mov	x1, x20
  408620:	aa1803e0 	mov	x0, x24
  408624:	aa1503e3 	mov	x3, x21
  408628:	97ffff81 	bl	40842c <z_log_msg_finalize>
	}
}
  40862c:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  408630:	f9476800 	ldr	x0, [x0, #3792]
  408634:	f9404fa2 	ldr	x2, [x29, #152]
  408638:	f9400001 	ldr	x1, [x0]
  40863c:	eb010042 	subs	x2, x2, x1
  408640:	d2800001 	mov	x1, #0x0                   	// #0
  408644:	54000040 	b.eq	40864c <z_impl_z_log_msg_runtime_vcreate+0x1c0>  // b.none
  408648:	97ffe336 	bl	401320 <__stack_chk_fail@plt>
  40864c:	910003bf 	mov	sp, x29
  408650:	a94153f3 	ldp	x19, x20, [sp, #16]
  408654:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408658:	a94363f7 	ldp	x23, x24, [sp, #48]
  40865c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  408660:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  408664:	d65f03c0 	ret

0000000000408668 <out_func>:

	return ret;
}

static int out_func(int c, void *ctx)
{
  408668:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40866c:	f0000102 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
  408670:	910003fd 	mov	x29, sp
  408674:	f9476842 	ldr	x2, [x2, #3792]
  408678:	f9400043 	ldr	x3, [x2]
  40867c:	f9000fe3 	str	x3, [sp, #24]
  408680:	d2800003 	mov	x3, #0x0                   	// #0
	int idx;

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		/* Backend must be thread safe in synchronous operation. */
		/* Need that step for big endian */
		char x = (char)c;
  408684:	39005fe0 	strb	w0, [sp, #23]

		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
  408688:	a9400023 	ldp	x3, x0, [x1]
  40868c:	d2800021 	mov	x1, #0x1                   	// #1
  408690:	f9400402 	ldr	x2, [x0, #8]
  408694:	91005fe0 	add	x0, sp, #0x17
  408698:	d63f0060 	blr	x3
	out_ctx->buf[idx] = (uint8_t)c;

	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);

	return 0;
}
  40869c:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4086a0:	f9476800 	ldr	x0, [x0, #3792]
  4086a4:	f9400fe2 	ldr	x2, [sp, #24]
  4086a8:	f9400001 	ldr	x1, [x0]
  4086ac:	eb010042 	subs	x2, x2, x1
  4086b0:	d2800001 	mov	x1, #0x0                   	// #0
  4086b4:	54000040 	b.eq	4086bc <out_func+0x54>  // b.none
  4086b8:	97ffe31a 	bl	401320 <__stack_chk_fail@plt>
  4086bc:	52800000 	mov	w0, #0x0                   	// #0
  4086c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4086c4:	d65f03c0 	ret

00000000004086c8 <cr_out_func>:

static int cr_out_func(int c, void *ctx)
{
  4086c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4086cc:	910003fd 	mov	x29, sp
  4086d0:	a90153f3 	stp	x19, x20, [sp, #16]
  4086d4:	2a0003f3 	mov	w19, w0
  4086d8:	aa0103f4 	mov	x20, x1
	if (c == '\n') {
  4086dc:	7100281f 	cmp	w0, #0xa
  4086e0:	54000061 	b.ne	4086ec <cr_out_func+0x24>  // b.any
		out_func((int)'\r', ctx);
  4086e4:	528001a0 	mov	w0, #0xd                   	// #13
  4086e8:	97ffffe0 	bl	408668 <out_func>
	}
	out_func(c, ctx);
  4086ec:	aa1403e1 	mov	x1, x20
  4086f0:	2a1303e0 	mov	w0, w19
  4086f4:	97ffffdd 	bl	408668 <out_func>

	return 0;
}
  4086f8:	52800000 	mov	w0, #0x0                   	// #0
  4086fc:	a94153f3 	ldp	x19, x20, [sp, #16]
  408700:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408704:	d65f03c0 	ret

0000000000408708 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
  408708:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40870c:	910003fd 	mov	x29, sp
  408710:	a90153f3 	stp	x19, x20, [sp, #16]
  408714:	aa0103f4 	mov	x20, x1
  408718:	aa0203f3 	mov	x19, x2
  40871c:	a9025bf5 	stp	x21, x22, [sp, #32]
  408720:	aa0003f5 	mov	x21, x0
  408724:	aa0303f6 	mov	x22, x3
	int processed;

	do {
		processed = outf(buf, len, ctx);
  408728:	aa1303e1 	mov	x1, x19
  40872c:	aa1403e0 	mov	x0, x20
  408730:	aa1603e2 	mov	x2, x22
  408734:	d63f02a0 	blr	x21
		len -= processed;
		buf += processed;
  408738:	8b20c294 	add	x20, x20, w0, sxtw
	} while (len != 0);
  40873c:	eb20c273 	subs	x19, x19, w0, sxtw
  408740:	54ffff41 	b.ne	408728 <buffer_write+0x20>  // b.any
}
  408744:	a94153f3 	ldp	x19, x20, [sp, #16]
  408748:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40874c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  408750:	d65f03c0 	ret

0000000000408754 <cbvprintf>:
#ifdef CONFIG_PICOLIBC
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
  408754:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  408758:	910003fd 	mov	x29, sp
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
  40875c:	ad400460 	ldp	q0, q1, [x3]
  408760:	910043e4 	add	x4, sp, #0x10
  408764:	aa0403e3 	mov	x3, x4
  408768:	ad000480 	stp	q0, q1, [x4]
  40876c:	52800004 	mov	w4, #0x0                   	// #0
  408770:	97fffa83 	bl	40717c <z_cbvprintf_impl>
}
  408774:	a8c37bfd 	ldp	x29, x30, [sp], #48
  408778:	d65f03c0 	ret

000000000040877c <print_formatted>:
{
  40877c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  408780:	910003fd 	mov	x29, sp
  408784:	a90e0fe2 	stp	x2, x3, [sp, #224]
  408788:	f0000102 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
  40878c:	f9476842 	ldr	x2, [x2, #3792]
  408790:	3d801be0 	str	q0, [sp, #96]
  408794:	3d801fe1 	str	q1, [sp, #112]
  408798:	3d8023e2 	str	q2, [sp, #128]
  40879c:	3d8027e3 	str	q3, [sp, #144]
  4087a0:	3d802be4 	str	q4, [sp, #160]
  4087a4:	3d802fe5 	str	q5, [sp, #176]
  4087a8:	3d8033e6 	str	q6, [sp, #192]
  4087ac:	3d8037e7 	str	q7, [sp, #208]
  4087b0:	a90f17e4 	stp	x4, x5, [sp, #240]
  4087b4:	a9101fe6 	stp	x6, x7, [sp, #256]
  4087b8:	f9400043 	ldr	x3, [x2]
  4087bc:	f9002fe3 	str	x3, [sp, #88]
  4087c0:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(args, fmt);
  4087c4:	910443e2 	add	x2, sp, #0x110
  4087c8:	a9038be2 	stp	x2, x2, [sp, #56]
  4087cc:	910383e2 	add	x2, sp, #0xe0
	length = cbvprintf(out_func, (void *)output, fmt, args);
  4087d0:	910043e3 	add	x3, sp, #0x10
	va_start(args, fmt);
  4087d4:	f90027e2 	str	x2, [sp, #72]
  4087d8:	128005e2 	mov	w2, #0xffffffd0            	// #-48
  4087dc:	b90053e2 	str	w2, [sp, #80]
  4087e0:	12800fe2 	mov	w2, #0xffffff80            	// #-128
  4087e4:	b90057e2 	str	w2, [sp, #84]
	length = cbvprintf(out_func, (void *)output, fmt, args);
  4087e8:	9100e3e2 	add	x2, sp, #0x38
  4087ec:	ad400440 	ldp	q0, q1, [x2]
  4087f0:	aa0103e2 	mov	x2, x1
  4087f4:	aa0003e1 	mov	x1, x0
  4087f8:	90000000 	adrp	x0, 408000 <enable_logger+0x8>
  4087fc:	9119a000 	add	x0, x0, #0x668
  408800:	ad000460 	stp	q0, q1, [x3]
  408804:	97ffffd4 	bl	408754 <cbvprintf>
}
  408808:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40880c:	f9476821 	ldr	x1, [x1, #3792]
  408810:	f9402fe3 	ldr	x3, [sp, #88]
  408814:	f9400022 	ldr	x2, [x1]
  408818:	eb020063 	subs	x3, x3, x2
  40881c:	d2800002 	mov	x2, #0x0                   	// #0
  408820:	54000040 	b.eq	408828 <print_formatted+0xac>  // b.none
  408824:	97ffe2bf 	bl	401320 <__stack_chk_fail@plt>
  408828:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40882c:	d65f03c0 	ret

0000000000408830 <log_output_flush>:


void log_output_flush(const struct log_output *output)
{
  408830:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408834:	910003fd 	mov	x29, sp
  408838:	f9000bf3 	str	x19, [sp, #16]
  40883c:	aa0003f3 	mov	x19, x0
	buffer_write(output->func, output->buf,
  408840:	a9408400 	ldp	x0, x1, [x0, #8]
  408844:	a9400c02 	ldp	x2, x3, [x0]
  408848:	f9400260 	ldr	x0, [x19]
  40884c:	97ffffaf 	bl	408708 <buffer_write>
		     output->control_block->offset,
		     output->control_block->ctx);

	output->control_block->offset = 0;
  408850:	f9400660 	ldr	x0, [x19, #8]
  408854:	f900001f 	str	xzr, [x0]
}
  408858:	f9400bf3 	ldr	x19, [sp, #16]
  40885c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408860:	d65f03c0 	ret

0000000000408864 <log_output_process>:
			uint8_t level,
			const uint8_t *package,
			const uint8_t *data,
			size_t data_len,
			uint32_t flags)
{
  408864:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  408868:	910003fd 	mov	x29, sp
  40886c:	a90153f3 	stp	x19, x20, [sp, #16]
  408870:	aa0003f3 	mov	x19, x0
  408874:	a9025bf5 	stp	x21, x22, [sp, #32]
  408878:	aa0703f5 	mov	x21, x7
  40887c:	b94083f6 	ldr	w22, [sp, #128]
  408880:	a90363f7 	stp	x23, x24, [sp, #48]
  408884:	aa0603f7 	mov	x23, x6
  408888:	a9046bf9 	stp	x25, x26, [sp, #64]
  40888c:	aa0303fa 	mov	x26, x3
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	uint32_t prefix_offset;
	cbprintf_cb cb;

	if (!raw_string) {
  408890:	72001c99 	ands	w25, w4, #0xff
{
  408894:	a90573fb 	stp	x27, x28, [sp, #80]
  408898:	aa0503fb 	mov	x27, x5
	if (!raw_string) {
  40889c:	54001100 	b.eq	408abc <log_output_process+0x258>  // b.none
	__ASSERT_NO_MSG(level <= LOG_LEVEL_DBG);
  4088a0:	7100133f 	cmp	w25, #0x4
  4088a4:	54000249 	b.ls	4088ec <log_output_process+0x88>  // b.plast
  4088a8:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  4088ac:	9134f673 	add	x19, x19, #0xd3d
  4088b0:	aa1303e2 	mov	x2, x19
  4088b4:	52803663 	mov	w3, #0x1b3                 	// #435
  4088b8:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4088bc:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4088c0:	9135b021 	add	x1, x1, #0xd6c
  4088c4:	9123f800 	add	x0, x0, #0x8fe
  4088c8:	97fffd11 	bl	407d0c <assert_print>
  4088cc:	aa1303e0 	mov	x0, x19
  4088d0:	52803661 	mov	w1, #0x1b3                 	// #435
  4088d4:	97fffd38 	bl	407db4 <assert_post_action>
  4088d8:	52803662 	mov	w2, #0x1b3                 	// #435

	if (package) {
		int err = cbpprintf(cb, (void *)output, (void *)package);

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
  4088dc:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4088e0:	aa1303e1 	mov	x1, x19
  4088e4:	9124f000 	add	x0, x0, #0x93c
  4088e8:	94000725 	bl	40a57c <posix_print_error_and_exit>
  4088ec:	121d02c0 	and	w0, w22, #0x8
  4088f0:	aa0203fc 	mov	x28, x2
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  4088f4:	2a0103f4 	mov	w20, w1
  4088f8:	b9007be0 	str	w0, [sp, #120]
	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
  4088fc:	97fffe8e 	bl	408334 <z_log_get_tag>
  408900:	aa0003e2 	mov	x2, x0
	if (tag) {
  408904:	b40009e0 	cbz	x0, 408a40 <log_output_process+0x1dc>
		length += print_formatted(output, "%s ", tag);
  408908:	aa1303e0 	mov	x0, x19
  40890c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408910:	9135e021 	add	x1, x1, #0xd78
  408914:	97ffff9a 	bl	40877c <print_formatted>
  408918:	2a0003f8 	mov	w24, w0
	if (stamp) {
  40891c:	121f02c0 	and	w0, w22, #0x2
  408920:	34000140 	cbz	w0, 408948 <log_output_process+0xe4>
	if (!format) {
  408924:	52800880 	mov	w0, #0x44                  	// #68
  408928:	6a0002df 	tst	w22, w0
  40892c:	540008e1 	b.ne	408a48 <log_output_process+0x1e4>  // b.any
		length = print_formatted(output, "[%08lu] ", timestamp);
  408930:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408934:	2a1403e2 	mov	w2, w20
  408938:	9135f021 	add	x1, x1, #0xd7c
  40893c:	aa1303e0 	mov	x0, x19
  408940:	97ffff8f 	bl	40877c <print_formatted>
		length += timestamp_print(output, flags, timestamp);
  408944:	0b000318 	add	w24, w24, w0
	if (color) {
  408948:	120002c0 	and	w0, w22, #0x1
  40894c:	34000180 	cbz	w0, 40897c <log_output_process+0x118>
		const char *log_color = start && (colors[level] != NULL) ?
  408950:	2a1903e1 	mov	w1, w25
  408954:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  408958:	911ee000 	add	x0, x0, #0x7b8
  40895c:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  408960:	b5000062 	cbnz	x2, 40896c <log_output_process+0x108>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
  408964:	90000062 	adrp	x2, 414000 <dlc_table.0+0x60d>
  408968:	9134e042 	add	x2, x2, #0xd38
		print_formatted(output, "%s", log_color);
  40896c:	b0000061 	adrp	x1, 415000 <random_data+0xb30>
  408970:	aa1303e0 	mov	x0, x19
  408974:	911c2c21 	add	x1, x1, #0x70b
  408978:	97ffff81 	bl	40877c <print_formatted>
	if (level_on) {
  40897c:	121d02c0 	and	w0, w22, #0x8
  408980:	340009a0 	cbz	w0, 408ab4 <log_output_process+0x250>
		total += print_formatted(output, "<%s> ", severity[level]);
  408984:	2a1903e1 	mov	w1, w25
  408988:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40898c:	911f8000 	add	x0, x0, #0x7e0
  408990:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  408994:	aa1303e0 	mov	x0, x19
  408998:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  40899c:	91368421 	add	x1, x1, #0xda1
  4089a0:	97ffff77 	bl	40877c <print_formatted>
  4089a4:	2a0003f4 	mov	w20, w0
	if (domain) {
  4089a8:	b40000fc 	cbz	x28, 4089c4 <log_output_process+0x160>
		total += print_formatted(output, "%s/", domain);
  4089ac:	aa1c03e2 	mov	x2, x28
  4089b0:	aa1303e0 	mov	x0, x19
  4089b4:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4089b8:	91369c21 	add	x1, x1, #0xda7
  4089bc:	97ffff70 	bl	40877c <print_formatted>
  4089c0:	0b000294 	add	w20, w20, w0
	if (source) {
  4089c4:	b40000fa 	cbz	x26, 4089e0 <log_output_process+0x17c>
		total += print_formatted(output,
  4089c8:	aa1a03e2 	mov	x2, x26
  4089cc:	aa1303e0 	mov	x0, x19
  4089d0:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4089d4:	9136ac21 	add	x1, x1, #0xdab
  4089d8:	97ffff69 	bl	40877c <print_formatted>
  4089dc:	0b000294 	add	w20, w20, w0
		cb = out_func;
  4089e0:	90000000 	adrp	x0, 408000 <enable_logger+0x8>
	length += ids_print(output, level_on, func_on, domain, source, level);
  4089e4:	0b180294 	add	w20, w20, w24
		cb = out_func;
  4089e8:	9119a000 	add	x0, x0, #0x668
	if (package) {
  4089ec:	b40007bb 	cbz	x27, 408ae0 <log_output_process+0x27c>
		return cbpprintf_external(out, cbvprintf_tagged_args,
					  ctx, packaged);
	}
#endif

	return cbpprintf_external(out, cbvprintf, ctx, packaged);
  4089f0:	90000001 	adrp	x1, 408000 <enable_logger+0x8>
  4089f4:	aa1b03e3 	mov	x3, x27
  4089f8:	aa1303e2 	mov	x2, x19
  4089fc:	911d5021 	add	x1, x1, #0x754
  408a00:	97fff6c6 	bl	406518 <cbpprintf_external>
		__ASSERT_NO_MSG(err >= 0);
  408a04:	36f806e0 	tbz	w0, #31, 408ae0 <log_output_process+0x27c>
  408a08:	90000073 	adrp	x19, 414000 <dlc_table.0+0x60d>
  408a0c:	9134f673 	add	x19, x19, #0xd3d
  408a10:	aa1303e2 	mov	x2, x19
  408a14:	52804123 	mov	w3, #0x209                 	// #521
  408a18:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408a1c:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408a20:	9136c021 	add	x1, x1, #0xdb0
  408a24:	9123f800 	add	x0, x0, #0x8fe
  408a28:	97fffcb9 	bl	407d0c <assert_print>
  408a2c:	aa1303e0 	mov	x0, x19
  408a30:	52804121 	mov	w1, #0x209                 	// #521
  408a34:	97fffce0 	bl	407db4 <assert_post_action>
  408a38:	52804122 	mov	w2, #0x209                 	// #521
  408a3c:	17ffffa8 	b	4088dc <log_output_process+0x78>
	uint32_t length = 0U;
  408a40:	52800018 	mov	w24, #0x0                   	// #0
  408a44:	17ffffb6 	b	40891c <log_output_process+0xb8>
	} else if (freq != 0U) {
  408a48:	b0000120 	adrp	x0, 42d000 <counter_period>
  408a4c:	b94ba406 	ldr	w6, [x0, #2980]
  408a50:	340002e6 	cbz	w6, 408aac <log_output_process+0x248>
		timestamp /= timestamp_div;
  408a54:	b0000120 	adrp	x0, 42d000 <counter_period>
  408a58:	5281c201 	mov	w1, #0xe10                 	// #3600
		ms = (remainder * 1000U) / freq;
  408a5c:	52807d03 	mov	w3, #0x3e8                 	// #1000
				length = print_formatted(output,
  408a60:	52800784 	mov	w4, #0x3c                  	// #60
		timestamp /= timestamp_div;
  408a64:	b94ba800 	ldr	w0, [x0, #2984]
  408a68:	1ac00a94 	udiv	w20, w20, w0
		total_seconds = timestamp / freq;
  408a6c:	1ac60a80 	udiv	w0, w20, w6
		seconds -= hours * 3600U;
  408a70:	1ac10802 	udiv	w2, w0, w1
  408a74:	1b018041 	msub	w1, w2, w1, w0
		remainder = timestamp % freq;
  408a78:	1b06d000 	msub	w0, w0, w6, w20
		ms = (remainder * 1000U) / freq;
  408a7c:	1b037c00 	mul	w0, w0, w3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  408a80:	1ac60805 	udiv	w5, w0, w6
  408a84:	1b0680a0 	msub	w0, w5, w6, w0
  408a88:	1b037c00 	mul	w0, w0, w3
				length = print_formatted(output,
  408a8c:	1ac40823 	udiv	w3, w1, w4
  408a90:	1ac60806 	udiv	w6, w0, w6
  408a94:	aa1303e0 	mov	x0, x19
  408a98:	1b048464 	msub	w4, w3, w4, w1
  408a9c:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408aa0:	91361421 	add	x1, x1, #0xd85
  408aa4:	97ffff36 	bl	40877c <print_formatted>
  408aa8:	17ffffa7 	b	408944 <log_output_process+0xe0>
		length = 0;
  408aac:	52800000 	mov	w0, #0x0                   	// #0
  408ab0:	17ffffa5 	b	408944 <log_output_process+0xe0>
	int total = 0;
  408ab4:	52800014 	mov	w20, #0x0                   	// #0
  408ab8:	17ffffbc 	b	4089a8 <log_output_process+0x144>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  408abc:	f100047f 	cmp	x3, #0x1
  408ac0:	540000a0 	b.eq	408ad4 <log_output_process+0x270>  // b.none
  408ac4:	90000000 	adrp	x0, 408000 <enable_logger+0x8>
  408ac8:	911b2000 	add	x0, x0, #0x6c8
		prefix_offset = 0;
  408acc:	52800014 	mov	w20, #0x0                   	// #0
  408ad0:	17ffffc7 	b	4089ec <log_output_process+0x188>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  408ad4:	90000000 	adrp	x0, 408000 <enable_logger+0x8>
  408ad8:	9119a000 	add	x0, x0, #0x668
  408adc:	17fffffc 	b	408acc <log_output_process+0x268>
	}

	if (data_len) {
  408ae0:	b4000895 	cbz	x21, 408bf0 <log_output_process+0x38c>
		print_formatted(output, " ");
  408ae4:	90000078 	adrp	x24, 414000 <dlc_table.0+0x60d>
  408ae8:	9136fb18 	add	x24, x24, #0xdbe
		print_formatted(ctx, "\r\n");
  408aec:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408af0:	9136e400 	add	x0, x0, #0xdb9
  408af4:	f9003be0 	str	x0, [sp, #112]
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
  408af8:	52800200 	mov	w0, #0x10                  	// #16
  408afc:	6b0002bf 	cmp	w21, w0
  408b00:	1a8092a1 	csel	w1, w21, w0, ls  // ls = plast
  408b04:	1a8092a0 	csel	w0, w21, w0, ls  // ls = plast
  408b08:	f90033e0 	str	x0, [sp, #96]
  408b0c:	b9007be1 	str	w1, [sp, #120]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  408b10:	372000d6 	tbnz	w22, #4, 408b28 <log_output_process+0x2c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  408b14:	362809b6 	tbz	w22, #5, 408c48 <log_output_process+0x3e4>
		print_formatted(ctx, "\n");
  408b18:	b0000061 	adrp	x1, 415000 <random_data+0xb30>
  408b1c:	913b7821 	add	x1, x1, #0xede
		print_formatted(ctx, "\r\n");
  408b20:	aa1303e0 	mov	x0, x19
  408b24:	97ffff16 	bl	40877c <print_formatted>
		prefix_offset = 0;
  408b28:	5280001b 	mov	w27, #0x0                   	// #0
	for (int i = 0; i < prefix_offset; i++) {
  408b2c:	6b1b029f 	cmp	w20, w27
  408b30:	5400090c 	b.gt	408c50 <log_output_process+0x3ec>
			print_formatted(output, "%02x ", data[i]);
  408b34:	f000005c 	adrp	x28, 413000 <sys_clock_announce+0x19c>
  408b38:	9138379c 	add	x28, x28, #0xe0d
			print_formatted(output, "   ");
  408b3c:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408b40:	d280001a 	mov	x26, #0x0                   	// #0
  408b44:	9136f000 	add	x0, x0, #0xdbc
  408b48:	f90037e0 	str	x0, [sp, #104]
		if (i < length) {
  408b4c:	b9407be0 	ldr	w0, [sp, #120]
  408b50:	2a1a03fb 	mov	w27, w26
  408b54:	6b1a001f 	cmp	w0, w26
  408b58:	54000969 	b.ls	408c84 <log_output_process+0x420>  // b.plast
			print_formatted(output, "%02x ", data[i]);
  408b5c:	387a6ae2 	ldrb	w2, [x23, x26]
  408b60:	aa1c03e1 	mov	x1, x28
  408b64:	aa1303e0 	mov	x0, x19
  408b68:	97ffff05 	bl	40877c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  408b6c:	f1003f5f 	cmp	x26, #0xf
  408b70:	540007a1 	b.ne	408c64 <log_output_process+0x400>  // b.any
			print_formatted(output, "%c",
  408b74:	9000007b 	adrp	x27, 414000 <dlc_table.0+0x60d>
  408b78:	91370b7b 	add	x27, x27, #0xdc2
	print_formatted(output, "|");
  408b7c:	d280001c 	mov	x28, #0x0                   	// #0
  408b80:	528005da 	mov	w26, #0x2e                  	// #46
  408b84:	aa1303e0 	mov	x0, x19
  408b88:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408b8c:	91370021 	add	x1, x1, #0xdc0
  408b90:	97fffefb 	bl	40877c <print_formatted>
		if (i < length) {
  408b94:	b9407be0 	ldr	w0, [sp, #120]
  408b98:	b9006bfc 	str	w28, [sp, #104]
  408b9c:	6b1c001f 	cmp	w0, w28
  408ba0:	540008c9 	b.ls	408cb8 <log_output_process+0x454>  // b.plast
			unsigned char c = (unsigned char)data[i];
  408ba4:	387c6ae2 	ldrb	w2, [x23, x28]
  408ba8:	b9007fe2 	str	w2, [sp, #124]
			      isprint((int)c) != 0 ? c : '.');
  408bac:	97ffe201 	bl	4013b0 <__ctype_b_loc@plt>
  408bb0:	b9407fe2 	ldr	w2, [sp, #124]
  408bb4:	f9400000 	ldr	x0, [x0]
  408bb8:	d37f1c41 	ubfiz	x1, x2, #1, #8
			print_formatted(output, "%c",
  408bbc:	78616800 	ldrh	w0, [x0, x1]
  408bc0:	aa1b03e1 	mov	x1, x27
  408bc4:	f272001f 	tst	x0, #0x4000
  408bc8:	aa1303e0 	mov	x0, x19
  408bcc:	1a9a1042 	csel	w2, w2, w26, ne  // ne = any
  408bd0:	97fffeeb 	bl	40877c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  408bd4:	f1003f9f 	cmp	x28, #0xf
  408bd8:	540005e1 	b.ne	408c94 <log_output_process+0x430>  // b.any
		data += length;
  408bdc:	f94033e0 	ldr	x0, [sp, #96]
  408be0:	8b0002f7 	add	x23, x23, x0
	} while (len);
  408be4:	b9407be0 	ldr	w0, [sp, #120]
  408be8:	6b0002b5 	subs	w21, w21, w0
  408bec:	54fff861 	b.ne	408af8 <log_output_process+0x294>  // b.any
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
	}

	if (!raw_string) {
  408bf0:	340001d9 	cbz	w25, 408c28 <log_output_process+0x3c4>
	if (color) {
  408bf4:	360000f6 	tbz	w22, #0, 408c10 <log_output_process+0x3ac>
		print_formatted(output, "%s", log_color);
  408bf8:	90000062 	adrp	x2, 414000 <dlc_table.0+0x60d>
  408bfc:	b0000061 	adrp	x1, 415000 <random_data+0xb30>
  408c00:	9134e042 	add	x2, x2, #0xd38
  408c04:	911c2c21 	add	x1, x1, #0x70b
  408c08:	aa1303e0 	mov	x0, x19
  408c0c:	97fffedc 	bl	40877c <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  408c10:	372000d6 	tbnz	w22, #4, 408c28 <log_output_process+0x3c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  408c14:	362805b6 	tbz	w22, #5, 408cc8 <log_output_process+0x464>
		print_formatted(ctx, "\n");
  408c18:	b0000061 	adrp	x1, 415000 <random_data+0xb30>
  408c1c:	913b7821 	add	x1, x1, #0xede
		print_formatted(ctx, "\r\n");
  408c20:	aa1303e0 	mov	x0, x19
  408c24:	97fffed6 	bl	40877c <print_formatted>
		postfix_print(output, flags, level);
	}

	log_output_flush(output);
  408c28:	aa1303e0 	mov	x0, x19
}
  408c2c:	a94153f3 	ldp	x19, x20, [sp, #16]
  408c30:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408c34:	a94363f7 	ldp	x23, x24, [sp, #48]
  408c38:	a9446bf9 	ldp	x25, x26, [sp, #64]
  408c3c:	a94573fb 	ldp	x27, x28, [sp, #80]
  408c40:	a8c87bfd 	ldp	x29, x30, [sp], #128
	log_output_flush(output);
  408c44:	17fffefb 	b	408830 <log_output_flush>
		print_formatted(ctx, "\r\n");
  408c48:	f9403be1 	ldr	x1, [sp, #112]
  408c4c:	17ffffb5 	b	408b20 <log_output_process+0x2bc>
		print_formatted(output, " ");
  408c50:	aa1803e1 	mov	x1, x24
  408c54:	aa1303e0 	mov	x0, x19
	for (int i = 0; i < prefix_offset; i++) {
  408c58:	1100077b 	add	w27, w27, #0x1
		print_formatted(output, " ");
  408c5c:	97fffec8 	bl	40877c <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
  408c60:	17ffffb3 	b	408b2c <log_output_process+0x2c8>
		if (i > 0 && !(i % 8)) {
  408c64:	1100077b 	add	w27, w27, #0x1
  408c68:	f2400b7f 	tst	x27, #0x7
  408c6c:	54000081 	b.ne	408c7c <log_output_process+0x418>  // b.any
			print_formatted(output, " ");
  408c70:	aa1803e1 	mov	x1, x24
  408c74:	aa1303e0 	mov	x0, x19
  408c78:	97fffec1 	bl	40877c <print_formatted>
  408c7c:	9100075a 	add	x26, x26, #0x1
  408c80:	17ffffb3 	b	408b4c <log_output_process+0x2e8>
			print_formatted(output, "   ");
  408c84:	f94037e1 	ldr	x1, [sp, #104]
  408c88:	aa1303e0 	mov	x0, x19
  408c8c:	97fffebc 	bl	40877c <print_formatted>
  408c90:	17ffffb7 	b	408b6c <log_output_process+0x308>
		if (i > 0 && !(i % 8)) {
  408c94:	b9406be0 	ldr	w0, [sp, #104]
  408c98:	11000400 	add	w0, w0, #0x1
  408c9c:	f240081f 	tst	x0, #0x7
  408ca0:	54000081 	b.ne	408cb0 <log_output_process+0x44c>  // b.any
			print_formatted(output, " ");
  408ca4:	aa1803e1 	mov	x1, x24
  408ca8:	aa1303e0 	mov	x0, x19
  408cac:	97fffeb4 	bl	40877c <print_formatted>
  408cb0:	9100079c 	add	x28, x28, #0x1
  408cb4:	17ffffb8 	b	408b94 <log_output_process+0x330>
			print_formatted(output, " ");
  408cb8:	aa1803e1 	mov	x1, x24
  408cbc:	aa1303e0 	mov	x0, x19
  408cc0:	97fffeaf 	bl	40877c <print_formatted>
  408cc4:	17ffffc4 	b	408bd4 <log_output_process+0x370>
		print_formatted(ctx, "\r\n");
  408cc8:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408ccc:	9136e421 	add	x1, x1, #0xdb9
  408cd0:	17ffffd4 	b	408c20 <log_output_process+0x3bc>

0000000000408cd4 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg, uint32_t flags)
{
  408cd4:	d10143ff 	sub	sp, sp, #0x50
  408cd8:	a9017bfd 	stp	x29, x30, [sp, #16]
  408cdc:	910043fd 	add	x29, sp, #0x10
  408ce0:	a90253f3 	stp	x19, x20, [sp, #32]
  408ce4:	aa0003f4 	mov	x20, x0
  408ce8:	aa0103f3 	mov	x19, x1
  408cec:	a9035bf5 	stp	x21, x22, [sp, #48]
  408cf0:	2a0203f5 	mov	w21, w2
  408cf4:	f90023f7 	str	x23, [sp, #64]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg_get_source(struct log_msg *msg)
{
	return msg->hdr.source;
  408cf8:	a9400c20 	ldp	x0, x3, [x1]
 *
 * @return Timestamp.
 */
static inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)
{
	return msg->hdr.timestamp;
  408cfc:	b9400436 	ldr	w22, [x1, #4]
	return msg->hdr.desc.level;
  408d00:	d3462017 	ubfx	x23, x0, #6, #3
		/* Remote domain is converting source pointer to ID */
		source_id = (int16_t)(uintptr_t)log_msg_get_source(msg);
	} else {
		void *source = (void *)log_msg_get_source(msg);

		if (source != NULL) {
  408d04:	b4000143 	cbz	x3, 408d2c <log_output_msg_process+0x58>
  408d08:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  408d0c:	f9472c21 	ldr	x1, [x1, #3672]
  408d10:	cb010063 	sub	x3, x3, x1
  408d14:	d344fc63 	lsr	x3, x3, #4
			source_id = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
  408d18:	13003c61 	sxth	w1, w3
		} else {
			source_id = -1;
		}
	}

	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  408d1c:	377802c3 	tbnz	w3, #15, 408d74 <log_output_msg_process+0xa0>
  408d20:	53031400 	ubfx	w0, w0, #3, #3
  408d24:	97fffd8d 	bl	408358 <log_source_name_get>
  408d28:	aa0003e3 	mov	x3, x0
 *
 * @return pointer to the package.
 */
static inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;
  408d2c:	f8410667 	ldr	x7, [x19], #16
	size_t plen, dlen;
	uint8_t *package = log_msg_get_package(msg, &plen);
	uint8_t *data = log_msg_get_data(msg, &dlen);

	log_output_process(output, timestamp, NULL, sname, level,
  408d30:	b90003f5 	str	w21, [sp]
  408d34:	2a1703e4 	mov	w4, w23
  408d38:	2a1603e1 	mov	w1, w22
  408d3c:	d2800002 	mov	x2, #0x0                   	// #0
  408d40:	d3494ce0 	ubfx	x0, x7, #9, #11
  408d44:	53147ce7 	lsr	w7, w7, #20
  408d48:	f100001f 	cmp	x0, #0x0
	return msg->data + msg->hdr.desc.package_len;
  408d4c:	8b000266 	add	x6, x19, x0
  408d50:	9a9f1265 	csel	x5, x19, xzr, ne  // ne = any
  408d54:	aa1403e0 	mov	x0, x20
  408d58:	97fffec3 	bl	408864 <log_output_process>
			   plen > 0 ? package : NULL, data, dlen, flags);
}
  408d5c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  408d60:	a94253f3 	ldp	x19, x20, [sp, #32]
  408d64:	a9435bf5 	ldp	x21, x22, [sp, #48]
  408d68:	f94023f7 	ldr	x23, [sp, #64]
  408d6c:	910143ff 	add	sp, sp, #0x50
  408d70:	d65f03c0 	ret
	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  408d74:	d2800003 	mov	x3, #0x0                   	// #0
  408d78:	17ffffed 	b	408d2c <log_output_msg_process+0x58>

0000000000408d7c <log_output_timestamp_freq_set>:
		     output->control_block->ctx);
}

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
  408d7c:	b0000122 	adrp	x2, 42d000 <counter_period>
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  408d80:	52884804 	mov	w4, #0x4240                	// #16960
	timestamp_div = 1U;
  408d84:	52800021 	mov	w1, #0x1                   	// #1
	while (frequency > 1000000) {
  408d88:	52800003 	mov	w3, #0x0                   	// #0
	timestamp_div = 1U;
  408d8c:	b90ba841 	str	w1, [x2, #2984]
	while (frequency > 1000000) {
  408d90:	72a001e4 	movk	w4, #0xf, lsl #16
  408d94:	6b04001f 	cmp	w0, w4
  408d98:	540000c8 	b.hi	408db0 <log_output_timestamp_freq_set+0x34>  // b.pmore
  408d9c:	34000043 	cbz	w3, 408da4 <log_output_timestamp_freq_set+0x28>
  408da0:	b90ba841 	str	w1, [x2, #2984]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
  408da4:	b0000121 	adrp	x1, 42d000 <counter_period>
  408da8:	b90ba420 	str	w0, [x1, #2980]
}
  408dac:	d65f03c0 	ret
		frequency /= 2U;
  408db0:	53017c00 	lsr	w0, w0, #1
		timestamp_div *= 2U;
  408db4:	531f7821 	lsl	w1, w1, #1
  408db8:	52800023 	mov	w3, #0x1                   	// #1
  408dbc:	17fffff6 	b	408d94 <log_output_timestamp_freq_set+0x18>

0000000000408dc0 <format_set>:
	log_output_func(&log_output_posix, &msg->log, flags);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
	log_format_current = log_type;
  408dc0:	b0000120 	adrp	x0, 42d000 <counter_period>
  408dc4:	b90bac01 	str	w1, [x0, #2988]
	return 0;
}
  408dc8:	52800000 	mov	w0, #0x0                   	// #0
  408dcc:	d65f03c0 	ret

0000000000408dd0 <panic>:
	log_output_flush(&log_output_posix);
  408dd0:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  408dd4:	91210000 	add	x0, x0, #0x840
  408dd8:	17fffe96 	b	408830 <log_output_flush>

0000000000408ddc <char_out>:
{
  408ddc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  408de0:	910003fd 	mov	x29, sp
  408de4:	a90153f3 	stp	x19, x20, [sp, #16]
  408de8:	b0000134 	adrp	x20, 42d000 <counter_period>
  408dec:	aa0003f3 	mov	x19, x0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  408df0:	912ec294 	add	x20, x20, #0xbb0
{
  408df4:	a9025bf5 	stp	x21, x22, [sp, #32]
		posix_print_trace("%s\n", stdout_buff);
  408df8:	b0000135 	adrp	x21, 42d000 <counter_period>
{
  408dfc:	aa0103f6 	mov	x22, x1
		posix_print_trace("%s\n", stdout_buff);
  408e00:	913b52b5 	add	x21, x21, #0xed4
{
  408e04:	a90363f7 	stp	x23, x24, [sp, #48]
  408e08:	8b010017 	add	x23, x0, x1
		posix_print_trace("%s\n", stdout_buff);
  408e0c:	b0000078 	adrp	x24, 415000 <random_data+0xb30>
	for (size_t i = 0; i < length; i++) {
  408e10:	eb17027f 	cmp	x19, x23
  408e14:	540000e1 	b.ne	408e30 <char_out+0x54>  // b.any
}
  408e18:	2a1603e0 	mov	w0, w22
  408e1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  408e20:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408e24:	a94363f7 	ldp	x23, x24, [sp, #48]
  408e28:	a8c47bfd 	ldp	x29, x30, [sp], #64
  408e2c:	d65f03c0 	ret
		preprint_char(data[i]);
  408e30:	39400260 	ldrb	w0, [x19]
	if (c == '\r') {
  408e34:	7100341f 	cmp	w0, #0xd
  408e38:	54000240 	b.eq	408e80 <char_out+0xa4>  // b.none
	if (c != '\n') {
  408e3c:	7100281f 	cmp	w0, #0xa
  408e40:	54000240 	b.eq	408e88 <char_out+0xac>  // b.none
		stdout_buff[n_pend++] = c;
  408e44:	b9400282 	ldr	w2, [x20]
  408e48:	11000441 	add	w1, w2, #0x1
  408e4c:	b9000281 	str	w1, [x20]
  408e50:	3822caa0 	strb	w0, [x21, w2, sxtw]
	int printnow = 0;
  408e54:	52800000 	mov	w0, #0x0                   	// #0
		stdout_buff[n_pend] = 0;
  408e58:	3821cabf 	strb	wzr, [x21, w1, sxtw]
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  408e5c:	b9400281 	ldr	w1, [x20]
  408e60:	7103f83f 	cmp	w1, #0xfe
  408e64:	5400004c 	b.gt	408e6c <char_out+0x90>
	if (printnow) {
  408e68:	340000c0 	cbz	w0, 408e80 <char_out+0xa4>
		posix_print_trace("%s\n", stdout_buff);
  408e6c:	aa1503e1 	mov	x1, x21
  408e70:	912c6f00 	add	x0, x24, #0xb1b
  408e74:	94000628 	bl	40a714 <posix_print_trace>
		stdout_buff[0] = 0;
  408e78:	390002bf 	strb	wzr, [x21]
		n_pend = 0;
  408e7c:	b900029f 	str	wzr, [x20]
	for (size_t i = 0; i < length; i++) {
  408e80:	91000673 	add	x19, x19, #0x1
  408e84:	17ffffe3 	b	408e10 <char_out+0x34>
		printnow = 1;
  408e88:	52800020 	mov	w0, #0x1                   	// #1
  408e8c:	17fffff4 	b	408e5c <char_out+0x80>

0000000000408e90 <process>:
{
  408e90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408e94:	b0000120 	adrp	x0, 42d000 <counter_period>
{
  408e98:	910003fd 	mov	x29, sp
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408e9c:	b94bac00 	ldr	w0, [x0, #2988]
{
  408ea0:	f9000bf3 	str	x19, [sp, #16]
  408ea4:	aa0103f3 	mov	x19, x1
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408ea8:	97fffc5c 	bl	408018 <log_format_func_t_get>
  408eac:	aa0003f0 	mov	x16, x0
	log_output_func(&log_output_posix, &msg->log, flags);
  408eb0:	aa1303e1 	mov	x1, x19
  408eb4:	528001e2 	mov	w2, #0xf                   	// #15
}
  408eb8:	f9400bf3 	ldr	x19, [sp, #16]
	log_output_func(&log_output_posix, &msg->log, flags);
  408ebc:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
}
  408ec0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	log_output_func(&log_output_posix, &msg->log, flags);
  408ec4:	91210000 	add	x0, x0, #0x840
  408ec8:	d61f0200 	br	x16

0000000000408ecc <sys_trace_isr_enter>:
 *
 * SPDX-License-Identifier: Apache-2.0
 */


void sys_trace_isr_enter(void) {}
  408ecc:	d65f03c0 	ret

0000000000408ed0 <sys_trace_isr_exit>:
  408ed0:	d65f03c0 	ret

0000000000408ed4 <sys_trace_idle>:
  408ed4:	d65f03c0 	ret

0000000000408ed8 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
  408ed8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  408edc:	910003fd 	mov	x29, sp
	sys_trace_idle();
  408ee0:	97fffffd 	bl	408ed4 <sys_trace_idle>
	posix_irq_full_unlock();
  408ee4:	94000493 	bl	40a130 <posix_irq_full_unlock>
	posix_halt_cpu();
}
  408ee8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_halt_cpu();
  408eec:	140001d9 	b	409650 <posix_halt_cpu>

0000000000408ef0 <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
  408ef0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
  408ef4:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408ef8:	9137f800 	add	x0, x0, #0xdfe
{
  408efc:	910003fd 	mov	x29, sp
	posix_print_error_and_exit("Exiting due to fatal error\n");
  408f00:	9400059f 	bl	40a57c <posix_print_error_and_exit>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  408f04:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408f08:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408f0c:	91386821 	add	x1, x1, #0xe1a
  408f10:	9124f000 	add	x0, x0, #0x93c
  408f14:	528002a2 	mov	w2, #0x15                  	// #21
  408f18:	94000599 	bl	40a57c <posix_print_error_and_exit>

0000000000408f1c <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
  408f1c:	14000487 	b	40a138 <posix_irq_enable>

0000000000408f20 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
  408f20:	34000080 	cbz	w0, 408f30 <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  408f24:	90000060 	adrp	x0, 414000 <dlc_table.0+0x60d>
  408f28:	91391400 	add	x0, x0, #0xe45
  408f2c:	14000594 	b	40a57c <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
  408f30:	d65f03c0 	ret

0000000000408f34 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
  408f34:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408f38:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408f3c:	912f2000 	add	x0, x0, #0xbc8
{
  408f40:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408f44:	97ffe157 	bl	4014a0 <pthread_mutex_unlock@plt>
  408f48:	90000061 	adrp	x1, 414000 <dlc_table.0+0x60d>
  408f4c:	91397c21 	add	x1, x1, #0xe5f
  408f50:	97fffff4 	bl	408f20 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  408f54:	97ffe147 	bl	401470 <pthread_self@plt>
}
  408f58:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  408f5c:	17ffe119 	b	4013c0 <pthread_detach@plt>

0000000000408f60 <abort_tail>:
{
  408f60:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	threads_table[this_th_nbr].running = false;
  408f64:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408f68:	937b7c00 	sbfiz	x0, x0, #5, #32
{
  408f6c:	910003fd 	mov	x29, sp
	threads_table[this_th_nbr].running = false;
  408f70:	f945fc21 	ldr	x1, [x1, #3064]
  408f74:	8b000022 	add	x2, x1, x0
  408f78:	3900105f 	strb	wzr, [x2, #4]
	threads_table[this_th_nbr].state = ABORTED;
  408f7c:	52800062 	mov	w2, #0x3                   	// #3
  408f80:	b8206822 	str	w2, [x1, x0]
	posix_preexit_cleanup();
  408f84:	97ffffec 	bl	408f34 <posix_preexit_cleanup>
	pthread_exit(NULL);
  408f88:	d2800000 	mov	x0, #0x0                   	// #0
  408f8c:	97ffe0f9 	bl	401370 <pthread_exit@plt>

0000000000408f90 <posix_wait_until_allowed>:
{
  408f90:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  408f94:	910003fd 	mov	x29, sp
  408f98:	a9025bf5 	stp	x21, x22, [sp, #32]
	threads_table[this_th_nbr].running = false;
  408f9c:	90000135 	adrp	x21, 42c000 <__dso_handle>
	while (this_th_nbr != currently_allowed_thread) {
  408fa0:	b0000136 	adrp	x22, 42d000 <counter_period>
{
  408fa4:	a90153f3 	stp	x19, x20, [sp, #16]
	threads_table[this_th_nbr].running = false;
  408fa8:	937b7c14 	sbfiz	x20, x0, #5, #32
{
  408fac:	2a0003f3 	mov	w19, w0
	threads_table[this_th_nbr].running = false;
  408fb0:	f945fea0 	ldr	x0, [x21, #3064]
	while (this_th_nbr != currently_allowed_thread) {
  408fb4:	912ed2d6 	add	x22, x22, #0xbb4
{
  408fb8:	a90363f7 	stp	x23, x24, [sp, #48]
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408fbc:	90000137 	adrp	x23, 42c000 <__dso_handle>
	threads_table[this_th_nbr].running = false;
  408fc0:	8b140000 	add	x0, x0, x20
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408fc4:	90000138 	adrp	x24, 42c000 <__dso_handle>
  408fc8:	912f22f7 	add	x23, x23, #0xbc8
  408fcc:	912e6318 	add	x24, x24, #0xb98
	threads_table[this_th_nbr].running = false;
  408fd0:	3900101f 	strb	wzr, [x0, #4]
	while (this_th_nbr != currently_allowed_thread) {
  408fd4:	b94002c0 	ldr	w0, [x22]
  408fd8:	6b13001f 	cmp	w0, w19
  408fdc:	54000141 	b.ne	409004 <posix_wait_until_allowed+0x74>  // b.any
	threads_table[this_th_nbr].running = true;
  408fe0:	f945fea0 	ldr	x0, [x21, #3064]
  408fe4:	52800021 	mov	w1, #0x1                   	// #1
  408fe8:	8b140000 	add	x0, x0, x20
  408fec:	39001001 	strb	w1, [x0, #4]
}
  408ff0:	a94153f3 	ldp	x19, x20, [sp, #16]
  408ff4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408ff8:	a94363f7 	ldp	x23, x24, [sp, #48]
  408ffc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  409000:	d65f03c0 	ret
		pthread_cond_wait(&cond_threads, &mtx_threads);
  409004:	aa1703e1 	mov	x1, x23
  409008:	aa1803e0 	mov	x0, x24
  40900c:	97ffe0f9 	bl	4013f0 <pthread_cond_wait@plt>
		if (threads_table &&
  409010:	f945fea0 	ldr	x0, [x21, #3064]
  409014:	b4fffe00 	cbz	x0, 408fd4 <posix_wait_until_allowed+0x44>
  409018:	b8746800 	ldr	w0, [x0, x20]
  40901c:	7100081f 	cmp	w0, #0x2
  409020:	54fffda1 	b.ne	408fd4 <posix_wait_until_allowed+0x44>  // b.any
			abort_tail(this_th_nbr);
  409024:	2a1303e0 	mov	w0, w19
  409028:	97ffffce 	bl	408f60 <abort_tail>

000000000040902c <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
  40902c:	90000120 	adrp	x0, 42d000 <counter_period>
  409030:	397f5000 	ldrb	w0, [x0, #4052]
  409034:	34000180 	cbz	w0, 409064 <posix_cleanup_handler+0x38>
{
  409038:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  40903c:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409040:	912f2000 	add	x0, x0, #0xbc8
{
  409044:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  409048:	97ffe116 	bl	4014a0 <pthread_mutex_unlock@plt>
  40904c:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x60d>
  409050:	91397c21 	add	x1, x1, #0xe5f
  409054:	97ffffb3 	bl	408f20 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  409058:	97ffe106 	bl	401470 <pthread_self@plt>
}
  40905c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  409060:	17ffe0d8 	b	4013c0 <pthread_detach@plt>
  409064:	d65f03c0 	ret

0000000000409068 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
  409068:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  40906c:	910003fd 	mov	x29, sp
  409070:	f9000be0 	str	x0, [sp, #16]
  409074:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409078:	f9476800 	ldr	x0, [x0, #3792]
  40907c:	f9400001 	ldr	x1, [x0]
  409080:	f9007fe1 	str	x1, [sp, #248]
  409084:	d2800001 	mov	x1, #0x0                   	// #0

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  409088:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  40908c:	912f2000 	add	x0, x0, #0xbc8
  409090:	97ffe100 	bl	401490 <pthread_mutex_lock@plt>
  409094:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x60d>
  409098:	913a0821 	add	x1, x1, #0xe82
  40909c:	97ffffa1 	bl	408f20 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
  4090a0:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  4090a4:	f945fc00 	ldr	x0, [x0, #3064]
  4090a8:	b50000a0 	cbnz	x0, 4090bc <posix_thread_starter+0x54>
		posix_cleanup_handler(arg);
  4090ac:	f9400be0 	ldr	x0, [sp, #16]
  4090b0:	97ffffdf 	bl	40902c <posix_cleanup_handler>
		pthread_exit(NULL);
  4090b4:	d2800000 	mov	x0, #0x0                   	// #0
  4090b8:	97ffe0ae 	bl	401370 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
  4090bc:	90000000 	adrp	x0, 409000 <posix_wait_until_allowed+0x70>
  4090c0:	9100b000 	add	x0, x0, #0x2c
  4090c4:	52800001 	mov	w1, #0x0                   	// #0
  4090c8:	f9000fe0 	str	x0, [sp, #24]
  4090cc:	910083e0 	add	x0, sp, #0x20
  4090d0:	97ffe04c 	bl	401200 <__sigsetjmp@plt>
  4090d4:	340000a0 	cbz	w0, 4090e8 <posix_thread_starter+0x80>
  4090d8:	a94107e0 	ldp	x0, x1, [sp, #16]
  4090dc:	d63f0020 	blr	x1
  4090e0:	910083e0 	add	x0, sp, #0x20
  4090e4:	97ffe0cb 	bl	401410 <__pthread_unwind_next@plt>
  4090e8:	910083e0 	add	x0, sp, #0x20
  4090ec:	97ffe0dd 	bl	401460 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
  4090f0:	b94013e0 	ldr	w0, [sp, #16]
  4090f4:	97ffffa7 	bl	408f90 <posix_wait_until_allowed>

	posix_new_thread_pre_start();
  4090f8:	94000108 	bl	409518 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
  4090fc:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409100:	b94013e0 	ldr	w0, [sp, #16]
  409104:	f945fc21 	ldr	x1, [x1, #3064]
  409108:	937b7c00 	sbfiz	x0, x0, #5, #32
  40910c:	8b000020 	add	x0, x1, x0
  409110:	f9400c00 	ldr	x0, [x0, #24]

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
  409114:	a9410c02 	ldp	x2, x3, [x0, #16]
  409118:	f9400401 	ldr	x1, [x0, #8]
  40911c:	f9400000 	ldr	x0, [x0]
  409120:	97fff568 	bl	4066c0 <z_thread_entry>

0000000000409124 <posix_swap>:
{
  409124:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409128:	910003fd 	mov	x29, sp
  40912c:	f9000bf3 	str	x19, [sp, #16]
  409130:	2a0103f3 	mov	w19, w1
	currently_allowed_thread = next_allowed_th;
  409134:	90000121 	adrp	x1, 42d000 <counter_period>
  409138:	b90bb420 	str	w0, [x1, #2996]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  40913c:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409140:	912e6000 	add	x0, x0, #0xb98
  409144:	97ffe067 	bl	4012e0 <pthread_cond_broadcast@plt>
  409148:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x60d>
  40914c:	913a8c21 	add	x1, x1, #0xea3
  409150:	97ffff74 	bl	408f20 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
  409154:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409158:	937b7e60 	sbfiz	x0, x19, #5, #32
  40915c:	f945fc21 	ldr	x1, [x1, #3064]
  409160:	b8606820 	ldr	w0, [x1, x0]
  409164:	7100081f 	cmp	w0, #0x2
		abort_tail(this_th_nbr);
  409168:	2a1303e0 	mov	w0, w19
	if (threads_table[this_th_nbr].state == ABORTING) {
  40916c:	54000041 	b.ne	409174 <posix_swap+0x50>  // b.any
		abort_tail(this_th_nbr);
  409170:	97ffff7c 	bl	408f60 <abort_tail>
}
  409174:	f9400bf3 	ldr	x19, [sp, #16]
  409178:	a8c27bfd 	ldp	x29, x30, [sp], #32
		posix_wait_until_allowed(this_th_nbr);
  40917c:	17ffff85 	b	408f90 <posix_wait_until_allowed>

0000000000409180 <posix_main_thread_start>:
{
  409180:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	currently_allowed_thread = next_allowed_th;
  409184:	90000121 	adrp	x1, 42d000 <counter_period>
{
  409188:	910003fd 	mov	x29, sp
	currently_allowed_thread = next_allowed_th;
  40918c:	b90bb420 	str	w0, [x1, #2996]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  409190:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409194:	912e6000 	add	x0, x0, #0xb98
  409198:	97ffe052 	bl	4012e0 <pthread_cond_broadcast@plt>
  40919c:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x60d>
  4091a0:	913a8c21 	add	x1, x1, #0xea3
  4091a4:	97ffff5f 	bl	408f20 <pc_safe_call>
	posix_preexit_cleanup();
  4091a8:	97ffff63 	bl	408f34 <posix_preexit_cleanup>
	pthread_exit(NULL);
  4091ac:	d2800000 	mov	x0, #0x0                   	// #0
  4091b0:	97ffe070 	bl	401370 <pthread_exit@plt>

00000000004091b4 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
  4091b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (int i = 0; i < threads_table_size; i++) {
  4091b8:	d2800002 	mov	x2, #0x0                   	// #0
{
  4091bc:	910003fd 	mov	x29, sp
  4091c0:	a9025bf5 	stp	x21, x22, [sp, #32]
		if ((threads_table[i].state == NOTUSED)
  4091c4:	f0000115 	adrp	x21, 42c000 <__dso_handle>
	for (int i = 0; i < threads_table_size; i++) {
  4091c8:	90000136 	adrp	x22, 42d000 <counter_period>
{
  4091cc:	a90153f3 	stp	x19, x20, [sp, #16]
  4091d0:	aa0003f4 	mov	x20, x0
	for (int i = 0; i < threads_table_size; i++) {
  4091d4:	b94bbec1 	ldr	w1, [x22, #3004]
		if ((threads_table[i].state == NOTUSED)
  4091d8:	f945fea0 	ldr	x0, [x21, #3064]
  4091dc:	d1008003 	sub	x3, x0, #0x20
  4091e0:	2a0203f3 	mov	w19, w2
	for (int i = 0; i < threads_table_size; i++) {
  4091e4:	6b02003f 	cmp	w1, w2
  4091e8:	5400026c 	b.gt	409234 <posix_new_thread+0x80>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
  4091ec:	11010021 	add	w1, w1, #0x40
	threads_table = realloc(threads_table,
  4091f0:	937b7c21 	sbfiz	x1, x1, #5, #32
  4091f4:	97ffe043 	bl	401300 <realloc@plt>
  4091f8:	f905fea0 	str	x0, [x21, #3064]
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  4091fc:	b5000080 	cbnz	x0, 40920c <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  409200:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  409204:	913b2400 	add	x0, x0, #0xec9
  409208:	940004dd 	bl	40a57c <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
  40920c:	b94bbed3 	ldr	w19, [x22, #3004]
  return __builtin___memset_chk (__dest, __ch, __len,
  409210:	d2810002 	mov	x2, #0x800                 	// #2048
  409214:	f945fea3 	ldr	x3, [x21, #3064]
  409218:	52800001 	mov	w1, #0x0                   	// #0
  40921c:	937b7e60 	sbfiz	x0, x19, #5, #32
  409220:	8b000060 	add	x0, x3, x0
  409224:	97ffe01f 	bl	4012a0 <memset@plt>
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
  409228:	11010260 	add	w0, w19, #0x40
  40922c:	b90bbec0 	str	w0, [x22, #3004]
	return threads_table_size - PC_ALLOC_CHUNK_SIZE;
  409230:	14000005 	b	409244 <posix_new_thread+0x90>
		if ((threads_table[i].state == NOTUSED)
  409234:	91000442 	add	x2, x2, #0x1
  409238:	d37be844 	lsl	x4, x2, #5
  40923c:	b8646864 	ldr	w4, [x3, x4]
  409240:	35fffd04 	cbnz	w4, 4091e0 <posix_new_thread+0x2c>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
  409244:	f945fea1 	ldr	x1, [x21, #3064]
  409248:	937b7e60 	sbfiz	x0, x19, #5, #32
  40924c:	52800022 	mov	w2, #0x1                   	// #1
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409250:	93407e63 	sxtw	x3, w19
	threads_table[t_slot].state = USED;
  409254:	8b000024 	add	x4, x1, x0
  409258:	b8206822 	str	w2, [x1, x0]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  40925c:	90000121 	adrp	x1, 42d000 <counter_period>
  409260:	b94bb820 	ldr	w0, [x1, #3000]
	threads_table[t_slot].running = false;
  409264:	3900109f 	strb	wzr, [x4, #4]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  409268:	b9001080 	str	w0, [x4, #16]
  40926c:	0b020002 	add	w2, w0, w2
	threads_table[t_slot].t_status = ptr;
  409270:	f9000c94 	str	x20, [x4, #24]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409274:	91002080 	add	x0, x4, #0x8
	ptr->thread_idx = t_slot;
  409278:	b9002293 	str	w19, [x20, #32]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  40927c:	b90bb822 	str	w2, [x1, #3000]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409280:	d2800001 	mov	x1, #0x0                   	// #0
  409284:	90000002 	adrp	x2, 409000 <posix_wait_until_allowed+0x70>
  409288:	9101a042 	add	x2, x2, #0x68
  40928c:	97ffe069 	bl	401430 <pthread_create@plt>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
  409290:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409294:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x60d>
}
  409298:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  40929c:	913bc421 	add	x1, x1, #0xef1
}
  4092a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  4092a4:	17ffff1f 	b	408f20 <pc_safe_call>

00000000004092a8 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
  4092a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_create_count = 0;
  4092ac:	90000120 	adrp	x0, 42d000 <counter_period>

	currently_allowed_thread = -1;
  4092b0:	12800001 	mov	w1, #0xffffffff            	// #-1
{
  4092b4:	910003fd 	mov	x29, sp
	thread_create_count = 0;
  4092b8:	b90bb81f 	str	wzr, [x0, #3000]
	currently_allowed_thread = -1;
  4092bc:	90000120 	adrp	x0, 42d000 <counter_period>
  4092c0:	b90bb401 	str	w1, [x0, #2996]

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
  4092c4:	d2800401 	mov	x1, #0x20                  	// #32
  4092c8:	d2800800 	mov	x0, #0x40                  	// #64
  4092cc:	97ffe001 	bl	4012d0 <calloc@plt>
  4092d0:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  4092d4:	f905fc20 	str	x0, [x1, #3064]
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  4092d8:	b5000080 	cbnz	x0, 4092e8 <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  4092dc:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4092e0:	913b2400 	add	x0, x0, #0xec9
  4092e4:	940004a6 	bl	40a57c <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
  4092e8:	52800801 	mov	w1, #0x40                  	// #64
  4092ec:	90000120 	adrp	x0, 42d000 <counter_period>
  4092f0:	b90bbc01 	str	w1, [x0, #3004]


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  4092f4:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  4092f8:	912f2000 	add	x0, x0, #0xbc8
  4092fc:	97ffe065 	bl	401490 <pthread_mutex_lock@plt>
}
  409300:	a8c17bfd 	ldp	x29, x30, [sp], #16
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  409304:	f0000041 	adrp	x1, 414000 <dlc_table.0+0x60d>
  409308:	913a0821 	add	x1, x1, #0xe82
  40930c:	17ffff05 	b	408f20 <pc_safe_call>

0000000000409310 <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
  409310:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  409314:	910003fd 	mov	x29, sp
  409318:	a9025bf5 	stp	x21, x22, [sp, #32]

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  40931c:	f0000115 	adrp	x21, 42c000 <__dso_handle>
  409320:	f945fea0 	ldr	x0, [x21, #3064]
{
  409324:	a90153f3 	stp	x19, x20, [sp, #16]
  409328:	f9001bf7 	str	x23, [sp, #48]
	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  40932c:	b4000200 	cbz	x0, 40936c <posix_core_clean_up+0x5c>
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;
  409330:	90000120 	adrp	x0, 42d000 <counter_period>

	for (int i = 0; i < threads_table_size; i++) {
  409334:	90000134 	adrp	x20, 42d000 <counter_period>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
  409338:	f0000056 	adrp	x22, 414000 <dlc_table.0+0x60d>
	for (int i = 0; i < threads_table_size; i++) {
  40933c:	912ef294 	add	x20, x20, #0xbbc
			posix_print_warning(
  409340:	913d56d6 	add	x22, x22, #0xf55
	terminate = true;
  409344:	52800021 	mov	w1, #0x1                   	// #1
	for (int i = 0; i < threads_table_size; i++) {
  409348:	d2800013 	mov	x19, #0x0                   	// #0
	terminate = true;
  40934c:	393f5001 	strb	w1, [x0, #4052]
	for (int i = 0; i < threads_table_size; i++) {
  409350:	b9400281 	ldr	w1, [x20]
		if (threads_table[i].state != USED) {
  409354:	912fe2b7 	add	x23, x21, #0xbf8
  409358:	f945fea0 	ldr	x0, [x21, #3064]
	for (int i = 0; i < threads_table_size; i++) {
  40935c:	6b13003f 	cmp	w1, w19
  409360:	5400010c 	b.gt	409380 <posix_core_clean_up+0x70>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
  409364:	97ffe01f 	bl	4013e0 <free@plt>
	threads_table = NULL;
  409368:	f90002ff 	str	xzr, [x23]
}
  40936c:	a94153f3 	ldp	x19, x20, [sp, #16]
  409370:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409374:	f9401bf7 	ldr	x23, [sp, #48]
  409378:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40937c:	d65f03c0 	ret
		if (threads_table[i].state != USED) {
  409380:	d37bea61 	lsl	x1, x19, #5
  409384:	8b131402 	add	x2, x0, x19, lsl #5
  409388:	b8616800 	ldr	w0, [x0, x1]
  40938c:	7100041f 	cmp	w0, #0x1
  409390:	540000e1 	b.ne	4093ac <posix_core_clean_up+0x9c>  // b.any
		if (pthread_cancel(threads_table[i].thread)) {
  409394:	f9400440 	ldr	x0, [x2, #8]
  409398:	97ffe03a 	bl	401480 <pthread_cancel@plt>
  40939c:	34000080 	cbz	w0, 4093ac <posix_core_clean_up+0x9c>
			posix_print_warning(
  4093a0:	2a1303e1 	mov	w1, w19
  4093a4:	aa1603e0 	mov	x0, x22
  4093a8:	940004a9 	bl	40a64c <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
  4093ac:	91000673 	add	x19, x19, #0x1
  4093b0:	17ffffe8 	b	409350 <posix_core_clean_up+0x40>

00000000004093b4 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
  4093b4:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  4093b8:	937b7c00 	sbfiz	x0, x0, #5, #32
  4093bc:	f945fc21 	ldr	x1, [x1, #3064]
  4093c0:	b8606822 	ldr	w2, [x1, x0]
  4093c4:	7100045f 	cmp	w2, #0x1
  4093c8:	54000061 	b.ne	4093d4 <posix_abort_thread+0x20>  // b.any

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
  4093cc:	52800042 	mov	w2, #0x2                   	// #2
  4093d0:	b8206822 	str	w2, [x1, x0]
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
  4093d4:	d65f03c0 	ret

00000000004093d8 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
  4093d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4093dc:	910003fd 	mov	x29, sp
  4093e0:	a90153f3 	stp	x19, x20, [sp, #16]
  4093e4:	aa0003f4 	mov	x20, x0
  4093e8:	a9025bf5 	stp	x21, x22, [sp, #32]
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
  4093ec:	f9402813 	ldr	x19, [x0, #80]
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
  4093f0:	b9402276 	ldr	w22, [x19, #32]
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
  4093f4:	9400034c 	bl	40a124 <posix_irq_lock>
  4093f8:	2a0003f5 	mov	w21, w0

	key = irq_lock();

	if (_current == thread) {
  4093fc:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409400:	f9473000 	ldr	x0, [x0, #3680]
  409404:	f9400800 	ldr	x0, [x0, #16]
  409408:	eb14001f 	cmp	x0, x20
  40940c:	54000141 	b.ne	409434 <z_impl_k_thread_abort+0x5c>  // b.any
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
  409410:	b9402660 	ldr	w0, [x19, #36]
  409414:	350002a0 	cbnz	w0, 409468 <z_impl_k_thread_abort+0x90>
			tstatus->aborted = 1;
  409418:	52800020 	mov	w0, #0x1                   	// #1
  40941c:	b9002660 	str	w0, [x19, #36]
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
  409420:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409424:	937b7ec0 	sbfiz	x0, x22, #5, #32
  409428:	52800042 	mov	w2, #0x2                   	// #2
  40942c:	f945fc21 	ldr	x1, [x1, #3064]
  409430:	b8206822 	str	w2, [x1, x0]
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
  409434:	aa1403e0 	mov	x0, x20
  409438:	940023d9 	bl	41239c <z_thread_abort>

	if (tstatus->aborted == 0) {
  40943c:	b9402660 	ldr	w0, [x19, #36]
  409440:	350000a0 	cbnz	w0, 409454 <z_impl_k_thread_abort+0x7c>
		PC_DEBUG("%s aborting now [%i] %i\n",
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
  409444:	52800020 	mov	w0, #0x1                   	// #1
  409448:	b9002660 	str	w0, [x19, #36]
		posix_abort_thread(thread_idx);
  40944c:	2a1603e0 	mov	w0, w22
  409450:	97ffffd9 	bl	4093b4 <posix_abort_thread>
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
  409454:	2a1503e0 	mov	w0, w21
}
  409458:	a94153f3 	ldp	x19, x20, [sp, #16]
  40945c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409460:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule_irqlock(key);
  409464:	14001cc0 	b	410764 <z_reschedule_irqlock>
			posix_print_warning(/* LCOV_EXCL_LINE */
  409468:	2a1603e1 	mov	w1, w22
  40946c:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  409470:	913e2400 	add	x0, x0, #0xf89
  409474:	94000476 	bl	40a64c <posix_print_warning>
  409478:	17ffffea 	b	409420 <z_impl_k_thread_abort+0x48>

000000000040947c <arch_swap>:
#include <zephyr/irq.h>
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
  40947c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409480:	910003fd 	mov	x29, sp
  409484:	f9000bf3 	str	x19, [sp, #16]
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
  409488:	d0000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  40948c:	f9473273 	ldr	x19, [x19, #3680]
  409490:	f9400a61 	ldr	x1, [x19, #16]
  409494:	b9004820 	str	w0, [x1, #72]
	_current->callee_saved.retval = -EAGAIN;
  409498:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40949c:	b9004c20 	str	w0, [x1, #76]
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
  4094a0:	f9401660 	ldr	x0, [x19, #40]
	posix_thread_status_t *this_thread_ptr  =
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
  4094a4:	f9000a60 	str	x0, [x19, #16]
	posix_thread_status_t *this_thread_ptr  =
  4094a8:	f9402821 	ldr	x1, [x1, #80]
	posix_thread_status_t *ready_thread_ptr =
  4094ac:	f9402802 	ldr	x2, [x0, #80]
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
  4094b0:	b9402021 	ldr	w1, [x1, #32]
  4094b4:	b9402040 	ldr	w0, [x2, #32]
  4094b8:	97ffff1b 	bl	409124 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
  4094bc:	f9400a60 	ldr	x0, [x19, #16]
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
  4094c0:	b9404800 	ldr	w0, [x0, #72]
  4094c4:	9400031a 	bl	40a12c <posix_irq_unlock>

	return _current->callee_saved.retval;
  4094c8:	f9400a60 	ldr	x0, [x19, #16]
}
  4094cc:	f9400bf3 	ldr	x19, [sp, #16]
  4094d0:	b9404c00 	ldr	w0, [x0, #76]
  4094d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4094d8:	d65f03c0 	ret

00000000004094dc <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
  4094dc:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4094e0:	f9473000 	ldr	x0, [x0, #3680]
  4094e4:	f9401401 	ldr	x1, [x0, #40]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
  4094e8:	f9000801 	str	x1, [x0, #16]
	posix_thread_status_t *ready_thread_ptr =
  4094ec:	f9402822 	ldr	x2, [x1, #80]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
  4094f0:	b9402040 	ldr	w0, [x2, #32]
  4094f4:	17ffff23 	b	409180 <posix_main_thread_start>

00000000004094f8 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
  4094f8:	aa0003e1 	mov	x1, x0
	posix_thread_status_t *thread_status;

	/* We store it in the same place where normal archs store the
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
  4094fc:	d100a040 	sub	x0, x2, #0x28

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
  409500:	f81d8043 	stur	x3, [x2, #-40]
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
  409504:	a9009404 	stp	x4, x5, [x0, #8]
	thread_status->arg3 = p3;
  409508:	f9000c06 	str	x6, [x0, #24]
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
  40950c:	b900241f 	str	wzr, [x0, #36]
#endif

	thread->callee_saved.thread_status = thread_status;
  409510:	f9002820 	str	x0, [x1, #80]

	posix_new_thread(thread_status);
  409514:	17ffff28 	b	4091b4 <posix_new_thread>

0000000000409518 <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
  409518:	14000306 	b	40a130 <posix_irq_full_unlock>

000000000040951c <pc_safe_call>:
	if (unlikely(test)) {
  40951c:	34000080 	cbz	w0, 40952c <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  409520:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  409524:	91391400 	add	x0, x0, #0xe45
  409528:	14000415 	b	40a57c <posix_print_error_and_exit>
}
  40952c:	d65f03c0 	ret

0000000000409530 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
  409530:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409534:	910003fd 	mov	x29, sp
  409538:	f9000bf3 	str	x19, [sp, #16]
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  40953c:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409540:	9130c273 	add	x19, x19, #0xc30
  409544:	aa1303e0 	mov	x0, x19
  409548:	97ffdfd2 	bl	401490 <pthread_mutex_lock@plt>
  40954c:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  409550:	91001421 	add	x1, x1, #0x5
  409554:	97fffff2 	bl	40951c <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409558:	aa1303e0 	mov	x0, x19
  40955c:	97ffdfd1 	bl	4014a0 <pthread_mutex_unlock@plt>
  409560:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  409564:	91008821 	add	x1, x1, #0x22
  409568:	97ffffed 	bl	40951c <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
  40956c:	97ffff4f 	bl	4092a8 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
  409570:	94001168 	bl	40db10 <z_cstart>

0000000000409574 <posix_is_cpu_running>:
	return !cpu_halted;
  409574:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409578:	39504000 	ldrb	w0, [x0, #1040]
}
  40957c:	52000000 	eor	w0, w0, #0x1
  409580:	d65f03c0 	ret

0000000000409584 <posix_change_cpu_state_and_wait>:
{
  409584:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  409588:	910003fd 	mov	x29, sp
  40958c:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409590:	f0000115 	adrp	x21, 42c000 <__dso_handle>
{
  409594:	12001c16 	and	w22, w0, #0xff
  409598:	f9001bf7 	str	x23, [sp, #48]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  40959c:	9130c2b7 	add	x23, x21, #0xc30
  4095a0:	aa1703e0 	mov	x0, x23
{
  4095a4:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4095a8:	97ffdfba 	bl	401490 <pthread_mutex_lock@plt>
	cpu_halted = halted;
  4095ac:	f0000113 	adrp	x19, 42c000 <__dso_handle>
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4095b0:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  4095b4:	91001421 	add	x1, x1, #0x5
  4095b8:	97ffffd9 	bl	40951c <pc_safe_call>
	cpu_halted = halted;
  4095bc:	39104276 	strb	w22, [x19, #1040]
	while (cpu_halted == halted) {
  4095c0:	91104273 	add	x19, x19, #0x410
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  4095c4:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  4095c8:	91300294 	add	x20, x20, #0xc00
  4095cc:	aa1403e0 	mov	x0, x20
  4095d0:	97ffdf44 	bl	4012e0 <pthread_cond_broadcast@plt>
  4095d4:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  4095d8:	91010421 	add	x1, x1, #0x41
  4095dc:	97ffffd0 	bl	40951c <pc_safe_call>
	while (cpu_halted == halted) {
  4095e0:	39400260 	ldrb	w0, [x19]
  4095e4:	6b16001f 	cmp	w0, w22
  4095e8:	54000140 	b.eq	409610 <posix_change_cpu_state_and_wait+0x8c>  // b.none
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  4095ec:	9130c2a0 	add	x0, x21, #0xc30
  4095f0:	97ffdfac 	bl	4014a0 <pthread_mutex_unlock@plt>
}
  4095f4:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  4095f8:	90000061 	adrp	x1, 415000 <random_data+0xb30>
}
  4095fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409600:	91008821 	add	x1, x1, #0x22
}
  409604:	f9401bf7 	ldr	x23, [sp, #48]
  409608:	a8c47bfd 	ldp	x29, x30, [sp], #64
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  40960c:	17ffffc4 	b	40951c <pc_safe_call>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  409610:	aa1703e1 	mov	x1, x23
  409614:	aa1403e0 	mov	x0, x20
  409618:	97ffdf76 	bl	4013f0 <pthread_cond_wait@plt>
  40961c:	17fffff1 	b	4095e0 <posix_change_cpu_state_and_wait+0x5c>

0000000000409620 <posix_interrupt_raised>:
{
  409620:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(false);
  409624:	52800000 	mov	w0, #0x0                   	// #0
{
  409628:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(false);
  40962c:	97ffffd6 	bl	409584 <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
  409630:	90000120 	adrp	x0, 42d000 <counter_period>
  409634:	397f5400 	ldrb	w0, [x0, #4053]
  409638:	34000080 	cbz	w0, 409648 <posix_interrupt_raised+0x28>
}
  40963c:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_exit(0);
  409640:	52800000 	mov	w0, #0x0                   	// #0
  409644:	14000378 	b	40a424 <posix_exit>
}
  409648:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40964c:	d65f03c0 	ret

0000000000409650 <posix_halt_cpu>:
{
  409650:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(true);
  409654:	52800020 	mov	w0, #0x1                   	// #1
{
  409658:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(true);
  40965c:	97ffffca 	bl	409584 <posix_change_cpu_state_and_wait>
}
  409660:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_irq_handler();
  409664:	14000245 	b	409f78 <posix_irq_handler>

0000000000409668 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
  409668:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40966c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409670:	910003fd 	mov	x29, sp
  409674:	f9476800 	ldr	x0, [x0, #3792]
  409678:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));

	cpu_halted = false;
  40967c:	f0000113 	adrp	x19, 42c000 <__dso_handle>
{
  409680:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409684:	f0000115 	adrp	x21, 42c000 <__dso_handle>
  409688:	9130c2b6 	add	x22, x21, #0xc30
{
  40968c:	f9400001 	ldr	x1, [x0]
  409690:	f9001fe1 	str	x1, [sp, #56]
  409694:	d2800001 	mov	x1, #0x0                   	// #0
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409698:	aa1603e0 	mov	x0, x22
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  40969c:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  4096a0:	91300294 	add	x20, x20, #0xc00
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4096a4:	97ffdf7b 	bl	401490 <pthread_mutex_lock@plt>
  4096a8:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  4096ac:	91001421 	add	x1, x1, #0x5
  4096b0:	97ffff9b 	bl	40951c <pc_safe_call>
	cpu_halted = false;
  4096b4:	3910427f 	strb	wzr, [x19, #1040]
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  4096b8:	90000002 	adrp	x2, 409000 <posix_wait_until_allowed+0x70>
	while (cpu_halted == false) {
  4096bc:	91104273 	add	x19, x19, #0x410
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  4096c0:	9114c042 	add	x2, x2, #0x530
  4096c4:	d2800003 	mov	x3, #0x0                   	// #0
  4096c8:	d2800001 	mov	x1, #0x0                   	// #0
  4096cc:	9100c3e0 	add	x0, sp, #0x30
  4096d0:	97ffdf58 	bl	401430 <pthread_create@plt>
  4096d4:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  4096d8:	91018c21 	add	x1, x1, #0x63
  4096dc:	97ffff90 	bl	40951c <pc_safe_call>
	while (cpu_halted == false) {
  4096e0:	39400260 	ldrb	w0, [x19]
  4096e4:	34000260 	cbz	w0, 409730 <posix_boot_cpu+0xc8>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  4096e8:	9130c2a0 	add	x0, x21, #0xc30
  4096ec:	97ffdf6d 	bl	4014a0 <pthread_mutex_unlock@plt>
  4096f0:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  4096f4:	91008821 	add	x1, x1, #0x22
  4096f8:	97ffff89 	bl	40951c <pc_safe_call>

	if (soc_terminate) {
  4096fc:	90000120 	adrp	x0, 42d000 <counter_period>
  409700:	397f5400 	ldrb	w0, [x0, #4053]
  409704:	34000060 	cbz	w0, 409710 <posix_boot_cpu+0xa8>
		posix_exit(0);
  409708:	52800000 	mov	w0, #0x0                   	// #0
  40970c:	94000346 	bl	40a424 <posix_exit>
	}
}
  409710:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409714:	f9476800 	ldr	x0, [x0, #3792]
  409718:	f9401fe2 	ldr	x2, [sp, #56]
  40971c:	f9400001 	ldr	x1, [x0]
  409720:	eb010042 	subs	x2, x2, x1
  409724:	d2800001 	mov	x1, #0x0                   	// #0
  409728:	540000c0 	b.eq	409740 <posix_boot_cpu+0xd8>  // b.none
  40972c:	97ffdefd 	bl	401320 <__stack_chk_fail@plt>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  409730:	aa1603e1 	mov	x1, x22
  409734:	aa1403e0 	mov	x0, x20
  409738:	97ffdf2e 	bl	4013f0 <pthread_cond_wait@plt>
  40973c:	17ffffe9 	b	4096e0 <posix_boot_cpu+0x78>
}
  409740:	a94153f3 	ldp	x19, x20, [sp, #16]
  409744:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409748:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40974c:	d65f03c0 	ret

0000000000409750 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
  409750:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  409754:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  409758:	91258021 	add	x1, x1, #0x960
{
  40975c:	910003fd 	mov	x29, sp
  409760:	a90153f3 	stp	x19, x20, [sp, #16]
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  409764:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
  409768:	11000400 	add	w0, w0, #0x1
  40976c:	f860d834 	ldr	x20, [x1, w0, sxtw #3]
  409770:	eb13029f 	cmp	x20, x19
  409774:	54000088 	b.hi	409784 <run_native_tasks+0x34>  // b.pmore
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
			(*fptr)();
		}
	}
}
  409778:	a94153f3 	ldp	x19, x20, [sp, #16]
  40977c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  409780:	d65f03c0 	ret
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
  409784:	f9400260 	ldr	x0, [x19]
  409788:	b4000040 	cbz	x0, 409790 <run_native_tasks+0x40>
			(*fptr)();
  40978c:	d63f0000 	blr	x0
		fptr++) {
  409790:	91002273 	add	x19, x19, #0x8
  409794:	17fffff7 	b	409770 <run_native_tasks+0x20>

0000000000409798 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
  409798:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40979c:	910003fd 	mov	x29, sp
  4097a0:	a90153f3 	stp	x19, x20, [sp, #16]
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
  4097a4:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  4097a8:	39504280 	ldrb	w0, [x20, #1040]
{
  4097ac:	f90013f5 	str	x21, [sp, #32]
	if (cpu_halted) {
  4097b0:	340000e0 	cbz	w0, 4097cc <posix_soc_clean_up+0x34>

		posix_core_clean_up();
  4097b4:	97fffed7 	bl	409310 <posix_core_clean_up>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
  4097b8:	a94153f3 	ldp	x19, x20, [sp, #16]
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  4097bc:	52800080 	mov	w0, #0x4                   	// #4
}
  4097c0:	f94013f5 	ldr	x21, [sp, #32]
  4097c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  4097c8:	17ffffe2 	b	409750 <run_native_tasks>
	} else if (soc_terminate == false) {
  4097cc:	90000120 	adrp	x0, 42d000 <counter_period>
  4097d0:	397f5401 	ldrb	w1, [x0, #4053]
  4097d4:	35000321 	cbnz	w1, 409838 <posix_soc_clean_up+0xa0>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4097d8:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  4097dc:	9130c273 	add	x19, x19, #0xc30
		soc_terminate = true;
  4097e0:	52800035 	mov	w21, #0x1                   	// #1
  4097e4:	393f5415 	strb	w21, [x0, #4053]
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4097e8:	aa1303e0 	mov	x0, x19
  4097ec:	97ffdf29 	bl	401490 <pthread_mutex_lock@plt>
  4097f0:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  4097f4:	91001421 	add	x1, x1, #0x5
  4097f8:	97ffff49 	bl	40951c <pc_safe_call>
		cpu_halted = true;
  4097fc:	39104295 	strb	w21, [x20, #1040]
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  409800:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409804:	91300000 	add	x0, x0, #0xc00
  409808:	97ffdeb6 	bl	4012e0 <pthread_cond_broadcast@plt>
  40980c:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  409810:	91010421 	add	x1, x1, #0x41
  409814:	97ffff42 	bl	40951c <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409818:	aa1303e0 	mov	x0, x19
  40981c:	97ffdf21 	bl	4014a0 <pthread_mutex_unlock@plt>
  409820:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  409824:	91008821 	add	x1, x1, #0x22
  409828:	97ffff3d 	bl	40951c <pc_safe_call>
			sleep(1);
  40982c:	52800020 	mov	w0, #0x1                   	// #1
  409830:	97ffdea0 	bl	4012b0 <sleep@plt>
		while (1) {
  409834:	17fffffe 	b	40982c <posix_soc_clean_up+0x94>
}
  409838:	a94153f3 	ldp	x19, x20, [sp, #16]
  40983c:	f94013f5 	ldr	x21, [sp, #32]
  409840:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409844:	d65f03c0 	ret

0000000000409848 <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
  409848:	90000120 	adrp	x0, 42d000 <counter_period>
  40984c:	52800021 	mov	w1, #0x1                   	// #1
  409850:	b90bc001 	str	w1, [x0, #3008]
}
  409854:	d65f03c0 	ret

0000000000409858 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
  409858:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
  40985c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409860:	910003fd 	mov	x29, sp
  409864:	f9476800 	ldr	x0, [x0, #3792]
  409868:	f9000bf3 	str	x19, [sp, #16]
  40986c:	f9400001 	ldr	x1, [x0]
  409870:	f9005fe1 	str	x1, [sp, #184]
  409874:	d2800001 	mov	x1, #0x0                   	// #0
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
  409878:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40987c:	f9475400 	ldr	x0, [x0, #3752]
  409880:	f90013e0 	str	x0, [sp, #32]
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
  409884:	9100a3e0 	add	x0, sp, #0x28
  409888:	97ffde7e 	bl	401280 <sigemptyset@plt>
	if (unlikely(test)) {
  40988c:	340000c0 	cbz	w0, 4098a4 <hwm_set_sig_handler+0x4c>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  409890:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  409894:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  409898:	91027821 	add	x1, x1, #0x9e
  40989c:	91391400 	add	x0, x0, #0xe45
  4098a0:	94000337 	bl	40a57c <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;
  4098a4:	52b00000 	mov	w0, #0x80000000            	// #-2147483648

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  4098a8:	910083f3 	add	x19, sp, #0x20
  4098ac:	aa1303e1 	mov	x1, x19
  4098b0:	d2800002 	mov	x2, #0x0                   	// #0
	act.sa_flags = SA_RESETHAND;
  4098b4:	b900abe0 	str	w0, [sp, #168]
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  4098b8:	528001e0 	mov	w0, #0xf                   	// #15
  4098bc:	97ffde9d 	bl	401330 <sigaction@plt>
	if (unlikely(test)) {
  4098c0:	340000c0 	cbz	w0, 4098d8 <hwm_set_sig_handler+0x80>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  4098c4:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  4098c8:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4098cc:	9102e021 	add	x1, x1, #0xb8
  4098d0:	91391400 	add	x0, x0, #0xe45
  4098d4:	9400032a 	bl	40a57c <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
  4098d8:	aa1303e1 	mov	x1, x19
  4098dc:	d2800002 	mov	x2, #0x0                   	// #0
  4098e0:	52800040 	mov	w0, #0x2                   	// #2
  4098e4:	97ffde93 	bl	401330 <sigaction@plt>
	if (unlikely(test)) {
  4098e8:	340000c0 	cbz	w0, 409900 <hwm_set_sig_handler+0xa8>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  4098ec:	90000061 	adrp	x1, 415000 <random_data+0xb30>
  4098f0:	f0000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4098f4:	91035c21 	add	x1, x1, #0xd7
  4098f8:	91391400 	add	x0, x0, #0xe45
  4098fc:	94000320 	bl	40a57c <posix_print_error_and_exit>
}
  409900:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409904:	f9476800 	ldr	x0, [x0, #3792]
  409908:	f9405fe2 	ldr	x2, [sp, #184]
  40990c:	f9400001 	ldr	x1, [x0]
  409910:	eb010042 	subs	x2, x2, x1
  409914:	d2800001 	mov	x1, #0x0                   	// #0
  409918:	54000040 	b.eq	409920 <hwm_set_sig_handler+0xc8>  // b.none
  40991c:	97ffde81 	bl	401320 <__stack_chk_fail@plt>
  409920:	f9400bf3 	ldr	x19, [sp, #16]
  409924:	a8cc7bfd 	ldp	x29, x30, [sp], #192
  409928:	d65f03c0 	ret

000000000040992c <hwm_find_next_timer>:
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
  40992c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
  409930:	d0000102 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
	next_timer_index = 0;
  409934:	f0000101 	adrp	x1, 42c000 <__dso_handle>
	next_timer_time  = *Timer_list[0];
  409938:	f9475800 	ldr	x0, [x0, #3760]
	next_timer_index = 0;
  40993c:	b903f83f 	str	wzr, [x1, #1016]
		if (next_timer_time > *Timer_list[i]) {
  409940:	f9478c42 	ldr	x2, [x2, #3864]
	next_timer_time  = *Timer_list[0];
  409944:	f9400003 	ldr	x3, [x0]
  409948:	f0000100 	adrp	x0, 42c000 <__dso_handle>
		if (next_timer_time > *Timer_list[i]) {
  40994c:	f9400042 	ldr	x2, [x2]
	next_timer_time  = *Timer_list[0];
  409950:	f9063003 	str	x3, [x0, #3168]
		if (next_timer_time > *Timer_list[i]) {
  409954:	eb02007f 	cmp	x3, x2
  409958:	54000089 	b.ls	409968 <hwm_find_next_timer+0x3c>  // b.plast
			next_timer_index = i;
  40995c:	52800023 	mov	w3, #0x1                   	// #1
			next_timer_time = *Timer_list[i];
  409960:	f9063002 	str	x2, [x0, #3168]
			next_timer_index = i;
  409964:	b903f823 	str	w3, [x1, #1016]
		if (next_timer_time > *Timer_list[i]) {
  409968:	d0000102 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
  40996c:	f9463003 	ldr	x3, [x0, #3168]
  409970:	f947d042 	ldr	x2, [x2, #4000]
  409974:	f9400042 	ldr	x2, [x2]
  409978:	eb03005f 	cmp	x2, x3
  40997c:	54000082 	b.cs	40998c <hwm_find_next_timer+0x60>  // b.hs, b.nlast
			next_timer_index = i;
  409980:	52800043 	mov	w3, #0x2                   	// #2
			next_timer_time = *Timer_list[i];
  409984:	f9063002 	str	x2, [x0, #3168]
			next_timer_index = i;
  409988:	b903f823 	str	w3, [x1, #1016]
		}
	}
}
  40998c:	d65f03c0 	ret

0000000000409990 <hwm_one_event>:

/**
 * Execute the next scheduled HW event/timer
 */
void hwm_one_event(void)
{
  409990:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  409994:	f0000100 	adrp	x0, 42c000 <__dso_handle>
{
  409998:	910003fd 	mov	x29, sp
  40999c:	a90153f3 	stp	x19, x20, [sp, #16]
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  4099a0:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  4099a4:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  4099a8:	f9463001 	ldr	x1, [x0, #3168]
  4099ac:	f9463662 	ldr	x2, [x19, #3176]
  4099b0:	eb02003f 	cmp	x1, x2
  4099b4:	540003c3 	b.cc	409a2c <hwm_one_event+0x9c>  // b.lo, b.ul, b.last
		simu_time = next_timer_time;
  4099b8:	f9063661 	str	x1, [x19, #3176]
	if (signaled_end || (simu_time > end_of_time)) {
  4099bc:	90000120 	adrp	x0, 42d000 <counter_period>
  4099c0:	b94bc001 	ldr	w1, [x0, #3008]
  4099c4:	f9463660 	ldr	x0, [x19, #3176]
  4099c8:	350000a1 	cbnz	w1, 4099dc <hwm_one_event+0x4c>
  4099cc:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  4099d0:	f9400c21 	ldr	x1, [x1, #24]
  4099d4:	eb00003f 	cmp	x1, x0
  4099d8:	54000162 	b.cs	409a04 <hwm_one_event+0x74>  // b.hs, b.nlast
				((long double)simu_time)/1.0e6L);
  4099dc:	97ffe171 	bl	401fa0 <__floatunditf>
		posix_print_trace("\nStopped at %.3Lfs\n",
  4099e0:	d0000040 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  4099e4:	911dc000 	add	x0, x0, #0x770
  4099e8:	3dc00001 	ldr	q1, [x0]
  4099ec:	97ffdf15 	bl	401640 <__divtf3>
  4099f0:	90000060 	adrp	x0, 415000 <random_data+0xb30>
  4099f4:	9104a800 	add	x0, x0, #0x12a
  4099f8:	94000347 	bl	40a714 <posix_print_trace>
		posix_exit(0);
  4099fc:	52800000 	mov	w0, #0x0                   	// #0
  409a00:	94000289 	bl	40a424 <posix_exit>
	hwm_sleep_until_next_timer();

	switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
  409a04:	b943fa80 	ldr	w0, [x20, #1016]
  409a08:	7100041f 	cmp	w0, #0x1
  409a0c:	540001a0 	b.eq	409a40 <hwm_one_event+0xb0>  // b.none
  409a10:	7100081f 	cmp	w0, #0x2
  409a14:	540001a0 	b.eq	409a48 <hwm_one_event+0xb8>  // b.none
  409a18:	350001c0 	cbnz	w0, 409a50 <hwm_one_event+0xc0>
	case HWTIMER:
		hwtimer_timer_reached();
  409a1c:	940000b7 	bl	409cf8 <hwtimer_timer_reached>
		break;
		/* LCOV_EXCL_STOP */
	}

	hwm_find_next_timer();
}
  409a20:	a94153f3 	ldp	x19, x20, [sp, #16]
  409a24:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  409a28:	17ffffc1 	b	40992c <hwm_find_next_timer>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
  409a2c:	b943fa83 	ldr	w3, [x20, #1016]
  409a30:	90000060 	adrp	x0, 415000 <random_data+0xb30>
  409a34:	9103d400 	add	x0, x0, #0xf5
  409a38:	94000305 	bl	40a64c <posix_print_warning>
  409a3c:	17ffffe0 	b	4099bc <hwm_one_event+0x2c>
		hw_irq_ctrl_timer_triggered();
  409a40:	94000274 	bl	40a410 <hw_irq_ctrl_timer_triggered>
		break;
  409a44:	17fffff7 	b	409a20 <hwm_one_event+0x90>
		hw_counter_triggered();
  409a48:	94000615 	bl	40b29c <hw_counter_triggered>
		break;
  409a4c:	17fffff5 	b	409a20 <hwm_one_event+0x90>
		posix_print_error_and_exit(
  409a50:	90000060 	adrp	x0, 415000 <random_data+0xb30>
  409a54:	9104f800 	add	x0, x0, #0x13e
  409a58:	940002c9 	bl	40a57c <posix_print_error_and_exit>
		break;
  409a5c:	17fffff1 	b	409a20 <hwm_one_event+0x90>

0000000000409a60 <hwm_set_end_of_time>:
/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
	end_of_time = new_end_of_time;
  409a60:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409a64:	f9000c20 	str	x0, [x1, #24]
}
  409a68:	d65f03c0 	ret

0000000000409a6c <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
  409a6c:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409a70:	f9463400 	ldr	x0, [x0, #3176]
  409a74:	d65f03c0 	ret

0000000000409a78 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
  409a78:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409a7c:	910003fd 	mov	x29, sp
	hwm_set_sig_handler();
  409a80:	97ffff76 	bl	409858 <hwm_set_sig_handler>
	hwtimer_init();
  409a84:	94000055 	bl	409bd8 <hwtimer_init>
	hw_counter_init();
  409a88:	940005f8 	bl	40b268 <hw_counter_init>
	hw_irq_ctrl_init();
  409a8c:	940001da 	bl	40a1f4 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
  409a90:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hwm_find_next_timer();
  409a94:	17ffffa6 	b	40992c <hwm_find_next_timer>

0000000000409a98 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
  409a98:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409a9c:	910003fd 	mov	x29, sp
	hwtimer_cleanup();
  409aa0:	94000086 	bl	409cb8 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
  409aa4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hw_irq_ctrl_cleanup();
  409aa8:	140001e0 	b	40a228 <hw_irq_ctrl_cleanup>

0000000000409aac <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
  409aac:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409ab0:	f947a400 	ldr	x0, [x0, #3912]
  409ab4:	f9400001 	ldr	x1, [x0]
  409ab8:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409abc:	f9477c00 	ldr	x0, [x0, #3832]
  409ac0:	f9400000 	ldr	x0, [x0]
  409ac4:	eb01001f 	cmp	x0, x1
  409ac8:	9a819000 	csel	x0, x0, x1, ls  // ls = plast
  409acc:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  409ad0:	f9475821 	ldr	x1, [x1, #3760]
  409ad4:	f9000020 	str	x0, [x1]
}
  409ad8:	d65f03c0 	ret

0000000000409adc <native_add_time_options>:
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
  409adc:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409ae0:	9100a000 	add	x0, x0, #0x28
  409ae4:	14000573 	b	40b0b0 <native_add_command_line_opts>

0000000000409ae8 <cmd_stop_at_found>:
{
  409ae8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409aec:	910003fd 	mov	x29, sp
  409af0:	f9000bf3 	str	x19, [sp, #16]
	if (args.stop_at < 0) {
  409af4:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409af8:	fd463a60 	ldr	d0, [x19, #3184]
  409afc:	1e602018 	fcmpe	d0, #0.0
  409b00:	54000144 	b.mi	409b28 <cmd_stop_at_found+0x40>  // b.first
	hwm_set_end_of_time(args.stop_at*1e6);
  409b04:	fd463a60 	ldr	d0, [x19, #3184]
  409b08:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409b0c:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409b10:	9e670001 	fmov	d1, x0
}
  409b14:	f9400bf3 	ldr	x19, [sp, #16]
	hwm_set_end_of_time(args.stop_at*1e6);
  409b18:	1e610800 	fmul	d0, d0, d1
}
  409b1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_set_end_of_time(args.stop_at*1e6);
  409b20:	9e790000 	fcvtzu	x0, d0
  409b24:	17ffffcf 	b	409a60 <hwm_set_end_of_time>
  409b28:	aa0003e1 	mov	x1, x0
		posix_print_error_and_exit("Error: stop-at must be positive "
  409b2c:	90000060 	adrp	x0, 415000 <random_data+0xb30>
  409b30:	91056800 	add	x0, x0, #0x15a
  409b34:	94000292 	bl	40a57c <posix_print_error_and_exit>
  409b38:	17fffff3 	b	409b04 <cmd_stop_at_found+0x1c>

0000000000409b3c <hwtimer_set_real_time_mode>:
	real_time_mode = new_rt;
  409b3c:	90000121 	adrp	x1, 42d000 <counter_period>
  409b40:	393f5820 	strb	w0, [x1, #4054]
}
  409b44:	d65f03c0 	ret

0000000000409b48 <cmd_no_realtime_found>:
	hwtimer_set_real_time_mode(false);
  409b48:	52800000 	mov	w0, #0x0                   	// #0
  409b4c:	17fffffc 	b	409b3c <hwtimer_set_real_time_mode>

0000000000409b50 <cmd_realtime_found>:
	hwtimer_set_real_time_mode(true);
  409b50:	52800020 	mov	w0, #0x1                   	// #1
  409b54:	17fffffa 	b	409b3c <hwtimer_set_real_time_mode>

0000000000409b58 <get_host_us_time>:
{
  409b58:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409b5c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409b60:	910003fd 	mov	x29, sp
  409b64:	f9476800 	ldr	x0, [x0, #3792]
  409b68:	f9400001 	ldr	x1, [x0]
  409b6c:	f90017e1 	str	x1, [sp, #40]
  409b70:	d2800001 	mov	x1, #0x0                   	// #0
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
  409b74:	52800080 	mov	w0, #0x4                   	// #4
  409b78:	910063e1 	add	x1, sp, #0x18
  409b7c:	97ffdda9 	bl	401220 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409b80:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409b84:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  409b88:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409b8c:	9e670001 	fmov	d1, x0
  409b90:	fd400fe0 	ldr	d0, [sp, #24]
  409b94:	f94013e0 	ldr	x0, [sp, #32]
  409b98:	7e61d800 	ucvtf	d0, d0
  409b9c:	9ac10c00 	sdiv	x0, x0, x1
}
  409ba0:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409ba4:	1e610800 	fmul	d0, d0, d1
}
  409ba8:	f9476821 	ldr	x1, [x1, #3792]
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409bac:	9e620001 	scvtf	d1, x0
}
  409bb0:	f94017e3 	ldr	x3, [sp, #40]
  409bb4:	f9400022 	ldr	x2, [x1]
  409bb8:	eb020063 	subs	x3, x3, x2
  409bbc:	d2800002 	mov	x2, #0x0                   	// #0
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409bc0:	1e612800 	fadd	d0, d0, d1
}
  409bc4:	54000040 	b.eq	409bcc <get_host_us_time+0x74>  // b.none
  409bc8:	97ffddd6 	bl	401320 <__stack_chk_fail@plt>
  409bcc:	9e790000 	fcvtzu	x0, d0
  409bd0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409bd4:	d65f03c0 	ret

0000000000409bd8 <hwtimer_init>:
{
  409bd8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409bdc:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409be0:	910003fd 	mov	x29, sp
  409be4:	f9476800 	ldr	x0, [x0, #3792]
  409be8:	f9400001 	ldr	x1, [x0]
  409bec:	f90017e1 	str	x1, [sp, #40]
  409bf0:	d2800001 	mov	x1, #0x0                   	// #0
	silent_ticks = 0;
  409bf4:	f0000100 	adrp	x0, 42c000 <__dso_handle>
	hw_timer_tick_timer = NEVER;
  409bf8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	silent_ticks = 0;
  409bfc:	f906601f 	str	xzr, [x0, #3264]
	hw_timer_tick_timer = NEVER;
  409c00:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409c04:	f947a400 	ldr	x0, [x0, #3912]
  409c08:	f9000001 	str	x1, [x0]
	hw_timer_awake_timer = NEVER;
  409c0c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409c10:	f9477c00 	ldr	x0, [x0, #3832]
  409c14:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409c18:	97ffffa5 	bl	409aac <hwtimer_update_timer>
	if (real_time_mode) {
  409c1c:	90000120 	adrp	x0, 42d000 <counter_period>
  409c20:	397f5800 	ldrb	w0, [x0, #4054]
  409c24:	340000c0 	cbz	w0, 409c3c <hwtimer_init+0x64>
		boot_time = get_host_us_time();
  409c28:	97ffffcc 	bl	409b58 <get_host_us_time>
		last_radj_rtime = boot_time;
  409c2c:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409c30:	f9065420 	str	x0, [x1, #3240]
		last_radj_stime = 0U;
  409c34:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409c38:	f906581f 	str	xzr, [x0, #3248]
	if (!reset_rtc) {
  409c3c:	90000120 	adrp	x0, 42d000 <counter_period>
  409c40:	397f5c00 	ldrb	w0, [x0, #4055]
  409c44:	35000260 	cbnz	w0, 409c90 <hwtimer_init+0xb8>
		clock_gettime(CLOCK_REALTIME, &tv);
  409c48:	910063e1 	add	x1, sp, #0x18
  409c4c:	97ffdd75 	bl	401220 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409c50:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409c54:	d2807d02 	mov	x2, #0x3e8                 	// #1000
  409c58:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409c5c:	9e670001 	fmov	d1, x0
  409c60:	fd400fe0 	ldr	d0, [sp, #24]
		rtc_offset += realhosttime;
  409c64:	f0000101 	adrp	x1, 42c000 <__dso_handle>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409c68:	f94013e0 	ldr	x0, [sp, #32]
  409c6c:	7e61d800 	ucvtf	d0, d0
  409c70:	9ac20c00 	sdiv	x0, x0, x2
		rtc_offset += realhosttime;
  409c74:	f9465c22 	ldr	x2, [x1, #3256]
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409c78:	1e610800 	fmul	d0, d0, d1
  409c7c:	9e620001 	scvtf	d1, x0
  409c80:	1e612800 	fadd	d0, d0, d1
  409c84:	9e790000 	fcvtzu	x0, d0
		rtc_offset += realhosttime;
  409c88:	8b020000 	add	x0, x0, x2
  409c8c:	f9065c20 	str	x0, [x1, #3256]
}
  409c90:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409c94:	f9476800 	ldr	x0, [x0, #3792]
  409c98:	f94017e2 	ldr	x2, [sp, #40]
  409c9c:	f9400001 	ldr	x1, [x0]
  409ca0:	eb010042 	subs	x2, x2, x1
  409ca4:	d2800001 	mov	x1, #0x0                   	// #0
  409ca8:	54000040 	b.eq	409cb0 <hwtimer_init+0xd8>  // b.none
  409cac:	97ffdd9d 	bl	401320 <__stack_chk_fail@plt>
  409cb0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409cb4:	d65f03c0 	ret

0000000000409cb8 <hwtimer_cleanup>:
}
  409cb8:	d65f03c0 	ret

0000000000409cbc <hwtimer_enable>:
{
  409cbc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409cc0:	910003fd 	mov	x29, sp
  409cc4:	f9000bf3 	str	x19, [sp, #16]
	tick_p = period;
  409cc8:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409ccc:	f9066660 	str	x0, [x19, #3272]
	hw_timer_tick_timer = hwm_get_time() + tick_p;
  409cd0:	97ffff67 	bl	409a6c <hwm_get_time>
  409cd4:	f9466661 	ldr	x1, [x19, #3272]
  409cd8:	8b000020 	add	x0, x1, x0
  409cdc:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  409ce0:	f947a421 	ldr	x1, [x1, #3912]
  409ce4:	f9000020 	str	x0, [x1]
	hwtimer_update_timer();
  409ce8:	97ffff71 	bl	409aac <hwtimer_update_timer>
}
  409cec:	f9400bf3 	ldr	x19, [sp, #16]
  409cf0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  409cf4:	17ffff0e 	b	40992c <hwm_find_next_timer>

0000000000409cf8 <hwtimer_timer_reached>:
{
  409cf8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  409cfc:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409d00:	910003fd 	mov	x29, sp
  409d04:	f9476800 	ldr	x0, [x0, #3792]
  409d08:	a90153f3 	stp	x19, x20, [sp, #16]
  409d0c:	f90013f5 	str	x21, [sp, #32]
  409d10:	f9400001 	ldr	x1, [x0]
  409d14:	f9002fe1 	str	x1, [sp, #88]
  409d18:	d2800001 	mov	x1, #0x0                   	// #0
	uint64_t Now = hw_timer_timer;
  409d1c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409d20:	f9475800 	ldr	x0, [x0, #3760]
  409d24:	f9400013 	ldr	x19, [x0]
	if (hw_timer_awake_timer == Now) {
  409d28:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409d2c:	f9477c00 	ldr	x0, [x0, #3832]
  409d30:	f9400001 	ldr	x1, [x0]
  409d34:	eb13003f 	cmp	x1, x19
  409d38:	540000c1 	b.ne	409d50 <hwtimer_timer_reached+0x58>  // b.any
	hw_timer_awake_timer = NEVER;
  409d3c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  409d40:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409d44:	97ffff5a 	bl	409aac <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
  409d48:	529fffe0 	mov	w0, #0xffff                	// #65535
  409d4c:	9400018a 	bl	40a374 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
  409d50:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  409d54:	d0000114 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  409d58:	aa0003f5 	mov	x21, x0
  409d5c:	f947a401 	ldr	x1, [x0, #3912]
  409d60:	f9400021 	ldr	x1, [x1]
  409d64:	eb13003f 	cmp	x1, x19
  409d68:	54000661 	b.ne	409e34 <hwtimer_timer_reached+0x13c>  // b.any
	if (real_time_mode) {
  409d6c:	90000120 	adrp	x0, 42d000 <counter_period>
  409d70:	397f5800 	ldrb	w0, [x0, #4054]
  409d74:	34000460 	cbz	w0, 409e00 <hwtimer_timer_reached+0x108>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  409d78:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409d7c:	f9465800 	ldr	x0, [x0, #3248]
  409d80:	cb000273 	sub	x19, x19, x0
				    / clock_ratio
  409d84:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409d88:	9e630260 	ucvtf	d0, x19
  409d8c:	fd401001 	ldr	d1, [x0, #32]
				    + last_radj_rtime;
  409d90:	f0000100 	adrp	x0, 42c000 <__dso_handle>
				    / clock_ratio
  409d94:	1e611800 	fdiv	d0, d0, d1
				    + last_radj_rtime;
  409d98:	fd465401 	ldr	d1, [x0, #3240]
  409d9c:	7e61d821 	ucvtf	d1, d1
  409da0:	1e612800 	fadd	d0, d0, d1
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  409da4:	9e790013 	fcvtzu	x19, d0
		uint64_t real_time = get_host_us_time();
  409da8:	97ffff6c 	bl	409b58 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
  409dac:	cb000260 	sub	x0, x19, x0
		if (diff > 0) { /* we need to slow down */
  409db0:	f100001f 	cmp	x0, #0x0
  409db4:	5400026d 	b.le	409e00 <hwtimer_timer_reached+0x108>
			requested_time.tv_sec  = diff / 1e6;
  409db8:	9e620000 	scvtf	d0, x0
  409dbc:	d0000040 	adrp	x0, 413000 <sys_clock_announce+0x19c>
			(void) nanosleep(&requested_time, &remaining);
  409dc0:	910123e1 	add	x1, sp, #0x48
			requested_time.tv_sec  = diff / 1e6;
  409dc4:	fd43c002 	ldr	d2, [x0, #1920]
						 requested_time.tv_sec*1e6)*1e3;
  409dc8:	d2c80000 	mov	x0, #0x400000000000        	// #70368744177664
  409dcc:	f2e811e0 	movk	x0, #0x408f, lsl #48
			requested_time.tv_sec  = diff / 1e6;
  409dd0:	1e621801 	fdiv	d1, d0, d2
  409dd4:	5ee1b821 	fcvtzs	d1, d1
  409dd8:	fd001fe1 	str	d1, [sp, #56]
						 requested_time.tv_sec*1e6)*1e3;
  409ddc:	5e61d821 	scvtf	d1, d1
  409de0:	1e620821 	fmul	d1, d1, d2
			requested_time.tv_nsec = (diff -
  409de4:	1e613800 	fsub	d0, d0, d1
						 requested_time.tv_sec*1e6)*1e3;
  409de8:	9e670001 	fmov	d1, x0
			(void) nanosleep(&requested_time, &remaining);
  409dec:	9100e3e0 	add	x0, sp, #0x38
						 requested_time.tv_sec*1e6)*1e3;
  409df0:	1e610800 	fmul	d0, d0, d1
			requested_time.tv_nsec = (diff -
  409df4:	5ee1b800 	fcvtzs	d0, d0
  409df8:	fd0023e0 	str	d0, [sp, #64]
			(void) nanosleep(&requested_time, &remaining);
  409dfc:	97ffdd81 	bl	401400 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
  409e00:	f947a6a0 	ldr	x0, [x21, #3912]
  409e04:	f0000102 	adrp	x2, 42c000 <__dso_handle>
  409e08:	f9466442 	ldr	x2, [x2, #3272]
  409e0c:	f9400001 	ldr	x1, [x0]
  409e10:	8b020021 	add	x1, x1, x2
  409e14:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409e18:	97ffff25 	bl	409aac <hwtimer_update_timer>
	if (silent_ticks > 0) {
  409e1c:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409e20:	f9466020 	ldr	x0, [x1, #3264]
  409e24:	f100001f 	cmp	x0, #0x0
  409e28:	540001ad 	b.le	409e5c <hwtimer_timer_reached+0x164>
		silent_ticks -= 1;
  409e2c:	d1000400 	sub	x0, x0, #0x1
  409e30:	f9066020 	str	x0, [x1, #3264]
}
  409e34:	f9476a80 	ldr	x0, [x20, #3792]
  409e38:	f9402fe2 	ldr	x2, [sp, #88]
  409e3c:	f9400001 	ldr	x1, [x0]
  409e40:	eb010042 	subs	x2, x2, x1
  409e44:	d2800001 	mov	x1, #0x0                   	// #0
  409e48:	54000161 	b.ne	409e74 <hwtimer_timer_reached+0x17c>  // b.any
  409e4c:	a94153f3 	ldp	x19, x20, [sp, #16]
  409e50:	f94013f5 	ldr	x21, [sp, #32]
  409e54:	a8c67bfd 	ldp	x29, x30, [sp], #96
  409e58:	d65f03c0 	ret
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409e5c:	f9476a80 	ldr	x0, [x20, #3792]
  409e60:	f9402fe2 	ldr	x2, [sp, #88]
  409e64:	f9400001 	ldr	x1, [x0]
  409e68:	eb010042 	subs	x2, x2, x1
  409e6c:	d2800001 	mov	x1, #0x0                   	// #0
  409e70:	54000040 	b.eq	409e78 <hwtimer_timer_reached+0x180>  // b.none
}
  409e74:	97ffdd2b 	bl	401320 <__stack_chk_fail@plt>
  409e78:	a94153f3 	ldp	x19, x20, [sp, #16]
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409e7c:	52800000 	mov	w0, #0x0                   	// #0
}
  409e80:	f94013f5 	ldr	x21, [sp, #32]
  409e84:	a8c67bfd 	ldp	x29, x30, [sp], #96
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409e88:	1400013b 	b	40a374 <hw_irq_ctrl_set_irq>

0000000000409e8c <hwtimer_set_silent_ticks>:
	silent_ticks = sys_ticks;
  409e8c:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409e90:	f9066020 	str	x0, [x1, #3264]
}
  409e94:	d65f03c0 	ret

0000000000409e98 <hwtimer_reset_rtc>:
	reset_rtc = true;
  409e98:	90000120 	adrp	x0, 42d000 <counter_period>
  409e9c:	52800021 	mov	w1, #0x1                   	// #1
  409ea0:	393f5c01 	strb	w1, [x0, #4055]
}
  409ea4:	d65f03c0 	ret

0000000000409ea8 <cmd_rtcreset_found>:
	hwtimer_reset_rtc();
  409ea8:	17fffffc 	b	409e98 <hwtimer_reset_rtc>

0000000000409eac <hwtimer_set_rtc_offset>:
	rtc_offset = offset;
  409eac:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409eb0:	f9065c20 	str	x0, [x1, #3256]
}
  409eb4:	d65f03c0 	ret

0000000000409eb8 <cmd_rtcoffset_found>:
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
  409eb8:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409ebc:	fd463c00 	ldr	d0, [x0, #3192]
  409ec0:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409ec4:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409ec8:	9e670001 	fmov	d1, x0
  409ecc:	1e610800 	fmul	d0, d0, d1
  409ed0:	9e780000 	fcvtzs	x0, d0
  409ed4:	17fffff6 	b	409eac <hwtimer_set_rtc_offset>

0000000000409ed8 <hwtimer_set_rt_ratio>:
	clock_ratio = ratio;
  409ed8:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409edc:	fd001000 	str	d0, [x0, #32]
}
  409ee0:	d65f03c0 	ret

0000000000409ee4 <cmd_rt_ratio_found>:
{
  409ee4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409ee8:	910003fd 	mov	x29, sp
  409eec:	f9000bf3 	str	x19, [sp, #16]
	if ((args.rt_ratio <= 0)) {
  409ef0:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409ef4:	9131c260 	add	x0, x19, #0xc70
  409ef8:	fd400c00 	ldr	d0, [x0, #24]
  409efc:	1e602018 	fcmpe	d0, #0.0
  409f00:	540000c9 	b.ls	409f18 <cmd_rt_ratio_found+0x34>  // b.plast
	hwtimer_set_rt_ratio(args.rt_ratio);
  409f04:	9131c273 	add	x19, x19, #0xc70
  409f08:	fd400e60 	ldr	d0, [x19, #24]
}
  409f0c:	f9400bf3 	ldr	x19, [sp, #16]
  409f10:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  409f14:	17fffff1 	b	409ed8 <hwtimer_set_rt_ratio>
		posix_print_error_and_exit("The ratio needs to be > 0. "
  409f18:	90000060 	adrp	x0, 415000 <random_data+0xb30>
  409f1c:	91060000 	add	x0, x0, #0x180
  409f20:	94000197 	bl	40a57c <posix_print_error_and_exit>
  409f24:	17fffff8 	b	409f04 <cmd_rt_ratio_found+0x20>

0000000000409f28 <cmd_rt_drift_found>:
{
  409f28:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!(args.rt_drift > -1)) {
  409f2c:	1e7e1000 	fmov	d0, #-1.000000000000000000e+00
{
  409f30:	910003fd 	mov	x29, sp
  409f34:	f9000bf3 	str	x19, [sp, #16]
	if (!(args.rt_drift > -1)) {
  409f38:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409f3c:	9131c260 	add	x0, x19, #0xc70
  409f40:	fd400801 	ldr	d1, [x0, #16]
  409f44:	1e602030 	fcmpe	d1, d0
  409f48:	5400008c 	b.gt	409f58 <cmd_rt_drift_found+0x30>
		posix_print_error_and_exit("The drift needs to be > -1. "
  409f4c:	90000060 	adrp	x0, 415000 <random_data+0xb30>
  409f50:	9106f000 	add	x0, x0, #0x1bc
  409f54:	9400018a 	bl	40a57c <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
  409f58:	9131c273 	add	x19, x19, #0xc70
  409f5c:	1e6e1001 	fmov	d1, #1.000000000000000000e+00
  409f60:	fd400a60 	ldr	d0, [x19, #16]
  409f64:	1e612800 	fadd	d0, d0, d1
  409f68:	fd000e60 	str	d0, [x19, #24]
}
  409f6c:	f9400bf3 	ldr	x19, [sp, #16]
  409f70:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  409f74:	17ffffd9 	b	409ed8 <hwtimer_set_rt_ratio>

0000000000409f78 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
  409f78:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  409f7c:	910003fd 	mov	x29, sp
  409f80:	a90153f3 	stp	x19, x20, [sp, #16]
  409f84:	a9025bf5 	stp	x21, x22, [sp, #32]
  409f88:	a90363f7 	stp	x23, x24, [sp, #48]
  409f8c:	f90023f9 	str	x25, [sp, #64]
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
  409f90:	940000b5 	bl	40a264 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
  409f94:	350009c0 	cbnz	w0, 40a0cc <posix_irq_handler+0x154>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
  409f98:	d0000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  409f9c:	aa1303f4 	mov	x20, x19
  409fa0:	f9473260 	ldr	x0, [x19, #3680]
  409fa4:	b9400000 	ldr	w0, [x0]
  409fa8:	35000060 	cbnz	w0, 409fb4 <posix_irq_handler+0x3c>
		may_swap = 0;
  409fac:	90000121 	adrp	x1, 42d000 <counter_period>
  409fb0:	b90bc43f 	str	wzr, [x1, #3012]
	}

	_kernel.cpus[0].nested++;
  409fb4:	f9473281 	ldr	x1, [x20, #3680]

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
		int last_running_irq = currently_running_irq;
  409fb8:	f0000115 	adrp	x21, 42c000 <__dso_handle>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  409fbc:	f0000116 	adrp	x22, 42c000 <__dso_handle>
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
		hw_irq_ctrl_clear_irq(irq_nbr);

		currently_running_irq = irq_nbr;
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;
  409fc0:	910ff2b8 	add	x24, x21, #0x3fc
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  409fc4:	913342d6 	add	x22, x22, #0xcd0
	_kernel.cpus[0].nested++;
  409fc8:	11000400 	add	w0, w0, #0x1
  409fcc:	b9000020 	str	w0, [x1]
	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
  409fd0:	940000bd 	bl	40a2c4 <hw_irq_ctrl_get_highest_prio_irq>
  409fd4:	2a0003f3 	mov	w19, w0
  409fd8:	3100041f 	cmn	w0, #0x1
  409fdc:	540002c1 	b.ne	40a034 <posix_irq_handler+0xbc>  // b.any

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
	}

	_kernel.cpus[0].nested--;
  409fe0:	f9473294 	ldr	x20, [x20, #3680]
  409fe4:	b9400280 	ldr	w0, [x20]
  409fe8:	51000400 	sub	w0, w0, #0x1
  409fec:	b9000280 	str	w0, [x20]
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
  409ff0:	90000120 	adrp	x0, 42d000 <counter_period>
  409ff4:	b94bc400 	ldr	w0, [x0, #3012]
  409ff8:	340006a0 	cbz	w0, 40a0cc <posix_irq_handler+0x154>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
  409ffc:	9400008f 	bl	40a238 <hw_irq_ctrl_get_cur_prio>
  40a000:	7104001f 	cmp	w0, #0x100
  40a004:	54000641 	b.ne	40a0cc <posix_irq_handler+0x154>  // b.any
		&& (_kernel.ready_q.cache != _current)) {
  40a008:	f9400a80 	ldr	x0, [x20, #16]
  40a00c:	f9401681 	ldr	x1, [x20, #40]
  40a010:	eb00003f 	cmp	x1, x0
  40a014:	540005c0 	b.eq	40a0cc <posix_irq_handler+0x154>  // b.none

		(void)z_swap_irqlock(irq_lock);
	}
}
  40a018:	a94153f3 	ldp	x19, x20, [sp, #16]

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
  40a01c:	52800000 	mov	w0, #0x0                   	// #0
  40a020:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a024:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a028:	f94023f9 	ldr	x25, [sp, #64]
  40a02c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40a030:	17fffd13 	b	40947c <arch_swap>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  40a034:	94000081 	bl	40a238 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;
  40a038:	b943feb9 	ldr	w25, [x21, #1020]
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  40a03c:	2a0003f7 	mov	w23, w0
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
  40a040:	2a1303e0 	mov	w0, w19
  40a044:	94000084 	bl	40a254 <hw_irq_ctrl_get_prio>
  40a048:	12001c00 	and	w0, w0, #0xff
  40a04c:	94000078 	bl	40a22c <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
  40a050:	2a1303e0 	mov	w0, w19
  40a054:	940000bd 	bl	40a348 <hw_irq_ctrl_clear_irq>
		currently_running_irq = irq_nbr;
  40a058:	b903feb3 	str	w19, [x21, #1020]
	sys_trace_isr_enter();
  40a05c:	97fffb9c 	bl	408ecc <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  40a060:	93407e61 	sxtw	x1, w19
  40a064:	d2800300 	mov	x0, #0x18                  	// #24
  40a068:	9b005821 	madd	x1, x1, x0, x22
  40a06c:	f9400422 	ldr	x2, [x1, #8]
  40a070:	b5000142 	cbnz	x2, 40a098 <posix_irq_handler+0x120>
		posix_print_error_and_exit("Received irq %i without a "
  40a074:	f0000040 	adrp	x0, 415000 <random_data+0xb30>
  40a078:	2a1303e1 	mov	w1, w19
  40a07c:	91174800 	add	x0, x0, #0x5d2
  40a080:	9400013f 	bl	40a57c <posix_print_error_and_exit>
	sys_trace_isr_exit();
  40a084:	97fffb93 	bl	408ed0 <sys_trace_isr_exit>
		currently_running_irq = last_running_irq;
  40a088:	b9000319 	str	w25, [x24]
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
  40a08c:	2a1703e0 	mov	w0, w23
  40a090:	94000067 	bl	40a22c <hw_irq_ctrl_set_cur_prio>
  40a094:	17ffffcf 	b	409fd0 <posix_irq_handler+0x58>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
  40a098:	b9400420 	ldr	w0, [x1, #4]
  40a09c:	f0000113 	adrp	x19, 42d000 <counter_period>
  40a0a0:	360000c0 	tbz	w0, #0, 40a0b8 <posix_irq_handler+0x140>
			*may_swap |= ((direct_irq_f_ptr)
  40a0a4:	d63f0040 	blr	x2
  40a0a8:	b94bc661 	ldr	w1, [x19, #3012]
  40a0ac:	2a000021 	orr	w1, w1, w0
  40a0b0:	b90bc661 	str	w1, [x19, #3012]
  40a0b4:	17fffff4 	b	40a084 <posix_irq_handler+0x10c>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
  40a0b8:	f9400820 	ldr	x0, [x1, #16]
  40a0bc:	d63f0040 	blr	x2
			*may_swap = 1;
  40a0c0:	52800020 	mov	w0, #0x1                   	// #1
  40a0c4:	b90bc660 	str	w0, [x19, #3012]
  40a0c8:	17ffffef 	b	40a084 <posix_irq_handler+0x10c>
}
  40a0cc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a0d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a0d4:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a0d8:	f94023f9 	ldr	x25, [sp, #64]
  40a0dc:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40a0e0:	d65f03c0 	ret

000000000040a0e4 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
  40a0e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a0e8:	910003fd 	mov	x29, sp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
  40a0ec:	94000076 	bl	40a2c4 <hw_irq_ctrl_get_highest_prio_irq>
  40a0f0:	3100041f 	cmn	w0, #0x1
  40a0f4:	54000140 	b.eq	40a11c <posix_irq_handler_im_from_sw+0x38>  // b.none
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
  40a0f8:	97fffd1f 	bl	409574 <posix_is_cpu_running>
  40a0fc:	350000c0 	cbnz	w0, 40a114 <posix_irq_handler_im_from_sw+0x30>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
  40a100:	f0000041 	adrp	x1, 415000 <random_data+0xb30>
  40a104:	f0000040 	adrp	x0, 415000 <random_data+0xb30>
  40a108:	9118d421 	add	x1, x1, #0x635
  40a10c:	91180000 	add	x0, x0, #0x600
  40a110:	9400011b 	bl	40a57c <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
  40a114:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler();
  40a118:	17ffff98 	b	409f78 <posix_irq_handler>
}
  40a11c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a120:	d65f03c0 	ret

000000000040a124 <posix_irq_lock>:
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
	return hw_irq_ctrl_change_lock(true);
  40a124:	52800020 	mov	w0, #0x1                   	// #1
  40a128:	14000052 	b	40a270 <hw_irq_ctrl_change_lock>

000000000040a12c <posix_irq_unlock>:
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
  40a12c:	14000051 	b	40a270 <hw_irq_ctrl_change_lock>

000000000040a130 <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
	hw_irq_ctrl_change_lock(false);
  40a130:	52800000 	mov	w0, #0x0                   	// #0
  40a134:	1400004f 	b	40a270 <hw_irq_ctrl_change_lock>

000000000040a138 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
  40a138:	140000aa 	b	40a3e0 <hw_irq_ctrl_enable_irq>

000000000040a13c <posix_isr_declare>:
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
	irq_vector_table[irq_p].irq   = irq_p;
  40a13c:	2a0003e4 	mov	w4, w0
  40a140:	d2800306 	mov	x6, #0x18                  	// #24
  40a144:	d0000105 	adrp	x5, 42c000 <__dso_handle>
  40a148:	913340a5 	add	x5, x5, #0xcd0
  40a14c:	9b067c84 	mul	x4, x4, x6
  40a150:	8b0400a6 	add	x6, x5, x4
  40a154:	b82468a0 	str	w0, [x5, x4]
	irq_vector_table[irq_p].func  = isr_p;
	irq_vector_table[irq_p].param = isr_param_p;
	irq_vector_table[irq_p].flags = flags;
  40a158:	b90004c1 	str	w1, [x6, #4]
	irq_vector_table[irq_p].param = isr_param_p;
  40a15c:	a9008cc2 	stp	x2, x3, [x6, #8]
}
  40a160:	d65f03c0 	ret

000000000040a164 <posix_irq_priority_set>:
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
  40a164:	14000038 	b	40a244 <hw_irq_ctrl_prio_set>

000000000040a168 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
  40a168:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a16c:	397fe001 	ldrb	w1, [x0, #4088]
  40a170:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a174:	34000061 	cbz	w1, 40a180 <irq_raising_from_hw_now+0x18>
  40a178:	397fe401 	ldrb	w1, [x0, #4089]
  40a17c:	34000061 	cbz	w1, 40a188 <irq_raising_from_hw_now+0x20>
		lock_ignore = false;
  40a180:	393fe41f 	strb	wzr, [x0, #4089]
		posix_interrupt_raised();
  40a184:	17fffd27 	b	409620 <posix_interrupt_raised>
	}
}
  40a188:	d65f03c0 	ret

000000000040a18c <hw_irq_ctrl_irq_raise_prefix>:
	if (irq < N_IRQS) {
  40a18c:	71007c1f 	cmp	w0, #0x1f
  40a190:	54000248 	b.hi	40a1d8 <hw_irq_ctrl_irq_raise_prefix+0x4c>  // b.pmore
		irq_premask |= ((uint64_t)1<<irq);
  40a194:	d2800021 	mov	x1, #0x1                   	// #1
  40a198:	d0000104 	adrp	x4, 42c000 <__dso_handle>
  40a19c:	9ac02023 	lsl	x3, x1, x0
		if (irq_mask & (1 << irq)) {
  40a1a0:	1ac02021 	lsl	w1, w1, w0
  40a1a4:	d0000100 	adrp	x0, 42c000 <__dso_handle>
		irq_premask |= ((uint64_t)1<<irq);
  40a1a8:	f947ec82 	ldr	x2, [x4, #4056]
		if (irq_mask & (1 << irq)) {
  40a1ac:	93407c21 	sxtw	x1, w1
  40a1b0:	f947e800 	ldr	x0, [x0, #4048]
		irq_premask |= ((uint64_t)1<<irq);
  40a1b4:	aa030042 	orr	x2, x2, x3
  40a1b8:	f907ec82 	str	x2, [x4, #4056]
		if (irq_mask & (1 << irq)) {
  40a1bc:	ea00003f 	tst	x1, x0
  40a1c0:	540000a0 	b.eq	40a1d4 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.none
			irq_status |= ((uint64_t)1<<irq);
  40a1c4:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a1c8:	f947f020 	ldr	x0, [x1, #4064]
  40a1cc:	aa030000 	orr	x0, x0, x3
  40a1d0:	f907f020 	str	x0, [x1, #4064]
}
  40a1d4:	d65f03c0 	ret
	} else if (irq == PHONY_HARD_IRQ) {
  40a1d8:	529fffe1 	mov	w1, #0xffff                	// #65535
  40a1dc:	6b01001f 	cmp	w0, w1
  40a1e0:	54ffffa1 	b.ne	40a1d4 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.any
		lock_ignore = true;
  40a1e4:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a1e8:	52800021 	mov	w1, #0x1                   	// #1
  40a1ec:	393fe401 	strb	w1, [x0, #4089]
}
  40a1f0:	17fffff9 	b	40a1d4 <hw_irq_ctrl_irq_raise_prefix+0x48>

000000000040a1f4 <hw_irq_ctrl_init>:
		irq_prio[i] = 255U;
  40a1f4:	6f000400 	mvni	v0.4s, #0x0
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
  40a1f8:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a1fc:	f907e81f 	str	xzr, [x0, #4048]
	irq_premask = 0U;
  40a200:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a204:	f907ec1f 	str	xzr, [x0, #4056]
	irqs_locked = false;
  40a208:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a20c:	393fe01f 	strb	wzr, [x0, #4088]
	lock_ignore = false;
  40a210:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a214:	393fe41f 	strb	wzr, [x0, #4089]
		irq_prio[i] = 255U;
  40a218:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a21c:	913f6000 	add	x0, x0, #0xfd8
  40a220:	ad000000 	stp	q0, q0, [x0]
}
  40a224:	d65f03c0 	ret

000000000040a228 <hw_irq_ctrl_cleanup>:
}
  40a228:	d65f03c0 	ret

000000000040a22c <hw_irq_ctrl_set_cur_prio>:
	currently_running_prio = new;
  40a22c:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a230:	b9040020 	str	w0, [x1, #1024]
}
  40a234:	d65f03c0 	ret

000000000040a238 <hw_irq_ctrl_get_cur_prio>:
}
  40a238:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a23c:	b9440000 	ldr	w0, [x0, #1024]
  40a240:	d65f03c0 	ret

000000000040a244 <hw_irq_ctrl_prio_set>:
	irq_prio[irq] = prio;
  40a244:	f0000102 	adrp	x2, 42d000 <counter_period>
  40a248:	913f6042 	add	x2, x2, #0xfd8
  40a24c:	38204841 	strb	w1, [x2, w0, uxtw]
}
  40a250:	d65f03c0 	ret

000000000040a254 <hw_irq_ctrl_get_prio>:
}
  40a254:	f0000101 	adrp	x1, 42d000 <counter_period>
  40a258:	913f6021 	add	x1, x1, #0xfd8
  40a25c:	38604820 	ldrb	w0, [x1, w0, uxtw]
  40a260:	d65f03c0 	ret

000000000040a264 <hw_irq_ctrl_get_current_lock>:
}
  40a264:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a268:	397fe000 	ldrb	w0, [x0, #4088]
  40a26c:	d65f03c0 	ret

000000000040a270 <hw_irq_ctrl_change_lock>:
{
  40a270:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t previous_lock = irqs_locked;
  40a274:	f0000101 	adrp	x1, 42d000 <counter_period>
	irqs_locked = new_lock;
  40a278:	7100001f 	cmp	w0, #0x0
{
  40a27c:	910003fd 	mov	x29, sp
	irqs_locked = new_lock;
  40a280:	1a9f07e0 	cset	w0, ne  // ne = any
{
  40a284:	f9000bf3 	str	x19, [sp, #16]
	uint32_t previous_lock = irqs_locked;
  40a288:	397fe033 	ldrb	w19, [x1, #4088]
	irqs_locked = new_lock;
  40a28c:	393fe020 	strb	w0, [x1, #4088]
	if ((previous_lock == true) && (new_lock == false)) {
  40a290:	7a400a64 	ccmp	w19, #0x0, #0x4, eq  // eq = none
  40a294:	540000a0 	b.eq	40a2a8 <hw_irq_ctrl_change_lock+0x38>  // b.none
		if (irq_status != 0U) {
  40a298:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a29c:	f947f000 	ldr	x0, [x0, #4064]
  40a2a0:	b4000040 	cbz	x0, 40a2a8 <hw_irq_ctrl_change_lock+0x38>
			posix_irq_handler_im_from_sw();
  40a2a4:	97ffff90 	bl	40a0e4 <posix_irq_handler_im_from_sw>
}
  40a2a8:	2a1303e0 	mov	w0, w19
  40a2ac:	f9400bf3 	ldr	x19, [sp, #16]
  40a2b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a2b4:	d65f03c0 	ret

000000000040a2b8 <hw_irq_ctrl_get_irq_status>:
}
  40a2b8:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a2bc:	f947f000 	ldr	x0, [x0, #4064]
  40a2c0:	d65f03c0 	ret

000000000040a2c4 <hw_irq_ctrl_get_highest_prio_irq>:
	if (irqs_locked) {
  40a2c4:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a2c8:	397fe000 	ldrb	w0, [x0, #4088]
  40a2cc:	350003a0 	cbnz	w0, 40a340 <hw_irq_ctrl_get_highest_prio_irq+0x7c>
{
  40a2d0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a2d4:	910003fd 	mov	x29, sp
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
  40a2d8:	97fffff8 	bl	40a2b8 <hw_irq_ctrl_get_irq_status>
  40a2dc:	aa0003e2 	mov	x2, x0
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a2e0:	d0000100 	adrp	x0, 42c000 <__dso_handle>
		if ((winner_prio > (int)irq_prio[irq_nbr])
  40a2e4:	f0000104 	adrp	x4, 42d000 <counter_period>
  40a2e8:	913f6084 	add	x4, x4, #0xfd8
	int winner_prio = 256;
  40a2ec:	52802003 	mov	w3, #0x100                 	// #256
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a2f0:	b9440006 	ldr	w6, [x0, #1024]
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  40a2f4:	d2800027 	mov	x7, #0x1                   	// #1
	int winner = -1;
  40a2f8:	12800000 	mov	w0, #0xffffffff            	// #-1
	while (irq_status != 0U) {
  40a2fc:	b5000062 	cbnz	x2, 40a308 <hw_irq_ctrl_get_highest_prio_irq+0x44>
}
  40a300:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a304:	d65f03c0 	ret
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
  40a308:	5ac00041 	rbit	w1, w2
  40a30c:	7100005f 	cmp	w2, #0x0
  40a310:	5ac01021 	clz	w1, w1
  40a314:	1a8107e1 	csinc	w1, wzr, w1, eq  // eq = none
		int irq_nbr = find_lsb_set(irq_status) - 1;
  40a318:	51000421 	sub	w1, w1, #0x1
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  40a31c:	9ac120e5 	lsl	x5, x7, x1
  40a320:	8a250042 	bic	x2, x2, x5
		if ((winner_prio > (int)irq_prio[irq_nbr])
  40a324:	3861c885 	ldrb	w5, [x4, w1, sxtw]
  40a328:	6b0300bf 	cmp	w5, w3
  40a32c:	54fffe8a 	b.ge	40a2fc <hw_irq_ctrl_get_highest_prio_irq+0x38>  // b.tcont
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a330:	6b0600bf 	cmp	w5, w6
  40a334:	1a85a063 	csel	w3, w3, w5, ge  // ge = tcont
  40a338:	1a81a000 	csel	w0, w0, w1, ge  // ge = tcont
  40a33c:	17fffff0 	b	40a2fc <hw_irq_ctrl_get_highest_prio_irq+0x38>
		return -1;
  40a340:	12800000 	mov	w0, #0xffffffff            	// #-1
}
  40a344:	d65f03c0 	ret

000000000040a348 <hw_irq_ctrl_clear_irq>:
	irq_status  &= ~((uint64_t)1<<irq);
  40a348:	d0000102 	adrp	x2, 42c000 <__dso_handle>
  40a34c:	d2800021 	mov	x1, #0x1                   	// #1
  40a350:	9ac02020 	lsl	x0, x1, x0
  40a354:	f947f041 	ldr	x1, [x2, #4064]
  40a358:	8a200021 	bic	x1, x1, x0
  40a35c:	f907f041 	str	x1, [x2, #4064]
	irq_premask &= ~((uint64_t)1<<irq);
  40a360:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a364:	f947ec22 	ldr	x2, [x1, #4056]
  40a368:	8a200040 	bic	x0, x2, x0
  40a36c:	f907ec20 	str	x0, [x1, #4056]
}
  40a370:	d65f03c0 	ret

000000000040a374 <hw_irq_ctrl_set_irq>:
{
  40a374:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a378:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  40a37c:	97ffff84 	bl	40a18c <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
  40a380:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a384:	397fe000 	ldrb	w0, [x0, #4088]
  40a388:	34000080 	cbz	w0, 40a398 <hw_irq_ctrl_set_irq+0x24>
  40a38c:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a390:	397fe400 	ldrb	w0, [x0, #4089]
  40a394:	340000e0 	cbz	w0, 40a3b0 <hw_irq_ctrl_set_irq+0x3c>
		irq_ctrl_timer = hwm_get_time();
  40a398:	97fffdb5 	bl	409a6c <hwm_get_time>
  40a39c:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40a3a0:	f9478c21 	ldr	x1, [x1, #3864]
  40a3a4:	f9000020 	str	x0, [x1]
}
  40a3a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
		hwm_find_next_timer();
  40a3ac:	17fffd60 	b	40992c <hwm_find_next_timer>
}
  40a3b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a3b4:	d65f03c0 	ret

000000000040a3b8 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
  40a3b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a3bc:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  40a3c0:	97ffff73 	bl	40a18c <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
  40a3c4:	f0000100 	adrp	x0, 42d000 <counter_period>
  40a3c8:	397fe000 	ldrb	w0, [x0, #4088]
  40a3cc:	35000060 	cbnz	w0, 40a3d8 <hw_irq_ctrl_raise_im_from_sw+0x20>
		posix_irq_handler_im_from_sw();
	}
}
  40a3d0:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler_im_from_sw();
  40a3d4:	17ffff44 	b	40a0e4 <posix_irq_handler_im_from_sw>
}
  40a3d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a3dc:	d65f03c0 	ret

000000000040a3e0 <hw_irq_ctrl_enable_irq>:
	irq_mask |= ((uint64_t)1<<irq);
  40a3e0:	d0000103 	adrp	x3, 42c000 <__dso_handle>
  40a3e4:	d2800021 	mov	x1, #0x1                   	// #1
  40a3e8:	9ac02021 	lsl	x1, x1, x0
  40a3ec:	f947e864 	ldr	x4, [x3, #4048]
  40a3f0:	aa040021 	orr	x1, x1, x4
  40a3f4:	f907e861 	str	x1, [x3, #4048]
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
  40a3f8:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a3fc:	f947ec21 	ldr	x1, [x1, #4056]
  40a400:	9ac02421 	lsr	x1, x1, x0
  40a404:	36000041 	tbz	w1, #0, 40a40c <hw_irq_ctrl_enable_irq+0x2c>
		hw_irq_ctrl_raise_im_from_sw(irq);
  40a408:	17ffffec 	b	40a3b8 <hw_irq_ctrl_raise_im_from_sw>
}
  40a40c:	d65f03c0 	ret

000000000040a410 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
  40a410:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40a414:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40a418:	f9478c00 	ldr	x0, [x0, #3864]
  40a41c:	f9000001 	str	x1, [x0]
	irq_raising_from_hw_now();
  40a420:	17ffff52 	b	40a168 <irq_raising_from_hw_now>

000000000040a424 <posix_exit>:
#include <zephyr/sys/time_units.h>
#include "cmdline.h"
#include "irq_ctrl.h"

void posix_exit(int exit_code)
{
  40a424:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a428:	910003fd 	mov	x29, sp
  40a42c:	f9000bf3 	str	x19, [sp, #16]
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
  40a430:	f0000113 	adrp	x19, 42d000 <counter_period>
  40a434:	b94bca61 	ldr	w1, [x19, #3016]
  40a438:	6b00003f 	cmp	w1, w0
  40a43c:	1a80a021 	csel	w1, w1, w0, ge  // ge = tcont
  40a440:	b90bca61 	str	w1, [x19, #3016]
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
  40a444:	97fffcd5 	bl	409798 <posix_soc_clean_up>
	hwm_cleanup();
  40a448:	97fffd94 	bl	409a98 <hwm_cleanup>
	native_cleanup_cmd_line();
  40a44c:	9400030e 	bl	40b084 <native_cleanup_cmd_line>
	exit(max_exit_code);
  40a450:	b94bca60 	ldr	w0, [x19, #3016]
  40a454:	97ffdb57 	bl	4011b0 <exit@plt>

000000000040a458 <posix_init>:
 * Run all early native_posix initialization steps, including command
 * line parsing and CPU start, until we are ready to let the HW models
 * run via hwm_one_event()
 */
void posix_init(int argc, char *argv[])
{
  40a458:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	 * Let's ensure that even if we are redirecting to a file, we get stdout
	 * and stderr line buffered (default for console)
	 * Note that glibc ignores size. But just in case we set a reasonable
	 * number in case somebody tries to compile against a different library
	 */
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a45c:	d2804003 	mov	x3, #0x200                 	// #512
  40a460:	52800022 	mov	w2, #0x1                   	// #1
{
  40a464:	910003fd 	mov	x29, sp
  40a468:	a90153f3 	stp	x19, x20, [sp, #16]
  40a46c:	2a0003f3 	mov	w19, w0
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a470:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
{
  40a474:	aa0103f4 	mov	x20, x1
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a478:	d2800001 	mov	x1, #0x0                   	// #0
  40a47c:	f9474400 	ldr	x0, [x0, #3720]
  40a480:	f9400000 	ldr	x0, [x0]
  40a484:	97ffdb6b 	bl	401230 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
  40a488:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40a48c:	d2804003 	mov	x3, #0x200                 	// #512
  40a490:	52800022 	mov	w2, #0x1                   	// #1
  40a494:	d2800001 	mov	x1, #0x0                   	// #0
  40a498:	f9471c00 	ldr	x0, [x0, #3640]
  40a49c:	f9400000 	ldr	x0, [x0]
  40a4a0:	97ffdb64 	bl	401230 <setvbuf@plt>

	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
  40a4a4:	52800000 	mov	w0, #0x0                   	// #0
  40a4a8:	97fffcaa 	bl	409750 <run_native_tasks>

	native_handle_cmd_line(argc, argv);
  40a4ac:	aa1403e1 	mov	x1, x20
  40a4b0:	2a1303e0 	mov	w0, w19
  40a4b4:	94000335 	bl	40b188 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
  40a4b8:	52800020 	mov	w0, #0x1                   	// #1
  40a4bc:	97fffca5 	bl	409750 <run_native_tasks>

	hwm_init();
  40a4c0:	97fffd6e 	bl	409a78 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
  40a4c4:	52800040 	mov	w0, #0x2                   	// #2
  40a4c8:	97fffca2 	bl	409750 <run_native_tasks>

	posix_boot_cpu();
  40a4cc:	97fffc67 	bl	409668 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
}
  40a4d0:	a94153f3 	ldp	x19, x20, [sp, #16]
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  40a4d4:	52800060 	mov	w0, #0x3                   	// #3
}
  40a4d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  40a4dc:	17fffc9d 	b	409750 <run_native_tasks>

000000000040a4e0 <main>:
 *
 * Not used when building fuzz cases, as libfuzzer has its own main()
 * and calls the "OS" through a per-case fuzz test entry point.
 */
int main(int argc, char *argv[])
{
  40a4e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a4e4:	910003fd 	mov	x29, sp
	posix_init(argc, argv);
  40a4e8:	97ffffdc 	bl	40a458 <posix_init>
	while (true) {
		hwm_one_event();
  40a4ec:	97fffd29 	bl	409990 <hwm_one_event>
	while (true) {
  40a4f0:	17ffffff 	b	40a4ec <main+0xc>

000000000040a4f4 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
  40a4f4:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a4f8:	91101000 	add	x0, x0, #0x404
  40a4fc:	f900001f 	str	xzr, [x0]
	is_a_tty[1] = 0;
}
  40a500:	d65f03c0 	ret

000000000040a504 <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
  40a504:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a508:	91101000 	add	x0, x0, #0x404
  40a50c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40a510:	f9000001 	str	x1, [x0]
	is_a_tty[1] = -1;

}
  40a514:	d65f03c0 	ret

000000000040a518 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
  40a518:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a51c:	91101000 	add	x0, x0, #0x404
  40a520:	b20003e1 	mov	x1, #0x100000001           	// #4294967297
  40a524:	f9000001 	str	x1, [x0]
	is_a_tty[1] = 1;
}
  40a528:	d65f03c0 	ret

000000000040a52c <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
  40a52c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a530:	910003fd 	mov	x29, sp
  40a534:	f9000bf3 	str	x19, [sp, #16]
	if (is_a_tty[0] == -1) {
  40a538:	d0000113 	adrp	x19, 42c000 <__dso_handle>
  40a53c:	b9440660 	ldr	w0, [x19, #1028]
  40a540:	3100041f 	cmn	w0, #0x1
  40a544:	54000081 	b.ne	40a554 <decide_about_color+0x28>  // b.any
		is_a_tty[0] = isatty(STDOUT_FILENO);
  40a548:	52800020 	mov	w0, #0x1                   	// #1
  40a54c:	97ffdbbd 	bl	401440 <isatty@plt>
  40a550:	b9040660 	str	w0, [x19, #1028]
	}
	if (is_a_tty[1] == -1) {
  40a554:	91101273 	add	x19, x19, #0x404
  40a558:	b9400660 	ldr	w0, [x19, #4]
  40a55c:	3100041f 	cmn	w0, #0x1
  40a560:	54000081 	b.ne	40a570 <decide_about_color+0x44>  // b.any
		is_a_tty[1] = isatty(STDERR_FILENO);
  40a564:	52800040 	mov	w0, #0x2                   	// #2
  40a568:	97ffdbb6 	bl	401440 <isatty@plt>
  40a56c:	b9000660 	str	w0, [x19, #4]
	}
}
  40a570:	f9400bf3 	ldr	x19, [sp, #16]
  40a574:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a578:	d65f03c0 	ret

000000000040a57c <posix_print_error_and_exit>:
{
  40a57c:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a580:	aa0003e8 	mov	x8, x0
  40a584:	910003fd 	mov	x29, sp
  40a588:	a9108be1 	stp	x1, x2, [sp, #264]
  40a58c:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
  40a590:	aa0803e2 	mov	x2, x8
  40a594:	f9476821 	ldr	x1, [x1, #3792]
  40a598:	3d8023e0 	str	q0, [sp, #128]
  40a59c:	3d8027e1 	str	q1, [sp, #144]
  40a5a0:	3d802be2 	str	q2, [sp, #160]
  40a5a4:	3d802fe3 	str	q3, [sp, #176]
  40a5a8:	3d8033e4 	str	q4, [sp, #192]
  40a5ac:	3d8037e5 	str	q5, [sp, #208]
  40a5b0:	3d803be6 	str	q6, [sp, #224]
  40a5b4:	3d803fe7 	str	q7, [sp, #240]
  40a5b8:	a91193e3 	stp	x3, x4, [sp, #280]
  40a5bc:	910043e3 	add	x3, sp, #0x10
  40a5c0:	a9129be5 	stp	x5, x6, [sp, #296]
  40a5c4:	f9009fe7 	str	x7, [sp, #312]
  40a5c8:	f9400020 	ldr	x0, [x1]
  40a5cc:	f9003fe0 	str	x0, [sp, #120]
  40a5d0:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  40a5d4:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
	va_start(variable_args, format);
  40a5d8:	910503e0 	add	x0, sp, #0x140
  40a5dc:	a90383e0 	stp	x0, x0, [sp, #56]
  40a5e0:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  40a5e4:	f9471c21 	ldr	x1, [x1, #3640]
	va_start(variable_args, format);
  40a5e8:	f90027e0 	str	x0, [sp, #72]
  40a5ec:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a5f0:	b90053e0 	str	w0, [sp, #80]
  40a5f4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a5f8:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  40a5fc:	f9400020 	ldr	x0, [x1]
  40a600:	9100e3e1 	add	x1, sp, #0x38
  40a604:	ad400420 	ldp	q0, q1, [x1]
  40a608:	910163e1 	add	x1, sp, #0x58
  40a60c:	ad000420 	stp	q0, q1, [x1]
  40a610:	52800021 	mov	w1, #0x1                   	// #1
  40a614:	ad000460 	stp	q0, q1, [x3]
  40a618:	97ffdb2a 	bl	4012c0 <__vfprintf_chk@plt>
	posix_exit(1);
  40a61c:	52800020 	mov	w0, #0x1                   	// #1
  40a620:	97ffff81 	bl	40a424 <posix_exit>
}
  40a624:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40a628:	f9476800 	ldr	x0, [x0, #3792]
  40a62c:	f9403fe2 	ldr	x2, [sp, #120]
  40a630:	f9400001 	ldr	x1, [x0]
  40a634:	eb010042 	subs	x2, x2, x1
  40a638:	d2800001 	mov	x1, #0x0                   	// #0
  40a63c:	54000040 	b.eq	40a644 <posix_print_error_and_exit+0xc8>  // b.none
  40a640:	97ffdb38 	bl	401320 <__stack_chk_fail@plt>
  40a644:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a648:	d65f03c0 	ret

000000000040a64c <posix_print_warning>:
{
  40a64c:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a650:	aa0003e8 	mov	x8, x0
  40a654:	910003fd 	mov	x29, sp
  40a658:	a9108be1 	stp	x1, x2, [sp, #264]
  40a65c:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40a660:	aa0803e2 	mov	x2, x8
  40a664:	f9476821 	ldr	x1, [x1, #3792]
  40a668:	3d8023e0 	str	q0, [sp, #128]
  40a66c:	3d8027e1 	str	q1, [sp, #144]
  40a670:	3d802be2 	str	q2, [sp, #160]
  40a674:	3d802fe3 	str	q3, [sp, #176]
  40a678:	3d8033e4 	str	q4, [sp, #192]
  40a67c:	3d8037e5 	str	q5, [sp, #208]
  40a680:	3d803be6 	str	q6, [sp, #224]
  40a684:	3d803fe7 	str	q7, [sp, #240]
  40a688:	a91193e3 	stp	x3, x4, [sp, #280]
  40a68c:	910043e3 	add	x3, sp, #0x10
  40a690:	a9129be5 	stp	x5, x6, [sp, #296]
  40a694:	f9009fe7 	str	x7, [sp, #312]
  40a698:	f9400020 	ldr	x0, [x1]
  40a69c:	f9003fe0 	str	x0, [sp, #120]
  40a6a0:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  40a6a4:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
	va_start(variable_args, format);
  40a6a8:	910503e0 	add	x0, sp, #0x140
  40a6ac:	a90383e0 	stp	x0, x0, [sp, #56]
  40a6b0:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  40a6b4:	f9471c21 	ldr	x1, [x1, #3640]
	va_start(variable_args, format);
  40a6b8:	f90027e0 	str	x0, [sp, #72]
  40a6bc:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a6c0:	b90053e0 	str	w0, [sp, #80]
  40a6c4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a6c8:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  40a6cc:	f9400020 	ldr	x0, [x1]
  40a6d0:	9100e3e1 	add	x1, sp, #0x38
  40a6d4:	ad400420 	ldp	q0, q1, [x1]
  40a6d8:	910163e1 	add	x1, sp, #0x58
  40a6dc:	ad000420 	stp	q0, q1, [x1]
  40a6e0:	52800021 	mov	w1, #0x1                   	// #1
  40a6e4:	ad000460 	stp	q0, q1, [x3]
  40a6e8:	97ffdaf6 	bl	4012c0 <__vfprintf_chk@plt>
}
  40a6ec:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40a6f0:	f9476800 	ldr	x0, [x0, #3792]
  40a6f4:	f9403fe2 	ldr	x2, [sp, #120]
  40a6f8:	f9400001 	ldr	x1, [x0]
  40a6fc:	eb010042 	subs	x2, x2, x1
  40a700:	d2800001 	mov	x1, #0x0                   	// #0
  40a704:	54000040 	b.eq	40a70c <posix_print_warning+0xc0>  // b.none
  40a708:	97ffdb06 	bl	401320 <__stack_chk_fail@plt>
  40a70c:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a710:	d65f03c0 	ret

000000000040a714 <posix_print_trace>:
{
  40a714:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a718:	aa0003e8 	mov	x8, x0
  40a71c:	910003fd 	mov	x29, sp
  40a720:	a9108be1 	stp	x1, x2, [sp, #264]
  40a724:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40a728:	aa0803e2 	mov	x2, x8
  40a72c:	f9476821 	ldr	x1, [x1, #3792]
  40a730:	3d8023e0 	str	q0, [sp, #128]
  40a734:	3d8027e1 	str	q1, [sp, #144]
  40a738:	3d802be2 	str	q2, [sp, #160]
  40a73c:	3d802fe3 	str	q3, [sp, #176]
  40a740:	3d8033e4 	str	q4, [sp, #192]
  40a744:	3d8037e5 	str	q5, [sp, #208]
  40a748:	3d803be6 	str	q6, [sp, #224]
  40a74c:	3d803fe7 	str	q7, [sp, #240]
  40a750:	a91193e3 	stp	x3, x4, [sp, #280]
  40a754:	910043e3 	add	x3, sp, #0x10
  40a758:	a9129be5 	stp	x5, x6, [sp, #296]
  40a75c:	f9009fe7 	str	x7, [sp, #312]
  40a760:	f9400020 	ldr	x0, [x1]
  40a764:	f9003fe0 	str	x0, [sp, #120]
  40a768:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stdout, format, variable_args);
  40a76c:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
	va_start(variable_args, format);
  40a770:	910503e0 	add	x0, sp, #0x140
  40a774:	a90383e0 	stp	x0, x0, [sp, #56]
  40a778:	910403e0 	add	x0, sp, #0x100
	vfprintf(stdout, format, variable_args);
  40a77c:	f9474421 	ldr	x1, [x1, #3720]
	va_start(variable_args, format);
  40a780:	f90027e0 	str	x0, [sp, #72]
  40a784:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a788:	b90053e0 	str	w0, [sp, #80]
  40a78c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a790:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stdout, format, variable_args);
  40a794:	f9400020 	ldr	x0, [x1]
  40a798:	9100e3e1 	add	x1, sp, #0x38
  40a79c:	ad400420 	ldp	q0, q1, [x1]
  40a7a0:	910163e1 	add	x1, sp, #0x58
  40a7a4:	ad000420 	stp	q0, q1, [x1]
  40a7a8:	52800021 	mov	w1, #0x1                   	// #1
  40a7ac:	ad000460 	stp	q0, q1, [x3]
  40a7b0:	97ffdac4 	bl	4012c0 <__vfprintf_chk@plt>
}
  40a7b4:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40a7b8:	f9476800 	ldr	x0, [x0, #3792]
  40a7bc:	f9403fe2 	ldr	x2, [sp, #120]
  40a7c0:	f9400001 	ldr	x1, [x0]
  40a7c4:	eb010042 	subs	x2, x2, x1
  40a7c8:	d2800001 	mov	x1, #0x0                   	// #0
  40a7cc:	54000040 	b.eq	40a7d4 <posix_print_trace+0xc0>  // b.none
  40a7d0:	97ffdad4 	bl	401320 <__stack_chk_fail@plt>
  40a7d4:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a7d8:	d65f03c0 	ret

000000000040a7dc <native_add_tracing_options>:
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
  40a7dc:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a7e0:	9107c000 	add	x0, x0, #0x1f0
  40a7e4:	14000233 	b	40b0b0 <native_add_command_line_opts>

000000000040a7e8 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
  40a7e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a7ec:	910003fd 	mov	x29, sp
  40a7f0:	a90153f3 	stp	x19, x20, [sp, #16]
  40a7f4:	aa0003f4 	mov	x20, x0
  40a7f8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a7fc:	aa0103f6 	mov	x22, x1

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
  40a800:	39400420 	ldrb	w0, [x1, #1]
  40a804:	35000440 	cbnz	w0, 40a88c <cmd_gen_switch_syntax.constprop.0+0xa4>
		*buf++ = '[';
  40a808:	52800b60 	mov	w0, #0x5b                  	// #91
		size--;
  40a80c:	528008b5 	mov	w21, #0x45                  	// #69
		*buf++ = '[';
  40a810:	38001680 	strb	w0, [x20], #1
	}

	if (args_s_el->is_switch == true) {
  40a814:	39400ac0 	ldrb	w0, [x22, #2]
		ret = snprintf(buf, size, "-%s", args_s_el->option);
  40a818:	93407ea1 	sxtw	x1, w21
  40a81c:	f94006c5 	ldr	x5, [x22, #8]
	if (args_s_el->is_switch == true) {
  40a820:	340003a0 	cbz	w0, 40a894 <cmd_gen_switch_syntax.constprop.0+0xac>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40a824:	f0000044 	adrp	x4, 415000 <random_data+0xb30>
  40a828:	aa1403e0 	mov	x0, x20
  40a82c:	911c2884 	add	x4, x4, #0x70a
  40a830:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40a834:	52800022 	mov	w2, #0x1                   	// #1
  40a838:	97ffda8a 	bl	401260 <__snprintf_chk@plt>
  40a83c:	2a0003f3 	mov	w19, w0
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
  40a840:	36f800e0 	tbz	w0, #31, 40a85c <cmd_gen_switch_syntax.constprop.0+0x74>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
  40a844:	f0000041 	adrp	x1, 415000 <random_data+0xb30>
  40a848:	f0000040 	adrp	x0, 415000 <random_data+0xb30>
  40a84c:	911c8c21 	add	x1, x1, #0x723
  40a850:	911d8400 	add	x0, x0, #0x761
  40a854:	528020e2 	mov	w2, #0x107                 	// #263
  40a858:	97ffff49 	bl	40a57c <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
  40a85c:	6b1302a1 	subs	w1, w21, w19
  40a860:	540003c4 	b.mi	40a8d8 <cmd_gen_switch_syntax.constprop.0+0xf0>  // b.first
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
  40a864:	394006c2 	ldrb	w2, [x22, #1]
	buf += ret;
  40a868:	8b33c280 	add	x0, x20, w19, sxtw
		snprintf(buf, size, "] ");
  40a86c:	93407c21 	sxtw	x1, w1
	if (args_s_el->is_mandatory == false) {
  40a870:	350002e2 	cbnz	w2, 40a8cc <cmd_gen_switch_syntax.constprop.0+0xe4>
  40a874:	d0000042 	adrp	x2, 414000 <dlc_table.0+0x60d>
  40a878:	91367842 	add	x2, x2, #0xd9e
	} else {
		snprintf(buf, size, " ");
	}
}
  40a87c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a880:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a884:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a888:	17ffda6e 	b	401240 <snprintf@plt>
  40a88c:	528008d5 	mov	w21, #0x46                  	// #70
  40a890:	17ffffe1 	b	40a814 <cmd_gen_switch_syntax.constprop.0+0x2c>
		if (args_s_el->type != 'l') {
  40a894:	394062c0 	ldrb	w0, [x22, #24]
			ret = snprintf(buf, size, "-%s=<%s>",
  40a898:	f9400ac6 	ldr	x6, [x22, #16]
		if (args_s_el->type != 'l') {
  40a89c:	7101b01f 	cmp	w0, #0x6c
  40a8a0:	54000100 	b.eq	40a8c0 <cmd_gen_switch_syntax.constprop.0+0xd8>  // b.none
  40a8a4:	f0000044 	adrp	x4, 415000 <random_data+0xb30>
  40a8a8:	911c3884 	add	x4, x4, #0x70e
  40a8ac:	aa1403e0 	mov	x0, x20
  40a8b0:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40a8b4:	52800022 	mov	w2, #0x1                   	// #1
  40a8b8:	97ffda6a 	bl	401260 <__snprintf_chk@plt>
  40a8bc:	17ffffe0 	b	40a83c <cmd_gen_switch_syntax.constprop.0+0x54>
  40a8c0:	f0000044 	adrp	x4, 415000 <random_data+0xb30>
  40a8c4:	911c5c84 	add	x4, x4, #0x717
  40a8c8:	17fffff9 	b	40a8ac <cmd_gen_switch_syntax.constprop.0+0xc4>
  40a8cc:	d0000042 	adrp	x2, 414000 <dlc_table.0+0x60d>
  40a8d0:	9136f842 	add	x2, x2, #0xdbe
  40a8d4:	17ffffea 	b	40a87c <cmd_gen_switch_syntax.constprop.0+0x94>
}
  40a8d8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a8dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a8e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a8e4:	d65f03c0 	ret

000000000040a8e8 <cmd_is_option>:
{
  40a8e8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40a8ec:	910003fd 	mov	x29, sp
  40a8f0:	a90153f3 	stp	x19, x20, [sp, #16]
  40a8f4:	aa0003f4 	mov	x20, x0
  40a8f8:	2a0203f3 	mov	w19, w2
	size_t to_match_len = strlen(option);
  40a8fc:	aa0103e0 	mov	x0, x1
{
  40a900:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a904:	aa0103f5 	mov	x21, x1
  40a908:	f9001bf7 	str	x23, [sp, #48]
	size_t to_match_len = strlen(option);
  40a90c:	97ffda25 	bl	4011a0 <strlen@plt>
  40a910:	aa0003f7 	mov	x23, x0
	if (arg[of] == '-') {
  40a914:	39400280 	ldrb	w0, [x20]
  40a918:	7100b41f 	cmp	w0, #0x2d
	if (arg[of] == '-') {
  40a91c:	9a9f17e0 	cset	x0, eq  // eq = none
	if (arg[of] == '-') {
  40a920:	1a9f17f6 	cset	w22, eq  // eq = none
	if (arg[of] == '-') {
  40a924:	38606a80 	ldrb	w0, [x20, x0]
		of++;
  40a928:	7100b41f 	cmp	w0, #0x2d
  40a92c:	1a9616d6 	cinc	w22, w22, eq  // eq = none
	if (!with_value) {
  40a930:	93407ec2 	sxtw	x2, w22
  40a934:	34000293 	cbz	w19, 40a984 <cmd_is_option+0x9c>
		if (*option == 0) {
  40a938:	cb0202b5 	sub	x21, x21, x2
	while (!(arg[of] == 0 && *option == 0)) {
  40a93c:	38626a80 	ldrb	w0, [x20, x2]
  40a940:	2a0203f3 	mov	w19, w2
		if (*option == 0) {
  40a944:	38626aa1 	ldrb	w1, [x21, x2]
	while (!(arg[of] == 0 && *option == 0)) {
  40a948:	2a010003 	orr	w3, w0, w1
  40a94c:	34000123 	cbz	w3, 40a970 <cmd_is_option+0x88>
		if (*option == 0) {
  40a950:	35000301 	cbnz	w1, 40a9b0 <cmd_is_option+0xc8>
			if ((arg[of] == ':') || (arg[of] == '=')) {
  40a954:	7100e81f 	cmp	w0, #0x3a
  40a958:	528007a1 	mov	w1, #0x3d                  	// #61
  40a95c:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40a960:	540002e1 	b.ne	40a9bc <cmd_is_option+0xd4>  // b.any
				of++;
  40a964:	11000673 	add	w19, w19, #0x1
	if (arg[of] == 0) { /* we need a value to follow */
  40a968:	3873ca80 	ldrb	w0, [x20, w19, sxtw]
  40a96c:	35000160 	cbnz	w0, 40a998 <cmd_is_option+0xb0>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
  40a970:	aa1403e1 	mov	x1, x20
  40a974:	f0000040 	adrp	x0, 415000 <random_data+0xb30>
  40a978:	911df000 	add	x0, x0, #0x77c
  40a97c:	97ffff00 	bl	40a57c <posix_print_error_and_exit>
  40a980:	14000006 	b	40a998 <cmd_is_option+0xb0>
		if (strcmp(&arg[of], option) != 0) {
  40a984:	aa1503e1 	mov	x1, x21
  40a988:	8b020280 	add	x0, x20, x2
  40a98c:	97ffda85 	bl	4013a0 <strcmp@plt>
  40a990:	35000040 	cbnz	w0, 40a998 <cmd_is_option+0xb0>
			return of + to_match_len;
  40a994:	0b1702d3 	add	w19, w22, w23
}
  40a998:	2a1303e0 	mov	w0, w19
  40a99c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a9a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a9a4:	f9401bf7 	ldr	x23, [sp, #48]
  40a9a8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40a9ac:	d65f03c0 	ret
		if (arg[of] != *option) {
  40a9b0:	91000442 	add	x2, x2, #0x1
  40a9b4:	6b01001f 	cmp	w0, w1
  40a9b8:	54fffc20 	b.eq	40a93c <cmd_is_option+0x54>  // b.none
			return 0;
  40a9bc:	52800013 	mov	w19, #0x0                   	// #0
  40a9c0:	17fffff6 	b	40a998 <cmd_is_option+0xb0>

000000000040a9c4 <cmd_is_help_option>:
{
  40a9c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a9c8:	910003fd 	mov	x29, sp
  40a9cc:	f9000bf3 	str	x19, [sp, #16]
  40a9d0:	aa0003f3 	mov	x19, x0
	if (arg[0] == '-') {
  40a9d4:	39400000 	ldrb	w0, [x0]
  40a9d8:	7100b41f 	cmp	w0, #0x2d
  40a9dc:	540000c1 	b.ne	40a9f4 <cmd_is_help_option+0x30>  // b.any
	if (arg[0] == '-') {
  40a9e0:	aa1303e0 	mov	x0, x19
		arg++;
  40a9e4:	91000a73 	add	x19, x19, #0x2
	if (arg[0] == '-') {
  40a9e8:	38401c01 	ldrb	w1, [x0, #1]!
		arg++;
  40a9ec:	7100b43f 	cmp	w1, #0x2d
  40a9f0:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	if ((strcasecmp(arg, "?") == 0) ||
  40a9f4:	f0000041 	adrp	x1, 415000 <random_data+0xb30>
  40a9f8:	aa1303e0 	mov	x0, x19
  40a9fc:	911f5821 	add	x1, x1, #0x7d6
  40aa00:	97ffda3c 	bl	4012f0 <strcasecmp@plt>
  40aa04:	340001e0 	cbz	w0, 40aa40 <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "h") == 0) ||
  40aa08:	90000061 	adrp	x1, 416000 <__func__.0+0x9cb>
  40aa0c:	aa1303e0 	mov	x0, x19
  40aa10:	91202821 	add	x1, x1, #0x80a
  40aa14:	97ffda37 	bl	4012f0 <strcasecmp@plt>
	if ((strcasecmp(arg, "?") == 0) ||
  40aa18:	34000140 	cbz	w0, 40aa40 <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "help") == 0)) {
  40aa1c:	aa1303e0 	mov	x0, x19
  40aa20:	f0000041 	adrp	x1, 415000 <random_data+0xb30>
  40aa24:	9121c821 	add	x1, x1, #0x872
  40aa28:	97ffda32 	bl	4012f0 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
  40aa2c:	7100001f 	cmp	w0, #0x0
  40aa30:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40aa34:	f9400bf3 	ldr	x19, [sp, #16]
  40aa38:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40aa3c:	d65f03c0 	ret
		return 1;
  40aa40:	52800020 	mov	w0, #0x1                   	// #1
  40aa44:	17fffffc 	b	40aa34 <cmd_is_help_option+0x70>

000000000040aa48 <cmd_read_option_value>:
{
  40aa48:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40aa4c:	910003fd 	mov	x29, sp
  40aa50:	a90153f3 	stp	x19, x20, [sp, #16]
  40aa54:	aa0103f4 	mov	x20, x1
  40aa58:	12001c41 	and	w1, w2, #0xff
  40aa5c:	b0000102 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
  40aa60:	f90013f5 	str	x21, [sp, #32]
  40aa64:	aa0303f5 	mov	x21, x3
  40aa68:	aa0003f3 	mov	x19, x0
  40aa6c:	f9476842 	ldr	x2, [x2, #3792]
  40aa70:	f9400043 	ldr	x3, [x2]
  40aa74:	f9001fe3 	str	x3, [sp, #56]
  40aa78:	d2800003 	mov	x3, #0x0                   	// #0
	char *endptr = NULL;
  40aa7c:	f9001bff 	str	xzr, [sp, #48]
	switch (type) {
  40aa80:	7101903f 	cmp	w1, #0x64
  40aa84:	54000b40 	b.eq	40abec <cmd_read_option_value+0x1a4>  // b.none
  40aa88:	54000168 	b.hi	40aab4 <cmd_read_option_value+0x6c>  // b.pmore
  40aa8c:	7101543f 	cmp	w1, #0x55
  40aa90:	540009c0 	b.eq	40abc8 <cmd_read_option_value+0x180>  // b.none
  40aa94:	7101883f 	cmp	w1, #0x62
  40aa98:	54000220 	b.eq	40aadc <cmd_read_option_value+0x94>  // b.none
  40aa9c:	7101243f 	cmp	w1, #0x49
  40aaa0:	540009e0 	b.eq	40abdc <cmd_read_option_value+0x194>  // b.none
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
  40aaa4:	f0000040 	adrp	x0, 415000 <random_data+0xb30>
  40aaa8:	91209c00 	add	x0, x0, #0x827
  40aaac:	97fffeb4 	bl	40a57c <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
  40aab0:	14000012 	b	40aaf8 <cmd_read_option_value+0xb0>
	switch (type) {
  40aab4:	7101cc3f 	cmp	w1, #0x73
  40aab8:	54000760 	b.eq	40aba4 <cmd_read_option_value+0x15c>  // b.none
  40aabc:	7101d43f 	cmp	w1, #0x75
  40aac0:	540007a0 	b.eq	40abb4 <cmd_read_option_value+0x16c>  // b.none
  40aac4:	7101a43f 	cmp	w1, #0x69
  40aac8:	54fffee1 	b.ne	40aaa4 <cmd_read_option_value+0x5c>  // b.any
		*(int32_t *)dest = strtol(str, &endptr, 0);
  40aacc:	9100c3e1 	add	x1, sp, #0x30
  40aad0:	52800002 	mov	w2, #0x0                   	// #0
  40aad4:	97ffda3f 	bl	4013d0 <strtol@plt>
  40aad8:	1400003a 	b	40abc0 <cmd_read_option_value+0x178>
		if (strcasecmp(str, "false") == 0) {
  40aadc:	f0000041 	adrp	x1, 415000 <random_data+0xb30>
  40aae0:	911f6021 	add	x1, x1, #0x7d8
  40aae4:	97ffda03 	bl	4012f0 <strcasecmp@plt>
  40aae8:	35000120 	cbnz	w0, 40ab0c <cmd_read_option_value+0xc4>
			endptr = (char *)str + 5;
  40aaec:	91001660 	add	x0, x19, #0x5
			*(bool *)dest = false;
  40aaf0:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  40aaf4:	f9001be0 	str	x0, [sp, #48]
	if (!error && endptr && *endptr != 0) {
  40aaf8:	f9401be0 	ldr	x0, [sp, #48]
  40aafc:	b40003e0 	cbz	x0, 40ab78 <cmd_read_option_value+0x130>
  40ab00:	39400000 	ldrb	w0, [x0]
  40ab04:	35000300 	cbnz	w0, 40ab64 <cmd_read_option_value+0x11c>
  40ab08:	1400001c 	b	40ab78 <cmd_read_option_value+0x130>
		} else if (strcmp(str, "0") == 0) {
  40ab0c:	90000061 	adrp	x1, 416000 <__func__.0+0x9cb>
  40ab10:	aa1303e0 	mov	x0, x19
  40ab14:	9128c821 	add	x1, x1, #0xa32
  40ab18:	97ffda22 	bl	4013a0 <strcmp@plt>
  40ab1c:	35000080 	cbnz	w0, 40ab2c <cmd_read_option_value+0xe4>
			*(bool *)dest = false;
  40ab20:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  40ab24:	91000660 	add	x0, x19, #0x1
  40ab28:	17fffff3 	b	40aaf4 <cmd_read_option_value+0xac>
		} else if (strcasecmp(str, "true") == 0) {
  40ab2c:	f0000041 	adrp	x1, 415000 <random_data+0xb30>
  40ab30:	aa1303e0 	mov	x0, x19
  40ab34:	911f7821 	add	x1, x1, #0x7de
  40ab38:	97ffd9ee 	bl	4012f0 <strcasecmp@plt>
  40ab3c:	350000a0 	cbnz	w0, 40ab50 <cmd_read_option_value+0x108>
			*(bool *)dest = true;
  40ab40:	52800020 	mov	w0, #0x1                   	// #1
  40ab44:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 4;
  40ab48:	91001260 	add	x0, x19, #0x4
  40ab4c:	17ffffea 	b	40aaf4 <cmd_read_option_value+0xac>
		} else if (strcmp(str, "1") == 0) {
  40ab50:	f0000041 	adrp	x1, 415000 <random_data+0xb30>
  40ab54:	aa1303e0 	mov	x0, x19
  40ab58:	911f8c21 	add	x1, x1, #0x7e3
  40ab5c:	97ffda11 	bl	4013a0 <strcmp@plt>
  40ab60:	340001c0 	cbz	w0, 40ab98 <cmd_read_option_value+0x150>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
  40ab64:	f0000040 	adrp	x0, 415000 <random_data+0xb30>
  40ab68:	aa1303e2 	mov	x2, x19
  40ab6c:	aa1503e1 	mov	x1, x21
  40ab70:	911f9400 	add	x0, x0, #0x7e5
  40ab74:	97fffe82 	bl	40a57c <posix_print_error_and_exit>
}
  40ab78:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40ab7c:	f9476800 	ldr	x0, [x0, #3792]
  40ab80:	f9401fe2 	ldr	x2, [sp, #56]
  40ab84:	f9400001 	ldr	x1, [x0]
  40ab88:	eb010042 	subs	x2, x2, x1
  40ab8c:	d2800001 	mov	x1, #0x0                   	// #0
  40ab90:	54000360 	b.eq	40abfc <cmd_read_option_value+0x1b4>  // b.none
  40ab94:	97ffd9e3 	bl	401320 <__stack_chk_fail@plt>
			*(bool *)dest = true;
  40ab98:	52800020 	mov	w0, #0x1                   	// #1
  40ab9c:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 1;
  40aba0:	17ffffe1 	b	40ab24 <cmd_read_option_value+0xdc>
		*(char **)dest = (char *)str;
  40aba4:	f9000280 	str	x0, [x20]
		endptr = (char *)str + strlen(str);
  40aba8:	97ffd97e 	bl	4011a0 <strlen@plt>
  40abac:	8b000260 	add	x0, x19, x0
  40abb0:	17ffffd1 	b	40aaf4 <cmd_read_option_value+0xac>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
  40abb4:	9100c3e1 	add	x1, sp, #0x30
  40abb8:	52800002 	mov	w2, #0x0                   	// #0
  40abbc:	97ffd975 	bl	401190 <strtoul@plt>
		*(int32_t *)dest = strtol(str, &endptr, 0);
  40abc0:	b9000280 	str	w0, [x20]
	if (!error && endptr && *endptr != 0) {
  40abc4:	17ffffcd 	b	40aaf8 <cmd_read_option_value+0xb0>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
  40abc8:	9100c3e1 	add	x1, sp, #0x30
  40abcc:	52800002 	mov	w2, #0x0                   	// #0
  40abd0:	97ffda14 	bl	401420 <strtoull@plt>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  40abd4:	f9000280 	str	x0, [x20]
	if (!error && endptr && *endptr != 0) {
  40abd8:	17ffffc8 	b	40aaf8 <cmd_read_option_value+0xb0>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  40abdc:	9100c3e1 	add	x1, sp, #0x30
  40abe0:	52800002 	mov	w2, #0x0                   	// #0
  40abe4:	97ffd97b 	bl	4011d0 <strtoll@plt>
  40abe8:	17fffffb 	b	40abd4 <cmd_read_option_value+0x18c>
		*(double *)dest = strtod(str, &endptr);
  40abec:	9100c3e1 	add	x1, sp, #0x30
  40abf0:	97ffd980 	bl	4011f0 <strtod@plt>
  40abf4:	fd000280 	str	d0, [x20]
	if (!error && endptr && *endptr != 0) {
  40abf8:	17ffffc0 	b	40aaf8 <cmd_read_option_value+0xb0>
}
  40abfc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ac00:	f94013f5 	ldr	x21, [sp, #32]
  40ac04:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40ac08:	d65f03c0 	ret

000000000040ac0c <cmd_args_set_defaults>:
{
  40ac0c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40ac10:	910003fd 	mov	x29, sp
  40ac14:	a90153f3 	stp	x19, x20, [sp, #16]
  40ac18:	91002013 	add	x19, x0, #0x8
			*(double *)args_struct[count].dest = (double)NAN;
  40ac1c:	b0000040 	adrp	x0, 413000 <sys_clock_announce+0x19c>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  40ac20:	f0000054 	adrp	x20, 415000 <random_data+0xb30>
  40ac24:	91209e94 	add	x20, x20, #0x827
{
  40ac28:	fd001be8 	str	d8, [sp, #48]
			*(double *)args_struct[count].dest = (double)NAN;
  40ac2c:	fd43c408 	ldr	d8, [x0, #1928]
{
  40ac30:	a9025bf5 	stp	x21, x22, [sp, #32]
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  40ac34:	12800015 	mov	w21, #0xffffffff            	// #-1
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  40ac38:	12b00016 	mov	w22, #0x7fffffff            	// #2147483647
	while (args_struct[count].option != NULL) {
  40ac3c:	f9400260 	ldr	x0, [x19]
  40ac40:	b50000c0 	cbnz	x0, 40ac58 <cmd_args_set_defaults+0x4c>
}
  40ac44:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ac48:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ac4c:	fd401be8 	ldr	d8, [sp, #48]
  40ac50:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40ac54:	d65f03c0 	ret
		if (args_struct[count].dest == NULL) {
  40ac58:	f9400e62 	ldr	x2, [x19, #24]
  40ac5c:	b4000222 	cbz	x2, 40aca0 <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  40ac60:	39404261 	ldrb	w1, [x19, #16]
  40ac64:	7101903f 	cmp	w1, #0x64
  40ac68:	54000420 	b.eq	40acec <cmd_args_set_defaults+0xe0>  // b.none
  40ac6c:	540001e8 	b.hi	40aca8 <cmd_args_set_defaults+0x9c>  // b.pmore
  40ac70:	7101543f 	cmp	w1, #0x55
  40ac74:	54000320 	b.eq	40acd8 <cmd_args_set_defaults+0xcc>  // b.none
  40ac78:	540000e8 	b.hi	40ac94 <cmd_args_set_defaults+0x88>  // b.pmore
  40ac7c:	34000121 	cbz	w1, 40aca0 <cmd_args_set_defaults+0x94>
  40ac80:	7101243f 	cmp	w1, #0x49
  40ac84:	54000300 	b.eq	40ace4 <cmd_args_set_defaults+0xd8>  // b.none
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  40ac88:	aa1403e0 	mov	x0, x20
  40ac8c:	97fffe3c 	bl	40a57c <posix_print_error_and_exit>
			break;
  40ac90:	14000004 	b	40aca0 <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  40ac94:	7101883f 	cmp	w1, #0x62
  40ac98:	54ffff81 	b.ne	40ac88 <cmd_args_set_defaults+0x7c>  // b.any
			*(bool *)args_struct[count].dest = false;
  40ac9c:	3900005f 	strb	wzr, [x2]
			break;
  40aca0:	9100e273 	add	x19, x19, #0x38
  40aca4:	17ffffe6 	b	40ac3c <cmd_args_set_defaults+0x30>
		switch (args_struct[count].type) {
  40aca8:	7101cc3f 	cmp	w1, #0x73
  40acac:	540000e0 	b.eq	40acc8 <cmd_args_set_defaults+0xbc>  // b.none
  40acb0:	7101d43f 	cmp	w1, #0x75
  40acb4:	540000e0 	b.eq	40acd0 <cmd_args_set_defaults+0xc4>  // b.none
  40acb8:	7101a43f 	cmp	w1, #0x69
  40acbc:	54fffe61 	b.ne	40ac88 <cmd_args_set_defaults+0x7c>  // b.any
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  40acc0:	b9000056 	str	w22, [x2]
			break;
  40acc4:	17fffff7 	b	40aca0 <cmd_args_set_defaults+0x94>
			*(char **)args_struct[count].dest = NULL;
  40acc8:	f900005f 	str	xzr, [x2]
			break;
  40accc:	17fffff5 	b	40aca0 <cmd_args_set_defaults+0x94>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  40acd0:	b9000055 	str	w21, [x2]
			break;
  40acd4:	17fffff3 	b	40aca0 <cmd_args_set_defaults+0x94>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
  40acd8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  40acdc:	f9000040 	str	x0, [x2]
			break;
  40ace0:	17fffff0 	b	40aca0 <cmd_args_set_defaults+0x94>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  40ace4:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  40ace8:	17fffffd 	b	40acdc <cmd_args_set_defaults+0xd0>
			*(double *)args_struct[count].dest = (double)NAN;
  40acec:	fd000048 	str	d8, [x2]
			break;
  40acf0:	17ffffec 	b	40aca0 <cmd_args_set_defaults+0x94>

000000000040acf4 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
  40acf4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  40acf8:	f0000043 	adrp	x3, 415000 <random_data+0xb30>
  40acfc:	d0000042 	adrp	x2, 414000 <dlc_table.0+0x60d>
  40ad00:	910003fd 	mov	x29, sp
  40ad04:	a90153f3 	stp	x19, x20, [sp, #16]
  40ad08:	aa0003f4 	mov	x20, x0
  40ad0c:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;

	fprintf(stdout, "%s ", _HELP_SWITCH);
  40ad10:	b0000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
{
  40ad14:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ad18:	91213063 	add	x3, x3, #0x84c
  40ad1c:	f9476800 	ldr	x0, [x0, #3792]
  40ad20:	a90363f7 	stp	x23, x24, [sp, #48]
  40ad24:	9135e042 	add	x2, x2, #0xd78
  40ad28:	f9400001 	ldr	x1, [x0]
  40ad2c:	f90047e1 	str	x1, [sp, #136]
  40ad30:	d2800001 	mov	x1, #0x0                   	// #0
  40ad34:	f0000057 	adrp	x23, 415000 <random_data+0xb30>
	fprintf(stdout, "%s ", _HELP_SWITCH);
  40ad38:	f9474660 	ldr	x0, [x19, #3720]
  40ad3c:	f0000058 	adrp	x24, 415000 <random_data+0xb30>

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40ad40:	910103f6 	add	x22, sp, #0x40
  40ad44:	913b7af7 	add	x23, x23, #0xede
  40ad48:	911c2f18 	add	x24, x24, #0x70b
  40ad4c:	52800021 	mov	w1, #0x1                   	// #1
  40ad50:	f9400000 	ldr	x0, [x0]
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
  40ad54:	52800335 	mov	w21, #0x19                  	// #25
  40ad58:	97ffd98e 	bl	401390 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
  40ad5c:	f9400680 	ldr	x0, [x20, #8]
  40ad60:	b5000120 	cbnz	x0, 40ad84 <cmd_print_switches_help+0x90>
  40ad64:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40ad68:	f9476800 	ldr	x0, [x0, #3792]
  40ad6c:	f94047e2 	ldr	x2, [sp, #136]
  40ad70:	f9400001 	ldr	x1, [x0]
  40ad74:	eb010042 	subs	x2, x2, x1
  40ad78:	d2800001 	mov	x1, #0x0                   	// #0
  40ad7c:	54000360 	b.eq	40ade8 <cmd_print_switches_help+0xf4>  // b.none
  40ad80:	97ffd968 	bl	401320 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40ad84:	aa1403e1 	mov	x1, x20
  40ad88:	aa1603e0 	mov	x0, x22
  40ad8c:	97fffe97 	bl	40a7e8 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
  40ad90:	aa1603e0 	mov	x0, x22
  40ad94:	97ffd903 	bl	4011a0 <strlen@plt>
  40ad98:	8b35c000 	add	x0, x0, w21, sxtw
  40ad9c:	f101901f 	cmp	x0, #0x64
  40ada0:	540000e9 	b.ls	40adbc <cmd_print_switches_help+0xc8>  // b.plast
			fprintf(stdout, "\n");
  40ada4:	f9474660 	ldr	x0, [x19, #3720]
  40ada8:	aa1703e2 	mov	x2, x23
  40adac:	52800021 	mov	w1, #0x1                   	// #1
			printed_in_line = 0;
  40adb0:	52800015 	mov	w21, #0x0                   	// #0
  40adb4:	f9400000 	ldr	x0, [x0]
  40adb8:	97ffd976 	bl	401390 <__fprintf_chk@plt>
		}

		fprintf(stdout, "%s", stringy);
  40adbc:	f9474660 	ldr	x0, [x19, #3720]
  40adc0:	aa1603e3 	mov	x3, x22
  40adc4:	aa1803e2 	mov	x2, x24
  40adc8:	52800021 	mov	w1, #0x1                   	// #1
  40adcc:	9100e294 	add	x20, x20, #0x38
  40add0:	f9400000 	ldr	x0, [x0]
  40add4:	97ffd96f 	bl	401390 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
  40add8:	aa1603e0 	mov	x0, x22
  40addc:	97ffd8f1 	bl	4011a0 <strlen@plt>
  40ade0:	0b0002b5 	add	w21, w21, w0
		count++;
  40ade4:	17ffffde 	b	40ad5c <cmd_print_switches_help+0x68>
	}

	fprintf(stdout, "\n");
  40ade8:	f9474673 	ldr	x19, [x19, #3720]
  40adec:	f0000042 	adrp	x2, 415000 <random_data+0xb30>
}
  40adf0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40adf4:	913b7842 	add	x2, x2, #0xede
  40adf8:	f9400260 	ldr	x0, [x19]
  40adfc:	52800021 	mov	w1, #0x1                   	// #1
  40ae00:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ae04:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ae08:	a8c97bfd 	ldp	x29, x30, [sp], #144
  40ae0c:	17ffd961 	b	401390 <__fprintf_chk@plt>

000000000040ae10 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
  40ae10:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  40ae14:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40ae18:	910003fd 	mov	x29, sp
  40ae1c:	f9476821 	ldr	x1, [x1, #3792]
  40ae20:	a90153f3 	stp	x19, x20, [sp, #16]
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  40ae24:	b0000114 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
{
  40ae28:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ae2c:	aa0003f3 	mov	x19, x0
  40ae30:	a90363f7 	stp	x23, x24, [sp, #48]
  40ae34:	f0000057 	adrp	x23, 415000 <random_data+0xb30>
  40ae38:	f0000058 	adrp	x24, 415000 <random_data+0xb30>
  40ae3c:	a9046bf9 	stp	x25, x26, [sp, #64]
  40ae40:	91220af7 	add	x23, x23, #0x882
  40ae44:	913b7f18 	add	x24, x24, #0xedf
  40ae48:	a90573fb 	stp	x27, x28, [sp, #80]
  40ae4c:	f9400022 	ldr	x2, [x1]
  40ae50:	f90057e2 	str	x2, [sp, #168]
  40ae54:	d2800002 	mov	x2, #0x0                   	// #0
	cmd_print_switches_help(args_struct);
  40ae58:	97ffffa7 	bl	40acf4 <cmd_print_switches_help>
	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  40ae5c:	f9474680 	ldr	x0, [x20, #3720]
  40ae60:	f0000045 	adrp	x5, 415000 <random_data+0xb30>
  40ae64:	f0000044 	adrp	x4, 415000 <random_data+0xb30>
  40ae68:	f0000042 	adrp	x2, 415000 <random_data+0xb30>
  40ae6c:	912194a5 	add	x5, x5, #0x865
  40ae70:	91213084 	add	x4, x4, #0x84c
  40ae74:	f9400000 	ldr	x0, [x0]
  40ae78:	9121dc42 	add	x2, x2, #0x877
  40ae7c:	528003a3 	mov	w3, #0x1d                  	// #29
  40ae80:	52800021 	mov	w1, #0x1                   	// #1
  40ae84:	97ffd943 	bl	401390 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
  40ae88:	f9400660 	ldr	x0, [x19, #8]
  40ae8c:	b5000280 	cbnz	x0, 40aedc <cmd_print_long_help+0xcc>
				      &toprint[printed_right]);
			printed_right += ret - 1;
		}
		count++;
	}
	fprintf(stdout, "\n");
  40ae90:	f9474694 	ldr	x20, [x20, #3720]
  40ae94:	52800021 	mov	w1, #0x1                   	// #1
  40ae98:	f0000042 	adrp	x2, 415000 <random_data+0xb30>
  40ae9c:	913b7842 	add	x2, x2, #0xede
  40aea0:	f9400280 	ldr	x0, [x20]
  40aea4:	97ffd93b 	bl	401390 <__fprintf_chk@plt>
  40aea8:	f9400280 	ldr	x0, [x20]
  40aeac:	52800021 	mov	w1, #0x1                   	// #1
  40aeb0:	f0000042 	adrp	x2, 415000 <random_data+0xb30>
  40aeb4:	91224c42 	add	x2, x2, #0x893
  40aeb8:	97ffd936 	bl	401390 <__fprintf_chk@plt>
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
  40aebc:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40aec0:	f9476800 	ldr	x0, [x0, #3792]
  40aec4:	f94057e2 	ldr	x2, [sp, #168]
  40aec8:	f9400001 	ldr	x1, [x0]
  40aecc:	eb010042 	subs	x2, x2, x1
  40aed0:	d2800001 	mov	x1, #0x0                   	// #0
  40aed4:	54000600 	b.eq	40af94 <cmd_print_long_help+0x184>  // b.none
  40aed8:	97ffd912 	bl	401320 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40aedc:	910183f5 	add	x21, sp, #0x60
  40aee0:	aa1303e1 	mov	x1, x19
  40aee4:	aa1503e0 	mov	x0, x21
  40aee8:	97fffe40 	bl	40a7e8 <cmd_gen_switch_syntax.constprop.0>
		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
  40aeec:	f9474696 	ldr	x22, [x20, #3720]
  40aef0:	aa1503e4 	mov	x4, x21
  40aef4:	aa1703e2 	mov	x2, x23
  40aef8:	528003a3 	mov	w3, #0x1d                  	// #29
  40aefc:	52800021 	mov	w1, #0x1                   	// #1
  40af00:	f000005b 	adrp	x27, 415000 <random_data+0xb30>
  40af04:	f94002c0 	ldr	x0, [x22]
  40af08:	f000005c 	adrp	x28, 415000 <random_data+0xb30>
  40af0c:	91223f9c 	add	x28, x28, #0x88f
  40af10:	97ffd920 	bl	401390 <__fprintf_chk@plt>
  40af14:	2a0003f5 	mov	w21, w0
		toprint = args_struct[count].descript;
  40af18:	f9401a7a 	ldr	x26, [x19, #48]
		total_to_print = strlen(toprint);
  40af1c:	aa1a03e0 	mov	x0, x26
  40af20:	97ffd8a0 	bl	4011a0 <strlen@plt>
  40af24:	2a0003f9 	mov	w25, w0
  40af28:	aa1a03e4 	mov	x4, x26
  40af2c:	f94002c0 	ldr	x0, [x22]
  40af30:	91222762 	add	x2, x27, #0x889
  40af34:	52800c83 	mov	w3, #0x64                  	// #100
  40af38:	52800021 	mov	w1, #0x1                   	// #1
  40af3c:	4b150063 	sub	w3, w3, w21
  40af40:	97ffd914 	bl	401390 <__fprintf_chk@plt>
		printed_right += ret - 1;
  40af44:	51000415 	sub	w21, w0, #0x1
		while (printed_right < total_to_print) {
  40af48:	6b1902bf 	cmp	w21, w25
  40af4c:	5400006b 	b.lt	40af58 <cmd_print_long_help+0x148>  // b.tstop
		count++;
  40af50:	9100e273 	add	x19, x19, #0x38
  40af54:	17ffffcd 	b	40ae88 <cmd_print_long_help+0x78>
  40af58:	f94002c0 	ldr	x0, [x22]
  40af5c:	aa1803e4 	mov	x4, x24
  40af60:	aa1c03e2 	mov	x2, x28
  40af64:	528003c3 	mov	w3, #0x1e                  	// #30
  40af68:	52800021 	mov	w1, #0x1                   	// #1
  40af6c:	97ffd909 	bl	401390 <__fprintf_chk@plt>
  40af70:	f94002c0 	ldr	x0, [x22]
  40af74:	8b35c344 	add	x4, x26, w21, sxtw
  40af78:	91222762 	add	x2, x27, #0x889
  40af7c:	528008c3 	mov	w3, #0x46                  	// #70
  40af80:	52800021 	mov	w1, #0x1                   	// #1
  40af84:	97ffd903 	bl	401390 <__fprintf_chk@plt>
			printed_right += ret - 1;
  40af88:	51000400 	sub	w0, w0, #0x1
  40af8c:	0b0002b5 	add	w21, w21, w0
  40af90:	17ffffee 	b	40af48 <cmd_print_long_help+0x138>
}
  40af94:	a94153f3 	ldp	x19, x20, [sp, #16]
  40af98:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40af9c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40afa0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40afa4:	a94573fb 	ldp	x27, x28, [sp, #80]
  40afa8:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  40afac:	d65f03c0 	ret

000000000040afb0 <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
  40afb0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40afb4:	910003fd 	mov	x29, sp
  40afb8:	a90153f3 	stp	x19, x20, [sp, #16]
  40afbc:	aa0003f4 	mov	x20, x0
  40afc0:	aa0103f3 	mov	x19, x1
  40afc4:	f90013f5 	str	x21, [sp, #32]
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
  40afc8:	97fffe7f 	bl	40a9c4 <cmd_is_help_option>
  40afcc:	340000a0 	cbz	w0, 40afe0 <cmd_parse_one_arg+0x30>
		cmd_print_long_help(args_struct);
  40afd0:	aa1303e0 	mov	x0, x19
  40afd4:	97ffff8f 	bl	40ae10 <cmd_print_long_help>
		posix_exit(0);
  40afd8:	52800000 	mov	w0, #0x0                   	// #0
  40afdc:	97fffd12 	bl	40a424 <posix_exit>
	}

	while (args_struct[count].option != NULL) {
  40afe0:	f9400661 	ldr	x1, [x19, #8]
  40afe4:	b50000c1 	cbnz	x1, 40affc <cmd_parse_one_arg+0x4c>
						    &args_struct[count]);
			return true;
		}
		count++;
	}
	return false;
  40afe8:	52800000 	mov	w0, #0x0                   	// #0
}
  40afec:	a94153f3 	ldp	x19, x20, [sp, #16]
  40aff0:	f94013f5 	ldr	x21, [sp, #32]
  40aff4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40aff8:	d65f03c0 	ret
		if (args_struct[count].manual) {
  40affc:	39400260 	ldrb	w0, [x19]
  40b000:	350003e0 	cbnz	w0, 40b07c <cmd_parse_one_arg+0xcc>
				    !args_struct[count].is_switch);
  40b004:	39400a62 	ldrb	w2, [x19, #2]
		ret = cmd_is_option(argv, args_struct[count].option,
  40b008:	aa1403e0 	mov	x0, x20
  40b00c:	52000042 	eor	w2, w2, #0x1
  40b010:	97fffe36 	bl	40a8e8 <cmd_is_option>
  40b014:	2a0003f5 	mov	w21, w0
		if (ret) {
  40b018:	34000320 	cbz	w0, 40b07c <cmd_parse_one_arg+0xcc>
	if (arg_element->dest != NULL) {
  40b01c:	f9401261 	ldr	x1, [x19, #32]
  40b020:	b4000101 	cbz	x1, 40b040 <cmd_parse_one_arg+0x90>
		if (arg_element->is_switch) {
  40b024:	39400a60 	ldrb	w0, [x19, #2]
			if (arg_element->type == 'b') {
  40b028:	39406262 	ldrb	w2, [x19, #24]
		if (arg_element->is_switch) {
  40b02c:	34000200 	cbz	w0, 40b06c <cmd_parse_one_arg+0xbc>
			if (arg_element->type == 'b') {
  40b030:	7101885f 	cmp	w2, #0x62
  40b034:	54000141 	b.ne	40b05c <cmd_parse_one_arg+0xac>  // b.any
				*(bool *)arg_element->dest = true;
  40b038:	52800020 	mov	w0, #0x1                   	// #1
  40b03c:	39000020 	strb	w0, [x1]
	if (arg_element->call_when_found) {
  40b040:	f9401662 	ldr	x2, [x19, #40]
  40b044:	b4000082 	cbz	x2, 40b054 <cmd_parse_one_arg+0xa4>
		arg_element->call_when_found(argv, offset);
  40b048:	2a1503e1 	mov	w1, w21
  40b04c:	aa1403e0 	mov	x0, x20
  40b050:	d63f0040 	blr	x2
			return true;
  40b054:	52800020 	mov	w0, #0x1                   	// #1
  40b058:	17ffffe5 	b	40afec <cmd_parse_one_arg+0x3c>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
  40b05c:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b060:	91238c00 	add	x0, x0, #0x8e3
  40b064:	97fffd46 	bl	40a57c <posix_print_error_and_exit>
  40b068:	17fffff6 	b	40b040 <cmd_parse_one_arg+0x90>
			cmd_read_option_value(&argv[offset],
  40b06c:	f9400663 	ldr	x3, [x19, #8]
  40b070:	8b35c280 	add	x0, x20, w21, sxtw
  40b074:	97fffe75 	bl	40aa48 <cmd_read_option_value>
  40b078:	17fffff2 	b	40b040 <cmd_parse_one_arg+0x90>
  40b07c:	9100e273 	add	x19, x19, #0x38
  40b080:	17ffffd8 	b	40afe0 <cmd_parse_one_arg+0x30>

000000000040b084 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
  40b084:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b088:	910003fd 	mov	x29, sp
  40b08c:	f9000bf3 	str	x19, [sp, #16]
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
  40b090:	b0000113 	adrp	x19, 42c000 <__dso_handle>
  40b094:	f947f660 	ldr	x0, [x19, #4072]
  40b098:	b4000060 	cbz	x0, 40b0a4 <native_cleanup_cmd_line+0x20>
		free(args_struct);
  40b09c:	97ffd8d1 	bl	4013e0 <free@plt>
		args_struct = NULL;
  40b0a0:	f907f67f 	str	xzr, [x19, #4072]
	}
}
  40b0a4:	f9400bf3 	ldr	x19, [sp, #16]
  40b0a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b0ac:	d65f03c0 	ret

000000000040b0b0 <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
  40b0b0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b0b4:	910003fd 	mov	x29, sp
  40b0b8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b0bc:	aa0003f5 	mov	x21, x0
  40b0c0:	91002000 	add	x0, x0, #0x8
  40b0c4:	a90153f3 	stp	x19, x20, [sp, #16]
	int count = 0;
  40b0c8:	52800013 	mov	w19, #0x0                   	// #0
{
  40b0cc:	a90363f7 	stp	x23, x24, [sp, #48]
  40b0d0:	f90023f9 	str	x25, [sp, #64]

	while (args[count].option != NULL) {
  40b0d4:	f8438401 	ldr	x1, [x0], #56
  40b0d8:	2a1303f7 	mov	w23, w19
		count++;
  40b0dc:	11000673 	add	w19, w19, #0x1
	while (args[count].option != NULL) {
  40b0e0:	b5ffffa1 	cbnz	x1, 40b0d4 <native_add_command_line_opts+0x24>
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
  40b0e4:	d0000116 	adrp	x22, 42d000 <counter_period>
  40b0e8:	d0000119 	adrp	x25, 42d000 <counter_period>
  40b0ec:	b0000118 	adrp	x24, 42c000 <__dso_handle>
  40b0f0:	b94bdac0 	ldr	w0, [x22, #3032]
  40b0f4:	b94bcf21 	ldr	w1, [x25, #3020]
  40b0f8:	0b000260 	add	w0, w19, w0
  40b0fc:	6b01001f 	cmp	w0, w1
  40b100:	540001cb 	b.lt	40b138 <native_add_command_line_opts+0x88>  // b.tstop
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
  40b104:	7100527f 	cmp	w19, #0x14
  40b108:	52800294 	mov	w20, #0x14                  	// #20
  40b10c:	1a94a274 	csel	w20, w19, w20, ge  // ge = tcont
  40b110:	0b010294 	add	w20, w20, w1
		struct args_struct_t *new_args_struct = realloc(args_struct,
  40b114:	52800701 	mov	w1, #0x38                  	// #56
  40b118:	f947f700 	ldr	x0, [x24, #4072]
  40b11c:	9b217e81 	smull	x1, w20, w1
  40b120:	97ffd878 	bl	401300 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
  40b124:	b90bcf34 	str	w20, [x25, #3020]
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
  40b128:	b5000260 	cbnz	x0, 40b174 <native_add_command_line_opts+0xc4>
			posix_print_error_and_exit("Could not allocate memory");
  40b12c:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b130:	9124b800 	add	x0, x0, #0x92e
  40b134:	97fffd12 	bl	40a57c <posix_print_error_and_exit>
			args_struct = new_args_struct;
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
  40b138:	b94bdad4 	ldr	w20, [x22, #3032]
  40b13c:	52800700 	mov	w0, #0x38                  	// #56
  40b140:	f947f703 	ldr	x3, [x24, #4072]
  return __builtin___memcpy_chk (__dest, __src, __len,
  40b144:	9b207e62 	smull	x2, w19, w0
  40b148:	aa1503e1 	mov	x1, x21
  40b14c:	9b200e80 	smaddl	x0, w20, w0, x3
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
  40b150:	0b170294 	add	w20, w20, w23
  40b154:	97ffd807 	bl	401170 <memcpy@plt>
  40b158:	b90bdad4 	str	w20, [x22, #3032]
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
  40b15c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b160:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b164:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b168:	f94023f9 	ldr	x25, [sp, #64]
  40b16c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40b170:	d65f03c0 	ret
			args_struct = new_args_struct;
  40b174:	f907f700 	str	x0, [x24, #4072]
  40b178:	17fffff0 	b	40b138 <native_add_command_line_opts+0x88>

000000000040b17c <native_add_testargs_option>:
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
  40b17c:	b0000100 	adrp	x0, 42c000 <__dso_handle>
  40b180:	910b4000 	add	x0, x0, #0x2d0
  40b184:	17ffffcb 	b	40b0b0 <native_add_command_line_opts>

000000000040b188 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
  40b188:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b18c:	910003fd 	mov	x29, sp
  40b190:	a90153f3 	stp	x19, x20, [sp, #16]
  40b194:	aa0103f4 	mov	x20, x1
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
  40b198:	d2800033 	mov	x19, #0x1                   	// #1
{
  40b19c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b1a0:	2a0003f5 	mov	w21, w0
  40b1a4:	a90363f7 	stp	x23, x24, [sp, #48]
	cmd_args_set_defaults(args_struct);
  40b1a8:	b0000118 	adrp	x24, 42c000 <__dso_handle>
{
  40b1ac:	a9046bf9 	stp	x25, x26, [sp, #64]
	native_add_tracing_options();
  40b1b0:	97fffd8b 	bl	40a7dc <native_add_tracing_options>
	native_add_testargs_option();
  40b1b4:	97fffff2 	bl	40b17c <native_add_testargs_option>
	s_argv = argv;
  40b1b8:	b0000100 	adrp	x0, 42c000 <__dso_handle>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40b1bc:	d0000059 	adrp	x25, 415000 <random_data+0xb30>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40b1c0:	d000005a 	adrp	x26, 415000 <random_data+0xb30>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40b1c4:	91252339 	add	x25, x25, #0x948
	s_argv = argv;
  40b1c8:	f907f814 	str	x20, [x0, #4080]
	s_argc = argc;
  40b1cc:	d0000100 	adrp	x0, 42d000 <counter_period>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40b1d0:	9125475a 	add	x26, x26, #0x951
	s_argc = argc;
  40b1d4:	b90bd015 	str	w21, [x0, #3024]
	cmd_args_set_defaults(args_struct);
  40b1d8:	f947f700 	ldr	x0, [x24, #4072]
  40b1dc:	97fffe8c 	bl	40ac0c <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
  40b1e0:	2a1303f6 	mov	w22, w19
  40b1e4:	6b1302bf 	cmp	w21, w19
  40b1e8:	540001cd 	b.le	40b220 <native_handle_cmd_line+0x98>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40b1ec:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  40b1f0:	aa1903e1 	mov	x1, x25
  40b1f4:	52800002 	mov	w2, #0x0                   	// #0
  40b1f8:	91000677 	add	x23, x19, #0x1
  40b1fc:	97fffdbb 	bl	40a8e8 <cmd_is_option>
  40b200:	340001c0 	cbz	w0, 40b238 <native_handle_cmd_line+0xb0>
			test_argc = argc - i - 1;
  40b204:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b208:	4b1602b6 	sub	w22, w21, w22
  40b20c:	510006d6 	sub	w22, w22, #0x1
			test_argv = &argv[i+1];
  40b210:	8b170e97 	add	x23, x20, x23, lsl #3
			test_argc = argc - i - 1;
  40b214:	b90bd416 	str	w22, [x0, #3028]
			test_argv = &argv[i+1];
  40b218:	b0000100 	adrp	x0, 42c000 <__dso_handle>
  40b21c:	f907fc17 	str	x23, [x0, #4088]
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
			cmd_print_switches_help(args_struct);
			print_invalid_opt_error(argv[i]);
		}
	}
}
  40b220:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b224:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b228:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b22c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40b230:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40b234:	d65f03c0 	ret
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
  40b238:	f947f701 	ldr	x1, [x24, #4072]
  40b23c:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  40b240:	97ffff5c 	bl	40afb0 <cmd_parse_one_arg>
  40b244:	72001c1f 	tst	w0, #0xff
  40b248:	540000c1 	b.ne	40b260 <native_handle_cmd_line+0xd8>  // b.any
			cmd_print_switches_help(args_struct);
  40b24c:	f947f700 	ldr	x0, [x24, #4072]
  40b250:	97fffea9 	bl	40acf4 <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40b254:	f8737a81 	ldr	x1, [x20, x19, lsl #3]
  40b258:	aa1a03e0 	mov	x0, x26
  40b25c:	97fffcc8 	bl	40a57c <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
  40b260:	aa1703f3 	mov	x19, x23
  40b264:	17ffffdf 	b	40b1e0 <native_handle_cmd_line+0x58>

000000000040b268 <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
  40b268:	90000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40b26c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40b270:	f947d021 	ldr	x1, [x1, #4000]
  40b274:	f9000020 	str	x0, [x1]
	counter_target = NEVER;
  40b278:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b27c:	f9000420 	str	x0, [x1, #8]
	counter_value = 0;
  40b280:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b284:	f900083f 	str	xzr, [x1, #16]
	counter_running = false;
  40b288:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b28c:	393fe83f 	strb	wzr, [x1, #4090]
	counter_period = NEVER;
  40b290:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b294:	f9000020 	str	x0, [x1]
}
  40b298:	d65f03c0 	ret

000000000040b29c <hw_counter_triggered>:

void hw_counter_triggered(void)
{
  40b29c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!counter_running) {
  40b2a0:	d0000100 	adrp	x0, 42d000 <counter_period>
{
  40b2a4:	910003fd 	mov	x29, sp
	if (!counter_running) {
  40b2a8:	397fe800 	ldrb	w0, [x0, #4090]
{
  40b2ac:	f9000bf3 	str	x19, [sp, #16]
  40b2b0:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
	if (!counter_running) {
  40b2b4:	350000e0 	cbnz	w0, 40b2d0 <hw_counter_triggered+0x34>
		hw_counter_timer = NEVER;
  40b2b8:	f947d273 	ldr	x19, [x19, #4000]
  40b2bc:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40b2c0:	f9000260 	str	x0, [x19]
	counter_value = counter_value + 1;

	if (counter_value == counter_target) {
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
	}
}
  40b2c4:	f9400bf3 	ldr	x19, [sp, #16]
  40b2c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b2cc:	d65f03c0 	ret
	hw_counter_timer = hwm_get_time() + counter_period;
  40b2d0:	97fff9e7 	bl	409a6c <hwm_get_time>
  40b2d4:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b2d8:	f947d273 	ldr	x19, [x19, #4000]
  40b2dc:	f9400021 	ldr	x1, [x1]
  40b2e0:	8b000021 	add	x1, x1, x0
  40b2e4:	f9000261 	str	x1, [x19]
	counter_value = counter_value + 1;
  40b2e8:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b2ec:	f9400820 	ldr	x0, [x1, #16]
  40b2f0:	91000400 	add	x0, x0, #0x1
  40b2f4:	f9000820 	str	x0, [x1, #16]
	if (counter_value == counter_target) {
  40b2f8:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b2fc:	f9400421 	ldr	x1, [x1, #8]
  40b300:	eb01001f 	cmp	x0, x1
  40b304:	54fffe01 	b.ne	40b2c4 <hw_counter_triggered+0x28>  // b.any
}
  40b308:	f9400bf3 	ldr	x19, [sp, #16]
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  40b30c:	52800040 	mov	w0, #0x2                   	// #2
}
  40b310:	a8c27bfd 	ldp	x29, x30, [sp], #32
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  40b314:	17fffc18 	b	40a374 <hw_irq_ctrl_set_irq>

000000000040b318 <receive_pool_free>:

/*
 * Wake every context that is waiting for a buffer
 */
static void receive_pool_free(struct net_buf *buf)
{
  40b318:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b31c:	910003fd 	mov	x29, sp
  40b320:	f9000bf3 	str	x19, [sp, #16]
  40b324:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b328:	39404800 	ldrb	w0, [x0, #18]
  40b32c:	94000425 	bl	40c3c0 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40b330:	aa1303e1 	mov	x1, x19
  40b334:	940010d3 	bl	40f680 <k_queue_prepend>
	return list->head;
  40b338:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b33c:	f9401013 	ldr	x19, [x0, #32]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.alloc_list, ctx_node) {
  40b340:	b5000093 	cbnz	x19, 40b350 <receive_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  40b344:	f9400bf3 	ldr	x19, [sp, #16]
  40b348:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b34c:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  40b350:	91004260 	add	x0, x19, #0x10
  40b354:	940013b9 	bl	410238 <k_work_submit>
	return node->next;
  40b358:	f9400273 	ldr	x19, [x19]
  40b35c:	17fffff9 	b	40b340 <receive_pool_free+0x28>

000000000040b360 <receive_ff_sf_pool_free>:

static void receive_ff_sf_pool_free(struct net_buf *buf)
{
  40b360:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b364:	910003fd 	mov	x29, sp
  40b368:	f9000bf3 	str	x19, [sp, #16]
  40b36c:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b370:	39404800 	ldrb	w0, [x0, #18]
  40b374:	94000413 	bl	40c3c0 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40b378:	aa1303e1 	mov	x1, x19
  40b37c:	940010c1 	bl	40f680 <k_queue_prepend>
	return list->head;
  40b380:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b384:	f9401813 	ldr	x19, [x0, #48]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.ff_sf_alloc_list, ctx_node) {
  40b388:	b5000093 	cbnz	x19, 40b398 <receive_ff_sf_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  40b38c:	f9400bf3 	ldr	x19, [sp, #16]
  40b390:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b394:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  40b398:	91004260 	add	x0, x19, #0x10
  40b39c:	940013a7 	bl	410238 <k_work_submit>
	return node->next;
  40b3a0:	f9400273 	ldr	x19, [x19]
  40b3a4:	17fffff9 	b	40b388 <receive_ff_sf_pool_free+0x28>

000000000040b3a8 <TC_RESULT_TO_STR>:
#define TC_SKIP_STR "SKIP"
#endif

static inline const char *TC_RESULT_TO_STR(int result)
{
	switch (result) {
  40b3a8:	7100041f 	cmp	w0, #0x1
  40b3ac:	54000140 	b.eq	40b3d4 <TC_RESULT_TO_STR+0x2c>  // b.none
  40b3b0:	7100081f 	cmp	w0, #0x2
  40b3b4:	54000160 	b.eq	40b3e0 <TC_RESULT_TO_STR+0x38>  // b.none
	case TC_PASS:
		return TC_PASS_STR;
  40b3b8:	7100001f 	cmp	w0, #0x0
  40b3bc:	d0000042 	adrp	x2, 415000 <random_data+0xb30>
  40b3c0:	d0000041 	adrp	x1, 415000 <random_data+0xb30>
  40b3c4:	91284c42 	add	x2, x2, #0xa13
  40b3c8:	911f5820 	add	x0, x1, #0x7d6
  40b3cc:	9a821000 	csel	x0, x0, x2, ne  // ne = any
	case TC_SKIP:
		return TC_SKIP_STR;
	default:
		return "?";
	}
}
  40b3d0:	d65f03c0 	ret
	switch (result) {
  40b3d4:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b3d8:	91286000 	add	x0, x0, #0xa18
  40b3dc:	17fffffd 	b	40b3d0 <TC_RESULT_TO_STR+0x28>
		return TC_SKIP_STR;
  40b3e0:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b3e4:	91287400 	add	x0, x0, #0xa1d
  40b3e8:	17fffffa 	b	40b3d0 <TC_RESULT_TO_STR+0x28>

000000000040b3ec <get_friendly_phase_name>:
 * @param phase an enum ztest_phase value describing the desired test phase
 * @returns a string name for `phase`
 */
static inline const char *get_friendly_phase_name(enum ztest_phase phase)
{
	switch (phase) {
  40b3ec:	7100141f 	cmp	w0, #0x5
  40b3f0:	540002c8 	b.hi	40b448 <get_friendly_phase_name+0x5c>  // b.pmore
  40b3f4:	90000041 	adrp	x1, 413000 <sys_clock_announce+0x19c>
  40b3f8:	91206021 	add	x1, x1, #0x818
  40b3fc:	38604821 	ldrb	w1, [x1, w0, uxtw]
  40b400:	10000060 	adr	x0, 40b40c <get_friendly_phase_name+0x20>
  40b404:	8b218801 	add	x1, x0, w1, sxtb #2
  40b408:	d61f0020 	br	x1
  40b40c:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b410:	9128a000 	add	x0, x0, #0xa28
	case TEST_PHASE_FRAMEWORK:
		return "framework";
	default:
		return "(unknown)";
	}
}
  40b414:	d65f03c0 	ret
		return "test";
  40b418:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b41c:	91353000 	add	x0, x0, #0xd4c
  40b420:	17fffffd 	b	40b414 <get_friendly_phase_name+0x28>
		return "after";
  40b424:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b428:	9128bc00 	add	x0, x0, #0xa2f
  40b42c:	17fffffa 	b	40b414 <get_friendly_phase_name+0x28>
		return "teardown";
  40b430:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b434:	9128d400 	add	x0, x0, #0xa35
  40b438:	17fffff7 	b	40b414 <get_friendly_phase_name+0x28>
		return "framework";
  40b43c:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b440:	9128f800 	add	x0, x0, #0xa3e
  40b444:	17fffff4 	b	40b414 <get_friendly_phase_name+0x28>
		return "(unknown)";
  40b448:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b44c:	91292000 	add	x0, x0, #0xa48
  40b450:	17fffff1 	b	40b414 <get_friendly_phase_name+0x28>
		return "setup";
  40b454:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b458:	91288800 	add	x0, x0, #0xa22
  40b45c:	17ffffee 	b	40b414 <get_friendly_phase_name+0x28>

000000000040b460 <ztest_find_test_suite>:
}

#endif /* !KERNEL */

static struct ztest_suite_node *ztest_find_test_suite(const char *name)
{
  40b460:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40b464:	910003fd 	mov	x29, sp
  40b468:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_suite_node *node;

	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b46c:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  40b470:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  40b474:	f9472273 	ldr	x19, [x19, #3648]
{
  40b478:	f90013f5 	str	x21, [sp, #32]
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b47c:	f9473e94 	ldr	x20, [x20, #3704]
{
  40b480:	aa0003f5 	mov	x21, x0
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b484:	eb14027f 	cmp	x19, x20
  40b488:	540000e3 	b.cc	40b4a4 <ztest_find_test_suite+0x44>  // b.lo, b.ul, b.last
		if (strcmp(name, node->name) == 0) {
			return node;
		}
	}

	return NULL;
  40b48c:	d2800013 	mov	x19, #0x0                   	// #0
}
  40b490:	aa1303e0 	mov	x0, x19
  40b494:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b498:	f94013f5 	ldr	x21, [sp, #32]
  40b49c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b4a0:	d65f03c0 	ret
		if (strcmp(name, node->name) == 0) {
  40b4a4:	f9400261 	ldr	x1, [x19]
  40b4a8:	aa1503e0 	mov	x0, x21
  40b4ac:	97ffd7bd 	bl	4013a0 <strcmp@plt>
  40b4b0:	34ffff00 	cbz	w0, 40b490 <ztest_find_test_suite+0x30>
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b4b4:	9100e273 	add	x19, x19, #0x38
  40b4b8:	17fffff3 	b	40b484 <ztest_find_test_suite+0x24>

000000000040b4bc <flush_log>:
		test->stats->duration_worst_ms = 0;
	}
}

static void flush_log(void)
{
  40b4bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b4c0:	910003fd 	mov	x29, sp
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke0(K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process();
  40b4c4:	97fff348 	bl	4081e4 <z_impl_log_process>
		while (log_data_pending()) {
			k_sleep(K_MSEC(10));
		}
		k_sleep(K_MSEC(10));
	} else {
		while (LOG_PROCESS()) {
  40b4c8:	72001c1f 	tst	w0, #0xff
  40b4cc:	54ffffc1 	b.ne	40b4c4 <flush_log+0x8>  // b.any
		}
	}
}
  40b4d0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b4d4:	d65f03c0 	ret

000000000040b4d8 <test_cb>:
{
  40b4d8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40b4dc:	910003fd 	mov	x29, sp
  40b4e0:	a90153f3 	stp	x19, x20, [sp, #16]
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40b4e4:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
{
  40b4e8:	aa0203f4 	mov	x20, x2
  40b4ec:	a90363f7 	stp	x23, x24, [sp, #48]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b4f0:	90000117 	adrp	x23, 42b000 <__FRAME_END__+0xfd74>
	test_result = ZTEST_RESULT_PENDING;
  40b4f4:	d0000118 	adrp	x24, 42d000 <counter_period>
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40b4f8:	f9476e73 	ldr	x19, [x19, #3800]
{
  40b4fc:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b500:	aa0003f6 	mov	x22, x0
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b504:	f947d6f7 	ldr	x23, [x23, #4008]
{
  40b508:	aa0103f5 	mov	x21, x1
	test_result = ZTEST_RESULT_PENDING;
  40b50c:	b90be71f 	str	wzr, [x24, #3044]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b510:	eb17027f 	cmp	x19, x23
  40b514:	54000263 	b.cc	40b560 <test_cb+0x88>  // b.lo, b.ul, b.last
	if (suite->before) {
  40b518:	f9400ac1 	ldr	x1, [x22, #16]
  40b51c:	b4000061 	cbz	x1, 40b528 <test_cb+0x50>
		suite->before(/*data=*/c);
  40b520:	aa1403e0 	mov	x0, x20
  40b524:	d63f0020 	blr	x1
	phase = TEST_PHASE_TEST;
  40b528:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40b52c:	52800042 	mov	w2, #0x2                   	// #2
  40b530:	f9400aa1 	ldr	x1, [x21, #16]
  40b534:	f947cc00 	ldr	x0, [x0, #3992]
  40b538:	b9000002 	str	w2, [x0]
	test->test(data);
  40b53c:	aa1403e0 	mov	x0, x20
  40b540:	d63f0020 	blr	x1
	test_result = ZTEST_RESULT_PASS;
  40b544:	52800020 	mov	w0, #0x1                   	// #1
  40b548:	b90be700 	str	w0, [x24, #3044]
}
  40b54c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b550:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b554:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b558:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40b55c:	d65f03c0 	ret
		if (is_before && rule->before_each) {
  40b560:	f9400262 	ldr	x2, [x19]
  40b564:	b4000082 	cbz	x2, 40b574 <test_cb+0x9c>
			rule->before_each(test, data);
  40b568:	aa1403e1 	mov	x1, x20
  40b56c:	aa1503e0 	mov	x0, x21
  40b570:	d63f0040 	blr	x2
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b574:	91004273 	add	x19, x19, #0x10
  40b578:	17ffffe6 	b	40b510 <test_cb+0x38>

000000000040b57c <test_finalize>:
{
  40b57c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b580:	910003fd 	mov	x29, sp
	z_impl_k_thread_abort(thread);
  40b584:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b588:	91010000 	add	x0, x0, #0x40
  40b58c:	97fff793 	bl	4093d8 <z_impl_k_thread_abort>
	return z_impl_z_current_get();
  40b590:	94001b7f 	bl	41238c <z_impl_z_current_get>
}
  40b594:	a8c17bfd 	ldp	x29, x30, [sp], #16
	z_impl_k_thread_abort(thread);
  40b598:	17fff790 	b	4093d8 <z_impl_k_thread_abort>

000000000040b59c <ztest_test_fail>:
	switch (phase) {
  40b59c:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40b5a0:	f947cc00 	ldr	x0, [x0, #3992]
  40b5a4:	b9400000 	ldr	w0, [x0]
  40b5a8:	34000200 	cbz	w0, 40b5e8 <ztest_test_fail+0x4c>
  40b5ac:	51000401 	sub	w1, w0, #0x1
  40b5b0:	7100043f 	cmp	w1, #0x1
  40b5b4:	54000229 	b.ls	40b5f8 <ztest_test_fail+0x5c>  // b.plast
{
  40b5b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b5bc:	910003fd 	mov	x29, sp
		PRINT(" ERROR: cannot fail in test phase '%s()', bailing\n",
  40b5c0:	97ffff8b 	bl	40b3ec <get_friendly_phase_name>
  40b5c4:	aa0003e1 	mov	x1, x0
  40b5c8:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b5cc:	91294800 	add	x0, x0, #0xa52
  40b5d0:	97ffec12 	bl	406618 <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b5d4:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b5d8:	52800041 	mov	w1, #0x2                   	// #2
}
  40b5dc:	a8c17bfd 	ldp	x29, x30, [sp], #16
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b5e0:	b90be801 	str	w1, [x0, #3048]
}
  40b5e4:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SUITE_FAIL;
  40b5e8:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b5ec:	528000a1 	mov	w1, #0x5                   	// #5
  40b5f0:	b90be401 	str	w1, [x0, #3044]
		break;
  40b5f4:	d65f03c0 	ret
		test_result = ZTEST_RESULT_FAIL;
  40b5f8:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b5fc:	52800041 	mov	w1, #0x2                   	// #2
  40b600:	b90be401 	str	w1, [x0, #3044]
		test_finalize();
  40b604:	17ffffde 	b	40b57c <test_finalize>

000000000040b608 <ztest_test_skip>:
	switch (phase) {
  40b608:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40b60c:	f947cc00 	ldr	x0, [x0, #3992]
  40b610:	b9400000 	ldr	w0, [x0]
  40b614:	34000200 	cbz	w0, 40b654 <ztest_test_skip+0x4c>
  40b618:	51000401 	sub	w1, w0, #0x1
  40b61c:	7100043f 	cmp	w1, #0x1
  40b620:	54000229 	b.ls	40b664 <ztest_test_skip+0x5c>  // b.plast
{
  40b624:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b628:	910003fd 	mov	x29, sp
		PRINT(" ERROR: cannot skip in test phase '%s()', bailing\n",
  40b62c:	97ffff70 	bl	40b3ec <get_friendly_phase_name>
  40b630:	aa0003e1 	mov	x1, x0
  40b634:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b638:	912a1400 	add	x0, x0, #0xa85
  40b63c:	97ffebf7 	bl	406618 <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b640:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b644:	52800041 	mov	w1, #0x2                   	// #2
}
  40b648:	a8c17bfd 	ldp	x29, x30, [sp], #16
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b64c:	b90be801 	str	w1, [x0, #3048]
}
  40b650:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SUITE_SKIP;
  40b654:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b658:	52800081 	mov	w1, #0x4                   	// #4
  40b65c:	b90be401 	str	w1, [x0, #3044]
		break;
  40b660:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SKIP;
  40b664:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b668:	52800061 	mov	w1, #0x3                   	// #3
  40b66c:	b90be401 	str	w1, [x0, #3044]
		test_finalize();
  40b670:	17ffffc3 	b	40b57c <test_finalize>

000000000040b674 <z_ztest_get_next_test>:
{
  40b674:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b678:	f100003f 	cmp	x1, #0x0
{
  40b67c:	910003fd 	mov	x29, sp
  40b680:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b684:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b688:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b68c:	f946ee73 	ldr	x19, [x19, #3544]
{
  40b690:	f90013f5 	str	x21, [sp, #32]
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b694:	f9474294 	ldr	x20, [x20, #3712]
{
  40b698:	aa0003f5 	mov	x21, x0
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b69c:	9100a020 	add	x0, x1, #0x28
  40b6a0:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b6a4:	eb14027f 	cmp	x19, x20
  40b6a8:	540000e3 	b.cc	40b6c4 <z_ztest_get_next_test+0x50>  // b.lo, b.ul, b.last
	return NULL;
  40b6ac:	d2800013 	mov	x19, #0x0                   	// #0
}
  40b6b0:	aa1303e0 	mov	x0, x19
  40b6b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b6b8:	f94013f5 	ldr	x21, [sp, #32]
  40b6bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b6c0:	d65f03c0 	ret
		if (strcmp(suite, test->test_suite_name) == 0) {
  40b6c4:	f9400261 	ldr	x1, [x19]
  40b6c8:	aa1503e0 	mov	x0, x21
  40b6cc:	97ffd735 	bl	4013a0 <strcmp@plt>
  40b6d0:	34ffff00 	cbz	w0, 40b6b0 <z_ztest_get_next_test+0x3c>
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b6d4:	9100a273 	add	x19, x19, #0x28
  40b6d8:	17fffff3 	b	40b6a4 <z_ztest_get_next_test+0x30>

000000000040b6dc <z_ztest_run_test_suite_ptr>:
{
  40b6dc:	d10203ff 	sub	sp, sp, #0x80
  40b6e0:	a9017bfd 	stp	x29, x30, [sp, #16]
  40b6e4:	910043fd 	add	x29, sp, #0x10
  40b6e8:	a90253f3 	stp	x19, x20, [sp, #32]
  40b6ec:	a9035bf5 	stp	x21, x22, [sp, #48]
  40b6f0:	a90463f7 	stp	x23, x24, [sp, #64]
  40b6f4:	a9056bf9 	stp	x25, x26, [sp, #80]
  40b6f8:	a90673fb 	stp	x27, x28, [sp, #96]
	if (suite == NULL) {
  40b6fc:	b50001c0 	cbnz	x0, 40b734 <z_ztest_run_test_suite_ptr+0x58>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b700:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b704:	52800041 	mov	w1, #0x2                   	// #2
		return -1;
  40b708:	12800016 	mov	w22, #0xffffffff            	// #-1
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b70c:	b90be801 	str	w1, [x0, #3048]
}
  40b710:	2a1603e0 	mov	w0, w22
  40b714:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40b718:	a94253f3 	ldp	x19, x20, [sp, #32]
  40b71c:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40b720:	a94463f7 	ldp	x23, x24, [sp, #64]
  40b724:	a9456bf9 	ldp	x25, x26, [sp, #80]
  40b728:	a94673fb 	ldp	x27, x28, [sp, #96]
  40b72c:	910203ff 	add	sp, sp, #0x80
  40b730:	d65f03c0 	ret
  40b734:	aa0003f4 	mov	x20, x0
	TC_SUITE_START(suite->name);
  40b738:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b73c:	912ae000 	add	x0, x0, #0xab8
	phase = TEST_PHASE_SETUP;
  40b740:	90000115 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
	test_result = ZTEST_RESULT_PENDING;
  40b744:	d0000118 	adrp	x24, 42d000 <counter_period>
	TC_SUITE_START(suite->name);
  40b748:	f9400281 	ldr	x1, [x20]
  40b74c:	97ffebb3 	bl	406618 <printk>
  40b750:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b754:	912b3800 	add	x0, x0, #0xace
  40b758:	97ffebb0 	bl	406618 <printk>
	test_result = ZTEST_RESULT_PENDING;
  40b75c:	b90be71f 	str	wzr, [x24, #3044]
	current_test_failed_assumption = false;
  40b760:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b764:	393fec1f 	strb	wzr, [x0, #4091]
	phase = TEST_PHASE_SETUP;
  40b768:	f947cea0 	ldr	x0, [x21, #3992]
  40b76c:	b900001f 	str	wzr, [x0]
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
  40b770:	f9400680 	ldr	x0, [x20, #8]
  40b774:	b4000340 	cbz	x0, 40b7dc <z_ztest_run_test_suite_ptr+0x100>
		data = suite->setup();
  40b778:	d63f0000 	blr	x0
  40b77c:	aa0003f7 	mov	x23, x0
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b780:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
		fail = 0;
  40b784:	52800016 	mov	w22, #0x0                   	// #0
	struct ztest_unit_test *test = NULL;
  40b788:	d2800013 	mov	x19, #0x0                   	// #0
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b78c:	f9479000 	ldr	x0, [x0, #3872]
  40b790:	f9003fe0 	str	x0, [sp, #120]
	tc_start_time = k_cycle_get_32();
}

static inline void get_test_duration_ms(void)
{
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40b794:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b798:	912f801c 	add	x28, x0, #0xbe0
		while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40b79c:	f9400280 	ldr	x0, [x20]
  40b7a0:	aa1303e1 	mov	x1, x19
  40b7a4:	97ffffb4 	bl	40b674 <z_ztest_get_next_test>
  40b7a8:	aa0003f3 	mov	x19, x0
  40b7ac:	b50001c0 	cbnz	x0, 40b7e4 <z_ztest_run_test_suite_ptr+0x108>
		if (test_status == ZTEST_STATUS_OK && fail != 0) {
  40b7b0:	d0000100 	adrp	x0, 42d000 <counter_period>
  40b7b4:	b94be801 	ldr	w1, [x0, #3048]
  40b7b8:	35001741 	cbnz	w1, 40baa0 <z_ztest_run_test_suite_ptr+0x3c4>
  40b7bc:	34001756 	cbz	w22, 40baa4 <z_ztest_run_test_suite_ptr+0x3c8>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  40b7c0:	52800021 	mov	w1, #0x1                   	// #1
  40b7c4:	b90be801 	str	w1, [x0, #3048]
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  40b7c8:	f9400281 	ldr	x1, [x20]
  40b7cc:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b7d0:	912d5000 	add	x0, x0, #0xb54
  40b7d4:	97ffeb91 	bl	406618 <printk>
  40b7d8:	140000b8 	b	40bab8 <z_ztest_run_test_suite_ptr+0x3dc>
	void *data = NULL;
  40b7dc:	d2800017 	mov	x23, #0x0                   	// #0
  40b7e0:	17ffffe8 	b	40b780 <z_ztest_run_test_suite_ptr+0xa4>
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b7e4:	f9403fe0 	ldr	x0, [sp, #120]
  40b7e8:	f9400661 	ldr	x1, [x19, #8]
  40b7ec:	f9400802 	ldr	x2, [x0, #16]
  40b7f0:	f9400280 	ldr	x0, [x20]
  40b7f4:	d63f0040 	blr	x2
  40b7f8:	72001c1f 	tst	w0, #0xff
  40b7fc:	540014a0 	b.eq	40ba90 <z_ztest_run_test_suite_ptr+0x3b4>  // b.none
				test->stats->run_count++;
  40b800:	f9401261 	ldr	x1, [x19, #32]
  40b804:	b9400020 	ldr	w0, [x1]
  40b808:	11000400 	add	w0, w0, #0x1
  40b80c:	b9000020 	str	w0, [x1]
	TC_START(test->name);
  40b810:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b814:	912c4c00 	add	x0, x0, #0xb13
  40b818:	f9400661 	ldr	x1, [x19, #8]
  40b81c:	97ffeb7f 	bl	406618 <printk>
	phase = TEST_PHASE_BEFORE;
  40b820:	f947cea0 	ldr	x0, [x21, #3992]
  40b824:	52800021 	mov	w1, #0x1                   	// #1
  40b828:	b9000001 	str	w1, [x0]
	return sys_clock_cycle_get_32();
  40b82c:	9400076f 	bl	40d5e8 <sys_clock_cycle_get_32>
	tc_start_time = k_cycle_get_32();
  40b830:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b834:	92800007 	mov	x7, #0xffffffffffffffff    	// #-1
  40b838:	b90be020 	str	w0, [x1, #3040]
		k_thread_create(&ztest_thread, ztest_thread_stack,
  40b83c:	b9401a60 	ldr	w0, [x19, #24]
  40b840:	321d0000 	orr	w0, w0, #0x8
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40b844:	90000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40b848:	b90003e0 	str	w0, [sp]
  40b84c:	f90007e7 	str	x7, [sp, #8]
  40b850:	d0000119 	adrp	x25, 42d000 <counter_period>
  40b854:	f947ec21 	ldr	x1, [x1, #4056]
  40b858:	9101033b 	add	x27, x25, #0x40
  40b85c:	aa1703e6 	mov	x6, x23
  40b860:	aa1303e5 	mov	x5, x19
  40b864:	aa1403e4 	mov	x4, x20
  40b868:	aa1b03e0 	mov	x0, x27
  40b86c:	d2808002 	mov	x2, #0x400                 	// #1024
  40b870:	90000003 	adrp	x3, 40b000 <cmd_parse_one_arg+0x50>
  40b874:	91136063 	add	x3, x3, #0x4d8
  40b878:	94000b40 	bl	40e578 <z_impl_k_thread_create>
		if (test->name != NULL) {
  40b87c:	f9400661 	ldr	x1, [x19, #8]
  40b880:	b4000061 	cbz	x1, 40b88c <z_ztest_run_test_suite_ptr+0x1b0>
	return z_impl_k_thread_name_set(thread, str);
  40b884:	aa1b03e0 	mov	x0, x27
  40b888:	94000ac7 	bl	40e3a4 <z_impl_k_thread_name_set>
		if (test_result != ZTEST_RESULT_SUITE_SKIP &&
  40b88c:	b94be700 	ldr	w0, [x24, #3044]
  40b890:	51001000 	sub	w0, w0, #0x4
  40b894:	7100041f 	cmp	w0, #0x1
  40b898:	540000e9 	b.ls	40b8b4 <z_ztest_run_test_suite_ptr+0x1d8>  // b.plast
	z_impl_k_thread_start(thread);
  40b89c:	9101033b 	add	x27, x25, #0x40
  40b8a0:	aa1b03e0 	mov	x0, x27
  40b8a4:	94000ad3 	bl	40e3f0 <z_impl_k_thread_start>
	return z_impl_k_thread_join(thread, timeout);
  40b8a8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40b8ac:	aa1b03e0 	mov	x0, x27
  40b8b0:	94001b71 	bl	412674 <z_impl_k_thread_join>
	phase = TEST_PHASE_AFTER;
  40b8b4:	f947cea0 	ldr	x0, [x21, #3992]
  40b8b8:	52800061 	mov	w1, #0x3                   	// #3
  40b8bc:	b9000001 	str	w1, [x0]
	if (suite->after != NULL) {
  40b8c0:	f9400e81 	ldr	x1, [x20, #24]
  40b8c4:	b4000061 	cbz	x1, 40b8d0 <z_ztest_run_test_suite_ptr+0x1f4>
		suite->after(data);
  40b8c8:	aa1703e0 	mov	x0, x23
  40b8cc:	d63f0020 	blr	x1
	void *data = NULL;
  40b8d0:	9000011b 	adrp	x27, 42b000 <__FRAME_END__+0xfd74>
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b8d4:	90000102 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
	void *data = NULL;
  40b8d8:	f9476f7b 	ldr	x27, [x27, #3800]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b8dc:	f947d45a 	ldr	x26, [x2, #4008]
  40b8e0:	14000007 	b	40b8fc <z_ztest_run_test_suite_ptr+0x220>
		} else if (!is_before && rule->after_each) {
  40b8e4:	f9400763 	ldr	x3, [x27, #8]
  40b8e8:	b4000083 	cbz	x3, 40b8f8 <z_ztest_run_test_suite_ptr+0x21c>
			rule->after_each(test, data);
  40b8ec:	aa1703e1 	mov	x1, x23
  40b8f0:	aa1303e0 	mov	x0, x19
  40b8f4:	d63f0060 	blr	x3
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b8f8:	9100437b 	add	x27, x27, #0x10
  40b8fc:	eb1a037f 	cmp	x27, x26
  40b900:	54ffff23 	b.cc	40b8e4 <z_ztest_run_test_suite_ptr+0x208>  // b.lo, b.ul, b.last
  40b904:	94000739 	bl	40d5e8 <sys_clock_cycle_get_32>
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40b908:	b9400382 	ldr	w2, [x28]
  40b90c:	4b020001 	sub	w1, w0, w2
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_cyc_to_ms_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
  40b910:	4b020000 	sub	w0, w0, w2
		t += off;
  40b914:	910f9c00 	add	x0, x0, #0x3e7
		if (result32 && (t < BIT64(32))) {
  40b918:	b2407fe2 	mov	x2, #0xffffffff            	// #4294967295
  40b91c:	eb02001f 	cmp	x0, x2
  40b920:	540007c8 	b.hi	40ba18 <z_ztest_run_test_suite_ptr+0x33c>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
  40b924:	110f9c21 	add	w1, w1, #0x3e7
  40b928:	52807d00 	mov	w0, #0x3e8                 	// #1000
  40b92c:	1ac00820 	udiv	w0, w1, w0

	tc_spend_time = k_cyc_to_ms_ceil32(spend_cycle);
  40b930:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b934:	b90bdc20 	str	w0, [x1, #3036]
	if (tc_spend_time > test->stats->duration_worst_ms) {
  40b938:	f9401261 	ldr	x1, [x19, #32]
  40b93c:	b9401022 	ldr	w2, [x1, #16]
  40b940:	6b00005f 	cmp	w2, w0
  40b944:	54000042 	b.cs	40b94c <z_ztest_run_test_suite_ptr+0x270>  // b.hs, b.nlast
		test->stats->duration_worst_ms = tc_spend_time;
  40b948:	b9001020 	str	w0, [x1, #16]
	phase = TEST_PHASE_FRAMEWORK;
  40b94c:	f947cea0 	ldr	x0, [x21, #3992]
  40b950:	528000a1 	mov	w1, #0x5                   	// #5
  40b954:	b9000001 	str	w1, [x0]
	if (test_result == ZTEST_RESULT_FAIL || test_result == ZTEST_RESULT_SUITE_FAIL ||
  40b958:	b94be700 	ldr	w0, [x24, #3044]
  40b95c:	7100081f 	cmp	w0, #0x2
  40b960:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40b964:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b968:	54000060 	b.eq	40b974 <z_ztest_run_test_suite_ptr+0x298>  // b.none
  40b96c:	397ff022 	ldrb	w2, [x1, #4092]
  40b970:	340005a2 	cbz	w2, 40ba24 <z_ztest_run_test_suite_ptr+0x348>
		failed_expectation = false;
  40b974:	393ff03f 	strb	wzr, [x1, #4092]
		ret = TC_FAIL;
  40b978:	5280003a 	mov	w26, #0x1                   	// #1
	z_impl_k_thread_abort(thread);
  40b97c:	91010320 	add	x0, x25, #0x40
  40b980:	97fff696 	bl	4093d8 <z_impl_k_thread_abort>
	for (struct ztest_expected_result_entry *expectation =
  40b984:	90000102 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40b988:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40b98c:	f9400679 	ldr	x25, [x19, #8]
	for (struct ztest_expected_result_entry *expectation =
  40b990:	f947745b 	ldr	x27, [x2, #3816]
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40b994:	f9478000 	ldr	x0, [x0, #3840]
  40b998:	f9003be0 	str	x0, [sp, #112]
  40b99c:	f9403be0 	ldr	x0, [sp, #112]
  40b9a0:	eb00037f 	cmp	x27, x0
  40b9a4:	540004a3 	b.cc	40ba38 <z_ztest_run_test_suite_ptr+0x35c>  // b.lo, b.ul, b.last
	Z_TC_END_RESULT(ret, test->name);
  40b9a8:	2a1a03e0 	mov	w0, w26
  40b9ac:	97fffe7f 	bl	40b3a8 <TC_RESULT_TO_STR>
  40b9b0:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b9b4:	52807d02 	mov	w2, #0x3e8                 	// #1000
  40b9b8:	b94bdc24 	ldr	w4, [x1, #3036]
  40b9bc:	aa0003e1 	mov	x1, x0
  40b9c0:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b9c4:	912c7c00 	add	x0, x0, #0xb1f
  40b9c8:	1ac20883 	udiv	w3, w4, w2
  40b9cc:	1b029064 	msub	w4, w3, w2, w4
  40b9d0:	aa1903e2 	mov	x2, x25
  40b9d4:	97ffeb11 	bl	406618 <printk>
  40b9d8:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40b9dc:	912b3800 	add	x0, x0, #0xace
  40b9e0:	97ffeb0e 	bl	406618 <printk>
	if (ret == TC_SKIP && current_test_failed_assumption) {
  40b9e4:	71000b5f 	cmp	w26, #0x2
  40b9e8:	f9401260 	ldr	x0, [x19, #32]
  40b9ec:	54000761 	b.ne	40bad8 <z_ztest_run_test_suite_ptr+0x3fc>  // b.any
  40b9f0:	d0000101 	adrp	x1, 42d000 <counter_period>
  40b9f4:	397fec21 	ldrb	w1, [x1, #4091]
  40b9f8:	34000081 	cbz	w1, 40ba08 <z_ztest_run_test_suite_ptr+0x32c>
		test_status = 1;
  40b9fc:	d0000101 	adrp	x1, 42d000 <counter_period>
  40ba00:	52800022 	mov	w2, #0x1                   	// #1
  40ba04:	b90be822 	str	w2, [x1, #3048]
					test->stats->skip_count++;
  40ba08:	b9400401 	ldr	w1, [x0, #4]
  40ba0c:	11000421 	add	w1, w1, #0x1
  40ba10:	b9000401 	str	w1, [x0, #4]
				if (tc_result == TC_FAIL) {
  40ba14:	1400001f 	b	40ba90 <z_ztest_run_test_suite_ptr+0x3b4>
			return t / ((uint64_t)from_hz / to_hz);
  40ba18:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  40ba1c:	9ac10800 	udiv	x0, x0, x1
  40ba20:	17ffffc4 	b	40b930 <z_ztest_run_test_suite_ptr+0x254>
	} else if (test_result == ZTEST_RESULT_SKIP || test_result == ZTEST_RESULT_SUITE_SKIP) {
  40ba24:	51000c00 	sub	w0, w0, #0x3
  40ba28:	7100041f 	cmp	w0, #0x1
  40ba2c:	1a9f87e5 	cset	w5, ls  // ls = plast
  40ba30:	531f78ba 	lsl	w26, w5, #1
  40ba34:	17ffffd2 	b	40b97c <z_ztest_run_test_suite_ptr+0x2a0>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40ba38:	f9400760 	ldr	x0, [x27, #8]
  40ba3c:	aa1903e1 	mov	x1, x25
  40ba40:	97ffd658 	bl	4013a0 <strcmp@plt>
  40ba44:	35000160 	cbnz	w0, 40ba70 <z_ztest_run_test_suite_ptr+0x394>
		    strcmp(expectation->test_suite_name, test->test_suite_name) == 0) {
  40ba48:	f9400261 	ldr	x1, [x19]
  40ba4c:	f9400360 	ldr	x0, [x27]
  40ba50:	97ffd654 	bl	4013a0 <strcmp@plt>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40ba54:	350000e0 	cbnz	w0, 40ba70 <z_ztest_run_test_suite_ptr+0x394>
			expected_result = expectation->expected_result;
  40ba58:	b9401360 	ldr	w0, [x27, #16]
	if (expected_result == ZTEST_EXPECTED_RESULT_FAIL) {
  40ba5c:	340000e0 	cbz	w0, 40ba78 <z_ztest_run_test_suite_ptr+0x39c>
	if (expected_result == ZTEST_EXPECTED_RESULT_SKIP) {
  40ba60:	7100041f 	cmp	w0, #0x1
  40ba64:	54fffa21 	b.ne	40b9a8 <z_ztest_run_test_suite_ptr+0x2cc>  // b.any
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  40ba68:	71000b5f 	cmp	w26, #0x2
  40ba6c:	14000004 	b	40ba7c <z_ztest_run_test_suite_ptr+0x3a0>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40ba70:	9100637b 	add	x27, x27, #0x18
  40ba74:	17ffffca 	b	40b99c <z_ztest_run_test_suite_ptr+0x2c0>
		return (ret == TC_FAIL) ? TC_PASS : TC_FAIL;
  40ba78:	7100075f 	cmp	w26, #0x1
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  40ba7c:	1a9f07fa 	cset	w26, ne  // ne = any
  40ba80:	17ffffca 	b	40b9a8 <z_ztest_run_test_suite_ptr+0x2cc>
					test->stats->pass_count++;
  40ba84:	b9400c01 	ldr	w1, [x0, #12]
  40ba88:	11000421 	add	w1, w1, #0x1
  40ba8c:	b9000c01 	str	w1, [x0, #12]
			if ((fail && FAIL_FAST) || test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40ba90:	d0000100 	adrp	x0, 42d000 <counter_period>
  40ba94:	b94be800 	ldr	w0, [x0, #3048]
  40ba98:	7100081f 	cmp	w0, #0x2
  40ba9c:	54ffe801 	b.ne	40b79c <z_ztest_run_test_suite_ptr+0xc0>  // b.any
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  40baa0:	35ffe956 	cbnz	w22, 40b7c8 <z_ztest_run_test_suite_ptr+0xec>
  40baa4:	f9400281 	ldr	x1, [x20]
  40baa8:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40baac:	52800016 	mov	w22, #0x0                   	// #0
  40bab0:	912cf000 	add	x0, x0, #0xb3c
  40bab4:	97ffead9 	bl	406618 <printk>
	phase = TEST_PHASE_TEARDOWN;
  40bab8:	f947ceb5 	ldr	x21, [x21, #3992]
  40babc:	52800080 	mov	w0, #0x4                   	// #4
	if (suite->teardown != NULL) {
  40bac0:	f9401281 	ldr	x1, [x20, #32]
	phase = TEST_PHASE_TEARDOWN;
  40bac4:	b90002a0 	str	w0, [x21]
	if (suite->teardown != NULL) {
  40bac8:	b4ffe241 	cbz	x1, 40b710 <z_ztest_run_test_suite_ptr+0x34>
		suite->teardown(data);
  40bacc:	aa1703e0 	mov	x0, x23
  40bad0:	d63f0020 	blr	x1
  40bad4:	17ffff0f 	b	40b710 <z_ztest_run_test_suite_ptr+0x34>
				if (tc_result == TC_PASS) {
  40bad8:	34fffd7a 	cbz	w26, 40ba84 <z_ztest_run_test_suite_ptr+0x3a8>
					test->stats->fail_count++;
  40badc:	b9400801 	ldr	w1, [x0, #8]
					fail++;
  40bae0:	110006d6 	add	w22, w22, #0x1
					test->stats->fail_count++;
  40bae4:	11000421 	add	w1, w1, #0x1
  40bae8:	b9000801 	str	w1, [x0, #8]
					fail++;
  40baec:	17ffffe9 	b	40ba90 <z_ztest_run_test_suite_ptr+0x3b4>

000000000040baf0 <z_impl_ztest_run_test_suites>:

	return count;
}

int z_impl_ztest_run_test_suites(const void *state)
{
  40baf0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40baf4:	910003fd 	mov	x29, sp
  40baf8:	f90023f9 	str	x25, [sp, #64]
	int count = 0;

	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40bafc:	d0000119 	adrp	x25, 42d000 <counter_period>
{
  40bb00:	a90363f7 	stp	x23, x24, [sp, #48]
  40bb04:	aa0003f7 	mov	x23, x0
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40bb08:	b94beb20 	ldr	w0, [x25, #3048]
{
  40bb0c:	a90153f3 	stp	x19, x20, [sp, #16]
  40bb10:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40bb14:	7100081f 	cmp	w0, #0x2
  40bb18:	540007a0 	b.eq	40bc0c <z_impl_ztest_run_test_suites+0x11c>  // b.none
		    (test_status == ZTEST_STATUS_HAS_FAILURE && FAIL_FAST)) {
			break;
		}
	}
#else
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40bb1c:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bb20:	90000116 	adrp	x22, 42b000 <__FRAME_END__+0xfd74>
		if (ztest_api.should_suite_run(state, ptr)) {
  40bb24:	90000118 	adrp	x24, 42b000 <__FRAME_END__+0xfd74>
	int count = 0;
  40bb28:	52800015 	mov	w21, #0x0                   	// #0
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40bb2c:	f9472273 	ldr	x19, [x19, #3648]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bb30:	f9473ed6 	ldr	x22, [x22, #3704]
		if (ztest_api.should_suite_run(state, ptr)) {
  40bb34:	f9479318 	ldr	x24, [x24, #3872]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bb38:	eb16027f 	cmp	x19, x22
  40bb3c:	54000103 	b.cc	40bb5c <z_impl_ztest_run_test_suites+0x6c>  // b.lo, b.ul, b.last
		}
	}
#endif

	return count;
}
  40bb40:	2a1503e0 	mov	w0, w21
  40bb44:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bb48:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40bb4c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40bb50:	f94023f9 	ldr	x25, [sp, #64]
  40bb54:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40bb58:	d65f03c0 	ret
		if (ztest_api.should_suite_run(state, ptr)) {
  40bb5c:	f9400702 	ldr	x2, [x24, #8]
  40bb60:	aa1303e1 	mov	x1, x19
  40bb64:	aa1703e0 	mov	x0, x23
	struct ztest_suite_stats *stats = ptr->stats;
  40bb68:	f9401a74 	ldr	x20, [x19, #48]
		if (ztest_api.should_suite_run(state, ptr)) {
  40bb6c:	d63f0040 	blr	x2
  40bb70:	72001c1f 	tst	w0, #0xff
  40bb74:	54000420 	b.eq	40bbf8 <z_impl_ztest_run_test_suites+0x108>  // b.none
	struct ztest_unit_test *test = NULL;
  40bb78:	d2800001 	mov	x1, #0x0                   	// #0
  40bb7c:	1400000b 	b	40bba8 <z_impl_ztest_run_test_suites+0xb8>
		test->stats->run_count = 0;
  40bb80:	f9401020 	ldr	x0, [x1, #32]
  40bb84:	b900001f 	str	wzr, [x0]
		test->stats->skip_count = 0;
  40bb88:	f9401020 	ldr	x0, [x1, #32]
  40bb8c:	b900041f 	str	wzr, [x0, #4]
		test->stats->fail_count = 0;
  40bb90:	f9401020 	ldr	x0, [x1, #32]
  40bb94:	b900081f 	str	wzr, [x0, #8]
		test->stats->pass_count = 0;
  40bb98:	f9401020 	ldr	x0, [x1, #32]
  40bb9c:	b9000c1f 	str	wzr, [x0, #12]
		test->stats->duration_worst_ms = 0;
  40bba0:	f9401020 	ldr	x0, [x1, #32]
  40bba4:	b900101f 	str	wzr, [x0, #16]
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40bba8:	f9400260 	ldr	x0, [x19]
  40bbac:	97fffeb2 	bl	40b674 <z_ztest_get_next_test>
  40bbb0:	aa0003e1 	mov	x1, x0
  40bbb4:	b5fffe60 	cbnz	x0, 40bb80 <z_impl_ztest_run_test_suites+0x90>
			int fail = z_ztest_run_test_suite_ptr(ptr);
  40bbb8:	aa1303e0 	mov	x0, x19
  40bbbc:	97fffec8 	bl	40b6dc <z_ztest_run_test_suite_ptr>
			stats->fail_count += (fail != 0) ? 1 : 0;
  40bbc0:	7100001f 	cmp	w0, #0x0
  40bbc4:	b9400a80 	ldr	w0, [x20, #8]
			stats->run_count++;
  40bbc8:	b9400281 	ldr	w1, [x20]
			stats->fail_count += (fail != 0) ? 1 : 0;
  40bbcc:	1a800400 	cinc	w0, w0, ne  // ne = any
  40bbd0:	b9000a80 	str	w0, [x20, #8]
			stats->run_count++;
  40bbd4:	11000421 	add	w1, w1, #0x1
			count++;
  40bbd8:	52800020 	mov	w0, #0x1                   	// #1
			stats->run_count++;
  40bbdc:	b9000281 	str	w1, [x20]
		count += __ztest_run_test_suite(ptr, state);
  40bbe0:	0b0002b5 	add	w21, w21, w0
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
  40bbe4:	b94beb20 	ldr	w0, [x25, #3048]
  40bbe8:	7100081f 	cmp	w0, #0x2
  40bbec:	54fffaa0 	b.eq	40bb40 <z_impl_ztest_run_test_suites+0x50>  // b.none
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bbf0:	9100e273 	add	x19, x19, #0x38
  40bbf4:	17ffffd1 	b	40bb38 <z_impl_ztest_run_test_suites+0x48>
			stats->skip_count++;
  40bbf8:	b9400680 	ldr	w0, [x20, #4]
  40bbfc:	11000400 	add	w0, w0, #0x1
  40bc00:	b9000680 	str	w0, [x20, #4]
	int count = 0;
  40bc04:	52800000 	mov	w0, #0x0                   	// #0
  40bc08:	17fffff6 	b	40bbe0 <z_impl_ztest_run_test_suites+0xf0>
		return count;
  40bc0c:	52800015 	mov	w21, #0x0                   	// #0
  40bc10:	17ffffcc 	b	40bb40 <z_impl_ztest_run_test_suites+0x50>

000000000040bc14 <ztest_verify_all_test_suites_ran>:

void ztest_verify_all_test_suites_ran(void)
{
  40bc14:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40bc18:	910003fd 	mov	x29, sp
  40bc1c:	a90153f3 	stp	x19, x20, [sp, #16]
	bool all_tests_run = true;
	struct ztest_suite_node *suite;
	struct ztest_unit_test *test;

	if (IS_ENABLED(CONFIG_ZTEST_VERIFY_RUN_ALL)) {
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40bc20:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  40bc24:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  40bc28:	f9472273 	ldr	x19, [x19, #3648]
{
  40bc2c:	a9025bf5 	stp	x21, x22, [sp, #32]
		     ++suite) {
			if (suite->stats->run_count < 1) {
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40bc30:	d0000056 	adrp	x22, 415000 <random_data+0xb30>
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40bc34:	f9473e94 	ldr	x20, [x20, #3704]
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40bc38:	912daad6 	add	x22, x22, #0xb6a
	bool all_tests_run = true;
  40bc3c:	52800035 	mov	w21, #0x1                   	// #1
{
  40bc40:	a90363f7 	stp	x23, x24, [sp, #48]
  40bc44:	f90023f9 	str	x25, [sp, #64]
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40bc48:	eb14027f 	cmp	x19, x20
  40bc4c:	54000383 	b.cc	40bcbc <ztest_verify_all_test_suites_ran+0xa8>  // b.lo, b.ul, b.last
				all_tests_run = false;
			}
		}

		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bc50:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40bc54:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
			suite = ztest_find_test_suite(test->test_suite_name);
			if (suite == NULL) {
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40bc58:	d0000056 	adrp	x22, 415000 <random_data+0xb30>
  40bc5c:	aa0003f8 	mov	x24, x0
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bc60:	f946ee74 	ldr	x20, [x19, #3544]
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40bc64:	912e3ed6 	add	x22, x22, #0xb8f
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bc68:	f9474019 	ldr	x25, [x0, #3712]
  40bc6c:	eb19029f 	cmp	x20, x25
  40bc70:	54000383 	b.cc	40bce0 <ztest_verify_all_test_suites_ran+0xcc>  // b.lo, b.ul, b.last
				      test->name, test->test_suite_name);
				all_tests_run = false;
			}
		}

		if (!all_tests_run) {
  40bc74:	35000095 	cbnz	w21, 40bc84 <ztest_verify_all_test_suites_ran+0x70>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  40bc78:	d0000100 	adrp	x0, 42d000 <counter_period>
  40bc7c:	52800021 	mov	w1, #0x1                   	// #1
  40bc80:	b90be801 	str	w1, [x0, #3048]
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bc84:	f946ee73 	ldr	x19, [x19, #3544]
	}

	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
		    test->stats->run_count) {
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40bc88:	d0000055 	adrp	x21, 415000 <random_data+0xb30>
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bc8c:	f9474318 	ldr	x24, [x24, #3712]
			test_status = 1;
  40bc90:	d0000116 	adrp	x22, 42d000 <counter_period>
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40bc94:	912f46b5 	add	x21, x21, #0xbd1
			test_status = 1;
  40bc98:	912fa2d6 	add	x22, x22, #0xbe8
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bc9c:	eb18027f 	cmp	x19, x24
  40bca0:	54000363 	b.cc	40bd0c <ztest_verify_all_test_suites_ran+0xf8>  // b.lo, b.ul, b.last
		}
	}
}
  40bca4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bca8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40bcac:	a94363f7 	ldp	x23, x24, [sp, #48]
  40bcb0:	f94023f9 	ldr	x25, [sp, #64]
  40bcb4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40bcb8:	d65f03c0 	ret
			if (suite->stats->run_count < 1) {
  40bcbc:	f9401a60 	ldr	x0, [x19, #48]
  40bcc0:	b9400000 	ldr	w0, [x0]
  40bcc4:	350000a0 	cbnz	w0, 40bcd8 <ztest_verify_all_test_suites_ran+0xc4>
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40bcc8:	f9400261 	ldr	x1, [x19]
  40bccc:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  40bcd0:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40bcd4:	97ffea51 	bl	406618 <printk>
		     ++suite) {
  40bcd8:	9100e273 	add	x19, x19, #0x38
  40bcdc:	17ffffdb 	b	40bc48 <ztest_verify_all_test_suites_ran+0x34>
			suite = ztest_find_test_suite(test->test_suite_name);
  40bce0:	f9400297 	ldr	x23, [x20]
  40bce4:	aa1703e0 	mov	x0, x23
  40bce8:	97fffdde 	bl	40b460 <ztest_find_test_suite>
			if (suite == NULL) {
  40bcec:	b50000c0 	cbnz	x0, 40bd04 <ztest_verify_all_test_suites_ran+0xf0>
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40bcf0:	f9400681 	ldr	x1, [x20, #8]
  40bcf4:	aa1703e2 	mov	x2, x23
  40bcf8:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  40bcfc:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40bd00:	97ffea46 	bl	406618 <printk>
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bd04:	9100a294 	add	x20, x20, #0x28
  40bd08:	17ffffd9 	b	40bc6c <ztest_verify_all_test_suites_ran+0x58>
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
  40bd0c:	f9401262 	ldr	x2, [x19, #32]
  40bd10:	29410041 	ldp	w1, w0, [x2, #8]
  40bd14:	0b000021 	add	w1, w1, w0
  40bd18:	b9400440 	ldr	w0, [x2, #4]
  40bd1c:	0b000021 	add	w1, w1, w0
  40bd20:	b9400040 	ldr	w0, [x2]
  40bd24:	6b00003f 	cmp	w1, w0
  40bd28:	540000c0 	b.eq	40bd40 <ztest_verify_all_test_suites_ran+0x12c>  // b.none
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40bd2c:	a9400a61 	ldp	x1, x2, [x19]
  40bd30:	aa1503e0 	mov	x0, x21
  40bd34:	97ffea39 	bl	406618 <printk>
			test_status = 1;
  40bd38:	52800020 	mov	w0, #0x1                   	// #1
  40bd3c:	b90002c0 	str	w0, [x22]
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40bd40:	9100a273 	add	x19, x19, #0x28
  40bd44:	17ffffd6 	b	40bc9c <ztest_verify_all_test_suites_ran+0x88>

000000000040bd48 <ztest_run_all>:

void ztest_run_all(const void *state) { ztest_api.run_all(state); }
  40bd48:	90000101 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40bd4c:	f9479021 	ldr	x1, [x1, #3872]
  40bd50:	f9400021 	ldr	x1, [x1]
  40bd54:	aa0103f0 	mov	x16, x1
  40bd58:	d61f0200 	br	x16

000000000040bd5c <test_main>:

void __weak test_main(void)
{
  40bd5c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ztest_run_all(NULL);
  40bd60:	d2800000 	mov	x0, #0x0                   	// #0
{
  40bd64:	910003fd 	mov	x29, sp
	ztest_run_all(NULL);
  40bd68:	97fffff8 	bl	40bd48 <ztest_run_all>

	ztest_verify_all_test_suites_ran();
}
  40bd6c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ztest_verify_all_test_suites_ran();
  40bd70:	17ffffa9 	b	40bc14 <ztest_verify_all_test_suites_ran>

000000000040bd74 <_posix_zephyr_main>:

	return test_status;
}
#else
int main(void)
{
  40bd74:	d10203ff 	sub	sp, sp, #0x80
  40bd78:	a9027bfd 	stp	x29, x30, [sp, #32]
  40bd7c:	910083fd 	add	x29, sp, #0x20
  40bd80:	a90353f3 	stp	x19, x20, [sp, #48]
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40bd84:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
{
  40bd88:	a9045bf5 	stp	x21, x22, [sp, #64]
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40bd8c:	d0000056 	adrp	x22, 415000 <random_data+0xb30>
  40bd90:	9131ced6 	add	x22, x22, #0xc73
{
  40bd94:	a90563f7 	stp	x23, x24, [sp, #80]
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40bd98:	52955577 	mov	w23, #0xaaab                	// #43691
  40bd9c:	72b55557 	movk	w23, #0xaaaa, lsl #16
{
  40bda0:	a9066bf9 	stp	x25, x26, [sp, #96]
  40bda4:	a90773fb 	stp	x27, x28, [sp, #112]
	k_mem_domain_add_partition(&k_mem_domain_default, &z_malloc_partition);
#endif
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
  40bda8:	97ffffed 	bl	40bd5c <test_main>
	flush_log();
  40bdac:	97fffdc4 	bl	40b4bc <flush_log>
	TC_SUMMARY_PRINT("\n------ TESTSUITE SUMMARY START ------\n\n");
  40bdb0:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40bdb4:	912f9800 	add	x0, x0, #0xbe6
  40bdb8:	97ffea18 	bl	406618 <printk>
	flush_log();
  40bdbc:	97fffdc0 	bl	40b4bc <flush_log>
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40bdc0:	f9472294 	ldr	x20, [x20, #3648]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bdc4:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40bdc8:	f9473c00 	ldr	x0, [x0, #3704]
  40bdcc:	eb00029f 	cmp	x20, x0
  40bdd0:	54000cc3 	b.cc	40bf68 <_posix_zephyr_main+0x1f4>  // b.lo, b.ul, b.last
	TC_SUMMARY_PRINT("------ TESTSUITE SUMMARY END ------\n\n");
  40bdd4:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40bdd8:	91327c00 	add	x0, x0, #0xc9f
  40bddc:	97ffea0f 	bl	406618 <printk>
	flush_log();
  40bde0:	d0000054 	adrp	x20, 415000 <random_data+0xb30>
  40bde4:	d0000053 	adrp	x19, 415000 <random_data+0xb30>
  40bde8:	97fffdb5 	bl	40b4bc <flush_log>
	if (test_status) {
  40bdec:	d0000100 	adrp	x0, 42d000 <counter_period>
  40bdf0:	b94be801 	ldr	w1, [x0, #3048]
  40bdf4:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
		TC_END_REPORT(TC_FAIL);
  40bdf8:	912b3800 	add	x0, x0, #0xace
	if (test_status) {
  40bdfc:	34000fc1 	cbz	w1, 40bff4 <_posix_zephyr_main+0x280>
		TC_END_REPORT(TC_FAIL);
  40be00:	97ffea06 	bl	406618 <printk>
  40be04:	91331680 	add	x0, x20, #0xcc5
  40be08:	97ffea04 	bl	406618 <printk>
  40be0c:	9133d660 	add	x0, x19, #0xcf5
  40be10:	d0000041 	adrp	x1, 415000 <random_data+0xb30>
  40be14:	9133b821 	add	x1, x1, #0xcee
  40be18:	97ffea00 	bl	406618 <printk>
	z_impl_log_panic();
  40be1c:	97fff0ad 	bl	4080d0 <z_impl_log_panic>
  40be20:	52800020 	mov	w0, #0x1                   	// #1
		TC_END_REPORT(TC_PASS);
  40be24:	97fff980 	bl	40a424 <posix_exit>
	end_report();
	flush_log();
  40be28:	97fffda5 	bl	40b4bc <flush_log>
  40be2c:	97fff0a9 	bl	4080d0 <z_impl_log_panic>
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
	return 0;
}
  40be30:	52800000 	mov	w0, #0x0                   	// #0
  40be34:	a9427bfd 	ldp	x29, x30, [sp, #32]
  40be38:	a94353f3 	ldp	x19, x20, [sp, #48]
  40be3c:	a9445bf5 	ldp	x21, x22, [sp, #64]
  40be40:	a94563f7 	ldp	x23, x24, [sp, #80]
  40be44:	a9466bf9 	ldp	x25, x26, [sp, #96]
  40be48:	a94773fb 	ldp	x27, x28, [sp, #112]
  40be4c:	910203ff 	add	sp, sp, #0x80
  40be50:	d65f03c0 	ret
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40be54:	f9401260 	ldr	x0, [x19, #32]
		distinct_total++;
  40be58:	1100075a 	add	w26, w26, #0x1
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40be5c:	b9401001 	ldr	w1, [x0, #16]
		if (test->stats->skip_count == test->stats->run_count) {
  40be60:	b9400402 	ldr	w2, [x0, #4]
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40be64:	0b0102b5 	add	w21, w21, w1
		if (test->stats->skip_count == test->stats->run_count) {
  40be68:	b9400001 	ldr	w1, [x0]
  40be6c:	6b01005f 	cmp	w2, w1
  40be70:	540006e1 	b.ne	40bf4c <_posix_zephyr_main+0x1d8>  // b.any
			distinct_skip++;
  40be74:	11000718 	add	w24, w24, #0x1
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40be78:	f9400280 	ldr	x0, [x20]
  40be7c:	aa1303e1 	mov	x1, x19
  40be80:	97fffdfd 	bl	40b674 <z_ztest_get_next_test>
  40be84:	aa0003f3 	mov	x19, x0
  40be88:	b5fffe60 	cbnz	x0, 40be54 <_posix_zephyr_main+0xe0>
	if (distinct_skip == distinct_total) {
  40be8c:	6b18035f 	cmp	w26, w24
  40be90:	540007a0 	b.eq	40bf84 <_posix_zephyr_main+0x210>  // b.none
		expanded_pass = distinct_pass * 100000;
  40be94:	5290d401 	mov	w1, #0x86a0                	// #34464
		effective_total = distinct_total - distinct_skip;
  40be98:	4b180342 	sub	w2, w26, w24
		expanded_pass = distinct_pass * 100000;
  40be9c:	72a00021 	movk	w1, #0x1, lsl #16
		passrate_major = expanded_passrate / 1000;
  40bea0:	52807d08 	mov	w8, #0x3e8                 	// #1000
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bea4:	52800143 	mov	w3, #0xa                   	// #10
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
  40bea8:	7100039f 	cmp	w28, #0x0
		expanded_pass = distinct_pass * 100000;
  40beac:	1b017f61 	mul	w1, w27, w1
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
  40beb0:	1a9fd7e0 	cset	w0, gt
		expanded_passrate = expanded_pass / effective_total;
  40beb4:	1ac20c21 	sdiv	w1, w1, w2
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40beb8:	12807ce2 	mov	w2, #0xfffffc18            	// #-1000
		passrate_major = expanded_passrate / 1000;
  40bebc:	1ac80c28 	sdiv	w8, w1, w8
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bec0:	1b020501 	madd	w1, w8, w2, w1
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
  40bec4:	12800122 	mov	w2, #0xfffffff6            	// #-10
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bec8:	1ac30c23 	sdiv	w3, w1, w3
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
  40becc:	1b020461 	madd	w1, w3, w2, w1
			passrate_minor++;
  40bed0:	7100103f 	cmp	w1, #0x4
  40bed4:	1a83d463 	cinc	w3, w3, gt
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
  40bed8:	52807d19 	mov	w25, #0x3e8                 	// #1000
  40bedc:	97fffd33 	bl	40b3a8 <TC_RESULT_TO_STR>
  40bee0:	b90003fa 	str	w26, [sp]
  40bee4:	aa0003e1 	mov	x1, x0
  40bee8:	1ad90aa2 	udiv	w2, w21, w25
  40beec:	2a1803e7 	mov	w7, w24
  40bef0:	2a1c03e6 	mov	w6, w28
  40bef4:	2a1b03e5 	mov	w5, w27
  40bef8:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40befc:	91303c00 	add	x0, x0, #0xc0f
  40bf00:	1b19d455 	msub	w21, w2, w25, w21
  40bf04:	b9000be2 	str	w2, [sp, #8]
  40bf08:	b90013f5 	str	w21, [sp, #16]
  40bf0c:	2a0803e2 	mov	w2, w8
	int flush_frequency = 0;
  40bf10:	52800015 	mov	w21, #0x0                   	// #0
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
  40bf14:	f9400284 	ldr	x4, [x20]
  40bf18:	97ffe9c0 	bl	406618 <printk>
	flush_log();
  40bf1c:	97fffd68 	bl	40b4bc <flush_log>
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40bf20:	f9400280 	ldr	x0, [x20]
  40bf24:	aa1303e1 	mov	x1, x19
  40bf28:	97fffdd3 	bl	40b674 <z_ztest_get_next_test>
  40bf2c:	aa0003f3 	mov	x19, x0
  40bf30:	b5000320 	cbnz	x0, 40bf94 <_posix_zephyr_main+0x220>
	TC_SUMMARY_PRINT("\n");
  40bf34:	d0000040 	adrp	x0, 415000 <random_data+0xb30>
  40bf38:	913b7800 	add	x0, x0, #0xede
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bf3c:	9100e294 	add	x20, x20, #0x38
	TC_SUMMARY_PRINT("\n");
  40bf40:	97ffe9b6 	bl	406618 <printk>
	flush_log();
  40bf44:	97fffd5e 	bl	40b4bc <flush_log>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bf48:	17ffff9f 	b	40bdc4 <_posix_zephyr_main+0x50>
		} else if (test->stats->pass_count == test->stats->run_count) {
  40bf4c:	b9400c00 	ldr	w0, [x0, #12]
  40bf50:	6b00003f 	cmp	w1, w0
  40bf54:	54000061 	b.ne	40bf60 <_posix_zephyr_main+0x1ec>  // b.any
			distinct_pass++;
  40bf58:	1100077b 	add	w27, w27, #0x1
  40bf5c:	17ffffc7 	b	40be78 <_posix_zephyr_main+0x104>
			distinct_fail++;
  40bf60:	1100079c 	add	w28, w28, #0x1
  40bf64:	17ffffc5 	b	40be78 <_posix_zephyr_main+0x104>
	unsigned int suite_duration_worst_ms = 0;
  40bf68:	52800015 	mov	w21, #0x0                   	// #0
	struct ztest_unit_test *test = NULL;
  40bf6c:	d2800013 	mov	x19, #0x0                   	// #0
	int distinct_pass = 0, distinct_fail = 0, distinct_skip = 0, distinct_total = 0;
  40bf70:	5280001a 	mov	w26, #0x0                   	// #0
  40bf74:	52800018 	mov	w24, #0x0                   	// #0
  40bf78:	5280001c 	mov	w28, #0x0                   	// #0
  40bf7c:	5280001b 	mov	w27, #0x0                   	// #0
  40bf80:	17ffffbe 	b	40be78 <_posix_zephyr_main+0x104>
		suite_result = TC_SKIP;
  40bf84:	52800040 	mov	w0, #0x2                   	// #2
		passrate_major = passrate_minor = 0;
  40bf88:	52800003 	mov	w3, #0x0                   	// #0
  40bf8c:	52800008 	mov	w8, #0x0                   	// #0
  40bf90:	17ffffd2 	b	40bed8 <_posix_zephyr_main+0x164>
		if (test->stats->skip_count == test->stats->run_count) {
  40bf94:	f9401263 	ldr	x3, [x19, #32]
  40bf98:	29400460 	ldp	w0, w1, [x3]
  40bf9c:	6b00003f 	cmp	w1, w0
  40bfa0:	54000260 	b.eq	40bfec <_posix_zephyr_main+0x278>  // b.none
		} else if (test->stats->pass_count == test->stats->run_count) {
  40bfa4:	b9400c61 	ldr	w1, [x3, #12]
  40bfa8:	6b00003f 	cmp	w1, w0
  40bfac:	1a9f07e0 	cset	w0, ne  // ne = any
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40bfb0:	97fffcfe 	bl	40b3a8 <TC_RESULT_TO_STR>
  40bfb4:	b9401065 	ldr	w5, [x3, #16]
  40bfb8:	a9400e62 	ldp	x2, x3, [x19]
  40bfbc:	aa0003e1 	mov	x1, x0
  40bfc0:	aa1603e0 	mov	x0, x22
  40bfc4:	1ad908a4 	udiv	w4, w5, w25
  40bfc8:	1b199485 	msub	w5, w4, w25, w5
  40bfcc:	97ffe993 	bl	406618 <printk>
  40bfd0:	1b177ea1 	mul	w1, w21, w23
		if (flush_frequency % 3 == 0) {
  40bfd4:	3200f3e0 	mov	w0, #0x55555555            	// #1431655765
  40bfd8:	6b00003f 	cmp	w1, w0
  40bfdc:	54000048 	b.hi	40bfe4 <_posix_zephyr_main+0x270>  // b.pmore
			flush_log();
  40bfe0:	97fffd37 	bl	40b4bc <flush_log>
		flush_frequency++;
  40bfe4:	110006b5 	add	w21, w21, #0x1
  40bfe8:	17ffffce 	b	40bf20 <_posix_zephyr_main+0x1ac>
			tc_result = TC_SKIP;
  40bfec:	52800040 	mov	w0, #0x2                   	// #2
  40bff0:	17fffff0 	b	40bfb0 <_posix_zephyr_main+0x23c>
		TC_END_REPORT(TC_PASS);
  40bff4:	97ffe989 	bl	406618 <printk>
  40bff8:	91331680 	add	x0, x20, #0xcc5
  40bffc:	97ffe987 	bl	406618 <printk>
  40c000:	9133d660 	add	x0, x19, #0xcf5
  40c004:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40c008:	91342c21 	add	x1, x1, #0xd0b
  40c00c:	97ffe983 	bl	406618 <printk>
  40c010:	97fff030 	bl	4080d0 <z_impl_log_panic>
  40c014:	52800000 	mov	w0, #0x0                   	// #0
  40c018:	17ffff83 	b	40be24 <_posix_zephyr_main+0xb0>

000000000040c01c <add_test_filter_option>:
		  "\'suiteA::test1,suiteA::test2,suiteB::*\'. An * can be used "
		  "as a wildcard to run all tests within a suite." },
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(test_filter_s);
  40c01c:	90000100 	adrp	x0, 42c000 <__dso_handle>
  40c020:	910d0000 	add	x0, x0, #0x340
  40c024:	17fffc23 	b	40b0b0 <native_add_command_line_opts>

000000000040c028 <z_ztest_testargs_contains>:
 * @param test_name
 * @return true
 * @return false
 */
static bool z_ztest_testargs_contains(const char *suite_name, const char *test_name)
{
  40c028:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40c02c:	910003fd 	mov	x29, sp
  40c030:	a90363f7 	stp	x23, x24, [sp, #48]
  40c034:	aa0003f7 	mov	x23, x0
  40c038:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40c03c:	a90153f3 	stp	x19, x20, [sp, #16]
  40c040:	aa0103f4 	mov	x20, x1
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
		test_arg = strtok_r(NULL, ":", &last_arg);

		found = !strcmp(suite_arg, suite_name);
		if (test_name) {
			found &= !strcmp(test_arg, "*") ||
  40c044:	b0000058 	adrp	x24, 415000 <random_data+0xb30>
{
  40c048:	f9476800 	ldr	x0, [x0, #3792]
  40c04c:	a9025bf5 	stp	x21, x22, [sp, #32]
			found &= !strcmp(test_arg, "*") ||
  40c050:	91346318 	add	x24, x24, #0xd18
{
  40c054:	a9046bf9 	stp	x25, x26, [sp, #64]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40c058:	b0000055 	adrp	x21, 415000 <random_data+0xb30>
  40c05c:	91221eb5 	add	x21, x21, #0x887
{
  40c060:	a90573fb 	stp	x27, x28, [sp, #80]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40c064:	9101c3fb 	add	x27, sp, #0x70
	bool found = false;
  40c068:	52800013 	mov	w19, #0x0                   	// #0
{
  40c06c:	f9400001 	ldr	x1, [x0]
  40c070:	f9003fe1 	str	x1, [sp, #120]
  40c074:	d2800001 	mov	x1, #0x0                   	// #0
	char *test_args_local = strdup(test_args);
  40c078:	b0000100 	adrp	x0, 42d000 <counter_period>
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40c07c:	9101a3f9 	add	x25, sp, #0x68
  40c080:	b000005a 	adrp	x26, 415000 <random_data+0xb30>
	char *test_args_local = strdup(test_args);
  40c084:	f9408000 	ldr	x0, [x0, #256]
  40c088:	97ffd4a2 	bl	401310 <strdup@plt>
  40c08c:	aa0003f6 	mov	x22, x0
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40c090:	aa1903e2 	mov	x2, x25
  40c094:	91345b41 	add	x1, x26, #0xd16
  40c098:	97ffd476 	bl	401270 <strtok_r@plt>
	while (suite_test_pair && !found) {
  40c09c:	f100001f 	cmp	x0, #0x0
  40c0a0:	52000261 	eor	w1, w19, #0x1
  40c0a4:	1a9f07e2 	cset	w2, ne  // ne = any
  40c0a8:	6a01005f 	tst	w2, w1
  40c0ac:	54000161 	b.ne	40c0d8 <z_ztest_testargs_contains+0xb0>  // b.any
		}

		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
	}

	free(test_args_local);
  40c0b0:	aa1603e0 	mov	x0, x22
  40c0b4:	97ffd4cb 	bl	4013e0 <free@plt>
	return found;
}
  40c0b8:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40c0bc:	f9476800 	ldr	x0, [x0, #3792]
  40c0c0:	f9403fe2 	ldr	x2, [sp, #120]
  40c0c4:	f9400001 	ldr	x1, [x0]
  40c0c8:	eb010042 	subs	x2, x2, x1
  40c0cc:	d2800001 	mov	x1, #0x0                   	// #0
  40c0d0:	54000440 	b.eq	40c158 <z_ztest_testargs_contains+0x130>  // b.none
  40c0d4:	97ffd493 	bl	401320 <__stack_chk_fail@plt>
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40c0d8:	aa1b03e2 	mov	x2, x27
  40c0dc:	aa1503e1 	mov	x1, x21
  40c0e0:	97ffd464 	bl	401270 <strtok_r@plt>
  40c0e4:	aa0003f3 	mov	x19, x0
		test_arg = strtok_r(NULL, ":", &last_arg);
  40c0e8:	aa1b03e2 	mov	x2, x27
  40c0ec:	aa1503e1 	mov	x1, x21
  40c0f0:	d2800000 	mov	x0, #0x0                   	// #0
  40c0f4:	97ffd45f 	bl	401270 <strtok_r@plt>
		found = !strcmp(suite_arg, suite_name);
  40c0f8:	aa1703e1 	mov	x1, x23
		test_arg = strtok_r(NULL, ":", &last_arg);
  40c0fc:	aa0003fc 	mov	x28, x0
		found = !strcmp(suite_arg, suite_name);
  40c100:	aa1303e0 	mov	x0, x19
  40c104:	97ffd4a7 	bl	4013a0 <strcmp@plt>
  40c108:	7100001f 	cmp	w0, #0x0
  40c10c:	1a9f17f3 	cset	w19, eq  // eq = none
		if (test_name) {
  40c110:	b4000174 	cbz	x20, 40c13c <z_ztest_testargs_contains+0x114>
			found &= !strcmp(test_arg, "*") ||
  40c114:	aa1803e1 	mov	x1, x24
  40c118:	aa1c03e0 	mov	x0, x28
  40c11c:	97ffd4a1 	bl	4013a0 <strcmp@plt>
  40c120:	34000180 	cbz	w0, 40c150 <z_ztest_testargs_contains+0x128>
				 !strcmp(test_arg, test_name);
  40c124:	aa1403e1 	mov	x1, x20
  40c128:	aa1c03e0 	mov	x0, x28
  40c12c:	97ffd49d 	bl	4013a0 <strcmp@plt>
			found &= !strcmp(test_arg, "*") ||
  40c130:	7100001f 	cmp	w0, #0x0
  40c134:	1a9f17e0 	cset	w0, eq  // eq = none
  40c138:	0a000273 	and	w19, w19, w0
		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
  40c13c:	aa1903e2 	mov	x2, x25
  40c140:	91345b41 	add	x1, x26, #0xd16
  40c144:	d2800000 	mov	x0, #0x0                   	// #0
  40c148:	97ffd44a 	bl	401270 <strtok_r@plt>
  40c14c:	17ffffd4 	b	40c09c <z_ztest_testargs_contains+0x74>
			found &= !strcmp(test_arg, "*") ||
  40c150:	52800020 	mov	w0, #0x1                   	// #1
  40c154:	17fffff9 	b	40c138 <z_ztest_testargs_contains+0x110>
}
  40c158:	2a1303e0 	mov	w0, w19
  40c15c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c160:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c164:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c168:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40c16c:	a94573fb 	ldp	x27, x28, [sp, #80]
  40c170:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40c174:	d65f03c0 	ret

000000000040c178 <z_ztest_should_test_run>:
 */
bool z_ztest_should_test_run(const char *suite, const char *test)
{
	bool run_test = false;

	run_test = (test_args == NULL ||
  40c178:	b0000102 	adrp	x2, 42d000 <counter_period>
  40c17c:	f9408042 	ldr	x2, [x2, #256]
  40c180:	b4000102 	cbz	x2, 40c1a0 <z_ztest_should_test_run+0x28>
{
  40c184:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40c188:	910003fd 	mov	x29, sp
		    z_ztest_testargs_contains(suite, test));
  40c18c:	97ffffa7 	bl	40c028 <z_ztest_testargs_contains>
  40c190:	12001c00 	and	w0, w0, #0xff

	return run_test;
}
  40c194:	12000000 	and	w0, w0, #0x1
  40c198:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40c19c:	d65f03c0 	ret
	run_test = (test_args == NULL ||
  40c1a0:	52800020 	mov	w0, #0x1                   	// #1
}
  40c1a4:	12000000 	and	w0, w0, #0x1
  40c1a8:	d65f03c0 	ret

000000000040c1ac <z_ztest_should_suite_run>:
 * @param suite Pointer to ztest_suite_node
 * @return true
 * @return false
 */
bool z_ztest_should_suite_run(const void *state, struct ztest_suite_node *suite)
{
  40c1ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c1b0:	910003fd 	mov	x29, sp
  40c1b4:	a90153f3 	stp	x19, x20, [sp, #16]
  40c1b8:	aa0003f4 	mov	x20, x0
	bool run_suite = true;

	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40c1bc:	b0000100 	adrp	x0, 42d000 <counter_period>
{
  40c1c0:	aa0103f3 	mov	x19, x1
	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40c1c4:	f9408000 	ldr	x0, [x0, #256]
  40c1c8:	b40001a0 	cbz	x0, 40c1fc <z_ztest_should_suite_run+0x50>
  40c1cc:	f9400260 	ldr	x0, [x19]
  40c1d0:	d2800001 	mov	x1, #0x0                   	// #0
  40c1d4:	97ffff95 	bl	40c028 <z_ztest_testargs_contains>
  40c1d8:	72001c00 	ands	w0, w0, #0xff
  40c1dc:	54000101 	b.ne	40c1fc <z_ztest_should_suite_run+0x50>  // b.any
  40c1e0:	f9401a62 	ldr	x2, [x19, #48]
		run_suite = false;
		suite->stats->run_count++;
  40c1e4:	b9400041 	ldr	w1, [x2]
  40c1e8:	11000421 	add	w1, w1, #0x1
  40c1ec:	b9000041 	str	w1, [x2]
	} else if (suite->predicate != NULL) {
		run_suite = suite->predicate(state);
	}

	return run_suite;
}
  40c1f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c1f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c1f8:	d65f03c0 	ret
	} else if (suite->predicate != NULL) {
  40c1fc:	f9401661 	ldr	x1, [x19, #40]
  40c200:	b40000c1 	cbz	x1, 40c218 <z_ztest_should_suite_run+0x6c>
		run_suite = suite->predicate(state);
  40c204:	aa1403e0 	mov	x0, x20
  40c208:	aa0103f0 	mov	x16, x1
}
  40c20c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c210:	a8c27bfd 	ldp	x29, x30, [sp], #32
		run_suite = suite->predicate(state);
  40c214:	d61f0200 	br	x16
	bool run_suite = true;
  40c218:	52800020 	mov	w0, #0x1                   	// #1
  40c21c:	17fffff5 	b	40c1f0 <z_ztest_should_suite_run+0x44>

000000000040c220 <ztest_relative_filename>:
{
  40c220:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  40c224:	910003fd 	mov	x29, sp
  40c228:	a90153f3 	stp	x19, x20, [sp, #16]
  40c22c:	aa0003f3 	mov	x19, x0
  40c230:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40c234:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c238:	f9476800 	ldr	x0, [x0, #3792]
  40c23c:	f9400001 	ldr	x1, [x0]
  40c240:	f9007fe1 	str	x1, [sp, #248]
  40c244:	d2800001 	mov	x1, #0x0                   	// #0
		       "destination buffer");

__fortify_function __wur char *
__NTH (getcwd (char *__buf, size_t __size))
{
  return __glibc_fortify (getcwd, __size, sizeof (char),
  40c248:	9100c3e0 	add	x0, sp, #0x30
  40c24c:	d2801901 	mov	x1, #0xc8                  	// #200
  40c250:	97ffd3cc 	bl	401180 <getcwd@plt>
	if (cwd && strlen(file) > strlen(cwd) && !strncmp(file, cwd, strlen(cwd))) {
  40c254:	b4000220 	cbz	x0, 40c298 <ztest_relative_filename+0x78>
  40c258:	aa0003f5 	mov	x21, x0
  40c25c:	aa1303e0 	mov	x0, x19
  40c260:	97ffd3d0 	bl	4011a0 <strlen@plt>
  40c264:	aa0003f6 	mov	x22, x0
  40c268:	aa1503e0 	mov	x0, x21
  40c26c:	97ffd3cd 	bl	4011a0 <strlen@plt>
  40c270:	aa0003f4 	mov	x20, x0
  40c274:	eb0002df 	cmp	x22, x0
  40c278:	54000109 	b.ls	40c298 <ztest_relative_filename+0x78>  // b.plast
  40c27c:	aa0003e2 	mov	x2, x0
  40c280:	aa1503e1 	mov	x1, x21
  40c284:	aa1303e0 	mov	x0, x19
  40c288:	97ffd402 	bl	401290 <strncmp@plt>
  40c28c:	35000060 	cbnz	w0, 40c298 <ztest_relative_filename+0x78>
		return file + strlen(cwd) + 1; /* move past the trailing '/' */
  40c290:	91000694 	add	x20, x20, #0x1
  40c294:	8b140273 	add	x19, x19, x20
}
  40c298:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40c29c:	f9476800 	ldr	x0, [x0, #3792]
  40c2a0:	f9407fe2 	ldr	x2, [sp, #248]
  40c2a4:	f9400001 	ldr	x1, [x0]
  40c2a8:	eb010042 	subs	x2, x2, x1
  40c2ac:	d2800001 	mov	x1, #0x0                   	// #0
  40c2b0:	54000040 	b.eq	40c2b8 <ztest_relative_filename+0x98>  // b.none
  40c2b4:	97ffd41b 	bl	401320 <__stack_chk_fail@plt>
  40c2b8:	aa1303e0 	mov	x0, x19
  40c2bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c2c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c2c4:	a8d07bfd 	ldp	x29, x30, [sp], #256
  40c2c8:	d65f03c0 	ret

000000000040c2cc <z_ztest_get_list_test>:
}
  40c2cc:	b0000100 	adrp	x0, 42d000 <counter_period>
  40c2d0:	397ff400 	ldrb	w0, [x0, #4093]
  40c2d4:	d65f03c0 	ret

000000000040c2d8 <z_ztest_list_tests>:
{
  40c2d8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40c2dc:	910003fd 	mov	x29, sp
  40c2e0:	a90363f7 	stp	x23, x24, [sp, #48]
	if (list_once) {
  40c2e4:	90000118 	adrp	x24, 42c000 <__dso_handle>
  40c2e8:	39504700 	ldrb	w0, [x24, #1041]
{
  40c2ec:	a90153f3 	stp	x19, x20, [sp, #16]
  40c2f0:	a9025bf5 	stp	x21, x22, [sp, #32]
	int test_count = 0;
  40c2f4:	52800015 	mov	w21, #0x0                   	// #0
	if (list_once) {
  40c2f8:	350002e0 	cbnz	w0, 40c354 <z_ztest_list_tests+0x7c>
}
  40c2fc:	2a1503e0 	mov	w0, w21
  40c300:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c304:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c308:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c30c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40c310:	d65f03c0 	ret
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c314:	a9400a61 	ldp	x1, x2, [x19]
  40c318:	aa1703e0 	mov	x0, x23
				test_count++;
  40c31c:	110006b5 	add	w21, w21, #0x1
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c320:	97ffe8be 	bl	406618 <printk>
			while ((test = z_ztest_get_next_test(ptr->name, test)) != NULL) {
  40c324:	f9400280 	ldr	x0, [x20]
  40c328:	aa1303e1 	mov	x1, x19
  40c32c:	97fffcd2 	bl	40b674 <z_ztest_get_next_test>
  40c330:	aa0003f3 	mov	x19, x0
  40c334:	b5ffff00 	cbnz	x0, 40c314 <z_ztest_list_tests+0x3c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c338:	9100e294 	add	x20, x20, #0x38
  40c33c:	eb16029f 	cmp	x20, x22
  40c340:	54000063 	b.cc	40c34c <z_ztest_list_tests+0x74>  // b.lo, b.ul, b.last
		list_once = false;
  40c344:	3910471f 	strb	wzr, [x24, #1041]
	return test_count;
  40c348:	17ffffed 	b	40c2fc <z_ztest_list_tests+0x24>
			test = NULL;
  40c34c:	d2800013 	mov	x19, #0x0                   	// #0
  40c350:	17fffff5 	b	40c324 <z_ztest_list_tests+0x4c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c354:	f00000f4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  40c358:	f00000f6 	adrp	x22, 42b000 <__FRAME_END__+0xfd74>
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c35c:	b0000057 	adrp	x23, 415000 <random_data+0xb30>
  40c360:	91346af7 	add	x23, x23, #0xd1a
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c364:	f9472294 	ldr	x20, [x20, #3648]
  40c368:	f9473ed6 	ldr	x22, [x22, #3704]
  40c36c:	17fffff4 	b	40c33c <z_ztest_list_tests+0x64>

000000000040c370 <z_ztest_run_all>:
{
  40c370:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c374:	910003fd 	mov	x29, sp
  40c378:	f9000bf3 	str	x19, [sp, #16]
  40c37c:	aa0003f3 	mov	x19, x0
	if (z_ztest_get_list_test()) {
  40c380:	97ffffd3 	bl	40c2cc <z_ztest_get_list_test>
  40c384:	72001c1f 	tst	w0, #0xff
  40c388:	54000080 	b.eq	40c398 <z_ztest_run_all+0x28>  // b.none
}
  40c38c:	f9400bf3 	ldr	x19, [sp, #16]
  40c390:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_ztest_list_tests();
  40c394:	17ffffd1 	b	40c2d8 <z_ztest_list_tests>
		union { uintptr_t x; const void * val; } parm0 = { .val = state };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_ZTEST_RUN_TEST_SUITES);
	}
#endif
	compiler_barrier();
	return z_impl_ztest_run_test_suites(state);
  40c398:	aa1303e0 	mov	x0, x19
}
  40c39c:	f9400bf3 	ldr	x19, [sp, #16]
  40c3a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c3a4:	17fffdd3 	b	40baf0 <z_impl_ztest_run_test_suites>

000000000040c3a8 <generic_data_ref>:

	net_buf_simple_reset(&buf->b);
}

static uint8_t *generic_data_ref(struct net_buf *buf, uint8_t *data)
{
  40c3a8:	aa0103e0 	mov	x0, x1
	uint8_t *ref_count;

	ref_count = data - sizeof(void *);
	(*ref_count)++;
  40c3ac:	385f8021 	ldurb	w1, [x1, #-8]
  40c3b0:	11000421 	add	w1, w1, #0x1
  40c3b4:	381f8001 	sturb	w1, [x0, #-8]

	return data;
}
  40c3b8:	d65f03c0 	ret

000000000040c3bc <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
  40c3bc:	d65f03c0 	ret

000000000040c3c0 <net_buf_pool_get>:
}
  40c3c0:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40c3c4:	52800c02 	mov	w2, #0x60                  	// #96
  40c3c8:	f9479421 	ldr	x1, [x1, #3880]
  40c3cc:	9b220400 	smaddl	x0, w0, w2, x1
  40c3d0:	d65f03c0 	ret

000000000040c3d4 <mem_pool_data_unref>:
{
  40c3d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c3d8:	910003fd 	mov	x29, sp
  40c3dc:	f9000bf3 	str	x19, [sp, #16]
  40c3e0:	aa0103f3 	mov	x19, x1
	struct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);
  40c3e4:	39404800 	ldrb	w0, [x0, #18]
  40c3e8:	97fffff6 	bl	40c3c0 <net_buf_pool_get>
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c3ec:	f9402800 	ldr	x0, [x0, #80]
	if (--(*ref_count)) {
  40c3f0:	385f8262 	ldurb	w2, [x19, #-8]
  40c3f4:	51000442 	sub	w2, w2, #0x1
  40c3f8:	12001c42 	and	w2, w2, #0xff
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c3fc:	f9400400 	ldr	x0, [x0, #8]
	if (--(*ref_count)) {
  40c400:	381f8262 	sturb	w2, [x19, #-8]
  40c404:	350000a2 	cbnz	w2, 40c418 <mem_pool_data_unref+0x44>
	k_heap_free(pool, ref_count);
  40c408:	d1002261 	sub	x1, x19, #0x8
}
  40c40c:	f9400bf3 	ldr	x19, [sp, #16]
  40c410:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_heap_free(pool, ref_count);
  40c414:	140006a4 	b	40dea4 <k_heap_free>
}
  40c418:	f9400bf3 	ldr	x19, [sp, #16]
  40c41c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c420:	d65f03c0 	ret

000000000040c424 <mem_pool_data_alloc>:
{
  40c424:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c428:	910003fd 	mov	x29, sp
  40c42c:	a90153f3 	stp	x19, x20, [sp, #16]
  40c430:	aa0103f4 	mov	x20, x1
  40c434:	aa0203f3 	mov	x19, x2
	struct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);
  40c438:	39404800 	ldrb	w0, [x0, #18]
  40c43c:	97ffffe1 	bl	40c3c0 <net_buf_pool_get>
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c440:	f9402800 	ldr	x0, [x0, #80]
	void *b = k_heap_alloc(pool, sizeof(void *) + *size, timeout);
  40c444:	aa1303e2 	mov	x2, x19
  40c448:	f9400281 	ldr	x1, [x20]
  40c44c:	f9400400 	ldr	x0, [x0, #8]
  40c450:	91002021 	add	x1, x1, #0x8
  40c454:	94000690 	bl	40de94 <k_heap_alloc>
	if (b == NULL) {
  40c458:	b4000060 	cbz	x0, 40c464 <mem_pool_data_alloc+0x40>
	*ref_count = 1U;
  40c45c:	52800021 	mov	w1, #0x1                   	// #1
  40c460:	38008401 	strb	w1, [x0], #8
}
  40c464:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c468:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c46c:	d65f03c0 	ret

000000000040c470 <data_alloc>:
};

#endif /* CONFIG_HEAP_MEM_POOL_SIZE > 0 */

static uint8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)
{
  40c470:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c474:	910003fd 	mov	x29, sp
  40c478:	a90153f3 	stp	x19, x20, [sp, #16]
  40c47c:	aa0003f3 	mov	x19, x0
  40c480:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c484:	39404800 	ldrb	w0, [x0, #18]
{
  40c488:	f90013f5 	str	x21, [sp, #32]
  40c48c:	aa0203f5 	mov	x21, x2
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c490:	97ffffcc 	bl	40c3c0 <net_buf_pool_get>

	return pool->alloc->cb->alloc(buf, size, timeout);
  40c494:	f9402800 	ldr	x0, [x0, #80]
  40c498:	aa1503e2 	mov	x2, x21
  40c49c:	aa1403e1 	mov	x1, x20
}
  40c4a0:	f94013f5 	ldr	x21, [sp, #32]
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c4a4:	f9400000 	ldr	x0, [x0]
  40c4a8:	f9400003 	ldr	x3, [x0]
  40c4ac:	aa1303e0 	mov	x0, x19
}
  40c4b0:	a94153f3 	ldp	x19, x20, [sp, #16]
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c4b4:	aa0303f0 	mov	x16, x3
}
  40c4b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c4bc:	d61f0200 	br	x16

000000000040c4c0 <net_buf_destroy>:
{
  40c4c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c4c4:	910003fd 	mov	x29, sp
  40c4c8:	f9000bf3 	str	x19, [sp, #16]
  40c4cc:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c4d0:	39404800 	ldrb	w0, [x0, #18]
  40c4d4:	97ffffbb 	bl	40c3c0 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40c4d8:	aa1303e1 	mov	x1, x19
}
  40c4dc:	f9400bf3 	ldr	x19, [sp, #16]
  40c4e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_lifo_put(&pool->free, buf);
  40c4e4:	14000c67 	b	40f680 <k_queue_prepend>

000000000040c4e8 <net_buf_id>:
{
  40c4e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c4ec:	910003fd 	mov	x29, sp
  40c4f0:	f9000bf3 	str	x19, [sp, #16]
  40c4f4:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c4f8:	39404800 	ldrb	w0, [x0, #18]
  40c4fc:	97ffffb1 	bl	40c3c0 <net_buf_pool_get>
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40c500:	f9402c01 	ldr	x1, [x0, #88]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c504:	39411000 	ldrb	w0, [x0, #68]
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40c508:	cb010273 	sub	x19, x19, x1
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c50c:	9100dc00 	add	x0, x0, #0x37
  40c510:	927df000 	and	x0, x0, #0xfffffffffffffff8
}
  40c514:	9ac00a60 	udiv	x0, x19, x0
  40c518:	f9400bf3 	ldr	x19, [sp, #16]
  40c51c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c520:	d65f03c0 	ret

000000000040c524 <fixed_data_alloc>:
{
  40c524:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c528:	910003fd 	mov	x29, sp
  40c52c:	a90153f3 	stp	x19, x20, [sp, #16]
  40c530:	aa0003f3 	mov	x19, x0
  40c534:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c538:	39404800 	ldrb	w0, [x0, #18]
{
  40c53c:	f90013f5 	str	x21, [sp, #32]
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c540:	97ffffa0 	bl	40c3c0 <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40c544:	f9402800 	ldr	x0, [x0, #80]
  40c548:	f9400401 	ldr	x1, [x0, #8]
	*size = MIN(fixed->data_size, *size);
  40c54c:	f9400280 	ldr	x0, [x20]
  40c550:	f9400022 	ldr	x2, [x1]
  40c554:	eb02001f 	cmp	x0, x2
  40c558:	9a829000 	csel	x0, x0, x2, ls  // ls = plast
  40c55c:	f9000280 	str	x0, [x20]
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
  40c560:	aa1303e0 	mov	x0, x19
  40c564:	a9405035 	ldp	x21, x20, [x1]
  40c568:	97ffffe0 	bl	40c4e8 <net_buf_id>
  40c56c:	93407c00 	sxtw	x0, w0
}
  40c570:	9b155000 	madd	x0, x0, x21, x20
  40c574:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c578:	f94013f5 	ldr	x21, [sp, #32]
  40c57c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40c580:	d65f03c0 	ret

000000000040c584 <net_buf_reset>:
{
  40c584:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c588:	910003fd 	mov	x29, sp
  40c58c:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(buf->flags == 0U);
  40c590:	39404401 	ldrb	w1, [x0, #17]
  40c594:	34000241 	cbz	w1, 40c5dc <net_buf_reset+0x58>
  40c598:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40c59c:	9137ca73 	add	x19, x19, #0xdf2
  40c5a0:	aa1303e2 	mov	x2, x19
  40c5a4:	52800b43 	mov	w3, #0x5a                  	// #90
  40c5a8:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40c5ac:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c5b0:	91385821 	add	x1, x1, #0xe16
  40c5b4:	9123f800 	add	x0, x0, #0x8fe
  40c5b8:	97ffedd5 	bl	407d0c <assert_print>
  40c5bc:	aa1303e0 	mov	x0, x19
  40c5c0:	52800b41 	mov	w1, #0x5a                  	// #90
  40c5c4:	97ffedfc 	bl	407db4 <assert_post_action>
  40c5c8:	52800b42 	mov	w2, #0x5a                  	// #90
	__ASSERT_NO_MSG(buf->frags == NULL);
  40c5cc:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c5d0:	aa1303e1 	mov	x1, x19
  40c5d4:	9124f000 	add	x0, x0, #0x93c
  40c5d8:	97fff7e9 	bl	40a57c <posix_print_error_and_exit>
  40c5dc:	f9400401 	ldr	x1, [x0, #8]
  40c5e0:	b40001e1 	cbz	x1, 40c61c <net_buf_reset+0x98>
  40c5e4:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40c5e8:	9137ca73 	add	x19, x19, #0xdf2
  40c5ec:	aa1303e2 	mov	x2, x19
  40c5f0:	52800b63 	mov	w3, #0x5b                  	// #91
  40c5f4:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40c5f8:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c5fc:	91389c21 	add	x1, x1, #0xe27
  40c600:	9123f800 	add	x0, x0, #0x8fe
  40c604:	97ffedc2 	bl	407d0c <assert_print>
  40c608:	aa1303e0 	mov	x0, x19
  40c60c:	52800b61 	mov	w1, #0x5b                  	// #91
  40c610:	97ffede9 	bl	407db4 <assert_post_action>
  40c614:	52800b62 	mov	w2, #0x5b                  	// #91
  40c618:	17ffffed 	b	40c5cc <net_buf_reset+0x48>
	buf->data = buf->__buf;
  40c61c:	f9401401 	ldr	x1, [x0, #40]
  40c620:	f9000c01 	str	x1, [x0, #24]
	buf->len  = 0U;
  40c624:	7900401f 	strh	wzr, [x0, #32]
}
  40c628:	f9400bf3 	ldr	x19, [sp, #16]
  40c62c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c630:	d65f03c0 	ret

000000000040c634 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
  40c634:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40c638:	910003fd 	mov	x29, sp
  40c63c:	a90153f3 	stp	x19, x20, [sp, #16]
  40c640:	aa0003f4 	mov	x20, x0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
  40c644:	aa0203e0 	mov	x0, x2
{
  40c648:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c64c:	aa0203f5 	mov	x21, x2
  40c650:	a90363f7 	stp	x23, x24, [sp, #48]
  40c654:	f90023f9 	str	x25, [sp, #64]
  40c658:	f9002fe1 	str	x1, [sp, #88]
	uint64_t end = sys_clock_timeout_end_calc(timeout);
  40c65c:	94001ac9 	bl	413180 <sys_clock_timeout_end_calc>
	struct net_buf *buf;
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(pool);
  40c660:	b5000254 	cbnz	x20, 40c6a8 <net_buf_alloc_len+0x74>
  40c664:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40c668:	9137ca73 	add	x19, x19, #0xdf2
  40c66c:	aa1303e2 	mov	x2, x19
  40c670:	52801f03 	mov	w3, #0xf8                  	// #248
  40c674:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40c678:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c67c:	91390421 	add	x1, x1, #0xe41
  40c680:	9123f800 	add	x0, x0, #0x8fe
  40c684:	97ffeda2 	bl	407d0c <assert_print>
  40c688:	aa1303e0 	mov	x0, x19
  40c68c:	52801f01 	mov	w1, #0xf8                  	// #248
  40c690:	97ffedc9 	bl	407db4 <assert_post_action>
  40c694:	52801f02 	mov	w2, #0xf8                  	// #248
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40c698:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c69c:	aa1303e1 	mov	x1, x19
  40c6a0:	9124f000 	add	x0, x0, #0x93c
  40c6a4:	97fff7b6 	bl	40a57c <posix_print_error_and_exit>
  40c6a8:	aa0003f7 	mov	x23, x0
	NET_BUF_DBG("%s():%d: pool %p size %zu", func, line, pool, size);

	/* We need to prevent race conditions
	 * when accessing pool->uninit_count.
	 */
	key = k_spin_lock(&pool->lock);
  40c6ac:	9100e296 	add	x22, x20, #0x38
	return posix_irq_lock();
  40c6b0:	97fff69d 	bl	40a124 <posix_irq_lock>
  40c6b4:	2a0003f8 	mov	w24, w0
  40c6b8:	aa1603e0 	mov	x0, x22
  40c6bc:	94000841 	bl	40e7c0 <z_spin_lock_valid>
  40c6c0:	72001c1f 	tst	w0, #0xff
  40c6c4:	54000261 	b.ne	40c710 <net_buf_alloc_len+0xdc>  // b.any
  40c6c8:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40c6cc:	91391a73 	add	x19, x19, #0xe46
  40c6d0:	aa1303e2 	mov	x2, x19
  40c6d4:	52801283 	mov	w3, #0x94                  	// #148
  40c6d8:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40c6dc:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c6e0:	9139cc21 	add	x1, x1, #0xe73
  40c6e4:	9123f800 	add	x0, x0, #0x8fe
  40c6e8:	97ffed89 	bl	407d0c <assert_print>
  40c6ec:	aa1603e1 	mov	x1, x22
  40c6f0:	b0000040 	adrp	x0, 415000 <random_data+0xb30>
  40c6f4:	913a2000 	add	x0, x0, #0xe88
  40c6f8:	97ffed85 	bl	407d0c <assert_print>
  40c6fc:	aa1303e0 	mov	x0, x19
  40c700:	52801281 	mov	w1, #0x94                  	// #148
  40c704:	97ffedac 	bl	407db4 <assert_post_action>
  40c708:	52801282 	mov	w2, #0x94                  	// #148
  40c70c:	17ffffe3 	b	40c698 <net_buf_alloc_len+0x64>
		arch_spin_relax();
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
  40c710:	aa1603e0 	mov	x0, x22
  40c714:	94000843 	bl	40e820 <z_spin_lock_set_owner>

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
  40c718:	79408680 	ldrh	w0, [x20, #66]
  40c71c:	340009e0 	cbz	w0, 40c858 <net_buf_alloc_len+0x224>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
  40c720:	79408281 	ldrh	w1, [x20, #64]
  40c724:	6b00003f 	cmp	w1, w0
  40c728:	54000609 	b.ls	40c7e8 <net_buf_alloc_len+0x1b4>  // b.plast
	return z_impl_k_queue_get(queue, timeout);
  40c72c:	d2800001 	mov	x1, #0x0                   	// #0
  40c730:	aa1403e0 	mov	x0, x20
  40c734:	94000bd8 	bl	40f694 <z_impl_k_queue_get>
  40c738:	aa0003f3 	mov	x19, x0
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
  40c73c:	b4000560 	cbz	x0, 40c7e8 <net_buf_alloc_len+0x1b4>
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40c740:	aa1603e0 	mov	x0, x22
  40c744:	9400082a 	bl	40e7ec <z_spin_unlock_valid>
  40c748:	72001c1f 	tst	w0, #0xff
  40c74c:	54000261 	b.ne	40c798 <net_buf_alloc_len+0x164>  // b.any
  40c750:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40c754:	91391a73 	add	x19, x19, #0xe46
  40c758:	aa1303e2 	mov	x2, x19
  40c75c:	52801863 	mov	w3, #0xc3                  	// #195
  40c760:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40c764:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c768:	913a8021 	add	x1, x1, #0xea0
  40c76c:	9123f800 	add	x0, x0, #0x8fe
  40c770:	97ffed67 	bl	407d0c <assert_print>
  40c774:	aa1603e1 	mov	x1, x22
  40c778:	b0000040 	adrp	x0, 415000 <random_data+0xb30>
  40c77c:	913adc00 	add	x0, x0, #0xeb7
  40c780:	97ffed63 	bl	407d0c <assert_print>
  40c784:	aa1303e0 	mov	x0, x19
  40c788:	52801861 	mov	w1, #0xc3                  	// #195
  40c78c:	97ffed8a 	bl	407db4 <assert_post_action>
  40c790:	52801862 	mov	w2, #0xc3                  	// #195
  40c794:	17ffffc1 	b	40c698 <net_buf_alloc_len+0x64>
	posix_irq_unlock(key);
  40c798:	2a1803e0 	mov	w0, w24
  40c79c:	97fff664 	bl	40a12c <posix_irq_unlock>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
  40c7a0:	f9402ff4 	ldr	x20, [sp, #88]
  40c7a4:	b4000a74 	cbz	x20, 40c8f0 <net_buf_alloc_len+0x2bc>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  40c7a8:	b40000d5 	cbz	x21, 40c7c0 <net_buf_alloc_len+0x18c>
  40c7ac:	b10006bf 	cmn	x21, #0x1
  40c7b0:	54000080 	b.eq	40c7c0 <net_buf_alloc_len+0x18c>  // b.none
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
  40c7b4:	94001a29 	bl	413058 <sys_clock_tick_get>

			if (remaining <= 0) {
  40c7b8:	eb0002f5 	subs	x21, x23, x0
  40c7bc:	9a9f52b5 	csel	x21, x21, xzr, pl  // pl = nfrst
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
  40c7c0:	aa1503e2 	mov	x2, x21
  40c7c4:	910163e1 	add	x1, sp, #0x58
  40c7c8:	aa1303e0 	mov	x0, x19
  40c7cc:	97ffff29 	bl	40c470 <data_alloc>
  40c7d0:	f9001660 	str	x0, [x19, #40]
		if (!buf->__buf) {
  40c7d4:	b5000660 	cbnz	x0, 40c8a0 <net_buf_alloc_len+0x26c>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
  40c7d8:	aa1303e0 	mov	x0, x19
			return NULL;
  40c7dc:	d2800013 	mov	x19, #0x0                   	// #0
			net_buf_destroy(buf);
  40c7e0:	97ffff38 	bl	40c4c0 <net_buf_destroy>
			return NULL;
  40c7e4:	14000028 	b	40c884 <net_buf_alloc_len+0x250>
		uninit_count = pool->uninit_count--;
  40c7e8:	79408699 	ldrh	w25, [x20, #66]
  40c7ec:	51000720 	sub	w0, w25, #0x1
  40c7f0:	79008680 	strh	w0, [x20, #66]
  40c7f4:	aa1603e0 	mov	x0, x22
  40c7f8:	940007fd 	bl	40e7ec <z_spin_unlock_valid>
  40c7fc:	72001c1f 	tst	w0, #0xff
  40c800:	54fffa80 	b.eq	40c750 <net_buf_alloc_len+0x11c>  // b.none
  40c804:	2a1803e0 	mov	w0, w24
  40c808:	97fff649 	bl	40a12c <posix_irq_unlock>
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c80c:	79408280 	ldrh	w0, [x20, #64]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c810:	39411293 	ldrb	w19, [x20, #68]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c814:	4b190000 	sub	w0, w0, w25
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c818:	9100de73 	add	x19, x19, #0x37
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
  40c81c:	f9402e81 	ldr	x1, [x20, #88]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c820:	93407c00 	sxtw	x0, w0
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c824:	927df273 	and	x19, x19, #0xfffffffffffffff8
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
  40c828:	9b000673 	madd	x19, x19, x0, x1
	return pool - TYPE_SECTION_START(net_buf_pool);
  40c82c:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40c830:	b201f3e1 	mov	x1, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
  40c834:	f9479400 	ldr	x0, [x0, #3880]
  40c838:	f2955561 	movk	x1, #0xaaab
  40c83c:	cb000280 	sub	x0, x20, x0
  40c840:	9345fc00 	asr	x0, x0, #5
  40c844:	9b017c00 	mul	x0, x0, x1
	buf->pool_id = pool_id(pool);
  40c848:	39004a60 	strb	w0, [x19, #18]
	buf->user_data_size = pool->user_data_size;
  40c84c:	39411280 	ldrb	w0, [x20, #68]
  40c850:	39004e60 	strb	w0, [x19, #19]
		goto success;
  40c854:	17ffffd3 	b	40c7a0 <net_buf_alloc_len+0x16c>
  40c858:	aa1603e0 	mov	x0, x22
  40c85c:	940007e4 	bl	40e7ec <z_spin_unlock_valid>
  40c860:	72001c1f 	tst	w0, #0xff
  40c864:	54fff760 	b.eq	40c750 <net_buf_alloc_len+0x11c>  // b.none
  40c868:	2a1803e0 	mov	w0, w24
  40c86c:	97fff630 	bl	40a12c <posix_irq_unlock>
  40c870:	aa1503e1 	mov	x1, x21
  40c874:	aa1403e0 	mov	x0, x20
  40c878:	94000b87 	bl	40f694 <z_impl_k_queue_get>
  40c87c:	aa0003f3 	mov	x19, x0
	if (!buf) {
  40c880:	b5fff900 	cbnz	x0, 40c7a0 <net_buf_alloc_len+0x16c>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
  40c884:	aa1303e0 	mov	x0, x19
  40c888:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c88c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c890:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c894:	f94023f9 	ldr	x25, [sp, #64]
  40c898:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40c89c:	d65f03c0 	ret
		NET_BUF_ASSERT(req_size <= size);
  40c8a0:	f9402fe0 	ldr	x0, [sp, #88]
  40c8a4:	eb00029f 	cmp	x20, x0
  40c8a8:	54000269 	b.ls	40c8f4 <net_buf_alloc_len+0x2c0>  // b.plast
  40c8ac:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40c8b0:	9137ca73 	add	x19, x19, #0xdf2
  40c8b4:	aa1303e2 	mov	x2, x19
  40c8b8:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40c8bc:	913b3021 	add	x1, x1, #0xecc
  40c8c0:	52802b23 	mov	w3, #0x159                 	// #345
  40c8c4:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c8c8:	9123f800 	add	x0, x0, #0x8fe
  40c8cc:	97ffed10 	bl	407d0c <assert_print>
  40c8d0:	b0000040 	adrp	x0, 415000 <random_data+0xb30>
  40c8d4:	913b7400 	add	x0, x0, #0xedd
  40c8d8:	97ffed0d 	bl	407d0c <assert_print>
  40c8dc:	aa1303e0 	mov	x0, x19
  40c8e0:	52802b21 	mov	w1, #0x159                 	// #345
  40c8e4:	97ffed34 	bl	407db4 <assert_post_action>
  40c8e8:	52802b22 	mov	w2, #0x159                 	// #345
  40c8ec:	17ffff6b 	b	40c698 <net_buf_alloc_len+0x64>
		buf->__buf = NULL;
  40c8f0:	f900167f 	str	xzr, [x19, #40]
	buf->ref   = 1U;
  40c8f4:	52800020 	mov	w0, #0x1                   	// #1
  40c8f8:	79002260 	strh	w0, [x19, #16]
	buf->size  = size;
  40c8fc:	f9402fe0 	ldr	x0, [sp, #88]
	buf->frags = NULL;
  40c900:	f900067f 	str	xzr, [x19, #8]
	buf->size  = size;
  40c904:	79004660 	strh	w0, [x19, #34]
	net_buf_reset(buf);
  40c908:	aa1303e0 	mov	x0, x19
  40c90c:	97ffff1e 	bl	40c584 <net_buf_reset>
	return buf;
  40c910:	17ffffdd 	b	40c884 <net_buf_alloc_len+0x250>

000000000040c914 <net_buf_alloc_fixed>:
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40c914:	f9402802 	ldr	x2, [x0, #80]

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
  40c918:	f9400443 	ldr	x3, [x2, #8]
  40c91c:	aa0103e2 	mov	x2, x1
  40c920:	f9400061 	ldr	x1, [x3]
  40c924:	17ffff44 	b	40c634 <net_buf_alloc_len>

000000000040c928 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
  40c928:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c92c:	910003fd 	mov	x29, sp
  40c930:	a90153f3 	stp	x19, x20, [sp, #16]
  40c934:	f90013f5 	str	x21, [sp, #32]
	__ASSERT_NO_MSG(buf);
  40c938:	b5000240 	cbnz	x0, 40c980 <net_buf_unref+0x58>
  40c93c:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40c940:	9137ca73 	add	x19, x19, #0xdf2
  40c944:	aa1303e2 	mov	x2, x19
  40c948:	52803ba3 	mov	w3, #0x1dd                 	// #477
  40c94c:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40c950:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c954:	913b9021 	add	x1, x1, #0xee4
  40c958:	9123f800 	add	x0, x0, #0x8fe
  40c95c:	97ffecec 	bl	407d0c <assert_print>
  40c960:	aa1303e0 	mov	x0, x19
  40c964:	52803ba1 	mov	w1, #0x1dd                 	// #477
  40c968:	97ffed13 	bl	407db4 <assert_post_action>
  40c96c:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40c970:	aa1303e1 	mov	x1, x19
  40c974:	9124f000 	add	x0, x0, #0x93c
  40c978:	52803ba2 	mov	w2, #0x1dd                 	// #477
  40c97c:	97fff700 	bl	40a57c <posix_print_error_and_exit>
  40c980:	aa0003f4 	mov	x20, x0
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
  40c984:	39404280 	ldrb	w0, [x20, #16]
  40c988:	aa1403f3 	mov	x19, x20
		struct net_buf *frags = buf->frags;
  40c98c:	f9400694 	ldr	x20, [x20, #8]
		if (--buf->ref > 0) {
  40c990:	51000400 	sub	w0, w0, #0x1
  40c994:	12001c00 	and	w0, w0, #0xff
  40c998:	39004260 	strb	w0, [x19, #16]
  40c99c:	350002e0 	cbnz	w0, 40c9f8 <net_buf_unref+0xd0>
			return;
		}

		if (buf->__buf) {
  40c9a0:	f9401675 	ldr	x21, [x19, #40]
  40c9a4:	b4000195 	cbz	x21, 40c9d4 <net_buf_unref+0xac>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c9a8:	39404a60 	ldrb	w0, [x19, #18]
  40c9ac:	97fffe85 	bl	40c3c0 <net_buf_pool_get>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
  40c9b0:	39404661 	ldrb	w1, [x19, #17]
  40c9b4:	370000e1 	tbnz	w1, #0, 40c9d0 <net_buf_unref+0xa8>
	pool->alloc->cb->unref(buf, data);
  40c9b8:	f9402800 	ldr	x0, [x0, #80]
  40c9bc:	aa1503e1 	mov	x1, x21
  40c9c0:	f9400000 	ldr	x0, [x0]
  40c9c4:	f9400802 	ldr	x2, [x0, #16]
  40c9c8:	aa1303e0 	mov	x0, x19
  40c9cc:	d63f0040 	blr	x2
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
  40c9d0:	f900167f 	str	xzr, [x19, #40]
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
  40c9d4:	39404a60 	ldrb	w0, [x19, #18]
		buf->frags = NULL;
  40c9d8:	f900067f 	str	xzr, [x19, #8]
		buf->data = NULL;
  40c9dc:	f9000e7f 	str	xzr, [x19, #24]
		pool = net_buf_pool_get(buf->pool_id);
  40c9e0:	97fffe78 	bl	40c3c0 <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
  40c9e4:	f9402401 	ldr	x1, [x0, #72]
			pool->destroy(buf);
  40c9e8:	aa1303e0 	mov	x0, x19
		if (pool->destroy) {
  40c9ec:	b40000e1 	cbz	x1, 40ca08 <net_buf_unref+0xe0>
			pool->destroy(buf);
  40c9f0:	d63f0020 	blr	x1
	while (buf) {
  40c9f4:	b5fffc94 	cbnz	x20, 40c984 <net_buf_unref+0x5c>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
  40c9f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c9fc:	f94013f5 	ldr	x21, [sp, #32]
  40ca00:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40ca04:	d65f03c0 	ret
			net_buf_destroy(buf);
  40ca08:	97fffeae 	bl	40c4c0 <net_buf_destroy>
  40ca0c:	17fffffa 	b	40c9f4 <net_buf_unref+0xcc>

000000000040ca10 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
  40ca10:	f9400001 	ldr	x1, [x0]
  40ca14:	f9400800 	ldr	x0, [x0, #16]
}
  40ca18:	cb000020 	sub	x0, x1, x0
  40ca1c:	d65f03c0 	ret

000000000040ca20 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
  40ca20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40ca24:	910003fd 	mov	x29, sp
  40ca28:	a90153f3 	stp	x19, x20, [sp, #16]
  40ca2c:	aa0003f3 	mov	x19, x0
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
  40ca30:	79401414 	ldrh	w20, [x0, #10]
  40ca34:	97fffff7 	bl	40ca10 <net_buf_simple_headroom>
  40ca38:	79401261 	ldrh	w1, [x19, #8]
  40ca3c:	cb010294 	sub	x20, x20, x1
}
  40ca40:	cb000280 	sub	x0, x20, x0
  40ca44:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ca48:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40ca4c:	d65f03c0 	ret

000000000040ca50 <net_buf_simple_add>:
{
  40ca50:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ca54:	910003fd 	mov	x29, sp
  40ca58:	a90153f3 	stp	x19, x20, [sp, #16]
  40ca5c:	aa0103f4 	mov	x20, x1
  40ca60:	aa0003f3 	mov	x19, x0
  40ca64:	f90013f5 	str	x21, [sp, #32]
	return buf->data + buf->len;
  40ca68:	79401001 	ldrh	w1, [x0, #8]
  40ca6c:	f9400015 	ldr	x21, [x0]
  40ca70:	8b0102b5 	add	x21, x21, x1
	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
  40ca74:	97ffffeb 	bl	40ca20 <net_buf_simple_tailroom>
  40ca78:	eb14001f 	cmp	x0, x20
  40ca7c:	54000242 	b.cs	40cac4 <net_buf_simple_add+0x74>  // b.hs, b.nlast
  40ca80:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40ca84:	913ba273 	add	x19, x19, #0xee8
  40ca88:	aa1303e2 	mov	x2, x19
  40ca8c:	528007c3 	mov	w3, #0x3e                  	// #62
  40ca90:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40ca94:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40ca98:	913c8821 	add	x1, x1, #0xf22
  40ca9c:	9123f800 	add	x0, x0, #0x8fe
  40caa0:	97ffec9b 	bl	407d0c <assert_print>
  40caa4:	aa1303e0 	mov	x0, x19
  40caa8:	528007c1 	mov	w1, #0x3e                  	// #62
  40caac:	97ffecc2 	bl	407db4 <assert_post_action>
  40cab0:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40cab4:	aa1303e1 	mov	x1, x19
  40cab8:	9124f000 	add	x0, x0, #0x93c
  40cabc:	528007c2 	mov	w2, #0x3e                  	// #62
  40cac0:	97fff6af 	bl	40a57c <posix_print_error_and_exit>
	buf->len += len;
  40cac4:	79401260 	ldrh	w0, [x19, #8]
  40cac8:	0b140000 	add	w0, w0, w20
  40cacc:	79001260 	strh	w0, [x19, #8]
}
  40cad0:	aa1503e0 	mov	x0, x21
  40cad4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cad8:	f94013f5 	ldr	x21, [sp, #32]
  40cadc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40cae0:	d65f03c0 	ret

000000000040cae4 <net_buf_simple_add_mem>:
{
  40cae4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40cae8:	910003fd 	mov	x29, sp
  40caec:	a90153f3 	stp	x19, x20, [sp, #16]
  40caf0:	aa0103f4 	mov	x20, x1
  40caf4:	aa0203f3 	mov	x19, x2
	return memcpy(net_buf_simple_add(buf, len), mem, len);
  40caf8:	aa0203e1 	mov	x1, x2
  40cafc:	97ffffd5 	bl	40ca50 <net_buf_simple_add>
  40cb00:	aa1303e2 	mov	x2, x19
  40cb04:	aa1403e1 	mov	x1, x20
}
  40cb08:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cb0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40cb10:	17ffd198 	b	401170 <memcpy@plt>

000000000040cb14 <can_tx_default_cb>:
	struct k_sem done;
	int status;
};

static void can_tx_default_cb(const struct device *dev, int error, void *user_data)
{
  40cb14:	aa0203e0 	mov	x0, x2
	struct can_tx_default_cb_ctx *ctx = user_data;

	ctx->status = error;
  40cb18:	b9002841 	str	w1, [x2, #40]
	z_impl_k_sem_give(sem);
  40cb1c:	14000b45 	b	40f830 <z_impl_k_sem_give>

000000000040cb20 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40cb20:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40cb24:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40cb28:	910003fd 	mov	x29, sp
  40cb2c:	f9476800 	ldr	x0, [x0, #3792]
  40cb30:	3d8023e0 	str	q0, [sp, #128]
  40cb34:	3d8027e1 	str	q1, [sp, #144]
  40cb38:	3d802be2 	str	q2, [sp, #160]
  40cb3c:	3d802fe3 	str	q3, [sp, #176]
  40cb40:	3d8033e4 	str	q4, [sp, #192]
  40cb44:	3d8037e5 	str	q5, [sp, #208]
  40cb48:	3d803be6 	str	q6, [sp, #224]
  40cb4c:	3d803fe7 	str	q7, [sp, #240]
  40cb50:	f90087e7 	str	x7, [sp, #264]
  40cb54:	f9400002 	ldr	x2, [x0]
  40cb58:	f9003fe2 	str	x2, [sp, #120]
  40cb5c:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40cb60:	910443e0 	add	x0, sp, #0x110
  40cb64:	a90383e0 	stp	x0, x0, [sp, #56]
  40cb68:	910403e0 	add	x0, sp, #0x100
  40cb6c:	9100e3e2 	add	x2, sp, #0x38
  40cb70:	f90027e0 	str	x0, [sp, #72]
  40cb74:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40cb78:	b90053e0 	str	w0, [sp, #80]
  40cb7c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40cb80:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40cb84:	910163e0 	add	x0, sp, #0x58
  40cb88:	ad400440 	ldp	q0, q1, [x2]
  40cb8c:	ad000400 	stp	q0, q1, [x0]
  40cb90:	ad400400 	ldp	q0, q1, [x0]
  40cb94:	910043e7 	add	x7, sp, #0x10
  40cb98:	52800022 	mov	w2, #0x1                   	// #1
  40cb9c:	52800000 	mov	w0, #0x0                   	// #0
  40cba0:	b0000046 	adrp	x6, 415000 <random_data+0xb30>
  40cba4:	52800005 	mov	w5, #0x0                   	// #0
  40cba8:	913d54c6 	add	x6, x6, #0xf55
  40cbac:	d2800004 	mov	x4, #0x0                   	// #0
  40cbb0:	d2800003 	mov	x3, #0x0                   	// #0
  40cbb4:	ad0004e0 	stp	q0, q1, [x7]
  40cbb8:	97ffee35 	bl	40848c <z_impl_z_log_msg_runtime_vcreate>
}
  40cbbc:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40cbc0:	f9476800 	ldr	x0, [x0, #3792]
  40cbc4:	f9403fe2 	ldr	x2, [sp, #120]
  40cbc8:	f9400001 	ldr	x1, [x0]
  40cbcc:	eb010042 	subs	x2, x2, x1
  40cbd0:	d2800001 	mov	x1, #0x0                   	// #0
  40cbd4:	54000040 	b.eq	40cbdc <z_log_msg_runtime_create.constprop.0+0xbc>  // b.none
  40cbd8:	97ffd1d2 	bl	401320 <__stack_chk_fail@plt>
  40cbdc:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40cbe0:	d65f03c0 	ret

000000000040cbe4 <can_msgq_put>:

	return api->send(dev, frame, timeout, callback, user_data);
}

static void can_msgq_put(const struct device *dev, struct can_frame *frame, void *user_data)
{
  40cbe4:	d100c3ff 	sub	sp, sp, #0x30
  40cbe8:	a9017bfd 	stp	x29, x30, [sp, #16]
  40cbec:	910043fd 	add	x29, sp, #0x10
  40cbf0:	a90253f3 	stp	x19, x20, [sp, #32]
	struct k_msgq *msgq = (struct k_msgq *)user_data;
	int ret;

	ARG_UNUSED(dev);

	__ASSERT_NO_MSG(msgq);
  40cbf4:	b5000242 	cbnz	x2, 40cc3c <can_msgq_put+0x58>
  40cbf8:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40cbfc:	913de273 	add	x19, x19, #0xf78
  40cc00:	aa1303e2 	mov	x2, x19
  40cc04:	52800823 	mov	w3, #0x41                  	// #65
  40cc08:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40cc0c:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40cc10:	913e9021 	add	x1, x1, #0xfa4
  40cc14:	9123f800 	add	x0, x0, #0x8fe
  40cc18:	97ffec3d 	bl	407d0c <assert_print>
  40cc1c:	aa1303e0 	mov	x0, x19
  40cc20:	52800821 	mov	w1, #0x41                  	// #65
  40cc24:	97ffec64 	bl	407db4 <assert_post_action>
  40cc28:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40cc2c:	aa1303e1 	mov	x1, x19
  40cc30:	9124f000 	add	x0, x0, #0x93c
  40cc34:	52800822 	mov	w2, #0x41                  	// #65
  40cc38:	97fff651 	bl	40a57c <posix_print_error_and_exit>
  40cc3c:	aa0103f4 	mov	x20, x1
  40cc40:	aa0203f3 	mov	x19, x2
	return z_impl_k_msgq_put(msgq, data, timeout);
  40cc44:	d2800002 	mov	x2, #0x0                   	// #0
  40cc48:	aa1303e0 	mov	x0, x19
  40cc4c:	9400073a 	bl	40e934 <z_impl_k_msgq_put>

	ret = k_msgq_put(msgq, frame, K_NO_WAIT);
	if (ret) {
  40cc50:	340001e0 	cbz	w0, 40cc8c <can_msgq_put+0xa8>
		LOG_ERR("Msgq %p overflowed. Frame ID: 0x%x", msgq, frame->id);
  40cc54:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40cc58:	b9400280 	ldr	w0, [x20]
  40cc5c:	b0000046 	adrp	x6, 415000 <random_data+0xb30>
  40cc60:	aa1303e7 	mov	x7, x19
  40cc64:	f9473821 	ldr	x1, [x1, #3696]
  40cc68:	d3407000 	ubfx	x0, x0, #0, #29
  40cc6c:	b90003e0 	str	w0, [sp]
  40cc70:	913d54c6 	add	x6, x6, #0xf55
  40cc74:	52800005 	mov	w5, #0x0                   	// #0
  40cc78:	d2800004 	mov	x4, #0x0                   	// #0
  40cc7c:	d2800003 	mov	x3, #0x0                   	// #0
  40cc80:	52800022 	mov	w2, #0x1                   	// #1
  40cc84:	52800000 	mov	w0, #0x0                   	// #0
  40cc88:	97ffffa6 	bl	40cb20 <z_log_msg_runtime_create.constprop.0>
	}
}
  40cc8c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40cc90:	a94253f3 	ldp	x19, x20, [sp, #32]
  40cc94:	9100c3ff 	add	sp, sp, #0x30
  40cc98:	d65f03c0 	ret

000000000040cc9c <z_impl_can_send>:
{
  40cc9c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40cca0:	f00000e5 	adrp	x5, 42b000 <__FRAME_END__+0xfd74>
  40cca4:	910003fd 	mov	x29, sp
  40cca8:	f94768a5 	ldr	x5, [x5, #3792]
  40ccac:	a90153f3 	stp	x19, x20, [sp, #16]
  40ccb0:	f00000f3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  40ccb4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ccb8:	a90363f7 	stp	x23, x24, [sp, #48]
  40ccbc:	f94000a6 	ldr	x6, [x5]
  40ccc0:	f9003fe6 	str	x6, [sp, #120]
  40ccc4:	d2800006 	mov	x6, #0x0                   	// #0
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  40ccc8:	f9400818 	ldr	x24, [x0, #16]
	if (callback == NULL) {
  40cccc:	b5000423 	cbnz	x3, 40cd50 <z_impl_can_send+0xb4>
  40ccd0:	aa0003f4 	mov	x20, x0
  40ccd4:	aa0103f6 	mov	x22, x1
  40ccd8:	aa0203f7 	mov	x23, x2
	return z_impl_k_sem_init(sem, initial_count, limit);
  40ccdc:	910123f5 	add	x21, sp, #0x48
  40cce0:	52800022 	mov	w2, #0x1                   	// #1
  40cce4:	52800001 	mov	w1, #0x0                   	// #0
  40cce8:	aa1503e0 	mov	x0, x21
  40ccec:	94000ac6 	bl	40f804 <z_impl_k_sem_init>
		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
  40ccf0:	f9401705 	ldr	x5, [x24, #40]
  40ccf4:	90000003 	adrp	x3, 40c000 <_posix_zephyr_main+0x28c>
  40ccf8:	aa1503e4 	mov	x4, x21
  40ccfc:	912c5063 	add	x3, x3, #0xb14
  40cd00:	aa1703e2 	mov	x2, x23
  40cd04:	aa1603e1 	mov	x1, x22
  40cd08:	aa1403e0 	mov	x0, x20
  40cd0c:	d63f00a0 	blr	x5
		if (err != 0) {
  40cd10:	350000a0 	cbnz	w0, 40cd24 <z_impl_can_send+0x88>
	return z_impl_k_sem_take(sem, timeout);
  40cd14:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40cd18:	aa1503e0 	mov	x0, x21
  40cd1c:	94000afc 	bl	40f90c <z_impl_k_sem_take>
		return ctx.status;
  40cd20:	b94073e0 	ldr	w0, [sp, #112]
}
  40cd24:	f9476a73 	ldr	x19, [x19, #3792]
  40cd28:	f9403fe1 	ldr	x1, [sp, #120]
  40cd2c:	f9400262 	ldr	x2, [x19]
  40cd30:	eb020021 	subs	x1, x1, x2
  40cd34:	d2800002 	mov	x2, #0x0                   	// #0
  40cd38:	54000181 	b.ne	40cd68 <z_impl_can_send+0xcc>  // b.any
  40cd3c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cd40:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40cd44:	a94363f7 	ldp	x23, x24, [sp, #48]
  40cd48:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40cd4c:	d65f03c0 	ret
	return api->send(dev, frame, timeout, callback, user_data);
  40cd50:	f9476a73 	ldr	x19, [x19, #3792]
  40cd54:	f9403fe5 	ldr	x5, [sp, #120]
  40cd58:	f9400266 	ldr	x6, [x19]
  40cd5c:	eb0600a5 	subs	x5, x5, x6
  40cd60:	d2800006 	mov	x6, #0x0                   	// #0
  40cd64:	54000040 	b.eq	40cd6c <z_impl_can_send+0xd0>  // b.none
}
  40cd68:	97ffd16e 	bl	401320 <__stack_chk_fail@plt>
  40cd6c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cd70:	a9425bf5 	ldp	x21, x22, [sp, #32]
	return api->send(dev, frame, timeout, callback, user_data);
  40cd74:	f9401705 	ldr	x5, [x24, #40]
}
  40cd78:	a94363f7 	ldp	x23, x24, [sp, #48]
	return api->send(dev, frame, timeout, callback, user_data);
  40cd7c:	aa0503f0 	mov	x16, x5
}
  40cd80:	a8c87bfd 	ldp	x29, x30, [sp], #128
	return api->send(dev, frame, timeout, callback, user_data);
  40cd84:	d61f0200 	br	x16

000000000040cd88 <z_impl_can_add_rx_filter_msgq>:
int z_impl_can_add_rx_filter_msgq(const struct device *dev, struct k_msgq *msgq,
				  const struct can_filter *filter)
{
	const struct can_driver_api *api = dev->api;

	return api->add_rx_filter(dev, can_msgq_put, msgq, filter);
  40cd88:	f9400803 	ldr	x3, [x0, #16]
  40cd8c:	f9401864 	ldr	x4, [x3, #48]
  40cd90:	aa0203e3 	mov	x3, x2
  40cd94:	aa0103e2 	mov	x2, x1
  40cd98:	90000001 	adrp	x1, 40c000 <_posix_zephyr_main+0x28c>
  40cd9c:	aa0403f0 	mov	x16, x4
  40cda0:	912f9021 	add	x1, x1, #0xbe4
  40cda4:	d61f0200 	br	x16

000000000040cda8 <can_loopback_get_capabilities>:

static int can_loopback_get_capabilities(const struct device *dev, can_mode_t *cap)
{
	ARG_UNUSED(dev);

	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK;
  40cda8:	52800020 	mov	w0, #0x1                   	// #1
  40cdac:	b9000020 	str	w0, [x1]
#if CONFIG_CAN_FD_MODE
	*cap |= CAN_MODE_FD;
#endif /* CONFIG_CAN_FD_MODE */

	return 0;
}
  40cdb0:	52800000 	mov	w0, #0x0                   	// #0
  40cdb4:	d65f03c0 	ret

000000000040cdb8 <can_loopback_start>:

static int can_loopback_start(const struct device *dev)
{
	struct can_loopback_data *data = dev->data;
  40cdb8:	f9401000 	ldr	x0, [x0, #32]

	if (data->started) {
  40cdbc:	39552001 	ldrb	w1, [x0, #1352]
  40cdc0:	350000a1 	cbnz	w1, 40cdd4 <can_loopback_start+0x1c>
		return -EALREADY;
	}

	data->started = true;
  40cdc4:	52800021 	mov	w1, #0x1                   	// #1
  40cdc8:	39152001 	strb	w1, [x0, #1352]

	return 0;
  40cdcc:	52800000 	mov	w0, #0x0                   	// #0
}
  40cdd0:	d65f03c0 	ret
		return -EALREADY;
  40cdd4:	12800e20 	mov	w0, #0xffffff8e            	// #-114
  40cdd8:	17fffffe 	b	40cdd0 <can_loopback_start+0x18>

000000000040cddc <can_loopback_set_timing>:
{
	struct can_loopback_data *data = dev->data;

	ARG_UNUSED(timing);

	if (data->started) {
  40cddc:	f9401000 	ldr	x0, [x0, #32]
  40cde0:	39552000 	ldrb	w0, [x0, #1352]
		return -EBUSY;
  40cde4:	7100001f 	cmp	w0, #0x0
	}

	return 0;
}
  40cde8:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40cdec:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40cdf0:	d65f03c0 	ret

000000000040cdf4 <can_loopback_get_state>:
static int can_loopback_get_state(const struct device *dev, enum can_state *state,
				  struct can_bus_err_cnt *err_cnt)
{
	struct can_loopback_data *data = dev->data;

	if (state != NULL) {
  40cdf4:	b40000e1 	cbz	x1, 40ce10 <can_loopback_get_state+0x1c>
		if (data->started) {
  40cdf8:	f9401000 	ldr	x0, [x0, #32]
  40cdfc:	39552000 	ldrb	w0, [x0, #1352]
			*state = CAN_STATE_ERROR_ACTIVE;
  40ce00:	7100001f 	cmp	w0, #0x0
  40ce04:	52800080 	mov	w0, #0x4                   	// #4
  40ce08:	1a8013e0 	csel	w0, wzr, w0, ne  // ne = any
  40ce0c:	b9000020 	str	w0, [x1]
		} else {
			*state = CAN_STATE_STOPPED;
		}
	}

	if (err_cnt) {
  40ce10:	b4000042 	cbz	x2, 40ce18 <can_loopback_get_state+0x24>
		err_cnt->tx_err_cnt = 0;
  40ce14:	7900005f 	strh	wzr, [x2]
		err_cnt->rx_err_cnt = 0;
	}

	return 0;
}
  40ce18:	52800000 	mov	w0, #0x0                   	// #0
  40ce1c:	d65f03c0 	ret

000000000040ce20 <can_loopback_set_state_change_callback>:
						   void *user_data)
{
	ARG_UNUSED(dev);
	ARG_UNUSED(cb);
	ARG_UNUSED(user_data);
}
  40ce20:	d65f03c0 	ret

000000000040ce24 <can_loopback_get_core_clock>:

static int can_loopback_get_core_clock(const struct device *dev, uint32_t *rate)
{
	/* Return 16MHz as an realistic value for the testcases */
	*rate = 16000000;
  40ce24:	52848000 	mov	w0, #0x2400                	// #9216
  40ce28:	72a01e80 	movk	w0, #0xf4, lsl #16
  40ce2c:	b9000020 	str	w0, [x1]
	return 0;
}
  40ce30:	52800000 	mov	w0, #0x0                   	// #0
  40ce34:	d65f03c0 	ret

000000000040ce38 <can_loopback_get_max_filters>:
static int can_loopback_get_max_filters(const struct device *dev, bool ide)
{
	ARG_UNUSED(ide);

	return CONFIG_CAN_MAX_FILTER;
}
  40ce38:	52800200 	mov	w0, #0x10                  	// #16
  40ce3c:	d65f03c0 	ret

000000000040ce40 <can_loopback_stop>:
	struct can_loopback_data *data = dev->data;
  40ce40:	f9401000 	ldr	x0, [x0, #32]
	if (!data->started) {
  40ce44:	39552001 	ldrb	w1, [x0, #1352]
  40ce48:	34000121 	cbz	w1, 40ce6c <can_loopback_stop+0x2c>
{
  40ce4c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40ce50:	910003fd 	mov	x29, sp
	data->started = false;
  40ce54:	3915201f 	strb	wzr, [x0, #1352]
	z_impl_k_msgq_purge(msgq);
  40ce58:	91088000 	add	x0, x0, #0x220
  40ce5c:	94000809 	bl	40ee80 <z_impl_k_msgq_purge>
	return 0;
  40ce60:	52800000 	mov	w0, #0x0                   	// #0
}
  40ce64:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40ce68:	d65f03c0 	ret
		return -EALREADY;
  40ce6c:	12800e20 	mov	w0, #0xffffff8e            	// #-114
}
  40ce70:	d65f03c0 	ret

000000000040ce74 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40ce74:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40ce78:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40ce7c:	12001c42 	and	w2, w2, #0xff
  40ce80:	910003fd 	mov	x29, sp
  40ce84:	f9476800 	ldr	x0, [x0, #3792]
  40ce88:	3d8023e0 	str	q0, [sp, #128]
  40ce8c:	3d8027e1 	str	q1, [sp, #144]
  40ce90:	3d802be2 	str	q2, [sp, #160]
  40ce94:	3d802fe3 	str	q3, [sp, #176]
  40ce98:	3d8033e4 	str	q4, [sp, #192]
  40ce9c:	3d8037e5 	str	q5, [sp, #208]
  40cea0:	3d803be6 	str	q6, [sp, #224]
  40cea4:	3d803fe7 	str	q7, [sp, #240]
  40cea8:	f90087e7 	str	x7, [sp, #264]
  40ceac:	f9400003 	ldr	x3, [x0]
  40ceb0:	f9003fe3 	str	x3, [sp, #120]
  40ceb4:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(ap, fmt);
  40ceb8:	910443e0 	add	x0, sp, #0x110
  40cebc:	a90383e0 	stp	x0, x0, [sp, #56]
  40cec0:	910403e0 	add	x0, sp, #0x100
  40cec4:	9100e3e3 	add	x3, sp, #0x38
  40cec8:	f90027e0 	str	x0, [sp, #72]
  40cecc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40ced0:	b90053e0 	str	w0, [sp, #80]
  40ced4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40ced8:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40cedc:	910163e0 	add	x0, sp, #0x58
  40cee0:	ad400460 	ldp	q0, q1, [x3]
  40cee4:	ad000400 	stp	q0, q1, [x0]
  40cee8:	ad400400 	ldp	q0, q1, [x0]
  40ceec:	910043e7 	add	x7, sp, #0x10
  40cef0:	52800000 	mov	w0, #0x0                   	// #0
  40cef4:	52800005 	mov	w5, #0x0                   	// #0
  40cef8:	d2800004 	mov	x4, #0x0                   	// #0
  40cefc:	d2800003 	mov	x3, #0x0                   	// #0
  40cf00:	ad0004e0 	stp	q0, q1, [x7]
  40cf04:	97ffed62 	bl	40848c <z_impl_z_log_msg_runtime_vcreate>
}
  40cf08:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40cf0c:	f9476800 	ldr	x0, [x0, #3792]
  40cf10:	f9403fe2 	ldr	x2, [sp, #120]
  40cf14:	f9400001 	ldr	x1, [x0]
  40cf18:	eb010042 	subs	x2, x2, x1
  40cf1c:	d2800001 	mov	x1, #0x0                   	// #0
  40cf20:	54000040 	b.eq	40cf28 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40cf24:	97ffd0ff 	bl	401320 <__stack_chk_fail@plt>
  40cf28:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40cf2c:	d65f03c0 	ret

000000000040cf30 <can_loopback_send>:
{
  40cf30:	d10183ff 	sub	sp, sp, #0x60
  40cf34:	f00000e5 	adrp	x5, 42b000 <__FRAME_END__+0xfd74>
  40cf38:	a9017bfd 	stp	x29, x30, [sp, #16]
  40cf3c:	910043fd 	add	x29, sp, #0x10
  40cf40:	f94768a5 	ldr	x5, [x5, #3792]
  40cf44:	f90013f3 	str	x19, [sp, #32]
  40cf48:	f94000a6 	ldr	x6, [x5]
  40cf4c:	f9002fe6 	str	x6, [sp, #88]
  40cf50:	d2800006 	mov	x6, #0x0                   	// #0
	struct can_loopback_data *data = dev->data;
  40cf54:	f9401000 	ldr	x0, [x0, #32]
	__ASSERT_NO_MSG(callback != NULL);
  40cf58:	b5000243 	cbnz	x3, 40cfa0 <can_loopback_send+0x70>
  40cf5c:	b0000053 	adrp	x19, 415000 <random_data+0xb30>
  40cf60:	913ed273 	add	x19, x19, #0xfb4
  40cf64:	aa1303e2 	mov	x2, x19
  40cf68:	52800d83 	mov	w3, #0x6c                  	// #108
  40cf6c:	b0000041 	adrp	x1, 415000 <random_data+0xb30>
  40cf70:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40cf74:	913f8821 	add	x1, x1, #0xfe2
  40cf78:	9123f800 	add	x0, x0, #0x8fe
  40cf7c:	97ffeb64 	bl	407d0c <assert_print>
  40cf80:	aa1303e0 	mov	x0, x19
  40cf84:	52800d81 	mov	w1, #0x6c                  	// #108
  40cf88:	97ffeb8b 	bl	407db4 <assert_post_action>
  40cf8c:	90000040 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40cf90:	aa1303e1 	mov	x1, x19
  40cf94:	9124f000 	add	x0, x0, #0x93c
  40cf98:	52800d82 	mov	w2, #0x6c                  	// #108
  40cf9c:	97fff578 	bl	40a57c <posix_print_error_and_exit>
	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0) {
  40cfa0:	39401425 	ldrb	w5, [x1, #5]
  40cfa4:	39401427 	ldrb	w7, [x1, #5]
  40cfa8:	f27e14bf 	tst	x5, #0xfc
  40cfac:	54000280 	b.eq	40cffc <can_loopback_send+0xcc>  // b.none
		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
  40cfb0:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40cfb4:	52800000 	mov	w0, #0x0                   	// #0
  40cfb8:	b0000046 	adrp	x6, 415000 <random_data+0xb30>
  40cfbc:	52800005 	mov	w5, #0x0                   	// #0
  40cfc0:	f9474c21 	ldr	x1, [x1, #3736]
  40cfc4:	913fe8c6 	add	x6, x6, #0xffa
  40cfc8:	d2800004 	mov	x4, #0x0                   	// #0
  40cfcc:	d2800003 	mov	x3, #0x0                   	// #0
  40cfd0:	52800022 	mov	w2, #0x1                   	// #1
  40cfd4:	97ffffa8 	bl	40ce74 <z_log_msg_runtime_create.constprop.0>
		return -ENOTSUP;
  40cfd8:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40cfdc:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40cfe0:	f9476821 	ldr	x1, [x1, #3792]
  40cfe4:	f9402fe3 	ldr	x3, [sp, #88]
  40cfe8:	f9400022 	ldr	x2, [x1]
  40cfec:	eb020063 	subs	x3, x3, x2
  40cff0:	d2800002 	mov	x2, #0x0                   	// #0
  40cff4:	54000420 	b.eq	40d078 <can_loopback_send+0x148>  // b.none
  40cff8:	97ffd0ca 	bl	401320 <__stack_chk_fail@plt>
	if (frame->dlc > max_dlc) {
  40cffc:	39401027 	ldrb	w7, [x1, #4]
  40d000:	710020ff 	cmp	w7, #0x8
  40d004:	540001e9 	b.ls	40d040 <can_loopback_send+0x110>  // b.plast
		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, max_dlc);
  40d008:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40d00c:	52800100 	mov	w0, #0x8                   	// #8
  40d010:	b90003e0 	str	w0, [sp]
  40d014:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d018:	f9474c21 	ldr	x1, [x1, #3736]
  40d01c:	52800000 	mov	w0, #0x0                   	// #0
  40d020:	910074c6 	add	x6, x6, #0x1d
  40d024:	52800005 	mov	w5, #0x0                   	// #0
  40d028:	d2800004 	mov	x4, #0x0                   	// #0
  40d02c:	d2800003 	mov	x3, #0x0                   	// #0
  40d030:	52800022 	mov	w2, #0x1                   	// #1
  40d034:	97ffff90 	bl	40ce74 <z_log_msg_runtime_create.constprop.0>
		return -EINVAL;
  40d038:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40d03c:	17ffffe8 	b	40cfdc <can_loopback_send+0xac>
	if (!data->started) {
  40d040:	39552005 	ldrb	w5, [x0, #1352]
  40d044:	34000165 	cbz	w5, 40d070 <can_loopback_send+0x140>
	loopback_frame.frame = *frame;
  40d048:	a9401c26 	ldp	x6, x7, [x1]
  40d04c:	a9039fe6 	stp	x6, x7, [sp, #56]
	loopback_frame.cb_arg = user_data;
  40d050:	a90493e3 	stp	x3, x4, [sp, #72]
	return z_impl_k_msgq_put(msgq, data, timeout);
  40d054:	9100e3e1 	add	x1, sp, #0x38
  40d058:	91088000 	add	x0, x0, #0x220
  40d05c:	94000636 	bl	40e934 <z_impl_k_msgq_put>
		return -EAGAIN;
  40d060:	7100001f 	cmp	w0, #0x0
  40d064:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40d068:	1a80a3e0 	csel	w0, wzr, w0, ge  // ge = tcont
  40d06c:	17ffffdc 	b	40cfdc <can_loopback_send+0xac>
		return -ENETDOWN;
  40d070:	12800c60 	mov	w0, #0xffffff9c            	// #-100
  40d074:	17ffffda 	b	40cfdc <can_loopback_send+0xac>
}
  40d078:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40d07c:	f94013f3 	ldr	x19, [sp, #32]
  40d080:	910183ff 	add	sp, sp, #0x60
  40d084:	d65f03c0 	ret

000000000040d088 <can_loopback_set_mode>:
	struct can_loopback_data *data = dev->data;
  40d088:	f9401000 	ldr	x0, [x0, #32]
{
  40d08c:	2a0103e7 	mov	w7, w1
	if (data->started) {
  40d090:	39552001 	ldrb	w1, [x0, #1352]
  40d094:	350002c1 	cbnz	w1, 40d0ec <can_loopback_set_mode+0x64>
	if ((mode & ~(CAN_MODE_LOOPBACK)) != 0) {
  40d098:	f27f78ff 	tst	x7, #0xfffffffe
  40d09c:	54000200 	b.eq	40d0dc <can_loopback_set_mode+0x54>  // b.none
{
  40d0a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40d0a4:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40d0a8:	52800005 	mov	w5, #0x0                   	// #0
{
  40d0ac:	910003fd 	mov	x29, sp
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40d0b0:	f9474c21 	ldr	x1, [x1, #3736]
  40d0b4:	d2800004 	mov	x4, #0x0                   	// #0
  40d0b8:	d2800003 	mov	x3, #0x0                   	// #0
  40d0bc:	52800022 	mov	w2, #0x1                   	// #1
  40d0c0:	52800000 	mov	w0, #0x0                   	// #0
  40d0c4:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d0c8:	9100f0c6 	add	x6, x6, #0x3c
  40d0cc:	97ffff6a 	bl	40ce74 <z_log_msg_runtime_create.constprop.0>
  40d0d0:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40d0d4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d0d8:	d65f03c0 	ret
	data->loopback = (mode & CAN_MODE_LOOPBACK) != 0;
  40d0dc:	120000e7 	and	w7, w7, #0x1
  40d0e0:	39152407 	strb	w7, [x0, #1353]
	return 0;
  40d0e4:	52800000 	mov	w0, #0x0                   	// #0
  40d0e8:	d65f03c0 	ret
		return -EBUSY;
  40d0ec:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
  40d0f0:	d65f03c0 	ret

000000000040d0f4 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
  40d0f4:	1400084e 	b	40f22c <z_impl_k_mutex_unlock>

000000000040d0f8 <can_loopback_remove_rx_filter>:
{
  40d0f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40d0fc:	910003fd 	mov	x29, sp
  40d100:	a90153f3 	stp	x19, x20, [sp, #16]
  40d104:	2a0103f3 	mov	w19, w1
  40d108:	f90013f5 	str	x21, [sp, #32]
	struct can_loopback_data *data = dev->data;
  40d10c:	f9401015 	ldr	x21, [x0, #32]
	if (filter_id >= ARRAY_SIZE(data->filters)) {
  40d110:	71003c3f 	cmp	w1, #0xf
  40d114:	540001e9 	b.ls	40d150 <can_loopback_remove_rx_filter+0x58>  // b.plast
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40d118:	2a0103e7 	mov	w7, w1
  40d11c:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
}
  40d120:	a94153f3 	ldp	x19, x20, [sp, #16]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40d124:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
}
  40d128:	f94013f5 	ldr	x21, [sp, #32]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40d12c:	910154c6 	add	x6, x6, #0x55
}
  40d130:	a8c37bfd 	ldp	x29, x30, [sp], #48
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40d134:	52800005 	mov	w5, #0x0                   	// #0
  40d138:	f9474c21 	ldr	x1, [x1, #3736]
  40d13c:	d2800004 	mov	x4, #0x0                   	// #0
  40d140:	d2800003 	mov	x3, #0x0                   	// #0
  40d144:	52800022 	mov	w2, #0x1                   	// #1
  40d148:	52800000 	mov	w0, #0x0                   	// #0
  40d14c:	17ffff4a 	b	40ce74 <z_log_msg_runtime_create.constprop.0>
	k_mutex_lock(&data->mtx, K_FOREVER);
  40d150:	910802b4 	add	x20, x21, #0x200
	data->filters[filter_id].rx_cb = NULL;
  40d154:	937b7e73 	sbfiz	x19, x19, #5, #32
	return z_impl_k_mutex_lock(mutex, timeout);
  40d158:	aa1403e0 	mov	x0, x20
  40d15c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40d160:	94000787 	bl	40ef7c <z_impl_k_mutex_lock>
	k_mutex_unlock(&data->mtx);
  40d164:	aa1403e0 	mov	x0, x20
	data->filters[filter_id].rx_cb = NULL;
  40d168:	f8336abf 	str	xzr, [x21, x19]
}
  40d16c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d170:	f94013f5 	ldr	x21, [sp, #32]
  40d174:	a8c37bfd 	ldp	x29, x30, [sp], #48
	k_mutex_unlock(&data->mtx);
  40d178:	17ffffdf 	b	40d0f4 <k_mutex_unlock.isra.0>

000000000040d17c <can_loopback_init>:
	},
#endif /* CONFIG_CAN_FD_MODE */
};

static int can_loopback_init(const struct device *dev)
{
  40d17c:	d10103ff 	sub	sp, sp, #0x40
  40d180:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d184:	910043fd 	add	x29, sp, #0x10
  40d188:	a90253f3 	stp	x19, x20, [sp, #32]
  40d18c:	aa0003f4 	mov	x20, x0
	struct can_loopback_data *data = dev->data;
  40d190:	f9401013 	ldr	x19, [x0, #32]
{
  40d194:	f9001bf5 	str	x21, [sp, #48]
	k_tid_t tx_tid;

	k_mutex_init(&data->mtx);
  40d198:	91080275 	add	x21, x19, #0x200
	return z_impl_k_mutex_init(mutex);
  40d19c:	aa1503e0 	mov	x0, x21
  40d1a0:	94000772 	bl	40ef68 <z_impl_k_mutex_init>

	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d1a4:	aa1303e0 	mov	x0, x19
		data->filters[i].rx_cb = NULL;
  40d1a8:	f802041f 	str	xzr, [x0], #32
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d1ac:	eb15001f 	cmp	x0, x21
  40d1b0:	54ffffc1 	b.ne	40d1a8 <can_loopback_init+0x2c>  // b.any
	}

	k_msgq_init(&data->tx_msgq, data->msgq_buffer, sizeof(struct can_loopback_frame),
  40d1b4:	910a2261 	add	x1, x19, #0x288
  40d1b8:	91088260 	add	x0, x19, #0x220
  40d1bc:	52800203 	mov	w3, #0x10                  	// #16
  40d1c0:	d2800402 	mov	x2, #0x20                  	// #32
  40d1c4:	940005ba 	bl	40e8ac <k_msgq_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40d1c8:	b90003ff 	str	wzr, [sp]
  40d1cc:	91154261 	add	x1, x19, #0x550
  40d1d0:	f90007ff 	str	xzr, [sp, #8]
  40d1d4:	aa1403e4 	mov	x4, x20
  40d1d8:	91122260 	add	x0, x19, #0x488
  40d1dc:	52800047 	mov	w7, #0x2                   	// #2
  40d1e0:	d2800006 	mov	x6, #0x0                   	// #0
  40d1e4:	d2800005 	mov	x5, #0x0                   	// #0
  40d1e8:	90000003 	adrp	x3, 40d000 <can_loopback_send+0xd0>
  40d1ec:	d2802002 	mov	x2, #0x100                 	// #256
  40d1f0:	9109a063 	add	x3, x3, #0x268
  40d1f4:	940004e1 	bl	40e578 <z_impl_k_thread_create>
	tx_tid = k_thread_create(&data->tx_thread_data, data->tx_thread_stack,
				 K_KERNEL_STACK_SIZEOF(data->tx_thread_stack),
				 tx_thread, (void *)dev, NULL, NULL,
				 CONFIG_CAN_LOOPBACK_TX_THREAD_PRIORITY,
				 0, K_NO_WAIT);
	if (!tx_tid) {
  40d1f8:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40d1fc:	b50001e0 	cbnz	x0, 40d238 <can_loopback_init+0xbc>
		LOG_ERR("ERROR spawning tx thread");
  40d200:	f9474c21 	ldr	x1, [x1, #3736]
  40d204:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d208:	52800005 	mov	w5, #0x0                   	// #0
  40d20c:	9101c0c6 	add	x6, x6, #0x70
  40d210:	d2800004 	mov	x4, #0x0                   	// #0
  40d214:	d2800003 	mov	x3, #0x0                   	// #0
  40d218:	52800022 	mov	w2, #0x1                   	// #1
  40d21c:	97ffff16 	bl	40ce74 <z_log_msg_runtime_create.constprop.0>
		return -1;
  40d220:	12800000 	mov	w0, #0xffffffff            	// #-1
	}

	LOG_INF("Init of %s done", dev->name);

	return 0;
}
  40d224:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40d228:	a94253f3 	ldp	x19, x20, [sp, #32]
  40d22c:	f9401bf5 	ldr	x21, [sp, #48]
  40d230:	910103ff 	add	sp, sp, #0x40
  40d234:	d65f03c0 	ret
	LOG_INF("Init of %s done", dev->name);
  40d238:	f9474c21 	ldr	x1, [x1, #3736]
  40d23c:	52800000 	mov	w0, #0x0                   	// #0
  40d240:	f9400287 	ldr	x7, [x20]
  40d244:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d248:	52800005 	mov	w5, #0x0                   	// #0
  40d24c:	910224c6 	add	x6, x6, #0x89
  40d250:	d2800004 	mov	x4, #0x0                   	// #0
  40d254:	d2800003 	mov	x3, #0x0                   	// #0
  40d258:	52800062 	mov	w2, #0x3                   	// #3
  40d25c:	97ffff06 	bl	40ce74 <z_log_msg_runtime_create.constprop.0>
	return 0;
  40d260:	52800000 	mov	w0, #0x0                   	// #0
  40d264:	17fffff0 	b	40d224 <can_loopback_init+0xa8>

000000000040d268 <tx_thread>:
{
  40d268:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  40d26c:	910003fd 	mov	x29, sp
  40d270:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d274:	aa0003f5 	mov	x21, x0
  40d278:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40d27c:	a90153f3 	stp	x19, x20, [sp, #16]
  40d280:	a90363f7 	stp	x23, x24, [sp, #48]
	return z_impl_k_msgq_get(msgq, data, timeout);
  40d284:	9101a3f7 	add	x23, sp, #0x68
  40d288:	a9046bf9 	stp	x25, x26, [sp, #64]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40d28c:	910163f9 	add	x25, sp, #0x58
{
  40d290:	f9476800 	ldr	x0, [x0, #3792]
	struct can_loopback_data *data = dev->data;
  40d294:	f94012b4 	ldr	x20, [x21, #32]
{
  40d298:	f9400001 	ldr	x1, [x0]
  40d29c:	f90047e1 	str	x1, [sp, #136]
  40d2a0:	d2800001 	mov	x1, #0x0                   	// #0
		ret = k_msgq_get(&data->tx_msgq, &frame, K_FOREVER);
  40d2a4:	91088298 	add	x24, x20, #0x220
  40d2a8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  40d2ac:	aa1703e1 	mov	x1, x23
  40d2b0:	aa1803e0 	mov	x0, x24
  40d2b4:	94000646 	bl	40ebcc <z_impl_k_msgq_get>
		if (ret < 0) {
  40d2b8:	37ffff80 	tbnz	w0, #31, 40d2a8 <tx_thread+0x40>
		frame.cb(dev, 0, frame.cb_arg);
  40d2bc:	a9478be3 	ldp	x3, x2, [sp, #120]
  40d2c0:	aa1503e0 	mov	x0, x21
  40d2c4:	52800001 	mov	w1, #0x0                   	// #0
  40d2c8:	d63f0060 	blr	x3
		if (!data->loopback) {
  40d2cc:	39552680 	ldrb	w0, [x20, #1353]
  40d2d0:	34fffec0 	cbz	w0, 40d2a8 <tx_thread+0x40>
		k_mutex_lock(&data->mtx, K_FOREVER);
  40d2d4:	9108029a 	add	x26, x20, #0x200
	return z_impl_k_mutex_lock(mutex, timeout);
  40d2d8:	aa1403f3 	mov	x19, x20
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d2dc:	52800016 	mov	w22, #0x0                   	// #0
  40d2e0:	aa1a03e0 	mov	x0, x26
  40d2e4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40d2e8:	94000725 	bl	40ef7c <z_impl_k_mutex_lock>
			if (filter->rx_cb != NULL &&
  40d2ec:	f9400260 	ldr	x0, [x19]
  40d2f0:	b40000c0 	cbz	x0, 40d308 <tx_thread+0xa0>
 * @return true if the CAN frame matches the CAN filter, false otherwise
 */
static inline bool can_frame_matches_filter(const struct can_frame *frame,
					    const struct can_filter *filter)
{
	if ((frame->flags & CAN_FRAME_IDE) != 0 && (filter->flags & CAN_FILTER_IDE) == 0) {
  40d2f4:	3941b7e0 	ldrb	w0, [sp, #109]
  40d2f8:	39406261 	ldrb	w1, [x19, #24]
  40d2fc:	12000022 	and	w2, w1, #0x1
  40d300:	36000120 	tbz	w0, #0, 40d324 <tx_thread+0xbc>
  40d304:	35000122 	cbnz	w2, 40d328 <tx_thread+0xc0>
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d308:	110006d6 	add	w22, w22, #0x1
  40d30c:	91008273 	add	x19, x19, #0x20
  40d310:	710042df 	cmp	w22, #0x10
  40d314:	54fffec1 	b.ne	40d2ec <tx_thread+0x84>  // b.any
		k_mutex_unlock(&data->mtx);
  40d318:	aa1a03e0 	mov	x0, x26
  40d31c:	97ffff76 	bl	40d0f4 <k_mutex_unlock.isra.0>
  40d320:	17ffffe2 	b	40d2a8 <tx_thread+0x40>
		/* Extended (29-bit) ID frame, standard (11-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_IDE) == 0 && (filter->flags & CAN_FILTER_IDE) != 0) {
  40d324:	35ffff22 	cbnz	w2, 40d308 <tx_thread+0xa0>
		/* Standard (11-bit) ID frame, extended (29-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_RTR) == 0 && (filter->flags & CAN_FILTER_DATA) == 0) {
  40d328:	37080280 	tbnz	w0, #1, 40d378 <tx_thread+0x110>
  40d32c:	3617fee1 	tbz	w1, #2, 40d308 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
		/* Remote transmission request (RTR) frame, non-RTR filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_FDF) != 0 && (filter->flags & CAN_FILTER_FDF) == 0) {
  40d330:	121d0021 	and	w1, w1, #0x8
  40d334:	36100260 	tbz	w0, #2, 40d380 <tx_thread+0x118>
  40d338:	34fffe81 	cbz	w1, 40d308 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
		/* Classic frame, CAN-FD format filter */
		return false;
	}

	if ((frame->id ^ filter->id) & filter->mask) {
  40d33c:	937b7ec0 	sbfiz	x0, x22, #5, #32
  40d340:	8b000280 	add	x0, x20, x0
  40d344:	f94037e1 	ldr	x1, [sp, #104]
  40d348:	f9400800 	ldr	x0, [x0, #16]
  40d34c:	4a010001 	eor	w1, w0, w1
  40d350:	d360f000 	ubfx	x0, x0, #32, #29
  40d354:	6a00003f 	tst	w1, w0
  40d358:	54fffd81 	b.ne	40d308 <tx_thread+0xa0>  // b.any
	struct can_frame frame_tmp = *frame;
  40d35c:	a94687e0 	ldp	x0, x1, [sp, #104]
  40d360:	a90587e0 	stp	x0, x1, [sp, #88]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40d364:	a9400a63 	ldp	x3, x2, [x19]
  40d368:	aa1903e1 	mov	x1, x25
  40d36c:	aa1503e0 	mov	x0, x21
  40d370:	d63f0060 	blr	x3
}
  40d374:	17ffffe5 	b	40d308 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
  40d378:	370ffdc1 	tbnz	w1, #1, 40d330 <tx_thread+0xc8>
  40d37c:	17ffffe3 	b	40d308 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
  40d380:	34fffde1 	cbz	w1, 40d33c <tx_thread+0xd4>
  40d384:	17ffffe1 	b	40d308 <tx_thread+0xa0>

000000000040d388 <can_loopback_add_rx_filter>:
{
  40d388:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40d38c:	910003fd 	mov	x29, sp
  40d390:	a90153f3 	stp	x19, x20, [sp, #16]
  40d394:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d398:	a90363f7 	stp	x23, x24, [sp, #48]
  40d39c:	f90023f9 	str	x25, [sp, #64]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA | CAN_FILTER_RTR)) != 0) {
  40d3a0:	39402073 	ldrb	w19, [x3, #8]
  40d3a4:	39402067 	ldrb	w7, [x3, #8]
  40d3a8:	f27df273 	ands	x19, x19, #0xfffffffffffffff8
	struct can_loopback_data *data = dev->data;
  40d3ac:	f9401016 	ldr	x22, [x0, #32]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA | CAN_FILTER_RTR)) != 0) {
  40d3b0:	54000260 	b.eq	40d3fc <can_loopback_add_rx_filter+0x74>  // b.none
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40d3b4:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
		return -ENOTSUP;
  40d3b8:	12800bd5 	mov	w21, #0xffffffa1            	// #-95
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40d3bc:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d3c0:	52800005 	mov	w5, #0x0                   	// #0
  40d3c4:	f9474c21 	ldr	x1, [x1, #3736]
  40d3c8:	910264c6 	add	x6, x6, #0x99
  40d3cc:	d2800004 	mov	x4, #0x0                   	// #0
  40d3d0:	d2800003 	mov	x3, #0x0                   	// #0
  40d3d4:	52800022 	mov	w2, #0x1                   	// #1
  40d3d8:	52800000 	mov	w0, #0x0                   	// #0
  40d3dc:	97fffea6 	bl	40ce74 <z_log_msg_runtime_create.constprop.0>
}
  40d3e0:	2a1503e0 	mov	w0, w21
  40d3e4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d3e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d3ec:	a94363f7 	ldp	x23, x24, [sp, #48]
  40d3f0:	f94023f9 	ldr	x25, [sp, #64]
  40d3f4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40d3f8:	d65f03c0 	ret
  40d3fc:	aa0103f9 	mov	x25, x1
  40d400:	aa0203f8 	mov	x24, x2
  40d404:	aa0303f4 	mov	x20, x3
	k_mutex_lock(&data->mtx, K_FOREVER);
  40d408:	910802d7 	add	x23, x22, #0x200
  40d40c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40d410:	aa1703e0 	mov	x0, x23
  40d414:	940006da 	bl	40ef7c <z_impl_k_mutex_lock>
		if (filters[i].rx_cb == NULL) {
  40d418:	d37bea60 	lsl	x0, x19, #5
  40d41c:	2a1303f5 	mov	w21, w19
  40d420:	f8606ac0 	ldr	x0, [x22, x0]
  40d424:	b4000240 	cbz	x0, 40d46c <can_loopback_add_rx_filter+0xe4>
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d428:	91000673 	add	x19, x19, #0x1
  40d42c:	f100427f 	cmp	x19, #0x10
  40d430:	54ffff41 	b.ne	40d418 <can_loopback_add_rx_filter+0x90>  // b.any
		LOG_ERR("No free filter left");
  40d434:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40d438:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d43c:	9102f4c6 	add	x6, x6, #0xbd
  40d440:	52800005 	mov	w5, #0x0                   	// #0
  40d444:	f9474c21 	ldr	x1, [x1, #3736]
  40d448:	d2800004 	mov	x4, #0x0                   	// #0
  40d44c:	d2800003 	mov	x3, #0x0                   	// #0
  40d450:	52800022 	mov	w2, #0x1                   	// #1
  40d454:	52800000 	mov	w0, #0x0                   	// #0
	return -ENOSPC;
  40d458:	12800375 	mov	w21, #0xffffffe4            	// #-28
		LOG_ERR("No free filter left");
  40d45c:	97fffe86 	bl	40ce74 <z_log_msg_runtime_create.constprop.0>
		k_mutex_unlock(&data->mtx);
  40d460:	aa1703e0 	mov	x0, x23
  40d464:	97ffff24 	bl	40d0f4 <k_mutex_unlock.isra.0>
		return filter_id;
  40d468:	17ffffde 	b	40d3e0 <can_loopback_add_rx_filter+0x58>
	loopback_filter->rx_cb = cb;
  40d46c:	937b7e61 	sbfiz	x1, x19, #5, #32
  40d470:	8b0102c0 	add	x0, x22, x1
  40d474:	f8216ad9 	str	x25, [x22, x1]
	loopback_filter->cb_arg = cb_arg;
  40d478:	f9000418 	str	x24, [x0, #8]
	loopback_filter->filter = *filter;
  40d47c:	f9400281 	ldr	x1, [x20]
  40d480:	f9000801 	str	x1, [x0, #16]
  40d484:	b9400a81 	ldr	w1, [x20, #8]
  40d488:	b9001801 	str	w1, [x0, #24]
	k_mutex_unlock(&data->mtx);
  40d48c:	aa1703e0 	mov	x0, x23
  40d490:	97ffff19 	bl	40d0f4 <k_mutex_unlock.isra.0>
	return filter_id;
  40d494:	17ffffd3 	b	40d3e0 <can_loopback_add_rx_filter+0x58>

000000000040d498 <posix_arch_console_init>:
		stdout_buff[0] = 0;
	}
}

static int posix_arch_console_init(void)
{
  40d498:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#ifdef CONFIG_PRINTK
	extern void __printk_hook_install(int (*fn)(int));
	__printk_hook_install(print_char);
  40d49c:	90000000 	adrp	x0, 40d000 <can_loopback_send+0xd0>
  40d4a0:	9112e000 	add	x0, x0, #0x4b8
{
  40d4a4:	910003fd 	mov	x29, sp
	__printk_hook_install(print_char);
  40d4a8:	97ffe44f 	bl	4065e4 <__printk_hook_install>
#ifdef CONFIG_STDOUT_CONSOLE
	extern void __stdout_hook_install(int (*fn)(int));
	__stdout_hook_install(print_char);
#endif
	return 0;
}
  40d4ac:	52800000 	mov	w0, #0x0                   	// #0
  40d4b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d4b4:	d65f03c0 	ret

000000000040d4b8 <print_char>:
{
  40d4b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if ((c != '\n') && (c != '\r')) {
  40d4bc:	7100281f 	cmp	w0, #0xa
  40d4c0:	7a4d1804 	ccmp	w0, #0xd, #0x4, ne  // ne = any
{
  40d4c4:	910003fd 	mov	x29, sp
  40d4c8:	a90153f3 	stp	x19, x20, [sp, #16]
  40d4cc:	2a0003f3 	mov	w19, w0
  40d4d0:	90000114 	adrp	x20, 42d000 <counter_period>
  40d4d4:	f90013f5 	str	x21, [sp, #32]
	if ((c != '\n') && (c != '\r')) {
  40d4d8:	54000320 	b.eq	40d53c <print_char+0x84>  // b.none
		stdout_buff[n_pend++] = c;
  40d4dc:	b94bee82 	ldr	w2, [x20, #3052]
  40d4e0:	90000100 	adrp	x0, 42d000 <counter_period>
  40d4e4:	913ff800 	add	x0, x0, #0xffe
  40d4e8:	11000441 	add	w1, w2, #0x1
  40d4ec:	b90bee81 	str	w1, [x20, #3052]
  40d4f0:	3822c813 	strb	w19, [x0, w2, sxtw]
		stdout_buff[n_pend] = 0;
  40d4f4:	3821c81f 	strb	wzr, [x0, w1, sxtw]
	int printnow = 0;
  40d4f8:	52800000 	mov	w0, #0x0                   	// #0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  40d4fc:	b94bee81 	ldr	w1, [x20, #3052]
  40d500:	7103f83f 	cmp	w1, #0xfe
  40d504:	5400004c 	b.gt	40d50c <print_char+0x54>
	if (printnow) {
  40d508:	34000100 	cbz	w0, 40d528 <print_char+0x70>
		posix_print_trace("%s\n", stdout_buff);
  40d50c:	90000115 	adrp	x21, 42d000 <counter_period>
  40d510:	90000040 	adrp	x0, 415000 <random_data+0xb30>
  40d514:	913ffaa1 	add	x1, x21, #0xffe
  40d518:	912c6c00 	add	x0, x0, #0xb1b
  40d51c:	97fff47e 	bl	40a714 <posix_print_trace>
		n_pend = 0;
  40d520:	b90bee9f 	str	wzr, [x20, #3052]
		stdout_buff[0] = 0;
  40d524:	393ffabf 	strb	wzr, [x21, #4094]
}
  40d528:	2a1303e0 	mov	w0, w19
  40d52c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d530:	f94013f5 	ldr	x21, [sp, #32]
  40d534:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40d538:	d65f03c0 	ret
		printnow = 1;
  40d53c:	52800020 	mov	w0, #0x1                   	// #1
  40d540:	17ffffef 	b	40d4fc <print_char+0x44>

000000000040d544 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
  40d544:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d548:	910003fd 	mov	x29, sp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
  40d54c:	97fff148 	bl	409a6c <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40d550:	90000102 	adrp	x2, 42d000 <counter_period>
  40d554:	90000101 	adrp	x1, 42d000 <counter_period>

	last_tick_time += elapsed_ticks*tick_period;
	sys_clock_announce(elapsed_ticks);
}
  40d558:	a8c17bfd 	ldp	x29, x30, [sp], #16
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40d55c:	f943ac43 	ldr	x3, [x2, #1880]
  40d560:	f943b024 	ldr	x4, [x1, #1888]
  40d564:	cb030000 	sub	x0, x0, x3
  40d568:	9ac40800 	udiv	x0, x0, x4
	last_tick_time += elapsed_ticks*tick_period;
  40d56c:	93407c01 	sxtw	x1, w0
  40d570:	9b040c21 	madd	x1, x1, x4, x3
  40d574:	f903ac41 	str	x1, [x2, #1880]
	sys_clock_announce(elapsed_ticks);
  40d578:	1400163b 	b	412e64 <sys_clock_announce>

000000000040d57c <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(void)
{
  40d57c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40d580:	d284e200 	mov	x0, #0x2710                	// #10000
{
  40d584:	910003fd 	mov	x29, sp
  40d588:	f9000bf3 	str	x19, [sp, #16]
	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40d58c:	90000113 	adrp	x19, 42d000 <counter_period>
  40d590:	f903b260 	str	x0, [x19, #1888]

	last_tick_time = hwm_get_time();
  40d594:	97fff136 	bl	409a6c <hwm_get_time>
  40d598:	90000101 	adrp	x1, 42d000 <counter_period>
  40d59c:	f903ac20 	str	x0, [x1, #1880]
	hwtimer_enable(tick_period);
  40d5a0:	f943b260 	ldr	x0, [x19, #1888]
  40d5a4:	97fff1c6 	bl	409cbc <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
  40d5a8:	d2800003 	mov	x3, #0x0                   	// #0
  40d5ac:	52800001 	mov	w1, #0x0                   	// #0
  40d5b0:	52800000 	mov	w0, #0x0                   	// #0
  40d5b4:	90000002 	adrp	x2, 40d000 <can_loopback_send+0xd0>
  40d5b8:	91151042 	add	x2, x2, #0x544
  40d5bc:	97fff2e0 	bl	40a13c <posix_isr_declare>
  40d5c0:	52800002 	mov	w2, #0x0                   	// #0
  40d5c4:	52800021 	mov	w1, #0x1                   	// #1
  40d5c8:	52800000 	mov	w0, #0x0                   	// #0
  40d5cc:	97fff2e6 	bl	40a164 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
  40d5d0:	52800000 	mov	w0, #0x0                   	// #0
  40d5d4:	97ffee52 	bl	408f1c <arch_irq_enable>

	return 0;
}
  40d5d8:	52800000 	mov	w0, #0x0                   	// #0
  40d5dc:	f9400bf3 	ldr	x19, [sp, #16]
  40d5e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40d5e4:	d65f03c0 	ret

000000000040d5e8 <sys_clock_cycle_get_32>:
{
  40d5e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d5ec:	910003fd 	mov	x29, sp
	return hwm_get_time();
  40d5f0:	97fff11f 	bl	409a6c <hwm_get_time>
}
  40d5f4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d5f8:	d65f03c0 	ret

000000000040d5fc <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
  40d5fc:	3100041f 	cmn	w0, #0x1
  40d600:	540000c0 	b.eq	40d618 <sys_clock_set_timeout+0x1c>  // b.none
		silent_ticks = ticks - 1;
  40d604:	51000401 	sub	w1, w0, #0x1
  40d608:	7100001f 	cmp	w0, #0x0
  40d60c:	93407c21 	sxtw	x1, w1
  40d610:	9a9fc020 	csel	x0, x1, xzr, gt
	hwtimer_set_silent_ticks(silent_ticks);
  40d614:	17fff21e 	b	409e8c <hwtimer_set_silent_ticks>
		silent_ticks = INT64_MAX;
  40d618:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  40d61c:	17fffffe 	b	40d614 <sys_clock_set_timeout+0x18>

000000000040d620 <sys_clock_elapsed>:
{
  40d620:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d624:	910003fd 	mov	x29, sp
	return (hwm_get_time() - last_tick_time)/tick_period;
  40d628:	97fff111 	bl	409a6c <hwm_get_time>
  40d62c:	90000101 	adrp	x1, 42d000 <counter_period>
}
  40d630:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return (hwm_get_time() - last_tick_time)/tick_period;
  40d634:	f943ac21 	ldr	x1, [x1, #1880]
  40d638:	cb010000 	sub	x0, x0, x1
  40d63c:	90000101 	adrp	x1, 42d000 <counter_period>
  40d640:	f943b021 	ldr	x1, [x1, #1888]
}
  40d644:	9ac10800 	udiv	x0, x0, x1
  40d648:	d65f03c0 	ret

000000000040d64c <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	STRUCT_SECTION_FOREACH(device, dev) {
  40d64c:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40d650:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40d654:	f9476000 	ldr	x0, [x0, #3776]
  40d658:	f9478421 	ldr	x1, [x1, #3848]
  40d65c:	eb01001f 	cmp	x0, x1
  40d660:	54000349 	b.ls	40d6c8 <z_device_state_init+0x7c>  // b.plast
{
  40d664:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	STRUCT_SECTION_FOREACH(device, dev) {
  40d668:	b0000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40d66c:	91043c21 	add	x1, x1, #0x10f
{
  40d670:	910003fd 	mov	x29, sp
  40d674:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(device, dev) {
  40d678:	b0000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40d67c:	9103b273 	add	x19, x19, #0xec
  40d680:	528002e3 	mov	w3, #0x17                  	// #23
  40d684:	aa1303e2 	mov	x2, x19
  40d688:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40d68c:	9123f800 	add	x0, x0, #0x8fe
  40d690:	97ffe99f 	bl	407d0c <assert_print>
  40d694:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40d698:	9130fc00 	add	x0, x0, #0xc3f
  40d69c:	97ffe99c 	bl	407d0c <assert_print>
  40d6a0:	aa1303e0 	mov	x0, x19
  40d6a4:	528002e1 	mov	w1, #0x17                  	// #23
  40d6a8:	97ffe9c3 	bl	407db4 <assert_post_action>
  40d6ac:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40d6b0:	aa1303e1 	mov	x1, x19
  40d6b4:	9124f000 	add	x0, x0, #0x93c
  40d6b8:	528002e2 	mov	w2, #0x17                  	// #23
  40d6bc:	97fff3b0 	bl	40a57c <posix_print_error_and_exit>
  40d6c0:	9100c000 	add	x0, x0, #0x30
  40d6c4:	17ffffe6 	b	40d65c <z_device_state_init+0x10>
  40d6c8:	54ffffc3 	b.cc	40d6c0 <z_device_state_init+0x74>  // b.lo, b.ul, b.last
  40d6cc:	d65f03c0 	ret

000000000040d6d0 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
  40d6d0:	b4000100 	cbz	x0, 40d6f0 <z_device_is_ready+0x20>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
  40d6d4:	f9400c00 	ldr	x0, [x0, #24]
  40d6d8:	39400401 	ldrb	w1, [x0, #1]
  40d6dc:	360000a1 	tbz	w1, #0, 40d6f0 <z_device_is_ready+0x20>
  40d6e0:	39400000 	ldrb	w0, [x0]
  40d6e4:	7100001f 	cmp	w0, #0x0
  40d6e8:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40d6ec:	d65f03c0 	ret
		return false;
  40d6f0:	52800000 	mov	w0, #0x0                   	// #0
  40d6f4:	17fffffe 	b	40d6ec <z_device_is_ready+0x1c>

000000000040d6f8 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40d6f8:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40d6fc:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40d700:	910003fd 	mov	x29, sp
  40d704:	f9476800 	ldr	x0, [x0, #3792]
  40d708:	3d8023e0 	str	q0, [sp, #128]
  40d70c:	3d8027e1 	str	q1, [sp, #144]
  40d710:	3d802be2 	str	q2, [sp, #160]
  40d714:	3d802fe3 	str	q3, [sp, #176]
  40d718:	3d8033e4 	str	q4, [sp, #192]
  40d71c:	3d8037e5 	str	q5, [sp, #208]
  40d720:	3d803be6 	str	q6, [sp, #224]
  40d724:	3d803fe7 	str	q7, [sp, #240]
  40d728:	f90087e7 	str	x7, [sp, #264]
  40d72c:	f9400002 	ldr	x2, [x0]
  40d730:	f9003fe2 	str	x2, [sp, #120]
  40d734:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40d738:	910443e0 	add	x0, sp, #0x110
  40d73c:	a90383e0 	stp	x0, x0, [sp, #56]
  40d740:	910403e0 	add	x0, sp, #0x100
  40d744:	9100e3e2 	add	x2, sp, #0x38
  40d748:	f90027e0 	str	x0, [sp, #72]
  40d74c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40d750:	b90053e0 	str	w0, [sp, #80]
  40d754:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40d758:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40d75c:	910163e0 	add	x0, sp, #0x58
  40d760:	ad400440 	ldp	q0, q1, [x2]
  40d764:	ad000400 	stp	q0, q1, [x0]
  40d768:	ad400400 	ldp	q0, q1, [x0]
  40d76c:	910043e7 	add	x7, sp, #0x10
  40d770:	52800022 	mov	w2, #0x1                   	// #1
  40d774:	52800000 	mov	w0, #0x0                   	// #0
  40d778:	52800005 	mov	w5, #0x0                   	// #0
  40d77c:	d2800004 	mov	x4, #0x0                   	// #0
  40d780:	d2800003 	mov	x3, #0x0                   	// #0
  40d784:	ad0004e0 	stp	q0, q1, [x7]
  40d788:	97ffeb41 	bl	40848c <z_impl_z_log_msg_runtime_vcreate>
}
  40d78c:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40d790:	f9476800 	ldr	x0, [x0, #3792]
  40d794:	f9403fe2 	ldr	x2, [sp, #120]
  40d798:	f9400001 	ldr	x1, [x0]
  40d79c:	eb010042 	subs	x2, x2, x1
  40d7a0:	d2800001 	mov	x1, #0x0                   	// #0
  40d7a4:	54000040 	b.eq	40d7ac <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40d7a8:	97ffcede 	bl	401320 <__stack_chk_fail@plt>
  40d7ac:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40d7b0:	d65f03c0 	ret

000000000040d7b4 <coredump>:
#else

void coredump(unsigned int reason, const z_arch_esf_t *esf,
	      struct k_thread *thread)
{
}
  40d7b4:	d65f03c0 	ret

000000000040d7b8 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  40d7b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40d7bc:	910003fd 	mov	x29, sp
  40d7c0:	f9000bf3 	str	x19, [sp, #16]
  40d7c4:	2a0003f3 	mov	w19, w0
  40d7c8:	97ffea42 	bl	4080d0 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
  40d7cc:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40d7d0:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d7d4:	91049cc6 	add	x6, x6, #0x127
  40d7d8:	52800005 	mov	w5, #0x0                   	// #0
  40d7dc:	f9470821 	ldr	x1, [x1, #3600]
  40d7e0:	d2800004 	mov	x4, #0x0                   	// #0
  40d7e4:	d2800003 	mov	x3, #0x0                   	// #0
  40d7e8:	52800022 	mov	w2, #0x1                   	// #1
  40d7ec:	52800000 	mov	w0, #0x0                   	// #0
  40d7f0:	97ffffc2 	bl	40d6f8 <z_log_msg_runtime_create.constprop.0>
	arch_system_halt(reason);
  40d7f4:	2a1303e0 	mov	w0, w19
  40d7f8:	97ffedbe 	bl	408ef0 <arch_system_halt>

000000000040d7fc <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  40d7fc:	d10143ff 	sub	sp, sp, #0x50
  40d800:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d804:	910043fd 	add	x29, sp, #0x10
  40d808:	a90253f3 	stp	x19, x20, [sp, #32]
  40d80c:	2a0003f3 	mov	w19, w0
  40d810:	aa0103f4 	mov	x20, x1
  40d814:	a9035bf5 	stp	x21, x22, [sp, #48]
  40d818:	f90023f7 	str	x23, [sp, #64]
	return posix_irq_lock();
  40d81c:	97fff242 	bl	40a124 <posix_irq_lock>
  40d820:	2a0003f5 	mov	w21, w0
	return z_impl_z_current_get();
  40d824:	940012da 	bl	41238c <z_impl_z_current_get>
  40d828:	aa0003f6 	mov	x22, x0
	switch (reason) {
  40d82c:	7100127f 	cmp	w19, #0x4
  40d830:	54000848 	b.hi	40d938 <z_fatal_error+0x13c>  // b.pmore
  40d834:	d0000020 	adrp	x0, 413000 <sys_clock_announce+0x19c>
  40d838:	91208000 	add	x0, x0, #0x820
  40d83c:	38734800 	ldrb	w0, [x0, w19, uxtw]
  40d840:	10000061 	adr	x1, 40d84c <z_fatal_error+0x50>
  40d844:	8b208820 	add	x0, x1, w0, sxtb #2
  40d848:	d61f0000 	br	x0
		return "Unhandled interrupt";
  40d84c:	b0000043 	adrp	x3, 416000 <__func__.0+0x9cb>
  40d850:	91051063 	add	x3, x3, #0x144
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  40d854:	d00000f7 	adrp	x23, 42b000 <__FRAME_END__+0xfd74>
  40d858:	f90003e3 	str	x3, [sp]
  40d85c:	b9000bff 	str	wzr, [sp, #8]
  40d860:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d864:	f9470ae1 	ldr	x1, [x23, #3600]
  40d868:	2a1303e7 	mov	w7, w19
  40d86c:	910658c6 	add	x6, x6, #0x196
  40d870:	52800005 	mov	w5, #0x0                   	// #0
  40d874:	d2800004 	mov	x4, #0x0                   	// #0
  40d878:	52800022 	mov	w2, #0x1                   	// #1
  40d87c:	52800000 	mov	w0, #0x0                   	// #0
  40d880:	d2800003 	mov	x3, #0x0                   	// #0
  40d884:	97ffff9d 	bl	40d6f8 <z_log_msg_runtime_create.constprop.0>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
  40d888:	b40000d6 	cbz	x22, 40d8a0 <z_fatal_error+0xa4>
  40d88c:	aa1603e0 	mov	x0, x22
  40d890:	940002d6 	bl	40e3e8 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
  40d894:	b4000060 	cbz	x0, 40d8a0 <z_fatal_error+0xa4>
  40d898:	39400001 	ldrb	w1, [x0]
  40d89c:	35000061 	cbnz	w1, 40d8a8 <z_fatal_error+0xac>
		thread_name = "unknown";
  40d8a0:	b0000043 	adrp	x3, 416000 <__func__.0+0x9cb>
  40d8a4:	91063860 	add	x0, x3, #0x18e
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  40d8a8:	f9470ae1 	ldr	x1, [x23, #3600]
  40d8ac:	aa1603e7 	mov	x7, x22
  40d8b0:	b0000046 	adrp	x6, 416000 <__func__.0+0x9cb>
  40d8b4:	9106f8c6 	add	x6, x6, #0x1be
  40d8b8:	f90003e0 	str	x0, [sp]
  40d8bc:	52800005 	mov	w5, #0x0                   	// #0
  40d8c0:	d2800004 	mov	x4, #0x0                   	// #0
  40d8c4:	d2800003 	mov	x3, #0x0                   	// #0
  40d8c8:	52800022 	mov	w2, #0x1                   	// #1
  40d8cc:	52800000 	mov	w0, #0x0                   	// #0
  40d8d0:	97ffff8a 	bl	40d6f8 <z_log_msg_runtime_create.constprop.0>
		thread_name_get(thread));

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
  40d8d4:	aa1603e2 	mov	x2, x22
  40d8d8:	aa1403e1 	mov	x1, x20
  40d8dc:	2a1303e0 	mov	w0, w19
  40d8e0:	97ffffb5 	bl	40d7b4 <coredump>
#endif

	k_sys_fatal_error_handler(reason, esf);
  40d8e4:	aa1403e1 	mov	x1, x20
  40d8e8:	2a1303e0 	mov	w0, w19
  40d8ec:	97ffffb3 	bl	40d7b8 <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
  40d8f0:	2a1503e0 	mov	w0, w21
  40d8f4:	97fff20e 	bl	40a12c <posix_irq_unlock>
	z_impl_k_thread_abort(thread);
  40d8f8:	aa1603e0 	mov	x0, x22
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
  40d8fc:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40d900:	a94253f3 	ldp	x19, x20, [sp, #32]
  40d904:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40d908:	f94023f7 	ldr	x23, [sp, #64]
  40d90c:	910143ff 	add	sp, sp, #0x50
  40d910:	17ffeeb2 	b	4093d8 <z_impl_k_thread_abort>
		return "Stack overflow";
  40d914:	b0000043 	adrp	x3, 416000 <__func__.0+0x9cb>
  40d918:	91056063 	add	x3, x3, #0x158
  40d91c:	17ffffce 	b	40d854 <z_fatal_error+0x58>
		return "Kernel oops";
  40d920:	b0000043 	adrp	x3, 416000 <__func__.0+0x9cb>
  40d924:	91059c63 	add	x3, x3, #0x167
  40d928:	17ffffcb 	b	40d854 <z_fatal_error+0x58>
		return "Kernel panic";
  40d92c:	b0000043 	adrp	x3, 416000 <__func__.0+0x9cb>
  40d930:	9105cc63 	add	x3, x3, #0x173
  40d934:	17ffffc8 	b	40d854 <z_fatal_error+0x58>
		return "Unknown error";
  40d938:	b0000043 	adrp	x3, 416000 <__func__.0+0x9cb>
  40d93c:	91060063 	add	x3, x3, #0x180
  40d940:	17ffffc5 	b	40d854 <z_fatal_error+0x58>
	switch (reason) {
  40d944:	b0000043 	adrp	x3, 416000 <__func__.0+0x9cb>
  40d948:	9104d863 	add	x3, x3, #0x136
  40d94c:	17ffffc2 	b	40d854 <z_fatal_error+0x58>

000000000040d950 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
  40d950:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d954:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40d958:	91276021 	add	x1, x1, #0x9d8
{
  40d95c:	910003fd 	mov	x29, sp
  40d960:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d964:	f8605833 	ldr	x19, [x1, w0, uxtw #3]
  40d968:	11000400 	add	w0, w0, #0x1
{
  40d96c:	a9025bf5 	stp	x21, x22, [sp, #32]
						rc = -rc;
					}
					if (rc > UINT8_MAX) {
						rc = UINT8_MAX;
					}
					dev->state->init_res = rc;
  40d970:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d974:	f8607835 	ldr	x21, [x1, x0, lsl #3]
  40d978:	eb1302bf 	cmp	x21, x19
  40d97c:	540000a8 	b.hi	40d990 <z_sys_init_run_level+0x40>  // b.pmore
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
  40d980:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d984:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d988:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40d98c:	d65f03c0 	ret
		const struct device *dev = entry->dev;
  40d990:	a9405261 	ldp	x1, x20, [x19]
		if (dev != NULL) {
  40d994:	b4000234 	cbz	x20, 40d9d8 <z_sys_init_run_level+0x88>
			if (entry->init_fn.dev != NULL) {
  40d998:	b4000141 	cbz	x1, 40d9c0 <z_sys_init_run_level+0x70>
				rc = entry->init_fn.dev(dev);
  40d99c:	aa1403e0 	mov	x0, x20
  40d9a0:	d63f0020 	blr	x1
				if (rc != 0) {
  40d9a4:	7100001f 	cmp	w0, #0x0
  40d9a8:	340000c0 	cbz	w0, 40d9c0 <z_sys_init_run_level+0x70>
					dev->state->init_res = rc;
  40d9ac:	f9400e81 	ldr	x1, [x20, #24]
  40d9b0:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
  40d9b4:	7103fc1f 	cmp	w0, #0xff
  40d9b8:	1a96d000 	csel	w0, w0, w22, le
  40d9bc:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
  40d9c0:	f9400e81 	ldr	x1, [x20, #24]
  40d9c4:	39400420 	ldrb	w0, [x1, #1]
  40d9c8:	32000000 	orr	w0, w0, #0x1
  40d9cc:	39000420 	strb	w0, [x1, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d9d0:	91004273 	add	x19, x19, #0x10
  40d9d4:	17ffffe9 	b	40d978 <z_sys_init_run_level+0x28>
			(void)entry->init_fn.sys();
  40d9d8:	d63f0020 	blr	x1
  40d9dc:	17fffffd 	b	40d9d0 <z_sys_init_run_level+0x80>

000000000040d9e0 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
  40d9e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
  40d9e4:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40d9e8:	52800021 	mov	w1, #0x1                   	// #1
{
  40d9ec:	910003fd 	mov	x29, sp
	z_sys_post_kernel = true;
  40d9f0:	f946f400 	ldr	x0, [x0, #3560]
  40d9f4:	39000001 	strb	w1, [x0]

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
  40d9f8:	52800060 	mov	w0, #0x3                   	// #3
  40d9fc:	97ffffd5 	bl	40d950 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
  40da00:	94001733 	bl	4136cc <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
  40da04:	52800080 	mov	w0, #0x4                   	// #4
  40da08:	97ffffd2 	bl	40d950 <z_sys_init_run_level>

	z_init_static_threads();
  40da0c:	9400030d 	bl	40e640 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
  40da10:	97fff8d9 	bl	40bd74 <_posix_zephyr_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  40da14:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40da18:	f947e800 	ldr	x0, [x0, #4048]
  40da1c:	39406001 	ldrb	w1, [x0, #24]
  40da20:	121f7821 	and	w1, w1, #0xfffffffe
  40da24:	39006001 	strb	w1, [x0, #24]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  40da28:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40da2c:	d65f03c0 	ret

000000000040da30 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
  40da30:	d10143ff 	sub	sp, sp, #0x50
	z_setup_new_thread(thread, stack,
  40da34:	52800504 	mov	w4, #0x28                  	// #40
  40da38:	d00000e3 	adrp	x3, 42b000 <__FRAME_END__+0xfd74>
  40da3c:	528001e7 	mov	w7, #0xf                   	// #15
  40da40:	d2800006 	mov	x6, #0x0                   	// #0
  40da44:	d2800005 	mov	x5, #0x0                   	// #0
{
  40da48:	a9017bfd 	stp	x29, x30, [sp, #16]
  40da4c:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(thread, stack,
  40da50:	d2802002 	mov	x2, #0x100                 	// #256
  40da54:	f9475063 	ldr	x3, [x3, #3744]
{
  40da58:	a9035bf5 	stp	x21, x22, [sp, #48]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  40da5c:	d00000f6 	adrp	x22, 42b000 <__FRAME_END__+0xfd74>
{
  40da60:	f90023f7 	str	x23, [sp, #64]
	struct k_thread *thread = &z_idle_threads[i];
  40da64:	d00000f7 	adrp	x23, 42b000 <__FRAME_END__+0xfd74>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  40da68:	f94732d6 	ldr	x22, [x22, #3680]
{
  40da6c:	a90253f3 	stp	x19, x20, [sp, #32]
  40da70:	93407c13 	sxtw	x19, w0
	struct k_thread *thread = &z_idle_threads[i];
  40da74:	f94702f7 	ldr	x23, [x23, #3584]
  40da78:	52801815 	mov	w21, #0xc0                  	// #192
	z_setup_new_thread(thread, stack,
  40da7c:	9b245a64 	smaddl	x4, w19, w4, x22
  40da80:	b0000040 	adrp	x0, 416000 <__func__.0+0x9cb>
  40da84:	91075800 	add	x0, x0, #0x1d6
  40da88:	f90007e0 	str	x0, [sp, #8]
	struct k_thread *thread = &z_idle_threads[i];
  40da8c:	9b355e75 	smaddl	x21, w19, w21, x23
	z_setup_new_thread(thread, stack,
  40da90:	52800020 	mov	w0, #0x1                   	// #1
  40da94:	b90003e0 	str	w0, [sp]
	k_thread_stack_t *stack = z_idle_stacks[i];
  40da98:	93787e61 	sbfiz	x1, x19, #8, #32
	z_setup_new_thread(thread, stack,
  40da9c:	b0000120 	adrp	x0, 432000 <ztest_thread_stack+0x2f8>
  40daa0:	910c2000 	add	x0, x0, #0x308
  40daa4:	8b010001 	add	x1, x0, x1
  40daa8:	aa1503e0 	mov	x0, x21
  40daac:	94000259 	bl	40e410 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  40dab0:	d2801800 	mov	x0, #0xc0                  	// #192
  40dab4:	9b005e60 	madd	x0, x19, x0, x23
  40dab8:	39406401 	ldrb	w1, [x0, #25]
  40dabc:	121d7821 	and	w1, w1, #0xfffffffb
  40dac0:	39006401 	strb	w1, [x0, #25]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40dac4:	d2800501 	mov	x1, #0x28                  	// #40
	_kernel.cpus[id].id = id;
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40dac8:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40dacc:	9b015a61 	madd	x1, x19, x1, x22
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40dad0:	f946fc00 	ldr	x0, [x0, #3576]
	_kernel.cpus[id].id = id;
  40dad4:	39008033 	strb	w19, [x1, #32]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40dad8:	91000673 	add	x19, x19, #0x1
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40dadc:	f9000c35 	str	x21, [x1, #24]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40dae0:	8b132c13 	add	x19, x0, x19, lsl #11
	_kernel.cpus[id].irq_stack =
  40dae4:	f9000433 	str	x19, [x1, #8]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  40dae8:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40daec:	d2800020 	mov	x0, #0x1                   	// #1
  40daf0:	f9477021 	ldr	x1, [x1, #3808]
  40daf4:	97ffcec7 	bl	401610 <__aarch64_ldadd8_acq_rel>
	/*
	 * Increment number of CPUs active. The pm subsystem
	 * will keep track of this from here.
	 */
	atomic_inc(&_cpus_active);
}
  40daf8:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40dafc:	a94253f3 	ldp	x19, x20, [sp, #32]
  40db00:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40db04:	f94023f7 	ldr	x23, [sp, #64]
  40db08:	910143ff 	add	sp, sp, #0x50
  40db0c:	d65f03c0 	ret

000000000040db10 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
  40db10:	d10403ff 	sub	sp, sp, #0x100
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  40db14:	52800000 	mov	w0, #0x0                   	// #0
{
  40db18:	a9017bfd 	stp	x29, x30, [sp, #16]
  40db1c:	910043fd 	add	x29, sp, #0x10
  40db20:	a90253f3 	stp	x19, x20, [sp, #32]

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
  40db24:	d00000f4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
	_kernel.ready_q.cache = &z_main_thread;
  40db28:	d00000f3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
{
  40db2c:	f9001bf5 	str	x21, [sp, #48]
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  40db30:	97ffff88 	bl	40d950 <z_sys_init_run_level>

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
  40db34:	97ffe95c 	bl	4080a4 <log_core_init>
	dummy_thread->resource_pool = NULL;
  40db38:	f9007bff 	str	xzr, [sp, #240]
	_current_cpu->current = dummy_thread;
  40db3c:	f9473294 	ldr	x20, [x20, #3680]
	dummy_thread->base.user_options = K_ESSENTIAL;
  40db40:	52802020 	mov	w0, #0x101                 	// #257
  40db44:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
  40db48:	910103e0 	add	x0, sp, #0x40
  40db4c:	f9000a80 	str	x0, [x20, #16]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
  40db50:	97fffebf 	bl	40d64c <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
  40db54:	52800020 	mov	w0, #0x1                   	// #1
  40db58:	97ffff7e 	bl	40d950 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
  40db5c:	52800040 	mov	w0, #0x2                   	// #2
  40db60:	97ffff7c 	bl	40d950 <z_sys_init_run_level>
	z_sched_init();
  40db64:	940010c7 	bl	411e80 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40db68:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40db6c:	b0000040 	adrp	x0, 416000 <__func__.0+0x9cb>
	_kernel.ready_q.cache = &z_main_thread;
  40db70:	f947ea73 	ldr	x19, [x19, #4048]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40db74:	91076c00 	add	x0, x0, #0x1db
  40db78:	f9477821 	ldr	x1, [x1, #3824]
	_kernel.ready_q.cache = &z_main_thread;
  40db7c:	f9001693 	str	x19, [x20, #40]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40db80:	f90007e0 	str	x0, [sp, #8]
  40db84:	52800020 	mov	w0, #0x1                   	// #1
  40db88:	b90003e0 	str	w0, [sp]
  40db8c:	90000014 	adrp	x20, 40d000 <can_loopback_send+0xd0>
  40db90:	91278294 	add	x20, x20, #0x9e0
  40db94:	52800007 	mov	w7, #0x0                   	// #0
  40db98:	aa1403e3 	mov	x3, x20
  40db9c:	d2800006 	mov	x6, #0x0                   	// #0
  40dba0:	d2800005 	mov	x5, #0x0                   	// #0
  40dba4:	d2800004 	mov	x4, #0x0                   	// #0
  40dba8:	d2804002 	mov	x2, #0x200                 	// #512
  40dbac:	aa1303e0 	mov	x0, x19
  40dbb0:	94000218 	bl	40e410 <z_setup_new_thread>
  40dbb4:	aa0003f5 	mov	x21, x0
  40dbb8:	39406660 	ldrb	w0, [x19, #25]
  40dbbc:	121d7800 	and	w0, w0, #0xfffffffb
  40dbc0:	39006660 	strb	w0, [x19, #25]
	z_ready_thread(&z_main_thread);
  40dbc4:	aa1303e0 	mov	x0, x19
  40dbc8:	94000cfe 	bl	410fc0 <z_ready_thread>
	z_init_cpu(0);
  40dbcc:	52800000 	mov	w0, #0x0                   	// #0
  40dbd0:	97ffff98 	bl	40da30 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  40dbd4:	aa1403e2 	mov	x2, x20
  40dbd8:	aa1503e1 	mov	x1, x21
  40dbdc:	aa1303e0 	mov	x0, x19
  40dbe0:	97ffee3f 	bl	4094dc <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  40dbe4:	b0000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40dbe8:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40dbec:	91078021 	add	x1, x1, #0x1e0
  40dbf0:	9124f000 	add	x0, x0, #0x93c
  40dbf4:	52803a82 	mov	w2, #0x1d4                 	// #468
  40dbf8:	97fff261 	bl	40a57c <posix_print_error_and_exit>

000000000040dbfc <k_heap_init>:
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
  40dbfc:	91006004 	add	x4, x0, #0x18
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
  40dc00:	a9019004 	stp	x4, x4, [x0, #24]
#include <zephyr/sys/iterable_sections.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
  40dc04:	17ffe470 	b	406dc4 <sys_heap_init>

000000000040dc08 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
  40dc08:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40dc0c:	910003fd 	mov	x29, sp
  40dc10:	a90153f3 	stp	x19, x20, [sp, #16]
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40dc14:	d00000f3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  40dc18:	d00000f4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  40dc1c:	f9474a73 	ldr	x19, [x19, #3728]
  40dc20:	f9473694 	ldr	x20, [x20, #3688]
  40dc24:	eb14027f 	cmp	x19, x20
  40dc28:	54000349 	b.ls	40dc90 <statics_init+0x88>  // b.plast
  40dc2c:	b0000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40dc30:	91081273 	add	x19, x19, #0x204
  40dc34:	aa1303e2 	mov	x2, x19
  40dc38:	b0000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40dc3c:	91089821 	add	x1, x1, #0x226
  40dc40:	52800303 	mov	w3, #0x18                  	// #24
  40dc44:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40dc48:	9123f800 	add	x0, x0, #0x8fe
  40dc4c:	97ffe830 	bl	407d0c <assert_print>
  40dc50:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40dc54:	9130fc00 	add	x0, x0, #0xc3f
  40dc58:	97ffe82d 	bl	407d0c <assert_print>
  40dc5c:	aa1303e0 	mov	x0, x19
  40dc60:	52800301 	mov	w1, #0x18                  	// #24
  40dc64:	97ffe854 	bl	407db4 <assert_post_action>
  40dc68:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40dc6c:	aa1303e1 	mov	x1, x19
  40dc70:	9124f000 	add	x0, x0, #0x93c
  40dc74:	52800302 	mov	w2, #0x18                  	// #24
  40dc78:	97fff241 	bl	40a57c <posix_print_error_and_exit>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  40dc7c:	a9408a61 	ldp	x1, x2, [x19, #8]
  40dc80:	aa1303e0 	mov	x0, x19
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40dc84:	9100c273 	add	x19, x19, #0x30
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  40dc88:	97ffffdd 	bl	40dbfc <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40dc8c:	17ffffe6 	b	40dc24 <statics_init+0x1c>
  40dc90:	54ffff63 	b.cc	40dc7c <statics_init+0x74>  // b.lo, b.ul, b.last
		}
	}
	return 0;
}
  40dc94:	52800000 	mov	w0, #0x0                   	// #0
  40dc98:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dc9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40dca0:	d65f03c0 	ret

000000000040dca4 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
  40dca4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40dca8:	910003fd 	mov	x29, sp
  40dcac:	a90153f3 	stp	x19, x20, [sp, #16]
  40dcb0:	a9025bf5 	stp	x21, x22, [sp, #32]
  40dcb4:	aa0303f6 	mov	x22, x3
  40dcb8:	aa0003f5 	mov	x21, x0
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  40dcbc:	aa0303e0 	mov	x0, x3
{
  40dcc0:	a90363f7 	stp	x23, x24, [sp, #48]
  40dcc4:	aa0103f7 	mov	x23, x1
  40dcc8:	aa0203f8 	mov	x24, x2
  40dccc:	a9046bf9 	stp	x25, x26, [sp, #64]
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  40dcd0:	9400152c 	bl	413180 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  40dcd4:	b10006df 	cmn	x22, #0x1
  40dcd8:	92f00001 	mov	x1, #0x7fffffffffffffff    	// #9223372036854775807

	k_spinlock_key_t key = k_spin_lock(&h->lock);
  40dcdc:	9100a2b3 	add	x19, x21, #0x28
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  40dce0:	9a811019 	csel	x25, x0, x1, ne  // ne = any
	return posix_irq_lock();
  40dce4:	97fff110 	bl	40a124 <posix_irq_lock>
  40dce8:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40dcec:	aa1303e0 	mov	x0, x19
  40dcf0:	940002b4 	bl	40e7c0 <z_spin_lock_valid>
  40dcf4:	72001c1f 	tst	w0, #0xff
  40dcf8:	54000281 	b.ne	40dd48 <k_heap_aligned_alloc+0xa4>  // b.any
  40dcfc:	90000054 	adrp	x20, 415000 <random_data+0xb30>
  40dd00:	91391a94 	add	x20, x20, #0xe46
  40dd04:	aa1403e2 	mov	x2, x20
  40dd08:	52801283 	mov	w3, #0x94                  	// #148
  40dd0c:	90000041 	adrp	x1, 415000 <random_data+0xb30>
  40dd10:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40dd14:	9139cc21 	add	x1, x1, #0xe73
  40dd18:	9123f800 	add	x0, x0, #0x8fe
  40dd1c:	97ffe7fc 	bl	407d0c <assert_print>
  40dd20:	aa1303e1 	mov	x1, x19
  40dd24:	90000040 	adrp	x0, 415000 <random_data+0xb30>
  40dd28:	913a2000 	add	x0, x0, #0xe88
  40dd2c:	97ffe7f8 	bl	407d0c <assert_print>
  40dd30:	aa1403e0 	mov	x0, x20
  40dd34:	52801281 	mov	w1, #0x94                  	// #148
  40dd38:	97ffe81f 	bl	407db4 <assert_post_action>
  40dd3c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dd40:	aa1403e1 	mov	x1, x20
  40dd44:	14000019 	b	40dda8 <k_heap_aligned_alloc+0x104>
	z_spin_lock_set_owner(l);
  40dd48:	aa1303e0 	mov	x0, x19
  40dd4c:	940002b5 	bl	40e820 <z_spin_lock_set_owner>
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
  40dd50:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40dd54:	f9473000 	ldr	x0, [x0, #3680]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40dd58:	b9400000 	ldr	w0, [x0]
  40dd5c:	34000860 	cbz	w0, 40de68 <k_heap_aligned_alloc+0x1c4>
  40dd60:	b4000856 	cbz	x22, 40de68 <k_heap_aligned_alloc+0x1c4>
  40dd64:	b0000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40dd68:	91081273 	add	x19, x19, #0x204
  40dd6c:	aa1303e2 	mov	x2, x19
  40dd70:	b0000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40dd74:	9108f021 	add	x1, x1, #0x23c
  40dd78:	52800983 	mov	w3, #0x4c                  	// #76
  40dd7c:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40dd80:	9123f800 	add	x0, x0, #0x8fe
  40dd84:	97ffe7e2 	bl	407d0c <assert_print>
  40dd88:	90000040 	adrp	x0, 415000 <random_data+0xb30>
  40dd8c:	913b7400 	add	x0, x0, #0xedd
  40dd90:	97ffe7df 	bl	407d0c <assert_print>
  40dd94:	52800981 	mov	w1, #0x4c                  	// #76
  40dd98:	aa1303e0 	mov	x0, x19
  40dd9c:	97ffe806 	bl	407db4 <assert_post_action>
  40dda0:	aa1303e1 	mov	x1, x19
  40dda4:	52800982 	mov	w2, #0x4c                  	// #76
  40dda8:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40ddac:	9124f000 	add	x0, x0, #0x93c
  40ddb0:	97fff1f3 	bl	40a57c <posix_print_error_and_exit>
	while (ret == NULL) {
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);

		now = sys_clock_tick_get();
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
		    (ret != NULL) || ((end - now) <= 0)) {
  40ddb4:	cb030323 	sub	x3, x25, x3
  40ddb8:	f100007f 	cmp	x3, #0x0
  40ddbc:	540002ad 	b.le	40de10 <k_heap_aligned_alloc+0x16c>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  40ddc0:	2a1403e1 	mov	w1, w20
  40ddc4:	aa1a03e2 	mov	x2, x26
  40ddc8:	aa1303e0 	mov	x0, x19
  40ddcc:	94000dc6 	bl	4114e4 <z_pend_curr>
  40ddd0:	97fff0d5 	bl	40a124 <posix_irq_lock>
  40ddd4:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ddd8:	aa1303e0 	mov	x0, x19
  40dddc:	94000279 	bl	40e7c0 <z_spin_lock_valid>
  40dde0:	72001c1f 	tst	w0, #0xff
  40dde4:	54fff8c0 	b.eq	40dcfc <k_heap_aligned_alloc+0x58>  // b.none
	z_spin_lock_set_owner(l);
  40dde8:	aa1303e0 	mov	x0, x19
  40ddec:	9400028d 	bl	40e820 <z_spin_lock_set_owner>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
  40ddf0:	aa1803e2 	mov	x2, x24
  40ddf4:	aa1703e1 	mov	x1, x23
  40ddf8:	aa1503e0 	mov	x0, x21
  40ddfc:	97ffe389 	bl	406c20 <sys_heap_aligned_alloc>
  40de00:	aa0003f6 	mov	x22, x0
		now = sys_clock_tick_get();
  40de04:	94001495 	bl	413058 <sys_clock_tick_get>
  40de08:	aa0003e3 	mov	x3, x0
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
  40de0c:	b4fffd56 	cbz	x22, 40ddb4 <k_heap_aligned_alloc+0x110>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40de10:	aa1303e0 	mov	x0, x19
  40de14:	94000276 	bl	40e7ec <z_spin_unlock_valid>
  40de18:	72001c1f 	tst	w0, #0xff
  40de1c:	540002a1 	b.ne	40de70 <k_heap_aligned_alloc+0x1cc>  // b.any
  40de20:	90000054 	adrp	x20, 415000 <random_data+0xb30>
  40de24:	91391a94 	add	x20, x20, #0xe46
  40de28:	aa1403e2 	mov	x2, x20
  40de2c:	52801863 	mov	w3, #0xc3                  	// #195
  40de30:	90000041 	adrp	x1, 415000 <random_data+0xb30>
  40de34:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40de38:	913a8021 	add	x1, x1, #0xea0
  40de3c:	9123f800 	add	x0, x0, #0x8fe
  40de40:	97ffe7b3 	bl	407d0c <assert_print>
  40de44:	aa1303e1 	mov	x1, x19
  40de48:	90000040 	adrp	x0, 415000 <random_data+0xb30>
  40de4c:	913adc00 	add	x0, x0, #0xeb7
  40de50:	97ffe7af 	bl	407d0c <assert_print>
  40de54:	aa1403e0 	mov	x0, x20
  40de58:	52801861 	mov	w1, #0xc3                  	// #195
  40de5c:	97ffe7d6 	bl	407db4 <assert_post_action>
  40de60:	52801862 	mov	w2, #0xc3                  	// #195
  40de64:	17ffffb7 	b	40dd40 <k_heap_aligned_alloc+0x9c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  40de68:	910062ba 	add	x26, x21, #0x18
  40de6c:	17ffffe1 	b	40ddf0 <k_heap_aligned_alloc+0x14c>
	posix_irq_unlock(key);
  40de70:	2a1403e0 	mov	w0, w20
  40de74:	97fff0ae 	bl	40a12c <posix_irq_unlock>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
  40de78:	aa1603e0 	mov	x0, x22
  40de7c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40de80:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40de84:	a94363f7 	ldp	x23, x24, [sp, #48]
  40de88:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40de8c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40de90:	d65f03c0 	ret

000000000040de94 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
  40de94:	aa0203e3 	mov	x3, x2
  40de98:	aa0103e2 	mov	x2, x1
  40de9c:	d2800101 	mov	x1, #0x8                   	// #8
  40dea0:	17ffff81 	b	40dca4 <k_heap_aligned_alloc>

000000000040dea4 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
  40dea4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40dea8:	910003fd 	mov	x29, sp
  40deac:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  40deb0:	9100a013 	add	x19, x0, #0x28
{
  40deb4:	aa0003f4 	mov	x20, x0
  40deb8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40debc:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  40dec0:	97fff099 	bl	40a124 <posix_irq_lock>
  40dec4:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40dec8:	aa1303e0 	mov	x0, x19
  40decc:	9400023d 	bl	40e7c0 <z_spin_lock_valid>
  40ded0:	72001c1f 	tst	w0, #0xff
  40ded4:	540002c1 	b.ne	40df2c <k_heap_free+0x88>  // b.any
  40ded8:	90000054 	adrp	x20, 415000 <random_data+0xb30>
  40dedc:	91391a94 	add	x20, x20, #0xe46
  40dee0:	aa1403e2 	mov	x2, x20
  40dee4:	52801283 	mov	w3, #0x94                  	// #148
  40dee8:	90000041 	adrp	x1, 415000 <random_data+0xb30>
  40deec:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40def0:	9139cc21 	add	x1, x1, #0xe73
  40def4:	9123f800 	add	x0, x0, #0x8fe
  40def8:	97ffe785 	bl	407d0c <assert_print>
  40defc:	aa1303e1 	mov	x1, x19
  40df00:	90000040 	adrp	x0, 415000 <random_data+0xb30>
  40df04:	913a2000 	add	x0, x0, #0xe88
  40df08:	97ffe781 	bl	407d0c <assert_print>
  40df0c:	aa1403e0 	mov	x0, x20
  40df10:	52801281 	mov	w1, #0x94                  	// #148
  40df14:	97ffe7a8 	bl	407db4 <assert_post_action>
  40df18:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40df1c:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40df20:	aa1403e1 	mov	x1, x20
  40df24:	9124f000 	add	x0, x0, #0x93c
  40df28:	97fff195 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40df2c:	aa1303e0 	mov	x0, x19
  40df30:	9400023c 	bl	40e820 <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
  40df34:	aa1603e1 	mov	x1, x22
  40df38:	aa1403e0 	mov	x0, x20
  40df3c:	97ffe2c8 	bl	406a5c <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
  40df40:	91006280 	add	x0, x20, #0x18
  40df44:	94000fba 	bl	411e2c <z_unpend_all>
  40df48:	340000e0 	cbz	w0, 40df64 <k_heap_free+0xc0>
		z_reschedule(&h->lock, key);
  40df4c:	2a1503e1 	mov	w1, w21
  40df50:	aa1303e0 	mov	x0, x19
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
  40df54:	a94153f3 	ldp	x19, x20, [sp, #16]
  40df58:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40df5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&h->lock, key);
  40df60:	140009bd 	b	410654 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40df64:	aa1303e0 	mov	x0, x19
  40df68:	94000221 	bl	40e7ec <z_spin_unlock_valid>
  40df6c:	72001c1f 	tst	w0, #0xff
  40df70:	54000261 	b.ne	40dfbc <k_heap_free+0x118>  // b.any
  40df74:	90000054 	adrp	x20, 415000 <random_data+0xb30>
  40df78:	91391a94 	add	x20, x20, #0xe46
  40df7c:	aa1403e2 	mov	x2, x20
  40df80:	52801863 	mov	w3, #0xc3                  	// #195
  40df84:	90000041 	adrp	x1, 415000 <random_data+0xb30>
  40df88:	f0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40df8c:	913a8021 	add	x1, x1, #0xea0
  40df90:	9123f800 	add	x0, x0, #0x8fe
  40df94:	97ffe75e 	bl	407d0c <assert_print>
  40df98:	aa1303e1 	mov	x1, x19
  40df9c:	90000040 	adrp	x0, 415000 <random_data+0xb30>
  40dfa0:	913adc00 	add	x0, x0, #0xeb7
  40dfa4:	97ffe75a 	bl	407d0c <assert_print>
  40dfa8:	aa1403e0 	mov	x0, x20
  40dfac:	52801861 	mov	w1, #0xc3                  	// #195
  40dfb0:	97ffe781 	bl	407db4 <assert_post_action>
  40dfb4:	52801862 	mov	w2, #0xc3                  	// #195
  40dfb8:	17ffffd9 	b	40df1c <k_heap_free+0x78>
	posix_irq_unlock(key);
  40dfbc:	2a1503e0 	mov	w0, w21
}
  40dfc0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dfc4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dfc8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40dfcc:	17fff058 	b	40a12c <posix_irq_unlock>

000000000040dfd0 <create_free_list>:
{
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  40dfd0:	a9420402 	ldp	x2, x1, [x0, #32]
  40dfd4:	aa020022 	orr	x2, x1, x2
  40dfd8:	f240085f 	tst	x2, #0x7
  40dfdc:	540001e1 	b.ne	40e018 <create_free_list+0x48>  // b.any
	}

	slab->free_list = NULL;
	p = slab->buffer;

	for (j = 0U; j < slab->num_blocks; j++) {
  40dfe0:	52800002 	mov	w2, #0x0                   	// #0
	slab->free_list = NULL;
  40dfe4:	f900181f 	str	xzr, [x0, #48]
	for (j = 0U; j < slab->num_blocks; j++) {
  40dfe8:	b9401803 	ldr	w3, [x0, #24]
  40dfec:	6b02007f 	cmp	w3, w2
  40dff0:	54000068 	b.hi	40dffc <create_free_list+0x2c>  // b.pmore
		*(char **)p = slab->free_list;
		slab->free_list = p;
		p += slab->block_size;
	}
	return 0;
  40dff4:	52800000 	mov	w0, #0x0                   	// #0
}
  40dff8:	d65f03c0 	ret
		*(char **)p = slab->free_list;
  40dffc:	f9401803 	ldr	x3, [x0, #48]
  40e000:	f9000023 	str	x3, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
  40e004:	11000442 	add	w2, w2, #0x1
		slab->free_list = p;
  40e008:	f9001801 	str	x1, [x0, #48]
		p += slab->block_size;
  40e00c:	f9401003 	ldr	x3, [x0, #32]
  40e010:	8b030021 	add	x1, x1, x3
	for (j = 0U; j < slab->num_blocks; j++) {
  40e014:	17fffff5 	b	40dfe8 <create_free_list+0x18>
		return -EINVAL;
  40e018:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40e01c:	17fffff7 	b	40dff8 <create_free_list+0x28>

000000000040e020 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
  40e020:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int rc = 0;

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40e024:	b00000e4 	adrp	x4, 42b000 <__FRAME_END__+0xfd74>
  40e028:	b00000e5 	adrp	x5, 42b000 <__FRAME_END__+0xfd74>
{
  40e02c:	910003fd 	mov	x29, sp
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40e030:	f947e484 	ldr	x4, [x4, #4040]
	int rc = 0;
  40e034:	52800000 	mov	w0, #0x0                   	// #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40e038:	f946f8a5 	ldr	x5, [x5, #3568]
{
  40e03c:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40e040:	eb05009f 	cmp	x4, x5
  40e044:	54000349 	b.ls	40e0ac <init_mem_slab_module+0x8c>  // b.plast
  40e048:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40e04c:	910a0a73 	add	x19, x19, #0x282
  40e050:	aa1303e2 	mov	x2, x19
  40e054:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40e058:	910a9c21 	add	x1, x1, #0x2a7
  40e05c:	528007a3 	mov	w3, #0x3d                  	// #61
  40e060:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e064:	9123f800 	add	x0, x0, #0x8fe
  40e068:	97ffe729 	bl	407d0c <assert_print>
  40e06c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e070:	9130fc00 	add	x0, x0, #0xc3f
  40e074:	97ffe726 	bl	407d0c <assert_print>
  40e078:	aa1303e0 	mov	x0, x19
  40e07c:	528007a1 	mov	w1, #0x3d                  	// #61
  40e080:	97ffe74d 	bl	407db4 <assert_post_action>
  40e084:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e088:	aa1303e1 	mov	x1, x19
  40e08c:	9124f000 	add	x0, x0, #0x93c
  40e090:	528007a2 	mov	w2, #0x3d                  	// #61
  40e094:	97fff13a 	bl	40a57c <posix_print_error_and_exit>
		rc = create_free_list(slab);
  40e098:	aa0403e0 	mov	x0, x4
  40e09c:	97ffffcd 	bl	40dfd0 <create_free_list>
		if (rc < 0) {
  40e0a0:	37f80080 	tbnz	w0, #31, 40e0b0 <init_mem_slab_module+0x90>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40e0a4:	91010084 	add	x4, x4, #0x40
  40e0a8:	17ffffe6 	b	40e040 <init_mem_slab_module+0x20>
  40e0ac:	54ffff63 	b.cc	40e098 <init_mem_slab_module+0x78>  // b.lo, b.ul, b.last
		z_object_init(slab);
	}

out:
	return rc;
}
  40e0b0:	f9400bf3 	ldr	x19, [sp, #16]
  40e0b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e0b8:	d65f03c0 	ret

000000000040e0bc <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
  40e0bc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40e0c0:	910003fd 	mov	x29, sp
  40e0c4:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  40e0c8:	91004014 	add	x20, x0, #0x10
{
  40e0cc:	aa0003f3 	mov	x19, x0
  40e0d0:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e0d4:	aa0103f5 	mov	x21, x1
  40e0d8:	f9001bf7 	str	x23, [sp, #48]
  40e0dc:	aa0203f7 	mov	x23, x2
	return posix_irq_lock();
  40e0e0:	97fff011 	bl	40a124 <posix_irq_lock>
  40e0e4:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40e0e8:	aa1403e0 	mov	x0, x20
  40e0ec:	940001b5 	bl	40e7c0 <z_spin_lock_valid>
  40e0f0:	72001c1f 	tst	w0, #0xff
  40e0f4:	540002c1 	b.ne	40e14c <k_mem_slab_alloc+0x90>  // b.any
  40e0f8:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40e0fc:	91391a73 	add	x19, x19, #0xe46
  40e100:	aa1303e2 	mov	x2, x19
  40e104:	52801283 	mov	w3, #0x94                  	// #148
  40e108:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40e10c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e110:	9139cc21 	add	x1, x1, #0xe73
  40e114:	9123f800 	add	x0, x0, #0x8fe
  40e118:	97ffe6fd 	bl	407d0c <assert_print>
  40e11c:	aa1403e1 	mov	x1, x20
  40e120:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40e124:	913a2000 	add	x0, x0, #0xe88
  40e128:	97ffe6f9 	bl	407d0c <assert_print>
  40e12c:	aa1303e0 	mov	x0, x19
  40e130:	52801281 	mov	w1, #0x94                  	// #148
  40e134:	97ffe720 	bl	407db4 <assert_post_action>
  40e138:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e13c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e140:	aa1303e1 	mov	x1, x19
  40e144:	9124f000 	add	x0, x0, #0x93c
  40e148:	97fff10d 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40e14c:	aa1403e0 	mov	x0, x20
  40e150:	940001b4 	bl	40e820 <z_spin_lock_set_owner>
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
  40e154:	f9401a60 	ldr	x0, [x19, #48]
  40e158:	b40003c0 	cbz	x0, 40e1d0 <k_mem_slab_alloc+0x114>
		/* take a free block */
		*mem = slab->free_list;
  40e15c:	f90002a0 	str	x0, [x21]
		slab->free_list = *(char **)(slab->free_list);
  40e160:	f9400000 	ldr	x0, [x0]
  40e164:	f9001a60 	str	x0, [x19, #48]
		slab->num_used++;
  40e168:	b9403a60 	ldr	w0, [x19, #56]
  40e16c:	11000400 	add	w0, w0, #0x1
  40e170:	b9003a60 	str	w0, [x19, #56]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
  40e174:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e178:	aa1403e0 	mov	x0, x20
  40e17c:	9400019c 	bl	40e7ec <z_spin_unlock_valid>
  40e180:	72001c1f 	tst	w0, #0xff
  40e184:	54000521 	b.ne	40e228 <k_mem_slab_alloc+0x16c>  // b.any
  40e188:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40e18c:	91391a73 	add	x19, x19, #0xe46
  40e190:	aa1303e2 	mov	x2, x19
  40e194:	52801863 	mov	w3, #0xc3                  	// #195
  40e198:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40e19c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e1a0:	913a8021 	add	x1, x1, #0xea0
  40e1a4:	9123f800 	add	x0, x0, #0x8fe
  40e1a8:	97ffe6d9 	bl	407d0c <assert_print>
  40e1ac:	aa1403e1 	mov	x1, x20
  40e1b0:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40e1b4:	913adc00 	add	x0, x0, #0xeb7
  40e1b8:	97ffe6d5 	bl	407d0c <assert_print>
  40e1bc:	aa1303e0 	mov	x0, x19
  40e1c0:	52801861 	mov	w1, #0xc3                  	// #195
  40e1c4:	97ffe6fc 	bl	407db4 <assert_post_action>
  40e1c8:	52801862 	mov	w2, #0xc3                  	// #195
  40e1cc:	17ffffdc 	b	40e13c <k_mem_slab_alloc+0x80>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
  40e1d0:	b5000097 	cbnz	x23, 40e1e0 <k_mem_slab_alloc+0x124>
		   !IS_ENABLED(CONFIG_MULTITHREADING)) {
		/* don't wait for a free block to become available */
		*mem = NULL;
		result = -ENOMEM;
  40e1d4:	12800173 	mov	w19, #0xfffffff4            	// #-12
		*mem = NULL;
  40e1d8:	f90002bf 	str	xzr, [x21]
		result = -ENOMEM;
  40e1dc:	17ffffe7 	b	40e178 <k_mem_slab_alloc+0xbc>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);

		/* wait for a free block or timeout */
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
  40e1e0:	aa1303e2 	mov	x2, x19
  40e1e4:	aa1703e3 	mov	x3, x23
  40e1e8:	2a1603e1 	mov	w1, w22
  40e1ec:	aa1403e0 	mov	x0, x20
  40e1f0:	94000cbd 	bl	4114e4 <z_pend_curr>
  40e1f4:	2a0003f3 	mov	w19, w0
		if (result == 0) {
  40e1f8:	350000c0 	cbnz	w0, 40e210 <k_mem_slab_alloc+0x154>
			*mem = _current->base.swap_data;
  40e1fc:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40e200:	f9473000 	ldr	x0, [x0, #3680]
  40e204:	f9400800 	ldr	x0, [x0, #16]
  40e208:	f9401000 	ldr	x0, [x0, #32]
  40e20c:	f90002a0 	str	x0, [x21]
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
  40e210:	2a1303e0 	mov	w0, w19
  40e214:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e218:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e21c:	f9401bf7 	ldr	x23, [sp, #48]
  40e220:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40e224:	d65f03c0 	ret
	posix_irq_unlock(key);
  40e228:	2a1603e0 	mov	w0, w22
  40e22c:	97ffefc0 	bl	40a12c <posix_irq_unlock>
	return result;
  40e230:	17fffff8 	b	40e210 <k_mem_slab_alloc+0x154>

000000000040e234 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
  40e234:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40e238:	910003fd 	mov	x29, sp
  40e23c:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  40e240:	91004014 	add	x20, x0, #0x10
{
  40e244:	aa0003f3 	mov	x19, x0
  40e248:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e24c:	aa0103f5 	mov	x21, x1
	return posix_irq_lock();
  40e250:	97ffefb5 	bl	40a124 <posix_irq_lock>
  40e254:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40e258:	aa1403e0 	mov	x0, x20
  40e25c:	94000159 	bl	40e7c0 <z_spin_lock_valid>
  40e260:	72001c1f 	tst	w0, #0xff
  40e264:	540002c1 	b.ne	40e2bc <k_mem_slab_free+0x88>  // b.any
  40e268:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40e26c:	91391a73 	add	x19, x19, #0xe46
  40e270:	aa1303e2 	mov	x2, x19
  40e274:	52801283 	mov	w3, #0x94                  	// #148
  40e278:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40e27c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e280:	9139cc21 	add	x1, x1, #0xe73
  40e284:	9123f800 	add	x0, x0, #0x8fe
  40e288:	97ffe6a1 	bl	407d0c <assert_print>
  40e28c:	aa1403e1 	mov	x1, x20
  40e290:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40e294:	913a2000 	add	x0, x0, #0xe88
  40e298:	97ffe69d 	bl	407d0c <assert_print>
  40e29c:	aa1303e0 	mov	x0, x19
  40e2a0:	52801281 	mov	w1, #0x94                  	// #148
  40e2a4:	97ffe6c4 	bl	407db4 <assert_post_action>
  40e2a8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e2ac:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e2b0:	aa1303e1 	mov	x1, x19
  40e2b4:	9124f000 	add	x0, x0, #0x93c
  40e2b8:	97fff0b1 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40e2bc:	aa1403e0 	mov	x0, x20
  40e2c0:	94000158 	bl	40e820 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
  40e2c4:	f9401a60 	ldr	x0, [x19, #48]
  40e2c8:	b50001c0 	cbnz	x0, 40e300 <k_mem_slab_free+0xcc>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
  40e2cc:	aa1303e0 	mov	x0, x19
  40e2d0:	94000e8d 	bl	411d04 <z_unpend_first_thread>

		if (pending_thread != NULL) {
  40e2d4:	b4000160 	cbz	x0, 40e300 <k_mem_slab_free+0xcc>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
  40e2d8:	f94002a1 	ldr	x1, [x21]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
  40e2dc:	f9001001 	str	x1, [x0, #32]
	thread->callee_saved.retval = value;
  40e2e0:	b9004c1f 	str	wzr, [x0, #76]
			z_ready_thread(pending_thread);
  40e2e4:	94000b37 	bl	410fc0 <z_ready_thread>
			z_reschedule(&slab->lock, key);
  40e2e8:	2a1603e1 	mov	w1, w22
  40e2ec:	aa1403e0 	mov	x0, x20
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
  40e2f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e2f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e2f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
			z_reschedule(&slab->lock, key);
  40e2fc:	140008d6 	b	410654 <z_reschedule>
	**(char ***) mem = slab->free_list;
  40e300:	f94002a0 	ldr	x0, [x21]
  40e304:	f9401a61 	ldr	x1, [x19, #48]
  40e308:	f9000001 	str	x1, [x0]
	slab->free_list = *(char **) mem;
  40e30c:	f94002a0 	ldr	x0, [x21]
  40e310:	f9001a60 	str	x0, [x19, #48]
	slab->num_used--;
  40e314:	b9403a60 	ldr	w0, [x19, #56]
  40e318:	51000400 	sub	w0, w0, #0x1
  40e31c:	b9003a60 	str	w0, [x19, #56]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e320:	aa1403e0 	mov	x0, x20
  40e324:	94000132 	bl	40e7ec <z_spin_unlock_valid>
  40e328:	72001c1f 	tst	w0, #0xff
  40e32c:	54000261 	b.ne	40e378 <k_mem_slab_free+0x144>  // b.any
  40e330:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40e334:	91391a73 	add	x19, x19, #0xe46
  40e338:	aa1303e2 	mov	x2, x19
  40e33c:	52801863 	mov	w3, #0xc3                  	// #195
  40e340:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40e344:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e348:	913a8021 	add	x1, x1, #0xea0
  40e34c:	9123f800 	add	x0, x0, #0x8fe
  40e350:	97ffe66f 	bl	407d0c <assert_print>
  40e354:	aa1403e1 	mov	x1, x20
  40e358:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40e35c:	913adc00 	add	x0, x0, #0xeb7
  40e360:	97ffe66b 	bl	407d0c <assert_print>
  40e364:	aa1303e0 	mov	x0, x19
  40e368:	52801861 	mov	w1, #0xc3                  	// #195
  40e36c:	97ffe692 	bl	407db4 <assert_post_action>
  40e370:	52801862 	mov	w2, #0xc3                  	// #195
  40e374:	17ffffce 	b	40e2ac <k_mem_slab_free+0x78>
	posix_irq_unlock(key);
  40e378:	2a1603e0 	mov	w0, w22
}
  40e37c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e380:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e384:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40e388:	17ffef69 	b	40a12c <posix_irq_unlock>

000000000040e38c <k_is_in_isr>:
	return _kernel.cpus[0].nested != 0U;
  40e38c:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40e390:	f9473000 	ldr	x0, [x0, #3680]
  40e394:	b9400000 	ldr	w0, [x0]
  40e398:	7100001f 	cmp	w0, #0x0
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
  40e39c:	1a9f07e0 	cset	w0, ne  // ne = any
  40e3a0:	d65f03c0 	ret

000000000040e3a4 <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
  40e3a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e3a8:	910003fd 	mov	x29, sp
  40e3ac:	f9000bf3 	str	x19, [sp, #16]
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
  40e3b0:	b5000180 	cbnz	x0, 40e3e0 <z_impl_k_thread_name_set+0x3c>
		thread = _current;
  40e3b4:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40e3b8:	f9473000 	ldr	x0, [x0, #3680]
  40e3bc:	f9400813 	ldr	x19, [x0, #16]

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len,
  40e3c0:	91022660 	add	x0, x19, #0x89
  40e3c4:	d28003e2 	mov	x2, #0x1f                  	// #31
  40e3c8:	97ffcc22 	bl	401450 <strncpy@plt>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  40e3cc:	3902a27f 	strb	wzr, [x19, #168]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
  40e3d0:	52800000 	mov	w0, #0x0                   	// #0
  40e3d4:	f9400bf3 	ldr	x19, [sp, #16]
  40e3d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e3dc:	d65f03c0 	ret
  40e3e0:	aa0003f3 	mov	x19, x0
  40e3e4:	17fffff7 	b	40e3c0 <z_impl_k_thread_name_set+0x1c>

000000000040e3e8 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
  40e3e8:	91022400 	add	x0, x0, #0x89
  40e3ec:	d65f03c0 	ret

000000000040e3f0 <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
  40e3f0:	14000b35 	b	4110c4 <z_sched_start>

000000000040e3f4 <z_init_thread_base>:

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
  40e3f4:	f900081f 	str	xzr, [x0, #16]
	thread_base->user_options = (uint8_t)options;
  40e3f8:	39006003 	strb	w3, [x0, #24]
	thread_base->thread_state = (uint8_t)initial_state;
  40e3fc:	39006402 	strb	w2, [x0, #25]

	thread_base->prio = priority;
  40e400:	39006801 	strb	w1, [x0, #26]

	thread_base->sched_locked = 0U;
  40e404:	39006c1f 	strb	wzr, [x0, #27]
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
  40e408:	a902fc1f 	stp	xzr, xzr, [x0, #40]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
  40e40c:	d65f03c0 	ret

000000000040e410 <z_setup_new_thread>:
{
  40e410:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40e414:	910003fd 	mov	x29, sp
  40e418:	a90153f3 	stp	x19, x20, [sp, #16]
  40e41c:	aa0003f3 	mov	x19, x0
  40e420:	aa0203f4 	mov	x20, x2
  40e424:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e428:	aa0103f6 	mov	x22, x1
  40e42c:	2a0703f5 	mov	w21, w7
  40e430:	a90363f7 	stp	x23, x24, [sp, #48]
  40e434:	aa0303f7 	mov	x23, x3
  40e438:	aa0403f8 	mov	x24, x4
  40e43c:	a9046bf9 	stp	x25, x26, [sp, #64]
  40e440:	aa0503fa 	mov	x26, x5
  40e444:	f9002bfb 	str	x27, [sp, #80]
  40e448:	aa0603fb 	mov	x27, x6
  40e44c:	f94037f9 	ldr	x25, [sp, #104]
	Z_ASSERT_VALID_PRIO(prio, entry);
  40e450:	71003cff 	cmp	w7, #0xf
  40e454:	540005a1 	b.ne	40e508 <z_setup_new_thread+0xf8>  // b.any
  40e458:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40e45c:	f9475000 	ldr	x0, [x0, #3744]
  40e460:	eb00007f 	cmp	x3, x0
  40e464:	54000581 	b.ne	40e514 <z_setup_new_thread+0x104>  // b.any
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e468:	b94063e3 	ldr	w3, [sp, #96]
  40e46c:	91018260 	add	x0, x19, #0x60
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  40e470:	91001e94 	add	x20, x20, #0x7
	list->tail = (sys_dnode_t *)list;
  40e474:	a9060260 	stp	x0, x0, [x19, #96]
  40e478:	927df294 	and	x20, x20, #0xfffffffffffffff8
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e47c:	2a1503e1 	mov	w1, w21
  40e480:	aa1303e0 	mov	x0, x19
  40e484:	52800082 	mov	w2, #0x4                   	// #4
	stack_ptr = (char *)stack + stack_obj_size;
  40e488:	8b1402d4 	add	x20, x22, x20
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e48c:	97ffffda 	bl	40e3f4 <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  40e490:	aa1b03e6 	mov	x6, x27
  40e494:	aa1a03e5 	mov	x5, x26
  40e498:	aa1803e4 	mov	x4, x24
  40e49c:	aa1703e3 	mov	x3, x23
  40e4a0:	aa1403e2 	mov	x2, x20
  40e4a4:	aa1603e1 	mov	x1, x22
  40e4a8:	aa1303e0 	mov	x0, x19
  40e4ac:	97ffec13 	bl	4094f8 <arch_new_thread>
	new_thread->init_data = NULL;
  40e4b0:	f9002e7f 	str	xzr, [x19, #88]
	new_thread->no_wake_on_timeout = false;
  40e4b4:	3902227f 	strb	wzr, [x19, #136]
	if (name != NULL) {
  40e4b8:	b40005d9 	cbz	x25, 40e570 <z_setup_new_thread+0x160>
  40e4bc:	aa1903e1 	mov	x1, x25
  40e4c0:	91022660 	add	x0, x19, #0x89
  40e4c4:	d28003e2 	mov	x2, #0x1f                  	// #31
  40e4c8:	97ffcbe2 	bl	401450 <strncpy@plt>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  40e4cc:	3902a27f 	strb	wzr, [x19, #168]
	if (!_current) {
  40e4d0:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40e4d4:	f9473000 	ldr	x0, [x0, #3680]
  40e4d8:	f9400800 	ldr	x0, [x0, #16]
  40e4dc:	b4000040 	cbz	x0, 40e4e4 <z_setup_new_thread+0xd4>
	new_thread->resource_pool = _current->resource_pool;
  40e4e0:	f9405800 	ldr	x0, [x0, #176]
	return stack_ptr;
  40e4e4:	f9005a60 	str	x0, [x19, #176]
}
  40e4e8:	aa1403e0 	mov	x0, x20
  40e4ec:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e4f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e4f4:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e4f8:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40e4fc:	f9402bfb 	ldr	x27, [sp, #80]
  40e500:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40e504:	d65f03c0 	ret
	Z_ASSERT_VALID_PRIO(prio, entry);
  40e508:	110040e0 	add	w0, w7, #0x10
  40e50c:	7100781f 	cmp	w0, #0x1e
  40e510:	54fffac9 	b.ls	40e468 <z_setup_new_thread+0x58>  // b.plast
  40e514:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40e518:	910b1273 	add	x19, x19, #0x2c4
  40e51c:	aa1303e2 	mov	x2, x19
  40e520:	52804343 	mov	w3, #0x21a                 	// #538
  40e524:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40e528:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e52c:	910b9c21 	add	x1, x1, #0x2e7
  40e530:	9123f800 	add	x0, x0, #0x8fe
  40e534:	97ffe5f6 	bl	407d0c <assert_print>
  40e538:	528001c2 	mov	w2, #0xe                   	// #14
  40e53c:	128001e3 	mov	w3, #0xfffffff0            	// #-16
  40e540:	2a1503e1 	mov	w1, w21
  40e544:	90000040 	adrp	x0, 416000 <__func__.0+0x9cb>
  40e548:	910d9c00 	add	x0, x0, #0x367
  40e54c:	97ffe5f0 	bl	407d0c <assert_print>
  40e550:	aa1303e0 	mov	x0, x19
  40e554:	52804341 	mov	w1, #0x21a                 	// #538
  40e558:	97ffe617 	bl	407db4 <assert_post_action>
  40e55c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e560:	aa1303e1 	mov	x1, x19
  40e564:	9124f000 	add	x0, x0, #0x93c
  40e568:	52804342 	mov	w2, #0x21a                 	// #538
  40e56c:	97fff004 	bl	40a57c <posix_print_error_and_exit>
		new_thread->name[0] = '\0';
  40e570:	3902267f 	strb	wzr, [x19, #137]
  40e574:	17ffffd7 	b	40e4d0 <z_setup_new_thread+0xc0>

000000000040e578 <z_impl_k_thread_create>:
{
  40e578:	d100c3ff 	sub	sp, sp, #0x30
  40e57c:	b00000e8 	adrp	x8, 42b000 <__FRAME_END__+0xfd74>
  40e580:	a9017bfd 	stp	x29, x30, [sp, #16]
  40e584:	910043fd 	add	x29, sp, #0x10
  40e588:	f9473108 	ldr	x8, [x8, #3680]
  40e58c:	a90253f3 	stp	x19, x20, [sp, #32]
  40e590:	f9401ff4 	ldr	x20, [sp, #56]
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
  40e594:	b9400108 	ldr	w8, [x8]
  40e598:	340002a8 	cbz	w8, 40e5ec <z_impl_k_thread_create+0x74>
  40e59c:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40e5a0:	910b1273 	add	x19, x19, #0x2c4
  40e5a4:	aa1303e2 	mov	x2, x19
  40e5a8:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40e5ac:	910e6021 	add	x1, x1, #0x398
  40e5b0:	52805183 	mov	w3, #0x28c                 	// #652
  40e5b4:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e5b8:	9123f800 	add	x0, x0, #0x8fe
  40e5bc:	97ffe5d4 	bl	407d0c <assert_print>
  40e5c0:	90000040 	adrp	x0, 416000 <__func__.0+0x9cb>
  40e5c4:	910ea800 	add	x0, x0, #0x3aa
  40e5c8:	97ffe5d1 	bl	407d0c <assert_print>
  40e5cc:	aa1303e0 	mov	x0, x19
  40e5d0:	52805181 	mov	w1, #0x28c                 	// #652
  40e5d4:	97ffe5f8 	bl	407db4 <assert_post_action>
  40e5d8:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e5dc:	aa1303e1 	mov	x1, x19
  40e5e0:	9124f000 	add	x0, x0, #0x93c
  40e5e4:	52805182 	mov	w2, #0x28c                 	// #652
  40e5e8:	97ffefe5 	bl	40a57c <posix_print_error_and_exit>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  40e5ec:	b94033e8 	ldr	w8, [sp, #48]
  40e5f0:	aa0003f3 	mov	x19, x0
  40e5f4:	b90003e8 	str	w8, [sp]
  40e5f8:	f90007ff 	str	xzr, [sp, #8]
  40e5fc:	97ffff85 	bl	40e410 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  40e600:	b100069f 	cmn	x20, #0x1
  40e604:	54000080 	b.eq	40e614 <z_impl_k_thread_create+0x9c>  // b.none
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  40e608:	b5000114 	cbnz	x20, 40e628 <z_impl_k_thread_create+0xb0>
	z_impl_k_thread_start(thread);
  40e60c:	aa1303e0 	mov	x0, x19
  40e610:	97ffff78 	bl	40e3f0 <z_impl_k_thread_start>
}
  40e614:	aa1303e0 	mov	x0, x19
  40e618:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40e61c:	a94253f3 	ldp	x19, x20, [sp, #32]
  40e620:	9100c3ff 	add	sp, sp, #0x30
  40e624:	d65f03c0 	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  40e628:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40e62c:	aa1403e2 	mov	x2, x20
  40e630:	9100a260 	add	x0, x19, #0x28
  40e634:	f9472821 	ldr	x1, [x1, #3664]
  40e638:	94001130 	bl	412af8 <z_add_timeout>
  40e63c:	17fffff6 	b	40e614 <z_impl_k_thread_create+0x9c>

000000000040e640 <z_init_static_threads>:
{
  40e640:	d10103ff 	sub	sp, sp, #0x40
	_FOREACH_STATIC_THREAD(thread_data) {
  40e644:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
{
  40e648:	a9017bfd 	stp	x29, x30, [sp, #16]
  40e64c:	910043fd 	add	x29, sp, #0x10
  40e650:	a90253f3 	stp	x19, x20, [sp, #32]
  40e654:	aa0003f4 	mov	x20, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  40e658:	f9479813 	ldr	x19, [x0, #3888]
  40e65c:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
{
  40e660:	a9035bf5 	stp	x21, x22, [sp, #48]
  40e664:	aa0003f5 	mov	x21, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  40e668:	f9471816 	ldr	x22, [x0, #3632]
  40e66c:	eb16027f 	cmp	x19, x22
  40e670:	54000469 	b.ls	40e6fc <z_init_static_threads+0xbc>  // b.plast
  40e674:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40e678:	910b1273 	add	x19, x19, #0x2c4
  40e67c:	aa1303e2 	mov	x2, x19
  40e680:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40e684:	910f3c21 	add	x1, x1, #0x3cf
  40e688:	52805e63 	mov	w3, #0x2f3                 	// #755
  40e68c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e690:	9123f800 	add	x0, x0, #0x8fe
  40e694:	97ffe59e 	bl	407d0c <assert_print>
  40e698:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e69c:	9130fc00 	add	x0, x0, #0xc3f
  40e6a0:	97ffe59b 	bl	407d0c <assert_print>
  40e6a4:	aa1303e0 	mov	x0, x19
  40e6a8:	52805e61 	mov	w1, #0x2f3                 	// #755
  40e6ac:	97ffe5c2 	bl	407db4 <assert_post_action>
  40e6b0:	52805e62 	mov	w2, #0x2f3                 	// #755
	_FOREACH_STATIC_THREAD(thread_data) {
  40e6b4:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e6b8:	aa1303e1 	mov	x1, x19
  40e6bc:	9124f000 	add	x0, x0, #0x93c
  40e6c0:	97ffefaf 	bl	40a57c <posix_print_error_and_exit>
		z_setup_new_thread(
  40e6c4:	f9402660 	ldr	x0, [x19, #72]
  40e6c8:	b9401262 	ldr	w2, [x19, #16]
  40e6cc:	f90007e0 	str	x0, [sp, #8]
  40e6d0:	b9403e60 	ldr	w0, [x19, #60]
  40e6d4:	b90003e0 	str	w0, [sp]
  40e6d8:	a9400660 	ldp	x0, x1, [x19]
  40e6dc:	a9419263 	ldp	x3, x4, [x19, #24]
  40e6e0:	a9429a65 	ldp	x5, x6, [x19, #40]
  40e6e4:	b9403a67 	ldr	w7, [x19, #56]
  40e6e8:	97ffff4a 	bl	40e410 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  40e6ec:	f9400260 	ldr	x0, [x19]
  40e6f0:	f9002c13 	str	x19, [x0, #88]
	_FOREACH_STATIC_THREAD(thread_data) {
  40e6f4:	91014273 	add	x19, x19, #0x50
  40e6f8:	17ffffdd 	b	40e66c <z_init_static_threads+0x2c>
  40e6fc:	54fffe43 	b.cc	40e6c4 <z_init_static_threads+0x84>  // b.lo, b.ul, b.last
	k_sched_lock();
  40e700:	94000826 	bl	410798 <k_sched_lock>
  40e704:	d2800156 	mov	x22, #0xa                   	// #10
	_FOREACH_STATIC_THREAD(thread_data) {
  40e708:	f9479a93 	ldr	x19, [x20, #3888]
  40e70c:	f9471ab4 	ldr	x20, [x21, #3632]
  40e710:	b00000f5 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
  40e714:	f9472ab5 	ldr	x21, [x21, #3664]
  40e718:	eb14027f 	cmp	x19, x20
  40e71c:	54000469 	b.ls	40e7a8 <z_init_static_threads+0x168>  // b.plast
  40e720:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40e724:	910b1273 	add	x19, x19, #0x2c4
  40e728:	aa1303e2 	mov	x2, x19
  40e72c:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40e730:	910f3c21 	add	x1, x1, #0x3cf
  40e734:	52806243 	mov	w3, #0x312                 	// #786
  40e738:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e73c:	9123f800 	add	x0, x0, #0x8fe
  40e740:	97ffe573 	bl	407d0c <assert_print>
  40e744:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e748:	9130fc00 	add	x0, x0, #0xc3f
  40e74c:	97ffe570 	bl	407d0c <assert_print>
  40e750:	aa1303e0 	mov	x0, x19
  40e754:	52806241 	mov	w1, #0x312                 	// #786
  40e758:	97ffe597 	bl	407db4 <assert_post_action>
  40e75c:	52806242 	mov	w2, #0x312                 	// #786
  40e760:	17ffffd5 	b	40e6b4 <z_init_static_threads+0x74>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
  40e764:	b9404262 	ldr	w2, [x19, #64]
  40e768:	3100045f 	cmn	w2, #0x1
  40e76c:	54000100 	b.eq	40e78c <z_init_static_threads+0x14c>  // b.none
					    K_MSEC(thread_data->init_delay));
  40e770:	7100005f 	cmp	w2, #0x0
  40e774:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
  40e778:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
  40e77c:	93407c43 	sxtw	x3, w2
		t += off;
  40e780:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  40e784:	b5000083 	cbnz	x3, 40e794 <z_init_static_threads+0x154>
  40e788:	97ffff1a 	bl	40e3f0 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
  40e78c:	91014273 	add	x19, x19, #0x50
  40e790:	17ffffe2 	b	40e718 <z_init_static_threads+0xd8>
  40e794:	9ad60842 	udiv	x2, x2, x22
  40e798:	aa1503e1 	mov	x1, x21
  40e79c:	9100a000 	add	x0, x0, #0x28
  40e7a0:	940010d6 	bl	412af8 <z_add_timeout>
  40e7a4:	17fffffa 	b	40e78c <z_init_static_threads+0x14c>
  40e7a8:	54fffde3 	b.cc	40e764 <z_init_static_threads+0x124>  // b.lo, b.ul, b.last
}
  40e7ac:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40e7b0:	a94253f3 	ldp	x19, x20, [sp, #32]
  40e7b4:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40e7b8:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
  40e7bc:	14000c9f 	b	411a38 <k_sched_unlock>

000000000040e7c0 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
  40e7c0:	f9400000 	ldr	x0, [x0]

	if (thread_cpu != 0U) {
  40e7c4:	b4000100 	cbz	x0, 40e7e4 <z_spin_lock_valid+0x24>
		if ((thread_cpu & 3U) == _current_cpu->id) {
  40e7c8:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40e7cc:	92400400 	and	x0, x0, #0x3
  40e7d0:	f9473021 	ldr	x1, [x1, #3680]
  40e7d4:	39408021 	ldrb	w1, [x1, #32]
  40e7d8:	eb01001f 	cmp	x0, x1
  40e7dc:	1a9f07e0 	cset	w0, ne  // ne = any
			return false;
		}
	}
	return true;
}
  40e7e0:	d65f03c0 	ret
	return true;
  40e7e4:	52800020 	mov	w0, #0x1                   	// #1
  40e7e8:	17fffffe 	b	40e7e0 <z_spin_lock_valid+0x20>

000000000040e7ec <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
  40e7ec:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40e7f0:	f9473021 	ldr	x1, [x1, #3680]
  40e7f4:	39408022 	ldrb	w2, [x1, #32]
  40e7f8:	f9400821 	ldr	x1, [x1, #16]
  40e7fc:	aa020021 	orr	x1, x1, x2
  40e800:	f9400002 	ldr	x2, [x0]
  40e804:	eb01005f 	cmp	x2, x1
  40e808:	54000081 	b.ne	40e818 <z_spin_unlock_valid+0x2c>  // b.any
		return false;
	}
	l->thread_cpu = 0;
  40e80c:	f900001f 	str	xzr, [x0]
	return true;
  40e810:	52800020 	mov	w0, #0x1                   	// #1
}
  40e814:	d65f03c0 	ret
		return false;
  40e818:	52800000 	mov	w0, #0x0                   	// #0
  40e81c:	17fffffe 	b	40e814 <z_spin_unlock_valid+0x28>

000000000040e820 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
  40e820:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  40e824:	f9473021 	ldr	x1, [x1, #3680]
  40e828:	39408022 	ldrb	w2, [x1, #32]
  40e82c:	f9400821 	ldr	x1, [x1, #16]
  40e830:	aa020021 	orr	x1, x1, x2
  40e834:	f9000001 	str	x1, [x0]
}
  40e838:	d65f03c0 	ret

000000000040e83c <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
  40e83c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e840:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
{
  40e844:	910003fd 	mov	x29, sp
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e848:	f9473000 	ldr	x0, [x0, #3680]
{
  40e84c:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e850:	f9400800 	ldr	x0, [x0, #16]
  40e854:	39c06800 	ldrsb	w0, [x0, #26]
  40e858:	36f80240 	tbz	w0, #31, 40e8a0 <idle+0x64>
  40e85c:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40e860:	910ff273 	add	x19, x19, #0x3fc
  40e864:	aa1303e2 	mov	x2, x19
  40e868:	52800523 	mov	w3, #0x29                  	// #41
  40e86c:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40e870:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e874:	91107421 	add	x1, x1, #0x41d
  40e878:	9123f800 	add	x0, x0, #0x8fe
  40e87c:	97ffe524 	bl	407d0c <assert_print>
  40e880:	aa1303e0 	mov	x0, x19
  40e884:	52800521 	mov	w1, #0x29                  	// #41
  40e888:	97ffe54b 	bl	407db4 <assert_post_action>
  40e88c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e890:	aa1303e1 	mov	x1, x19
  40e894:	9124f000 	add	x0, x0, #0x93c
  40e898:	52800522 	mov	w2, #0x29                  	// #41
  40e89c:	97ffef38 	bl	40a57c <posix_print_error_and_exit>
	return posix_irq_lock();
  40e8a0:	97ffee21 	bl	40a124 <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
  40e8a4:	97ffe98d 	bl	408ed8 <arch_cpu_idle>
  40e8a8:	17fffffe 	b	40e8a0 <idle+0x64>

000000000040e8ac <k_msgq_init>:

void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
		 uint32_t max_msgs)
{
	msgq->msg_size = msg_size;
	msgq->max_msgs = max_msgs;
  40e8ac:	b9002003 	str	w3, [x0, #32]
	msgq->buffer_start = buffer;
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e8b0:	2a0303e3 	mov	w3, w3
	msgq->msg_size = msg_size;
  40e8b4:	a901081f 	stp	xzr, x2, [x0, #16]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e8b8:	9b020462 	madd	x2, x3, x2, x1
  40e8bc:	a9000000 	stp	x0, x0, [x0]
	msgq->buffer_start = buffer;
  40e8c0:	f9001401 	str	x1, [x0, #40]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e8c4:	f9001802 	str	x2, [x0, #48]
	msgq->read_ptr = buffer;
	msgq->write_ptr = buffer;
  40e8c8:	a9038401 	stp	x1, x1, [x0, #56]
	msgq->used_msgs = 0;
	msgq->flags = 0;
	z_waitq_init(&msgq->wait_q);
	msgq->lock = (struct k_spinlock) {};
#ifdef CONFIG_POLL
	sys_dlist_init(&msgq->poll_events);
  40e8cc:	91014001 	add	x1, x0, #0x50
	msgq->used_msgs = 0;
  40e8d0:	b900481f 	str	wzr, [x0, #72]
  40e8d4:	a9050401 	stp	x1, x1, [x0, #80]
	msgq->flags = 0;
  40e8d8:	3901801f 	strb	wzr, [x0, #96]
#endif	/* CONFIG_POLL */

	SYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);

	z_object_init(msgq);
}
  40e8dc:	d65f03c0 	ret

000000000040e8e0 <k_msgq_cleanup>:
}
#include <syscalls/k_msgq_alloc_init_mrsh.c>
#endif

int k_msgq_cleanup(struct k_msgq *msgq)
{
  40e8e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e8e4:	910003fd 	mov	x29, sp
  40e8e8:	f9000bf3 	str	x19, [sp, #16]
  40e8ec:	aa0003f3 	mov	x19, x0
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  40e8f0:	f9400000 	ldr	x0, [x0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40e8f4:	eb00027f 	cmp	x19, x0
  40e8f8:	54000040 	b.eq	40e900 <k_msgq_cleanup+0x20>  // b.none
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);

	CHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {
  40e8fc:	b5000140 	cbnz	x0, 40e924 <k_msgq_cleanup+0x44>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, -EBUSY);

		return -EBUSY;
	}

	if ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {
  40e900:	39418260 	ldrb	w0, [x19, #96]
  40e904:	360000c0 	tbz	w0, #0, 40e91c <k_msgq_cleanup+0x3c>
		k_free(msgq->buffer_start);
  40e908:	f9401660 	ldr	x0, [x19, #40]
  40e90c:	94001334 	bl	4135dc <k_free>
		msgq->flags &= ~K_MSGQ_FLAG_ALLOC;
  40e910:	39418260 	ldrb	w0, [x19, #96]
  40e914:	121f7800 	and	w0, w0, #0xfffffffe
  40e918:	39018260 	strb	w0, [x19, #96]
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, 0);

	return 0;
  40e91c:	52800000 	mov	w0, #0x0                   	// #0
  40e920:	14000002 	b	40e928 <k_msgq_cleanup+0x48>
		return -EBUSY;
  40e924:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
  40e928:	f9400bf3 	ldr	x19, [sp, #16]
  40e92c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e930:	d65f03c0 	ret

000000000040e934 <z_impl_k_msgq_put>:


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
  40e934:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40e938:	910003fd 	mov	x29, sp
  40e93c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e940:	aa0203f5 	mov	x21, x2
  40e944:	b00000e2 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
  40e948:	a90153f3 	stp	x19, x20, [sp, #16]
  40e94c:	aa0003f3 	mov	x19, x0
  40e950:	f9473040 	ldr	x0, [x2, #3680]
  40e954:	a90363f7 	stp	x23, x24, [sp, #48]
  40e958:	aa0103f7 	mov	x23, x1
  40e95c:	aa0203f8 	mov	x24, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40e960:	b9400000 	ldr	w0, [x0]
  40e964:	340002c0 	cbz	w0, 40e9bc <z_impl_k_msgq_put+0x88>
  40e968:	b40002b5 	cbz	x21, 40e9bc <z_impl_k_msgq_put+0x88>
  40e96c:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40e970:	91111673 	add	x19, x19, #0x445
  40e974:	aa1303e2 	mov	x2, x19
  40e978:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40e97c:	9108f021 	add	x1, x1, #0x23c
  40e980:	52800ec3 	mov	w3, #0x76                  	// #118
  40e984:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e988:	9123f800 	add	x0, x0, #0x8fe
  40e98c:	97ffe4e0 	bl	407d0c <assert_print>
  40e990:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40e994:	913b7400 	add	x0, x0, #0xedd
  40e998:	97ffe4dd 	bl	407d0c <assert_print>
  40e99c:	aa1303e0 	mov	x0, x19
  40e9a0:	52800ec1 	mov	w1, #0x76                  	// #118
  40e9a4:	97ffe504 	bl	407db4 <assert_post_action>
  40e9a8:	52800ec2 	mov	w2, #0x76                  	// #118
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40e9ac:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e9b0:	aa1303e1 	mov	x1, x19
  40e9b4:	9124f000 	add	x0, x0, #0x93c
  40e9b8:	97ffeef1 	bl	40a57c <posix_print_error_and_exit>
  40e9bc:	97ffedda 	bl	40a124 <posix_irq_lock>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
  40e9c0:	91004274 	add	x20, x19, #0x10
  40e9c4:	2a0003f6 	mov	w22, w0
  40e9c8:	aa1403e0 	mov	x0, x20
  40e9cc:	97ffff7d 	bl	40e7c0 <z_spin_lock_valid>
  40e9d0:	72001c1f 	tst	w0, #0xff
  40e9d4:	54000261 	b.ne	40ea20 <z_impl_k_msgq_put+0xec>  // b.any
  40e9d8:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40e9dc:	91391a73 	add	x19, x19, #0xe46
  40e9e0:	aa1303e2 	mov	x2, x19
  40e9e4:	52801283 	mov	w3, #0x94                  	// #148
  40e9e8:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40e9ec:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40e9f0:	9139cc21 	add	x1, x1, #0xe73
  40e9f4:	9123f800 	add	x0, x0, #0x8fe
  40e9f8:	97ffe4c5 	bl	407d0c <assert_print>
  40e9fc:	aa1403e1 	mov	x1, x20
  40ea00:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40ea04:	913a2000 	add	x0, x0, #0xe88
  40ea08:	97ffe4c1 	bl	407d0c <assert_print>
  40ea0c:	aa1303e0 	mov	x0, x19
  40ea10:	52801281 	mov	w1, #0x94                  	// #148
  40ea14:	97ffe4e8 	bl	407db4 <assert_post_action>
  40ea18:	52801282 	mov	w2, #0x94                  	// #148
  40ea1c:	17ffffe4 	b	40e9ac <z_impl_k_msgq_put+0x78>
	z_spin_lock_set_owner(l);
  40ea20:	aa1403e0 	mov	x0, x20
  40ea24:	97ffff7f 	bl	40e820 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
  40ea28:	b9402260 	ldr	w0, [x19, #32]
  40ea2c:	b9404a61 	ldr	w1, [x19, #72]
  40ea30:	6b00003f 	cmp	w1, w0
  40ea34:	54000a82 	b.cs	40eb84 <z_impl_k_msgq_put+0x250>  // b.hs, b.nlast
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  40ea38:	aa1303e0 	mov	x0, x19
  40ea3c:	94000cb2 	bl	411d04 <z_unpend_first_thread>
  40ea40:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  40ea44:	b4000240 	cbz	x0, 40ea8c <z_impl_k_msgq_put+0x158>
  return __builtin___memcpy_chk (__dest, __src, __len,
  40ea48:	f9400e62 	ldr	x2, [x19, #24]
  40ea4c:	aa1703e1 	mov	x1, x23
  40ea50:	f9401000 	ldr	x0, [x0, #32]
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
  40ea54:	52800013 	mov	w19, #0x0                   	// #0
  40ea58:	97ffc9c6 	bl	401170 <memcpy@plt>
	thread->callee_saved.retval = value;
  40ea5c:	b9004ebf 	str	wzr, [x21, #76]
			z_ready_thread(pending_thread);
  40ea60:	aa1503e0 	mov	x0, x21
  40ea64:	94000957 	bl	410fc0 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  40ea68:	2a1603e1 	mov	w1, w22
  40ea6c:	aa1403e0 	mov	x0, x20
  40ea70:	940006f9 	bl	410654 <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  40ea74:	2a1303e0 	mov	w0, w19
  40ea78:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ea7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ea80:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ea84:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40ea88:	d65f03c0 	ret
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  40ea8c:	f9401661 	ldr	x1, [x19, #40]
  40ea90:	f9402260 	ldr	x0, [x19, #64]
  40ea94:	eb01001f 	cmp	x0, x1
  40ea98:	54000083 	b.cc	40eaa8 <z_impl_k_msgq_put+0x174>  // b.lo, b.ul, b.last
  40ea9c:	f9401a61 	ldr	x1, [x19, #48]
  40eaa0:	eb01001f 	cmp	x0, x1
  40eaa4:	540001e3 	b.cc	40eae0 <z_impl_k_msgq_put+0x1ac>  // b.lo, b.ul, b.last
  40eaa8:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40eaac:	91111673 	add	x19, x19, #0x445
  40eab0:	aa1303e2 	mov	x2, x19
  40eab4:	52801203 	mov	w3, #0x90                  	// #144
  40eab8:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40eabc:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40eac0:	91119c21 	add	x1, x1, #0x467
  40eac4:	9123f800 	add	x0, x0, #0x8fe
  40eac8:	97ffe491 	bl	407d0c <assert_print>
  40eacc:	aa1303e0 	mov	x0, x19
  40ead0:	52801201 	mov	w1, #0x90                  	// #144
  40ead4:	97ffe4b8 	bl	407db4 <assert_post_action>
  40ead8:	52801202 	mov	w2, #0x90                  	// #144
  40eadc:	17ffffb4 	b	40e9ac <z_impl_k_msgq_put+0x78>
  40eae0:	f9400e62 	ldr	x2, [x19, #24]
  40eae4:	aa1703e1 	mov	x1, x23
  40eae8:	97ffc9a2 	bl	401170 <memcpy@plt>
			msgq->write_ptr += msgq->msg_size;
  40eaec:	f9400e60 	ldr	x0, [x19, #24]
  40eaf0:	f9402262 	ldr	x2, [x19, #64]
  40eaf4:	8b000042 	add	x2, x2, x0
  40eaf8:	f9002262 	str	x2, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  40eafc:	f9401a60 	ldr	x0, [x19, #48]
  40eb00:	eb00005f 	cmp	x2, x0
  40eb04:	54000061 	b.ne	40eb10 <z_impl_k_msgq_put+0x1dc>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  40eb08:	f9401660 	ldr	x0, [x19, #40]
  40eb0c:	f9002260 	str	x0, [x19, #64]
			msgq->used_msgs++;
  40eb10:	b9404a60 	ldr	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40eb14:	52800201 	mov	w1, #0x10                  	// #16
			msgq->used_msgs++;
  40eb18:	11000400 	add	w0, w0, #0x1
  40eb1c:	b9004a60 	str	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40eb20:	91014260 	add	x0, x19, #0x50
		result = 0;
  40eb24:	52800013 	mov	w19, #0x0                   	// #0
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40eb28:	940012a3 	bl	4135b4 <z_handle_obj_poll_events>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40eb2c:	aa1403e0 	mov	x0, x20
  40eb30:	97ffff2f 	bl	40e7ec <z_spin_unlock_valid>
  40eb34:	72001c1f 	tst	w0, #0xff
  40eb38:	54000441 	b.ne	40ebc0 <z_impl_k_msgq_put+0x28c>  // b.any
  40eb3c:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40eb40:	91391a73 	add	x19, x19, #0xe46
  40eb44:	aa1303e2 	mov	x2, x19
  40eb48:	52801863 	mov	w3, #0xc3                  	// #195
  40eb4c:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40eb50:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40eb54:	913a8021 	add	x1, x1, #0xea0
  40eb58:	9123f800 	add	x0, x0, #0x8fe
  40eb5c:	97ffe46c 	bl	407d0c <assert_print>
  40eb60:	aa1403e1 	mov	x1, x20
  40eb64:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40eb68:	913adc00 	add	x0, x0, #0xeb7
  40eb6c:	97ffe468 	bl	407d0c <assert_print>
  40eb70:	aa1303e0 	mov	x0, x19
  40eb74:	52801861 	mov	w1, #0xc3                  	// #195
  40eb78:	97ffe48f 	bl	407db4 <assert_post_action>
  40eb7c:	52801862 	mov	w2, #0xc3                  	// #195
  40eb80:	17ffff8b 	b	40e9ac <z_impl_k_msgq_put+0x78>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40eb84:	b40001b5 	cbz	x21, 40ebb8 <z_impl_k_msgq_put+0x284>
		_current->base.swap_data = (void *) data;
  40eb88:	f9473302 	ldr	x2, [x24, #3680]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40eb8c:	aa1503e3 	mov	x3, x21
  40eb90:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = (void *) data;
  40eb94:	f9400840 	ldr	x0, [x2, #16]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40eb98:	aa1303e2 	mov	x2, x19
		_current->base.swap_data = (void *) data;
  40eb9c:	f9001017 	str	x23, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40eba0:	aa1403e0 	mov	x0, x20
}
  40eba4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40eba8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ebac:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ebb0:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ebb4:	14000a4c 	b	4114e4 <z_pend_curr>
		result = -ENOMSG;
  40ebb8:	12800533 	mov	w19, #0xffffffd6            	// #-42
  40ebbc:	17ffffdc 	b	40eb2c <z_impl_k_msgq_put+0x1f8>
	posix_irq_unlock(key);
  40ebc0:	2a1603e0 	mov	w0, w22
  40ebc4:	97ffed5a 	bl	40a12c <posix_irq_unlock>
	return result;
  40ebc8:	17ffffab 	b	40ea74 <z_impl_k_msgq_put+0x140>

000000000040ebcc <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
  40ebcc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	return _kernel.cpus[0].nested != 0U;
  40ebd0:	b00000e4 	adrp	x4, 42b000 <__FRAME_END__+0xfd74>
  40ebd4:	910003fd 	mov	x29, sp
  40ebd8:	a90153f3 	stp	x19, x20, [sp, #16]
  40ebdc:	aa0003f3 	mov	x19, x0
  40ebe0:	f9473080 	ldr	x0, [x4, #3680]
  40ebe4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ebe8:	aa0403f5 	mov	x21, x4
  40ebec:	a90363f7 	stp	x23, x24, [sp, #48]
  40ebf0:	aa0103f8 	mov	x24, x1
  40ebf4:	aa0203f7 	mov	x23, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40ebf8:	b9400000 	ldr	w0, [x0]
  40ebfc:	340002c0 	cbz	w0, 40ec54 <z_impl_k_msgq_get+0x88>
  40ec00:	b40002a2 	cbz	x2, 40ec54 <z_impl_k_msgq_get+0x88>
  40ec04:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40ec08:	91111673 	add	x19, x19, #0x445
  40ec0c:	aa1303e2 	mov	x2, x19
  40ec10:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40ec14:	9108f021 	add	x1, x1, #0x23c
  40ec18:	52801a43 	mov	w3, #0xd2                  	// #210
  40ec1c:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40ec20:	9123f800 	add	x0, x0, #0x8fe
  40ec24:	97ffe43a 	bl	407d0c <assert_print>
  40ec28:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40ec2c:	913b7400 	add	x0, x0, #0xedd
  40ec30:	97ffe437 	bl	407d0c <assert_print>
  40ec34:	aa1303e0 	mov	x0, x19
  40ec38:	52801a41 	mov	w1, #0xd2                  	// #210
  40ec3c:	97ffe45e 	bl	407db4 <assert_post_action>
  40ec40:	52801a42 	mov	w2, #0xd2                  	// #210
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ec44:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40ec48:	aa1303e1 	mov	x1, x19
  40ec4c:	9124f000 	add	x0, x0, #0x93c
  40ec50:	97ffee4b 	bl	40a57c <posix_print_error_and_exit>
	return posix_irq_lock();
  40ec54:	97ffed34 	bl	40a124 <posix_irq_lock>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
  40ec58:	91004274 	add	x20, x19, #0x10
  40ec5c:	2a0003f6 	mov	w22, w0
  40ec60:	aa1403e0 	mov	x0, x20
  40ec64:	97fffed7 	bl	40e7c0 <z_spin_lock_valid>
  40ec68:	72001c1f 	tst	w0, #0xff
  40ec6c:	54000261 	b.ne	40ecb8 <z_impl_k_msgq_get+0xec>  // b.any
  40ec70:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40ec74:	91391a73 	add	x19, x19, #0xe46
  40ec78:	aa1303e2 	mov	x2, x19
  40ec7c:	52801283 	mov	w3, #0x94                  	// #148
  40ec80:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40ec84:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40ec88:	9139cc21 	add	x1, x1, #0xe73
  40ec8c:	9123f800 	add	x0, x0, #0x8fe
  40ec90:	97ffe41f 	bl	407d0c <assert_print>
  40ec94:	aa1403e1 	mov	x1, x20
  40ec98:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40ec9c:	913a2000 	add	x0, x0, #0xe88
  40eca0:	97ffe41b 	bl	407d0c <assert_print>
  40eca4:	aa1303e0 	mov	x0, x19
  40eca8:	52801281 	mov	w1, #0x94                  	// #148
  40ecac:	97ffe442 	bl	407db4 <assert_post_action>
  40ecb0:	52801282 	mov	w2, #0x94                  	// #148
  40ecb4:	17ffffe4 	b	40ec44 <z_impl_k_msgq_get+0x78>
	z_spin_lock_set_owner(l);
  40ecb8:	aa1403e0 	mov	x0, x20
  40ecbc:	97fffed9 	bl	40e820 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
  40ecc0:	b9404a60 	ldr	w0, [x19, #72]
  40ecc4:	340008c0 	cbz	w0, 40eddc <z_impl_k_msgq_get+0x210>
  40ecc8:	f9400e62 	ldr	x2, [x19, #24]
  40eccc:	aa1803e0 	mov	x0, x24
  40ecd0:	f9401e61 	ldr	x1, [x19, #56]
  40ecd4:	97ffc927 	bl	401170 <memcpy@plt>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
  40ecd8:	f9400e61 	ldr	x1, [x19, #24]
  40ecdc:	f9401e60 	ldr	x0, [x19, #56]
  40ece0:	8b010000 	add	x0, x0, x1
  40ece4:	f9001e60 	str	x0, [x19, #56]
		if (msgq->read_ptr == msgq->buffer_end) {
  40ece8:	f9401a61 	ldr	x1, [x19, #48]
  40ecec:	eb01001f 	cmp	x0, x1
  40ecf0:	54000061 	b.ne	40ecfc <z_impl_k_msgq_get+0x130>  // b.any
			msgq->read_ptr = msgq->buffer_start;
  40ecf4:	f9401660 	ldr	x0, [x19, #40]
  40ecf8:	f9001e60 	str	x0, [x19, #56]
		}
		msgq->used_msgs--;
  40ecfc:	b9404a60 	ldr	w0, [x19, #72]
  40ed00:	51000400 	sub	w0, w0, #0x1
  40ed04:	b9004a60 	str	w0, [x19, #72]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  40ed08:	aa1303e0 	mov	x0, x19
  40ed0c:	94000bfe 	bl	411d04 <z_unpend_first_thread>
  40ed10:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  40ed14:	b40007e0 	cbz	x0, 40ee10 <z_impl_k_msgq_get+0x244>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  40ed18:	f9401661 	ldr	x1, [x19, #40]
  40ed1c:	f9402260 	ldr	x0, [x19, #64]
  40ed20:	eb01001f 	cmp	x0, x1
  40ed24:	54000083 	b.cc	40ed34 <z_impl_k_msgq_get+0x168>  // b.lo, b.ul, b.last
  40ed28:	f9401a61 	ldr	x1, [x19, #48]
  40ed2c:	eb01001f 	cmp	x0, x1
  40ed30:	540001e3 	b.cc	40ed6c <z_impl_k_msgq_get+0x1a0>  // b.lo, b.ul, b.last
  40ed34:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40ed38:	91111673 	add	x19, x19, #0x445
  40ed3c:	aa1303e2 	mov	x2, x19
  40ed40:	52801d63 	mov	w3, #0xeb                  	// #235
  40ed44:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40ed48:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40ed4c:	91119c21 	add	x1, x1, #0x467
  40ed50:	9123f800 	add	x0, x0, #0x8fe
  40ed54:	97ffe3ee 	bl	407d0c <assert_print>
  40ed58:	aa1303e0 	mov	x0, x19
  40ed5c:	52801d61 	mov	w1, #0xeb                  	// #235
  40ed60:	97ffe415 	bl	407db4 <assert_post_action>
  40ed64:	52801d62 	mov	w2, #0xeb                  	// #235
  40ed68:	17ffffb7 	b	40ec44 <z_impl_k_msgq_get+0x78>
  40ed6c:	f9400e62 	ldr	x2, [x19, #24]
  40ed70:	f94012a1 	ldr	x1, [x21, #32]
  40ed74:	97ffc8ff 	bl	401170 <memcpy@plt>
					msgq->write_ptr < msgq->buffer_end);
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
  40ed78:	f9400e61 	ldr	x1, [x19, #24]
  40ed7c:	f9402260 	ldr	x0, [x19, #64]
  40ed80:	8b010000 	add	x0, x0, x1
  40ed84:	f9002260 	str	x0, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  40ed88:	f9401a61 	ldr	x1, [x19, #48]
  40ed8c:	eb01001f 	cmp	x0, x1
  40ed90:	54000061 	b.ne	40ed9c <z_impl_k_msgq_get+0x1d0>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  40ed94:	f9401660 	ldr	x0, [x19, #40]
  40ed98:	f9002260 	str	x0, [x19, #64]
			}
			msgq->used_msgs++;
  40ed9c:	b9404a60 	ldr	w0, [x19, #72]
  40eda0:	11000400 	add	w0, w0, #0x1
  40eda4:	b9004a60 	str	w0, [x19, #72]
	thread->callee_saved.retval = value;
  40eda8:	b9004ebf 	str	wzr, [x21, #76]

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
  40edac:	aa1503e0 	mov	x0, x21
			z_reschedule(&msgq->lock, key);

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
  40edb0:	52800013 	mov	w19, #0x0                   	// #0
			z_ready_thread(pending_thread);
  40edb4:	94000883 	bl	410fc0 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  40edb8:	2a1603e1 	mov	w1, w22
  40edbc:	aa1403e0 	mov	x0, x20
  40edc0:	94000625 	bl	410654 <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  40edc4:	2a1303e0 	mov	w0, w19
  40edc8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40edcc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40edd0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40edd4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40edd8:	d65f03c0 	ret
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40eddc:	b4000497 	cbz	x23, 40ee6c <z_impl_k_msgq_get+0x2a0>
		_current->base.swap_data = data;
  40ede0:	f94732a4 	ldr	x4, [x21, #3680]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ede4:	aa1703e3 	mov	x3, x23
  40ede8:	aa1303e2 	mov	x2, x19
  40edec:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = data;
  40edf0:	f9400880 	ldr	x0, [x4, #16]
  40edf4:	f9001018 	str	x24, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40edf8:	aa1403e0 	mov	x0, x20
}
  40edfc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ee00:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ee04:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ee08:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ee0c:	140009b6 	b	4114e4 <z_pend_curr>
		result = 0;
  40ee10:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40ee14:	aa1403e0 	mov	x0, x20
  40ee18:	97fffe75 	bl	40e7ec <z_spin_unlock_valid>
  40ee1c:	72001c1f 	tst	w0, #0xff
  40ee20:	540002a1 	b.ne	40ee74 <z_impl_k_msgq_get+0x2a8>  // b.any
  40ee24:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40ee28:	91391a73 	add	x19, x19, #0xe46
  40ee2c:	aa1303e2 	mov	x2, x19
  40ee30:	52801863 	mov	w3, #0xc3                  	// #195
  40ee34:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40ee38:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40ee3c:	913a8021 	add	x1, x1, #0xea0
  40ee40:	9123f800 	add	x0, x0, #0x8fe
  40ee44:	97ffe3b2 	bl	407d0c <assert_print>
  40ee48:	aa1403e1 	mov	x1, x20
  40ee4c:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40ee50:	913adc00 	add	x0, x0, #0xeb7
  40ee54:	97ffe3ae 	bl	407d0c <assert_print>
  40ee58:	aa1303e0 	mov	x0, x19
  40ee5c:	52801861 	mov	w1, #0xc3                  	// #195
  40ee60:	97ffe3d5 	bl	407db4 <assert_post_action>
  40ee64:	52801862 	mov	w2, #0xc3                  	// #195
  40ee68:	17ffff77 	b	40ec44 <z_impl_k_msgq_get+0x78>
		result = -ENOMSG;
  40ee6c:	12800533 	mov	w19, #0xffffffd6            	// #-42
  40ee70:	17ffffe9 	b	40ee14 <z_impl_k_msgq_get+0x248>
	posix_irq_unlock(key);
  40ee74:	2a1603e0 	mov	w0, w22
  40ee78:	97ffecad 	bl	40a12c <posix_irq_unlock>
	return result;
  40ee7c:	17ffffd2 	b	40edc4 <z_impl_k_msgq_get+0x1f8>

000000000040ee80 <z_impl_k_msgq_purge>:
}
#include <syscalls/k_msgq_peek_at_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
  40ee80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ee84:	910003fd 	mov	x29, sp
  40ee88:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
  40ee8c:	91004014 	add	x20, x0, #0x10
{
  40ee90:	aa0003f3 	mov	x19, x0
  40ee94:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40ee98:	97ffeca3 	bl	40a124 <posix_irq_lock>
  40ee9c:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40eea0:	aa1403e0 	mov	x0, x20
  40eea4:	97fffe47 	bl	40e7c0 <z_spin_lock_valid>
  40eea8:	72001c1f 	tst	w0, #0xff
  40eeac:	540002c1 	b.ne	40ef04 <z_impl_k_msgq_purge+0x84>  // b.any
  40eeb0:	f0000033 	adrp	x19, 415000 <random_data+0xb30>
  40eeb4:	91391a73 	add	x19, x19, #0xe46
  40eeb8:	aa1303e2 	mov	x2, x19
  40eebc:	52801283 	mov	w3, #0x94                  	// #148
  40eec0:	f0000021 	adrp	x1, 415000 <random_data+0xb30>
  40eec4:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40eec8:	9139cc21 	add	x1, x1, #0xe73
  40eecc:	9123f800 	add	x0, x0, #0x8fe
  40eed0:	97ffe38f 	bl	407d0c <assert_print>
  40eed4:	aa1403e1 	mov	x1, x20
  40eed8:	f0000020 	adrp	x0, 415000 <random_data+0xb30>
  40eedc:	913a2000 	add	x0, x0, #0xe88
  40eee0:	97ffe38b 	bl	407d0c <assert_print>
  40eee4:	aa1303e0 	mov	x0, x19
  40eee8:	52801281 	mov	w1, #0x94                  	// #148
  40eeec:	97ffe3b2 	bl	407db4 <assert_post_action>
  40eef0:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40eef4:	aa1303e1 	mov	x1, x19
  40eef8:	9124f000 	add	x0, x0, #0x93c
  40eefc:	52801282 	mov	w2, #0x94                  	// #148
  40ef00:	97ffed9f 	bl	40a57c <posix_print_error_and_exit>
  40ef04:	12800536 	mov	w22, #0xffffffd6            	// #-42
	z_spin_lock_set_owner(l);
  40ef08:	aa1403e0 	mov	x0, x20
  40ef0c:	97fffe45 	bl	40e820 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
  40ef10:	aa1303e0 	mov	x0, x19
  40ef14:	94000b7c 	bl	411d04 <z_unpend_first_thread>
  40ef18:	aa0003e2 	mov	x2, x0
  40ef1c:	b5000140 	cbnz	x0, 40ef44 <z_impl_k_msgq_purge+0xc4>
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
	}

	msgq->used_msgs = 0;
	msgq->read_ptr = msgq->write_ptr;
  40ef20:	f9402260 	ldr	x0, [x19, #64]
  40ef24:	f9001e60 	str	x0, [x19, #56]
	msgq->used_msgs = 0;
  40ef28:	b9004a7f 	str	wzr, [x19, #72]

	z_reschedule(&msgq->lock, key);
  40ef2c:	2a1503e1 	mov	w1, w21
  40ef30:	aa1403e0 	mov	x0, x20
}
  40ef34:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ef38:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ef3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&msgq->lock, key);
  40ef40:	140005c5 	b	410654 <z_reschedule>
  40ef44:	b9004c56 	str	w22, [x2, #76]
		z_ready_thread(pending_thread);
  40ef48:	9400081e 	bl	410fc0 <z_ready_thread>
  40ef4c:	17fffff1 	b	40ef10 <z_impl_k_msgq_purge+0x90>

000000000040ef50 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
  40ef50:	39c06802 	ldrsb	w2, [x0, #26]
  40ef54:	6b01005f 	cmp	w2, w1
  40ef58:	54000040 	b.eq	40ef60 <adjust_owner_prio.isra.0+0x10>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
  40ef5c:	140009d2 	b	4116a4 <z_set_prio>
	}
	return false;
}
  40ef60:	52800000 	mov	w0, #0x0                   	// #0
  40ef64:	d65f03c0 	ret

000000000040ef68 <z_impl_k_mutex_init>:
	list->tail = (sys_dnode_t *)list;
  40ef68:	a9000000 	stp	x0, x0, [x0]
	mutex->owner = NULL;
  40ef6c:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
  40ef70:	b900181f 	str	wzr, [x0, #24]
}
  40ef74:	52800000 	mov	w0, #0x0                   	// #0
  40ef78:	d65f03c0 	ret

000000000040ef7c <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
  40ef7c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ef80:	910003fd 	mov	x29, sp
  40ef84:	a9025bf5 	stp	x21, x22, [sp, #32]
	return _kernel.cpus[0].nested != 0U;
  40ef88:	b00000f5 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
  40ef8c:	f90023f9 	str	x25, [sp, #64]
  40ef90:	f94732b9 	ldr	x25, [x21, #3680]
  40ef94:	a90153f3 	stp	x19, x20, [sp, #16]
  40ef98:	aa0003f3 	mov	x19, x0
  40ef9c:	a90363f7 	stp	x23, x24, [sp, #48]
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  40efa0:	b9400320 	ldr	w0, [x25]
  40efa4:	340002a0 	cbz	w0, 40eff8 <z_impl_k_mutex_lock+0x7c>
  40efa8:	90000053 	adrp	x19, 416000 <__func__.0+0x9cb>
  40efac:	9112ce73 	add	x19, x19, #0x4b3
  40efb0:	aa1303e2 	mov	x2, x19
  40efb4:	90000041 	adrp	x1, 416000 <__func__.0+0x9cb>
  40efb8:	910e6021 	add	x1, x1, #0x398
  40efbc:	52800ca3 	mov	w3, #0x65                  	// #101
  40efc0:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40efc4:	9123f800 	add	x0, x0, #0x8fe
  40efc8:	97ffe351 	bl	407d0c <assert_print>
  40efcc:	90000040 	adrp	x0, 416000 <__func__.0+0x9cb>
  40efd0:	91135400 	add	x0, x0, #0x4d5
  40efd4:	97ffe34e 	bl	407d0c <assert_print>
  40efd8:	aa1303e0 	mov	x0, x19
  40efdc:	52800ca1 	mov	w1, #0x65                  	// #101
  40efe0:	97ffe375 	bl	407db4 <assert_post_action>
  40efe4:	52800ca2 	mov	w2, #0x65                  	// #101
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40efe8:	d0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40efec:	aa1303e1 	mov	x1, x19
  40eff0:	9124f000 	add	x0, x0, #0x93c
  40eff4:	97ffed62 	bl	40a57c <posix_print_error_and_exit>
  40eff8:	aa0103f8 	mov	x24, x1
  40effc:	f00000f4 	adrp	x20, 42d000 <counter_period>
  40f000:	97ffec49 	bl	40a124 <posix_irq_lock>
  40f004:	9124c297 	add	x23, x20, #0x930
  40f008:	2a0003f6 	mov	w22, w0
  40f00c:	aa1703e0 	mov	x0, x23
  40f010:	97fffdec 	bl	40e7c0 <z_spin_lock_valid>
  40f014:	72001c1f 	tst	w0, #0xff
  40f018:	54000261 	b.ne	40f064 <z_impl_k_mutex_lock+0xe8>  // b.any
  40f01c:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f020:	91391a73 	add	x19, x19, #0xe46
  40f024:	aa1303e2 	mov	x2, x19
  40f028:	52801283 	mov	w3, #0x94                  	// #148
  40f02c:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f030:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f034:	9139cc21 	add	x1, x1, #0xe73
  40f038:	9123f800 	add	x0, x0, #0x8fe
  40f03c:	97ffe334 	bl	407d0c <assert_print>
  40f040:	9124c281 	add	x1, x20, #0x930
  40f044:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f048:	913a2000 	add	x0, x0, #0xe88
  40f04c:	97ffe330 	bl	407d0c <assert_print>
  40f050:	aa1303e0 	mov	x0, x19
  40f054:	52801281 	mov	w1, #0x94                  	// #148
  40f058:	97ffe357 	bl	407db4 <assert_post_action>
  40f05c:	52801282 	mov	w2, #0x94                  	// #148
  40f060:	17ffffe2 	b	40efe8 <z_impl_k_mutex_lock+0x6c>
	z_spin_lock_set_owner(l);
  40f064:	aa1703e0 	mov	x0, x23
  40f068:	97fffdee 	bl	40e820 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  40f06c:	b9401a61 	ldr	w1, [x19, #24]
  40f070:	340001c1 	cbz	w1, 40f0a8 <z_impl_k_mutex_lock+0x12c>
  40f074:	f9400a60 	ldr	x0, [x19, #16]
  40f078:	f9400b22 	ldr	x2, [x25, #16]
  40f07c:	eb02001f 	cmp	x0, x2
  40f080:	540004e0 	b.eq	40f11c <z_impl_k_mutex_lock+0x1a0>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
  40f084:	b5000638 	cbnz	x24, 40f148 <z_impl_k_mutex_lock+0x1cc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f088:	aa1703e0 	mov	x0, x23
  40f08c:	97fffdd8 	bl	40e7ec <z_spin_unlock_valid>
  40f090:	72001c1f 	tst	w0, #0xff
  40f094:	54000200 	b.eq	40f0d4 <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  40f098:	2a1603e0 	mov	w0, w22
  40f09c:	97ffec24 	bl	40a12c <posix_irq_unlock>
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
  40f0a0:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40f0a4:	14000023 	b	40f130 <z_impl_k_mutex_lock+0x1b4>
					_current->base.prio :
  40f0a8:	f9400b20 	ldr	x0, [x25, #16]
  40f0ac:	39c06800 	ldrsb	w0, [x0, #26]
		mutex->owner = _current;
  40f0b0:	f94732b5 	ldr	x21, [x21, #3680]
		mutex->lock_count++;
  40f0b4:	11000421 	add	w1, w1, #0x1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  40f0b8:	29030261 	stp	w1, w0, [x19, #24]
		mutex->owner = _current;
  40f0bc:	f9400aa0 	ldr	x0, [x21, #16]
  40f0c0:	f9000a60 	str	x0, [x19, #16]
  40f0c4:	9124c280 	add	x0, x20, #0x930
  40f0c8:	97fffdc9 	bl	40e7ec <z_spin_unlock_valid>
  40f0cc:	72001c1f 	tst	w0, #0xff
  40f0d0:	540002a1 	b.ne	40f124 <z_impl_k_mutex_lock+0x1a8>  // b.any
  40f0d4:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f0d8:	91391a73 	add	x19, x19, #0xe46
  40f0dc:	aa1303e2 	mov	x2, x19
  40f0e0:	52801863 	mov	w3, #0xc3                  	// #195
  40f0e4:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f0e8:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f0ec:	913a8021 	add	x1, x1, #0xea0
  40f0f0:	9123f800 	add	x0, x0, #0x8fe
  40f0f4:	97ffe306 	bl	407d0c <assert_print>
  40f0f8:	9124c281 	add	x1, x20, #0x930
  40f0fc:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f100:	913adc00 	add	x0, x0, #0xeb7
  40f104:	97ffe302 	bl	407d0c <assert_print>
  40f108:	aa1303e0 	mov	x0, x19
  40f10c:	52801861 	mov	w1, #0xc3                  	// #195
  40f110:	97ffe329 	bl	407db4 <assert_post_action>
  40f114:	52801862 	mov	w2, #0xc3                  	// #195
  40f118:	17ffffb4 	b	40efe8 <z_impl_k_mutex_lock+0x6c>
					_current->base.prio :
  40f11c:	b9401e60 	ldr	w0, [x19, #28]
  40f120:	17ffffe4 	b	40f0b0 <z_impl_k_mutex_lock+0x134>
  40f124:	2a1603e0 	mov	w0, w22
  40f128:	97ffec01 	bl	40a12c <posix_irq_unlock>
		return 0;
  40f12c:	52800000 	mov	w0, #0x0                   	// #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
  40f130:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f134:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f138:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f13c:	f94023f9 	ldr	x25, [sp, #64]
  40f140:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40f144:	d65f03c0 	ret
	new_prio = new_prio_for_inheritance(_current->base.prio,
  40f148:	39c06842 	ldrsb	w2, [x2, #26]
  40f14c:	39c06803 	ldrsb	w3, [x0, #26]
  40f150:	6b03005f 	cmp	w2, w3
  40f154:	1a83d041 	csel	w1, w2, w3, le
  40f158:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  40f15c:	3101fc3f 	cmn	w1, #0x7f
  40f160:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  40f164:	6b01007f 	cmp	w3, w1
  40f168:	5400050d 	b.le	40f208 <z_impl_k_mutex_lock+0x28c>
		resched = adjust_owner_prio(mutex, new_prio);
  40f16c:	97ffff79 	bl	40ef50 <adjust_owner_prio.isra.0>
  40f170:	12001c17 	and	w23, w0, #0xff
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  40f174:	9124c299 	add	x25, x20, #0x930
  40f178:	aa1803e3 	mov	x3, x24
  40f17c:	aa1303e2 	mov	x2, x19
  40f180:	2a1603e1 	mov	w1, w22
  40f184:	aa1903e0 	mov	x0, x25
  40f188:	940008d7 	bl	4114e4 <z_pend_curr>
	if (got_mutex == 0) {
  40f18c:	34fffd20 	cbz	w0, 40f130 <z_impl_k_mutex_lock+0x1b4>
	return posix_irq_lock();
  40f190:	97ffebe5 	bl	40a124 <posix_irq_lock>
  40f194:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f198:	aa1903e0 	mov	x0, x25
  40f19c:	97fffd89 	bl	40e7c0 <z_spin_lock_valid>
  40f1a0:	72001c1f 	tst	w0, #0xff
  40f1a4:	54fff3c0 	b.eq	40f01c <z_impl_k_mutex_lock+0xa0>  // b.none
	z_spin_lock_set_owner(l);
  40f1a8:	aa1903e0 	mov	x0, x25
  40f1ac:	97fffd9d 	bl	40e820 <z_spin_lock_set_owner>
	if (likely(mutex->owner != NULL)) {
  40f1b0:	f9400a60 	ldr	x0, [x19, #16]
  40f1b4:	b40001e0 	cbz	x0, 40f1f0 <z_impl_k_mutex_lock+0x274>
	return list->head == list;
  40f1b8:	f9400262 	ldr	x2, [x19]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  40f1bc:	b9401e61 	ldr	w1, [x19, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40f1c0:	eb02027f 	cmp	x19, x2
  40f1c4:	54000100 	b.eq	40f1e4 <z_impl_k_mutex_lock+0x268>  // b.none
  40f1c8:	b40000e2 	cbz	x2, 40f1e4 <z_impl_k_mutex_lock+0x268>
  40f1cc:	39c06842 	ldrsb	w2, [x2, #26]
  40f1d0:	6b02003f 	cmp	w1, w2
  40f1d4:	1a82d021 	csel	w1, w1, w2, le
  40f1d8:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  40f1dc:	3101fc3f 	cmn	w1, #0x7f
  40f1e0:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
		resched = adjust_owner_prio(mutex, new_prio) || resched;
  40f1e4:	97ffff5b 	bl	40ef50 <adjust_owner_prio.isra.0>
  40f1e8:	72001c1f 	tst	w0, #0xff
  40f1ec:	54000041 	b.ne	40f1f4 <z_impl_k_mutex_lock+0x278>  // b.any
	if (resched) {
  40f1f0:	34000117 	cbz	w23, 40f210 <z_impl_k_mutex_lock+0x294>
		z_reschedule(&lock, key);
  40f1f4:	2a1503e1 	mov	w1, w21
  40f1f8:	9124c280 	add	x0, x20, #0x930
  40f1fc:	94000516 	bl	410654 <z_reschedule>
	return -EAGAIN;
  40f200:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40f204:	17ffffcb 	b	40f130 <z_impl_k_mutex_lock+0x1b4>
	bool resched = false;
  40f208:	52800017 	mov	w23, #0x0                   	// #0
  40f20c:	17ffffda 	b	40f174 <z_impl_k_mutex_lock+0x1f8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f210:	9124c280 	add	x0, x20, #0x930
  40f214:	97fffd76 	bl	40e7ec <z_spin_unlock_valid>
  40f218:	72001c1f 	tst	w0, #0xff
  40f21c:	54fff5c0 	b.eq	40f0d4 <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  40f220:	2a1503e0 	mov	w0, w21
  40f224:	97ffebc2 	bl	40a12c <posix_irq_unlock>
  40f228:	17fffff6 	b	40f200 <z_impl_k_mutex_lock+0x284>

000000000040f22c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  40f22c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40f230:	910003fd 	mov	x29, sp
  40f234:	a90153f3 	stp	x19, x20, [sp, #16]
  40f238:	aa0003f3 	mov	x19, x0
  40f23c:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40f240:	f90013f5 	str	x21, [sp, #32]
  40f244:	f9473000 	ldr	x0, [x0, #3680]
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  40f248:	b9400001 	ldr	w1, [x0]
  40f24c:	340002a1 	cbz	w1, 40f2a0 <z_impl_k_mutex_unlock+0x74>
  40f250:	f0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  40f254:	9112ce73 	add	x19, x19, #0x4b3
  40f258:	aa1303e2 	mov	x2, x19
  40f25c:	f0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  40f260:	910e6021 	add	x1, x1, #0x398
  40f264:	528019a3 	mov	w3, #0xcd                  	// #205
  40f268:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f26c:	9123f800 	add	x0, x0, #0x8fe
  40f270:	97ffe2a7 	bl	407d0c <assert_print>
  40f274:	f0000020 	adrp	x0, 416000 <__func__.0+0x9cb>
  40f278:	91135400 	add	x0, x0, #0x4d5
  40f27c:	97ffe2a4 	bl	407d0c <assert_print>
  40f280:	aa1303e0 	mov	x0, x19
  40f284:	528019a1 	mov	w1, #0xcd                  	// #205
  40f288:	97ffe2cb 	bl	407db4 <assert_post_action>
  40f28c:	528019a2 	mov	w2, #0xcd                  	// #205
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  40f290:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f294:	aa1303e1 	mov	x1, x19
  40f298:	9124f000 	add	x0, x0, #0x93c
  40f29c:	97ffecb8 	bl	40a57c <posix_print_error_and_exit>
	CHECKIF(mutex->owner == NULL) {
  40f2a0:	f9400a61 	ldr	x1, [x19, #16]
  40f2a4:	b4000c41 	cbz	x1, 40f42c <z_impl_k_mutex_unlock+0x200>
	CHECKIF(mutex->owner != _current) {
  40f2a8:	f9400800 	ldr	x0, [x0, #16]
  40f2ac:	eb00003f 	cmp	x1, x0
  40f2b0:	54000c21 	b.ne	40f434 <z_impl_k_mutex_unlock+0x208>  // b.any
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  40f2b4:	b9401a60 	ldr	w0, [x19, #24]
  40f2b8:	350001e0 	cbnz	w0, 40f2f4 <z_impl_k_mutex_unlock+0xc8>
  40f2bc:	f0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  40f2c0:	9112ce73 	add	x19, x19, #0x4b3
  40f2c4:	aa1303e2 	mov	x2, x19
  40f2c8:	52801ca3 	mov	w3, #0xe5                  	// #229
  40f2cc:	f0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  40f2d0:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f2d4:	9113e821 	add	x1, x1, #0x4fa
  40f2d8:	9123f800 	add	x0, x0, #0x8fe
  40f2dc:	97ffe28c 	bl	407d0c <assert_print>
  40f2e0:	aa1303e0 	mov	x0, x19
  40f2e4:	52801ca1 	mov	w1, #0xe5                  	// #229
  40f2e8:	97ffe2b3 	bl	407db4 <assert_post_action>
  40f2ec:	52801ca2 	mov	w2, #0xe5                  	// #229
  40f2f0:	17ffffe8 	b	40f290 <z_impl_k_mutex_unlock+0x64>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
  40f2f4:	7100041f 	cmp	w0, #0x1
  40f2f8:	54000100 	b.eq	40f318 <z_impl_k_mutex_unlock+0xec>  // b.none
		mutex->lock_count--;
  40f2fc:	51000400 	sub	w0, w0, #0x1
  40f300:	b9001a60 	str	w0, [x19, #24]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
  40f304:	52800000 	mov	w0, #0x0                   	// #0
}
  40f308:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f30c:	f94013f5 	ldr	x21, [sp, #32]
  40f310:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40f314:	d65f03c0 	ret
	return posix_irq_lock();
  40f318:	97ffeb83 	bl	40a124 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f31c:	d00000f4 	adrp	x20, 42d000 <counter_period>
  40f320:	9124c294 	add	x20, x20, #0x930
  40f324:	2a0003f5 	mov	w21, w0
  40f328:	aa1403e0 	mov	x0, x20
  40f32c:	97fffd25 	bl	40e7c0 <z_spin_lock_valid>
  40f330:	72001c1f 	tst	w0, #0xff
  40f334:	54000261 	b.ne	40f380 <z_impl_k_mutex_unlock+0x154>  // b.any
  40f338:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f33c:	91391a73 	add	x19, x19, #0xe46
  40f340:	aa1303e2 	mov	x2, x19
  40f344:	52801283 	mov	w3, #0x94                  	// #148
  40f348:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f34c:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f350:	9139cc21 	add	x1, x1, #0xe73
  40f354:	9123f800 	add	x0, x0, #0x8fe
  40f358:	97ffe26d 	bl	407d0c <assert_print>
  40f35c:	aa1403e1 	mov	x1, x20
  40f360:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f364:	913a2000 	add	x0, x0, #0xe88
  40f368:	97ffe269 	bl	407d0c <assert_print>
  40f36c:	aa1303e0 	mov	x0, x19
  40f370:	52801281 	mov	w1, #0x94                  	// #148
  40f374:	97ffe290 	bl	407db4 <assert_post_action>
  40f378:	52801282 	mov	w2, #0x94                  	// #148
  40f37c:	17ffffc5 	b	40f290 <z_impl_k_mutex_unlock+0x64>
	z_spin_lock_set_owner(l);
  40f380:	aa1403e0 	mov	x0, x20
  40f384:	97fffd27 	bl	40e820 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  40f388:	b9401e61 	ldr	w1, [x19, #28]
  40f38c:	f9400a60 	ldr	x0, [x19, #16]
  40f390:	97fffef0 	bl	40ef50 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  40f394:	aa1303e0 	mov	x0, x19
  40f398:	94000a5b 	bl	411d04 <z_unpend_first_thread>
	mutex->owner = new_owner;
  40f39c:	f9000a60 	str	x0, [x19, #16]
	if (new_owner != NULL) {
  40f3a0:	b4000120 	cbz	x0, 40f3c4 <z_impl_k_mutex_unlock+0x198>
		mutex->owner_orig_prio = new_owner->base.prio;
  40f3a4:	39c06801 	ldrsb	w1, [x0, #26]
  40f3a8:	b9001e61 	str	w1, [x19, #28]
	thread->callee_saved.retval = value;
  40f3ac:	b9004c1f 	str	wzr, [x0, #76]
		z_ready_thread(new_owner);
  40f3b0:	94000704 	bl	410fc0 <z_ready_thread>
		z_reschedule(&lock, key);
  40f3b4:	2a1503e1 	mov	w1, w21
  40f3b8:	aa1403e0 	mov	x0, x20
  40f3bc:	940004a6 	bl	410654 <z_reschedule>
  40f3c0:	17ffffd1 	b	40f304 <z_impl_k_mutex_unlock+0xd8>
		mutex->lock_count = 0U;
  40f3c4:	b9001a7f 	str	wzr, [x19, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f3c8:	aa1403e0 	mov	x0, x20
  40f3cc:	97fffd08 	bl	40e7ec <z_spin_unlock_valid>
  40f3d0:	72001c1f 	tst	w0, #0xff
  40f3d4:	54000261 	b.ne	40f420 <z_impl_k_mutex_unlock+0x1f4>  // b.any
  40f3d8:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f3dc:	91391a73 	add	x19, x19, #0xe46
  40f3e0:	aa1303e2 	mov	x2, x19
  40f3e4:	52801863 	mov	w3, #0xc3                  	// #195
  40f3e8:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f3ec:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f3f0:	913a8021 	add	x1, x1, #0xea0
  40f3f4:	9123f800 	add	x0, x0, #0x8fe
  40f3f8:	97ffe245 	bl	407d0c <assert_print>
  40f3fc:	aa1403e1 	mov	x1, x20
  40f400:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f404:	913adc00 	add	x0, x0, #0xeb7
  40f408:	97ffe241 	bl	407d0c <assert_print>
  40f40c:	aa1303e0 	mov	x0, x19
  40f410:	52801861 	mov	w1, #0xc3                  	// #195
  40f414:	97ffe268 	bl	407db4 <assert_post_action>
  40f418:	52801862 	mov	w2, #0xc3                  	// #195
  40f41c:	17ffff9d 	b	40f290 <z_impl_k_mutex_unlock+0x64>
	posix_irq_unlock(key);
  40f420:	2a1503e0 	mov	w0, w21
  40f424:	97ffeb42 	bl	40a12c <posix_irq_unlock>
  40f428:	17ffffb7 	b	40f304 <z_impl_k_mutex_unlock+0xd8>
		return -EINVAL;
  40f42c:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40f430:	17ffffb6 	b	40f308 <z_impl_k_mutex_unlock+0xdc>
		return -EPERM;
  40f434:	12800000 	mov	w0, #0xffffffff            	// #-1
  40f438:	17ffffb4 	b	40f308 <z_impl_k_mutex_unlock+0xdc>

000000000040f43c <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
  40f43c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40f440:	910003fd 	mov	x29, sp
  40f444:	a90153f3 	stp	x19, x20, [sp, #16]
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  40f448:	91004014 	add	x20, x0, #0x10
{
  40f44c:	aa0003f3 	mov	x19, x0
  40f450:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f454:	aa0103f5 	mov	x21, x1
  40f458:	a90363f7 	stp	x23, x24, [sp, #48]
  40f45c:	aa0203f7 	mov	x23, x2
  40f460:	12001c78 	and	w24, w3, #0xff
  40f464:	f90023f9 	str	x25, [sp, #64]
  40f468:	12001c99 	and	w25, w4, #0xff
	return posix_irq_lock();
  40f46c:	97ffeb2e 	bl	40a124 <posix_irq_lock>
  40f470:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f474:	aa1403e0 	mov	x0, x20
  40f478:	97fffcd2 	bl	40e7c0 <z_spin_lock_valid>
  40f47c:	72001c1f 	tst	w0, #0xff
  40f480:	540002c1 	b.ne	40f4d8 <queue_insert+0x9c>  // b.any
  40f484:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f488:	91391a73 	add	x19, x19, #0xe46
  40f48c:	aa1303e2 	mov	x2, x19
  40f490:	52801283 	mov	w3, #0x94                  	// #148
  40f494:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f498:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f49c:	9139cc21 	add	x1, x1, #0xe73
  40f4a0:	9123f800 	add	x0, x0, #0x8fe
  40f4a4:	97ffe21a 	bl	407d0c <assert_print>
  40f4a8:	aa1403e1 	mov	x1, x20
  40f4ac:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f4b0:	913a2000 	add	x0, x0, #0xe88
  40f4b4:	97ffe216 	bl	407d0c <assert_print>
  40f4b8:	aa1303e0 	mov	x0, x19
  40f4bc:	52801281 	mov	w1, #0x94                  	// #148
  40f4c0:	97ffe23d 	bl	407db4 <assert_post_action>
  40f4c4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f4c8:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f4cc:	aa1303e1 	mov	x1, x19
  40f4d0:	9124f000 	add	x0, x0, #0x93c
  40f4d4:	97ffec2a 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f4d8:	aa1403e0 	mov	x0, x20
  40f4dc:	97fffcd1 	bl	40e820 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
  40f4e0:	34000059 	cbz	w25, 40f4e8 <queue_insert+0xac>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
  40f4e4:	f9400675 	ldr	x21, [x19, #8]
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  40f4e8:	91006260 	add	x0, x19, #0x18
  40f4ec:	94000a06 	bl	411d04 <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
  40f4f0:	b4000120 	cbz	x0, 40f514 <queue_insert+0xd8>
  40f4f4:	f9001017 	str	x23, [x0, #32]
  40f4f8:	b9004c1f 	str	wzr, [x0, #76]
	z_ready_thread(thread);
  40f4fc:	940006b1 	bl	410fc0 <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
  40f500:	aa1403e0 	mov	x0, x20
  40f504:	2a1603e1 	mov	w1, w22
  40f508:	94000453 	bl	410654 <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
  40f50c:	52800000 	mov	w0, #0x0                   	// #0
  40f510:	1400001f 	b	40f58c <queue_insert+0x150>
	if (alloc) {
  40f514:	34000638 	cbz	w24, 40f5d8 <queue_insert+0x19c>
	return z_thread_aligned_alloc(0, size);
  40f518:	d2800201 	mov	x1, #0x10                  	// #16
  40f51c:	94001035 	bl	4135f0 <z_thread_aligned_alloc>
  40f520:	aa0003e3 	mov	x3, x0
		if (anode == NULL) {
  40f524:	b5000400 	cbnz	x0, 40f5a4 <queue_insert+0x168>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f528:	aa1403e0 	mov	x0, x20
  40f52c:	97fffcb0 	bl	40e7ec <z_spin_unlock_valid>
  40f530:	72001c1f 	tst	w0, #0xff
  40f534:	54000261 	b.ne	40f580 <queue_insert+0x144>  // b.any
  40f538:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f53c:	91391a73 	add	x19, x19, #0xe46
  40f540:	aa1303e2 	mov	x2, x19
  40f544:	52801863 	mov	w3, #0xc3                  	// #195
  40f548:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f54c:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f550:	913a8021 	add	x1, x1, #0xea0
  40f554:	9123f800 	add	x0, x0, #0x8fe
  40f558:	97ffe1ed 	bl	407d0c <assert_print>
  40f55c:	aa1403e1 	mov	x1, x20
  40f560:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f564:	913adc00 	add	x0, x0, #0xeb7
  40f568:	97ffe1e9 	bl	407d0c <assert_print>
  40f56c:	aa1303e0 	mov	x0, x19
  40f570:	52801861 	mov	w1, #0xc3                  	// #195
  40f574:	97ffe210 	bl	407db4 <assert_post_action>
  40f578:	52801862 	mov	w2, #0xc3                  	// #195
  40f57c:	17ffffd3 	b	40f4c8 <queue_insert+0x8c>
	posix_irq_unlock(key);
  40f580:	2a1603e0 	mov	w0, w22
  40f584:	97ffeaea 	bl	40a12c <posix_irq_unlock>
			return -ENOMEM;
  40f588:	12800160 	mov	w0, #0xfffffff4            	// #-12
}
  40f58c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f590:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f594:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f598:	f94023f9 	ldr	x25, [sp, #64]
  40f59c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40f5a0:	d65f03c0 	ret
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
  40f5a4:	d2800020 	mov	x0, #0x1                   	// #1
		anode->data = data;
  40f5a8:	a9005c60 	stp	x0, x23, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f5ac:	f9400060 	ldr	x0, [x3]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f5b0:	92400400 	and	x0, x0, #0x3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
  40f5b4:	b5000195 	cbnz	x21, 40f5e4 <queue_insert+0x1a8>
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f5b8:	f9400261 	ldr	x1, [x19]
  40f5bc:	aa000020 	orr	x0, x1, x0
  40f5c0:	f9000060 	str	x0, [x3]
	list->head = node;
  40f5c4:	f9000263 	str	x3, [x19]
Z_GENLIST_PREPEND(sflist, sfnode)
  40f5c8:	f9400660 	ldr	x0, [x19, #8]
  40f5cc:	b50001a0 	cbnz	x0, 40f600 <queue_insert+0x1c4>
	list->tail = node;
  40f5d0:	f9000663 	str	x3, [x19, #8]
}
  40f5d4:	1400000b 	b	40f600 <queue_insert+0x1c4>
}
  40f5d8:	aa1703e3 	mov	x3, x23
	node->next_and_flags = flags;
  40f5dc:	f90002ff 	str	xzr, [x23]
}
  40f5e0:	17fffff3 	b	40f5ac <queue_insert+0x170>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f5e4:	f94002a2 	ldr	x2, [x21]
Z_GENLIST_INSERT(sflist, sfnode)
  40f5e8:	f27ef442 	ands	x2, x2, #0xfffffffffffffffc
  40f5ec:	540001c1 	b.ne	40f624 <queue_insert+0x1e8>  // b.any
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f5f0:	f9000060 	str	x0, [x3]
	return list->tail;
  40f5f4:	f9400661 	ldr	x1, [x19, #8]
Z_GENLIST_APPEND(sflist, sfnode)
  40f5f8:	b50000c1 	cbnz	x1, 40f610 <queue_insert+0x1d4>
	list->tail = node;
  40f5fc:	a9000e63 	stp	x3, x3, [x19]
	z_handle_obj_poll_events(&queue->poll_events, state);
  40f600:	9100a260 	add	x0, x19, #0x28
  40f604:	52800081 	mov	w1, #0x4                   	// #4
  40f608:	94000feb 	bl	4135b4 <z_handle_obj_poll_events>
  40f60c:	17ffffbd 	b	40f500 <queue_insert+0xc4>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f610:	f9400020 	ldr	x0, [x1]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f614:	92400400 	and	x0, x0, #0x3
  40f618:	aa000060 	orr	x0, x3, x0
  40f61c:	f9000020 	str	x0, [x1]
  40f620:	17ffffec 	b	40f5d0 <queue_insert+0x194>
  40f624:	aa000042 	orr	x2, x2, x0
  40f628:	f9000062 	str	x2, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f62c:	f94002a0 	ldr	x0, [x21]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f630:	92400400 	and	x0, x0, #0x3
  40f634:	aa000063 	orr	x3, x3, x0
  40f638:	f90002a3 	str	x3, [x21]
}
  40f63c:	17fffff1 	b	40f600 <queue_insert+0x1c4>

000000000040f640 <z_queue_node_peek>:
{
  40f640:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40f644:	910003fd 	mov	x29, sp
  40f648:	f9000bf3 	str	x19, [sp, #16]
  40f64c:	aa0003f3 	mov	x19, x0
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
  40f650:	b4000100 	cbz	x0, 40f670 <z_queue_node_peek+0x30>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f654:	f9400003 	ldr	x3, [x0]
  40f658:	f240047f 	tst	x3, #0x3
  40f65c:	540000a0 	b.eq	40f670 <z_queue_node_peek+0x30>  // b.none
  40f660:	12001c21 	and	w1, w1, #0xff
		ret = anode->data;
  40f664:	f9400413 	ldr	x19, [x0, #8]
		if (needs_free) {
  40f668:	34000041 	cbz	w1, 40f670 <z_queue_node_peek+0x30>
			k_free(anode);
  40f66c:	94000fdc 	bl	4135dc <k_free>
}
  40f670:	aa1303e0 	mov	x0, x19
  40f674:	f9400bf3 	ldr	x19, [sp, #16]
  40f678:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f67c:	d65f03c0 	ret

000000000040f680 <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
  40f680:	aa0103e2 	mov	x2, x1
  40f684:	52800004 	mov	w4, #0x0                   	// #0
  40f688:	52800003 	mov	w3, #0x0                   	// #0
  40f68c:	d2800001 	mov	x1, #0x0                   	// #0
  40f690:	17ffff6b 	b	40f43c <queue_insert>

000000000040f694 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
  40f694:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40f698:	910003fd 	mov	x29, sp
  40f69c:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  40f6a0:	91004014 	add	x20, x0, #0x10
{
  40f6a4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f6a8:	aa0003f5 	mov	x21, x0
  40f6ac:	f9001bf7 	str	x23, [sp, #48]
  40f6b0:	aa0103f7 	mov	x23, x1
	return posix_irq_lock();
  40f6b4:	97ffea9c 	bl	40a124 <posix_irq_lock>
  40f6b8:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f6bc:	aa1403e0 	mov	x0, x20
  40f6c0:	97fffc40 	bl	40e7c0 <z_spin_lock_valid>
  40f6c4:	72001c1f 	tst	w0, #0xff
  40f6c8:	540002c1 	b.ne	40f720 <z_impl_k_queue_get+0x8c>  // b.any
  40f6cc:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f6d0:	91391a73 	add	x19, x19, #0xe46
  40f6d4:	aa1303e2 	mov	x2, x19
  40f6d8:	52801283 	mov	w3, #0x94                  	// #148
  40f6dc:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f6e0:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f6e4:	9139cc21 	add	x1, x1, #0xe73
  40f6e8:	9123f800 	add	x0, x0, #0x8fe
  40f6ec:	97ffe188 	bl	407d0c <assert_print>
  40f6f0:	aa1403e1 	mov	x1, x20
  40f6f4:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f6f8:	913a2000 	add	x0, x0, #0xe88
  40f6fc:	97ffe184 	bl	407d0c <assert_print>
  40f700:	aa1303e0 	mov	x0, x19
  40f704:	52801281 	mov	w1, #0x94                  	// #148
  40f708:	97ffe1ab 	bl	407db4 <assert_post_action>
  40f70c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f710:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f714:	aa1303e1 	mov	x1, x19
  40f718:	9124f000 	add	x0, x0, #0x93c
  40f71c:	97ffeb98 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f720:	aa1403e0 	mov	x0, x20
  40f724:	97fffc3f 	bl	40e820 <z_spin_lock_set_owner>
	return list->head;
  40f728:	f94002b3 	ldr	x19, [x21]
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
  40f72c:	b4000453 	cbz	x19, 40f7b4 <z_impl_k_queue_get+0x120>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f730:	f9400260 	ldr	x0, [x19]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  40f734:	f94006a1 	ldr	x1, [x21, #8]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f738:	927ef400 	and	x0, x0, #0xfffffffffffffffc
	list->head = node;
  40f73c:	f90002a0 	str	x0, [x21]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  40f740:	eb01027f 	cmp	x19, x1
  40f744:	54000041 	b.ne	40f74c <z_impl_k_queue_get+0xb8>  // b.any
	list->tail = node;
  40f748:	f90006a0 	str	x0, [x21, #8]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
  40f74c:	aa1303e0 	mov	x0, x19
  40f750:	52800021 	mov	w1, #0x1                   	// #1
  40f754:	97ffffbb 	bl	40f640 <z_queue_node_peek>
  40f758:	aa0003f3 	mov	x19, x0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f75c:	aa1403e0 	mov	x0, x20
  40f760:	97fffc23 	bl	40e7ec <z_spin_unlock_valid>
  40f764:	72001c1f 	tst	w0, #0xff
  40f768:	540003e1 	b.ne	40f7e4 <z_impl_k_queue_get+0x150>  // b.any
  40f76c:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f770:	91391a73 	add	x19, x19, #0xe46
  40f774:	aa1303e2 	mov	x2, x19
  40f778:	52801863 	mov	w3, #0xc3                  	// #195
  40f77c:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f780:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f784:	913a8021 	add	x1, x1, #0xea0
  40f788:	9123f800 	add	x0, x0, #0x8fe
  40f78c:	97ffe160 	bl	407d0c <assert_print>
  40f790:	aa1403e1 	mov	x1, x20
  40f794:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f798:	913adc00 	add	x0, x0, #0xeb7
  40f79c:	97ffe15c 	bl	407d0c <assert_print>
  40f7a0:	aa1303e0 	mov	x0, x19
  40f7a4:	52801861 	mov	w1, #0xc3                  	// #195
  40f7a8:	97ffe183 	bl	407db4 <assert_post_action>
  40f7ac:	52801862 	mov	w2, #0xc3                  	// #195
  40f7b0:	17ffffd8 	b	40f710 <z_impl_k_queue_get+0x7c>
		return data;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40f7b4:	b4fffd57 	cbz	x23, 40f75c <z_impl_k_queue_get+0xc8>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
  40f7b8:	aa1703e3 	mov	x3, x23
  40f7bc:	910062a2 	add	x2, x21, #0x18
  40f7c0:	2a1603e1 	mov	w1, w22
  40f7c4:	aa1403e0 	mov	x0, x20
  40f7c8:	94000747 	bl	4114e4 <z_pend_curr>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
  40f7cc:	35000100 	cbnz	w0, 40f7ec <z_impl_k_queue_get+0x158>
  40f7d0:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40f7d4:	f9473000 	ldr	x0, [x0, #3680]
  40f7d8:	f9400800 	ldr	x0, [x0, #16]
  40f7dc:	f9401013 	ldr	x19, [x0, #32]
  40f7e0:	14000003 	b	40f7ec <z_impl_k_queue_get+0x158>
	posix_irq_unlock(key);
  40f7e4:	2a1603e0 	mov	w0, w22
  40f7e8:	97ffea51 	bl	40a12c <posix_irq_unlock>
}
  40f7ec:	aa1303e0 	mov	x0, x19
  40f7f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f7f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f7f8:	f9401bf7 	ldr	x23, [sp, #48]
  40f7fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40f800:	d65f03c0 	ret

000000000040f804 <z_impl_k_sem_init>:
		      unsigned int limit)
{
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
  40f804:	7100005f 	cmp	w2, #0x0
  40f808:	7a411040 	ccmp	w2, w1, #0x0, ne  // ne = any
  40f80c:	540000e3 	b.cc	40f828 <z_impl_k_sem_init+0x24>  // b.lo, b.ul, b.last
	list->tail = (sys_dnode_t *)list;
  40f810:	a9000000 	stp	x0, x0, [x0]

		return -EINVAL;
	}

	sem->count = initial_count;
	sem->limit = limit;
  40f814:	29020801 	stp	w1, w2, [x0, #16]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
  40f818:	91006001 	add	x1, x0, #0x18
  40f81c:	a9018401 	stp	x1, x1, [x0, #24]
#endif
	z_object_init(sem);

	return 0;
  40f820:	52800000 	mov	w0, #0x0                   	// #0
}
  40f824:	d65f03c0 	ret
		return -EINVAL;
  40f828:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40f82c:	17fffffe 	b	40f824 <z_impl_k_sem_init+0x20>

000000000040f830 <z_impl_k_sem_give>:
	return false;
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  40f830:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40f834:	910003fd 	mov	x29, sp
  40f838:	a90153f3 	stp	x19, x20, [sp, #16]
  40f83c:	aa0003f3 	mov	x19, x0
  40f840:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40f844:	97ffea38 	bl	40a124 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f848:	d00000f6 	adrp	x22, 42d000 <counter_period>
  40f84c:	9124e2d5 	add	x21, x22, #0x938
  40f850:	2a0003f4 	mov	w20, w0
  40f854:	aa1503e0 	mov	x0, x21
  40f858:	97fffbda 	bl	40e7c0 <z_spin_lock_valid>
  40f85c:	72001c1f 	tst	w0, #0xff
  40f860:	540002c1 	b.ne	40f8b8 <z_impl_k_sem_give+0x88>  // b.any
  40f864:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40f868:	91391a73 	add	x19, x19, #0xe46
  40f86c:	aa1303e2 	mov	x2, x19
  40f870:	52801283 	mov	w3, #0x94                  	// #148
  40f874:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f878:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f87c:	9139cc21 	add	x1, x1, #0xe73
  40f880:	9123f800 	add	x0, x0, #0x8fe
  40f884:	97ffe122 	bl	407d0c <assert_print>
  40f888:	aa1503e1 	mov	x1, x21
  40f88c:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f890:	913a2000 	add	x0, x0, #0xe88
  40f894:	97ffe11e 	bl	407d0c <assert_print>
  40f898:	aa1303e0 	mov	x0, x19
  40f89c:	52801281 	mov	w1, #0x94                  	// #148
  40f8a0:	97ffe145 	bl	407db4 <assert_post_action>
  40f8a4:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f8a8:	aa1303e1 	mov	x1, x19
  40f8ac:	9124f000 	add	x0, x0, #0x93c
  40f8b0:	52801282 	mov	w2, #0x94                  	// #148
  40f8b4:	97ffeb32 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f8b8:	aa1503e0 	mov	x0, x21
  40f8bc:	97fffbd9 	bl	40e820 <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool resched = true;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
  40f8c0:	aa1303e0 	mov	x0, x19
  40f8c4:	94000910 	bl	411d04 <z_unpend_first_thread>

	if (thread != NULL) {
  40f8c8:	b4000120 	cbz	x0, 40f8ec <z_impl_k_sem_give+0xbc>
  40f8cc:	b9004c1f 	str	wzr, [x0, #76]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
  40f8d0:	940005bc 	bl	410fc0 <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		resched = handle_poll_events(sem);
	}

	if (resched) {
		z_reschedule(&lock, key);
  40f8d4:	2a1403e1 	mov	w1, w20
  40f8d8:	9124e2c0 	add	x0, x22, #0x938
	} else {
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
  40f8dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f8e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f8e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&lock, key);
  40f8e8:	1400035b 	b	410654 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f8ec:	29420262 	ldp	w2, w0, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f8f0:	52800041 	mov	w1, #0x2                   	// #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f8f4:	6b02001f 	cmp	w0, w2
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f8f8:	91006260 	add	x0, x19, #0x18
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f8fc:	1a820442 	cinc	w2, w2, ne  // ne = any
  40f900:	b9001262 	str	w2, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f904:	94000f2c 	bl	4135b4 <z_handle_obj_poll_events>
	return true;
  40f908:	17fffff3 	b	40f8d4 <z_impl_k_sem_give+0xa4>

000000000040f90c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
  40f90c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40f910:	910003fd 	mov	x29, sp
  40f914:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f918:	aa0003f5 	mov	x21, x0
	return _kernel.cpus[0].nested != 0U;
  40f91c:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40f920:	a90153f3 	stp	x19, x20, [sp, #16]
  40f924:	aa0103f6 	mov	x22, x1
  40f928:	f9473000 	ldr	x0, [x0, #3680]
  40f92c:	f9001bf7 	str	x23, [sp, #48]
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
  40f930:	b9400000 	ldr	w0, [x0]
  40f934:	34000280 	cbz	w0, 40f984 <z_impl_k_sem_take+0x78>
  40f938:	b4000261 	cbz	x1, 40f984 <z_impl_k_sem_take+0x78>
  40f93c:	f0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  40f940:	91144673 	add	x19, x19, #0x511
  40f944:	aa1303e2 	mov	x2, x19
  40f948:	f0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  40f94c:	9114c421 	add	x1, x1, #0x531
  40f950:	52801003 	mov	w3, #0x80                  	// #128
  40f954:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f958:	9123f800 	add	x0, x0, #0x8fe
  40f95c:	97ffe0ec 	bl	407d0c <assert_print>
  40f960:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f964:	913b7400 	add	x0, x0, #0xedd
  40f968:	97ffe0e9 	bl	407d0c <assert_print>
  40f96c:	aa1303e0 	mov	x0, x19
  40f970:	52801001 	mov	w1, #0x80                  	// #128
  40f974:	97ffe110 	bl	407db4 <assert_post_action>
  40f978:	52801002 	mov	w2, #0x80                  	// #128
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f97c:	aa1303e1 	mov	x1, x19
  40f980:	1400001b 	b	40f9ec <z_impl_k_sem_take+0xe0>
  40f984:	97ffe9e8 	bl	40a124 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f988:	d00000f7 	adrp	x23, 42d000 <counter_period>
  40f98c:	9124e2f3 	add	x19, x23, #0x938
  40f990:	2a0003f4 	mov	w20, w0
  40f994:	aa1303e0 	mov	x0, x19
  40f998:	97fffb8a 	bl	40e7c0 <z_spin_lock_valid>
  40f99c:	72001c1f 	tst	w0, #0xff
  40f9a0:	540002c1 	b.ne	40f9f8 <z_impl_k_sem_take+0xec>  // b.any
  40f9a4:	d0000034 	adrp	x20, 415000 <random_data+0xb30>
  40f9a8:	91391a94 	add	x20, x20, #0xe46
  40f9ac:	aa1403e2 	mov	x2, x20
  40f9b0:	52801283 	mov	w3, #0x94                  	// #148
  40f9b4:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40f9b8:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f9bc:	9139cc21 	add	x1, x1, #0xe73
  40f9c0:	9123f800 	add	x0, x0, #0x8fe
  40f9c4:	97ffe0d2 	bl	407d0c <assert_print>
  40f9c8:	aa1303e1 	mov	x1, x19
  40f9cc:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40f9d0:	913a2000 	add	x0, x0, #0xe88
  40f9d4:	97ffe0ce 	bl	407d0c <assert_print>
  40f9d8:	52801281 	mov	w1, #0x94                  	// #148
  40f9dc:	aa1403e0 	mov	x0, x20
  40f9e0:	97ffe0f5 	bl	407db4 <assert_post_action>
  40f9e4:	aa1403e1 	mov	x1, x20
  40f9e8:	52801282 	mov	w2, #0x94                  	// #148
  40f9ec:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40f9f0:	9124f000 	add	x0, x0, #0x93c
  40f9f4:	97ffeae2 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f9f8:	aa1303e0 	mov	x0, x19
  40f9fc:	97fffb89 	bl	40e820 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
  40fa00:	b94012a0 	ldr	w0, [x21, #16]
  40fa04:	34000420 	cbz	w0, 40fa88 <z_impl_k_sem_take+0x17c>
		sem->count--;
  40fa08:	51000400 	sub	w0, w0, #0x1
  40fa0c:	b90012a0 	str	w0, [x21, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fa10:	aa1303e0 	mov	x0, x19
  40fa14:	97fffb76 	bl	40e7ec <z_spin_unlock_valid>
  40fa18:	72001c1f 	tst	w0, #0xff
  40fa1c:	54000261 	b.ne	40fa68 <z_impl_k_sem_take+0x15c>  // b.any
  40fa20:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40fa24:	91391a73 	add	x19, x19, #0xe46
  40fa28:	aa1303e2 	mov	x2, x19
  40fa2c:	52801863 	mov	w3, #0xc3                  	// #195
  40fa30:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40fa34:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40fa38:	913a8021 	add	x1, x1, #0xea0
  40fa3c:	9123f800 	add	x0, x0, #0x8fe
  40fa40:	97ffe0b3 	bl	407d0c <assert_print>
  40fa44:	9124e2e1 	add	x1, x23, #0x938
  40fa48:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40fa4c:	913adc00 	add	x0, x0, #0xeb7
  40fa50:	97ffe0af 	bl	407d0c <assert_print>
  40fa54:	aa1303e0 	mov	x0, x19
  40fa58:	52801861 	mov	w1, #0xc3                  	// #195
  40fa5c:	97ffe0d6 	bl	407db4 <assert_post_action>
  40fa60:	52801862 	mov	w2, #0xc3                  	// #195
  40fa64:	17ffffc6 	b	40f97c <z_impl_k_sem_take+0x70>
	posix_irq_unlock(key);
  40fa68:	2a1403e0 	mov	w0, w20
  40fa6c:	97ffe9b0 	bl	40a12c <posix_irq_unlock>
		k_spin_unlock(&lock, key);
		ret = 0;
  40fa70:	52800000 	mov	w0, #0x0                   	// #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
  40fa74:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fa78:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fa7c:	f9401bf7 	ldr	x23, [sp, #48]
  40fa80:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40fa84:	d65f03c0 	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40fa88:	b5000136 	cbnz	x22, 40faac <z_impl_k_sem_take+0x1a0>
  40fa8c:	aa1303e0 	mov	x0, x19
  40fa90:	97fffb57 	bl	40e7ec <z_spin_unlock_valid>
  40fa94:	72001c1f 	tst	w0, #0xff
  40fa98:	54fffc40 	b.eq	40fa20 <z_impl_k_sem_take+0x114>  // b.none
  40fa9c:	2a1403e0 	mov	w0, w20
  40faa0:	97ffe9a3 	bl	40a12c <posix_irq_unlock>
		ret = -EBUSY;
  40faa4:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40faa8:	17fffff3 	b	40fa74 <z_impl_k_sem_take+0x168>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  40faac:	aa1603e3 	mov	x3, x22
  40fab0:	aa1503e2 	mov	x2, x21
  40fab4:	2a1403e1 	mov	w1, w20
  40fab8:	aa1303e0 	mov	x0, x19
}
  40fabc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fac0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fac4:	f9401bf7 	ldr	x23, [sp, #48]
  40fac8:	a8c47bfd 	ldp	x29, x30, [sp], #64
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  40facc:	14000686 	b	4114e4 <z_pend_curr>

000000000040fad0 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
  40fad0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40fad4:	910003fd 	mov	x29, sp
  40fad8:	a90153f3 	stp	x19, x20, [sp, #16]
  40fadc:	aa0003f3 	mov	x19, x0
  40fae0:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40fae4:	97ffe990 	bl	40a124 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fae8:	d00000f6 	adrp	x22, 42d000 <counter_period>
  40faec:	9124e2d5 	add	x21, x22, #0x938
  40faf0:	2a0003f4 	mov	w20, w0
  40faf4:	aa1503e0 	mov	x0, x21
  40faf8:	97fffb32 	bl	40e7c0 <z_spin_lock_valid>
  40fafc:	72001c1f 	tst	w0, #0xff
  40fb00:	540002c1 	b.ne	40fb58 <z_impl_k_sem_reset+0x88>  // b.any
  40fb04:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40fb08:	91391a73 	add	x19, x19, #0xe46
  40fb0c:	aa1303e2 	mov	x2, x19
  40fb10:	52801283 	mov	w3, #0x94                  	// #148
  40fb14:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40fb18:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40fb1c:	9139cc21 	add	x1, x1, #0xe73
  40fb20:	9123f800 	add	x0, x0, #0x8fe
  40fb24:	97ffe07a 	bl	407d0c <assert_print>
  40fb28:	aa1503e1 	mov	x1, x21
  40fb2c:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40fb30:	913a2000 	add	x0, x0, #0xe88
  40fb34:	97ffe076 	bl	407d0c <assert_print>
  40fb38:	aa1303e0 	mov	x0, x19
  40fb3c:	52801281 	mov	w1, #0x94                  	// #148
  40fb40:	97ffe09d 	bl	407db4 <assert_post_action>
  40fb44:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40fb48:	aa1303e1 	mov	x1, x19
  40fb4c:	9124f000 	add	x0, x0, #0x93c
  40fb50:	52801282 	mov	w2, #0x94                  	// #148
  40fb54:	97ffea8a 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40fb58:	aa1503e0 	mov	x0, x21
	thread->callee_saved.retval = value;
  40fb5c:	12800155 	mov	w21, #0xfffffff5            	// #-11
  40fb60:	97fffb30 	bl	40e820 <z_spin_lock_set_owner>
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
  40fb64:	aa1303e0 	mov	x0, x19
  40fb68:	94000867 	bl	411d04 <z_unpend_first_thread>
		if (thread == NULL) {
  40fb6c:	b4000080 	cbz	x0, 40fb7c <z_impl_k_sem_reset+0xac>
  40fb70:	b9004c15 	str	w21, [x0, #76]
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
  40fb74:	94000513 	bl	410fc0 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
  40fb78:	17fffffb 	b	40fb64 <z_impl_k_sem_reset+0x94>
	}
	sem->count = 0;
  40fb7c:	b900127f 	str	wzr, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40fb80:	91006260 	add	x0, x19, #0x18
  40fb84:	52800041 	mov	w1, #0x2                   	// #2
  40fb88:	94000e8b 	bl	4135b4 <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
  40fb8c:	2a1403e1 	mov	w1, w20
  40fb90:	9124e2c0 	add	x0, x22, #0x938
}
  40fb94:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fb98:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fb9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&lock, key);
  40fba0:	140002ad 	b	410654 <z_reschedule>

000000000040fba4 <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
  40fba4:	b9400002 	ldr	w2, [x0]
	*flagp &= ~BIT(bit);
  40fba8:	d2800023 	mov	x3, #0x1                   	// #1
  40fbac:	9ac12063 	lsl	x3, x3, x1
  40fbb0:	0a230043 	bic	w3, w2, w3
  40fbb4:	b9000003 	str	w3, [x0]
	return (*flagp & BIT(bit)) != 0U;
  40fbb8:	2a0203e0 	mov	w0, w2
  40fbbc:	9ac12400 	lsr	x0, x0, x1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
  40fbc0:	12000000 	and	w0, w0, #0x1
  40fbc4:	d65f03c0 	ret

000000000040fbc8 <notify_queue_locked.isra.0>:
 */
static inline bool notify_queue_locked(struct k_work_q *queue)
{
	bool rv = false;

	if (queue != NULL) {
  40fbc8:	b40000a0 	cbz	x0, 40fbdc <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
  40fbcc:	91034000 	add	x0, x0, #0xd0
  40fbd0:	d2800002 	mov	x2, #0x0                   	// #0
  40fbd4:	52800001 	mov	w1, #0x0                   	// #0
  40fbd8:	14000b38 	b	4128b8 <z_sched_wake>
	}

	return rv;
}
  40fbdc:	d65f03c0 	ret

000000000040fbe0 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
  40fbe0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40fbe4:	910003fd 	mov	x29, sp
  40fbe8:	a90153f3 	stp	x19, x20, [sp, #16]
  40fbec:	aa0003f3 	mov	x19, x0
  40fbf0:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fbf4:	d00000f5 	adrp	x21, 42d000 <counter_period>
  40fbf8:	a90363f7 	stp	x23, x24, [sp, #48]
	return list->head;
  40fbfc:	d00000f8 	adrp	x24, 42d000 <counter_period>
	return list->tail;
  40fc00:	91252316 	add	x22, x24, #0x948
  40fc04:	a9046bf9 	stp	x25, x26, [sp, #64]
  40fc08:	97ffe947 	bl	40a124 <posix_irq_lock>
  40fc0c:	912502b4 	add	x20, x21, #0x940
  40fc10:	2a0003f7 	mov	w23, w0
  40fc14:	aa1403e0 	mov	x0, x20
  40fc18:	97fffaea 	bl	40e7c0 <z_spin_lock_valid>
  40fc1c:	72001c1f 	tst	w0, #0xff
  40fc20:	540002c1 	b.ne	40fc78 <work_queue_main+0x98>  // b.any
  40fc24:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40fc28:	91391a73 	add	x19, x19, #0xe46
  40fc2c:	aa1303e2 	mov	x2, x19
  40fc30:	52801283 	mov	w3, #0x94                  	// #148
  40fc34:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40fc38:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40fc3c:	9139cc21 	add	x1, x1, #0xe73
  40fc40:	9123f800 	add	x0, x0, #0x8fe
  40fc44:	97ffe032 	bl	407d0c <assert_print>
  40fc48:	912502a1 	add	x1, x21, #0x940
  40fc4c:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40fc50:	913a2000 	add	x0, x0, #0xe88
  40fc54:	97ffe02e 	bl	407d0c <assert_print>
  40fc58:	aa1303e0 	mov	x0, x19
  40fc5c:	52801281 	mov	w1, #0x94                  	// #148
  40fc60:	97ffe055 	bl	407db4 <assert_post_action>
  40fc64:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fc68:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40fc6c:	aa1303e1 	mov	x1, x19
  40fc70:	9124f000 	add	x0, x0, #0x93c
  40fc74:	97ffea42 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40fc78:	aa1403e0 	mov	x0, x20
  40fc7c:	97fffae9 	bl	40e820 <z_spin_lock_set_owner>
	return list->head;
  40fc80:	f9406274 	ldr	x20, [x19, #192]
Z_GENLIST_GET(slist, snode)
  40fc84:	b50001b4 	cbnz	x20, 40fcb8 <work_queue_main+0xd8>
			 * which should never happen, even line 'if (work != NULL)'
			 * ensures that.
			 * This means that if node is not NULL, then work will not be NULL.
			 */
			handler = work->handler;
		} else if (flag_test_and_clear(&queue->flags,
  40fc88:	9103c260 	add	x0, x19, #0xf0
  40fc8c:	52800041 	mov	w1, #0x2                   	// #2
  40fc90:	97ffffc5 	bl	40fba4 <flag_test_and_clear>
  40fc94:	72001c1f 	tst	w0, #0xff
  40fc98:	54000581 	b.ne	40fd48 <work_queue_main+0x168>  // b.any
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
  40fc9c:	91034262 	add	x2, x19, #0xd0
  40fca0:	2a1703e1 	mov	w1, w23
  40fca4:	912502a0 	add	x0, x21, #0x940
  40fca8:	d2800004 	mov	x4, #0x0                   	// #0
  40fcac:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40fcb0:	94000b58 	bl	412a10 <z_sched_wait>
					   K_FOREVER, NULL);
			continue;
  40fcb4:	17ffffd5 	b	40fc08 <work_queue_main+0x28>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  40fcb8:	f9406661 	ldr	x1, [x19, #200]
	return node->next;
  40fcbc:	f9400280 	ldr	x0, [x20]
	list->head = node;
  40fcc0:	f9006260 	str	x0, [x19, #192]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  40fcc4:	eb01029f 	cmp	x20, x1
  40fcc8:	54000041 	b.ne	40fcd0 <work_queue_main+0xf0>  // b.any
	list->tail = node;
  40fccc:	f9006660 	str	x0, [x19, #200]
	*flagp |= BIT(bit);
  40fcd0:	b940f260 	ldr	w0, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fcd4:	912502b9 	add	x25, x21, #0x940
  40fcd8:	321f0000 	orr	w0, w0, #0x2
  40fcdc:	b900f260 	str	w0, [x19, #240]
  40fce0:	aa1903e0 	mov	x0, x25
	*flagp &= ~BIT(bit);
  40fce4:	b9401a82 	ldr	w2, [x20, #24]
			handler = work->handler;
  40fce8:	f940069a 	ldr	x26, [x20, #8]
	*flagp &= ~BIT(bit);
  40fcec:	121d7842 	and	w2, w2, #0xfffffffb
  40fcf0:	32000042 	orr	w2, w2, #0x1
  40fcf4:	b9001a82 	str	w2, [x20, #24]
  40fcf8:	97fffabd 	bl	40e7ec <z_spin_unlock_valid>
  40fcfc:	72001c1f 	tst	w0, #0xff
  40fd00:	54000600 	b.eq	40fdc0 <work_queue_main+0x1e0>  // b.none
	posix_irq_unlock(key);
  40fd04:	2a1703e0 	mov	w0, w23
  40fd08:	97ffe909 	bl	40a12c <posix_irq_unlock>
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
  40fd0c:	b50002fa 	cbnz	x26, 40fd68 <work_queue_main+0x188>
  40fd10:	f0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  40fd14:	9115fe73 	add	x19, x19, #0x57f
  40fd18:	aa1303e2 	mov	x2, x19
  40fd1c:	52805363 	mov	w3, #0x29b                 	// #667
  40fd20:	f0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  40fd24:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40fd28:	91168021 	add	x1, x1, #0x5a0
  40fd2c:	9123f800 	add	x0, x0, #0x8fe
  40fd30:	97ffdff7 	bl	407d0c <assert_print>
  40fd34:	aa1303e0 	mov	x0, x19
  40fd38:	52805361 	mov	w1, #0x29b                 	// #667
  40fd3c:	97ffe01e 	bl	407db4 <assert_post_action>
  40fd40:	52805362 	mov	w2, #0x29b                 	// #667
  40fd44:	17ffffc9 	b	40fc68 <work_queue_main+0x88>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
  40fd48:	91038274 	add	x20, x19, #0xe0
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
  40fd4c:	aa1403e0 	mov	x0, x20
  40fd50:	d2800002 	mov	x2, #0x0                   	// #0
  40fd54:	52800021 	mov	w1, #0x1                   	// #1
  40fd58:	94000ad8 	bl	4128b8 <z_sched_wake>
  40fd5c:	72001c1f 	tst	w0, #0xff
  40fd60:	54ffff61 	b.ne	40fd4c <work_queue_main+0x16c>  // b.any
  40fd64:	17ffffce 	b	40fc9c <work_queue_main+0xbc>
		handler(work);
  40fd68:	aa1403e0 	mov	x0, x20
  40fd6c:	d63f0340 	blr	x26
	return posix_irq_lock();
  40fd70:	97ffe8ed 	bl	40a124 <posix_irq_lock>
  40fd74:	2a0003f7 	mov	w23, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fd78:	aa1903e0 	mov	x0, x25
  40fd7c:	97fffa91 	bl	40e7c0 <z_spin_lock_valid>
  40fd80:	72001c1f 	tst	w0, #0xff
  40fd84:	54fff500 	b.eq	40fc24 <work_queue_main+0x44>  // b.none
	z_spin_lock_set_owner(l);
  40fd88:	aa1903e0 	mov	x0, x25
  40fd8c:	97fffaa5 	bl	40e820 <z_spin_lock_set_owner>
	*flagp &= ~BIT(bit);
  40fd90:	b9401a80 	ldr	w0, [x20, #24]
  40fd94:	121f7801 	and	w1, w0, #0xfffffffe
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  40fd98:	37080380 	tbnz	w0, #1, 40fe08 <work_queue_main+0x228>
	*flagp &= ~BIT(bit);
  40fd9c:	b9001a81 	str	w1, [x20, #24]
  40fda0:	b940f261 	ldr	w1, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fda4:	912502a0 	add	x0, x21, #0x940
  40fda8:	121e7821 	and	w1, w1, #0xfffffffd
  40fdac:	b900f261 	str	w1, [x19, #240]
	return (*flagp & BIT(bit)) != 0U;
  40fdb0:	d3482034 	ubfx	x20, x1, #8, #1
  40fdb4:	97fffa8e 	bl	40e7ec <z_spin_unlock_valid>
  40fdb8:	72001c1f 	tst	w0, #0xff
  40fdbc:	54000641 	b.ne	40fe84 <work_queue_main+0x2a4>  // b.any
  40fdc0:	d0000033 	adrp	x19, 415000 <random_data+0xb30>
  40fdc4:	91391a73 	add	x19, x19, #0xe46
  40fdc8:	aa1303e2 	mov	x2, x19
  40fdcc:	52801863 	mov	w3, #0xc3                  	// #195
  40fdd0:	d0000021 	adrp	x1, 415000 <random_data+0xb30>
  40fdd4:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40fdd8:	913a8021 	add	x1, x1, #0xea0
  40fddc:	9123f800 	add	x0, x0, #0x8fe
  40fde0:	97ffdfcb 	bl	407d0c <assert_print>
  40fde4:	912502a1 	add	x1, x21, #0x940
  40fde8:	d0000020 	adrp	x0, 415000 <random_data+0xb30>
  40fdec:	913adc00 	add	x0, x0, #0xeb7
  40fdf0:	97ffdfc7 	bl	407d0c <assert_print>
  40fdf4:	aa1303e0 	mov	x0, x19
  40fdf8:	52801861 	mov	w1, #0xc3                  	// #195
  40fdfc:	97ffdfee 	bl	407db4 <assert_post_action>
  40fe00:	52801862 	mov	w2, #0xc3                  	// #195
  40fe04:	17ffff99 	b	40fc68 <work_queue_main+0x88>
	*flagp &= ~BIT(bit);
  40fe08:	121e7400 	and	w0, w0, #0xfffffffc
  40fe0c:	b9001a80 	str	w0, [x20, #24]
	return list->head;
  40fe10:	f944a700 	ldr	x0, [x24, #2376]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  40fe14:	b4fffc60 	cbz	x0, 40fda0 <work_queue_main+0x1c0>
	return node->next;
  40fe18:	f940001a 	ldr	x26, [x0]
  40fe1c:	d2800019 	mov	x25, #0x0                   	// #0
		if (wc->work == work) {
  40fe20:	f9400402 	ldr	x2, [x0, #8]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
  40fe24:	aa0003e1 	mov	x1, x0
		if (wc->work == work) {
  40fe28:	eb02029f 	cmp	x20, x2
  40fe2c:	54000161 	b.ne	40fe58 <work_queue_main+0x278>  // b.any
  40fe30:	f9400001 	ldr	x1, [x0]
Z_GENLIST_REMOVE(slist, snode)
  40fe34:	b50001d9 	cbnz	x25, 40fe6c <work_queue_main+0x28c>
  40fe38:	f94006c2 	ldr	x2, [x22, #8]
	list->head = node;
  40fe3c:	f90002c1 	str	x1, [x22]
Z_GENLIST_REMOVE(slist, snode)
  40fe40:	eb00005f 	cmp	x2, x0
  40fe44:	54000041 	b.ne	40fe4c <work_queue_main+0x26c>  // b.any
	list->tail = node;
  40fe48:	f90006c1 	str	x1, [x22, #8]
	parent->next = child;
  40fe4c:	f801041f 	str	xzr, [x0], #16
	z_impl_k_sem_give(sem);
  40fe50:	97fffe78 	bl	40f830 <z_impl_k_sem_give>
}
  40fe54:	aa1903e1 	mov	x1, x25
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  40fe58:	b4fffa5a 	cbz	x26, 40fda0 <work_queue_main+0x1c0>
	return node->next;
  40fe5c:	aa1a03e0 	mov	x0, x26
  40fe60:	aa0103f9 	mov	x25, x1
  40fe64:	f940035a 	ldr	x26, [x26]
  40fe68:	17ffffee 	b	40fe20 <work_queue_main+0x240>
	parent->next = child;
  40fe6c:	f9000321 	str	x1, [x25]
Z_GENLIST_REMOVE(slist, snode)
  40fe70:	f94006c1 	ldr	x1, [x22, #8]
  40fe74:	eb00003f 	cmp	x1, x0
  40fe78:	54fffea1 	b.ne	40fe4c <work_queue_main+0x26c>  // b.any
	list->tail = node;
  40fe7c:	f90006d9 	str	x25, [x22, #8]
}
  40fe80:	17fffff3 	b	40fe4c <work_queue_main+0x26c>
	posix_irq_unlock(key);
  40fe84:	2a1703e0 	mov	w0, w23
  40fe88:	97ffe8a9 	bl	40a12c <posix_irq_unlock>
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
  40fe8c:	35ffebf4 	cbnz	w20, 40fc08 <work_queue_main+0x28>
	z_impl_k_yield();
  40fe90:	94000800 	bl	411e90 <z_impl_k_yield>
}
  40fe94:	17ffff5d 	b	40fc08 <work_queue_main+0x28>

000000000040fe98 <submit_to_queue_locked>:
{
  40fe98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40fe9c:	910003fd 	mov	x29, sp
  40fea0:	a90153f3 	stp	x19, x20, [sp, #16]
  40fea4:	aa0003f3 	mov	x19, x0
  40fea8:	aa0103f4 	mov	x20, x1
  40feac:	a9025bf5 	stp	x21, x22, [sp, #32]
	return (*flagp & BIT(bit)) != 0U;
  40feb0:	b9401800 	ldr	w0, [x0, #24]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  40feb4:	721f001f 	tst	w0, #0x2
  40feb8:	54000941 	b.ne	40ffe0 <submit_to_queue_locked+0x148>  // b.any
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
  40febc:	721e001f 	tst	w0, #0x4
  40fec0:	54000961 	b.ne	40ffec <submit_to_queue_locked+0x154>  // b.any
		if (*queuep == NULL) {
  40fec4:	f9400020 	ldr	x0, [x1]
  40fec8:	b5000060 	cbnz	x0, 40fed4 <submit_to_queue_locked+0x3c>
			*queuep = work->queue;
  40fecc:	f9400a60 	ldr	x0, [x19, #16]
  40fed0:	f9000020 	str	x0, [x1]
	return (*flagp & BIT(bit)) != 0U;
  40fed4:	b9401a60 	ldr	w0, [x19, #24]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
  40fed8:	36000760 	tbz	w0, #0, 40ffc4 <submit_to_queue_locked+0x12c>
			__ASSERT_NO_MSG(work->queue != NULL);
  40fedc:	f9400a60 	ldr	x0, [x19, #16]
  40fee0:	b5000240 	cbnz	x0, 40ff28 <submit_to_queue_locked+0x90>
  40fee4:	f0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  40fee8:	9115fe73 	add	x19, x19, #0x57f
  40feec:	aa1303e2 	mov	x2, x19
  40fef0:	528029c3 	mov	w3, #0x14e                 	// #334
  40fef4:	f0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  40fef8:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40fefc:	9116dc21 	add	x1, x1, #0x5b7
  40ff00:	9123f800 	add	x0, x0, #0x8fe
  40ff04:	97ffdf82 	bl	407d0c <assert_print>
  40ff08:	aa1303e0 	mov	x0, x19
  40ff0c:	528029c1 	mov	w1, #0x14e                 	// #334
  40ff10:	97ffdfa9 	bl	407db4 <assert_post_action>
  40ff14:	b0000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  40ff18:	aa1303e1 	mov	x1, x19
  40ff1c:	9124f000 	add	x0, x0, #0x93c
  40ff20:	528029c2 	mov	w2, #0x14e                 	// #334
  40ff24:	97ffe996 	bl	40a57c <posix_print_error_and_exit>
			ret = 2;
  40ff28:	52800056 	mov	w22, #0x2                   	// #2
			*queuep = work->queue;
  40ff2c:	f9000280 	str	x0, [x20]
		int rc = queue_submit_locked(*queuep, work);
  40ff30:	f9400295 	ldr	x21, [x20]
	if (queue == NULL) {
  40ff34:	b4000615 	cbz	x21, 40fff4 <submit_to_queue_locked+0x15c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40ff38:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  40ff3c:	f9473000 	ldr	x0, [x0, #3680]
  40ff40:	f9400800 	ldr	x0, [x0, #16]
  40ff44:	eb15001f 	cmp	x0, x21
  40ff48:	54000421 	b.ne	40ffcc <submit_to_queue_locked+0x134>  // b.any
  40ff4c:	97fff910 	bl	40e38c <k_is_in_isr>
  40ff50:	12001c00 	and	w0, w0, #0xff
  40ff54:	52000000 	eor	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  40ff58:	b940f2a2 	ldr	w2, [x21, #240]
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40ff5c:	12000000 	and	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  40ff60:	d3420841 	ubfx	x1, x2, #2, #1
  40ff64:	d3430c43 	ubfx	x3, x2, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
  40ff68:	360004a2 	tbz	w2, #0, 40fffc <submit_to_queue_locked+0x164>
	} else if (draining && !chained) {
  40ff6c:	52000000 	eor	w0, w0, #0x1
  40ff70:	6a00003f 	tst	w1, w0
  40ff74:	54000361 	b.ne	40ffe0 <submit_to_queue_locked+0x148>  // b.any
	} else if (plugged && !draining) {
  40ff78:	52000021 	eor	w1, w1, #0x1
  40ff7c:	6a01007f 	tst	w3, w1
  40ff80:	54000301 	b.ne	40ffe0 <submit_to_queue_locked+0x148>  // b.any
	parent->next = child;
  40ff84:	f900027f 	str	xzr, [x19]
	return list->tail;
  40ff88:	f94066a0 	ldr	x0, [x21, #200]
Z_GENLIST_APPEND(slist, snode)
  40ff8c:	b5000240 	cbnz	x0, 40ffd4 <submit_to_queue_locked+0x13c>
	list->tail = node;
  40ff90:	a90c4eb3 	stp	x19, x19, [x21, #192]
		(void)notify_queue_locked(queue);
  40ff94:	aa1503e0 	mov	x0, x21
  40ff98:	97ffff0c 	bl	40fbc8 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
  40ff9c:	b9401a60 	ldr	w0, [x19, #24]
  40ffa0:	321e0000 	orr	w0, w0, #0x4
  40ffa4:	b9001a60 	str	w0, [x19, #24]
			work->queue = *queuep;
  40ffa8:	f9400280 	ldr	x0, [x20]
  40ffac:	f9000a60 	str	x0, [x19, #16]
}
  40ffb0:	2a1603e0 	mov	w0, w22
  40ffb4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ffb8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ffbc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40ffc0:	d65f03c0 	ret
		ret = 1;
  40ffc4:	52800036 	mov	w22, #0x1                   	// #1
  40ffc8:	17ffffda 	b	40ff30 <submit_to_queue_locked+0x98>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40ffcc:	52800000 	mov	w0, #0x0                   	// #0
  40ffd0:	17ffffe2 	b	40ff58 <submit_to_queue_locked+0xc0>
	parent->next = child;
  40ffd4:	f9000013 	str	x19, [x0]
	list->tail = node;
  40ffd8:	f90066b3 	str	x19, [x21, #200]
}
  40ffdc:	17ffffee 	b	40ff94 <submit_to_queue_locked+0xfc>
		ret = -EBUSY;
  40ffe0:	128001f6 	mov	w22, #0xfffffff0            	// #-16
		*queuep = NULL;
  40ffe4:	f900029f 	str	xzr, [x20]
	return ret;
  40ffe8:	17fffff2 	b	40ffb0 <submit_to_queue_locked+0x118>
	int ret = 0;
  40ffec:	52800016 	mov	w22, #0x0                   	// #0
  40fff0:	17fffffd 	b	40ffe4 <submit_to_queue_locked+0x14c>
		return -EINVAL;
  40fff4:	128002b6 	mov	w22, #0xffffffea            	// #-22
  40fff8:	17fffffb 	b	40ffe4 <submit_to_queue_locked+0x14c>
		ret = -ENODEV;
  40fffc:	12800256 	mov	w22, #0xffffffed            	// #-19
  410000:	17fffff9 	b	40ffe4 <submit_to_queue_locked+0x14c>

0000000000410004 <k_work_init>:
{
  410004:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410008:	910003fd 	mov	x29, sp
  41000c:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(work != NULL);
  410010:	b5000240 	cbnz	x0, 410058 <k_work_init+0x54>
  410014:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  410018:	9115fe73 	add	x19, x19, #0x57f
  41001c:	aa1303e2 	mov	x2, x19
  410020:	52801123 	mov	w3, #0x89                  	// #137
  410024:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  410028:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41002c:	91174821 	add	x1, x1, #0x5d2
  410030:	9123f800 	add	x0, x0, #0x8fe
  410034:	97ffdf36 	bl	407d0c <assert_print>
  410038:	aa1303e0 	mov	x0, x19
  41003c:	52801121 	mov	w1, #0x89                  	// #137
  410040:	97ffdf5d 	bl	407db4 <assert_post_action>
  410044:	52801122 	mov	w2, #0x89                  	// #137
	__ASSERT_NO_MSG(handler != NULL);
  410048:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41004c:	aa1303e1 	mov	x1, x19
  410050:	9124f000 	add	x0, x0, #0x93c
  410054:	97ffe94a 	bl	40a57c <posix_print_error_and_exit>
  410058:	b50001e1 	cbnz	x1, 410094 <k_work_init+0x90>
  41005c:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  410060:	9115fe73 	add	x19, x19, #0x57f
  410064:	aa1303e2 	mov	x2, x19
  410068:	52801143 	mov	w3, #0x8a                  	// #138
  41006c:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  410070:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410074:	91168021 	add	x1, x1, #0x5a0
  410078:	9123f800 	add	x0, x0, #0x8fe
  41007c:	97ffdf24 	bl	407d0c <assert_print>
  410080:	aa1303e0 	mov	x0, x19
  410084:	52801141 	mov	w1, #0x8a                  	// #138
  410088:	97ffdf4b 	bl	407db4 <assert_post_action>
  41008c:	52801142 	mov	w2, #0x8a                  	// #138
  410090:	17ffffee 	b	410048 <k_work_init+0x44>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  410094:	a9007c1f 	stp	xzr, xzr, [x0]
  410098:	f9000401 	str	x1, [x0, #8]
  41009c:	a9017c1f 	stp	xzr, xzr, [x0, #16]
}
  4100a0:	f9400bf3 	ldr	x19, [sp, #16]
  4100a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4100a8:	d65f03c0 	ret

00000000004100ac <z_work_submit_to_queue>:
{
  4100ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4100b0:	910003fd 	mov	x29, sp
  4100b4:	a90153f3 	stp	x19, x20, [sp, #16]
  4100b8:	f90013f5 	str	x21, [sp, #32]
  4100bc:	f9001fe0 	str	x0, [sp, #56]
	__ASSERT_NO_MSG(work != NULL);
  4100c0:	b5000241 	cbnz	x1, 410108 <z_work_submit_to_queue+0x5c>
  4100c4:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  4100c8:	9115fe73 	add	x19, x19, #0x57f
  4100cc:	aa1303e2 	mov	x2, x19
  4100d0:	52802e83 	mov	w3, #0x174                 	// #372
  4100d4:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  4100d8:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4100dc:	91174821 	add	x1, x1, #0x5d2
  4100e0:	9123f800 	add	x0, x0, #0x8fe
  4100e4:	97ffdf0a 	bl	407d0c <assert_print>
  4100e8:	52802e81 	mov	w1, #0x174                 	// #372
  4100ec:	aa1303e0 	mov	x0, x19
  4100f0:	97ffdf31 	bl	407db4 <assert_post_action>
  4100f4:	aa1303e1 	mov	x1, x19
  4100f8:	52802e82 	mov	w2, #0x174                 	// #372
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4100fc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410100:	9124f000 	add	x0, x0, #0x93c
  410104:	97ffe91e 	bl	40a57c <posix_print_error_and_exit>
  410108:	aa0103f4 	mov	x20, x1
  41010c:	b00000f3 	adrp	x19, 42d000 <counter_period>
	return posix_irq_lock();
  410110:	97ffe805 	bl	40a124 <posix_irq_lock>
  410114:	91250273 	add	x19, x19, #0x940
  410118:	2a0003f5 	mov	w21, w0
  41011c:	aa1303e0 	mov	x0, x19
  410120:	97fff9a8 	bl	40e7c0 <z_spin_lock_valid>
  410124:	72001c1f 	tst	w0, #0xff
  410128:	54000281 	b.ne	410178 <z_work_submit_to_queue+0xcc>  // b.any
  41012c:	b0000034 	adrp	x20, 415000 <random_data+0xb30>
  410130:	91391a94 	add	x20, x20, #0xe46
  410134:	aa1403e2 	mov	x2, x20
  410138:	52801283 	mov	w3, #0x94                  	// #148
  41013c:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  410140:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410144:	9139cc21 	add	x1, x1, #0xe73
  410148:	9123f800 	add	x0, x0, #0x8fe
  41014c:	97ffdef0 	bl	407d0c <assert_print>
  410150:	aa1303e1 	mov	x1, x19
  410154:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410158:	913a2000 	add	x0, x0, #0xe88
  41015c:	97ffdeec 	bl	407d0c <assert_print>
  410160:	aa1403e0 	mov	x0, x20
  410164:	52801281 	mov	w1, #0x94                  	// #148
  410168:	97ffdf13 	bl	407db4 <assert_post_action>
  41016c:	52801282 	mov	w2, #0x94                  	// #148
  410170:	aa1403e1 	mov	x1, x20
  410174:	17ffffe2 	b	4100fc <z_work_submit_to_queue+0x50>
	z_spin_lock_set_owner(l);
  410178:	aa1303e0 	mov	x0, x19
  41017c:	97fff9a9 	bl	40e820 <z_spin_lock_set_owner>
	int ret = submit_to_queue_locked(work, &queue);
  410180:	9100e3e1 	add	x1, sp, #0x38
  410184:	aa1403e0 	mov	x0, x20
  410188:	97ffff44 	bl	40fe98 <submit_to_queue_locked>
  41018c:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410190:	aa1303e0 	mov	x0, x19
  410194:	97fff996 	bl	40e7ec <z_spin_unlock_valid>
  410198:	72001c1f 	tst	w0, #0xff
  41019c:	54000261 	b.ne	4101e8 <z_work_submit_to_queue+0x13c>  // b.any
  4101a0:	b0000034 	adrp	x20, 415000 <random_data+0xb30>
  4101a4:	91391a94 	add	x20, x20, #0xe46
  4101a8:	aa1403e2 	mov	x2, x20
  4101ac:	52801863 	mov	w3, #0xc3                  	// #195
  4101b0:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  4101b4:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4101b8:	913a8021 	add	x1, x1, #0xea0
  4101bc:	9123f800 	add	x0, x0, #0x8fe
  4101c0:	97ffded3 	bl	407d0c <assert_print>
  4101c4:	aa1303e1 	mov	x1, x19
  4101c8:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  4101cc:	913adc00 	add	x0, x0, #0xeb7
  4101d0:	97ffdecf 	bl	407d0c <assert_print>
  4101d4:	aa1403e0 	mov	x0, x20
  4101d8:	52801861 	mov	w1, #0xc3                  	// #195
  4101dc:	97ffdef6 	bl	407db4 <assert_post_action>
  4101e0:	52801862 	mov	w2, #0xc3                  	// #195
  4101e4:	17ffffe3 	b	410170 <z_work_submit_to_queue+0xc4>
	posix_irq_unlock(key);
  4101e8:	2a1503e0 	mov	w0, w21
  4101ec:	97ffe7d0 	bl	40a12c <posix_irq_unlock>
}
  4101f0:	2a1403e0 	mov	w0, w20
  4101f4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4101f8:	f94013f5 	ldr	x21, [sp, #32]
  4101fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  410200:	d65f03c0 	ret

0000000000410204 <k_work_submit_to_queue>:
{
  410204:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410208:	910003fd 	mov	x29, sp
  41020c:	f9000bf3 	str	x19, [sp, #16]
	int ret = z_work_submit_to_queue(queue, work);
  410210:	97ffffa7 	bl	4100ac <z_work_submit_to_queue>
  410214:	2a0003f3 	mov	w19, w0
	if (ret > 0) {
  410218:	7100001f 	cmp	w0, #0x0
  41021c:	5400006d 	b.le	410228 <k_work_submit_to_queue+0x24>
	return posix_irq_lock();
  410220:	97ffe7c1 	bl	40a124 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
  410224:	94000150 	bl	410764 <z_reschedule_irqlock>
}
  410228:	2a1303e0 	mov	w0, w19
  41022c:	f9400bf3 	ldr	x19, [sp, #16]
  410230:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410234:	d65f03c0 	ret

0000000000410238 <k_work_submit>:
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
  410238:	aa0003e1 	mov	x1, x0
  41023c:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  410240:	f947f400 	ldr	x0, [x0, #4072]
  410244:	17fffff0 	b	410204 <k_work_submit_to_queue>

0000000000410248 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
  410248:	d100c3ff 	sub	sp, sp, #0x30
  41024c:	a9017bfd 	stp	x29, x30, [sp, #16]
  410250:	910043fd 	add	x29, sp, #0x10
  410254:	a90253f3 	stp	x19, x20, [sp, #32]
	__ASSERT_NO_MSG(queue);
  410258:	b5000240 	cbnz	x0, 4102a0 <k_work_queue_start+0x58>
  41025c:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  410260:	9115fe73 	add	x19, x19, #0x57f
  410264:	aa1303e2 	mov	x2, x19
  410268:	52805903 	mov	w3, #0x2c8                 	// #712
  41026c:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  410270:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410274:	91179821 	add	x1, x1, #0x5e6
  410278:	9123f800 	add	x0, x0, #0x8fe
  41027c:	97ffdea4 	bl	407d0c <assert_print>
  410280:	aa1303e0 	mov	x0, x19
  410284:	52805901 	mov	w1, #0x2c8                 	// #712
  410288:	97ffdecb 	bl	407db4 <assert_post_action>
  41028c:	52805902 	mov	w2, #0x2c8                 	// #712
	__ASSERT_NO_MSG(stack);
  410290:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410294:	aa1303e1 	mov	x1, x19
  410298:	9124f000 	add	x0, x0, #0x93c
  41029c:	97ffe8b8 	bl	40a57c <posix_print_error_and_exit>
  4102a0:	b50001e1 	cbnz	x1, 4102dc <k_work_queue_start+0x94>
  4102a4:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  4102a8:	9115fe73 	add	x19, x19, #0x57f
  4102ac:	aa1303e2 	mov	x2, x19
  4102b0:	52805923 	mov	w3, #0x2c9                 	// #713
  4102b4:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  4102b8:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4102bc:	9117b021 	add	x1, x1, #0x5ec
  4102c0:	9123f800 	add	x0, x0, #0x8fe
  4102c4:	97ffde92 	bl	407d0c <assert_print>
  4102c8:	aa1303e0 	mov	x0, x19
  4102cc:	52805921 	mov	w1, #0x2c9                 	// #713
  4102d0:	97ffdeb9 	bl	407db4 <assert_post_action>
  4102d4:	52805922 	mov	w2, #0x2c9                 	// #713
  4102d8:	17ffffee 	b	410290 <k_work_queue_start+0x48>
  4102dc:	aa0003f3 	mov	x19, x0
	return (*flagp & BIT(bit)) != 0U;
  4102e0:	b940f000 	ldr	w0, [x0, #240]
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
  4102e4:	360001e0 	tbz	w0, #0, 410320 <k_work_queue_start+0xd8>
  4102e8:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  4102ec:	9115fe73 	add	x19, x19, #0x57f
  4102f0:	aa1303e2 	mov	x2, x19
  4102f4:	52805943 	mov	w3, #0x2ca                 	// #714
  4102f8:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  4102fc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410300:	9117c821 	add	x1, x1, #0x5f2
  410304:	9123f800 	add	x0, x0, #0x8fe
  410308:	97ffde81 	bl	407d0c <assert_print>
  41030c:	aa1303e0 	mov	x0, x19
  410310:	52805941 	mov	w1, #0x2ca                 	// #714
  410314:	97ffdea8 	bl	407db4 <assert_post_action>
  410318:	52805942 	mov	w2, #0x2ca                 	// #714
  41031c:	17ffffdd 	b	410290 <k_work_queue_start+0x48>
  410320:	91034260 	add	x0, x19, #0xd0
	list->tail = NULL;
  410324:	a90c7e7f 	stp	xzr, xzr, [x19, #192]
  410328:	2a0303e7 	mov	w7, w3
  41032c:	a90d0260 	stp	x0, x0, [x19, #208]
  410330:	91038260 	add	x0, x19, #0xe0
  410334:	aa0403f4 	mov	x20, x4
  410338:	a90e0260 	stp	x0, x0, [x19, #224]

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
  41033c:	b4000344 	cbz	x4, 4103a4 <k_work_queue_start+0x15c>
  410340:	39402080 	ldrb	w0, [x4, #8]
		flags |= K_WORK_QUEUE_NO_YIELD;
  410344:	7100001f 	cmp	w0, #0x0
  410348:	52802020 	mov	w0, #0x101                 	// #257
  41034c:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
	*flagp = flags;
  410350:	b900f260 	str	w0, [x19, #240]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  410354:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  410358:	b90003ff 	str	wzr, [sp]
  41035c:	f90007e0 	str	x0, [sp, #8]
  410360:	f0ffffe3 	adrp	x3, 40f000 <z_impl_k_mutex_lock+0x84>
  410364:	aa1303e4 	mov	x4, x19
  410368:	912f8063 	add	x3, x3, #0xbe0
  41036c:	aa1303e0 	mov	x0, x19
  410370:	d2800006 	mov	x6, #0x0                   	// #0
  410374:	d2800005 	mov	x5, #0x0                   	// #0
  410378:	97fff880 	bl	40e578 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
  41037c:	b40000b4 	cbz	x20, 410390 <k_work_queue_start+0x148>
  410380:	f9400281 	ldr	x1, [x20]
  410384:	b4000061 	cbz	x1, 410390 <k_work_queue_start+0x148>
	return z_impl_k_thread_name_set(thread, str);
  410388:	aa1303e0 	mov	x0, x19
  41038c:	97fff806 	bl	40e3a4 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
  410390:	aa1303e0 	mov	x0, x19
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
  410394:	a9417bfd 	ldp	x29, x30, [sp, #16]
  410398:	a94253f3 	ldp	x19, x20, [sp, #32]
  41039c:	9100c3ff 	add	sp, sp, #0x30
  4103a0:	17fff814 	b	40e3f0 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
  4103a4:	52800020 	mov	w0, #0x1                   	// #1
  4103a8:	17ffffea 	b	410350 <k_work_queue_start+0x108>

00000000004103ac <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
  4103ac:	79403401 	ldrh	w1, [x0, #26]
  4103b0:	7101fc3f 	cmp	w1, #0x7f
  4103b4:	54000248 	b.hi	4103fc <sliceable+0x50>  // b.pmore
	int ret = slice_ticks;
  4103b8:	b00000e1 	adrp	x1, 42d000 <counter_period>
  4103bc:	b94bf421 	ldr	w1, [x1, #3060]
		&& slice_time(thread) != 0
  4103c0:	340001a1 	cbz	w1, 4103f4 <sliceable+0x48>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
  4103c4:	b00000e1 	adrp	x1, 42d000 <counter_period>
  4103c8:	39c06802 	ldrsb	w2, [x0, #26]
  4103cc:	b94bf021 	ldr	w1, [x1, #3056]
  4103d0:	6b01005f 	cmp	w2, w1
  4103d4:	5400014b 	b.lt	4103fc <sliceable+0x50>  // b.tstop
		&& !z_is_thread_prevented_from_running(thread)
  4103d8:	39406401 	ldrb	w1, [x0, #25]
  4103dc:	f240103f 	tst	x1, #0x1f
  4103e0:	540000e1 	b.ne	4103fc <sliceable+0x50>  // b.any
		&& !z_is_idle_thread_object(thread);
  4103e4:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  4103e8:	f9470021 	ldr	x1, [x1, #3584]
  4103ec:	eb01001f 	cmp	x0, x1
  4103f0:	1a9f07e1 	cset	w1, ne  // ne = any
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
  4103f4:	12000020 	and	w0, w1, #0x1
  4103f8:	d65f03c0 	ret
		&& !z_is_idle_thread_object(thread);
  4103fc:	52800001 	mov	w1, #0x0                   	// #0
  410400:	17fffffd 	b	4103f4 <sliceable+0x48>

0000000000410404 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  410404:	b4000160 	cbz	x0, 410430 <slice_timeout+0x2c>
  410408:	b00000e1 	adrp	x1, 42d000 <counter_period>
  41040c:	91258021 	add	x1, x1, #0x960
  410410:	eb01001f 	cmp	x0, x1
  410414:	540000e3 	b.cc	410430 <slice_timeout+0x2c>  // b.lo, b.ul, b.last
  410418:	91008022 	add	x2, x1, #0x20
  41041c:	eb02001f 	cmp	x0, x2
  410420:	54000082 	b.cs	410430 <slice_timeout+0x2c>  // b.hs, b.nlast
  410424:	cb010000 	sub	x0, x0, x1
  410428:	f240101f 	tst	x0, #0x1f
  41042c:	540002a0 	b.eq	410480 <slice_timeout+0x7c>  // b.none
{
  410430:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  410434:	528038e3 	mov	w3, #0x1c7                 	// #455
  410438:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
{
  41043c:	910003fd 	mov	x29, sp
  410440:	f9000bf3 	str	x19, [sp, #16]
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  410444:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  410448:	91189a73 	add	x19, x19, #0x626
  41044c:	91192021 	add	x1, x1, #0x648
  410450:	aa1303e2 	mov	x2, x19
  410454:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410458:	9123f800 	add	x0, x0, #0x8fe
  41045c:	97ffde2c 	bl	407d0c <assert_print>
  410460:	aa1303e0 	mov	x0, x19
  410464:	528038e1 	mov	w1, #0x1c7                 	// #455
  410468:	97ffde53 	bl	407db4 <assert_post_action>
  41046c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410470:	aa1303e1 	mov	x1, x19
  410474:	9124f000 	add	x0, x0, #0x93c
  410478:	528038e2 	mov	w2, #0x1c7                 	// #455
  41047c:	97ffe840 	bl	40a57c <posix_print_error_and_exit>

	slice_expired[cpu] = true;
  410480:	93459000 	sbfx	x0, x0, #5, #32
  410484:	d00000e1 	adrp	x1, 42e000 <stdout_buff+0x2>
  410488:	9103fc21 	add	x1, x1, #0xff
  41048c:	52800022 	mov	w2, #0x1                   	// #1
  410490:	38206822 	strb	w2, [x1, x0]
  410494:	d65f03c0 	ret

0000000000410498 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
  410498:	39c06802 	ldrsb	w2, [x0, #26]
	int32_t b2 = thread_2->base.prio;
  41049c:	39c06821 	ldrsb	w1, [x1, #26]
		return b2 - b1;
  4104a0:	4b020020 	sub	w0, w1, w2
  4104a4:	6b01005f 	cmp	w2, w1
}
  4104a8:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  4104ac:	d65f03c0 	ret

00000000004104b0 <z_reset_time_slice>:
		flag_ipi();
	}
}

void z_reset_time_slice(struct k_thread *curr)
{
  4104b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int cpu = _current_cpu->id;
  4104b4:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
{
  4104b8:	910003fd 	mov	x29, sp
	int cpu = _current_cpu->id;
  4104bc:	f9473021 	ldr	x1, [x1, #3680]
{
  4104c0:	a90153f3 	stp	x19, x20, [sp, #16]
  4104c4:	aa0003f4 	mov	x20, x0
  4104c8:	f90013f5 	str	x21, [sp, #32]

	z_abort_timeout(&slice_timeouts[cpu]);
  4104cc:	b00000e0 	adrp	x0, 42d000 <counter_period>
  4104d0:	91258000 	add	x0, x0, #0x960
  4104d4:	39408033 	ldrb	w19, [x1, #32]
	int cpu = _current_cpu->id;
  4104d8:	39408035 	ldrb	w21, [x1, #32]
	z_abort_timeout(&slice_timeouts[cpu]);
  4104dc:	8b131413 	add	x19, x0, x19, lsl #5
  4104e0:	aa1303e0 	mov	x0, x19
  4104e4:	94000a17 	bl	412d40 <z_abort_timeout>
	slice_expired[cpu] = false;
  4104e8:	d00000e0 	adrp	x0, 42e000 <stdout_buff+0x2>
  4104ec:	9103fc00 	add	x0, x0, #0xff
  4104f0:	3835c81f 	strb	wzr, [x0, w21, sxtw]
	if (sliceable(curr)) {
  4104f4:	aa1403e0 	mov	x0, x20
  4104f8:	97ffffad 	bl	4103ac <sliceable>
  4104fc:	72001c1f 	tst	w0, #0xff
  410500:	54000180 	b.eq	410530 <z_reset_time_slice+0x80>  // b.none
	int ret = slice_ticks;
  410504:	b00000e0 	adrp	x0, 42d000 <counter_period>
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  410508:	90000001 	adrp	x1, 410000 <submit_to_queue_locked+0x168>
			      K_TICKS(slice_time(curr) - 1));
	}
}
  41050c:	f94013f5 	ldr	x21, [sp, #32]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  410510:	91101021 	add	x1, x1, #0x404
			      K_TICKS(slice_time(curr) - 1));
  410514:	b94bf402 	ldr	w2, [x0, #3060]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  410518:	aa1303e0 	mov	x0, x19
}
  41051c:	a94153f3 	ldp	x19, x20, [sp, #16]
			      K_TICKS(slice_time(curr) - 1));
  410520:	51000442 	sub	w2, w2, #0x1
}
  410524:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  410528:	93407c42 	sxtw	x2, w2
  41052c:	14000973 	b	412af8 <z_add_timeout>
}
  410530:	a94153f3 	ldp	x19, x20, [sp, #16]
  410534:	f94013f5 	ldr	x21, [sp, #32]
  410538:	a8c37bfd 	ldp	x29, x30, [sp], #48
  41053c:	d65f03c0 	ret

0000000000410540 <z_unpend_thread_no_timeout>:
	z_mark_thread_as_not_pending(thread);
	thread->base.pended_on = NULL;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
  410540:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410544:	910003fd 	mov	x29, sp
  410548:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41054c:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  410550:	aa0003f4 	mov	x20, x0
  410554:	a9025bf5 	stp	x21, x22, [sp, #32]
  410558:	97ffe6f3 	bl	40a124 <posix_irq_lock>
  41055c:	2a0003f5 	mov	w21, w0
  410560:	f947ca76 	ldr	x22, [x19, #3984]
  410564:	aa1603e0 	mov	x0, x22
  410568:	97fff896 	bl	40e7c0 <z_spin_lock_valid>
  41056c:	72001c1f 	tst	w0, #0xff
  410570:	540002c1 	b.ne	4105c8 <z_unpend_thread_no_timeout+0x88>  // b.any
  410574:	b0000033 	adrp	x19, 415000 <random_data+0xb30>
  410578:	91391a73 	add	x19, x19, #0xe46
  41057c:	aa1303e2 	mov	x2, x19
  410580:	52801283 	mov	w3, #0x94                  	// #148
  410584:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  410588:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41058c:	9139cc21 	add	x1, x1, #0xe73
  410590:	9123f800 	add	x0, x0, #0x8fe
  410594:	97ffddde 	bl	407d0c <assert_print>
  410598:	aa1603e1 	mov	x1, x22
  41059c:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  4105a0:	913a2000 	add	x0, x0, #0xe88
  4105a4:	97ffddda 	bl	407d0c <assert_print>
  4105a8:	52801281 	mov	w1, #0x94                  	// #148
  4105ac:	aa1303e0 	mov	x0, x19
  4105b0:	97ffde01 	bl	407db4 <assert_post_action>
  4105b4:	aa1303e1 	mov	x1, x19
  4105b8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4105bc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4105c0:	9124f000 	add	x0, x0, #0x93c
  4105c4:	97ffe7ee 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4105c8:	aa1603e0 	mov	x0, x22
  4105cc:	97fff895 	bl	40e820 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		if (thread->base.pended_on != NULL) {
  4105d0:	f9400a80 	ldr	x0, [x20, #16]
  4105d4:	b4000060 	cbz	x0, 4105e0 <z_unpend_thread_no_timeout+0xa0>
			unpend_thread_no_timeout(thread);
  4105d8:	aa1403e0 	mov	x0, x20
  4105dc:	940000f5 	bl	4109b0 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4105e0:	f947ca73 	ldr	x19, [x19, #3984]
  4105e4:	aa1303e0 	mov	x0, x19
  4105e8:	97fff881 	bl	40e7ec <z_spin_unlock_valid>
  4105ec:	72001c1f 	tst	w0, #0xff
  4105f0:	54000281 	b.ne	410640 <z_unpend_thread_no_timeout+0x100>  // b.any
  4105f4:	b0000034 	adrp	x20, 415000 <random_data+0xb30>
  4105f8:	91391a94 	add	x20, x20, #0xe46
  4105fc:	aa1403e2 	mov	x2, x20
  410600:	52801863 	mov	w3, #0xc3                  	// #195
  410604:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  410608:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41060c:	913a8021 	add	x1, x1, #0xea0
  410610:	9123f800 	add	x0, x0, #0x8fe
  410614:	97ffddbe 	bl	407d0c <assert_print>
  410618:	aa1303e1 	mov	x1, x19
  41061c:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410620:	913adc00 	add	x0, x0, #0xeb7
  410624:	97ffddba 	bl	407d0c <assert_print>
  410628:	52801861 	mov	w1, #0xc3                  	// #195
  41062c:	aa1403e0 	mov	x0, x20
  410630:	97ffdde1 	bl	407db4 <assert_post_action>
  410634:	aa1403e1 	mov	x1, x20
  410638:	52801862 	mov	w2, #0xc3                  	// #195
  41063c:	17ffffe0 	b	4105bc <z_unpend_thread_no_timeout+0x7c>
	posix_irq_unlock(key);
  410640:	2a1503e0 	mov	w0, w21
		}
	}
}
  410644:	a94153f3 	ldp	x19, x20, [sp, #16]
  410648:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41064c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410650:	17ffe6b7 	b	40a12c <posix_irq_unlock>

0000000000410654 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
  410654:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return _kernel.cpus[0].nested != 0U;
  410658:	f00000c2 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
  41065c:	910003fd 	mov	x29, sp
  410660:	f9473042 	ldr	x2, [x2, #3680]
  410664:	a90153f3 	stp	x19, x20, [sp, #16]
  410668:	2a0103f3 	mov	w19, w1
  41066c:	aa0003f4 	mov	x20, x0
	if (resched(key.key) && need_swap()) {
  410670:	b9400041 	ldr	w1, [x2]
  410674:	2a010261 	orr	w1, w19, w1
  410678:	35000421 	cbnz	w1, 4106fc <z_reschedule+0xa8>
  41067c:	f9400841 	ldr	x1, [x2, #16]
  410680:	f9401443 	ldr	x3, [x2, #40]
  410684:	eb01007f 	cmp	x3, x1
  410688:	540003a0 	b.eq	4106fc <z_reschedule+0xa8>  // b.none
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41068c:	97fff858 	bl	40e7ec <z_spin_unlock_valid>
  410690:	72001c1f 	tst	w0, #0xff
  410694:	540002c1 	b.ne	4106ec <z_reschedule+0x98>  // b.any
  410698:	b0000033 	adrp	x19, 415000 <random_data+0xb30>
  41069c:	91391a73 	add	x19, x19, #0xe46
  4106a0:	aa1303e2 	mov	x2, x19
  4106a4:	52801c43 	mov	w3, #0xe2                  	// #226
  4106a8:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  4106ac:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4106b0:	913a8021 	add	x1, x1, #0xea0
  4106b4:	9123f800 	add	x0, x0, #0x8fe
  4106b8:	97ffdd95 	bl	407d0c <assert_print>
  4106bc:	aa1403e1 	mov	x1, x20
  4106c0:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  4106c4:	913adc00 	add	x0, x0, #0xeb7
  4106c8:	97ffdd91 	bl	407d0c <assert_print>
  4106cc:	aa1303e0 	mov	x0, x19
  4106d0:	52801c41 	mov	w1, #0xe2                  	// #226
  4106d4:	97ffddb8 	bl	407db4 <assert_post_action>
  4106d8:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4106dc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4106e0:	aa1303e1 	mov	x1, x19
  4106e4:	9124f000 	add	x0, x0, #0x93c
  4106e8:	97ffe7a5 	bl	40a57c <posix_print_error_and_exit>
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
  4106ec:	a94153f3 	ldp	x19, x20, [sp, #16]
	ret = arch_swap(key);
  4106f0:	52800000 	mov	w0, #0x0                   	// #0
  4106f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4106f8:	17ffe361 	b	40947c <arch_swap>
  4106fc:	aa1403e0 	mov	x0, x20
  410700:	97fff83b 	bl	40e7ec <z_spin_unlock_valid>
  410704:	72001c1f 	tst	w0, #0xff
  410708:	54000261 	b.ne	410754 <z_reschedule+0x100>  // b.any
  41070c:	b0000033 	adrp	x19, 415000 <random_data+0xb30>
  410710:	91391a73 	add	x19, x19, #0xe46
  410714:	aa1303e2 	mov	x2, x19
  410718:	52801863 	mov	w3, #0xc3                  	// #195
  41071c:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  410720:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410724:	913a8021 	add	x1, x1, #0xea0
  410728:	9123f800 	add	x0, x0, #0x8fe
  41072c:	97ffdd78 	bl	407d0c <assert_print>
  410730:	aa1403e1 	mov	x1, x20
  410734:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410738:	913adc00 	add	x0, x0, #0xeb7
  41073c:	97ffdd74 	bl	407d0c <assert_print>
  410740:	aa1303e0 	mov	x0, x19
  410744:	52801861 	mov	w1, #0xc3                  	// #195
  410748:	97ffdd9b 	bl	407db4 <assert_post_action>
  41074c:	52801862 	mov	w2, #0xc3                  	// #195
  410750:	17ffffe3 	b	4106dc <z_reschedule+0x88>
  410754:	2a1303e0 	mov	w0, w19
  410758:	a94153f3 	ldp	x19, x20, [sp, #16]
  41075c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410760:	17ffe673 	b	40a12c <posix_irq_unlock>

0000000000410764 <z_reschedule_irqlock>:
  410764:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  410768:	f9473021 	ldr	x1, [x1, #3680]

void z_reschedule_irqlock(uint32_t key)
{
	if (resched(key)) {
  41076c:	b9400021 	ldr	w1, [x1]
  410770:	2a010001 	orr	w1, w0, w1
  410774:	35000061 	cbnz	w1, 410780 <z_reschedule_irqlock+0x1c>
  410778:	52800000 	mov	w0, #0x0                   	// #0
  41077c:	17ffe340 	b	40947c <arch_swap>
  410780:	17ffe66b 	b	40a12c <posix_irq_unlock>

0000000000410784 <z_reschedule_unlocked>:
{
  410784:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410788:	910003fd 	mov	x29, sp
	return posix_irq_lock();
  41078c:	97ffe666 	bl	40a124 <posix_irq_lock>
}
  410790:	a8c17bfd 	ldp	x29, x30, [sp], #16
	(void) z_reschedule_irqlock(arch_irq_lock());
  410794:	17fffff4 	b	410764 <z_reschedule_irqlock>

0000000000410798 <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
  410798:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  41079c:	910003fd 	mov	x29, sp
  4107a0:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4107a4:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  4107a8:	97ffe65f 	bl	40a124 <posix_irq_lock>
  4107ac:	f947ca73 	ldr	x19, [x19, #3984]
  4107b0:	2a0003f4 	mov	w20, w0
  4107b4:	aa1303e0 	mov	x0, x19
  4107b8:	97fff802 	bl	40e7c0 <z_spin_lock_valid>
  4107bc:	72001c1f 	tst	w0, #0xff
  4107c0:	54000281 	b.ne	410810 <k_sched_lock+0x78>  // b.any
  4107c4:	b0000034 	adrp	x20, 415000 <random_data+0xb30>
  4107c8:	91391a94 	add	x20, x20, #0xe46
  4107cc:	aa1403e2 	mov	x2, x20
  4107d0:	52801283 	mov	w3, #0x94                  	// #148
  4107d4:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  4107d8:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4107dc:	9139cc21 	add	x1, x1, #0xe73
  4107e0:	9123f800 	add	x0, x0, #0x8fe
  4107e4:	97ffdd4a 	bl	407d0c <assert_print>
  4107e8:	aa1303e1 	mov	x1, x19
  4107ec:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  4107f0:	913a2000 	add	x0, x0, #0xe88
  4107f4:	97ffdd46 	bl	407d0c <assert_print>
  4107f8:	aa1403e0 	mov	x0, x20
  4107fc:	52801281 	mov	w1, #0x94                  	// #148
  410800:	97ffdd6d 	bl	407db4 <assert_post_action>
  410804:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410808:	aa1403e1 	mov	x1, x20
  41080c:	14000018 	b	41086c <k_sched_lock+0xd4>
	z_spin_lock_set_owner(l);
  410810:	aa1303e0 	mov	x0, x19
  410814:	97fff803 	bl	40e820 <z_spin_lock_set_owner>
  410818:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  41081c:	f9473021 	ldr	x1, [x1, #3680]
	__ASSERT(!arch_is_in_isr(), "");
  410820:	b9400020 	ldr	w0, [x1]
  410824:	340002a0 	cbz	w0, 410878 <k_sched_lock+0xe0>
  410828:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  41082c:	911f8673 	add	x19, x19, #0x7e1
  410830:	aa1303e2 	mov	x2, x19
  410834:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  410838:	910e6021 	add	x1, x1, #0x398
  41083c:	52801fa3 	mov	w3, #0xfd                  	// #253
  410840:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410844:	9123f800 	add	x0, x0, #0x8fe
  410848:	97ffdd31 	bl	407d0c <assert_print>
  41084c:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410850:	913b7400 	add	x0, x0, #0xedd
  410854:	97ffdd2e 	bl	407d0c <assert_print>
  410858:	aa1303e0 	mov	x0, x19
  41085c:	52801fa1 	mov	w1, #0xfd                  	// #253
  410860:	97ffdd55 	bl	407db4 <assert_post_action>
  410864:	52801fa2 	mov	w2, #0xfd                  	// #253
  410868:	aa1303e1 	mov	x1, x19
  41086c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410870:	9124f000 	add	x0, x0, #0x93c
  410874:	97ffe742 	bl	40a57c <posix_print_error_and_exit>
	__ASSERT(_current->base.sched_locked != 1U, "");
  410878:	f9400820 	ldr	x0, [x1, #16]
  41087c:	39406c01 	ldrb	w1, [x0, #27]
  410880:	7100043f 	cmp	w1, #0x1
  410884:	54000241 	b.ne	4108cc <k_sched_lock+0x134>  // b.any
  410888:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  41088c:	911f8673 	add	x19, x19, #0x7e1
  410890:	aa1303e2 	mov	x2, x19
  410894:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  410898:	91203021 	add	x1, x1, #0x80c
  41089c:	52801fc3 	mov	w3, #0xfe                  	// #254
  4108a0:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4108a4:	9123f800 	add	x0, x0, #0x8fe
  4108a8:	97ffdd19 	bl	407d0c <assert_print>
  4108ac:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  4108b0:	913b7400 	add	x0, x0, #0xedd
  4108b4:	97ffdd16 	bl	407d0c <assert_print>
  4108b8:	aa1303e0 	mov	x0, x19
  4108bc:	52801fc1 	mov	w1, #0xfe                  	// #254
  4108c0:	97ffdd3d 	bl	407db4 <assert_post_action>
  4108c4:	52801fc2 	mov	w2, #0xfe                  	// #254
  4108c8:	17ffffe8 	b	410868 <k_sched_lock+0xd0>
	--_current->base.sched_locked;
  4108cc:	51000421 	sub	w1, w1, #0x1
  4108d0:	39006c01 	strb	w1, [x0, #27]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4108d4:	aa1303e0 	mov	x0, x19
  4108d8:	97fff7c5 	bl	40e7ec <z_spin_unlock_valid>
  4108dc:	72001c1f 	tst	w0, #0xff
  4108e0:	54000261 	b.ne	41092c <k_sched_lock+0x194>  // b.any
  4108e4:	b0000034 	adrp	x20, 415000 <random_data+0xb30>
  4108e8:	91391a94 	add	x20, x20, #0xe46
  4108ec:	aa1403e2 	mov	x2, x20
  4108f0:	52801863 	mov	w3, #0xc3                  	// #195
  4108f4:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  4108f8:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4108fc:	913a8021 	add	x1, x1, #0xea0
  410900:	9123f800 	add	x0, x0, #0x8fe
  410904:	97ffdd02 	bl	407d0c <assert_print>
  410908:	aa1303e1 	mov	x1, x19
  41090c:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410910:	913adc00 	add	x0, x0, #0xeb7
  410914:	97ffdcfe 	bl	407d0c <assert_print>
  410918:	aa1403e0 	mov	x0, x20
  41091c:	52801861 	mov	w1, #0xc3                  	// #195
  410920:	97ffdd25 	bl	407db4 <assert_post_action>
  410924:	52801862 	mov	w2, #0xc3                  	// #195
  410928:	17ffffb8 	b	410808 <k_sched_lock+0x70>
	posix_irq_unlock(key);
  41092c:	2a1403e0 	mov	w0, w20
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
  410930:	a94153f3 	ldp	x19, x20, [sp, #16]
  410934:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410938:	17ffe5fd 	b	40a12c <posix_irq_unlock>

000000000041093c <z_priq_dumb_remove>:
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  41093c:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  410940:	f9470000 	ldr	x0, [x0, #3584]
  410944:	eb00003f 	cmp	x1, x0
  410948:	540002a1 	b.ne	41099c <z_priq_dumb_remove+0x60>  // b.any
{
  41094c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410950:	52808f63 	mov	w3, #0x47b                 	// #1147
  410954:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
{
  410958:	910003fd 	mov	x29, sp
  41095c:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410960:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  410964:	91189a73 	add	x19, x19, #0x626
  410968:	9120f421 	add	x1, x1, #0x83d
  41096c:	aa1303e2 	mov	x2, x19
  410970:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410974:	9123f800 	add	x0, x0, #0x8fe
  410978:	97ffdce5 	bl	407d0c <assert_print>
  41097c:	aa1303e0 	mov	x0, x19
  410980:	52808f61 	mov	w1, #0x47b                 	// #1147
  410984:	97ffdd0c 	bl	407db4 <assert_post_action>
  410988:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41098c:	aa1303e1 	mov	x1, x19
  410990:	9124f000 	add	x0, x0, #0x93c
  410994:	52808f62 	mov	w2, #0x47b                 	// #1147
  410998:	97ffe6f9 	bl	40a57c <posix_print_error_and_exit>
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
  41099c:	a9400820 	ldp	x0, x2, [x1]
	sys_dnode_t *const next = node->next;

	prev->next = next;
  4109a0:	f9000040 	str	x0, [x2]
	next->prev = prev;
  4109a4:	f9000402 	str	x2, [x0, #8]
	node->prev = NULL;
  4109a8:	a9007c3f 	stp	xzr, xzr, [x1]
  4109ac:	d65f03c0 	ret

00000000004109b0 <unpend_thread_no_timeout>:
{
  4109b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4109b4:	910003fd 	mov	x29, sp
  4109b8:	f9000bf3 	str	x19, [sp, #16]
  4109bc:	aa0003f3 	mov	x19, x0
  4109c0:	f9400800 	ldr	x0, [x0, #16]
	__ASSERT_NO_MSG(thread->base.pended_on);
  4109c4:	b5000240 	cbnz	x0, 410a0c <unpend_thread_no_timeout+0x5c>
  4109c8:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  4109cc:	91189a73 	add	x19, x19, #0x626
  4109d0:	aa1303e2 	mov	x2, x19
  4109d4:	528058a3 	mov	w3, #0x2c5                 	// #709
  4109d8:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  4109dc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4109e0:	91217821 	add	x1, x1, #0x85e
  4109e4:	9123f800 	add	x0, x0, #0x8fe
  4109e8:	97ffdcc9 	bl	407d0c <assert_print>
  4109ec:	aa1303e0 	mov	x0, x19
  4109f0:	528058a1 	mov	w1, #0x2c5                 	// #709
  4109f4:	97ffdcf0 	bl	407db4 <assert_post_action>
  4109f8:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4109fc:	aa1303e1 	mov	x1, x19
  410a00:	9124f000 	add	x0, x0, #0x93c
  410a04:	528058a2 	mov	w2, #0x2c5                 	// #709
  410a08:	97ffe6dd 	bl	40a57c <posix_print_error_and_exit>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
  410a0c:	aa1303e1 	mov	x1, x19
  410a10:	97ffffcb 	bl	41093c <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  410a14:	39406660 	ldrb	w0, [x19, #25]
	thread->base.pended_on = NULL;
  410a18:	f9000a7f 	str	xzr, [x19, #16]
  410a1c:	121e7800 	and	w0, w0, #0xfffffffd
  410a20:	39006660 	strb	w0, [x19, #25]
}
  410a24:	f9400bf3 	ldr	x19, [sp, #16]
  410a28:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410a2c:	d65f03c0 	ret

0000000000410a30 <z_unpend_thread>:
{
  410a30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410a34:	910003fd 	mov	x29, sp
  410a38:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410a3c:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  410a40:	aa0003f4 	mov	x20, x0
  410a44:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  410a48:	97ffe5b7 	bl	40a124 <posix_irq_lock>
  410a4c:	2a0003f5 	mov	w21, w0
  410a50:	f947ca76 	ldr	x22, [x19, #3984]
  410a54:	aa1603e0 	mov	x0, x22
  410a58:	97fff75a 	bl	40e7c0 <z_spin_lock_valid>
  410a5c:	72001c1f 	tst	w0, #0xff
  410a60:	540002c1 	b.ne	410ab8 <z_unpend_thread+0x88>  // b.any
  410a64:	b0000033 	adrp	x19, 415000 <random_data+0xb30>
  410a68:	91391a73 	add	x19, x19, #0xe46
  410a6c:	aa1303e2 	mov	x2, x19
  410a70:	52801283 	mov	w3, #0x94                  	// #148
  410a74:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  410a78:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410a7c:	9139cc21 	add	x1, x1, #0xe73
  410a80:	9123f800 	add	x0, x0, #0x8fe
  410a84:	97ffdca2 	bl	407d0c <assert_print>
  410a88:	aa1603e1 	mov	x1, x22
  410a8c:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410a90:	913a2000 	add	x0, x0, #0xe88
  410a94:	97ffdc9e 	bl	407d0c <assert_print>
  410a98:	52801281 	mov	w1, #0x94                  	// #148
  410a9c:	aa1303e0 	mov	x0, x19
  410aa0:	97ffdcc5 	bl	407db4 <assert_post_action>
  410aa4:	aa1303e1 	mov	x1, x19
  410aa8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410aac:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410ab0:	9124f000 	add	x0, x0, #0x93c
  410ab4:	97ffe6b2 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410ab8:	aa1603e0 	mov	x0, x22
  410abc:	97fff759 	bl	40e820 <z_spin_lock_set_owner>
		if (thread->base.pended_on != NULL) {
  410ac0:	f9400a80 	ldr	x0, [x20, #16]
  410ac4:	b4000060 	cbz	x0, 410ad0 <z_unpend_thread+0xa0>
			unpend_thread_no_timeout(thread);
  410ac8:	aa1403e0 	mov	x0, x20
  410acc:	97ffffb9 	bl	4109b0 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410ad0:	f947ca73 	ldr	x19, [x19, #3984]
  410ad4:	aa1303e0 	mov	x0, x19
  410ad8:	97fff745 	bl	40e7ec <z_spin_unlock_valid>
  410adc:	72001c1f 	tst	w0, #0xff
  410ae0:	54000281 	b.ne	410b30 <z_unpend_thread+0x100>  // b.any
  410ae4:	b0000034 	adrp	x20, 415000 <random_data+0xb30>
  410ae8:	91391a94 	add	x20, x20, #0xe46
  410aec:	aa1403e2 	mov	x2, x20
  410af0:	52801863 	mov	w3, #0xc3                  	// #195
  410af4:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  410af8:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410afc:	913a8021 	add	x1, x1, #0xea0
  410b00:	9123f800 	add	x0, x0, #0x8fe
  410b04:	97ffdc82 	bl	407d0c <assert_print>
  410b08:	aa1303e1 	mov	x1, x19
  410b0c:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410b10:	913adc00 	add	x0, x0, #0xeb7
  410b14:	97ffdc7e 	bl	407d0c <assert_print>
  410b18:	52801861 	mov	w1, #0xc3                  	// #195
  410b1c:	aa1403e0 	mov	x0, x20
  410b20:	97ffdca5 	bl	407db4 <assert_post_action>
  410b24:	aa1403e1 	mov	x1, x20
  410b28:	52801862 	mov	w2, #0xc3                  	// #195
  410b2c:	17ffffe0 	b	410aac <z_unpend_thread+0x7c>
	posix_irq_unlock(key);
  410b30:	2a1503e0 	mov	w0, w21
  410b34:	97ffe57e 	bl	40a12c <posix_irq_unlock>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  410b38:	9100a280 	add	x0, x20, #0x28
}
  410b3c:	a94153f3 	ldp	x19, x20, [sp, #16]
  410b40:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410b44:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410b48:	1400087e 	b	412d40 <z_abort_timeout>

0000000000410b4c <z_priq_dumb_best>:
	return list->head == list;
  410b4c:	f9400001 	ldr	x1, [x0]
	sys_dlist_remove(&thread->base.qnode_dlist);
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
  410b50:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
  410b54:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
  410b58:	d65f03c0 	ret

0000000000410b5c <update_cache>:
{
  410b5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410b60:	910003fd 	mov	x29, sp
  410b64:	a90153f3 	stp	x19, x20, [sp, #16]
	return _priq_run_best(curr_cpu_runq());
  410b68:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
{
  410b6c:	a9025bf5 	stp	x21, x22, [sp, #32]
  410b70:	2a0003f5 	mov	w21, w0
	return _priq_run_best(curr_cpu_runq());
  410b74:	f9473276 	ldr	x22, [x19, #3680]
  410b78:	9100c2c0 	add	x0, x22, #0x30
  410b7c:	97fffff4 	bl	410b4c <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
  410b80:	b5000340 	cbnz	x0, 410be8 <update_cache+0x8c>
  410b84:	f9400ed4 	ldr	x20, [x22, #24]
	__ASSERT(_current != NULL, "");
  410b88:	f9473260 	ldr	x0, [x19, #3680]
  410b8c:	f9400801 	ldr	x1, [x0, #16]
	if (preempt_ok != 0) {
  410b90:	350003d5 	cbnz	w21, 410c08 <update_cache+0xac>
	__ASSERT(_current != NULL, "");
  410b94:	b50002e1 	cbnz	x1, 410bf0 <update_cache+0x94>
  410b98:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  410b9c:	91189a73 	add	x19, x19, #0x626
  410ba0:	aa1303e2 	mov	x2, x19
  410ba4:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  410ba8:	9121d421 	add	x1, x1, #0x875
  410bac:	52801143 	mov	w3, #0x8a                  	// #138
  410bb0:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410bb4:	9123f800 	add	x0, x0, #0x8fe
  410bb8:	97ffdc55 	bl	407d0c <assert_print>
  410bbc:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410bc0:	913b7400 	add	x0, x0, #0xedd
  410bc4:	97ffdc52 	bl	407d0c <assert_print>
  410bc8:	aa1303e0 	mov	x0, x19
  410bcc:	52801141 	mov	w1, #0x8a                  	// #138
  410bd0:	97ffdc79 	bl	407db4 <assert_post_action>
  410bd4:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410bd8:	aa1303e1 	mov	x1, x19
  410bdc:	9124f000 	add	x0, x0, #0x93c
  410be0:	52801142 	mov	w2, #0x8a                  	// #138
  410be4:	97ffe666 	bl	40a57c <posix_print_error_and_exit>
  410be8:	aa0003f4 	mov	x20, x0
  410bec:	17ffffe7 	b	410b88 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
  410bf0:	39406420 	ldrb	w0, [x1, #25]
  410bf4:	f240101f 	tst	x0, #0x1f
  410bf8:	54000081 	b.ne	410c08 <update_cache+0xac>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
  410bfc:	79403420 	ldrh	w0, [x1, #26]
  410c00:	7101fc1f 	cmp	w0, #0x7f
  410c04:	540000c8 	b.hi	410c1c <update_cache+0xc0>  // b.pmore
		if (thread != _current) {
  410c08:	eb01029f 	cmp	x20, x1
  410c0c:	54000060 	b.eq	410c18 <update_cache+0xbc>  // b.none
			z_reset_time_slice(thread);
  410c10:	aa1403e0 	mov	x0, x20
  410c14:	97fffe27 	bl	4104b0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
  410c18:	aa1403e1 	mov	x1, x20
  410c1c:	f9473273 	ldr	x19, [x19, #3680]
  410c20:	f9001661 	str	x1, [x19, #40]
}
  410c24:	a94153f3 	ldp	x19, x20, [sp, #16]
  410c28:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410c2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410c30:	d65f03c0 	ret

0000000000410c34 <move_thread_to_end_of_prio_q>:
{
  410c34:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410c38:	910003fd 	mov	x29, sp
  410c3c:	a90153f3 	stp	x19, x20, [sp, #16]
  410c40:	aa0003f3 	mov	x19, x0
  410c44:	a9025bf5 	stp	x21, x22, [sp, #32]
  410c48:	f00000d5 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
	if (z_is_thread_queued(thread)) {
  410c4c:	39c06661 	ldrsb	w1, [x19, #25]
	return (thread->base.thread_state & state) != 0U;
  410c50:	39406400 	ldrb	w0, [x0, #25]
  410c54:	36f800e1 	tbz	w1, #31, 410c70 <move_thread_to_end_of_prio_q+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  410c58:	12001800 	and	w0, w0, #0x7f
  410c5c:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  410c60:	f94732a0 	ldr	x0, [x21, #3680]
  410c64:	aa1303e1 	mov	x1, x19
  410c68:	9100c000 	add	x0, x0, #0x30
  410c6c:	97ffff34 	bl	41093c <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  410c70:	39406660 	ldrb	w0, [x19, #25]
  410c74:	32196000 	orr	w0, w0, #0xffffff80
  410c78:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410c7c:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  410c80:	f9470000 	ldr	x0, [x0, #3584]
  410c84:	eb00027f 	cmp	x19, x0
  410c88:	54000241 	b.ne	410cd0 <move_thread_to_end_of_prio_q+0x9c>  // b.any
  410c8c:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  410c90:	91189a73 	add	x19, x19, #0x626
  410c94:	aa1303e2 	mov	x2, x19
  410c98:	52801783 	mov	w3, #0xbc                  	// #188
  410c9c:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  410ca0:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410ca4:	9120f421 	add	x1, x1, #0x83d
  410ca8:	9123f800 	add	x0, x0, #0x8fe
  410cac:	97ffdc18 	bl	407d0c <assert_print>
  410cb0:	aa1303e0 	mov	x0, x19
  410cb4:	52801781 	mov	w1, #0xbc                  	// #188
  410cb8:	97ffdc3f 	bl	407db4 <assert_post_action>
  410cbc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410cc0:	aa1303e1 	mov	x1, x19
  410cc4:	9124f000 	add	x0, x0, #0x93c
  410cc8:	52801782 	mov	w2, #0xbc                  	// #188
  410ccc:	97ffe62c 	bl	40a57c <posix_print_error_and_exit>
  410cd0:	f94732b6 	ldr	x22, [x21, #3680]
  410cd4:	aa1603e0 	mov	x0, x22
  410cd8:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  410cdc:	eb00029f 	cmp	x20, x0
  410ce0:	54000261 	b.ne	410d2c <move_thread_to_end_of_prio_q+0xf8>  // b.any
	sys_dnode_t *const tail = list->tail;
  410ce4:	f94732a0 	ldr	x0, [x21, #3680]
	node->next = list;
  410ce8:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  410cec:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  410cf0:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  410cf4:	f9000033 	str	x19, [x1]
	list->tail = node;
  410cf8:	f9001c13 	str	x19, [x0, #56]
	update_cache(thread == _current);
  410cfc:	f94732b5 	ldr	x21, [x21, #3680]
  410d00:	f9400aa0 	ldr	x0, [x21, #16]
}
  410d04:	a9425bf5 	ldp	x21, x22, [sp, #32]
	update_cache(thread == _current);
  410d08:	eb13001f 	cmp	x0, x19
}
  410d0c:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  410d10:	1a9f17e0 	cset	w0, eq  // eq = none
}
  410d14:	a8c37bfd 	ldp	x29, x30, [sp], #48
	update_cache(thread == _current);
  410d18:	17ffff91 	b	410b5c <update_cache>
	return (node == list->tail) ? NULL : node->next;
  410d1c:	f9401ec0 	ldr	x0, [x22, #56]
  410d20:	eb14001f 	cmp	x0, x20
  410d24:	54fffe00 	b.eq	410ce4 <move_thread_to_end_of_prio_q+0xb0>  // b.none
  410d28:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  410d2c:	b4fffdd4 	cbz	x20, 410ce4 <move_thread_to_end_of_prio_q+0xb0>
		if (z_sched_prio_cmp(thread, t) > 0) {
  410d30:	aa1403e1 	mov	x1, x20
  410d34:	aa1303e0 	mov	x0, x19
  410d38:	97fffdd8 	bl	410498 <z_sched_prio_cmp>
  410d3c:	7100001f 	cmp	w0, #0x0
  410d40:	54fffeed 	b.le	410d1c <move_thread_to_end_of_prio_q+0xe8>
	sys_dnode_t *const prev = successor->prev;
  410d44:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  410d48:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  410d4c:	f9000013 	str	x19, [x0]
	successor->prev = node;
  410d50:	f9000693 	str	x19, [x20, #8]
}
  410d54:	17ffffea 	b	410cfc <move_thread_to_end_of_prio_q+0xc8>

0000000000410d58 <z_time_slice>:
{
  410d58:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410d5c:	910003fd 	mov	x29, sp
  410d60:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410d64:	f00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  410d68:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  410d6c:	97ffe4ee 	bl	40a124 <posix_irq_lock>
  410d70:	2a0003f6 	mov	w22, w0
  410d74:	f947ca95 	ldr	x21, [x20, #3984]
  410d78:	aa1503e0 	mov	x0, x21
  410d7c:	97fff691 	bl	40e7c0 <z_spin_lock_valid>
  410d80:	72001c1f 	tst	w0, #0xff
  410d84:	540002c1 	b.ne	410ddc <z_time_slice+0x84>  // b.any
  410d88:	b0000033 	adrp	x19, 415000 <random_data+0xb30>
  410d8c:	91391a73 	add	x19, x19, #0xe46
  410d90:	aa1303e2 	mov	x2, x19
  410d94:	52801283 	mov	w3, #0x94                  	// #148
  410d98:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  410d9c:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410da0:	9139cc21 	add	x1, x1, #0xe73
  410da4:	9123f800 	add	x0, x0, #0x8fe
  410da8:	97ffdbd9 	bl	407d0c <assert_print>
  410dac:	aa1503e1 	mov	x1, x21
  410db0:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410db4:	913a2000 	add	x0, x0, #0xe88
  410db8:	97ffdbd5 	bl	407d0c <assert_print>
  410dbc:	aa1303e0 	mov	x0, x19
  410dc0:	52801281 	mov	w1, #0x94                  	// #148
  410dc4:	97ffdbfc 	bl	407db4 <assert_post_action>
  410dc8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410dcc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410dd0:	aa1303e1 	mov	x1, x19
  410dd4:	9124f000 	add	x0, x0, #0x93c
  410dd8:	97ffe5e9 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410ddc:	aa1503e0 	mov	x0, x21
  410de0:	97fff690 	bl	40e820 <z_spin_lock_set_owner>
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  410de4:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  410de8:	d00000e2 	adrp	x2, 42e000 <stdout_buff+0x2>
  410dec:	9103fc42 	add	x2, x2, #0xff
  410df0:	f9473021 	ldr	x1, [x1, #3680]
  410df4:	39408020 	ldrb	w0, [x1, #32]
  410df8:	38606840 	ldrb	w0, [x2, x0]
  410dfc:	340001a0 	cbz	w0, 410e30 <z_time_slice+0xd8>
	struct k_thread *curr = _current;
  410e00:	f9400833 	ldr	x19, [x1, #16]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  410e04:	aa1303e0 	mov	x0, x19
  410e08:	97fffd69 	bl	4103ac <sliceable>
  410e0c:	72001c1f 	tst	w0, #0xff
  410e10:	54000100 	b.eq	410e30 <z_time_slice+0xd8>  // b.none
		if (!z_is_thread_prevented_from_running(curr)) {
  410e14:	39406660 	ldrb	w0, [x19, #25]
  410e18:	f240101f 	tst	x0, #0x1f
  410e1c:	54000061 	b.ne	410e28 <z_time_slice+0xd0>  // b.any
			move_thread_to_end_of_prio_q(curr);
  410e20:	aa1303e0 	mov	x0, x19
  410e24:	97ffff84 	bl	410c34 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
  410e28:	aa1303e0 	mov	x0, x19
  410e2c:	97fffda1 	bl	4104b0 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410e30:	f947ca94 	ldr	x20, [x20, #3984]
  410e34:	aa1403e0 	mov	x0, x20
  410e38:	97fff66d 	bl	40e7ec <z_spin_unlock_valid>
  410e3c:	72001c1f 	tst	w0, #0xff
  410e40:	54000261 	b.ne	410e8c <z_time_slice+0x134>  // b.any
  410e44:	b0000033 	adrp	x19, 415000 <random_data+0xb30>
  410e48:	91391a73 	add	x19, x19, #0xe46
  410e4c:	aa1303e2 	mov	x2, x19
  410e50:	52801863 	mov	w3, #0xc3                  	// #195
  410e54:	b0000021 	adrp	x1, 415000 <random_data+0xb30>
  410e58:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410e5c:	913a8021 	add	x1, x1, #0xea0
  410e60:	9123f800 	add	x0, x0, #0x8fe
  410e64:	97ffdbaa 	bl	407d0c <assert_print>
  410e68:	aa1403e1 	mov	x1, x20
  410e6c:	b0000020 	adrp	x0, 415000 <random_data+0xb30>
  410e70:	913adc00 	add	x0, x0, #0xeb7
  410e74:	97ffdba6 	bl	407d0c <assert_print>
  410e78:	aa1303e0 	mov	x0, x19
  410e7c:	52801861 	mov	w1, #0xc3                  	// #195
  410e80:	97ffdbcd 	bl	407db4 <assert_post_action>
  410e84:	52801862 	mov	w2, #0xc3                  	// #195
  410e88:	17ffffd1 	b	410dcc <z_time_slice+0x74>
	posix_irq_unlock(key);
  410e8c:	2a1603e0 	mov	w0, w22
}
  410e90:	a94153f3 	ldp	x19, x20, [sp, #16]
  410e94:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410e98:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410e9c:	17ffe4a4 	b	40a12c <posix_irq_unlock>

0000000000410ea0 <ready_thread>:
{
  410ea0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410ea4:	910003fd 	mov	x29, sp
  410ea8:	a90153f3 	stp	x19, x20, [sp, #16]
  410eac:	aa0003f3 	mov	x19, x0
  410eb0:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  410eb4:	39c06661 	ldrsb	w1, [x19, #25]
  410eb8:	39406400 	ldrb	w0, [x0, #25]
  410ebc:	37f807a1 	tbnz	w1, #31, 410fb0 <ready_thread+0x110>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  410ec0:	f240101f 	tst	x0, #0x1f
  410ec4:	54000761 	b.ne	410fb0 <ready_thread+0x110>  // b.any
  410ec8:	f9401661 	ldr	x1, [x19, #40]
  410ecc:	b5000721 	cbnz	x1, 410fb0 <ready_thread+0x110>
	thread->base.thread_state |= _THREAD_QUEUED;
  410ed0:	32196000 	orr	w0, w0, #0xffffff80
  410ed4:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410ed8:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  410edc:	f9470000 	ldr	x0, [x0, #3584]
  410ee0:	eb00027f 	cmp	x19, x0
  410ee4:	54000241 	b.ne	410f2c <ready_thread+0x8c>  // b.any
  410ee8:	d0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  410eec:	91189a73 	add	x19, x19, #0x626
  410ef0:	aa1303e2 	mov	x2, x19
  410ef4:	52801783 	mov	w3, #0xbc                  	// #188
  410ef8:	d0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  410efc:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410f00:	9120f421 	add	x1, x1, #0x83d
  410f04:	9123f800 	add	x0, x0, #0x8fe
  410f08:	97ffdb81 	bl	407d0c <assert_print>
  410f0c:	aa1303e0 	mov	x0, x19
  410f10:	52801781 	mov	w1, #0xbc                  	// #188
  410f14:	97ffdba8 	bl	407db4 <assert_post_action>
  410f18:	90000020 	adrp	x0, 414000 <dlc_table.0+0x60d>
  410f1c:	aa1303e1 	mov	x1, x19
  410f20:	9124f000 	add	x0, x0, #0x93c
  410f24:	52801782 	mov	w2, #0xbc                  	// #188
  410f28:	97ffe595 	bl	40a57c <posix_print_error_and_exit>
	return list->head == list;
  410f2c:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  410f30:	aa0003f5 	mov	x21, x0
  410f34:	f9473016 	ldr	x22, [x0, #3680]
  410f38:	aa1603e1 	mov	x1, x22
  410f3c:	f8430c34 	ldr	x20, [x1, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  410f40:	eb01029f 	cmp	x20, x1
  410f44:	54000201 	b.ne	410f84 <ready_thread+0xe4>  // b.any
	sys_dnode_t *const tail = list->tail;
  410f48:	f94732a0 	ldr	x0, [x21, #3680]
	node->next = list;
  410f4c:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  410f50:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  410f54:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  410f58:	f9000033 	str	x19, [x1]
	list->tail = node;
  410f5c:	f9001c13 	str	x19, [x0, #56]
}
  410f60:	a94153f3 	ldp	x19, x20, [sp, #16]
		update_cache(0);
  410f64:	52800000 	mov	w0, #0x0                   	// #0
}
  410f68:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410f6c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		update_cache(0);
  410f70:	17fffefb 	b	410b5c <update_cache>
	return (node == list->tail) ? NULL : node->next;
  410f74:	f9401ec0 	ldr	x0, [x22, #56]
  410f78:	eb14001f 	cmp	x0, x20
  410f7c:	54fffe60 	b.eq	410f48 <ready_thread+0xa8>  // b.none
  410f80:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  410f84:	b4fffe34 	cbz	x20, 410f48 <ready_thread+0xa8>
		if (z_sched_prio_cmp(thread, t) > 0) {
  410f88:	aa1403e1 	mov	x1, x20
  410f8c:	aa1303e0 	mov	x0, x19
  410f90:	97fffd42 	bl	410498 <z_sched_prio_cmp>
  410f94:	7100001f 	cmp	w0, #0x0
  410f98:	54fffeed 	b.le	410f74 <ready_thread+0xd4>
	sys_dnode_t *const prev = successor->prev;
  410f9c:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  410fa0:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  410fa4:	f9000013 	str	x19, [x0]
	successor->prev = node;
  410fa8:	f9000693 	str	x19, [x20, #8]
}
  410fac:	17ffffed 	b	410f60 <ready_thread+0xc0>
}
  410fb0:	a94153f3 	ldp	x19, x20, [sp, #16]
  410fb4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410fb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410fbc:	d65f03c0 	ret

0000000000410fc0 <z_ready_thread>:
{
  410fc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410fc4:	910003fd 	mov	x29, sp
  410fc8:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410fcc:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  410fd0:	f90013f5 	str	x21, [sp, #32]
  410fd4:	aa0003f5 	mov	x21, x0
	return posix_irq_lock();
  410fd8:	97ffe453 	bl	40a124 <posix_irq_lock>
  410fdc:	2a0003f4 	mov	w20, w0
  410fe0:	f947ca73 	ldr	x19, [x19, #3984]
  410fe4:	aa1303e0 	mov	x0, x19
  410fe8:	97fff5f6 	bl	40e7c0 <z_spin_lock_valid>
  410fec:	72001c1f 	tst	w0, #0xff
  410ff0:	540002c1 	b.ne	411048 <z_ready_thread+0x88>  // b.any
  410ff4:	b0000034 	adrp	x20, 415000 <random_data+0xb30>
  410ff8:	91391a94 	add	x20, x20, #0xe46
  410ffc:	aa1403e2 	mov	x2, x20
  411000:	52801283 	mov	w3, #0x94                  	// #148
  411004:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411008:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41100c:	9139cc21 	add	x1, x1, #0xe73
  411010:	9123f800 	add	x0, x0, #0x8fe
  411014:	97ffdb3e 	bl	407d0c <assert_print>
  411018:	aa1303e1 	mov	x1, x19
  41101c:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411020:	913a2000 	add	x0, x0, #0xe88
  411024:	97ffdb3a 	bl	407d0c <assert_print>
  411028:	aa1403e0 	mov	x0, x20
  41102c:	52801281 	mov	w1, #0x94                  	// #148
  411030:	97ffdb61 	bl	407db4 <assert_post_action>
  411034:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411038:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41103c:	aa1403e1 	mov	x1, x20
  411040:	9124f000 	add	x0, x0, #0x93c
  411044:	97ffe54e 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411048:	aa1303e0 	mov	x0, x19
  41104c:	97fff5f5 	bl	40e820 <z_spin_lock_set_owner>
			ready_thread(thread);
  411050:	aa1503e0 	mov	x0, x21
  411054:	97ffff93 	bl	410ea0 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411058:	aa1303e0 	mov	x0, x19
  41105c:	97fff5e4 	bl	40e7ec <z_spin_unlock_valid>
  411060:	72001c1f 	tst	w0, #0xff
  411064:	54000261 	b.ne	4110b0 <z_ready_thread+0xf0>  // b.any
  411068:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  41106c:	91391a94 	add	x20, x20, #0xe46
  411070:	aa1403e2 	mov	x2, x20
  411074:	52801863 	mov	w3, #0xc3                  	// #195
  411078:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  41107c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411080:	913a8021 	add	x1, x1, #0xea0
  411084:	9123f800 	add	x0, x0, #0x8fe
  411088:	97ffdb21 	bl	407d0c <assert_print>
  41108c:	aa1303e1 	mov	x1, x19
  411090:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411094:	913adc00 	add	x0, x0, #0xeb7
  411098:	97ffdb1d 	bl	407d0c <assert_print>
  41109c:	aa1403e0 	mov	x0, x20
  4110a0:	52801861 	mov	w1, #0xc3                  	// #195
  4110a4:	97ffdb44 	bl	407db4 <assert_post_action>
  4110a8:	52801862 	mov	w2, #0xc3                  	// #195
  4110ac:	17ffffe3 	b	411038 <z_ready_thread+0x78>
	posix_irq_unlock(key);
  4110b0:	2a1403e0 	mov	w0, w20
}
  4110b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4110b8:	f94013f5 	ldr	x21, [sp, #32]
  4110bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4110c0:	17ffe41b 	b	40a12c <posix_irq_unlock>

00000000004110c4 <z_sched_start>:
{
  4110c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4110c8:	910003fd 	mov	x29, sp
  4110cc:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4110d0:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  4110d4:	aa0003f4 	mov	x20, x0
  4110d8:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  4110dc:	97ffe412 	bl	40a124 <posix_irq_lock>
  4110e0:	f947ca73 	ldr	x19, [x19, #3984]
  4110e4:	2a0003f5 	mov	w21, w0
  4110e8:	aa1303e0 	mov	x0, x19
  4110ec:	97fff5b5 	bl	40e7c0 <z_spin_lock_valid>
  4110f0:	72001c1f 	tst	w0, #0xff
  4110f4:	540002c1 	b.ne	41114c <z_sched_start+0x88>  // b.any
  4110f8:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  4110fc:	91391a94 	add	x20, x20, #0xe46
  411100:	aa1403e2 	mov	x2, x20
  411104:	52801283 	mov	w3, #0x94                  	// #148
  411108:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  41110c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411110:	9139cc21 	add	x1, x1, #0xe73
  411114:	9123f800 	add	x0, x0, #0x8fe
  411118:	97ffdafd 	bl	407d0c <assert_print>
  41111c:	aa1303e1 	mov	x1, x19
  411120:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411124:	913a2000 	add	x0, x0, #0xe88
  411128:	97ffdaf9 	bl	407d0c <assert_print>
  41112c:	aa1403e0 	mov	x0, x20
  411130:	52801281 	mov	w1, #0x94                  	// #148
  411134:	97ffdb20 	bl	407db4 <assert_post_action>
  411138:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41113c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411140:	aa1403e1 	mov	x1, x20
  411144:	9124f000 	add	x0, x0, #0x93c
  411148:	97ffe50d 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  41114c:	aa1303e0 	mov	x0, x19
  411150:	97fff5b4 	bl	40e820 <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
  411154:	39406680 	ldrb	w0, [x20, #25]
	if (z_has_thread_started(thread)) {
  411158:	37100380 	tbnz	w0, #2, 4111c8 <z_sched_start+0x104>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41115c:	aa1303e0 	mov	x0, x19
  411160:	97fff5a3 	bl	40e7ec <z_spin_unlock_valid>
  411164:	72001c1f 	tst	w0, #0xff
  411168:	54000261 	b.ne	4111b4 <z_sched_start+0xf0>  // b.any
  41116c:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  411170:	91391a94 	add	x20, x20, #0xe46
  411174:	aa1403e2 	mov	x2, x20
  411178:	52801863 	mov	w3, #0xc3                  	// #195
  41117c:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411180:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411184:	913a8021 	add	x1, x1, #0xea0
  411188:	9123f800 	add	x0, x0, #0x8fe
  41118c:	97ffdae0 	bl	407d0c <assert_print>
  411190:	aa1303e1 	mov	x1, x19
  411194:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411198:	913adc00 	add	x0, x0, #0xeb7
  41119c:	97ffdadc 	bl	407d0c <assert_print>
  4111a0:	aa1403e0 	mov	x0, x20
  4111a4:	52801861 	mov	w1, #0xc3                  	// #195
  4111a8:	97ffdb03 	bl	407db4 <assert_post_action>
  4111ac:	52801862 	mov	w2, #0xc3                  	// #195
  4111b0:	17ffffe3 	b	41113c <z_sched_start+0x78>
	posix_irq_unlock(key);
  4111b4:	2a1503e0 	mov	w0, w21
}
  4111b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4111bc:	f94013f5 	ldr	x21, [sp, #32]
  4111c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4111c4:	17ffe3da 	b	40a12c <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
  4111c8:	121d7800 	and	w0, w0, #0xfffffffb
  4111cc:	39006680 	strb	w0, [x20, #25]
	ready_thread(thread);
  4111d0:	aa1403e0 	mov	x0, x20
  4111d4:	97ffff33 	bl	410ea0 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  4111d8:	2a1503e1 	mov	w1, w21
  4111dc:	aa1303e0 	mov	x0, x19
}
  4111e0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4111e4:	f94013f5 	ldr	x21, [sp, #32]
  4111e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&sched_spinlock, key);
  4111ec:	17fffd1a 	b	410654 <z_reschedule>

00000000004111f0 <z_sched_wake_thread>:
{
  4111f0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4111f4:	910003fd 	mov	x29, sp
  4111f8:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4111fc:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  411200:	aa0003f3 	mov	x19, x0
  411204:	a9025bf5 	stp	x21, x22, [sp, #32]
  411208:	f9001bf7 	str	x23, [sp, #48]
  41120c:	12001c37 	and	w23, w1, #0xff
	return posix_irq_lock();
  411210:	97ffe3c5 	bl	40a124 <posix_irq_lock>
  411214:	2a0003f6 	mov	w22, w0
  411218:	f947ca95 	ldr	x21, [x20, #3984]
  41121c:	aa1503e0 	mov	x0, x21
  411220:	97fff568 	bl	40e7c0 <z_spin_lock_valid>
  411224:	72001c1f 	tst	w0, #0xff
  411228:	540002c1 	b.ne	411280 <z_sched_wake_thread+0x90>  // b.any
  41122c:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  411230:	91391a73 	add	x19, x19, #0xe46
  411234:	aa1303e2 	mov	x2, x19
  411238:	52801283 	mov	w3, #0x94                  	// #148
  41123c:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411240:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411244:	9139cc21 	add	x1, x1, #0xe73
  411248:	9123f800 	add	x0, x0, #0x8fe
  41124c:	97ffdab0 	bl	407d0c <assert_print>
  411250:	aa1503e1 	mov	x1, x21
  411254:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411258:	913a2000 	add	x0, x0, #0xe88
  41125c:	97ffdaac 	bl	407d0c <assert_print>
  411260:	aa1303e0 	mov	x0, x19
  411264:	52801281 	mov	w1, #0x94                  	// #148
  411268:	97ffdad3 	bl	407db4 <assert_post_action>
  41126c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411270:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411274:	aa1303e1 	mov	x1, x19
  411278:	9124f000 	add	x0, x0, #0x93c
  41127c:	97ffe4c0 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411280:	aa1503e0 	mov	x0, x21
  411284:	97fff567 	bl	40e820 <z_spin_lock_set_owner>
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  411288:	39422260 	ldrb	w0, [x19, #136]
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
  41128c:	39406661 	ldrb	w1, [x19, #25]
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  411290:	34000060 	cbz	w0, 41129c <z_sched_wake_thread+0xac>
		thread->no_wake_on_timeout = false;
  411294:	3902227f 	strb	wzr, [x19, #136]
		if (do_nothing) {
  411298:	35000237 	cbnz	w23, 4112dc <z_sched_wake_thread+0xec>
		if (!killed) {
  41129c:	52800500 	mov	w0, #0x28                  	// #40
  4112a0:	6a00003f 	tst	w1, w0
  4112a4:	540001c1 	b.ne	4112dc <z_sched_wake_thread+0xec>  // b.any
			if (thread->base.pended_on != NULL) {
  4112a8:	f9400a60 	ldr	x0, [x19, #16]
  4112ac:	b4000060 	cbz	x0, 4112b8 <z_sched_wake_thread+0xc8>
				unpend_thread_no_timeout(thread);
  4112b0:	aa1303e0 	mov	x0, x19
  4112b4:	97fffdbf 	bl	4109b0 <unpend_thread_no_timeout>
  4112b8:	39406662 	ldrb	w2, [x19, #25]
  4112bc:	710002ff 	cmp	w23, #0x0
  4112c0:	12800281 	mov	w1, #0xffffffeb            	// #-21
			ready_thread(thread);
  4112c4:	aa1303e0 	mov	x0, x19
  4112c8:	0a010041 	and	w1, w2, w1
  4112cc:	121d7842 	and	w2, w2, #0xfffffffb
  4112d0:	1a810042 	csel	w2, w2, w1, eq  // eq = none
  4112d4:	39006662 	strb	w2, [x19, #25]
  4112d8:	97fffef2 	bl	410ea0 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4112dc:	f947ca94 	ldr	x20, [x20, #3984]
  4112e0:	aa1403e0 	mov	x0, x20
  4112e4:	97fff542 	bl	40e7ec <z_spin_unlock_valid>
  4112e8:	72001c1f 	tst	w0, #0xff
  4112ec:	54000261 	b.ne	411338 <z_sched_wake_thread+0x148>  // b.any
  4112f0:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  4112f4:	91391a73 	add	x19, x19, #0xe46
  4112f8:	aa1303e2 	mov	x2, x19
  4112fc:	52801863 	mov	w3, #0xc3                  	// #195
  411300:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411304:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411308:	913a8021 	add	x1, x1, #0xea0
  41130c:	9123f800 	add	x0, x0, #0x8fe
  411310:	97ffda7f 	bl	407d0c <assert_print>
  411314:	aa1403e1 	mov	x1, x20
  411318:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  41131c:	913adc00 	add	x0, x0, #0xeb7
  411320:	97ffda7b 	bl	407d0c <assert_print>
  411324:	aa1303e0 	mov	x0, x19
  411328:	52801861 	mov	w1, #0xc3                  	// #195
  41132c:	97ffdaa2 	bl	407db4 <assert_post_action>
  411330:	52801862 	mov	w2, #0xc3                  	// #195
  411334:	17ffffcf 	b	411270 <z_sched_wake_thread+0x80>
	posix_irq_unlock(key);
  411338:	2a1603e0 	mov	w0, w22
}
  41133c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411340:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411344:	f9401bf7 	ldr	x23, [sp, #48]
  411348:	a8c47bfd 	ldp	x29, x30, [sp], #64
  41134c:	17ffe378 	b	40a12c <posix_irq_unlock>

0000000000411350 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
  411350:	d100a000 	sub	x0, x0, #0x28
  411354:	52800021 	mov	w1, #0x1                   	// #1
  411358:	17ffffa6 	b	4111f0 <z_sched_wake_thread>

000000000041135c <unready_thread>:
{
  41135c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411360:	910003fd 	mov	x29, sp
  411364:	a90153f3 	stp	x19, x20, [sp, #16]
  411368:	aa0003f3 	mov	x19, x0
	return (thread->base.thread_state & state) != 0U;
  41136c:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  411370:	39406400 	ldrb	w0, [x0, #25]
	if (z_is_thread_queued(thread)) {
  411374:	39c06661 	ldrsb	w1, [x19, #25]
  411378:	36f800e1 	tbz	w1, #31, 411394 <unready_thread+0x38>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  41137c:	12001800 	and	w0, w0, #0x7f
  411380:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411384:	f9473280 	ldr	x0, [x20, #3680]
  411388:	aa1303e1 	mov	x1, x19
  41138c:	9100c000 	add	x0, x0, #0x30
  411390:	97fffd6b 	bl	41093c <z_priq_dumb_remove>
	update_cache(thread == _current);
  411394:	f9473294 	ldr	x20, [x20, #3680]
  411398:	f9400a80 	ldr	x0, [x20, #16]
  41139c:	eb13001f 	cmp	x0, x19
}
  4113a0:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  4113a4:	1a9f17e0 	cset	w0, eq  // eq = none
}
  4113a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	update_cache(thread == _current);
  4113ac:	17fffdec 	b	410b5c <update_cache>

00000000004113b0 <add_to_waitq_locked>:
{
  4113b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4113b4:	910003fd 	mov	x29, sp
  4113b8:	a90153f3 	stp	x19, x20, [sp, #16]
  4113bc:	aa0003f3 	mov	x19, x0
  4113c0:	aa0103f4 	mov	x20, x1
  4113c4:	f90013f5 	str	x21, [sp, #32]
	unready_thread(thread);
  4113c8:	97ffffe5 	bl	41135c <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
  4113cc:	39406660 	ldrb	w0, [x19, #25]
  4113d0:	321f0000 	orr	w0, w0, #0x2
  4113d4:	39006660 	strb	w0, [x19, #25]
	if (wait_q != NULL) {
  4113d8:	b40003d4 	cbz	x20, 411450 <add_to_waitq_locked+0xa0>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4113dc:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
		thread->base.pended_on = wait_q;
  4113e0:	f9000a74 	str	x20, [x19, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4113e4:	f9470000 	ldr	x0, [x0, #3584]
  4113e8:	eb00027f 	cmp	x19, x0
  4113ec:	54000241 	b.ne	411434 <add_to_waitq_locked+0x84>  // b.any
  4113f0:	b0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  4113f4:	91189a73 	add	x19, x19, #0x626
  4113f8:	aa1303e2 	mov	x2, x19
  4113fc:	52801783 	mov	w3, #0xbc                  	// #188
  411400:	b0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  411404:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411408:	9120f421 	add	x1, x1, #0x83d
  41140c:	9123f800 	add	x0, x0, #0x8fe
  411410:	97ffda3f 	bl	407d0c <assert_print>
  411414:	aa1303e0 	mov	x0, x19
  411418:	52801781 	mov	w1, #0xbc                  	// #188
  41141c:	97ffda66 	bl	407db4 <assert_post_action>
  411420:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411424:	aa1303e1 	mov	x1, x19
  411428:	9124f000 	add	x0, x0, #0x93c
  41142c:	52801782 	mov	w2, #0xbc                  	// #188
  411430:	97ffe453 	bl	40a57c <posix_print_error_and_exit>
	return list->head == list;
  411434:	f9400295 	ldr	x21, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411438:	eb15029f 	cmp	x20, x21
  41143c:	540001a1 	b.ne	411470 <add_to_waitq_locked+0xc0>  // b.any
	sys_dnode_t *const tail = list->tail;
  411440:	f9400680 	ldr	x0, [x20, #8]
	node->prev = tail;
  411444:	a9000274 	stp	x20, x0, [x19]
	tail->next = node;
  411448:	f9000013 	str	x19, [x0]
	list->tail = node;
  41144c:	f9000693 	str	x19, [x20, #8]
}
  411450:	a94153f3 	ldp	x19, x20, [sp, #16]
  411454:	f94013f5 	ldr	x21, [sp, #32]
  411458:	a8c37bfd 	ldp	x29, x30, [sp], #48
  41145c:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
  411460:	f9400680 	ldr	x0, [x20, #8]
  411464:	eb15001f 	cmp	x0, x21
  411468:	54fffec0 	b.eq	411440 <add_to_waitq_locked+0x90>  // b.none
  41146c:	f94002b5 	ldr	x21, [x21]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  411470:	b4fffe95 	cbz	x21, 411440 <add_to_waitq_locked+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
  411474:	aa1503e1 	mov	x1, x21
  411478:	aa1303e0 	mov	x0, x19
  41147c:	97fffc07 	bl	410498 <z_sched_prio_cmp>
  411480:	7100001f 	cmp	w0, #0x0
  411484:	54fffeed 	b.le	411460 <add_to_waitq_locked+0xb0>
	sys_dnode_t *const prev = successor->prev;
  411488:	f94006a0 	ldr	x0, [x21, #8]
	node->prev = prev;
  41148c:	a9000275 	stp	x21, x0, [x19]
	prev->next = node;
  411490:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411494:	f90006b3 	str	x19, [x21, #8]
}
  411498:	17ffffee 	b	411450 <add_to_waitq_locked+0xa0>

000000000041149c <pend_locked>:
{
  41149c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4114a0:	910003fd 	mov	x29, sp
  4114a4:	a90153f3 	stp	x19, x20, [sp, #16]
  4114a8:	aa0203f3 	mov	x19, x2
  4114ac:	aa0003f4 	mov	x20, x0
	add_to_waitq_locked(thread, wait_q);
  4114b0:	97ffffc0 	bl	4113b0 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4114b4:	b100067f 	cmn	x19, #0x1
  4114b8:	54000100 	b.eq	4114d8 <pend_locked+0x3c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  4114bc:	aa1303e2 	mov	x2, x19
  4114c0:	9100a280 	add	x0, x20, #0x28
  4114c4:	d00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
}
  4114c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4114cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4114d0:	f9472821 	ldr	x1, [x1, #3664]
  4114d4:	14000589 	b	412af8 <z_add_timeout>
  4114d8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4114dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4114e0:	d65f03c0 	ret

00000000004114e4 <z_pend_curr>:
{
  4114e4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4114e8:	910003fd 	mov	x29, sp
  4114ec:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  4114f0:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  4114f4:	f947ca73 	ldr	x19, [x19, #3984]
{
  4114f8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4114fc:	f9001bf7 	str	x23, [sp, #48]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  411500:	eb13001f 	cmp	x0, x19
  411504:	54000201 	b.ne	411544 <z_pend_curr+0x60>  // b.any
  411508:	b0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  41150c:	91189a73 	add	x19, x19, #0x626
  411510:	aa1303e2 	mov	x2, x19
  411514:	52806a43 	mov	w3, #0x352                 	// #850
  411518:	b0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  41151c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411520:	91227021 	add	x1, x1, #0x89c
  411524:	9123f800 	add	x0, x0, #0x8fe
  411528:	97ffd9f9 	bl	407d0c <assert_print>
  41152c:	aa1303e0 	mov	x0, x19
  411530:	52806a41 	mov	w1, #0x352                 	// #850
  411534:	97ffda20 	bl	407db4 <assert_post_action>
  411538:	52806a42 	mov	w2, #0x352                 	// #850
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41153c:	aa1303e1 	mov	x1, x19
  411540:	1400001c 	b	4115b0 <z_pend_curr+0xcc>
  411544:	aa0003f4 	mov	x20, x0
  411548:	2a0103f5 	mov	w21, w1
  41154c:	aa0203f6 	mov	x22, x2
  411550:	aa0303f7 	mov	x23, x3
	return posix_irq_lock();
  411554:	97ffe2f4 	bl	40a124 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411558:	aa1303e0 	mov	x0, x19
  41155c:	97fff499 	bl	40e7c0 <z_spin_lock_valid>
  411560:	72001c1f 	tst	w0, #0xff
  411564:	540002c1 	b.ne	4115bc <z_pend_curr+0xd8>  // b.any
  411568:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  41156c:	91391a94 	add	x20, x20, #0xe46
  411570:	aa1403e2 	mov	x2, x20
  411574:	52801283 	mov	w3, #0x94                  	// #148
  411578:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  41157c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411580:	9139cc21 	add	x1, x1, #0xe73
  411584:	9123f800 	add	x0, x0, #0x8fe
  411588:	97ffd9e1 	bl	407d0c <assert_print>
  41158c:	aa1303e1 	mov	x1, x19
  411590:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411594:	913a2000 	add	x0, x0, #0xe88
  411598:	97ffd9dd 	bl	407d0c <assert_print>
  41159c:	aa1403e0 	mov	x0, x20
  4115a0:	52801281 	mov	w1, #0x94                  	// #148
  4115a4:	97ffda04 	bl	407db4 <assert_post_action>
  4115a8:	52801282 	mov	w2, #0x94                  	// #148
  4115ac:	aa1403e1 	mov	x1, x20
  4115b0:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4115b4:	9124f000 	add	x0, x0, #0x93c
  4115b8:	97ffe3f1 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4115bc:	aa1303e0 	mov	x0, x19
  4115c0:	97fff498 	bl	40e820 <z_spin_lock_set_owner>
	pend_locked(_current, wait_q, timeout);
  4115c4:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  4115c8:	aa1703e2 	mov	x2, x23
  4115cc:	aa1603e1 	mov	x1, x22
  4115d0:	f9473000 	ldr	x0, [x0, #3680]
  4115d4:	f9400800 	ldr	x0, [x0, #16]
  4115d8:	97ffffb1 	bl	41149c <pend_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4115dc:	aa1403e0 	mov	x0, x20
  4115e0:	97fff483 	bl	40e7ec <z_spin_unlock_valid>
  4115e4:	72001c1f 	tst	w0, #0xff
  4115e8:	54000261 	b.ne	411634 <z_pend_curr+0x150>  // b.any
  4115ec:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  4115f0:	91391a73 	add	x19, x19, #0xe46
  4115f4:	aa1303e2 	mov	x2, x19
  4115f8:	52801c43 	mov	w3, #0xe2                  	// #226
  4115fc:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411600:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411604:	913a8021 	add	x1, x1, #0xea0
  411608:	9123f800 	add	x0, x0, #0x8fe
  41160c:	97ffd9c0 	bl	407d0c <assert_print>
  411610:	aa1403e1 	mov	x1, x20
  411614:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411618:	913adc00 	add	x0, x0, #0xeb7
  41161c:	97ffd9bc 	bl	407d0c <assert_print>
  411620:	aa1303e0 	mov	x0, x19
  411624:	52801c41 	mov	w1, #0xe2                  	// #226
  411628:	97ffd9e3 	bl	407db4 <assert_post_action>
  41162c:	52801c42 	mov	w2, #0xe2                  	// #226
  411630:	17ffffc3 	b	41153c <z_pend_curr+0x58>
  411634:	aa1303e0 	mov	x0, x19
  411638:	97fff46d 	bl	40e7ec <z_spin_unlock_valid>
  41163c:	72001c1f 	tst	w0, #0xff
  411640:	54000261 	b.ne	41168c <z_pend_curr+0x1a8>  // b.any
  411644:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  411648:	91391a94 	add	x20, x20, #0xe46
  41164c:	aa1403e2 	mov	x2, x20
  411650:	52801c43 	mov	w3, #0xe2                  	// #226
  411654:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411658:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41165c:	913a8021 	add	x1, x1, #0xea0
  411660:	9123f800 	add	x0, x0, #0x8fe
  411664:	97ffd9aa 	bl	407d0c <assert_print>
  411668:	aa1303e1 	mov	x1, x19
  41166c:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411670:	913adc00 	add	x0, x0, #0xeb7
  411674:	97ffd9a6 	bl	407d0c <assert_print>
  411678:	aa1403e0 	mov	x0, x20
  41167c:	52801c41 	mov	w1, #0xe2                  	// #226
  411680:	97ffd9cd 	bl	407db4 <assert_post_action>
  411684:	52801c42 	mov	w2, #0xe2                  	// #226
  411688:	17ffffc9 	b	4115ac <z_pend_curr+0xc8>
  41168c:	2a1503e0 	mov	w0, w21
}
  411690:	a94153f3 	ldp	x19, x20, [sp, #16]
  411694:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411698:	f9401bf7 	ldr	x23, [sp, #48]
  41169c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4116a0:	17ffdf77 	b	40947c <arch_swap>

00000000004116a4 <z_set_prio>:
{
  4116a4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4116a8:	910003fd 	mov	x29, sp
  4116ac:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4116b0:	d00000d8 	adrp	x24, 42b000 <__FRAME_END__+0xfd74>
  4116b4:	a90153f3 	stp	x19, x20, [sp, #16]
  4116b8:	aa0003f3 	mov	x19, x0
  4116bc:	a9025bf5 	stp	x21, x22, [sp, #32]
  4116c0:	2a0103f5 	mov	w21, w1
  4116c4:	f90023f9 	str	x25, [sp, #64]
  4116c8:	97ffe297 	bl	40a124 <posix_irq_lock>
  4116cc:	f947cb19 	ldr	x25, [x24, #3984]
  4116d0:	2a0003f7 	mov	w23, w0
  4116d4:	aa1903e0 	mov	x0, x25
  4116d8:	97fff43a 	bl	40e7c0 <z_spin_lock_valid>
  4116dc:	72001c16 	ands	w22, w0, #0xff
  4116e0:	540002c1 	b.ne	411738 <z_set_prio+0x94>  // b.any
  4116e4:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  4116e8:	91391a73 	add	x19, x19, #0xe46
  4116ec:	aa1303e2 	mov	x2, x19
  4116f0:	52801283 	mov	w3, #0x94                  	// #148
  4116f4:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  4116f8:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4116fc:	9139cc21 	add	x1, x1, #0xe73
  411700:	9123f800 	add	x0, x0, #0x8fe
  411704:	97ffd982 	bl	407d0c <assert_print>
  411708:	aa1903e1 	mov	x1, x25
  41170c:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411710:	913a2000 	add	x0, x0, #0xe88
  411714:	97ffd97e 	bl	407d0c <assert_print>
  411718:	aa1303e0 	mov	x0, x19
  41171c:	52801281 	mov	w1, #0x94                  	// #148
  411720:	97ffd9a5 	bl	407db4 <assert_post_action>
  411724:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411728:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41172c:	aa1303e1 	mov	x1, x19
  411730:	9124f000 	add	x0, x0, #0x93c
  411734:	97ffe392 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411738:	aa1903e0 	mov	x0, x25
  41173c:	97fff439 	bl	40e820 <z_spin_lock_set_owner>
	uint8_t state = thread->base.thread_state;
  411740:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  411744:	13001eb5 	sxtb	w21, w21
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  411748:	f240101f 	tst	x0, #0x1f
  41174c:	54000a61 	b.ne	411898 <z_set_prio+0x1f4>  // b.any
		if (need_sched) {
  411750:	f9401661 	ldr	x1, [x19, #40]
  411754:	b5000a21 	cbnz	x1, 411898 <z_set_prio+0x1f4>
	_priq_run_remove(thread_runq(thread), thread);
  411758:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  41175c:	12001800 	and	w0, w0, #0x7f
  411760:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411764:	aa1303e1 	mov	x1, x19
  411768:	f9473299 	ldr	x25, [x20, #3680]
  41176c:	9100c320 	add	x0, x25, #0x30
  411770:	97fffc73 	bl	41093c <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  411774:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  411778:	39006a75 	strb	w21, [x19, #26]
	thread->base.thread_state |= _THREAD_QUEUED;
  41177c:	aa1403f5 	mov	x21, x20
  411780:	32196000 	orr	w0, w0, #0xffffff80
  411784:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411788:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  41178c:	f9470000 	ldr	x0, [x0, #3584]
  411790:	eb00027f 	cmp	x19, x0
  411794:	540001e1 	b.ne	4117d0 <z_set_prio+0x12c>  // b.any
  411798:	b0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  41179c:	91189a73 	add	x19, x19, #0x626
  4117a0:	aa1303e2 	mov	x2, x19
  4117a4:	52801783 	mov	w3, #0xbc                  	// #188
  4117a8:	b0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  4117ac:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4117b0:	9120f421 	add	x1, x1, #0x83d
  4117b4:	9123f800 	add	x0, x0, #0x8fe
  4117b8:	97ffd955 	bl	407d0c <assert_print>
  4117bc:	aa1303e0 	mov	x0, x19
  4117c0:	52801781 	mov	w1, #0xbc                  	// #188
  4117c4:	97ffd97c 	bl	407db4 <assert_post_action>
  4117c8:	52801782 	mov	w2, #0xbc                  	// #188
  4117cc:	17ffffd7 	b	411728 <z_set_prio+0x84>
	return list->head == list;
  4117d0:	aa1903e0 	mov	x0, x25
  4117d4:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4117d8:	eb00029f 	cmp	x20, x0
  4117dc:	54000481 	b.ne	41186c <z_set_prio+0x1c8>  // b.any
	sys_dnode_t *const tail = list->tail;
  4117e0:	f94732a2 	ldr	x2, [x21, #3680]
	node->next = list;
  4117e4:	9100c041 	add	x1, x2, #0x30
	sys_dnode_t *const tail = list->tail;
  4117e8:	f9401c40 	ldr	x0, [x2, #56]
	node->prev = tail;
  4117ec:	a9000261 	stp	x1, x0, [x19]
	tail->next = node;
  4117f0:	f9000013 	str	x19, [x0]
	list->tail = node;
  4117f4:	f9001c53 	str	x19, [x2, #56]
			update_cache(1);
  4117f8:	52800020 	mov	w0, #0x1                   	// #1
  4117fc:	97fffcd8 	bl	410b5c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411800:	f947cb18 	ldr	x24, [x24, #3984]
  411804:	aa1803e0 	mov	x0, x24
  411808:	97fff3f9 	bl	40e7ec <z_spin_unlock_valid>
  41180c:	72001c1f 	tst	w0, #0xff
  411810:	540004a1 	b.ne	4118a4 <z_set_prio+0x200>  // b.any
  411814:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  411818:	91391a73 	add	x19, x19, #0xe46
  41181c:	aa1303e2 	mov	x2, x19
  411820:	52801863 	mov	w3, #0xc3                  	// #195
  411824:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411828:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41182c:	913a8021 	add	x1, x1, #0xea0
  411830:	9123f800 	add	x0, x0, #0x8fe
  411834:	97ffd936 	bl	407d0c <assert_print>
  411838:	aa1803e1 	mov	x1, x24
  41183c:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411840:	913adc00 	add	x0, x0, #0xeb7
  411844:	97ffd932 	bl	407d0c <assert_print>
  411848:	aa1303e0 	mov	x0, x19
  41184c:	52801861 	mov	w1, #0xc3                  	// #195
  411850:	97ffd959 	bl	407db4 <assert_post_action>
  411854:	52801862 	mov	w2, #0xc3                  	// #195
  411858:	17ffffb4 	b	411728 <z_set_prio+0x84>
	return (node == list->tail) ? NULL : node->next;
  41185c:	f9401f20 	ldr	x0, [x25, #56]
  411860:	eb00029f 	cmp	x20, x0
  411864:	54fffbe0 	b.eq	4117e0 <z_set_prio+0x13c>  // b.none
  411868:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  41186c:	b4fffbb4 	cbz	x20, 4117e0 <z_set_prio+0x13c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  411870:	aa1403e1 	mov	x1, x20
  411874:	aa1303e0 	mov	x0, x19
  411878:	97fffb08 	bl	410498 <z_sched_prio_cmp>
  41187c:	7100001f 	cmp	w0, #0x0
  411880:	54fffeed 	b.le	41185c <z_set_prio+0x1b8>
	sys_dnode_t *const prev = successor->prev;
  411884:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  411888:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  41188c:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411890:	f9000693 	str	x19, [x20, #8]
}
  411894:	17ffffd9 	b	4117f8 <z_set_prio+0x154>
			thread->base.prio = prio;
  411898:	52800016 	mov	w22, #0x0                   	// #0
  41189c:	39006a75 	strb	w21, [x19, #26]
  4118a0:	17ffffd8 	b	411800 <z_set_prio+0x15c>
	posix_irq_unlock(key);
  4118a4:	2a1703e0 	mov	w0, w23
  4118a8:	97ffe221 	bl	40a12c <posix_irq_unlock>
}
  4118ac:	2a1603e0 	mov	w0, w22
  4118b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4118b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4118b8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4118bc:	f94023f9 	ldr	x25, [sp, #64]
  4118c0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4118c4:	d65f03c0 	ret

00000000004118c8 <z_impl_k_thread_suspend>:
{
  4118c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4118cc:	910003fd 	mov	x29, sp
  4118d0:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4118d4:	d00000d5 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
  4118d8:	a90153f3 	stp	x19, x20, [sp, #16]
  4118dc:	aa0003f3 	mov	x19, x0
	return z_abort_timeout(&thread->base.timeout);
  4118e0:	9100a000 	add	x0, x0, #0x28
  4118e4:	94000517 	bl	412d40 <z_abort_timeout>
	return posix_irq_lock();
  4118e8:	97ffe20f 	bl	40a124 <posix_irq_lock>
  4118ec:	2a0003f6 	mov	w22, w0
  4118f0:	f947cab4 	ldr	x20, [x21, #3984]
  4118f4:	aa1403e0 	mov	x0, x20
  4118f8:	97fff3b2 	bl	40e7c0 <z_spin_lock_valid>
  4118fc:	72001c1f 	tst	w0, #0xff
  411900:	540002c1 	b.ne	411958 <z_impl_k_thread_suspend+0x90>  // b.any
  411904:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  411908:	91391a73 	add	x19, x19, #0xe46
  41190c:	aa1303e2 	mov	x2, x19
  411910:	52801283 	mov	w3, #0x94                  	// #148
  411914:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411918:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41191c:	9139cc21 	add	x1, x1, #0xe73
  411920:	9123f800 	add	x0, x0, #0x8fe
  411924:	97ffd8fa 	bl	407d0c <assert_print>
  411928:	aa1403e1 	mov	x1, x20
  41192c:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411930:	913a2000 	add	x0, x0, #0xe88
  411934:	97ffd8f6 	bl	407d0c <assert_print>
  411938:	aa1303e0 	mov	x0, x19
  41193c:	52801281 	mov	w1, #0x94                  	// #148
  411940:	97ffd91d 	bl	407db4 <assert_post_action>
  411944:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411948:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41194c:	aa1303e1 	mov	x1, x19
  411950:	9124f000 	add	x0, x0, #0x93c
  411954:	97ffe30a 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411958:	aa1403e0 	mov	x0, x20
  41195c:	97fff3b1 	bl	40e820 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
  411960:	39c06661 	ldrsb	w1, [x19, #25]
  411964:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
	return (thread->base.thread_state & state) != 0U;
  411968:	39406660 	ldrb	w0, [x19, #25]
  41196c:	36f800e1 	tbz	w1, #31, 411988 <z_impl_k_thread_suspend+0xc0>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411970:	12001800 	and	w0, w0, #0x7f
  411974:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411978:	f9473280 	ldr	x0, [x20, #3680]
  41197c:	aa1303e1 	mov	x1, x19
  411980:	9100c000 	add	x0, x0, #0x30
  411984:	97fffbee 	bl	41093c <z_priq_dumb_remove>
		update_cache(thread == _current);
  411988:	f9473294 	ldr	x20, [x20, #3680]
	thread->base.thread_state |= _THREAD_SUSPENDED;
  41198c:	39406660 	ldrb	w0, [x19, #25]
  411990:	321c0000 	orr	w0, w0, #0x10
  411994:	39006660 	strb	w0, [x19, #25]
  411998:	f9400a80 	ldr	x0, [x20, #16]
  41199c:	eb13001f 	cmp	x0, x19
  4119a0:	1a9f17e0 	cset	w0, eq  // eq = none
  4119a4:	97fffc6e 	bl	410b5c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4119a8:	f947cab5 	ldr	x21, [x21, #3984]
  4119ac:	aa1503e0 	mov	x0, x21
  4119b0:	97fff38f 	bl	40e7ec <z_spin_unlock_valid>
  4119b4:	72001c1f 	tst	w0, #0xff
  4119b8:	54000261 	b.ne	411a04 <z_impl_k_thread_suspend+0x13c>  // b.any
  4119bc:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  4119c0:	91391a73 	add	x19, x19, #0xe46
  4119c4:	aa1303e2 	mov	x2, x19
  4119c8:	52801863 	mov	w3, #0xc3                  	// #195
  4119cc:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  4119d0:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4119d4:	913a8021 	add	x1, x1, #0xea0
  4119d8:	9123f800 	add	x0, x0, #0x8fe
  4119dc:	97ffd8cc 	bl	407d0c <assert_print>
  4119e0:	aa1503e1 	mov	x1, x21
  4119e4:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  4119e8:	913adc00 	add	x0, x0, #0xeb7
  4119ec:	97ffd8c8 	bl	407d0c <assert_print>
  4119f0:	aa1303e0 	mov	x0, x19
  4119f4:	52801861 	mov	w1, #0xc3                  	// #195
  4119f8:	97ffd8ef 	bl	407db4 <assert_post_action>
  4119fc:	52801862 	mov	w2, #0xc3                  	// #195
  411a00:	17ffffd2 	b	411948 <z_impl_k_thread_suspend+0x80>
	posix_irq_unlock(key);
  411a04:	2a1603e0 	mov	w0, w22
  411a08:	97ffe1c9 	bl	40a12c <posix_irq_unlock>
	if (thread == _current) {
  411a0c:	f9400a80 	ldr	x0, [x20, #16]
  411a10:	eb13001f 	cmp	x0, x19
  411a14:	540000a1 	b.ne	411a28 <z_impl_k_thread_suspend+0x160>  // b.any
}
  411a18:	a94153f3 	ldp	x19, x20, [sp, #16]
  411a1c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411a20:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule_unlocked();
  411a24:	17fffb58 	b	410784 <z_reschedule_unlocked>
}
  411a28:	a94153f3 	ldp	x19, x20, [sp, #16]
  411a2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411a30:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411a34:	d65f03c0 	ret

0000000000411a38 <k_sched_unlock>:
{
  411a38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411a3c:	910003fd 	mov	x29, sp
  411a40:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411a44:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
	return posix_irq_lock();
  411a48:	97ffe1b7 	bl	40a124 <posix_irq_lock>
  411a4c:	f947ca73 	ldr	x19, [x19, #3984]
  411a50:	2a0003f4 	mov	w20, w0
  411a54:	aa1303e0 	mov	x0, x19
  411a58:	97fff35a 	bl	40e7c0 <z_spin_lock_valid>
  411a5c:	72001c1f 	tst	w0, #0xff
  411a60:	54000281 	b.ne	411ab0 <k_sched_unlock+0x78>  // b.any
  411a64:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  411a68:	91391a94 	add	x20, x20, #0xe46
  411a6c:	aa1403e2 	mov	x2, x20
  411a70:	52801283 	mov	w3, #0x94                  	// #148
  411a74:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411a78:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411a7c:	9139cc21 	add	x1, x1, #0xe73
  411a80:	9123f800 	add	x0, x0, #0x8fe
  411a84:	97ffd8a2 	bl	407d0c <assert_print>
  411a88:	aa1303e1 	mov	x1, x19
  411a8c:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411a90:	913a2000 	add	x0, x0, #0xe88
  411a94:	97ffd89e 	bl	407d0c <assert_print>
  411a98:	aa1403e0 	mov	x0, x20
  411a9c:	52801281 	mov	w1, #0x94                  	// #148
  411aa0:	97ffd8c5 	bl	407db4 <assert_post_action>
  411aa4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411aa8:	aa1403e1 	mov	x1, x20
  411aac:	14000019 	b	411b10 <k_sched_unlock+0xd8>
	z_spin_lock_set_owner(l);
  411ab0:	aa1303e0 	mov	x0, x19
  411ab4:	97fff35b 	bl	40e820 <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0U, "");
  411ab8:	d00000c2 	adrp	x2, 42b000 <__FRAME_END__+0xfd74>
  411abc:	f9473042 	ldr	x2, [x2, #3680]
  411ac0:	f9400840 	ldr	x0, [x2, #16]
  411ac4:	39406c01 	ldrb	w1, [x0, #27]
  411ac8:	350002a1 	cbnz	w1, 411b1c <k_sched_unlock+0xe4>
  411acc:	b0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  411ad0:	91189a73 	add	x19, x19, #0x626
  411ad4:	aa1303e2 	mov	x2, x19
  411ad8:	b0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  411adc:	91234c21 	add	x1, x1, #0x8d3
  411ae0:	52807d63 	mov	w3, #0x3eb                 	// #1003
  411ae4:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411ae8:	9123f800 	add	x0, x0, #0x8fe
  411aec:	97ffd888 	bl	407d0c <assert_print>
  411af0:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411af4:	913b7400 	add	x0, x0, #0xedd
  411af8:	97ffd885 	bl	407d0c <assert_print>
  411afc:	aa1303e0 	mov	x0, x19
  411b00:	52807d61 	mov	w1, #0x3eb                 	// #1003
  411b04:	97ffd8ac 	bl	407db4 <assert_post_action>
  411b08:	52807d62 	mov	w2, #0x3eb                 	// #1003
  411b0c:	aa1303e1 	mov	x1, x19
  411b10:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411b14:	9124f000 	add	x0, x0, #0x93c
  411b18:	97ffe299 	bl	40a57c <posix_print_error_and_exit>
		__ASSERT(!arch_is_in_isr(), "");
  411b1c:	b9400042 	ldr	w2, [x2]
  411b20:	34000242 	cbz	w2, 411b68 <k_sched_unlock+0x130>
  411b24:	b0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  411b28:	91189a73 	add	x19, x19, #0x626
  411b2c:	aa1303e2 	mov	x2, x19
  411b30:	b0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  411b34:	910e6021 	add	x1, x1, #0x398
  411b38:	52807d83 	mov	w3, #0x3ec                 	// #1004
  411b3c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411b40:	9123f800 	add	x0, x0, #0x8fe
  411b44:	97ffd872 	bl	407d0c <assert_print>
  411b48:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411b4c:	913b7400 	add	x0, x0, #0xedd
  411b50:	97ffd86f 	bl	407d0c <assert_print>
  411b54:	aa1303e0 	mov	x0, x19
  411b58:	52807d81 	mov	w1, #0x3ec                 	// #1004
  411b5c:	97ffd896 	bl	407db4 <assert_post_action>
  411b60:	52807d82 	mov	w2, #0x3ec                 	// #1004
  411b64:	17ffffea 	b	411b0c <k_sched_unlock+0xd4>
		++_current->base.sched_locked;
  411b68:	11000421 	add	w1, w1, #0x1
  411b6c:	39006c01 	strb	w1, [x0, #27]
		update_cache(0);
  411b70:	52800000 	mov	w0, #0x0                   	// #0
  411b74:	97fffbfa 	bl	410b5c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411b78:	aa1303e0 	mov	x0, x19
  411b7c:	97fff31c 	bl	40e7ec <z_spin_unlock_valid>
  411b80:	72001c1f 	tst	w0, #0xff
  411b84:	54000261 	b.ne	411bd0 <k_sched_unlock+0x198>  // b.any
  411b88:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  411b8c:	91391a94 	add	x20, x20, #0xe46
  411b90:	aa1403e2 	mov	x2, x20
  411b94:	52801863 	mov	w3, #0xc3                  	// #195
  411b98:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411b9c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411ba0:	913a8021 	add	x1, x1, #0xea0
  411ba4:	9123f800 	add	x0, x0, #0x8fe
  411ba8:	97ffd859 	bl	407d0c <assert_print>
  411bac:	aa1303e1 	mov	x1, x19
  411bb0:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411bb4:	913adc00 	add	x0, x0, #0xeb7
  411bb8:	97ffd855 	bl	407d0c <assert_print>
  411bbc:	aa1403e0 	mov	x0, x20
  411bc0:	52801861 	mov	w1, #0xc3                  	// #195
  411bc4:	97ffd87c 	bl	407db4 <assert_post_action>
  411bc8:	52801862 	mov	w2, #0xc3                  	// #195
  411bcc:	17ffffb7 	b	411aa8 <k_sched_unlock+0x70>
	posix_irq_unlock(key);
  411bd0:	2a1403e0 	mov	w0, w20
  411bd4:	97ffe156 	bl	40a12c <posix_irq_unlock>
}
  411bd8:	a94153f3 	ldp	x19, x20, [sp, #16]
  411bdc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
  411be0:	17fffae9 	b	410784 <z_reschedule_unlocked>

0000000000411be4 <z_unpend1_no_timeout>:
{
  411be4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411be8:	910003fd 	mov	x29, sp
  411bec:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411bf0:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  411bf4:	aa0003f4 	mov	x20, x0
  411bf8:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  411bfc:	97ffe14a 	bl	40a124 <posix_irq_lock>
  411c00:	2a0003f5 	mov	w21, w0
  411c04:	f947ca76 	ldr	x22, [x19, #3984]
  411c08:	aa1603e0 	mov	x0, x22
  411c0c:	97fff2ed 	bl	40e7c0 <z_spin_lock_valid>
  411c10:	72001c1f 	tst	w0, #0xff
  411c14:	540002c1 	b.ne	411c6c <z_unpend1_no_timeout+0x88>  // b.any
  411c18:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  411c1c:	91391a73 	add	x19, x19, #0xe46
  411c20:	aa1303e2 	mov	x2, x19
  411c24:	52801283 	mov	w3, #0x94                  	// #148
  411c28:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411c2c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411c30:	9139cc21 	add	x1, x1, #0xe73
  411c34:	9123f800 	add	x0, x0, #0x8fe
  411c38:	97ffd835 	bl	407d0c <assert_print>
  411c3c:	aa1603e1 	mov	x1, x22
  411c40:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411c44:	913a2000 	add	x0, x0, #0xe88
  411c48:	97ffd831 	bl	407d0c <assert_print>
  411c4c:	52801281 	mov	w1, #0x94                  	// #148
  411c50:	aa1303e0 	mov	x0, x19
  411c54:	97ffd858 	bl	407db4 <assert_post_action>
  411c58:	aa1303e1 	mov	x1, x19
  411c5c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411c60:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411c64:	9124f000 	add	x0, x0, #0x93c
  411c68:	97ffe245 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411c6c:	aa1603e0 	mov	x0, x22
  411c70:	97fff2ec 	bl	40e820 <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  411c74:	aa1403e0 	mov	x0, x20
  411c78:	97fffbb5 	bl	410b4c <z_priq_dumb_best>
  411c7c:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  411c80:	b4000040 	cbz	x0, 411c88 <z_unpend1_no_timeout+0xa4>
			unpend_thread_no_timeout(thread);
  411c84:	97fffb4b 	bl	4109b0 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411c88:	f947ca73 	ldr	x19, [x19, #3984]
  411c8c:	aa1303e0 	mov	x0, x19
  411c90:	97fff2d7 	bl	40e7ec <z_spin_unlock_valid>
  411c94:	72001c1f 	tst	w0, #0xff
  411c98:	54000281 	b.ne	411ce8 <z_unpend1_no_timeout+0x104>  // b.any
  411c9c:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  411ca0:	91391a94 	add	x20, x20, #0xe46
  411ca4:	aa1403e2 	mov	x2, x20
  411ca8:	52801863 	mov	w3, #0xc3                  	// #195
  411cac:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411cb0:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411cb4:	913a8021 	add	x1, x1, #0xea0
  411cb8:	9123f800 	add	x0, x0, #0x8fe
  411cbc:	97ffd814 	bl	407d0c <assert_print>
  411cc0:	aa1303e1 	mov	x1, x19
  411cc4:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411cc8:	913adc00 	add	x0, x0, #0xeb7
  411ccc:	97ffd810 	bl	407d0c <assert_print>
  411cd0:	52801861 	mov	w1, #0xc3                  	// #195
  411cd4:	aa1403e0 	mov	x0, x20
  411cd8:	97ffd837 	bl	407db4 <assert_post_action>
  411cdc:	aa1403e1 	mov	x1, x20
  411ce0:	52801862 	mov	w2, #0xc3                  	// #195
  411ce4:	17ffffdf 	b	411c60 <z_unpend1_no_timeout+0x7c>
	posix_irq_unlock(key);
  411ce8:	2a1503e0 	mov	w0, w21
  411cec:	97ffe110 	bl	40a12c <posix_irq_unlock>
}
  411cf0:	aa1403e0 	mov	x0, x20
  411cf4:	a94153f3 	ldp	x19, x20, [sp, #16]
  411cf8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411cfc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411d00:	d65f03c0 	ret

0000000000411d04 <z_unpend_first_thread>:
{
  411d04:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411d08:	910003fd 	mov	x29, sp
  411d0c:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411d10:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  411d14:	aa0003f4 	mov	x20, x0
  411d18:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  411d1c:	97ffe102 	bl	40a124 <posix_irq_lock>
  411d20:	2a0003f5 	mov	w21, w0
  411d24:	f947ca76 	ldr	x22, [x19, #3984]
  411d28:	aa1603e0 	mov	x0, x22
  411d2c:	97fff2a5 	bl	40e7c0 <z_spin_lock_valid>
  411d30:	72001c1f 	tst	w0, #0xff
  411d34:	540002c1 	b.ne	411d8c <z_unpend_first_thread+0x88>  // b.any
  411d38:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  411d3c:	91391a73 	add	x19, x19, #0xe46
  411d40:	aa1303e2 	mov	x2, x19
  411d44:	52801283 	mov	w3, #0x94                  	// #148
  411d48:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411d4c:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411d50:	9139cc21 	add	x1, x1, #0xe73
  411d54:	9123f800 	add	x0, x0, #0x8fe
  411d58:	97ffd7ed 	bl	407d0c <assert_print>
  411d5c:	aa1603e1 	mov	x1, x22
  411d60:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411d64:	913a2000 	add	x0, x0, #0xe88
  411d68:	97ffd7e9 	bl	407d0c <assert_print>
  411d6c:	52801281 	mov	w1, #0x94                  	// #148
  411d70:	aa1303e0 	mov	x0, x19
  411d74:	97ffd810 	bl	407db4 <assert_post_action>
  411d78:	aa1303e1 	mov	x1, x19
  411d7c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411d80:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411d84:	9124f000 	add	x0, x0, #0x93c
  411d88:	97ffe1fd 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411d8c:	aa1603e0 	mov	x0, x22
  411d90:	97fff2a4 	bl	40e820 <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  411d94:	aa1403e0 	mov	x0, x20
  411d98:	97fffb6d 	bl	410b4c <z_priq_dumb_best>
  411d9c:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  411da0:	b4000080 	cbz	x0, 411db0 <z_unpend_first_thread+0xac>
			unpend_thread_no_timeout(thread);
  411da4:	97fffb03 	bl	4109b0 <unpend_thread_no_timeout>
  411da8:	9100a280 	add	x0, x20, #0x28
  411dac:	940003e5 	bl	412d40 <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411db0:	f947ca73 	ldr	x19, [x19, #3984]
  411db4:	aa1303e0 	mov	x0, x19
  411db8:	97fff28d 	bl	40e7ec <z_spin_unlock_valid>
  411dbc:	72001c1f 	tst	w0, #0xff
  411dc0:	54000281 	b.ne	411e10 <z_unpend_first_thread+0x10c>  // b.any
  411dc4:	90000034 	adrp	x20, 415000 <random_data+0xb30>
  411dc8:	91391a94 	add	x20, x20, #0xe46
  411dcc:	aa1403e2 	mov	x2, x20
  411dd0:	52801863 	mov	w3, #0xc3                  	// #195
  411dd4:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411dd8:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411ddc:	913a8021 	add	x1, x1, #0xea0
  411de0:	9123f800 	add	x0, x0, #0x8fe
  411de4:	97ffd7ca 	bl	407d0c <assert_print>
  411de8:	aa1303e1 	mov	x1, x19
  411dec:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411df0:	913adc00 	add	x0, x0, #0xeb7
  411df4:	97ffd7c6 	bl	407d0c <assert_print>
  411df8:	52801861 	mov	w1, #0xc3                  	// #195
  411dfc:	aa1403e0 	mov	x0, x20
  411e00:	97ffd7ed 	bl	407db4 <assert_post_action>
  411e04:	aa1403e1 	mov	x1, x20
  411e08:	52801862 	mov	w2, #0xc3                  	// #195
  411e0c:	17ffffdd 	b	411d80 <z_unpend_first_thread+0x7c>
	posix_irq_unlock(key);
  411e10:	2a1503e0 	mov	w0, w21
  411e14:	97ffe0c6 	bl	40a12c <posix_irq_unlock>
}
  411e18:	aa1403e0 	mov	x0, x20
  411e1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411e20:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411e24:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411e28:	d65f03c0 	ret

0000000000411e2c <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
  411e2c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411e30:	910003fd 	mov	x29, sp
  411e34:	a90153f3 	stp	x19, x20, [sp, #16]
  411e38:	aa0003f4 	mov	x20, x0
	int need_sched = 0;
  411e3c:	52800000 	mov	w0, #0x0                   	// #0
	return list->head == list;
  411e40:	f9400293 	ldr	x19, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411e44:	eb13029f 	cmp	x20, x19
  411e48:	54000040 	b.eq	411e50 <z_unpend_all+0x24>  // b.none
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
  411e4c:	b5000093 	cbnz	x19, 411e5c <z_unpend_all+0x30>
		z_ready_thread(thread);
		need_sched = 1;
	}

	return need_sched;
}
  411e50:	a94153f3 	ldp	x19, x20, [sp, #16]
  411e54:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411e58:	d65f03c0 	ret
		z_unpend_thread(thread);
  411e5c:	aa1303e0 	mov	x0, x19
  411e60:	97fffaf4 	bl	410a30 <z_unpend_thread>
		z_ready_thread(thread);
  411e64:	aa1303e0 	mov	x0, x19
  411e68:	97fffc56 	bl	410fc0 <z_ready_thread>
		need_sched = 1;
  411e6c:	52800020 	mov	w0, #0x1                   	// #1
  411e70:	17fffff4 	b	411e40 <z_unpend_all+0x14>

0000000000411e74 <init_ready_q>:
#elif defined(CONFIG_SCHED_MULTIQ)
	for (int i = 0; i < ARRAY_SIZE(_kernel.ready_q.runq.queues); i++) {
		sys_dlist_init(&rq->runq.queues[i]);
	}
#else
	sys_dlist_init(&rq->runq);
  411e74:	91002001 	add	x1, x0, #0x8
	list->tail = (sys_dnode_t *)list;
  411e78:	a9008401 	stp	x1, x1, [x0, #8]
#endif
}
  411e7c:	d65f03c0 	ret

0000000000411e80 <z_sched_init>:
#ifdef CONFIG_SCHED_CPU_MASK_PIN_ONLY
	for (int i = 0; i < CONFIG_MP_MAX_NUM_CPUS; i++) {
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
  411e80:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  411e84:	f9473000 	ldr	x0, [x0, #3680]
  411e88:	9100a000 	add	x0, x0, #0x28
  411e8c:	17fffffa 	b	411e74 <init_ready_q>

0000000000411e90 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
  411e90:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  411e94:	d00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  411e98:	910003fd 	mov	x29, sp
  411e9c:	a9025bf5 	stp	x21, x22, [sp, #32]
  411ea0:	f9473035 	ldr	x21, [x1, #3680]
  411ea4:	a90153f3 	stp	x19, x20, [sp, #16]
  411ea8:	a90363f7 	stp	x23, x24, [sp, #48]
  411eac:	f90023f9 	str	x25, [sp, #64]
	__ASSERT(!arch_is_in_isr(), "");
  411eb0:	b94002a0 	ldr	w0, [x21]
  411eb4:	340002a0 	cbz	w0, 411f08 <z_impl_k_yield+0x78>
  411eb8:	b0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  411ebc:	91189a73 	add	x19, x19, #0x626
  411ec0:	aa1303e2 	mov	x2, x19
  411ec4:	b0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  411ec8:	910e6021 	add	x1, x1, #0x398
  411ecc:	5280ae23 	mov	w3, #0x571                 	// #1393
  411ed0:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411ed4:	9123f800 	add	x0, x0, #0x8fe
  411ed8:	97ffd78d 	bl	407d0c <assert_print>
  411edc:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411ee0:	913b7400 	add	x0, x0, #0xedd
  411ee4:	97ffd78a 	bl	407d0c <assert_print>
  411ee8:	aa1303e0 	mov	x0, x19
  411eec:	5280ae21 	mov	w1, #0x571                 	// #1393
  411ef0:	97ffd7b1 	bl	407db4 <assert_post_action>
  411ef4:	5280ae22 	mov	w2, #0x571                 	// #1393
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411ef8:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411efc:	aa1303e1 	mov	x1, x19
  411f00:	9124f000 	add	x0, x0, #0x93c
  411f04:	97ffe19e 	bl	40a57c <posix_print_error_and_exit>
  411f08:	d00000d7 	adrp	x23, 42b000 <__FRAME_END__+0xfd74>
  411f0c:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  411f10:	97ffe085 	bl	40a124 <posix_irq_lock>
  411f14:	2a0003f8 	mov	w24, w0
  411f18:	f947caf9 	ldr	x25, [x23, #3984]
  411f1c:	aa1903e0 	mov	x0, x25
  411f20:	97fff228 	bl	40e7c0 <z_spin_lock_valid>
  411f24:	72001c1f 	tst	w0, #0xff
  411f28:	54000261 	b.ne	411f74 <z_impl_k_yield+0xe4>  // b.any
  411f2c:	90000033 	adrp	x19, 415000 <random_data+0xb30>
  411f30:	91391a73 	add	x19, x19, #0xe46
  411f34:	aa1303e2 	mov	x2, x19
  411f38:	52801283 	mov	w3, #0x94                  	// #148
  411f3c:	90000021 	adrp	x1, 415000 <random_data+0xb30>
  411f40:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411f44:	9139cc21 	add	x1, x1, #0xe73
  411f48:	9123f800 	add	x0, x0, #0x8fe
  411f4c:	97ffd770 	bl	407d0c <assert_print>
  411f50:	aa1903e1 	mov	x1, x25
  411f54:	90000020 	adrp	x0, 415000 <random_data+0xb30>
  411f58:	913a2000 	add	x0, x0, #0xe88
  411f5c:	97ffd76c 	bl	407d0c <assert_print>
  411f60:	aa1303e0 	mov	x0, x19
  411f64:	52801281 	mov	w1, #0x94                  	// #148
  411f68:	97ffd793 	bl	407db4 <assert_post_action>
  411f6c:	52801282 	mov	w2, #0x94                  	// #148
  411f70:	17ffffe2 	b	411ef8 <z_impl_k_yield+0x68>
	z_spin_lock_set_owner(l);
  411f74:	aa1903e0 	mov	x0, x25
  411f78:	97fff22a 	bl	40e820 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
  411f7c:	f9400aa1 	ldr	x1, [x21, #16]
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411f80:	39406420 	ldrb	w0, [x1, #25]
  411f84:	12001800 	and	w0, w0, #0x7f
  411f88:	39006420 	strb	w0, [x1, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411f8c:	9100c2a0 	add	x0, x21, #0x30
  411f90:	97fffa6b 	bl	41093c <z_priq_dumb_remove>
	}
	queue_thread(_current);
  411f94:	f9400ab3 	ldr	x19, [x21, #16]
	thread->base.thread_state |= _THREAD_QUEUED;
  411f98:	39406660 	ldrb	w0, [x19, #25]
  411f9c:	32196000 	orr	w0, w0, #0xffffff80
  411fa0:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411fa4:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  411fa8:	f9470000 	ldr	x0, [x0, #3584]
  411fac:	eb00027f 	cmp	x19, x0
  411fb0:	540001e1 	b.ne	411fec <z_impl_k_yield+0x15c>  // b.any
  411fb4:	b0000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  411fb8:	91189a73 	add	x19, x19, #0x626
  411fbc:	aa1303e2 	mov	x2, x19
  411fc0:	52801783 	mov	w3, #0xbc                  	// #188
  411fc4:	b0000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  411fc8:	f0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  411fcc:	9120f421 	add	x1, x1, #0x83d
  411fd0:	9123f800 	add	x0, x0, #0x8fe
  411fd4:	97ffd74e 	bl	407d0c <assert_print>
  411fd8:	aa1303e0 	mov	x0, x19
  411fdc:	52801781 	mov	w1, #0xbc                  	// #188
  411fe0:	97ffd775 	bl	407db4 <assert_post_action>
  411fe4:	52801782 	mov	w2, #0xbc                  	// #188
  411fe8:	17ffffc4 	b	411ef8 <z_impl_k_yield+0x68>
	return list->head == list;
  411fec:	aa1503e0 	mov	x0, x21
  411ff0:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411ff4:	eb00029f 	cmp	x20, x0
  411ff8:	54000481 	b.ne	412088 <z_impl_k_yield+0x1f8>  // b.any
	sys_dnode_t *const tail = list->tail;
  411ffc:	f94732c1 	ldr	x1, [x22, #3680]
	node->next = list;
  412000:	9100c022 	add	x2, x1, #0x30
	sys_dnode_t *const tail = list->tail;
  412004:	f9401c20 	ldr	x0, [x1, #56]
	node->prev = tail;
  412008:	a9000262 	stp	x2, x0, [x19]
	tail->next = node;
  41200c:	f9000013 	str	x19, [x0]
	list->tail = node;
  412010:	f9001c33 	str	x19, [x1, #56]
	update_cache(1);
  412014:	52800020 	mov	w0, #0x1                   	// #1
  412018:	97fffad1 	bl	410b5c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41201c:	f947caf7 	ldr	x23, [x23, #3984]
  412020:	aa1703e0 	mov	x0, x23
  412024:	97fff1f2 	bl	40e7ec <z_spin_unlock_valid>
  412028:	72001c1f 	tst	w0, #0xff
  41202c:	54000441 	b.ne	4120b4 <z_impl_k_yield+0x224>  // b.any
  412030:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412034:	91391a73 	add	x19, x19, #0xe46
  412038:	aa1303e2 	mov	x2, x19
  41203c:	52801c43 	mov	w3, #0xe2                  	// #226
  412040:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412044:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412048:	913a8021 	add	x1, x1, #0xea0
  41204c:	9123f800 	add	x0, x0, #0x8fe
  412050:	97ffd72f 	bl	407d0c <assert_print>
  412054:	aa1703e1 	mov	x1, x23
  412058:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  41205c:	913adc00 	add	x0, x0, #0xeb7
  412060:	97ffd72b 	bl	407d0c <assert_print>
  412064:	aa1303e0 	mov	x0, x19
  412068:	52801c41 	mov	w1, #0xe2                  	// #226
  41206c:	97ffd752 	bl	407db4 <assert_post_action>
  412070:	52801c42 	mov	w2, #0xe2                  	// #226
  412074:	17ffffa1 	b	411ef8 <z_impl_k_yield+0x68>
	return (node == list->tail) ? NULL : node->next;
  412078:	f9401ea0 	ldr	x0, [x21, #56]
  41207c:	eb14001f 	cmp	x0, x20
  412080:	54fffbe0 	b.eq	411ffc <z_impl_k_yield+0x16c>  // b.none
  412084:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  412088:	b4fffbb4 	cbz	x20, 411ffc <z_impl_k_yield+0x16c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  41208c:	aa1403e1 	mov	x1, x20
  412090:	aa1303e0 	mov	x0, x19
  412094:	97fff901 	bl	410498 <z_sched_prio_cmp>
  412098:	7100001f 	cmp	w0, #0x0
  41209c:	54fffeed 	b.le	412078 <z_impl_k_yield+0x1e8>
	sys_dnode_t *const prev = successor->prev;
  4120a0:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  4120a4:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  4120a8:	f9000013 	str	x19, [x0]
	successor->prev = node;
  4120ac:	f9000693 	str	x19, [x20, #8]
}
  4120b0:	17ffffd9 	b	412014 <z_impl_k_yield+0x184>
  4120b4:	2a1803e0 	mov	w0, w24
	z_swap(&sched_spinlock, key);
}
  4120b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4120bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4120c0:	a94363f7 	ldp	x23, x24, [sp, #48]
  4120c4:	f94023f9 	ldr	x25, [sp, #64]
  4120c8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4120cc:	17ffdcec 	b	40947c <arch_swap>

00000000004120d0 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
  4120d0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4120d4:	910003fd 	mov	x29, sp
  4120d8:	a90153f3 	stp	x19, x20, [sp, #16]
  4120dc:	b00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  4120e0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4120e4:	aa0003f6 	mov	x22, x0
  4120e8:	f9473280 	ldr	x0, [x20, #3680]
  4120ec:	f9001bf7 	str	x23, [sp, #48]
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
  4120f0:	b9400000 	ldr	w0, [x0]
  4120f4:	340002a0 	cbz	w0, 412148 <z_tick_sleep+0x78>
  4120f8:	90000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  4120fc:	91189a73 	add	x19, x19, #0x626
  412100:	aa1303e2 	mov	x2, x19
  412104:	90000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  412108:	910e6021 	add	x1, x1, #0x398
  41210c:	5280b1a3 	mov	w3, #0x58d                 	// #1421
  412110:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412114:	9123f800 	add	x0, x0, #0x8fe
  412118:	97ffd6fd 	bl	407d0c <assert_print>
  41211c:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412120:	913b7400 	add	x0, x0, #0xedd
  412124:	97ffd6fa 	bl	407d0c <assert_print>
  412128:	aa1303e0 	mov	x0, x19
  41212c:	5280b1a1 	mov	w1, #0x58d                 	// #1421
  412130:	97ffd721 	bl	407db4 <assert_post_action>
  412134:	5280b1a2 	mov	w2, #0x58d                 	// #1421
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412138:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41213c:	aa1303e1 	mov	x1, x19
  412140:	9124f000 	add	x0, x0, #0x93c
  412144:	97ffe10e 	bl	40a57c <posix_print_error_and_exit>

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
  412148:	b5000116 	cbnz	x22, 412168 <z_tick_sleep+0x98>
	z_impl_k_yield();
  41214c:	97ffff51 	bl	411e90 <z_impl_k_yield>
		k_yield();
		return 0;
  412150:	52800000 	mov	w0, #0x0                   	// #0
		return ticks;
	}
#endif

	return 0;
}
  412154:	a94153f3 	ldp	x19, x20, [sp, #16]
  412158:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41215c:	f9401bf7 	ldr	x23, [sp, #48]
  412160:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412164:	d65f03c0 	ret
	if (Z_TICK_ABS(ticks) <= 0) {
  412168:	b1000adf 	cmn	x22, #0x2
  41216c:	540003ab 	b.lt	4121e0 <z_tick_sleep+0x110>  // b.tstop
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
  412170:	940003fe 	bl	413168 <sys_clock_tick_get_32>
  412174:	0b160013 	add	w19, w0, w22
  412178:	b00000d5 	adrp	x21, 42b000 <__FRAME_END__+0xfd74>
  41217c:	97ffdfea 	bl	40a124 <posix_irq_lock>
  412180:	2a0003f7 	mov	w23, w0
  412184:	f947cab5 	ldr	x21, [x21, #3984]
  412188:	aa1503e0 	mov	x0, x21
  41218c:	97fff18d 	bl	40e7c0 <z_spin_lock_valid>
  412190:	72001c1f 	tst	w0, #0xff
  412194:	540002c1 	b.ne	4121ec <z_tick_sleep+0x11c>  // b.any
  412198:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  41219c:	91391a73 	add	x19, x19, #0xe46
  4121a0:	aa1303e2 	mov	x2, x19
  4121a4:	52801283 	mov	w3, #0x94                  	// #148
  4121a8:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  4121ac:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4121b0:	9139cc21 	add	x1, x1, #0xe73
  4121b4:	9123f800 	add	x0, x0, #0x8fe
  4121b8:	97ffd6d5 	bl	407d0c <assert_print>
  4121bc:	aa1503e1 	mov	x1, x21
  4121c0:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  4121c4:	913a2000 	add	x0, x0, #0xe88
  4121c8:	97ffd6d1 	bl	407d0c <assert_print>
  4121cc:	aa1303e0 	mov	x0, x19
  4121d0:	52801281 	mov	w1, #0x94                  	// #148
  4121d4:	97ffd6f8 	bl	407db4 <assert_post_action>
  4121d8:	52801282 	mov	w2, #0x94                  	// #148
  4121dc:	17ffffd7 	b	412138 <z_tick_sleep+0x68>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
  4121e0:	12800033 	mov	w19, #0xfffffffe            	// #-2
  4121e4:	4b160273 	sub	w19, w19, w22
  4121e8:	17ffffe4 	b	412178 <z_tick_sleep+0xa8>
	z_spin_lock_set_owner(l);
  4121ec:	aa1503e0 	mov	x0, x21
  4121f0:	97fff18c 	bl	40e820 <z_spin_lock_set_owner>
	unready_thread(_current);
  4121f4:	f9473294 	ldr	x20, [x20, #3680]
  4121f8:	f9400a80 	ldr	x0, [x20, #16]
  4121fc:	97fffc58 	bl	41135c <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  412200:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  412204:	aa1603e2 	mov	x2, x22
	z_add_thread_timeout(_current, timeout);
  412208:	f9400a80 	ldr	x0, [x20, #16]
  41220c:	f9472821 	ldr	x1, [x1, #3664]
  412210:	9100a000 	add	x0, x0, #0x28
  412214:	94000239 	bl	412af8 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
  412218:	f9400a82 	ldr	x2, [x20, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41221c:	aa1503e0 	mov	x0, x21
  412220:	39406441 	ldrb	w1, [x2, #25]
  412224:	321c0021 	orr	w1, w1, #0x10
  412228:	39006441 	strb	w1, [x2, #25]
  41222c:	97fff170 	bl	40e7ec <z_spin_unlock_valid>
  412230:	72001c1f 	tst	w0, #0xff
  412234:	54000261 	b.ne	412280 <z_tick_sleep+0x1b0>  // b.any
  412238:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  41223c:	91391a73 	add	x19, x19, #0xe46
  412240:	aa1303e2 	mov	x2, x19
  412244:	52801c43 	mov	w3, #0xe2                  	// #226
  412248:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  41224c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412250:	913a8021 	add	x1, x1, #0xea0
  412254:	9123f800 	add	x0, x0, #0x8fe
  412258:	97ffd6ad 	bl	407d0c <assert_print>
  41225c:	aa1503e1 	mov	x1, x21
  412260:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412264:	913adc00 	add	x0, x0, #0xeb7
  412268:	97ffd6a9 	bl	407d0c <assert_print>
  41226c:	aa1303e0 	mov	x0, x19
  412270:	52801c41 	mov	w1, #0xe2                  	// #226
  412274:	97ffd6d0 	bl	407db4 <assert_post_action>
  412278:	52801c42 	mov	w2, #0xe2                  	// #226
  41227c:	17ffffaf 	b	412138 <z_tick_sleep+0x68>
  412280:	2a1703e0 	mov	w0, w23
  412284:	97ffdc7e 	bl	40947c <arch_swap>
	return (thread->base.thread_state & state) != 0U;
  412288:	f9400a80 	ldr	x0, [x20, #16]
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
  41228c:	39406400 	ldrb	w0, [x0, #25]
  412290:	36200240 	tbz	w0, #4, 4122d8 <z_tick_sleep+0x208>
  412294:	90000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  412298:	91189a73 	add	x19, x19, #0x626
  41229c:	aa1303e2 	mov	x2, x19
  4122a0:	90000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  4122a4:	91241021 	add	x1, x1, #0x904
  4122a8:	5280b523 	mov	w3, #0x5a9                 	// #1449
  4122ac:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4122b0:	9123f800 	add	x0, x0, #0x8fe
  4122b4:	97ffd696 	bl	407d0c <assert_print>
  4122b8:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  4122bc:	913b7400 	add	x0, x0, #0xedd
  4122c0:	97ffd693 	bl	407d0c <assert_print>
  4122c4:	aa1303e0 	mov	x0, x19
  4122c8:	5280b521 	mov	w1, #0x5a9                 	// #1449
  4122cc:	97ffd6ba 	bl	407db4 <assert_post_action>
  4122d0:	5280b522 	mov	w2, #0x5a9                 	// #1449
  4122d4:	17ffff99 	b	412138 <z_tick_sleep+0x68>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
  4122d8:	940003a4 	bl	413168 <sys_clock_tick_get_32>
  4122dc:	cb204260 	sub	x0, x19, w0, uxtw
		return ticks;
  4122e0:	f100001f 	cmp	x0, #0x0
  4122e4:	1a9fc000 	csel	w0, w0, wzr, gt
  4122e8:	17ffff9b 	b	412154 <z_tick_sleep+0x84>

00000000004122ec <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
  4122ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4122f0:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  4122f4:	910003fd 	mov	x29, sp
  4122f8:	f9473021 	ldr	x1, [x1, #3680]
  4122fc:	f9000bf3 	str	x19, [sp, #16]
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
  412300:	b9400022 	ldr	w2, [x1]
  412304:	340002a2 	cbz	w2, 412358 <z_impl_k_sleep+0x6c>
  412308:	90000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  41230c:	91189a73 	add	x19, x19, #0x626
  412310:	aa1303e2 	mov	x2, x19
  412314:	90000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  412318:	910e6021 	add	x1, x1, #0x398
  41231c:	5280b703 	mov	w3, #0x5b8                 	// #1464
  412320:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412324:	9123f800 	add	x0, x0, #0x8fe
  412328:	97ffd679 	bl	407d0c <assert_print>
  41232c:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412330:	913b7400 	add	x0, x0, #0xedd
  412334:	97ffd676 	bl	407d0c <assert_print>
  412338:	aa1303e0 	mov	x0, x19
  41233c:	5280b701 	mov	w1, #0x5b8                 	// #1464
  412340:	97ffd69d 	bl	407db4 <assert_post_action>
  412344:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412348:	aa1303e1 	mov	x1, x19
  41234c:	9124f000 	add	x0, x0, #0x93c
  412350:	5280b702 	mov	w2, #0x5b8                 	// #1464
  412354:	97ffe08a 	bl	40a57c <posix_print_error_and_exit>
  412358:	aa0003f3 	mov	x19, x0

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  41235c:	b100041f 	cmn	x0, #0x1
  412360:	540000e1 	b.ne	41237c <z_impl_k_sleep+0x90>  // b.any
		k_thread_suspend(_current);
  412364:	f9400820 	ldr	x0, [x1, #16]
	z_impl_k_thread_suspend(thread);
  412368:	97fffd58 	bl	4118c8 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
  41236c:	2a1303e0 	mov	w0, w19
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
  412370:	f9400bf3 	ldr	x19, [sp, #16]
  412374:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412378:	d65f03c0 	ret
	ticks = z_tick_sleep(ticks);
  41237c:	97ffff55 	bl	4120d0 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
  412380:	52800141 	mov	w1, #0xa                   	// #10
  412384:	1b017c00 	mul	w0, w0, w1
	return ret;
  412388:	17fffffa 	b	412370 <z_impl_k_sleep+0x84>

000000000041238c <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
  41238c:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  412390:	f9473000 	ldr	x0, [x0, #3680]
  412394:	f9400800 	ldr	x0, [x0, #16]
  412398:	d65f03c0 	ret

000000000041239c <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
  41239c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4123a0:	910003fd 	mov	x29, sp
  4123a4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4123a8:	b00000d4 	adrp	x20, 42b000 <__FRAME_END__+0xfd74>
  4123ac:	aa0003f3 	mov	x19, x0
  4123b0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4123b4:	f9001bf7 	str	x23, [sp, #48]
  4123b8:	97ffdf5b 	bl	40a124 <posix_irq_lock>
  4123bc:	f947ca96 	ldr	x22, [x20, #3984]
  4123c0:	2a0003f5 	mov	w21, w0
  4123c4:	aa1603e0 	mov	x0, x22
  4123c8:	97fff0fe 	bl	40e7c0 <z_spin_lock_valid>
  4123cc:	72001c1f 	tst	w0, #0xff
  4123d0:	540002c1 	b.ne	412428 <z_thread_abort+0x8c>  // b.any
  4123d4:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  4123d8:	91391a73 	add	x19, x19, #0xe46
  4123dc:	aa1303e2 	mov	x2, x19
  4123e0:	52801283 	mov	w3, #0x94                  	// #148
  4123e4:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  4123e8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4123ec:	9139cc21 	add	x1, x1, #0xe73
  4123f0:	9123f800 	add	x0, x0, #0x8fe
  4123f4:	97ffd646 	bl	407d0c <assert_print>
  4123f8:	aa1603e1 	mov	x1, x22
  4123fc:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412400:	913a2000 	add	x0, x0, #0xe88
  412404:	97ffd642 	bl	407d0c <assert_print>
  412408:	aa1303e0 	mov	x0, x19
  41240c:	52801281 	mov	w1, #0x94                  	// #148
  412410:	97ffd669 	bl	407db4 <assert_post_action>
  412414:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412418:	aa1303e1 	mov	x1, x19
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
  41241c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412420:	9124f000 	add	x0, x0, #0x93c
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
  412424:	97ffe056 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412428:	aa1603e0 	mov	x0, x22
  41242c:	97fff0fd 	bl	40e820 <z_spin_lock_set_owner>
	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
  412430:	39406260 	ldrb	w0, [x19, #24]
  412434:	36000580 	tbz	w0, #0, 4124e4 <z_thread_abort+0x148>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412438:	aa1603e0 	mov	x0, x22
  41243c:	97fff0ec 	bl	40e7ec <z_spin_unlock_valid>
  412440:	72001c1f 	tst	w0, #0xff
  412444:	54000261 	b.ne	412490 <z_thread_abort+0xf4>  // b.any
  412448:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  41244c:	91391a73 	add	x19, x19, #0xe46
  412450:	aa1303e2 	mov	x2, x19
  412454:	52801863 	mov	w3, #0xc3                  	// #195
  412458:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  41245c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412460:	913a8021 	add	x1, x1, #0xea0
  412464:	9123f800 	add	x0, x0, #0x8fe
  412468:	97ffd629 	bl	407d0c <assert_print>
  41246c:	f947ca81 	ldr	x1, [x20, #3984]
  412470:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412474:	913adc00 	add	x0, x0, #0xeb7
  412478:	97ffd625 	bl	407d0c <assert_print>
  41247c:	aa1303e0 	mov	x0, x19
  412480:	52801861 	mov	w1, #0xc3                  	// #195
  412484:	97ffd64c 	bl	407db4 <assert_post_action>
  412488:	52801862 	mov	w2, #0xc3                  	// #195
  41248c:	17ffffe3 	b	412418 <z_thread_abort+0x7c>
	posix_irq_unlock(key);
  412490:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborting essential thread %p", thread);
  412494:	90000034 	adrp	x20, 416000 <__func__.0+0x9cb>
  412498:	97ffdf25 	bl	40a12c <posix_irq_unlock>
  41249c:	91189a94 	add	x20, x20, #0x626
  4124a0:	aa1403e2 	mov	x2, x20
  4124a4:	5280d9c3 	mov	w3, #0x6ce                 	// #1742
  4124a8:	90000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  4124ac:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4124b0:	9128c821 	add	x1, x1, #0xa32
  4124b4:	9123f800 	add	x0, x0, #0x8fe
  4124b8:	97ffd615 	bl	407d0c <assert_print>
  4124bc:	aa1303e1 	mov	x1, x19
  4124c0:	90000020 	adrp	x0, 416000 <__func__.0+0x9cb>
  4124c4:	91251000 	add	x0, x0, #0x944
  4124c8:	97ffd611 	bl	407d0c <assert_print>
  4124cc:	5280d9c1 	mov	w1, #0x6ce                 	// #1742
  4124d0:	aa1403e0 	mov	x0, x20
  4124d4:	97ffd638 	bl	407db4 <assert_post_action>
  4124d8:	aa1403e1 	mov	x1, x20
  4124dc:	5280d9c2 	mov	w2, #0x6ce                 	// #1742
  4124e0:	17ffffcf 	b	41241c <z_thread_abort+0x80>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  4124e4:	39406661 	ldrb	w1, [x19, #25]
  4124e8:	36180161 	tbz	w1, #3, 412514 <z_thread_abort+0x178>
  4124ec:	aa1603e0 	mov	x0, x22
  4124f0:	97fff0bf 	bl	40e7ec <z_spin_unlock_valid>
  4124f4:	72001c1f 	tst	w0, #0xff
  4124f8:	54fffa80 	b.eq	412448 <z_thread_abort+0xac>  // b.none
  4124fc:	2a1503e0 	mov	w0, w21
	}
	k_spin_unlock(&sched_spinlock, key);
}
  412500:	a94153f3 	ldp	x19, x20, [sp, #16]
  412504:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412508:	f9401bf7 	ldr	x23, [sp, #48]
  41250c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412510:	17ffdf07 	b	40a12c <posix_irq_unlock>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  412514:	121a7820 	and	w0, w1, #0xffffffdf
  412518:	321d0002 	orr	w2, w0, #0x8
		if (z_is_thread_queued(thread)) {
  41251c:	37380600 	tbnz	w0, #7, 4125dc <z_thread_abort+0x240>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  412520:	39006662 	strb	w2, [x19, #25]
		if (thread->base.pended_on != NULL) {
  412524:	f9400a60 	ldr	x0, [x19, #16]
  412528:	b4000060 	cbz	x0, 412534 <z_thread_abort+0x198>
			unpend_thread_no_timeout(thread);
  41252c:	aa1303e0 	mov	x0, x19
  412530:	97fff920 	bl	4109b0 <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  412534:	91018277 	add	x23, x19, #0x60
	return z_abort_timeout(&thread->base.timeout);
  412538:	9100a260 	add	x0, x19, #0x28
  41253c:	94000201 	bl	412d40 <z_abort_timeout>
	return list->head == list;
  412540:	f9403276 	ldr	x22, [x19, #96]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412544:	eb1702df 	cmp	x22, x23
  412548:	54000040 	b.eq	412550 <z_thread_abort+0x1b4>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  41254c:	b50005d6 	cbnz	x22, 412604 <z_thread_abort+0x268>
		update_cache(1);
  412550:	52800020 	mov	w0, #0x1                   	// #1
  412554:	97fff982 	bl	410b5c <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
  412558:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  41255c:	f9473000 	ldr	x0, [x0, #3680]
  412560:	f9400801 	ldr	x1, [x0, #16]
  412564:	eb13003f 	cmp	x1, x19
  412568:	54000821 	b.ne	41266c <z_thread_abort+0x2d0>  // b.any
  41256c:	b9400000 	ldr	w0, [x0]
  412570:	350007e0 	cbnz	w0, 41266c <z_thread_abort+0x2d0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412574:	f947ca94 	ldr	x20, [x20, #3984]
  412578:	d0000017 	adrp	x23, 414000 <dlc_table.0+0x60d>
  41257c:	d0000016 	adrp	x22, 414000 <dlc_table.0+0x60d>
  412580:	aa1403e0 	mov	x0, x20
  412584:	97fff09a 	bl	40e7ec <z_spin_unlock_valid>
  412588:	72001c1f 	tst	w0, #0xff
  41258c:	540004c1 	b.ne	412624 <z_thread_abort+0x288>  // b.any
  412590:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412594:	91391a73 	add	x19, x19, #0xe46
  412598:	aa1303e2 	mov	x2, x19
  41259c:	52801c43 	mov	w3, #0xe2                  	// #226
  4125a0:	9123fae0 	add	x0, x23, #0x8fe
  4125a4:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  4125a8:	913a8021 	add	x1, x1, #0xea0
  4125ac:	97ffd5d8 	bl	407d0c <assert_print>
  4125b0:	aa1403e1 	mov	x1, x20
  4125b4:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  4125b8:	913adc00 	add	x0, x0, #0xeb7
  4125bc:	97ffd5d4 	bl	407d0c <assert_print>
  4125c0:	aa1303e0 	mov	x0, x19
  4125c4:	52801c41 	mov	w1, #0xe2                  	// #226
  4125c8:	97ffd5fb 	bl	407db4 <assert_post_action>
  4125cc:	52801c42 	mov	w2, #0xe2                  	// #226
		__ASSERT(false, "aborted _current back from dead");
  4125d0:	aa1303e1 	mov	x1, x19
  4125d4:	9124f2c0 	add	x0, x22, #0x93c
  4125d8:	17ffff93 	b	412424 <z_thread_abort+0x88>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4125dc:	52800be0 	mov	w0, #0x5f                  	// #95
  4125e0:	0a000021 	and	w1, w1, w0
	_priq_run_remove(thread_runq(thread), thread);
  4125e4:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4125e8:	321d0021 	orr	w1, w1, #0x8
  4125ec:	39006661 	strb	w1, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4125f0:	aa1303e1 	mov	x1, x19
  4125f4:	f9473000 	ldr	x0, [x0, #3680]
  4125f8:	9100c000 	add	x0, x0, #0x30
  4125fc:	97fff8d0 	bl	41093c <z_priq_dumb_remove>
}
  412600:	17ffffc9 	b	412524 <z_thread_abort+0x188>
		unpend_thread_no_timeout(thread);
  412604:	aa1603e0 	mov	x0, x22
  412608:	97fff8ea 	bl	4109b0 <unpend_thread_no_timeout>
  41260c:	9100a2c0 	add	x0, x22, #0x28
  412610:	940001cc 	bl	412d40 <z_abort_timeout>
	thread->callee_saved.retval = value;
  412614:	b9004edf 	str	wzr, [x22, #76]
		ready_thread(thread);
  412618:	aa1603e0 	mov	x0, x22
  41261c:	97fffa21 	bl	410ea0 <ready_thread>
  412620:	17ffffc8 	b	412540 <z_thread_abort+0x1a4>
  412624:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborted _current back from dead");
  412628:	90000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  41262c:	97ffdb94 	bl	40947c <arch_swap>
  412630:	91189a73 	add	x19, x19, #0x626
  412634:	aa1303e2 	mov	x2, x19
  412638:	90000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  41263c:	9128c821 	add	x1, x1, #0xa32
  412640:	5280e083 	mov	w3, #0x704                 	// #1796
  412644:	9123fae0 	add	x0, x23, #0x8fe
  412648:	97ffd5b1 	bl	407d0c <assert_print>
  41264c:	90000020 	adrp	x0, 416000 <__func__.0+0x9cb>
  412650:	91258c00 	add	x0, x0, #0x963
  412654:	97ffd5ae 	bl	407d0c <assert_print>
  412658:	aa1303e0 	mov	x0, x19
  41265c:	5280e081 	mov	w1, #0x704                 	// #1796
  412660:	97ffd5d5 	bl	407db4 <assert_post_action>
  412664:	5280e082 	mov	w2, #0x704                 	// #1796
  412668:	17ffffda 	b	4125d0 <z_thread_abort+0x234>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41266c:	f947ca80 	ldr	x0, [x20, #3984]
  412670:	17ffffa0 	b	4124f0 <z_thread_abort+0x154>

0000000000412674 <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
  412674:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412678:	910003fd 	mov	x29, sp
  41267c:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412680:	b00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  412684:	aa0003f4 	mov	x20, x0
  412688:	a9025bf5 	stp	x21, x22, [sp, #32]
  41268c:	aa0103f5 	mov	x21, x1
  412690:	f9001bf7 	str	x23, [sp, #48]
	return posix_irq_lock();
  412694:	97ffdea4 	bl	40a124 <posix_irq_lock>
  412698:	f947ca76 	ldr	x22, [x19, #3984]
  41269c:	2a0003f7 	mov	w23, w0
  4126a0:	aa1603e0 	mov	x0, x22
  4126a4:	97fff047 	bl	40e7c0 <z_spin_lock_valid>
  4126a8:	72001c1f 	tst	w0, #0xff
  4126ac:	540002c1 	b.ne	412704 <z_impl_k_thread_join+0x90>  // b.any
  4126b0:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  4126b4:	91391a73 	add	x19, x19, #0xe46
  4126b8:	aa1303e2 	mov	x2, x19
  4126bc:	52801283 	mov	w3, #0x94                  	// #148
  4126c0:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  4126c4:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4126c8:	9139cc21 	add	x1, x1, #0xe73
  4126cc:	9123f800 	add	x0, x0, #0x8fe
  4126d0:	97ffd58f 	bl	407d0c <assert_print>
  4126d4:	aa1603e1 	mov	x1, x22
  4126d8:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  4126dc:	913a2000 	add	x0, x0, #0xe88
  4126e0:	97ffd58b 	bl	407d0c <assert_print>
  4126e4:	aa1303e0 	mov	x0, x19
  4126e8:	52801281 	mov	w1, #0x94                  	// #148
  4126ec:	97ffd5b2 	bl	407db4 <assert_post_action>
  4126f0:	52801282 	mov	w2, #0x94                  	// #148
		ret = -EBUSY;
	} else if ((thread == _current) ||
		   (thread->base.pended_on == &_current->join_queue)) {
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  4126f4:	aa1303e1 	mov	x1, x19
  4126f8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4126fc:	9124f000 	add	x0, x0, #0x93c
  412700:	97ffdf9f 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412704:	aa1603e0 	mov	x0, x22
  412708:	97fff046 	bl	40e820 <z_spin_lock_set_owner>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  41270c:	39406680 	ldrb	w0, [x20, #25]
  412710:	371808c0 	tbnz	w0, #3, 412828 <z_impl_k_thread_join+0x1b4>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  412714:	b4000bb5 	cbz	x21, 412888 <z_impl_k_thread_join+0x214>
	} else if ((thread == _current) ||
  412718:	b00000d6 	adrp	x22, 42b000 <__FRAME_END__+0xfd74>
  41271c:	f94732d6 	ldr	x22, [x22, #3680]
  412720:	f9400ac0 	ldr	x0, [x22, #16]
  412724:	eb14001f 	cmp	x0, x20
  412728:	54000b40 	b.eq	412890 <z_impl_k_thread_join+0x21c>  // b.none
  41272c:	f9400a82 	ldr	x2, [x20, #16]
		   (thread->base.pended_on == &_current->join_queue)) {
  412730:	91018001 	add	x1, x0, #0x60
	} else if ((thread == _current) ||
  412734:	eb01005f 	cmp	x2, x1
  412738:	54000ac0 	b.eq	412890 <z_impl_k_thread_join+0x21c>  // b.none
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  41273c:	b94002c1 	ldr	w1, [x22]
  412740:	34000241 	cbz	w1, 412788 <z_impl_k_thread_join+0x114>
  412744:	90000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  412748:	91189a73 	add	x19, x19, #0x626
  41274c:	aa1303e2 	mov	x2, x19
  412750:	90000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  412754:	910e6021 	add	x1, x1, #0x398
  412758:	5280e483 	mov	w3, #0x724                 	// #1828
  41275c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412760:	9123f800 	add	x0, x0, #0x8fe
  412764:	97ffd56a 	bl	407d0c <assert_print>
  412768:	90000020 	adrp	x0, 416000 <__func__.0+0x9cb>
  41276c:	91261400 	add	x0, x0, #0x985
  412770:	97ffd567 	bl	407d0c <assert_print>
  412774:	aa1303e0 	mov	x0, x19
  412778:	5280e481 	mov	w1, #0x724                 	// #1828
  41277c:	97ffd58e 	bl	407db4 <assert_post_action>
  412780:	5280e482 	mov	w2, #0x724                 	// #1828
  412784:	17ffffdc 	b	4126f4 <z_impl_k_thread_join+0x80>
		add_to_waitq_locked(_current, &thread->join_queue);
  412788:	91018281 	add	x1, x20, #0x60
  41278c:	97fffb09 	bl	4113b0 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  412790:	b10006bf 	cmn	x21, #0x1
  412794:	540000e0 	b.eq	4127b0 <z_impl_k_thread_join+0x13c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  412798:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  41279c:	aa1503e2 	mov	x2, x21
		add_thread_timeout(_current, timeout);
  4127a0:	f9400ac0 	ldr	x0, [x22, #16]
  4127a4:	f9472821 	ldr	x1, [x1, #3664]
  4127a8:	9100a000 	add	x0, x0, #0x28
  4127ac:	940000d3 	bl	412af8 <z_add_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4127b0:	f947ca73 	ldr	x19, [x19, #3984]
  4127b4:	aa1303e0 	mov	x0, x19
  4127b8:	97fff00d 	bl	40e7ec <z_spin_unlock_valid>
  4127bc:	72001c1f 	tst	w0, #0xff
  4127c0:	54000281 	b.ne	412810 <z_impl_k_thread_join+0x19c>  // b.any
  4127c4:	f0000014 	adrp	x20, 415000 <random_data+0xb30>
  4127c8:	91391a94 	add	x20, x20, #0xe46
  4127cc:	aa1403e2 	mov	x2, x20
  4127d0:	52801c43 	mov	w3, #0xe2                  	// #226
  4127d4:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  4127d8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4127dc:	913a8021 	add	x1, x1, #0xea0
  4127e0:	9123f800 	add	x0, x0, #0x8fe
  4127e4:	97ffd54a 	bl	407d0c <assert_print>
  4127e8:	aa1303e1 	mov	x1, x19
  4127ec:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  4127f0:	913adc00 	add	x0, x0, #0xeb7
  4127f4:	97ffd546 	bl	407d0c <assert_print>
  4127f8:	aa1403e0 	mov	x0, x20
  4127fc:	52801c41 	mov	w1, #0xe2                  	// #226
  412800:	97ffd56d 	bl	407db4 <assert_post_action>
  412804:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412808:	aa1403e1 	mov	x1, x20
  41280c:	17ffffbb 	b	4126f8 <z_impl_k_thread_join+0x84>
  412810:	2a1703e0 	mov	w0, w23

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
  412814:	a94153f3 	ldp	x19, x20, [sp, #16]
  412818:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41281c:	f9401bf7 	ldr	x23, [sp, #48]
  412820:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412824:	17ffdb16 	b	40947c <arch_swap>
		ret = 0;
  412828:	52800014 	mov	w20, #0x0                   	// #0
  41282c:	f947ca73 	ldr	x19, [x19, #3984]
  412830:	aa1303e0 	mov	x0, x19
  412834:	97ffefee 	bl	40e7ec <z_spin_unlock_valid>
  412838:	72001c1f 	tst	w0, #0xff
  41283c:	540002e1 	b.ne	412898 <z_impl_k_thread_join+0x224>  // b.any
  412840:	f0000014 	adrp	x20, 415000 <random_data+0xb30>
  412844:	91391a94 	add	x20, x20, #0xe46
  412848:	aa1403e2 	mov	x2, x20
  41284c:	52801863 	mov	w3, #0xc3                  	// #195
  412850:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412854:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412858:	913a8021 	add	x1, x1, #0xea0
  41285c:	9123f800 	add	x0, x0, #0x8fe
  412860:	97ffd52b 	bl	407d0c <assert_print>
  412864:	aa1303e1 	mov	x1, x19
  412868:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  41286c:	913adc00 	add	x0, x0, #0xeb7
  412870:	97ffd527 	bl	407d0c <assert_print>
  412874:	aa1403e0 	mov	x0, x20
  412878:	52801861 	mov	w1, #0xc3                  	// #195
  41287c:	97ffd54e 	bl	407db4 <assert_post_action>
  412880:	52801862 	mov	w2, #0xc3                  	// #195
  412884:	17ffffe1 	b	412808 <z_impl_k_thread_join+0x194>
		ret = -EBUSY;
  412888:	128001f4 	mov	w20, #0xfffffff0            	// #-16
  41288c:	17ffffe8 	b	41282c <z_impl_k_thread_join+0x1b8>
		ret = -EDEADLK;
  412890:	12800454 	mov	w20, #0xffffffdd            	// #-35
  412894:	17ffffe6 	b	41282c <z_impl_k_thread_join+0x1b8>
	posix_irq_unlock(key);
  412898:	2a1703e0 	mov	w0, w23
  41289c:	97ffde24 	bl	40a12c <posix_irq_unlock>
}
  4128a0:	2a1403e0 	mov	w0, w20
  4128a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4128a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4128ac:	f9401bf7 	ldr	x23, [sp, #48]
  4128b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4128b4:	d65f03c0 	ret

00000000004128b8 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
  4128b8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4128bc:	910003fd 	mov	x29, sp
  4128c0:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4128c4:	b00000d3 	adrp	x19, 42b000 <__FRAME_END__+0xfd74>
  4128c8:	aa0003f4 	mov	x20, x0
  4128cc:	a9025bf5 	stp	x21, x22, [sp, #32]
  4128d0:	a90363f7 	stp	x23, x24, [sp, #48]
  4128d4:	2a0103f8 	mov	w24, w1
  4128d8:	aa0203f7 	mov	x23, x2
  4128dc:	f90023f9 	str	x25, [sp, #64]
	return posix_irq_lock();
  4128e0:	97ffde11 	bl	40a124 <posix_irq_lock>
  4128e4:	f947ca79 	ldr	x25, [x19, #3984]
  4128e8:	2a0003f6 	mov	w22, w0
  4128ec:	aa1903e0 	mov	x0, x25
  4128f0:	97ffefb4 	bl	40e7c0 <z_spin_lock_valid>
  4128f4:	72001c15 	ands	w21, w0, #0xff
  4128f8:	540002c1 	b.ne	412950 <z_sched_wake+0x98>  // b.any
  4128fc:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412900:	91391a73 	add	x19, x19, #0xe46
  412904:	aa1303e2 	mov	x2, x19
  412908:	52801283 	mov	w3, #0x94                  	// #148
  41290c:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412910:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412914:	9139cc21 	add	x1, x1, #0xe73
  412918:	9123f800 	add	x0, x0, #0x8fe
  41291c:	97ffd4fc 	bl	407d0c <assert_print>
  412920:	aa1903e1 	mov	x1, x25
  412924:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412928:	913a2000 	add	x0, x0, #0xe88
  41292c:	97ffd4f8 	bl	407d0c <assert_print>
  412930:	52801281 	mov	w1, #0x94                  	// #148
  412934:	aa1303e0 	mov	x0, x19
  412938:	97ffd51f 	bl	407db4 <assert_post_action>
  41293c:	aa1303e1 	mov	x1, x19
  412940:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412944:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412948:	9124f000 	add	x0, x0, #0x93c
  41294c:	97ffdf0c 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412950:	aa1903e0 	mov	x0, x25
  412954:	97ffefb3 	bl	40e820 <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
  412958:	aa1403e0 	mov	x0, x20
  41295c:	97fff87c 	bl	410b4c <z_priq_dumb_best>
  412960:	aa0003f4 	mov	x20, x0

		if (thread != NULL) {
  412964:	b4000400 	cbz	x0, 4129e4 <z_sched_wake+0x12c>
	thread->base.swap_data = data;
  412968:	f9001017 	str	x23, [x0, #32]
  41296c:	b9004c18 	str	w24, [x0, #76]
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
  412970:	97fff810 	bl	4109b0 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
  412974:	9100a280 	add	x0, x20, #0x28
  412978:	940000f2 	bl	412d40 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
  41297c:	aa1403e0 	mov	x0, x20
  412980:	97fff948 	bl	410ea0 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412984:	f947ca73 	ldr	x19, [x19, #3984]
  412988:	aa1303e0 	mov	x0, x19
  41298c:	97ffef98 	bl	40e7ec <z_spin_unlock_valid>
  412990:	72001c1f 	tst	w0, #0xff
  412994:	540002c1 	b.ne	4129ec <z_sched_wake+0x134>  // b.any
  412998:	f0000014 	adrp	x20, 415000 <random_data+0xb30>
  41299c:	91391a94 	add	x20, x20, #0xe46
  4129a0:	aa1403e2 	mov	x2, x20
  4129a4:	52801863 	mov	w3, #0xc3                  	// #195
  4129a8:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  4129ac:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4129b0:	913a8021 	add	x1, x1, #0xea0
  4129b4:	9123f800 	add	x0, x0, #0x8fe
  4129b8:	97ffd4d5 	bl	407d0c <assert_print>
  4129bc:	aa1303e1 	mov	x1, x19
  4129c0:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  4129c4:	913adc00 	add	x0, x0, #0xeb7
  4129c8:	97ffd4d1 	bl	407d0c <assert_print>
  4129cc:	52801861 	mov	w1, #0xc3                  	// #195
  4129d0:	aa1403e0 	mov	x0, x20
  4129d4:	97ffd4f8 	bl	407db4 <assert_post_action>
  4129d8:	aa1403e1 	mov	x1, x20
  4129dc:	52801862 	mov	w2, #0xc3                  	// #195
  4129e0:	17ffffd9 	b	412944 <z_sched_wake+0x8c>
	bool ret = false;
  4129e4:	52800015 	mov	w21, #0x0                   	// #0
  4129e8:	17ffffe7 	b	412984 <z_sched_wake+0xcc>
	posix_irq_unlock(key);
  4129ec:	2a1603e0 	mov	w0, w22
  4129f0:	97ffddcf 	bl	40a12c <posix_irq_unlock>
			ret = true;
		}
	}

	return ret;
}
  4129f4:	2a1503e0 	mov	w0, w21
  4129f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4129fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412a00:	a94363f7 	ldp	x23, x24, [sp, #48]
  412a04:	f94023f9 	ldr	x25, [sp, #64]
  412a08:	a8c57bfd 	ldp	x29, x30, [sp], #80
  412a0c:	d65f03c0 	ret

0000000000412a10 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
  412a10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  412a14:	910003fd 	mov	x29, sp
  412a18:	f9000bf3 	str	x19, [sp, #16]
  412a1c:	aa0403f3 	mov	x19, x4
	int ret = z_pend_curr(lock, key, wait_q, timeout);
  412a20:	97fffab1 	bl	4114e4 <z_pend_curr>

	if (data != NULL) {
  412a24:	b40000d3 	cbz	x19, 412a3c <z_sched_wait+0x2c>
		*data = _current->base.swap_data;
  412a28:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  412a2c:	f9473021 	ldr	x1, [x1, #3680]
  412a30:	f9400821 	ldr	x1, [x1, #16]
  412a34:	f9401021 	ldr	x1, [x1, #32]
  412a38:	f9000261 	str	x1, [x19]
	}
	return ret;
}
  412a3c:	f9400bf3 	ldr	x19, [sp, #16]
  412a40:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412a44:	d65f03c0 	ret

0000000000412a48 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
  412a48:	f00000c0 	adrp	x0, 42d000 <counter_period>
  412a4c:	b94bf800 	ldr	w0, [x0, #3064]
  412a50:	35000040 	cbnz	w0, 412a58 <elapsed+0x10>
  412a54:	17ffeaf3 	b	40d620 <sys_clock_elapsed>
}
  412a58:	52800000 	mov	w0, #0x0                   	// #0
  412a5c:	d65f03c0 	ret

0000000000412a60 <next_timeout>:

static int32_t next_timeout(void)
{
  412a60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
  412a64:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
  412a68:	910fa001 	add	x1, x0, #0x3e8
  412a6c:	910003fd 	mov	x29, sp
  412a70:	f9000bf3 	str	x19, [sp, #16]
  412a74:	f941f413 	ldr	x19, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412a78:	eb01027f 	cmp	x19, x1
  412a7c:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
  412a80:	97fffff2 	bl	412a48 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
  412a84:	b4000173 	cbz	x19, 412ab0 <next_timeout+0x50>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
  412a88:	f9400e61 	ldr	x1, [x19, #24]
  412a8c:	cb20c021 	sub	x1, x1, w0, sxtw
	if ((to == NULL) ||
  412a90:	b2407be0 	mov	x0, #0x7fffffff            	// #2147483647
  412a94:	eb00003f 	cmp	x1, x0
  412a98:	5400006c 	b.gt	412aa4 <next_timeout+0x44>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
  412a9c:	f100003f 	cmp	x1, #0x0
  412aa0:	9a9fa020 	csel	x0, x1, xzr, ge  // ge = tcont
	}

	return ret;
}
  412aa4:	f9400bf3 	ldr	x19, [sp, #16]
  412aa8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412aac:	d65f03c0 	ret
		ret = MAX_WAIT;
  412ab0:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
  412ab4:	17fffffc 	b	412aa4 <next_timeout+0x44>

0000000000412ab8 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  412ab8:	b4000160 	cbz	x0, 412ae4 <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
  412abc:	d00000c1 	adrp	x1, 42c000 <__dso_handle>
  412ac0:	f941f821 	ldr	x1, [x1, #1008]
  412ac4:	eb01001f 	cmp	x0, x1
  412ac8:	540000e0 	b.eq	412ae4 <remove_timeout+0x2c>  // b.none
  412acc:	f9400001 	ldr	x1, [x0]
	if (next(t) != NULL) {
  412ad0:	b40000a1 	cbz	x1, 412ae4 <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
  412ad4:	f9400c03 	ldr	x3, [x0, #24]
  412ad8:	f9400c22 	ldr	x2, [x1, #24]
  412adc:	8b030042 	add	x2, x2, x3
  412ae0:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
  412ae4:	a9400801 	ldp	x1, x2, [x0]
	prev->next = next;
  412ae8:	f9000041 	str	x1, [x2]
	next->prev = prev;
  412aec:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
  412af0:	a9007c1f 	stp	xzr, xzr, [x0]
}
  412af4:	d65f03c0 	ret

0000000000412af8 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  412af8:	b100045f 	cmn	x2, #0x1
  412afc:	54001200 	b.eq	412d3c <z_add_timeout+0x244>  // b.none
{
  412b00:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412b04:	910003fd 	mov	x29, sp
  412b08:	a90153f3 	stp	x19, x20, [sp, #16]
  412b0c:	aa0003f3 	mov	x19, x0
  412b10:	a9025bf5 	stp	x21, x22, [sp, #32]
  412b14:	f9001bf7 	str	x23, [sp, #48]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
  412b18:	f9400000 	ldr	x0, [x0]
  412b1c:	b40002a0 	cbz	x0, 412b70 <z_add_timeout+0x78>
  412b20:	90000033 	adrp	x19, 416000 <__func__.0+0x9cb>
  412b24:	91266a73 	add	x19, x19, #0x99a
  412b28:	aa1303e2 	mov	x2, x19
  412b2c:	90000021 	adrp	x1, 416000 <__func__.0+0x9cb>
  412b30:	9126f821 	add	x1, x1, #0x9be
  412b34:	52800bc3 	mov	w3, #0x5e                  	// #94
  412b38:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412b3c:	9123f800 	add	x0, x0, #0x8fe
  412b40:	97ffd473 	bl	407d0c <assert_print>
  412b44:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412b48:	913b7400 	add	x0, x0, #0xedd
  412b4c:	97ffd470 	bl	407d0c <assert_print>
  412b50:	aa1303e0 	mov	x0, x19
  412b54:	52800bc1 	mov	w1, #0x5e                  	// #94
  412b58:	97ffd497 	bl	407db4 <assert_post_action>
  412b5c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412b60:	aa1303e1 	mov	x1, x19
  412b64:	9124f000 	add	x0, x0, #0x93c
  412b68:	52800bc2 	mov	w2, #0x5e                  	// #94
  412b6c:	97ffde84 	bl	40a57c <posix_print_error_and_exit>
	to->fn = fn;
  412b70:	f9000a61 	str	x1, [x19, #16]
  412b74:	aa0203f4 	mov	x20, x2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412b78:	f00000d5 	adrp	x21, 42d000 <counter_period>
  412b7c:	912622b7 	add	x23, x21, #0x988
	return posix_irq_lock();
  412b80:	97ffdd69 	bl	40a124 <posix_irq_lock>
  412b84:	2a0003f6 	mov	w22, w0
  412b88:	aa1703e0 	mov	x0, x23
  412b8c:	97ffef0d 	bl	40e7c0 <z_spin_lock_valid>
  412b90:	72001c1f 	tst	w0, #0xff
  412b94:	540002c1 	b.ne	412bec <z_add_timeout+0xf4>  // b.any
  412b98:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412b9c:	91391a73 	add	x19, x19, #0xe46
  412ba0:	aa1303e2 	mov	x2, x19
  412ba4:	52801283 	mov	w3, #0x94                  	// #148
  412ba8:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412bac:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412bb0:	9139cc21 	add	x1, x1, #0xe73
  412bb4:	9123f800 	add	x0, x0, #0x8fe
  412bb8:	97ffd455 	bl	407d0c <assert_print>
  412bbc:	aa1703e1 	mov	x1, x23
  412bc0:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412bc4:	913a2000 	add	x0, x0, #0xe88
  412bc8:	97ffd451 	bl	407d0c <assert_print>
  412bcc:	aa1303e0 	mov	x0, x19
  412bd0:	52801281 	mov	w1, #0x94                  	// #148
  412bd4:	97ffd478 	bl	407db4 <assert_post_action>
  412bd8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412bdc:	aa1303e1 	mov	x1, x19
  412be0:	9124f000 	add	x0, x0, #0x93c
  412be4:	52801282 	mov	w2, #0x94                  	// #148
  412be8:	97ffde65 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412bec:	aa1703e0 	mov	x0, x23
  412bf0:	97ffef0c 	bl	40e820 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
  412bf4:	b1000a9f 	cmn	x20, #0x2
  412bf8:	5400028c 	b.gt	412c48 <z_add_timeout+0x150>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
  412bfc:	f00000c0 	adrp	x0, 42d000 <counter_period>
  412c00:	92800023 	mov	x3, #0xfffffffffffffffe    	// #-2
  412c04:	f944c000 	ldr	x0, [x0, #2432]
  412c08:	cb000063 	sub	x3, x3, x0
  412c0c:	cb140062 	sub	x2, x3, x20

			to->dticks = MAX(1, ticks);
  412c10:	f100005f 	cmp	x2, #0x0
  412c14:	9a9fc442 	csinc	x2, x2, xzr, gt
	return list->head == list;
  412c18:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
  412c1c:	910fa001 	add	x1, x0, #0x3e8
  412c20:	f9000e62 	str	x2, [x19, #24]
  412c24:	f941f402 	ldr	x2, [x0, #1000]
	sys_dnode_t *const tail = list->tail;
  412c28:	f9400424 	ldr	x4, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412c2c:	eb01005f 	cmp	x2, x1
  412c30:	540001e1 	b.ne	412c6c <z_add_timeout+0x174>  // b.any
	node->next = list;
  412c34:	910fa001 	add	x1, x0, #0x3e8
	node->prev = tail;
  412c38:	a9001261 	stp	x1, x4, [x19]
	tail->next = node;
  412c3c:	f9000093 	str	x19, [x4]
	list->tail = node;
  412c40:	f9000433 	str	x19, [x1, #8]
}
  412c44:	14000015 	b	412c98 <z_add_timeout+0x1a0>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
  412c48:	91000694 	add	x20, x20, #0x1
  412c4c:	97ffff7f 	bl	412a48 <elapsed>
  412c50:	8b20c282 	add	x2, x20, w0, sxtw
  412c54:	17fffff1 	b	412c18 <z_add_timeout+0x120>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
  412c58:	cb030021 	sub	x1, x1, x3
  412c5c:	f9000e61 	str	x1, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
  412c60:	eb02009f 	cmp	x4, x2
  412c64:	54fffe80 	b.eq	412c34 <z_add_timeout+0x13c>  // b.none
  412c68:	f9400042 	ldr	x2, [x2]
		for (t = first(); t != NULL; t = next(t)) {
  412c6c:	b4fffe42 	cbz	x2, 412c34 <z_add_timeout+0x13c>
			if (t->dticks > to->dticks) {
  412c70:	f9400c43 	ldr	x3, [x2, #24]
  412c74:	f9400e61 	ldr	x1, [x19, #24]
  412c78:	eb01007f 	cmp	x3, x1
  412c7c:	54fffeed 	b.le	412c58 <z_add_timeout+0x160>
				t->dticks -= to->dticks;
  412c80:	cb010063 	sub	x3, x3, x1
  412c84:	f9000c43 	str	x3, [x2, #24]
	sys_dnode_t *const prev = successor->prev;
  412c88:	f9400441 	ldr	x1, [x2, #8]
	node->prev = prev;
  412c8c:	a9000662 	stp	x2, x1, [x19]
	prev->next = node;
  412c90:	f9000033 	str	x19, [x1]
	successor->prev = node;
  412c94:	f9000453 	str	x19, [x2, #8]
	return list->head == list;
  412c98:	910fa001 	add	x1, x0, #0x3e8
  412c9c:	f941f400 	ldr	x0, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412ca0:	eb01001f 	cmp	x0, x1
  412ca4:	540000c0 	b.eq	412cbc <z_add_timeout+0x1c4>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
  412ca8:	eb00027f 	cmp	x19, x0
  412cac:	54000081 	b.ne	412cbc <z_add_timeout+0x1c4>  // b.any
			sys_clock_set_timeout(next_timeout(), false);
  412cb0:	97ffff6c 	bl	412a60 <next_timeout>
  412cb4:	52800001 	mov	w1, #0x0                   	// #0
  412cb8:	97ffea51 	bl	40d5fc <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412cbc:	912622b5 	add	x21, x21, #0x988
  412cc0:	aa1503e0 	mov	x0, x21
  412cc4:	97ffeeca 	bl	40e7ec <z_spin_unlock_valid>
  412cc8:	72001c1f 	tst	w0, #0xff
  412ccc:	540002c1 	b.ne	412d24 <z_add_timeout+0x22c>  // b.any
  412cd0:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412cd4:	91391a73 	add	x19, x19, #0xe46
  412cd8:	aa1303e2 	mov	x2, x19
  412cdc:	52801863 	mov	w3, #0xc3                  	// #195
  412ce0:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412ce4:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412ce8:	913a8021 	add	x1, x1, #0xea0
  412cec:	9123f800 	add	x0, x0, #0x8fe
  412cf0:	97ffd407 	bl	407d0c <assert_print>
  412cf4:	aa1503e1 	mov	x1, x21
  412cf8:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412cfc:	913adc00 	add	x0, x0, #0xeb7
  412d00:	97ffd403 	bl	407d0c <assert_print>
  412d04:	aa1303e0 	mov	x0, x19
  412d08:	52801861 	mov	w1, #0xc3                  	// #195
  412d0c:	97ffd42a 	bl	407db4 <assert_post_action>
  412d10:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412d14:	aa1303e1 	mov	x1, x19
  412d18:	9124f000 	add	x0, x0, #0x93c
  412d1c:	52801862 	mov	w2, #0xc3                  	// #195
  412d20:	97ffde17 	bl	40a57c <posix_print_error_and_exit>
	posix_irq_unlock(key);
  412d24:	2a1603e0 	mov	w0, w22
		}
	}
}
  412d28:	a94153f3 	ldp	x19, x20, [sp, #16]
  412d2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412d30:	f9401bf7 	ldr	x23, [sp, #48]
  412d34:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412d38:	17ffdcfd 	b	40a12c <posix_irq_unlock>
  412d3c:	d65f03c0 	ret

0000000000412d40 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
  412d40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412d44:	910003fd 	mov	x29, sp
  412d48:	a90153f3 	stp	x19, x20, [sp, #16]
  412d4c:	aa0003f4 	mov	x20, x0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412d50:	f00000d3 	adrp	x19, 42d000 <counter_period>
  412d54:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  412d58:	97ffdcf3 	bl	40a124 <posix_irq_lock>
  412d5c:	91262276 	add	x22, x19, #0x988
  412d60:	2a0003f5 	mov	w21, w0
  412d64:	aa1603e0 	mov	x0, x22
  412d68:	97ffee96 	bl	40e7c0 <z_spin_lock_valid>
  412d6c:	72001c1f 	tst	w0, #0xff
  412d70:	540002c1 	b.ne	412dc8 <z_abort_timeout+0x88>  // b.any
  412d74:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412d78:	91391a73 	add	x19, x19, #0xe46
  412d7c:	aa1303e2 	mov	x2, x19
  412d80:	52801283 	mov	w3, #0x94                  	// #148
  412d84:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412d88:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412d8c:	9139cc21 	add	x1, x1, #0xe73
  412d90:	9123f800 	add	x0, x0, #0x8fe
  412d94:	97ffd3de 	bl	407d0c <assert_print>
  412d98:	aa1603e1 	mov	x1, x22
  412d9c:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412da0:	913a2000 	add	x0, x0, #0xe88
  412da4:	97ffd3da 	bl	407d0c <assert_print>
  412da8:	aa1303e0 	mov	x0, x19
  412dac:	52801281 	mov	w1, #0x94                  	// #148
  412db0:	97ffd401 	bl	407db4 <assert_post_action>
  412db4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412db8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412dbc:	aa1303e1 	mov	x1, x19
  412dc0:	9124f000 	add	x0, x0, #0x93c
  412dc4:	97ffddee 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412dc8:	aa1603e0 	mov	x0, x22
  412dcc:	97ffee95 	bl	40e820 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
  412dd0:	f9400280 	ldr	x0, [x20]
  412dd4:	b4000360 	cbz	x0, 412e40 <z_abort_timeout+0x100>
			remove_timeout(to);
			ret = 0;
  412dd8:	52800016 	mov	w22, #0x0                   	// #0
			remove_timeout(to);
  412ddc:	aa1403e0 	mov	x0, x20
  412de0:	97ffff36 	bl	412ab8 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412de4:	91262274 	add	x20, x19, #0x988
  412de8:	aa1403e0 	mov	x0, x20
  412dec:	97ffee80 	bl	40e7ec <z_spin_unlock_valid>
  412df0:	72001c1f 	tst	w0, #0xff
  412df4:	540002a1 	b.ne	412e48 <z_abort_timeout+0x108>  // b.any
  412df8:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412dfc:	91391a73 	add	x19, x19, #0xe46
  412e00:	aa1303e2 	mov	x2, x19
  412e04:	52801863 	mov	w3, #0xc3                  	// #195
  412e08:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412e0c:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412e10:	913a8021 	add	x1, x1, #0xea0
  412e14:	9123f800 	add	x0, x0, #0x8fe
  412e18:	97ffd3bd 	bl	407d0c <assert_print>
  412e1c:	aa1403e1 	mov	x1, x20
  412e20:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412e24:	913adc00 	add	x0, x0, #0xeb7
  412e28:	97ffd3b9 	bl	407d0c <assert_print>
  412e2c:	aa1303e0 	mov	x0, x19
  412e30:	52801861 	mov	w1, #0xc3                  	// #195
  412e34:	97ffd3e0 	bl	407db4 <assert_post_action>
  412e38:	52801862 	mov	w2, #0xc3                  	// #195
  412e3c:	17ffffdf 	b	412db8 <z_abort_timeout+0x78>
	int ret = -EINVAL;
  412e40:	128002b6 	mov	w22, #0xffffffea            	// #-22
  412e44:	17ffffe8 	b	412de4 <z_abort_timeout+0xa4>
	posix_irq_unlock(key);
  412e48:	2a1503e0 	mov	w0, w21
  412e4c:	97ffdcb8 	bl	40a12c <posix_irq_unlock>
		}
	}

	return ret;
}
  412e50:	2a1603e0 	mov	w0, w22
  412e54:	a94153f3 	ldp	x19, x20, [sp, #16]
  412e58:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412e5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  412e60:	d65f03c0 	ret

0000000000412e64 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
  412e64:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  412e68:	910003fd 	mov	x29, sp
  412e6c:	a90153f3 	stp	x19, x20, [sp, #16]
  412e70:	2a0003f3 	mov	w19, w0
  412e74:	a9025bf5 	stp	x21, x22, [sp, #32]
  412e78:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412e7c:	f00000d7 	adrp	x23, 42d000 <counter_period>
  412e80:	912622f6 	add	x22, x23, #0x988
  412e84:	a9046bf9 	stp	x25, x26, [sp, #64]
  412e88:	f9002bfb 	str	x27, [sp, #80]
	return posix_irq_lock();
  412e8c:	97ffdca6 	bl	40a124 <posix_irq_lock>
  412e90:	2a0003f4 	mov	w20, w0
  412e94:	aa1603e0 	mov	x0, x22
  412e98:	97ffee4a 	bl	40e7c0 <z_spin_lock_valid>
  412e9c:	72001c1f 	tst	w0, #0xff
  412ea0:	540002c1 	b.ne	412ef8 <sys_clock_announce+0x94>  // b.any
  412ea4:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412ea8:	91391a73 	add	x19, x19, #0xe46
  412eac:	aa1303e2 	mov	x2, x19
  412eb0:	52801283 	mov	w3, #0x94                  	// #148
  412eb4:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412eb8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412ebc:	9139cc21 	add	x1, x1, #0xe73
  412ec0:	9123f800 	add	x0, x0, #0x8fe
  412ec4:	97ffd392 	bl	407d0c <assert_print>
  412ec8:	912622e1 	add	x1, x23, #0x988
  412ecc:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412ed0:	913a2000 	add	x0, x0, #0xe88
  412ed4:	97ffd38e 	bl	407d0c <assert_print>
  412ed8:	aa1303e0 	mov	x0, x19
  412edc:	52801281 	mov	w1, #0x94                  	// #148
  412ee0:	97ffd3b5 	bl	407db4 <assert_post_action>
  412ee4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412ee8:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412eec:	aa1303e1 	mov	x1, x19
  412ef0:	9124f000 	add	x0, x0, #0x93c
  412ef4:	97ffdda2 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412ef8:	aa1603e0 	mov	x0, x22
  412efc:	97ffee49 	bl	40e820 <z_spin_lock_set_owner>
	return list->head == list;
  412f00:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
  412f04:	f00000d8 	adrp	x24, 42d000 <counter_period>
  412f08:	910fa01a 	add	x26, x0, #0x3e8
  412f0c:	f00000d9 	adrp	x25, 42d000 <counter_period>
  412f10:	b90bfb13 	str	w19, [x24, #3064]
  412f14:	f941f413 	ldr	x19, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412f18:	eb1a027f 	cmp	x19, x26
  412f1c:	54000740 	b.eq	413004 <sys_clock_announce+0x1a0>  // b.none

	struct _timeout *t = first();

	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
  412f20:	912fe31b 	add	x27, x24, #0xbf8
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
  412f24:	f944c320 	ldr	x0, [x25, #2432]
	     (t != NULL) && (t->dticks <= announce_remaining);
  412f28:	b9400361 	ldr	w1, [x27]
  412f2c:	b40006d3 	cbz	x19, 413004 <sys_clock_announce+0x1a0>
  412f30:	f9400e75 	ldr	x21, [x19, #24]
  412f34:	93407c22 	sxtw	x2, w1
  412f38:	eb21c2bf 	cmp	x21, w1, sxtw
  412f3c:	5400008d 	b.le	412f4c <sys_clock_announce+0xe8>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
  412f40:	cb0202b5 	sub	x21, x21, x2
  412f44:	f9000e75 	str	x21, [x19, #24]
  412f48:	1400002f 	b	413004 <sys_clock_announce+0x1a0>
		t->dticks = 0;
  412f4c:	f9000e7f 	str	xzr, [x19, #24]
		curr_tick += dt;
  412f50:	8b35c000 	add	x0, x0, w21, sxtw
  412f54:	f904c320 	str	x0, [x25, #2432]
		remove_timeout(t);
  412f58:	aa1303e0 	mov	x0, x19
  412f5c:	97fffed7 	bl	412ab8 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412f60:	aa1603e0 	mov	x0, x22
  412f64:	97ffee22 	bl	40e7ec <z_spin_unlock_valid>
  412f68:	72001c1f 	tst	w0, #0xff
  412f6c:	54000261 	b.ne	412fb8 <sys_clock_announce+0x154>  // b.any
  412f70:	f0000013 	adrp	x19, 415000 <random_data+0xb30>
  412f74:	91391a73 	add	x19, x19, #0xe46
  412f78:	aa1303e2 	mov	x2, x19
  412f7c:	52801863 	mov	w3, #0xc3                  	// #195
  412f80:	f0000001 	adrp	x1, 415000 <random_data+0xb30>
  412f84:	d0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  412f88:	913a8021 	add	x1, x1, #0xea0
  412f8c:	9123f800 	add	x0, x0, #0x8fe
  412f90:	97ffd35f 	bl	407d0c <assert_print>
  412f94:	912622e1 	add	x1, x23, #0x988
  412f98:	f0000000 	adrp	x0, 415000 <random_data+0xb30>
  412f9c:	913adc00 	add	x0, x0, #0xeb7
  412fa0:	97ffd35b 	bl	407d0c <assert_print>
  412fa4:	aa1303e0 	mov	x0, x19
  412fa8:	52801861 	mov	w1, #0xc3                  	// #195
  412fac:	97ffd382 	bl	407db4 <assert_post_action>
  412fb0:	52801862 	mov	w2, #0xc3                  	// #195
  412fb4:	17ffffcd 	b	412ee8 <sys_clock_announce+0x84>
	posix_irq_unlock(key);
  412fb8:	2a1403e0 	mov	w0, w20
  412fbc:	97ffdc5c 	bl	40a12c <posix_irq_unlock>
		t->fn(t);
  412fc0:	f9400a61 	ldr	x1, [x19, #16]
  412fc4:	aa1303e0 	mov	x0, x19
  412fc8:	d63f0020 	blr	x1
	return posix_irq_lock();
  412fcc:	97ffdc56 	bl	40a124 <posix_irq_lock>
  412fd0:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412fd4:	aa1603e0 	mov	x0, x22
  412fd8:	97ffedfa 	bl	40e7c0 <z_spin_lock_valid>
  412fdc:	72001c1f 	tst	w0, #0xff
  412fe0:	54fff620 	b.eq	412ea4 <sys_clock_announce+0x40>  // b.none
	z_spin_lock_set_owner(l);
  412fe4:	aa1603e0 	mov	x0, x22
  412fe8:	97ffee0e 	bl	40e820 <z_spin_lock_set_owner>
		announce_remaining -= dt;
  412fec:	b9400360 	ldr	w0, [x27]
	return list->head == list;
  412ff0:	f9400353 	ldr	x19, [x26]
  412ff4:	4b150000 	sub	w0, w0, w21
  412ff8:	b9000360 	str	w0, [x27]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412ffc:	eb1a027f 	cmp	x19, x26
  413000:	54fff921 	b.ne	412f24 <sys_clock_announce+0xc0>  // b.any
	}

	curr_tick += announce_remaining;
  413004:	f944c321 	ldr	x1, [x25, #2432]
  413008:	b98bfb00 	ldrsw	x0, [x24, #3064]
	announce_remaining = 0;
  41300c:	b90bfb1f 	str	wzr, [x24, #3064]
	curr_tick += announce_remaining;
  413010:	8b010000 	add	x0, x0, x1
  413014:	f904c320 	str	x0, [x25, #2432]

	sys_clock_set_timeout(next_timeout(), false);
  413018:	97fffe92 	bl	412a60 <next_timeout>
  41301c:	52800001 	mov	w1, #0x0                   	// #0
  413020:	97ffe977 	bl	40d5fc <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413024:	912622e0 	add	x0, x23, #0x988
  413028:	97ffedf1 	bl	40e7ec <z_spin_unlock_valid>
  41302c:	72001c1f 	tst	w0, #0xff
  413030:	54fffa00 	b.eq	412f70 <sys_clock_announce+0x10c>  // b.none
	posix_irq_unlock(key);
  413034:	2a1403e0 	mov	w0, w20
  413038:	97ffdc3d 	bl	40a12c <posix_irq_unlock>
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
  41303c:	a94153f3 	ldp	x19, x20, [sp, #16]
  413040:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413044:	a94363f7 	ldp	x23, x24, [sp, #48]
  413048:	a9446bf9 	ldp	x25, x26, [sp, #64]
  41304c:	f9402bfb 	ldr	x27, [sp, #80]
  413050:	a8c67bfd 	ldp	x29, x30, [sp], #96
	z_time_slice();
  413054:	17fff741 	b	410d58 <z_time_slice>

0000000000413058 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
  413058:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  41305c:	910003fd 	mov	x29, sp
  413060:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413064:	d00000d3 	adrp	x19, 42d000 <counter_period>
  413068:	91262273 	add	x19, x19, #0x988
  41306c:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  413070:	97ffdc2d 	bl	40a124 <posix_irq_lock>
  413074:	2a0003f5 	mov	w21, w0
  413078:	aa1303e0 	mov	x0, x19
  41307c:	97ffedd1 	bl	40e7c0 <z_spin_lock_valid>
  413080:	72001c1f 	tst	w0, #0xff
  413084:	540002c1 	b.ne	4130dc <sys_clock_tick_get+0x84>  // b.any
  413088:	d0000014 	adrp	x20, 415000 <random_data+0xb30>
  41308c:	91391a94 	add	x20, x20, #0xe46
  413090:	aa1403e2 	mov	x2, x20
  413094:	52801283 	mov	w3, #0x94                  	// #148
  413098:	d0000001 	adrp	x1, 415000 <random_data+0xb30>
  41309c:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4130a0:	9139cc21 	add	x1, x1, #0xe73
  4130a4:	9123f800 	add	x0, x0, #0x8fe
  4130a8:	97ffd319 	bl	407d0c <assert_print>
  4130ac:	aa1303e1 	mov	x1, x19
  4130b0:	d0000000 	adrp	x0, 415000 <random_data+0xb30>
  4130b4:	913a2000 	add	x0, x0, #0xe88
  4130b8:	97ffd315 	bl	407d0c <assert_print>
  4130bc:	aa1403e0 	mov	x0, x20
  4130c0:	52801281 	mov	w1, #0x94                  	// #148
  4130c4:	97ffd33c 	bl	407db4 <assert_post_action>
  4130c8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4130cc:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4130d0:	aa1403e1 	mov	x1, x20
  4130d4:	9124f000 	add	x0, x0, #0x93c
  4130d8:	97ffdd29 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4130dc:	aa1303e0 	mov	x0, x19
  4130e0:	97ffedd0 	bl	40e820 <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
  4130e4:	97fffe59 	bl	412a48 <elapsed>
  4130e8:	d00000c1 	adrp	x1, 42d000 <counter_period>
  4130ec:	f944c021 	ldr	x1, [x1, #2432]
  4130f0:	8b20c034 	add	x20, x1, w0, sxtw
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4130f4:	aa1303e0 	mov	x0, x19
  4130f8:	97ffedbd 	bl	40e7ec <z_spin_unlock_valid>
  4130fc:	72001c1f 	tst	w0, #0xff
  413100:	54000261 	b.ne	41314c <sys_clock_tick_get+0xf4>  // b.any
  413104:	d0000014 	adrp	x20, 415000 <random_data+0xb30>
  413108:	91391a94 	add	x20, x20, #0xe46
  41310c:	aa1403e2 	mov	x2, x20
  413110:	52801863 	mov	w3, #0xc3                  	// #195
  413114:	d0000001 	adrp	x1, 415000 <random_data+0xb30>
  413118:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41311c:	913a8021 	add	x1, x1, #0xea0
  413120:	9123f800 	add	x0, x0, #0x8fe
  413124:	97ffd2fa 	bl	407d0c <assert_print>
  413128:	aa1303e1 	mov	x1, x19
  41312c:	d0000000 	adrp	x0, 415000 <random_data+0xb30>
  413130:	913adc00 	add	x0, x0, #0xeb7
  413134:	97ffd2f6 	bl	407d0c <assert_print>
  413138:	aa1403e0 	mov	x0, x20
  41313c:	52801861 	mov	w1, #0xc3                  	// #195
  413140:	97ffd31d 	bl	407db4 <assert_post_action>
  413144:	52801862 	mov	w2, #0xc3                  	// #195
  413148:	17ffffe1 	b	4130cc <sys_clock_tick_get+0x74>
	posix_irq_unlock(key);
  41314c:	2a1503e0 	mov	w0, w21
  413150:	97ffdbf7 	bl	40a12c <posix_irq_unlock>
	}
	return t;
}
  413154:	aa1403e0 	mov	x0, x20
  413158:	a94153f3 	ldp	x19, x20, [sp, #16]
  41315c:	f94013f5 	ldr	x21, [sp, #32]
  413160:	a8c37bfd 	ldp	x29, x30, [sp], #48
  413164:	d65f03c0 	ret

0000000000413168 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
  413168:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  41316c:	910003fd 	mov	x29, sp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
  413170:	97ffffba 	bl	413058 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
  413174:	a8c17bfd 	ldp	x29, x30, [sp], #16
  413178:	d65f03c0 	ret

000000000041317c <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
  41317c:	17ffffb7 	b	413058 <sys_clock_tick_get>

0000000000413180 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
  413180:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  413184:	910003fd 	mov	x29, sp
  413188:	f9000bf3 	str	x19, [sp, #16]
  41318c:	aa0003f3 	mov	x19, x0
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  413190:	b100041f 	cmn	x0, #0x1
  413194:	54000180 	b.eq	4131c4 <sys_clock_timeout_end_calc+0x44>  // b.none
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  413198:	b5000080 	cbnz	x0, 4131a8 <sys_clock_timeout_end_calc+0x28>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
  41319c:	f9400bf3 	ldr	x19, [sp, #16]
  4131a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
		return sys_clock_tick_get();
  4131a4:	17ffffad 	b	413058 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
  4131a8:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
  4131ac:	eb130000 	subs	x0, x0, x19
  4131b0:	540000a5 	b.pl	4131c4 <sys_clock_timeout_end_calc+0x44>  // b.nfrst
		return sys_clock_tick_get() + MAX(1, dt);
  4131b4:	97ffffa9 	bl	413058 <sys_clock_tick_get>
  4131b8:	f100027f 	cmp	x19, #0x0
  4131bc:	9a9fc673 	csinc	x19, x19, xzr, gt
  4131c0:	8b000260 	add	x0, x19, x0
}
  4131c4:	f9400bf3 	ldr	x19, [sp, #16]
  4131c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4131cc:	d65f03c0 	ret

00000000004131d0 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  4131d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4131d4:	910003fd 	mov	x29, sp
  4131d8:	a90153f3 	stp	x19, x20, [sp, #16]
  4131dc:	aa0003f3 	mov	x19, x0
  4131e0:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  4131e4:	97ffdbd0 	bl	40a124 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4131e8:	d00000d6 	adrp	x22, 42d000 <counter_period>
  4131ec:	912642d5 	add	x21, x22, #0x990
  4131f0:	2a0003f4 	mov	w20, w0
  4131f4:	aa1503e0 	mov	x0, x21
  4131f8:	97ffed72 	bl	40e7c0 <z_spin_lock_valid>
  4131fc:	72001c1f 	tst	w0, #0xff
  413200:	540002c1 	b.ne	413258 <z_timer_expiration_handler+0x88>  // b.any
  413204:	d0000013 	adrp	x19, 415000 <random_data+0xb30>
  413208:	91391a73 	add	x19, x19, #0xe46
  41320c:	aa1303e2 	mov	x2, x19
  413210:	52801283 	mov	w3, #0x94                  	// #148
  413214:	d0000001 	adrp	x1, 415000 <random_data+0xb30>
  413218:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41321c:	9139cc21 	add	x1, x1, #0xe73
  413220:	9123f800 	add	x0, x0, #0x8fe
  413224:	97ffd2ba 	bl	407d0c <assert_print>
  413228:	912642c1 	add	x1, x22, #0x990
  41322c:	d0000000 	adrp	x0, 415000 <random_data+0xb30>
  413230:	913a2000 	add	x0, x0, #0xe88
  413234:	97ffd2b6 	bl	407d0c <assert_print>
  413238:	aa1303e0 	mov	x0, x19
  41323c:	52801281 	mov	w1, #0x94                  	// #148
  413240:	97ffd2dd 	bl	407db4 <assert_post_action>
  413244:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413248:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  41324c:	aa1303e1 	mov	x1, x19
  413250:	9124f000 	add	x0, x0, #0x93c
  413254:	97ffdcca 	bl	40a57c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413258:	aa1503e0 	mov	x0, x21
  41325c:	97ffed71 	bl	40e820 <z_spin_lock_set_owner>
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
  413260:	f9400260 	ldr	x0, [x19]
  413264:	b40002e0 	cbz	x0, 4132c0 <z_timer_expiration_handler+0xf0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413268:	aa1503e0 	mov	x0, x21
  41326c:	97ffed60 	bl	40e7ec <z_spin_unlock_valid>
  413270:	72001c1f 	tst	w0, #0xff
  413274:	540008e1 	b.ne	413390 <z_timer_expiration_handler+0x1c0>  // b.any
  413278:	d0000013 	adrp	x19, 415000 <random_data+0xb30>
  41327c:	91391a73 	add	x19, x19, #0xe46
  413280:	aa1303e2 	mov	x2, x19
  413284:	52801863 	mov	w3, #0xc3                  	// #195
  413288:	d0000001 	adrp	x1, 415000 <random_data+0xb30>
  41328c:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  413290:	913a8021 	add	x1, x1, #0xea0
  413294:	9123f800 	add	x0, x0, #0x8fe
  413298:	97ffd29d 	bl	407d0c <assert_print>
  41329c:	912642c1 	add	x1, x22, #0x990
  4132a0:	d0000000 	adrp	x0, 415000 <random_data+0xb30>
  4132a4:	913adc00 	add	x0, x0, #0xeb7
  4132a8:	97ffd299 	bl	407d0c <assert_print>
  4132ac:	aa1303e0 	mov	x0, x19
  4132b0:	52801861 	mov	w1, #0xc3                  	// #195
  4132b4:	97ffd2c0 	bl	407db4 <assert_post_action>
  4132b8:	52801862 	mov	w2, #0xc3                  	// #195
  4132bc:	17ffffe3 	b	413248 <z_timer_expiration_handler+0x78>

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
  4132c0:	f9402260 	ldr	x0, [x19, #64]
  4132c4:	91000401 	add	x1, x0, #0x1
  4132c8:	f100043f 	cmp	x1, #0x1
  4132cc:	54000249 	b.ls	413314 <z_timer_expiration_handler+0x144>  // b.plast
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		k_timeout_t next = timer->period;

		/* see note about z_add_timeout() in z_impl_k_timer_start() */
		next.ticks = MAX(next.ticks - 1, 0);
  4132d0:	f100001f 	cmp	x0, #0x0
  4132d4:	9a9fc400 	csinc	x0, x0, xzr, gt
  4132d8:	d1000415 	sub	x21, x0, #0x1
	return z_impl_k_uptime_ticks();
  4132dc:	97ffffa8 	bl	41317c <z_impl_k_uptime_ticks>
		 * we "should" have run.  Requires absolute timeouts.
		 * (Note offset by one: we're nominally at the
		 * beginning of a tick, so need to defeat the "round
		 * down" behavior on timeout addition).
		 */
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
  4132e0:	91000400 	add	x0, x0, #0x1
  4132e4:	8b150000 	add	x0, x0, x21
  4132e8:	f100001f 	cmp	x0, #0x0
  4132ec:	540004ed 	b.le	413388 <z_timer_expiration_handler+0x1b8>
  4132f0:	97ffffa3 	bl	41317c <z_impl_k_uptime_ticks>
  4132f4:	91000400 	add	x0, x0, #0x1
  4132f8:	8b150000 	add	x0, x0, x21
  4132fc:	92800022 	mov	x2, #0xfffffffffffffffe    	// #-2
  413300:	cb000042 	sub	x2, x2, x0
#endif
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  413304:	900000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
  413308:	aa1303e0 	mov	x0, x19
  41330c:	f947d821 	ldr	x1, [x1, #4016]
  413310:	97fffdfa 	bl	412af8 <z_add_timeout>
			      next);
	}

	/* update timer's status */
	timer->status += 1U;
  413314:	b9404a60 	ldr	w0, [x19, #72]
  413318:	11000400 	add	w0, w0, #0x1
  41331c:	b9004a60 	str	w0, [x19, #72]

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  413320:	f9401a60 	ldr	x0, [x19, #48]
  413324:	b4000260 	cbz	x0, 413370 <z_timer_expiration_handler+0x1a0>
  413328:	912642d5 	add	x21, x22, #0x990
  41332c:	aa1503e0 	mov	x0, x21
  413330:	97ffed2f 	bl	40e7ec <z_spin_unlock_valid>
  413334:	72001c1f 	tst	w0, #0xff
  413338:	54fffa00 	b.eq	413278 <z_timer_expiration_handler+0xa8>  // b.none
	posix_irq_unlock(key);
  41333c:	2a1403e0 	mov	w0, w20
  413340:	97ffdb7b 	bl	40a12c <posix_irq_unlock>
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
  413344:	f9401a61 	ldr	x1, [x19, #48]
  413348:	aa1303e0 	mov	x0, x19
  41334c:	d63f0020 	blr	x1
	return posix_irq_lock();
  413350:	97ffdb75 	bl	40a124 <posix_irq_lock>
  413354:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413358:	aa1503e0 	mov	x0, x21
  41335c:	97ffed19 	bl	40e7c0 <z_spin_lock_valid>
  413360:	72001c1f 	tst	w0, #0xff
  413364:	54fff500 	b.eq	413204 <z_timer_expiration_handler+0x34>  // b.none
	z_spin_lock_set_owner(l);
  413368:	aa1503e0 	mov	x0, x21
  41336c:	97ffed2d 	bl	40e820 <z_spin_lock_set_owner>
	return list->head == list;
  413370:	f8420e75 	ldr	x21, [x19, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  413374:	eb1302bf 	cmp	x21, x19
  413378:	54000040 	b.eq	413380 <z_timer_expiration_handler+0x1b0>  // b.none
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
  41337c:	b5000155 	cbnz	x21, 4133a4 <z_timer_expiration_handler+0x1d4>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413380:	912642c0 	add	x0, x22, #0x990
  413384:	17ffffba 	b	41326c <z_timer_expiration_handler+0x9c>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
  413388:	92800022 	mov	x2, #0xfffffffffffffffe    	// #-2
  41338c:	17ffffde 	b	413304 <z_timer_expiration_handler+0x134>
	posix_irq_unlock(key);
  413390:	2a1403e0 	mov	w0, w20
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
  413394:	a94153f3 	ldp	x19, x20, [sp, #16]
  413398:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41339c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4133a0:	17ffdb63 	b	40a12c <posix_irq_unlock>
	z_unpend_thread_no_timeout(thread);
  4133a4:	aa1503e0 	mov	x0, x21
  4133a8:	97fff466 	bl	410540 <z_unpend_thread_no_timeout>
  4133ac:	b9004ebf 	str	wzr, [x21, #76]
  4133b0:	912642c0 	add	x0, x22, #0x990
  4133b4:	97ffed0e 	bl	40e7ec <z_spin_unlock_valid>
  4133b8:	72001c1f 	tst	w0, #0xff
  4133bc:	54fff5e0 	b.eq	413278 <z_timer_expiration_handler+0xa8>  // b.none
  4133c0:	2a1403e0 	mov	w0, w20
  4133c4:	97ffdb5a 	bl	40a12c <posix_irq_unlock>
	z_ready_thread(thread);
  4133c8:	aa1503e0 	mov	x0, x21
}
  4133cc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4133d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4133d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_ready_thread(thread);
  4133d8:	17fff6fa 	b	410fc0 <z_ready_thread>

00000000004133dc <k_timer_init>:
	node->prev = NULL;
  4133dc:	a9007c1f 	stp	xzr, xzr, [x0]
void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
	timer->stop_fn = stop_fn;
  4133e0:	a9030801 	stp	x1, x2, [x0, #48]
	sys_dlist_init(&w->waitq);
  4133e4:	91008001 	add	x1, x0, #0x20
	list->tail = (sys_dnode_t *)list;
  4133e8:	a9020401 	stp	x1, x1, [x0, #32]
	timer->status = 0U;
  4133ec:	b900481f 	str	wzr, [x0, #72]

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
  4133f0:	f900281f 	str	xzr, [x0, #80]

	z_object_init(timer);
}
  4133f4:	d65f03c0 	ret

00000000004133f8 <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
  4133f8:	b100043f 	cmn	x1, #0x1
  4133fc:	54000320 	b.eq	413460 <z_impl_k_timer_start+0x68>  // b.none
{
  413400:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  413404:	910003fd 	mov	x29, sp
  413408:	a90153f3 	stp	x19, x20, [sp, #16]
  41340c:	aa0003f4 	mov	x20, x0
  413410:	aa0103f3 	mov	x19, x1
  413414:	f90013f5 	str	x21, [sp, #32]
  413418:	aa0203f5 	mov	x21, x2
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
  41341c:	b100083f 	cmn	x1, #0x2
  413420:	5400008d 	b.le	413430 <z_impl_k_timer_start+0x38>
		duration.ticks = MAX(duration.ticks - 1, 0);
  413424:	f100003f 	cmp	x1, #0x0
  413428:	9a9fc433 	csinc	x19, x1, xzr, gt
  41342c:	d1000673 	sub	x19, x19, #0x1
	}

	(void)z_abort_timeout(&timer->timeout);
  413430:	aa1403e0 	mov	x0, x20
  413434:	97fffe43 	bl	412d40 <z_abort_timeout>
	timer->period = period;
  413438:	f9002295 	str	x21, [x20, #64]
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  41343c:	aa1303e2 	mov	x2, x19
	timer->status = 0U;
  413440:	b9004a9f 	str	wzr, [x20, #72]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  413444:	aa1403e0 	mov	x0, x20
  413448:	900000c1 	adrp	x1, 42b000 <__FRAME_END__+0xfd74>
		     duration);
}
  41344c:	a94153f3 	ldp	x19, x20, [sp, #16]
  413450:	f94013f5 	ldr	x21, [sp, #32]
  413454:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  413458:	f947d821 	ldr	x1, [x1, #4016]
  41345c:	17fffda7 	b	412af8 <z_add_timeout>
  413460:	d65f03c0 	ret

0000000000413464 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
  413464:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  413468:	910003fd 	mov	x29, sp
  41346c:	f9000bf3 	str	x19, [sp, #16]
  413470:	aa0003f3 	mov	x19, x0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
  413474:	97fffe33 	bl	412d40 <z_abort_timeout>

	if (inactive) {
  413478:	350001a0 	cbnz	w0, 4134ac <z_impl_k_timer_stop+0x48>
		return;
	}

	if (timer->stop_fn != NULL) {
  41347c:	f9401e61 	ldr	x1, [x19, #56]
  413480:	b4000061 	cbz	x1, 41348c <z_impl_k_timer_stop+0x28>
		timer->stop_fn(timer);
  413484:	aa1303e0 	mov	x0, x19
  413488:	d63f0020 	blr	x1
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
  41348c:	91008260 	add	x0, x19, #0x20
  413490:	97fff9d5 	bl	411be4 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
  413494:	b40000c0 	cbz	x0, 4134ac <z_impl_k_timer_stop+0x48>
			z_ready_thread(pending_thread);
  413498:	97fff6ca 	bl	410fc0 <z_ready_thread>
	return posix_irq_lock();
  41349c:	97ffdb22 	bl	40a124 <posix_irq_lock>
			z_reschedule_unlocked();
		}
	}
}
  4134a0:	f9400bf3 	ldr	x19, [sp, #16]
  4134a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	(void) z_reschedule_irqlock(arch_irq_lock());
  4134a8:	17fff4af 	b	410764 <z_reschedule_irqlock>
  4134ac:	f9400bf3 	ldr	x19, [sp, #16]
  4134b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4134b4:	d65f03c0 	ret

00000000004134b8 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
  4134b8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4134bc:	910003fd 	mov	x29, sp
  4134c0:	a90153f3 	stp	x19, x20, [sp, #16]
  4134c4:	aa0003f4 	mov	x20, x0
  4134c8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4134cc:	2a0103f5 	mov	w21, w1
  4134d0:	f9001bf7 	str	x23, [sp, #48]
	struct z_poller *poller = event->poller;
  4134d4:	f9400813 	ldr	x19, [x0, #16]
	int retcode = 0;

	if (poller != NULL) {
  4134d8:	b4000113 	cbz	x19, 4134f8 <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
  4134dc:	39400660 	ldrb	w0, [x19, #1]
  4134e0:	7100041f 	cmp	w0, #0x1
  4134e4:	540004c1 	b.ne	41357c <signal_poll_event+0xc4>  // b.any
	if (!z_is_thread_pending(thread)) {
  4134e8:	385a9260 	ldurb	w0, [x19, #-87]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
  4134ec:	d101c276 	sub	x22, x19, #0x70
  4134f0:	37080160 	tbnz	w0, #1, 41351c <signal_poll_event+0x64>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
  4134f4:	3900027f 	strb	wzr, [x19]
	event->state |= state;
  4134f8:	f9400e80 	ldr	x0, [x20, #24]
	event->poller = NULL;
  4134fc:	f9000a9f 	str	xzr, [x20, #16]
	event->state |= state;
  413500:	d34e5000 	ubfx	x0, x0, #14, #7
  413504:	2a0002b5 	orr	w21, w21, w0
  413508:	b9401a80 	ldr	w0, [x20, #24]
  41350c:	33121aa0 	bfi	w0, w21, #14, #7
  413510:	b9001a80 	str	w0, [x20, #24]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
  413514:	52800000 	mov	w0, #0x0                   	// #0
  413518:	14000006 	b	413530 <signal_poll_event+0x78>
	if (z_is_thread_timeout_expired(thread)) {
  41351c:	f94022c0 	ldr	x0, [x22, #64]
  413520:	b100081f 	cmn	x0, #0x2
  413524:	54000101 	b.ne	413544 <signal_poll_event+0x8c>  // b.any
		return -EAGAIN;
  413528:	12800140 	mov	w0, #0xfffffff5            	// #-11
		poller->is_polling = false;
  41352c:	3900027f 	strb	wzr, [x19]
}
  413530:	a94153f3 	ldp	x19, x20, [sp, #16]
  413534:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413538:	f9401bf7 	ldr	x23, [sp, #48]
  41353c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  413540:	d65f03c0 	ret
	z_unpend_thread(thread);
  413544:	aa1603e0 	mov	x0, x22
  413548:	97fff53a 	bl	410a30 <z_unpend_thread>
	arch_thread_return_value_set(thread,
  41354c:	710022bf 	cmp	w21, #0x8
  413550:	12800060 	mov	w0, #0xfffffffc            	// #-4
  413554:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  413558:	b9004ec0 	str	w0, [x22, #76]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  41355c:	394066c0 	ldrb	w0, [x22, #25]
  413560:	f240101f 	tst	x0, #0x1f
  413564:	54fffc81 	b.ne	4134f4 <signal_poll_event+0x3c>  // b.any
	if (!z_is_thread_ready(thread)) {
  413568:	f85b8260 	ldur	x0, [x19, #-72]
  41356c:	b5fffc40 	cbnz	x0, 4134f4 <signal_poll_event+0x3c>
	z_ready_thread(thread);
  413570:	aa1603e0 	mov	x0, x22
  413574:	97fff693 	bl	410fc0 <z_ready_thread>
		poller->is_polling = false;
  413578:	17ffffdf 	b	4134f4 <signal_poll_event+0x3c>
		} else if (poller->mode == MODE_TRIGGERED) {
  41357c:	7100081f 	cmp	w0, #0x2
  413580:	54fffba1 	b.ne	4134f4 <signal_poll_event+0x3c>  // b.any
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
  413584:	39400260 	ldrb	w0, [x19]
  413588:	34fffb80 	cbz	w0, 4134f8 <signal_poll_event+0x40>
  41358c:	f85f8277 	ldur	x23, [x19, #-8]
  413590:	d100a276 	sub	x22, x19, #0x28
  413594:	b4fffb17 	cbz	x23, 4134f4 <signal_poll_event+0x3c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
  413598:	91008260 	add	x0, x19, #0x20
  41359c:	97fffde9 	bl	412d40 <z_abort_timeout>
		twork->poll_result = 0;
  4135a0:	b900427f 	str	wzr, [x19, #64]
		z_work_submit_to_queue(work_q, &twork->work);
  4135a4:	aa1603e1 	mov	x1, x22
  4135a8:	aa1703e0 	mov	x0, x23
  4135ac:	97fff2c0 	bl	4100ac <z_work_submit_to_queue>
		poller->is_polling = false;
  4135b0:	17ffffd1 	b	4134f4 <signal_poll_event+0x3c>

00000000004135b4 <z_handle_obj_poll_events>:
{
  4135b4:	aa0003e2 	mov	x2, x0
	return list->head == list;
  4135b8:	f9400000 	ldr	x0, [x0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
  4135bc:	eb00005f 	cmp	x2, x0
  4135c0:	540000c0 	b.eq	4135d8 <z_handle_obj_poll_events+0x24>  // b.none
	sys_dnode_t *const prev = node->prev;
  4135c4:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
  4135c8:	f9000062 	str	x2, [x3]
	next->prev = prev;
  4135cc:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
  4135d0:	a9007c1f 	stp	xzr, xzr, [x0]
		(void) signal_poll_event(poll_event, state);
  4135d4:	17ffffb9 	b	4134b8 <signal_poll_event>
}
  4135d8:	d65f03c0 	ret

00000000004135dc <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
  4135dc:	b4000080 	cbz	x0, 4135ec <k_free+0x10>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
  4135e0:	d1002001 	sub	x1, x0, #0x8
  4135e4:	f85f8000 	ldur	x0, [x0, #-8]
  4135e8:	17ffea2f 	b	40dea4 <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
  4135ec:	d65f03c0 	ret

00000000004135f0 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
  4135f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4135f4:	910003fd 	mov	x29, sp
  4135f8:	a90153f3 	stp	x19, x20, [sp, #16]
  4135fc:	aa0103f4 	mov	x20, x1
  413600:	f90013f5 	str	x21, [sp, #32]
  413604:	aa0003f5 	mov	x21, x0
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
  413608:	97ffeb61 	bl	40e38c <k_is_in_isr>
  41360c:	72001c1f 	tst	w0, #0xff
  413610:	54000521 	b.ne	4136b4 <z_thread_aligned_alloc+0xc4>  // b.any
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
  413614:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  413618:	f9473000 	ldr	x0, [x0, #3680]
  41361c:	f9400800 	ldr	x0, [x0, #16]
  413620:	f9405813 	ldr	x19, [x0, #176]
	}

	if (heap != NULL) {
  413624:	b40004b3 	cbz	x19, 4136b8 <z_thread_aligned_alloc+0xc8>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
  413628:	b1002282 	adds	x2, x20, #0x8
  41362c:	54000442 	b.cs	4136b4 <z_thread_aligned_alloc+0xc4>  // b.hs, b.nlast
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
  413630:	b27d02a1 	orr	x1, x21, #0x8
  413634:	aa1303e0 	mov	x0, x19
  413638:	d2800003 	mov	x3, #0x0                   	// #0
  41363c:	97ffe99a 	bl	40dca4 <k_heap_aligned_alloc>
	if (mem == NULL) {
  413640:	b40003a0 	cbz	x0, 4136b4 <z_thread_aligned_alloc+0xc4>
	*heap_ref = heap;
  413644:	f9000013 	str	x19, [x0]
	mem = ++heap_ref;
  413648:	91002013 	add	x19, x0, #0x8
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
  41364c:	b4000375 	cbz	x21, 4136b8 <z_thread_aligned_alloc+0xc8>
  413650:	d10006a0 	sub	x0, x21, #0x1
  413654:	ea00027f 	tst	x19, x0
  413658:	54000300 	b.eq	4136b8 <z_thread_aligned_alloc+0xc8>  // b.none
  41365c:	f0000014 	adrp	x20, 416000 <__func__.0+0x9cb>
  413660:	91277a94 	add	x20, x20, #0x9de
  413664:	528004a3 	mov	w3, #0x25                  	// #37
  413668:	aa1403e2 	mov	x2, x20
  41366c:	f0000001 	adrp	x1, 416000 <__func__.0+0x9cb>
  413670:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  413674:	91280821 	add	x1, x1, #0xa02
  413678:	9123f800 	add	x0, x0, #0x8fe
  41367c:	97ffd1a4 	bl	407d0c <assert_print>
  413680:	aa1503e2 	mov	x2, x21
  413684:	aa1303e1 	mov	x1, x19
  413688:	f0000000 	adrp	x0, 416000 <__func__.0+0x9cb>
  41368c:	9128d000 	add	x0, x0, #0xa34
  413690:	97ffd19f 	bl	407d0c <assert_print>
  413694:	aa1403e0 	mov	x0, x20
  413698:	528004a1 	mov	w1, #0x25                  	// #37
  41369c:	97ffd1c6 	bl	407db4 <assert_post_action>
  4136a0:	b0000000 	adrp	x0, 414000 <dlc_table.0+0x60d>
  4136a4:	aa1403e1 	mov	x1, x20
  4136a8:	9124f000 	add	x0, x0, #0x93c
  4136ac:	528004a2 	mov	w2, #0x25                  	// #37
  4136b0:	97ffdbb3 	bl	40a57c <posix_print_error_and_exit>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
  4136b4:	d2800013 	mov	x19, #0x0                   	// #0
	}

	return ret;
}
  4136b8:	aa1303e0 	mov	x0, x19
  4136bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4136c0:	f94013f5 	ldr	x21, [sp, #32]
  4136c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4136c8:	d65f03c0 	ret

00000000004136cc <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
  4136cc:	f0000000 	adrp	x0, 416000 <__func__.0+0x9cb>
  4136d0:	91297000 	add	x0, x0, #0xa5c
  4136d4:	17ffcbd1 	b	406618 <printk>

00000000004136d8 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
  4136d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4136dc:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
	struct k_work_queue_config cfg = {
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
  4136e0:	d2808002 	mov	x2, #0x400                 	// #1024
{
  4136e4:	910003fd 	mov	x29, sp
  4136e8:	f9476800 	ldr	x0, [x0, #3792]
	k_work_queue_start(&k_sys_work_q,
  4136ec:	910063e4 	add	x4, sp, #0x18
  4136f0:	12800003 	mov	w3, #0xffffffff            	// #-1
{
  4136f4:	f9400001 	ldr	x1, [x0]
  4136f8:	f90017e1 	str	x1, [sp, #40]
  4136fc:	d2800001 	mov	x1, #0x0                   	// #0
	struct k_work_queue_config cfg = {
  413700:	f0000000 	adrp	x0, 416000 <__func__.0+0x9cb>
  413704:	912a7c00 	add	x0, x0, #0xa9f
  413708:	f9000fe0 	str	x0, [sp, #24]
	k_work_queue_start(&k_sys_work_q,
  41370c:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  413710:	f00000e1 	adrp	x1, 432000 <ztest_thread_stack+0x2f8>
  413714:	91302021 	add	x1, x1, #0xc08
	struct k_work_queue_config cfg = {
  413718:	390083ff 	strb	wzr, [sp, #32]
	k_work_queue_start(&k_sys_work_q,
  41371c:	f947f400 	ldr	x0, [x0, #4072]
  413720:	97fff2ca 	bl	410248 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
  413724:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0xfd74>
  413728:	f9476800 	ldr	x0, [x0, #3792]
  41372c:	f94017e2 	ldr	x2, [sp, #40]
  413730:	f9400001 	ldr	x1, [x0]
  413734:	eb010042 	subs	x2, x2, x1
  413738:	d2800001 	mov	x1, #0x0                   	// #0
  41373c:	54000040 	b.eq	413744 <k_sys_work_q_init+0x6c>  // b.none
  413740:	97ffb6f8 	bl	401320 <__stack_chk_fail@plt>
  413744:	52800000 	mov	w0, #0x0                   	// #0
  413748:	a8c37bfd 	ldp	x29, x30, [sp], #48
  41374c:	d65f03c0 	ret

Disassembly of section .fini:

0000000000413750 <_fini>:
  413750:	d503201f 	nop
  413754:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  413758:	910003fd 	mov	x29, sp
  41375c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  413760:	d65f03c0 	ret
