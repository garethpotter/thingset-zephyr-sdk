
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section .init:

0000000000401138 <_init>:
  401138:	d503201f 	nop
  40113c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  401140:	910003fd 	mov	x29, sp
  401144:	940003db 	bl	4020b0 <call_weak_fn>
  401148:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40114c:	d65f03c0 	ret

Disassembly of section .plt:

0000000000401150 <.plt>:
  401150:	a9bf7bf0 	stp	x16, x30, [sp, #-16]!
  401154:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401158:	f9461211 	ldr	x17, [x16, #3104]
  40115c:	91308210 	add	x16, x16, #0xc20
  401160:	d61f0220 	br	x17
  401164:	d503201f 	nop
  401168:	d503201f 	nop
  40116c:	d503201f 	nop

0000000000401170 <memcpy@plt>:
  401170:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401174:	f9461611 	ldr	x17, [x16, #3112]
  401178:	9130a210 	add	x16, x16, #0xc28
  40117c:	d61f0220 	br	x17

0000000000401180 <getcwd@plt>:
  401180:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401184:	f9461a11 	ldr	x17, [x16, #3120]
  401188:	9130c210 	add	x16, x16, #0xc30
  40118c:	d61f0220 	br	x17

0000000000401190 <strtoul@plt>:
  401190:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401194:	f9461e11 	ldr	x17, [x16, #3128]
  401198:	9130e210 	add	x16, x16, #0xc38
  40119c:	d61f0220 	br	x17

00000000004011a0 <strlen@plt>:
  4011a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4011a4:	f9462211 	ldr	x17, [x16, #3136]
  4011a8:	91310210 	add	x16, x16, #0xc40
  4011ac:	d61f0220 	br	x17

00000000004011b0 <exit@plt>:
  4011b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4011b4:	f9462611 	ldr	x17, [x16, #3144]
  4011b8:	91312210 	add	x16, x16, #0xc48
  4011bc:	d61f0220 	br	x17

00000000004011c0 <__libc_start_main@plt>:
  4011c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4011c4:	f9462a11 	ldr	x17, [x16, #3152]
  4011c8:	91314210 	add	x16, x16, #0xc50
  4011cc:	d61f0220 	br	x17

00000000004011d0 <strtoll@plt>:
  4011d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4011d4:	f9462e11 	ldr	x17, [x16, #3160]
  4011d8:	91316210 	add	x16, x16, #0xc58
  4011dc:	d61f0220 	br	x17

00000000004011e0 <strnlen@plt>:
  4011e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4011e4:	f9463211 	ldr	x17, [x16, #3168]
  4011e8:	91318210 	add	x16, x16, #0xc60
  4011ec:	d61f0220 	br	x17

00000000004011f0 <strtod@plt>:
  4011f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4011f4:	f9463611 	ldr	x17, [x16, #3176]
  4011f8:	9131a210 	add	x16, x16, #0xc68
  4011fc:	d61f0220 	br	x17

0000000000401200 <__sigsetjmp@plt>:
  401200:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401204:	f9463a11 	ldr	x17, [x16, #3184]
  401208:	9131c210 	add	x16, x16, #0xc70
  40120c:	d61f0220 	br	x17

0000000000401210 <__cxa_finalize@plt>:
  401210:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401214:	f9463e11 	ldr	x17, [x16, #3192]
  401218:	9131e210 	add	x16, x16, #0xc78
  40121c:	d61f0220 	br	x17

0000000000401220 <clock_gettime@plt>:
  401220:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401224:	f9464211 	ldr	x17, [x16, #3200]
  401228:	91320210 	add	x16, x16, #0xc80
  40122c:	d61f0220 	br	x17

0000000000401230 <setvbuf@plt>:
  401230:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401234:	f9464611 	ldr	x17, [x16, #3208]
  401238:	91322210 	add	x16, x16, #0xc88
  40123c:	d61f0220 	br	x17

0000000000401240 <snprintf@plt>:
  401240:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401244:	f9464a11 	ldr	x17, [x16, #3216]
  401248:	91324210 	add	x16, x16, #0xc90
  40124c:	d61f0220 	br	x17

0000000000401250 <__memcpy_chk@plt>:
  401250:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401254:	f9464e11 	ldr	x17, [x16, #3224]
  401258:	91326210 	add	x16, x16, #0xc98
  40125c:	d61f0220 	br	x17

0000000000401260 <__snprintf_chk@plt>:
  401260:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401264:	f9465211 	ldr	x17, [x16, #3232]
  401268:	91328210 	add	x16, x16, #0xca0
  40126c:	d61f0220 	br	x17

0000000000401270 <strtok_r@plt>:
  401270:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401274:	f9465611 	ldr	x17, [x16, #3240]
  401278:	9132a210 	add	x16, x16, #0xca8
  40127c:	d61f0220 	br	x17

0000000000401280 <sigemptyset@plt>:
  401280:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401284:	f9465a11 	ldr	x17, [x16, #3248]
  401288:	9132c210 	add	x16, x16, #0xcb0
  40128c:	d61f0220 	br	x17

0000000000401290 <strncmp@plt>:
  401290:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401294:	f9465e11 	ldr	x17, [x16, #3256]
  401298:	9132e210 	add	x16, x16, #0xcb8
  40129c:	d61f0220 	br	x17

00000000004012a0 <memset@plt>:
  4012a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4012a4:	f9466211 	ldr	x17, [x16, #3264]
  4012a8:	91330210 	add	x16, x16, #0xcc0
  4012ac:	d61f0220 	br	x17

00000000004012b0 <sleep@plt>:
  4012b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4012b4:	f9466611 	ldr	x17, [x16, #3272]
  4012b8:	91332210 	add	x16, x16, #0xcc8
  4012bc:	d61f0220 	br	x17

00000000004012c0 <__vfprintf_chk@plt>:
  4012c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4012c4:	f9466a11 	ldr	x17, [x16, #3280]
  4012c8:	91334210 	add	x16, x16, #0xcd0
  4012cc:	d61f0220 	br	x17

00000000004012d0 <calloc@plt>:
  4012d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4012d4:	f9466e11 	ldr	x17, [x16, #3288]
  4012d8:	91336210 	add	x16, x16, #0xcd8
  4012dc:	d61f0220 	br	x17

00000000004012e0 <pthread_cond_broadcast@plt>:
  4012e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4012e4:	f9467211 	ldr	x17, [x16, #3296]
  4012e8:	91338210 	add	x16, x16, #0xce0
  4012ec:	d61f0220 	br	x17

00000000004012f0 <strcasecmp@plt>:
  4012f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4012f4:	f9467611 	ldr	x17, [x16, #3304]
  4012f8:	9133a210 	add	x16, x16, #0xce8
  4012fc:	d61f0220 	br	x17

0000000000401300 <realloc@plt>:
  401300:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401304:	f9467a11 	ldr	x17, [x16, #3312]
  401308:	9133c210 	add	x16, x16, #0xcf0
  40130c:	d61f0220 	br	x17

0000000000401310 <strdup@plt>:
  401310:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401314:	f9467e11 	ldr	x17, [x16, #3320]
  401318:	9133e210 	add	x16, x16, #0xcf8
  40131c:	d61f0220 	br	x17

0000000000401320 <__stack_chk_fail@plt>:
  401320:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401324:	f9468211 	ldr	x17, [x16, #3328]
  401328:	91340210 	add	x16, x16, #0xd00
  40132c:	d61f0220 	br	x17

0000000000401330 <sigaction@plt>:
  401330:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401334:	f9468611 	ldr	x17, [x16, #3336]
  401338:	91342210 	add	x16, x16, #0xd08
  40133c:	d61f0220 	br	x17

0000000000401340 <__gmon_start__@plt>:
  401340:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401344:	f9468a11 	ldr	x17, [x16, #3344]
  401348:	91344210 	add	x16, x16, #0xd10
  40134c:	d61f0220 	br	x17

0000000000401350 <__getauxval@plt>:
  401350:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401354:	f9468e11 	ldr	x17, [x16, #3352]
  401358:	91346210 	add	x16, x16, #0xd18
  40135c:	d61f0220 	br	x17

0000000000401360 <abort@plt>:
  401360:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401364:	f9469211 	ldr	x17, [x16, #3360]
  401368:	91348210 	add	x16, x16, #0xd20
  40136c:	d61f0220 	br	x17

0000000000401370 <pthread_exit@plt>:
  401370:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401374:	f9469611 	ldr	x17, [x16, #3368]
  401378:	9134a210 	add	x16, x16, #0xd28
  40137c:	d61f0220 	br	x17

0000000000401380 <memcmp@plt>:
  401380:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401384:	f9469a11 	ldr	x17, [x16, #3376]
  401388:	9134c210 	add	x16, x16, #0xd30
  40138c:	d61f0220 	br	x17

0000000000401390 <__fprintf_chk@plt>:
  401390:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401394:	f9469e11 	ldr	x17, [x16, #3384]
  401398:	9134e210 	add	x16, x16, #0xd38
  40139c:	d61f0220 	br	x17

00000000004013a0 <strcmp@plt>:
  4013a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4013a4:	f946a211 	ldr	x17, [x16, #3392]
  4013a8:	91350210 	add	x16, x16, #0xd40
  4013ac:	d61f0220 	br	x17

00000000004013b0 <__ctype_b_loc@plt>:
  4013b0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4013b4:	f946a611 	ldr	x17, [x16, #3400]
  4013b8:	91352210 	add	x16, x16, #0xd48
  4013bc:	d61f0220 	br	x17

00000000004013c0 <pthread_detach@plt>:
  4013c0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4013c4:	f946aa11 	ldr	x17, [x16, #3408]
  4013c8:	91354210 	add	x16, x16, #0xd50
  4013cc:	d61f0220 	br	x17

00000000004013d0 <strtol@plt>:
  4013d0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4013d4:	f946ae11 	ldr	x17, [x16, #3416]
  4013d8:	91356210 	add	x16, x16, #0xd58
  4013dc:	d61f0220 	br	x17

00000000004013e0 <free@plt>:
  4013e0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4013e4:	f946b211 	ldr	x17, [x16, #3424]
  4013e8:	91358210 	add	x16, x16, #0xd60
  4013ec:	d61f0220 	br	x17

00000000004013f0 <pthread_cond_wait@plt>:
  4013f0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4013f4:	f946b611 	ldr	x17, [x16, #3432]
  4013f8:	9135a210 	add	x16, x16, #0xd68
  4013fc:	d61f0220 	br	x17

0000000000401400 <nanosleep@plt>:
  401400:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401404:	f946ba11 	ldr	x17, [x16, #3440]
  401408:	9135c210 	add	x16, x16, #0xd70
  40140c:	d61f0220 	br	x17

0000000000401410 <__pthread_unwind_next@plt>:
  401410:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401414:	f946be11 	ldr	x17, [x16, #3448]
  401418:	9135e210 	add	x16, x16, #0xd78
  40141c:	d61f0220 	br	x17

0000000000401420 <strtoull@plt>:
  401420:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401424:	f946c211 	ldr	x17, [x16, #3456]
  401428:	91360210 	add	x16, x16, #0xd80
  40142c:	d61f0220 	br	x17

0000000000401430 <pthread_create@plt>:
  401430:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401434:	f946c611 	ldr	x17, [x16, #3464]
  401438:	91362210 	add	x16, x16, #0xd88
  40143c:	d61f0220 	br	x17

0000000000401440 <isatty@plt>:
  401440:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401444:	f946ca11 	ldr	x17, [x16, #3472]
  401448:	91364210 	add	x16, x16, #0xd90
  40144c:	d61f0220 	br	x17

0000000000401450 <strncpy@plt>:
  401450:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401454:	f946ce11 	ldr	x17, [x16, #3480]
  401458:	91366210 	add	x16, x16, #0xd98
  40145c:	d61f0220 	br	x17

0000000000401460 <__pthread_register_cancel@plt>:
  401460:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401464:	f946d211 	ldr	x17, [x16, #3488]
  401468:	91368210 	add	x16, x16, #0xda0
  40146c:	d61f0220 	br	x17

0000000000401470 <pthread_self@plt>:
  401470:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401474:	f946d611 	ldr	x17, [x16, #3496]
  401478:	9136a210 	add	x16, x16, #0xda8
  40147c:	d61f0220 	br	x17

0000000000401480 <pthread_cancel@plt>:
  401480:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401484:	f946da11 	ldr	x17, [x16, #3504]
  401488:	9136c210 	add	x16, x16, #0xdb0
  40148c:	d61f0220 	br	x17

0000000000401490 <pthread_mutex_lock@plt>:
  401490:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  401494:	f946de11 	ldr	x17, [x16, #3512]
  401498:	9136e210 	add	x16, x16, #0xdb8
  40149c:	d61f0220 	br	x17

00000000004014a0 <pthread_mutex_unlock@plt>:
  4014a0:	d0000150 	adrp	x16, 42b000 <__FRAME_END__+0x1007c>
  4014a4:	f946e211 	ldr	x17, [x16, #3520]
  4014a8:	91370210 	add	x16, x16, #0xdc0
  4014ac:	d61f0220 	br	x17

Disassembly of section .text:

00000000004014c0 <init_have_lse_atomics>:
  4014c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4014c4:	d2800200 	mov	x0, #0x10                  	// #16
  4014c8:	910003fd 	mov	x29, sp
  4014cc:	97ffffa1 	bl	401350 <__getauxval@plt>
  4014d0:	53082000 	ubfx	w0, w0, #8, #1
  4014d4:	b0000161 	adrp	x1, 42e000 <des_frames+0x27>
  4014d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4014dc:	39102c20 	strb	w0, [x1, #1035]
  4014e0:	d65f03c0 	ret
  4014e4:	d503201f 	nop
  4014e8:	d503201f 	nop
  4014ec:	d503201f 	nop
  4014f0:	d503201f 	nop
  4014f4:	d503201f 	nop
  4014f8:	d503201f 	nop
  4014fc:	d503201f 	nop

0000000000401500 <_start>:
  401500:	d503201f 	nop
  401504:	d280001d 	mov	x29, #0x0                   	// #0
  401508:	d280001e 	mov	x30, #0x0                   	// #0
  40150c:	aa0003e5 	mov	x5, x0
  401510:	f94003e1 	ldr	x1, [sp]
  401514:	910023e2 	add	x2, sp, #0x8
  401518:	910003e6 	mov	x6, sp
  40151c:	d0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  401520:	f947a400 	ldr	x0, [x0, #3912]
  401524:	d2800003 	mov	x3, #0x0                   	// #0
  401528:	d2800004 	mov	x4, #0x0                   	// #0
  40152c:	97ffff25 	bl	4011c0 <__libc_start_main@plt>
  401530:	97ffff8c 	bl	401360 <abort@plt>
  401534:	d503201f 	nop
  401538:	d503201f 	nop
  40153c:	d503201f 	nop

0000000000401540 <deregister_tm_clones>:
  401540:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  401544:	91106000 	add	x0, x0, #0x418
  401548:	f0000141 	adrp	x1, 42c000 <__dso_handle>
  40154c:	91106021 	add	x1, x1, #0x418
  401550:	eb00003f 	cmp	x1, x0
  401554:	540000c0 	b.eq	40156c <deregister_tm_clones+0x2c>  // b.none
  401558:	d0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40155c:	f946ec21 	ldr	x1, [x1, #3544]
  401560:	b4000061 	cbz	x1, 40156c <deregister_tm_clones+0x2c>
  401564:	aa0103f0 	mov	x16, x1
  401568:	d61f0200 	br	x16
  40156c:	d65f03c0 	ret

0000000000401570 <register_tm_clones>:
  401570:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  401574:	91106000 	add	x0, x0, #0x418
  401578:	f0000141 	adrp	x1, 42c000 <__dso_handle>
  40157c:	91106021 	add	x1, x1, #0x418
  401580:	cb000021 	sub	x1, x1, x0
  401584:	d37ffc22 	lsr	x2, x1, #63
  401588:	8b810c41 	add	x1, x2, x1, asr #3
  40158c:	9341fc21 	asr	x1, x1, #1
  401590:	b40000c1 	cbz	x1, 4015a8 <register_tm_clones+0x38>
  401594:	d0000142 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
  401598:	f947dc42 	ldr	x2, [x2, #4024]
  40159c:	b4000062 	cbz	x2, 4015a8 <register_tm_clones+0x38>
  4015a0:	aa0203f0 	mov	x16, x2
  4015a4:	d61f0200 	br	x16
  4015a8:	d65f03c0 	ret
  4015ac:	d503201f 	nop

00000000004015b0 <__do_global_dtors_aux>:
  4015b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4015b4:	910003fd 	mov	x29, sp
  4015b8:	f9000bf3 	str	x19, [sp, #16]
  4015bc:	90000173 	adrp	x19, 42d000 <counter_value>
  4015c0:	397d6260 	ldrb	w0, [x19, #3928]
  4015c4:	35000140 	cbnz	w0, 4015ec <__do_global_dtors_aux+0x3c>
  4015c8:	d0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4015cc:	f9470800 	ldr	x0, [x0, #3600]
  4015d0:	b4000080 	cbz	x0, 4015e0 <__do_global_dtors_aux+0x30>
  4015d4:	f0000140 	adrp	x0, 42c000 <__dso_handle>
  4015d8:	f9400000 	ldr	x0, [x0]
  4015dc:	97ffff0d 	bl	401210 <__cxa_finalize@plt>
  4015e0:	97ffffd8 	bl	401540 <deregister_tm_clones>
  4015e4:	52800020 	mov	w0, #0x1                   	// #1
  4015e8:	393d6260 	strb	w0, [x19, #3928]
  4015ec:	f9400bf3 	ldr	x19, [sp, #16]
  4015f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4015f4:	d65f03c0 	ret
  4015f8:	d503201f 	nop
  4015fc:	d503201f 	nop

0000000000401600 <frame_dummy>:
  401600:	17ffffdc 	b	401570 <register_tm_clones>
  401604:	d503201f 	nop
  401608:	d503201f 	nop
  40160c:	d503201f 	nop

0000000000401610 <__aarch64_ldadd8_acq_rel>:
  401610:	d503245f 	bti	c
  401614:	b0000170 	adrp	x16, 42e000 <des_frames+0x27>
  401618:	39502e10 	ldrb	w16, [x16, #1035]
  40161c:	34000070 	cbz	w16, 401628 <__aarch64_ldadd8_acq_rel+0x18>
  401620:	f8e00020 	ldaddal	x0, x0, [x1]
  401624:	d65f03c0 	ret
  401628:	aa0003f0 	mov	x16, x0
  40162c:	c85ffc20 	ldaxr	x0, [x1]
  401630:	8b100011 	add	x17, x0, x16
  401634:	c80ffc31 	stlxr	w15, x17, [x1]
  401638:	35ffffaf 	cbnz	w15, 40162c <__aarch64_ldadd8_acq_rel+0x1c>
  40163c:	d65f03c0 	ret

0000000000401640 <__divtf3>:
  401640:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  401644:	910003fd 	mov	x29, sp
  401648:	3d8007e0 	str	q0, [sp, #16]
  40164c:	3d800be1 	str	q1, [sp, #32]
  401650:	a94103e1 	ldp	x1, x0, [sp, #16]
  401654:	a9420fe6 	ldp	x6, x3, [sp, #32]
  401658:	d53b440c 	mrs	x12, fpcr
  40165c:	d37ffc04 	lsr	x4, x0, #63
  401660:	d340bc02 	ubfx	x2, x0, #0, #48
  401664:	12001c8d 	and	w13, w4, #0xff
  401668:	aa0403ea 	mov	x10, x4
  40166c:	d370f808 	ubfx	x8, x0, #48, #15
  401670:	34001ee8 	cbz	w8, 401a4c <__divtf3+0x40c>
  401674:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401678:	6b04011f 	cmp	w8, w4
  40167c:	540020c0 	b.eq	401a94 <__divtf3+0x454>  // b.none
  401680:	92403d08 	and	x8, x8, #0xffff
  401684:	93c1f442 	extr	x2, x2, x1, #61
  401688:	9287ffce 	mov	x14, #0xffffffffffffc001    	// #-16383
  40168c:	d37df021 	lsl	x1, x1, #3
  401690:	8b0e0108 	add	x8, x8, x14
  401694:	b24d0045 	orr	x5, x2, #0x8000000000000
  401698:	d2800010 	mov	x16, #0x0                   	// #0
  40169c:	d2800002 	mov	x2, #0x0                   	// #0
  4016a0:	52800000 	mov	w0, #0x0                   	// #0
  4016a4:	d37ffc64 	lsr	x4, x3, #63
  4016a8:	d340bc67 	ubfx	x7, x3, #0, #48
  4016ac:	12001c8f 	and	w15, w4, #0xff
  4016b0:	aa0403e9 	mov	x9, x4
  4016b4:	d370f864 	ubfx	x4, x3, #48, #15
  4016b8:	34001a04 	cbz	w4, 4019f8 <__divtf3+0x3b8>
  4016bc:	528fffeb 	mov	w11, #0x7fff                	// #32767
  4016c0:	6b0b009f 	cmp	w4, w11
  4016c4:	54001f80 	b.eq	401ab4 <__divtf3+0x474>  // b.none
  4016c8:	9287ffcb 	mov	x11, #0xffffffffffffc001    	// #-16383
  4016cc:	92403c84 	and	x4, x4, #0xffff
  4016d0:	8b0b0084 	add	x4, x4, x11
  4016d4:	93c6f4e7 	extr	x7, x7, x6, #61
  4016d8:	4a0f01ab 	eor	w11, w13, w15
  4016dc:	b24d00e7 	orr	x7, x7, #0x8000000000000
  4016e0:	cb040108 	sub	x8, x8, x4
  4016e4:	d37df0c6 	lsl	x6, x6, #3
  4016e8:	92401d6e 	and	x14, x11, #0xff
  4016ec:	d2800003 	mov	x3, #0x0                   	// #0
  4016f0:	f100245f 	cmp	x2, #0x9
  4016f4:	5400046c 	b.gt	401780 <__divtf3+0x140>
  4016f8:	f1001c5f 	cmp	x2, #0x7
  4016fc:	54002bcc 	b.gt	401c74 <__divtf3+0x634>
  401700:	f1000c5f 	cmp	x2, #0x3
  401704:	540000e0 	b.eq	401720 <__divtf3+0xe0>  // b.none
  401708:	5400050d 	b.le	4017a8 <__divtf3+0x168>
  40170c:	f100145f 	cmp	x2, #0x5
  401710:	54000400 	b.eq	401790 <__divtf3+0x150>  // b.none
  401714:	5400080d 	b.le	401814 <__divtf3+0x1d4>
  401718:	f100185f 	cmp	x2, #0x6
  40171c:	54000640 	b.eq	4017e4 <__divtf3+0x1a4>  // b.none
  401720:	f100047f 	cmp	x3, #0x1
  401724:	54002780 	b.eq	401c14 <__divtf3+0x5d4>  // b.none
  401728:	b40000a3 	cbz	x3, 40173c <__divtf3+0xfc>
  40172c:	f100087f 	cmp	x3, #0x2
  401730:	54003260 	b.eq	401d7c <__divtf3+0x73c>  // b.none
  401734:	f1000c7f 	cmp	x3, #0x3
  401738:	54003160 	b.eq	401d64 <__divtf3+0x724>  // b.none
  40173c:	d287ffe1 	mov	x1, #0x3fff                	// #16383
  401740:	8b010104 	add	x4, x8, x1
  401744:	f100009f 	cmp	x4, #0x0
  401748:	5400222d 	b.le	401b8c <__divtf3+0x54c>
  40174c:	f24008df 	tst	x6, #0x7
  401750:	540026c1 	b.ne	401c28 <__divtf3+0x5e8>  // b.any
  401754:	1200012b 	and	w11, w9, #0x1
  401758:	b6a00067 	tbz	x7, #52, 401764 <__divtf3+0x124>
  40175c:	924bf8e7 	and	x7, x7, #0xffefffffffffffff
  401760:	91401104 	add	x4, x8, #0x4, lsl #12
  401764:	d28fffc2 	mov	x2, #0x7ffe                	// #32766
  401768:	eb02009f 	cmp	x4, x2
  40176c:	54002cec 	b.gt	401d08 <__divtf3+0x6c8>
  401770:	d343c8e5 	ubfx	x5, x7, #3, #48
  401774:	93c60ce1 	extr	x1, x7, x6, #3
  401778:	12003884 	and	w4, w4, #0x7fff
  40177c:	1400001d 	b	4017f0 <__divtf3+0x1b0>
  401780:	f1002c5f 	cmp	x2, #0xb
  401784:	54001c4c 	b.gt	401b0c <__divtf3+0x4cc>
  401788:	f100285f 	cmp	x2, #0xa
  40178c:	54fffca1 	b.ne	401720 <__divtf3+0xe0>  // b.any
  401790:	5280000b 	mov	w11, #0x0                   	// #0
  401794:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401798:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40179c:	52800020 	mov	w0, #0x1                   	// #1
  4017a0:	528fffe4 	mov	w4, #0x7fff                	// #32767
  4017a4:	14000013 	b	4017f0 <__divtf3+0x1b0>
  4017a8:	f100045f 	cmp	x2, #0x1
  4017ac:	54000181 	b.ne	4017dc <__divtf3+0x19c>  // b.any
  4017b0:	d2800002 	mov	x2, #0x0                   	// #0
  4017b4:	9e670040 	fmov	d0, x2
  4017b8:	d34101ce 	lsl	x14, x14, #63
  4017bc:	321f0000 	orr	w0, w0, #0x2
  4017c0:	b25039c3 	orr	x3, x14, #0x7fff000000000000
  4017c4:	9eaf0060 	fmov	v0.d[1], x3
  4017c8:	3d8007e0 	str	q0, [sp, #16]
  4017cc:	9400021d 	bl	402040 <__sfp_handle_exceptions>
  4017d0:	3dc007e0 	ldr	q0, [sp, #16]
  4017d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4017d8:	d65f03c0 	ret
  4017dc:	f100085f 	cmp	x2, #0x2
  4017e0:	540001e1 	b.ne	40181c <__divtf3+0x1dc>  // b.any
  4017e4:	52800004 	mov	w4, #0x0                   	// #0
  4017e8:	d2800005 	mov	x5, #0x0                   	// #0
  4017ec:	d2800001 	mov	x1, #0x0                   	// #0
  4017f0:	d2800003 	mov	x3, #0x0                   	// #0
  4017f4:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  4017f8:	b340bca3 	bfxil	x3, x5, #0, #48
  4017fc:	9e670020 	fmov	d0, x1
  401800:	b3503c83 	bfi	x3, x4, #48, #16
  401804:	9eaf0060 	fmov	v0.d[1], x3
  401808:	35fffe00 	cbnz	w0, 4017c8 <__divtf3+0x188>
  40180c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  401810:	d65f03c0 	ret
  401814:	f100105f 	cmp	x2, #0x4
  401818:	54fffe60 	b.eq	4017e4 <__divtf3+0x1a4>  // b.none
  40181c:	eb0700bf 	cmp	x5, x7
  401820:	54000068 	b.hi	40182c <__divtf3+0x1ec>  // b.pmore
  401824:	fa4100c2 	ccmp	x6, x1, #0x2, eq  // eq = none
  401828:	54002da8 	b.hi	401ddc <__divtf3+0x79c>  // b.pmore
  40182c:	d341fca3 	lsr	x3, x5, #1
  401830:	93c104a2 	extr	x2, x5, x1, #1
  401834:	d3410021 	lsl	x1, x1, #63
  401838:	d354cce9 	ubfx	x9, x7, #20, #32
  40183c:	93c6d0e4 	extr	x4, x7, x6, #52
  401840:	92407c8a 	and	x10, x4, #0xffffffff
  401844:	d374ccc5 	lsl	x5, x6, #12
  401848:	9ac90867 	udiv	x7, x3, x9
  40184c:	9b098ce3 	msub	x3, x7, x9, x3
  401850:	9b077d46 	mul	x6, x10, x7
  401854:	93c28063 	extr	x3, x3, x2, #32
  401858:	eb0300df 	cmp	x6, x3
  40185c:	540000c9 	b.ls	401874 <__divtf3+0x234>  // b.plast
  401860:	ab030083 	adds	x3, x4, x3
  401864:	d10004ed 	sub	x13, x7, #0x1
  401868:	fa4330c0 	ccmp	x6, x3, #0x0, cc  // cc = lo, ul, last
  40186c:	54003088 	b.hi	401e7c <__divtf3+0x83c>  // b.pmore
  401870:	aa0d03e7 	mov	x7, x13
  401874:	cb060063 	sub	x3, x3, x6
  401878:	9ac90866 	udiv	x6, x3, x9
  40187c:	9b098cc3 	msub	x3, x6, x9, x3
  401880:	9b067d50 	mul	x16, x10, x6
  401884:	b3607c62 	bfi	x2, x3, #32, #32
  401888:	eb02021f 	cmp	x16, x2
  40188c:	540000c9 	b.ls	4018a4 <__divtf3+0x264>  // b.plast
  401890:	ab020082 	adds	x2, x4, x2
  401894:	d10004c3 	sub	x3, x6, #0x1
  401898:	fa423200 	ccmp	x16, x2, #0x0, cc  // cc = lo, ul, last
  40189c:	54002ea8 	b.hi	401e70 <__divtf3+0x830>  // b.pmore
  4018a0:	aa0303e6 	mov	x6, x3
  4018a4:	aa0780d1 	orr	x17, x6, x7, lsl #32
  4018a8:	92407caf 	and	x15, x5, #0xffffffff
  4018ac:	92407e27 	and	x7, x17, #0xffffffff
  4018b0:	d360fcad 	lsr	x13, x5, #32
  4018b4:	d360fe26 	lsr	x6, x17, #32
  4018b8:	cb100042 	sub	x2, x2, x16
  4018bc:	d2c00032 	mov	x18, #0x100000000           	// #4294967296
  4018c0:	9b0f7ce3 	mul	x3, x7, x15
  4018c4:	9b0f7cde 	mul	x30, x6, x15
  4018c8:	9b0779a7 	madd	x7, x13, x7, x30
  4018cc:	92407c70 	and	x16, x3, #0xffffffff
  4018d0:	9b0d7cc6 	mul	x6, x6, x13
  4018d4:	8b4380e3 	add	x3, x7, x3, lsr #32
  4018d8:	8b1200c7 	add	x7, x6, x18
  4018dc:	eb0303df 	cmp	x30, x3
  4018e0:	9a8680e6 	csel	x6, x7, x6, hi  // hi = pmore
  4018e4:	8b038210 	add	x16, x16, x3, lsl #32
  4018e8:	8b4380c3 	add	x3, x6, x3, lsr #32
  4018ec:	eb03005f 	cmp	x2, x3
  4018f0:	54001ca3 	b.cc	401c84 <__divtf3+0x644>  // b.lo, b.ul, b.last
  4018f4:	fa500022 	ccmp	x1, x16, #0x2, eq  // eq = none
  4018f8:	aa1103e7 	mov	x7, x17
  4018fc:	54001c43 	b.cc	401c84 <__divtf3+0x644>  // b.lo, b.ul, b.last
  401900:	eb100021 	subs	x1, x1, x16
  401904:	da030042 	sbc	x2, x2, x3
  401908:	eb02009f 	cmp	x4, x2
  40190c:	54002be0 	b.eq	401e88 <__divtf3+0x848>  // b.none
  401910:	9ac90846 	udiv	x6, x2, x9
  401914:	9b0988c2 	msub	x2, x6, x9, x2
  401918:	9b067d43 	mul	x3, x10, x6
  40191c:	93c18042 	extr	x2, x2, x1, #32
  401920:	eb02007f 	cmp	x3, x2
  401924:	540000c9 	b.ls	40193c <__divtf3+0x2fc>  // b.plast
  401928:	ab020082 	adds	x2, x4, x2
  40192c:	d10004cb 	sub	x11, x6, #0x1
  401930:	fa423060 	ccmp	x3, x2, #0x0, cc  // cc = lo, ul, last
  401934:	540030e8 	b.hi	401f50 <__divtf3+0x910>  // b.pmore
  401938:	aa0b03e6 	mov	x6, x11
  40193c:	cb030042 	sub	x2, x2, x3
  401940:	9ac90843 	udiv	x3, x2, x9
  401944:	9b098869 	msub	x9, x3, x9, x2
  401948:	9b037d4a 	mul	x10, x10, x3
  40194c:	b3607d21 	bfi	x1, x9, #32, #32
  401950:	eb01015f 	cmp	x10, x1
  401954:	540000c9 	b.ls	40196c <__divtf3+0x32c>  // b.plast
  401958:	ab010081 	adds	x1, x4, x1
  40195c:	d1000462 	sub	x2, x3, #0x1
  401960:	fa413140 	ccmp	x10, x1, #0x0, cc  // cc = lo, ul, last
  401964:	54002f08 	b.hi	401f44 <__divtf3+0x904>  // b.pmore
  401968:	aa0203e3 	mov	x3, x2
  40196c:	aa068066 	orr	x6, x3, x6, lsl #32
  401970:	cb0a0021 	sub	x1, x1, x10
  401974:	92407cc3 	and	x3, x6, #0xffffffff
  401978:	d2c0002b 	mov	x11, #0x100000000           	// #4294967296
  40197c:	d360fcca 	lsr	x10, x6, #32
  401980:	9b037de2 	mul	x2, x15, x3
  401984:	9b0f7d4f 	mul	x15, x10, x15
  401988:	9b033da3 	madd	x3, x13, x3, x15
  40198c:	92407c49 	and	x9, x2, #0xffffffff
  401990:	9b0a7dad 	mul	x13, x13, x10
  401994:	8b428062 	add	x2, x3, x2, lsr #32
  401998:	8b0b01a3 	add	x3, x13, x11
  40199c:	eb0201ff 	cmp	x15, x2
  4019a0:	9a8d806d 	csel	x13, x3, x13, hi  // hi = pmore
  4019a4:	8b028123 	add	x3, x9, x2, lsl #32
  4019a8:	8b4281a2 	add	x2, x13, x2, lsr #32
  4019ac:	eb02003f 	cmp	x1, x2
  4019b0:	54002042 	b.cs	401db8 <__divtf3+0x778>  // b.hs, b.nlast
  4019b4:	ab010089 	adds	x9, x4, x1
  4019b8:	d10004ca 	sub	x10, x6, #0x1
  4019bc:	aa0903e1 	mov	x1, x9
  4019c0:	540000a2 	b.cs	4019d4 <__divtf3+0x394>  // b.hs, b.nlast
  4019c4:	eb02013f 	cmp	x9, x2
  4019c8:	54002823 	b.cc	401ecc <__divtf3+0x88c>  // b.lo, b.ul, b.last
  4019cc:	fa4300a2 	ccmp	x5, x3, #0x2, eq  // eq = none
  4019d0:	540027e3 	b.cc	401ecc <__divtf3+0x88c>  // b.lo, b.ul, b.last
  4019d4:	eb0300bf 	cmp	x5, x3
  4019d8:	aa0a03e6 	mov	x6, x10
  4019dc:	1a9f07e9 	cset	w9, ne  // ne = any
  4019e0:	7100013f 	cmp	w9, #0x0
  4019e4:	aa0e03e9 	mov	x9, x14
  4019e8:	fa420020 	ccmp	x1, x2, #0x0, eq  // eq = none
  4019ec:	b24000c1 	orr	x1, x6, #0x1
  4019f0:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  4019f4:	17ffff52 	b	40173c <__divtf3+0xfc>
  4019f8:	aa0700c3 	orr	x3, x6, x7
  4019fc:	b4000b63 	cbz	x3, 401b68 <__divtf3+0x528>
  401a00:	b4001707 	cbz	x7, 401ce0 <__divtf3+0x6a0>
  401a04:	dac010e3 	clz	x3, x7
  401a08:	d1003c64 	sub	x4, x3, #0xf
  401a0c:	11000c8e 	add	w14, w4, #0x3
  401a10:	528007ab 	mov	w11, #0x3d                  	// #61
  401a14:	4b040164 	sub	w4, w11, w4
  401a18:	9ace20e7 	lsl	x7, x7, x14
  401a1c:	9ac424c4 	lsr	x4, x6, x4
  401a20:	aa070087 	orr	x7, x4, x7
  401a24:	9ace20c6 	lsl	x6, x6, x14
  401a28:	8b080064 	add	x4, x3, x8
  401a2c:	4a0f01ab 	eor	w11, w13, w15
  401a30:	d287fde8 	mov	x8, #0x3fef                	// #16367
  401a34:	92401d6e 	and	x14, x11, #0xff
  401a38:	8b080088 	add	x8, x4, x8
  401a3c:	d2800003 	mov	x3, #0x0                   	// #0
  401a40:	f100245f 	cmp	x2, #0x9
  401a44:	54ffe5ad 	b.le	4016f8 <__divtf3+0xb8>
  401a48:	17ffff4e 	b	401780 <__divtf3+0x140>
  401a4c:	aa020025 	orr	x5, x1, x2
  401a50:	b4000805 	cbz	x5, 401b50 <__divtf3+0x510>
  401a54:	b4001342 	cbz	x2, 401cbc <__divtf3+0x67c>
  401a58:	dac01040 	clz	x0, x2
  401a5c:	d1003c05 	sub	x5, x0, #0xf
  401a60:	11000ca7 	add	w7, w5, #0x3
  401a64:	528007a4 	mov	w4, #0x3d                  	// #61
  401a68:	4b050084 	sub	w4, w4, w5
  401a6c:	9ac72042 	lsl	x2, x2, x7
  401a70:	9ac42424 	lsr	x4, x1, x4
  401a74:	aa020085 	orr	x5, x4, x2
  401a78:	9ac72021 	lsl	x1, x1, x7
  401a7c:	9287fdc8 	mov	x8, #0xffffffffffffc011    	// #-16367
  401a80:	d2800002 	mov	x2, #0x0                   	// #0
  401a84:	cb000108 	sub	x8, x8, x0
  401a88:	d2800010 	mov	x16, #0x0                   	// #0
  401a8c:	52800000 	mov	w0, #0x0                   	// #0
  401a90:	17ffff05 	b	4016a4 <__divtf3+0x64>
  401a94:	aa020025 	orr	x5, x1, x2
  401a98:	b50004e5 	cbnz	x5, 401b34 <__divtf3+0x4f4>
  401a9c:	d2800001 	mov	x1, #0x0                   	// #0
  401aa0:	d2800102 	mov	x2, #0x8                   	// #8
  401aa4:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401aa8:	d2800050 	mov	x16, #0x2                   	// #2
  401aac:	52800000 	mov	w0, #0x0                   	// #0
  401ab0:	17fffefd 	b	4016a4 <__divtf3+0x64>
  401ab4:	928fffc3 	mov	x3, #0xffffffffffff8001    	// #-32767
  401ab8:	8b030108 	add	x8, x8, x3
  401abc:	aa0700c3 	orr	x3, x6, x7
  401ac0:	b4000303 	cbz	x3, 401b20 <__divtf3+0x4e0>
  401ac4:	f25100ff 	tst	x7, #0x800000000000
  401ac8:	b2400442 	orr	x2, x2, #0x3
  401acc:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
  401ad0:	d2800063 	mov	x3, #0x3                   	// #3
  401ad4:	4a0f01ab 	eor	w11, w13, w15
  401ad8:	92401d6e 	and	x14, x11, #0xff
  401adc:	f100245f 	cmp	x2, #0x9
  401ae0:	54ffe0cd 	b.le	4016f8 <__divtf3+0xb8>
  401ae4:	f1003c5f 	cmp	x2, #0xf
  401ae8:	54ffe4c1 	b.ne	401780 <__divtf3+0x140>  // b.any
  401aec:	b6780ba5 	tbz	x5, #47, 401c60 <__divtf3+0x620>
  401af0:	b7780b87 	tbnz	x7, #47, 401c60 <__divtf3+0x620>
  401af4:	b25100e5 	orr	x5, x7, #0x800000000000
  401af8:	2a0f03eb 	mov	w11, w15
  401afc:	9240bca5 	and	x5, x5, #0xffffffffffff
  401b00:	aa0603e1 	mov	x1, x6
  401b04:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401b08:	17ffff3a 	b	4017f0 <__divtf3+0x1b0>
  401b0c:	aa0503e7 	mov	x7, x5
  401b10:	aa0103e6 	mov	x6, x1
  401b14:	aa0a03e9 	mov	x9, x10
  401b18:	aa1003e3 	mov	x3, x16
  401b1c:	17ffff01 	b	401720 <__divtf3+0xe0>
  401b20:	b27f0042 	orr	x2, x2, #0x2
  401b24:	d2800007 	mov	x7, #0x0                   	// #0
  401b28:	d2800006 	mov	x6, #0x0                   	// #0
  401b2c:	d2800043 	mov	x3, #0x2                   	// #2
  401b30:	17ffffe9 	b	401ad4 <__divtf3+0x494>
  401b34:	d36ffc40 	lsr	x0, x2, #47
  401b38:	aa0203e5 	mov	x5, x2
  401b3c:	52000000 	eor	w0, w0, #0x1
  401b40:	d2800182 	mov	x2, #0xc                   	// #12
  401b44:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401b48:	d2800070 	mov	x16, #0x3                   	// #3
  401b4c:	17fffed6 	b	4016a4 <__divtf3+0x64>
  401b50:	d2800001 	mov	x1, #0x0                   	// #0
  401b54:	d2800082 	mov	x2, #0x4                   	// #4
  401b58:	d2800008 	mov	x8, #0x0                   	// #0
  401b5c:	d2800030 	mov	x16, #0x1                   	// #1
  401b60:	52800000 	mov	w0, #0x0                   	// #0
  401b64:	17fffed0 	b	4016a4 <__divtf3+0x64>
  401b68:	4a0f01ab 	eor	w11, w13, w15
  401b6c:	b2400042 	orr	x2, x2, #0x1
  401b70:	92401d6e 	and	x14, x11, #0xff
  401b74:	d2800007 	mov	x7, #0x0                   	// #0
  401b78:	d2800006 	mov	x6, #0x0                   	// #0
  401b7c:	d2800023 	mov	x3, #0x1                   	// #1
  401b80:	f100245f 	cmp	x2, #0x9
  401b84:	54ffdbad 	b.le	4016f8 <__divtf3+0xb8>
  401b88:	17fffefe 	b	401780 <__divtf3+0x140>
  401b8c:	d2800021 	mov	x1, #0x1                   	// #1
  401b90:	cb040024 	sub	x4, x1, x4
  401b94:	1200012b 	and	w11, w9, #0x1
  401b98:	f101d09f 	cmp	x4, #0x74
  401b9c:	5400102c 	b.gt	401da0 <__divtf3+0x760>
  401ba0:	f100fc9f 	cmp	x4, #0x3f
  401ba4:	5400126d 	b.le	401df0 <__divtf3+0x7b0>
  401ba8:	52801001 	mov	w1, #0x80                  	// #128
  401bac:	4b040021 	sub	w1, w1, w4
  401bb0:	f101009f 	cmp	x4, #0x40
  401bb4:	51010084 	sub	w4, w4, #0x40
  401bb8:	9ac120e1 	lsl	x1, x7, x1
  401bbc:	aa0100c1 	orr	x1, x6, x1
  401bc0:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  401bc4:	9ac424e1 	lsr	x1, x7, x4
  401bc8:	f10000df 	cmp	x6, #0x0
  401bcc:	9a9f07e2 	cset	x2, ne  // ne = any
  401bd0:	aa010041 	orr	x1, x2, x1
  401bd4:	f2400825 	ands	x5, x1, #0x7
  401bd8:	54001260 	b.eq	401e24 <__divtf3+0x7e4>  // b.none
  401bdc:	d2800005 	mov	x5, #0x0                   	// #0
  401be0:	926a058c 	and	x12, x12, #0xc00000
  401be4:	321c0000 	orr	w0, w0, #0x10
  401be8:	f150019f 	cmp	x12, #0x400, lsl #12
  401bec:	54001800 	b.eq	401eec <__divtf3+0x8ac>  // b.none
  401bf0:	f160019f 	cmp	x12, #0x800, lsl #12
  401bf4:	54001c80 	b.eq	401f84 <__divtf3+0x944>  // b.none
  401bf8:	b4001b8c 	cbz	x12, 401f68 <__divtf3+0x928>
  401bfc:	b7981805 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401c00:	321d0000 	orr	w0, w0, #0x8
  401c04:	93c10ca1 	extr	x1, x5, x1, #3
  401c08:	52800004 	mov	w4, #0x0                   	// #0
  401c0c:	d343c8a5 	ubfx	x5, x5, #3, #48
  401c10:	1400004b 	b	401d3c <__divtf3+0x6fc>
  401c14:	1200012b 	and	w11, w9, #0x1
  401c18:	52800004 	mov	w4, #0x0                   	// #0
  401c1c:	d2800005 	mov	x5, #0x0                   	// #0
  401c20:	d2800001 	mov	x1, #0x0                   	// #0
  401c24:	17fffef3 	b	4017f0 <__divtf3+0x1b0>
  401c28:	926a0581 	and	x1, x12, #0xc00000
  401c2c:	321c0000 	orr	w0, w0, #0x10
  401c30:	f150003f 	cmp	x1, #0x400, lsl #12
  401c34:	540017c0 	b.eq	401f2c <__divtf3+0x8ec>  // b.none
  401c38:	f160003f 	cmp	x1, #0x800, lsl #12
  401c3c:	540010e0 	b.eq	401e58 <__divtf3+0x818>  // b.none
  401c40:	b5ffd8a1 	cbnz	x1, 401754 <__divtf3+0x114>
  401c44:	92400cc1 	and	x1, x6, #0xf
  401c48:	1200012b 	and	w11, w9, #0x1
  401c4c:	f100103f 	cmp	x1, #0x4
  401c50:	54ffd840 	b.eq	401758 <__divtf3+0x118>  // b.none
  401c54:	b10010c6 	adds	x6, x6, #0x4
  401c58:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401c5c:	17fffebf 	b	401758 <__divtf3+0x118>
  401c60:	b25100a5 	orr	x5, x5, #0x800000000000
  401c64:	2a0d03eb 	mov	w11, w13
  401c68:	9240bca5 	and	x5, x5, #0xffffffffffff
  401c6c:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401c70:	17fffee0 	b	4017f0 <__divtf3+0x1b0>
  401c74:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401c78:	d2800005 	mov	x5, #0x0                   	// #0
  401c7c:	d2800001 	mov	x1, #0x0                   	// #0
  401c80:	17fffedc 	b	4017f0 <__divtf3+0x1b0>
  401c84:	ab050026 	adds	x6, x1, x5
  401c88:	d1000627 	sub	x7, x17, #0x1
  401c8c:	9a040042 	adc	x2, x2, x4
  401c90:	9a9f37f2 	cset	x18, cs  // cs = hs, nlast
  401c94:	aa0603e1 	mov	x1, x6
  401c98:	eb02009f 	cmp	x4, x2
  401c9c:	540007a2 	b.cs	401d90 <__divtf3+0x750>  // b.hs, b.nlast
  401ca0:	eb02007f 	cmp	x3, x2
  401ca4:	54000969 	b.ls	401dd0 <__divtf3+0x790>  // b.plast
  401ca8:	ab0600a6 	adds	x6, x5, x6
  401cac:	d1000a27 	sub	x7, x17, #0x2
  401cb0:	aa0603e1 	mov	x1, x6
  401cb4:	9a040042 	adc	x2, x2, x4
  401cb8:	17ffff12 	b	401900 <__divtf3+0x2c0>
  401cbc:	dac01020 	clz	x0, x1
  401cc0:	9100c405 	add	x5, x0, #0x31
  401cc4:	91010000 	add	x0, x0, #0x40
  401cc8:	f100f0bf 	cmp	x5, #0x3c
  401ccc:	54ffecad 	b.le	401a60 <__divtf3+0x420>
  401cd0:	5100f4a5 	sub	w5, w5, #0x3d
  401cd4:	9ac52025 	lsl	x5, x1, x5
  401cd8:	d2800001 	mov	x1, #0x0                   	// #0
  401cdc:	17ffff68 	b	401a7c <__divtf3+0x43c>
  401ce0:	dac010c3 	clz	x3, x6
  401ce4:	9100c464 	add	x4, x3, #0x31
  401ce8:	91010063 	add	x3, x3, #0x40
  401cec:	f100f09f 	cmp	x4, #0x3c
  401cf0:	54ffe8ed 	b.le	401a0c <__divtf3+0x3cc>
  401cf4:	5100f484 	sub	w4, w4, #0x3d
  401cf8:	9ac420c4 	lsl	x4, x6, x4
  401cfc:	d2800006 	mov	x6, #0x0                   	// #0
  401d00:	aa0403e7 	mov	x7, x4
  401d04:	17ffff49 	b	401a28 <__divtf3+0x3e8>
  401d08:	926a0581 	and	x1, x12, #0xc00000
  401d0c:	f150003f 	cmp	x1, #0x400, lsl #12
  401d10:	54001000 	b.eq	401f10 <__divtf3+0x8d0>  // b.none
  401d14:	f160003f 	cmp	x1, #0x800, lsl #12
  401d18:	54000920 	b.eq	401e3c <__divtf3+0x7fc>  // b.none
  401d1c:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d20:	d2800005 	mov	x5, #0x0                   	// #0
  401d24:	b4000081 	cbz	x1, 401d34 <__divtf3+0x6f4>
  401d28:	2a0203e4 	mov	w4, w2
  401d2c:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401d30:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  401d34:	52800282 	mov	w2, #0x14                  	// #20
  401d38:	2a020000 	orr	w0, w0, w2
  401d3c:	d2800003 	mov	x3, #0x0                   	// #0
  401d40:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  401d44:	b340bca3 	bfxil	x3, x5, #0, #48
  401d48:	9e670020 	fmov	d0, x1
  401d4c:	b3503c83 	bfi	x3, x4, #48, #16
  401d50:	9eaf0060 	fmov	v0.d[1], x3
  401d54:	3d8007e0 	str	q0, [sp, #16]
  401d58:	940000ba 	bl	402040 <__sfp_handle_exceptions>
  401d5c:	3dc007e0 	ldr	q0, [sp, #16]
  401d60:	17fffe9d 	b	4017d4 <__divtf3+0x194>
  401d64:	b25100e5 	orr	x5, x7, #0x800000000000
  401d68:	1200012b 	and	w11, w9, #0x1
  401d6c:	9240bca5 	and	x5, x5, #0xffffffffffff
  401d70:	aa0603e1 	mov	x1, x6
  401d74:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d78:	17fffe9e 	b	4017f0 <__divtf3+0x1b0>
  401d7c:	1200012b 	and	w11, w9, #0x1
  401d80:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d84:	d2800005 	mov	x5, #0x0                   	// #0
  401d88:	d2800001 	mov	x1, #0x0                   	// #0
  401d8c:	17fffe99 	b	4017f0 <__divtf3+0x1b0>
  401d90:	f100025f 	cmp	x18, #0x0
  401d94:	fa420080 	ccmp	x4, x2, #0x0, eq  // eq = none
  401d98:	54ffdb41 	b.ne	401900 <__divtf3+0x2c0>  // b.any
  401d9c:	17ffffc1 	b	401ca0 <__divtf3+0x660>
  401da0:	aa0700c1 	orr	x1, x6, x7
  401da4:	b5000861 	cbnz	x1, 401eb0 <__divtf3+0x870>
  401da8:	321d0000 	orr	w0, w0, #0x8
  401dac:	52800004 	mov	w4, #0x0                   	// #0
  401db0:	d2800005 	mov	x5, #0x0                   	// #0
  401db4:	17ffffe2 	b	401d3c <__divtf3+0x6fc>
  401db8:	f100007f 	cmp	x3, #0x0
  401dbc:	1a9f07e9 	cset	w9, ne  // ne = any
  401dc0:	7100013f 	cmp	w9, #0x0
  401dc4:	fa421020 	ccmp	x1, x2, #0x0, ne  // ne = any
  401dc8:	54ffe0c1 	b.ne	4019e0 <__divtf3+0x3a0>  // b.any
  401dcc:	17fffefa 	b	4019b4 <__divtf3+0x374>
  401dd0:	fa460200 	ccmp	x16, x6, #0x0, eq  // eq = none
  401dd4:	54ffd969 	b.ls	401900 <__divtf3+0x2c0>  // b.plast
  401dd8:	17ffffb4 	b	401ca8 <__divtf3+0x668>
  401ddc:	aa0103e2 	mov	x2, x1
  401de0:	d1000508 	sub	x8, x8, #0x1
  401de4:	aa0503e3 	mov	x3, x5
  401de8:	d2800001 	mov	x1, #0x0                   	// #0
  401dec:	17fffe93 	b	401838 <__divtf3+0x1f8>
  401df0:	52800801 	mov	w1, #0x40                  	// #64
  401df4:	4b040021 	sub	w1, w1, w4
  401df8:	9ac424c3 	lsr	x3, x6, x4
  401dfc:	9ac120c6 	lsl	x6, x6, x1
  401e00:	f10000df 	cmp	x6, #0x0
  401e04:	9a9f07e2 	cset	x2, ne  // ne = any
  401e08:	9ac120e1 	lsl	x1, x7, x1
  401e0c:	aa030021 	orr	x1, x1, x3
  401e10:	9ac424e5 	lsr	x5, x7, x4
  401e14:	aa020021 	orr	x1, x1, x2
  401e18:	f240083f 	tst	x1, #0x7
  401e1c:	54ffee21 	b.ne	401be0 <__divtf3+0x5a0>  // b.any
  401e20:	b7980b85 	tbnz	x5, #51, 401f90 <__divtf3+0x950>
  401e24:	52800004 	mov	w4, #0x0                   	// #0
  401e28:	93c10ca1 	extr	x1, x5, x1, #3
  401e2c:	d343c8a5 	ubfx	x5, x5, #3, #48
  401e30:	365fce0c 	tbz	w12, #11, 4017f0 <__divtf3+0x1b0>
  401e34:	321d0000 	orr	w0, w0, #0x8
  401e38:	17ffffc1 	b	401d3c <__divtf3+0x6fc>
  401e3c:	f100013f 	cmp	x9, #0x0
  401e40:	528fffe1 	mov	w1, #0x7fff                	// #32767
  401e44:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401e48:	1a810044 	csel	w4, w2, w1, eq  // eq = none
  401e4c:	9a9f00a5 	csel	x5, x5, xzr, eq  // eq = none
  401e50:	da9f13e1 	csetm	x1, eq  // eq = none
  401e54:	17ffffb8 	b	401d34 <__divtf3+0x6f4>
  401e58:	5280000b 	mov	w11, #0x0                   	// #0
  401e5c:	b4ffc7e9 	cbz	x9, 401758 <__divtf3+0x118>
  401e60:	b10020c6 	adds	x6, x6, #0x8
  401e64:	5280002b 	mov	w11, #0x1                   	// #1
  401e68:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401e6c:	17fffe3b 	b	401758 <__divtf3+0x118>
  401e70:	d10008c6 	sub	x6, x6, #0x2
  401e74:	8b040042 	add	x2, x2, x4
  401e78:	17fffe8b 	b	4018a4 <__divtf3+0x264>
  401e7c:	d10008e7 	sub	x7, x7, #0x2
  401e80:	8b040063 	add	x3, x3, x4
  401e84:	17fffe7c 	b	401874 <__divtf3+0x234>
  401e88:	d287ffe2 	mov	x2, #0x3fff                	// #16383
  401e8c:	8b020104 	add	x4, x8, x2
  401e90:	aa0e03e9 	mov	x9, x14
  401e94:	92800006 	mov	x6, #0xffffffffffffffff    	// #-1
  401e98:	f100009f 	cmp	x4, #0x0
  401e9c:	54ffec6c 	b.gt	401c28 <__divtf3+0x5e8>
  401ea0:	d2800021 	mov	x1, #0x1                   	// #1
  401ea4:	cb040024 	sub	x4, x1, x4
  401ea8:	f101d09f 	cmp	x4, #0x74
  401eac:	54ffe7ad 	b.le	401ba0 <__divtf3+0x560>
  401eb0:	926a058c 	and	x12, x12, #0xc00000
  401eb4:	321c0000 	orr	w0, w0, #0x10
  401eb8:	f150019f 	cmp	x12, #0x400, lsl #12
  401ebc:	54000500 	b.eq	401f5c <__divtf3+0x91c>  // b.none
  401ec0:	f160019f 	cmp	x12, #0x800, lsl #12
  401ec4:	9a9f0121 	csel	x1, x9, xzr, eq  // eq = none
  401ec8:	17ffffb8 	b	401da8 <__divtf3+0x768>
  401ecc:	d37ff8aa 	lsl	x10, x5, #1
  401ed0:	d10008c6 	sub	x6, x6, #0x2
  401ed4:	eb0a00bf 	cmp	x5, x10
  401ed8:	9a849481 	cinc	x1, x4, hi  // hi = pmore
  401edc:	eb0a007f 	cmp	x3, x10
  401ee0:	8b010121 	add	x1, x9, x1
  401ee4:	1a9f07e9 	cset	w9, ne  // ne = any
  401ee8:	17fffebe 	b	4019e0 <__divtf3+0x3a0>
  401eec:	b5000069 	cbnz	x9, 401ef8 <__divtf3+0x8b8>
  401ef0:	b1002021 	adds	x1, x1, #0x8
  401ef4:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  401ef8:	b69fe845 	tbz	x5, #51, 401c00 <__divtf3+0x5c0>
  401efc:	321d0000 	orr	w0, w0, #0x8
  401f00:	52800024 	mov	w4, #0x1                   	// #1
  401f04:	d2800005 	mov	x5, #0x0                   	// #0
  401f08:	d2800001 	mov	x1, #0x0                   	// #0
  401f0c:	17ffff8c 	b	401d3c <__divtf3+0x6fc>
  401f10:	f100013f 	cmp	x9, #0x0
  401f14:	528fffe1 	mov	w1, #0x7fff                	// #32767
  401f18:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401f1c:	1a811044 	csel	w4, w2, w1, ne  // ne = any
  401f20:	9a9f10a5 	csel	x5, x5, xzr, ne  // ne = any
  401f24:	da9f03e1 	csetm	x1, ne  // ne = any
  401f28:	17ffff83 	b	401d34 <__divtf3+0x6f4>
  401f2c:	5280002b 	mov	w11, #0x1                   	// #1
  401f30:	b5ffc149 	cbnz	x9, 401758 <__divtf3+0x118>
  401f34:	b10020c6 	adds	x6, x6, #0x8
  401f38:	5280000b 	mov	w11, #0x0                   	// #0
  401f3c:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401f40:	17fffe06 	b	401758 <__divtf3+0x118>
  401f44:	d1000863 	sub	x3, x3, #0x2
  401f48:	8b040021 	add	x1, x1, x4
  401f4c:	17fffe88 	b	40196c <__divtf3+0x32c>
  401f50:	d10008c6 	sub	x6, x6, #0x2
  401f54:	8b040042 	add	x2, x2, x4
  401f58:	17fffe79 	b	40193c <__divtf3+0x2fc>
  401f5c:	d2800021 	mov	x1, #0x1                   	// #1
  401f60:	cb090021 	sub	x1, x1, x9
  401f64:	17ffff91 	b	401da8 <__divtf3+0x768>
  401f68:	92400c22 	and	x2, x1, #0xf
  401f6c:	f100105f 	cmp	x2, #0x4
  401f70:	54fffc40 	b.eq	401ef8 <__divtf3+0x8b8>  // b.none
  401f74:	b1001021 	adds	x1, x1, #0x4
  401f78:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  401f7c:	b79ffc05 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401f80:	17ffff20 	b	401c00 <__divtf3+0x5c0>
  401f84:	b5fffb69 	cbnz	x9, 401ef0 <__divtf3+0x8b0>
  401f88:	b79ffba5 	tbnz	x5, #51, 401efc <__divtf3+0x8bc>
  401f8c:	17ffff1d 	b	401c00 <__divtf3+0x5c0>
  401f90:	321c0000 	orr	w0, w0, #0x10
  401f94:	17ffffda 	b	401efc <__divtf3+0x8bc>
  401f98:	d503201f 	nop
  401f9c:	d503201f 	nop

0000000000401fa0 <__floatunditf>:
  401fa0:	b40002a0 	cbz	x0, 401ff4 <__floatunditf+0x54>
  401fa4:	dac01001 	clz	x1, x0
  401fa8:	528807c2 	mov	w2, #0x403e                	// #16446
  401fac:	4b010042 	sub	w2, w2, w1
  401fb0:	d2880de3 	mov	x3, #0x406f                	// #16495
  401fb4:	12003844 	and	w4, w2, #0x7fff
  401fb8:	cb22c062 	sub	x2, x3, w2, sxtw
  401fbc:	f100fc5f 	cmp	x2, #0x3f
  401fc0:	540002ac 	b.gt	402014 <__floatunditf+0x74>
  401fc4:	1100c423 	add	w3, w1, #0x31
  401fc8:	528001e2 	mov	w2, #0xf                   	// #15
  401fcc:	4b010041 	sub	w1, w2, w1
  401fd0:	9ac12401 	lsr	x1, x0, x1
  401fd4:	9240bc21 	and	x1, x1, #0xffffffffffff
  401fd8:	9ac32000 	lsl	x0, x0, x3
  401fdc:	d2800003 	mov	x3, #0x0                   	// #0
  401fe0:	b340bc23 	bfxil	x3, x1, #0, #48
  401fe4:	9e670000 	fmov	d0, x0
  401fe8:	b3503c83 	bfi	x3, x4, #48, #16
  401fec:	9eaf0060 	fmov	v0.d[1], x3
  401ff0:	d65f03c0 	ret
  401ff4:	d2800001 	mov	x1, #0x0                   	// #0
  401ff8:	d2800003 	mov	x3, #0x0                   	// #0
  401ffc:	b340bc23 	bfxil	x3, x1, #0, #48
  402000:	9e670000 	fmov	d0, x0
  402004:	52800004 	mov	w4, #0x0                   	// #0
  402008:	b3503c83 	bfi	x3, x4, #48, #16
  40200c:	9eaf0060 	fmov	v0.d[1], x3
  402010:	d65f03c0 	ret
  402014:	51003c21 	sub	w1, w1, #0xf
  402018:	d2800003 	mov	x3, #0x0                   	// #0
  40201c:	9ac12001 	lsl	x1, x0, x1
  402020:	9240bc21 	and	x1, x1, #0xffffffffffff
  402024:	d2800000 	mov	x0, #0x0                   	// #0
  402028:	9e670000 	fmov	d0, x0
  40202c:	b340bc23 	bfxil	x3, x1, #0, #48
  402030:	b3503c83 	bfi	x3, x4, #48, #16
  402034:	9eaf0060 	fmov	v0.d[1], x3
  402038:	d65f03c0 	ret
  40203c:	d503201f 	nop

0000000000402040 <__sfp_handle_exceptions>:
  402040:	36000080 	tbz	w0, #0, 402050 <__sfp_handle_exceptions+0x10>
  402044:	0f000401 	movi	v1.2s, #0x0
  402048:	1e211820 	fdiv	s0, s1, s1
  40204c:	d53b4421 	mrs	x1, fpsr
  402050:	360800a0 	tbz	w0, #1, 402064 <__sfp_handle_exceptions+0x24>
  402054:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
  402058:	0f000402 	movi	v2.2s, #0x0
  40205c:	1e221820 	fdiv	s0, s1, s2
  402060:	d53b4421 	mrs	x1, fpsr
  402064:	36100100 	tbz	w0, #2, 402084 <__sfp_handle_exceptions+0x44>
  402068:	5298b5c2 	mov	w2, #0xc5ae                	// #50606
  40206c:	12b01001 	mov	w1, #0x7f7fffff            	// #2139095039
  402070:	72ae93a2 	movk	w2, #0x749d, lsl #16
  402074:	1e270021 	fmov	s1, w1
  402078:	1e270042 	fmov	s2, w2
  40207c:	1e222820 	fadd	s0, s1, s2
  402080:	d53b4421 	mrs	x1, fpsr
  402084:	36180080 	tbz	w0, #3, 402094 <__sfp_handle_exceptions+0x54>
  402088:	0f044401 	movi	v1.2s, #0x80, lsl #16
  40208c:	1e210820 	fmul	s0, s1, s1
  402090:	d53b4421 	mrs	x1, fpsr
  402094:	362000c0 	tbz	w0, #4, 4020ac <__sfp_handle_exceptions+0x6c>
  402098:	12b01000 	mov	w0, #0x7f7fffff            	// #2139095039
  40209c:	1e2e1002 	fmov	s2, #1.000000000000000000e+00
  4020a0:	1e270001 	fmov	s1, w0
  4020a4:	1e223820 	fsub	s0, s1, s2
  4020a8:	d53b4420 	mrs	x0, fpsr
  4020ac:	d65f03c0 	ret

00000000004020b0 <call_weak_fn>:
  4020b0:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4020b4:	f9476400 	ldr	x0, [x0, #3784]
  4020b8:	b4000040 	cbz	x0, 4020c0 <call_weak_fn+0x10>
  4020bc:	17fffca1 	b	401340 <__gmon_start__@plt>
  4020c0:	d65f03c0 	ret

00000000004020c4 <_OffsetAbsSyms>:
#include <zephyr/kernel.h>
#include <kernel_arch_data.h>
#include <gen_offset.h>
#include <kernel_offsets.h>

GEN_ABS_SYM_END
  4020c4:	d65f03c0 	ret

00000000004020c8 <k_timer_stop>:
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_TIMER_STOP);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_stop(timer);
  4020c8:	14004459 	b	41322c <z_impl_k_timer_stop>

00000000004020cc <send_can_tx_callback>:
        receive_can_rx(rctx, frame);
    }
}

static void send_can_tx_callback(const struct device *dev, int error, void *arg)
{
  4020cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4020d0:	910003fd 	mov	x29, sp
    struct isotp_fast_send_ctx *sctx = arg;

    ARG_UNUSED(dev);

    sctx->backlog--;
  4020d4:	39434c40 	ldrb	w0, [x2, #211]
{
  4020d8:	f9000bf3 	str	x19, [sp, #16]
  4020dc:	aa0203f3 	mov	x19, x2
    sctx->backlog--;
  4020e0:	51000400 	sub	w0, w0, #0x1
  4020e4:	39034c40 	strb	w0, [x2, #211]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
  4020e8:	91024040 	add	x0, x2, #0x90
  4020ec:	94003543 	bl	40f5f8 <z_impl_k_sem_give>
    k_sem_give(&sctx->sem);

    if (sctx->state == ISOTP_TX_WAIT_BACKLOG) {
  4020f0:	f9406260 	ldr	x0, [x19, #192]
  4020f4:	530c4c00 	ubfx	w0, w0, #12, #8
  4020f8:	7100181f 	cmp	w0, #0x6
  4020fc:	54000181 	b.ne	40212c <send_can_tx_callback+0x60>  // b.any
        if (sctx->backlog > 0) {
  402100:	39434e60 	ldrb	w0, [x19, #211]
  402104:	350001c0 	cbnz	w0, 40213c <send_can_tx_callback+0x70>
            return;
        }

        sctx->state = ISOTP_TX_WAIT_FIN;
  402108:	79418260 	ldrh	w0, [x19, #192]
  40210c:	91030261 	add	x1, x19, #0xc0
  402110:	12002c00 	and	w0, w0, #0xfff
  402114:	32140800 	orr	w0, w0, #0x7000
  402118:	79018260 	strh	w0, [x19, #192]
  40211c:	aa0103e0 	mov	x0, x1
  402120:	39400821 	ldrb	w1, [x1, #2]
  402124:	121c6c21 	and	w1, w1, #0xfffffff0
  402128:	39000801 	strb	w1, [x0, #2]
    }

    k_work_submit(&sctx->work);
  40212c:	91006260 	add	x0, x19, #0x18
}
  402130:	f9400bf3 	ldr	x19, [sp, #16]
  402134:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&sctx->work);
  402138:	140037b2 	b	410000 <k_work_submit>
}
  40213c:	f9400bf3 	ldr	x19, [sp, #16]
  402140:	a8c27bfd 	ldp	x29, x30, [sp], #32
  402144:	d65f03c0 	ret

0000000000402148 <can_bytes_to_dlc>:
 * @param num_bytes Number of bytes.
 *
 * @retval Data Length Code (DLC).
 */
static inline uint8_t can_bytes_to_dlc(uint8_t num_bytes)
{
  402148:	12001c00 	and	w0, w0, #0xff
	return num_bytes <= 8  ? num_bytes :
  40214c:	7100201f 	cmp	w0, #0x8
  402150:	540001c9 	b.ls	402188 <can_bytes_to_dlc+0x40>  // b.plast
  402154:	7100301f 	cmp	w0, #0xc
  402158:	540001a9 	b.ls	40218c <can_bytes_to_dlc+0x44>  // b.plast
  40215c:	7100401f 	cmp	w0, #0x10
  402160:	540001a9 	b.ls	402194 <can_bytes_to_dlc+0x4c>  // b.plast
  402164:	7100501f 	cmp	w0, #0x14
  402168:	540001a9 	b.ls	40219c <can_bytes_to_dlc+0x54>  // b.plast
  40216c:	7100601f 	cmp	w0, #0x18
  402170:	540001a9 	b.ls	4021a4 <can_bytes_to_dlc+0x5c>  // b.plast
  402174:	7100801f 	cmp	w0, #0x20
  402178:	540001a9 	b.ls	4021ac <can_bytes_to_dlc+0x64>  // b.plast
  40217c:	7100c01f 	cmp	w0, #0x30
  402180:	1a9f97e0 	cset	w0, hi  // hi = pmore
  402184:	11003800 	add	w0, w0, #0xe
	       num_bytes <= 20 ? 11 :
	       num_bytes <= 24 ? 12 :
	       num_bytes <= 32 ? 13 :
	       num_bytes <= 48 ? 14 :
	       15;
}
  402188:	d65f03c0 	ret
	return num_bytes <= 8  ? num_bytes :
  40218c:	52800120 	mov	w0, #0x9                   	// #9
  402190:	17fffffe 	b	402188 <can_bytes_to_dlc+0x40>
  402194:	52800140 	mov	w0, #0xa                   	// #10
  402198:	17fffffc 	b	402188 <can_bytes_to_dlc+0x40>
  40219c:	52800160 	mov	w0, #0xb                   	// #11
  4021a0:	17fffffa 	b	402188 <can_bytes_to_dlc+0x40>
  4021a4:	52800180 	mov	w0, #0xc                   	// #12
  4021a8:	17fffff8 	b	402188 <can_bytes_to_dlc+0x40>
  4021ac:	528001a0 	mov	w0, #0xd                   	// #13
  4021b0:	17fffff6 	b	402188 <can_bytes_to_dlc+0x40>

00000000004021b4 <z_log_msg_runtime_create.constprop.0>:
 *
 * @param fmt String.
 *
 * @param ... String arguments.
 */
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  4021b4:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  4021b8:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4021bc:	12001c42 	and	w2, w2, #0xff
  4021c0:	910003fd 	mov	x29, sp
  4021c4:	f9476800 	ldr	x0, [x0, #3792]
  4021c8:	3d8023e0 	str	q0, [sp, #128]
  4021cc:	3d8027e1 	str	q1, [sp, #144]
  4021d0:	3d802be2 	str	q2, [sp, #160]
  4021d4:	3d802fe3 	str	q3, [sp, #176]
  4021d8:	3d8033e4 	str	q4, [sp, #192]
  4021dc:	3d8037e5 	str	q5, [sp, #208]
  4021e0:	3d803be6 	str	q6, [sp, #224]
  4021e4:	3d803fe7 	str	q7, [sp, #240]
  4021e8:	f90087e7 	str	x7, [sp, #264]
  4021ec:	f9400003 	ldr	x3, [x0]
  4021f0:	f9003fe3 	str	x3, [sp, #120]
  4021f4:	d2800003 	mov	x3, #0x0                   	// #0
					     size_t dlen, uint32_t package_flags,
					     const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
  4021f8:	910443e0 	add	x0, sp, #0x110
  4021fc:	a90383e0 	stp	x0, x0, [sp, #56]
  402200:	910403e0 	add	x0, sp, #0x100
  402204:	9100e3e3 	add	x3, sp, #0x38
  402208:	f90027e0 	str	x0, [sp, #72]
  40220c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  402210:	b90053e0 	str	w0, [sp, #80]
  402214:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  402218:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40221c:	910163e0 	add	x0, sp, #0x58
  402220:	ad400460 	ldp	q0, q1, [x3]
  402224:	ad000400 	stp	q0, q1, [x0]
		va_end(parm7.val);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_runtime_vcreate(domain_id, source, level, data, dlen, package_flags, fmt, ap);
  402228:	ad400400 	ldp	q0, q1, [x0]
  40222c:	910043e7 	add	x7, sp, #0x10
  402230:	52800000 	mov	w0, #0x0                   	// #0
  402234:	52800005 	mov	w5, #0x0                   	// #0
  402238:	d2800004 	mov	x4, #0x0                   	// #0
  40223c:	d2800003 	mov	x3, #0x0                   	// #0
  402240:	ad0004e0 	stp	q0, q1, [x7]
  402244:	940017ed 	bl	4081f8 <z_impl_z_log_msg_runtime_vcreate>
				   data, dlen, package_flags, fmt, ap);
	va_end(ap);
}
  402248:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40224c:	f9476800 	ldr	x0, [x0, #3792]
  402250:	f9403fe2 	ldr	x2, [sp, #120]
  402254:	f9400001 	ldr	x1, [x0]
  402258:	eb010042 	subs	x2, x2, x1
  40225c:	d2800001 	mov	x1, #0x0                   	// #0
  402260:	54000040 	b.eq	402268 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  402264:	97fffc2f 	bl	401320 <__stack_chk_fail@plt>
  402268:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40226c:	d65f03c0 	ret

0000000000402270 <send_timeout_handler>:

    send_state_machine(sctx);
}

static void send_timeout_handler(struct k_timer *timer)
{
  402270:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402274:	910003fd 	mov	x29, sp
  402278:	f9000bf3 	str	x19, [sp, #16]
  40227c:	aa0003f3 	mov	x19, x0
    struct isotp_fast_send_ctx *sctx = CONTAINER_OF(timer, struct isotp_fast_send_ctx, timer);

    if (sctx->state != ISOTP_TX_SEND_CF) {
  402280:	f9404400 	ldr	x0, [x0, #136]
  402284:	530c4c00 	ubfx	w0, w0, #12, #8
  402288:	7100101f 	cmp	w0, #0x4
  40228c:	54000240 	b.eq	4022d4 <send_timeout_handler+0x64>  // b.none
        LOG_ERR("Timed out waiting for FC frame");
  402290:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  402294:	52800000 	mov	w0, #0x0                   	// #0
  402298:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  40229c:	52800005 	mov	w5, #0x0                   	// #0
  4022a0:	f9478821 	ldr	x1, [x1, #3856]
  4022a4:	911794c6 	add	x6, x6, #0x5e5
  4022a8:	d2800004 	mov	x4, #0x0                   	// #0
  4022ac:	d2800003 	mov	x3, #0x0                   	// #0
  4022b0:	52800022 	mov	w2, #0x1                   	// #1
  4022b4:	97ffffc0 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  4022b8:	b9408a61 	ldr	w1, [x19, #136]
  4022bc:	52900000 	mov	w0, #0x8000                	// #32768
  4022c0:	72bfc000 	movk	w0, #0xfe00, lsl #16
  4022c4:	12005c21 	and	w1, w1, #0xffffff
  4022c8:	120c5c21 	and	w1, w1, #0xfff00fff
  4022cc:	2a000021 	orr	w1, w1, w0
  4022d0:	b9008a61 	str	w1, [x19, #136]
        send_report_error(sctx, ISOTP_N_TIMEOUT_BS);
    }

    k_work_submit(&sctx->work);
  4022d4:	d1008260 	sub	x0, x19, #0x20
}
  4022d8:	f9400bf3 	ldr	x19, [sp, #16]
  4022dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&sctx->work);
  4022e0:	14003748 	b	410000 <k_work_submit>

00000000004022e4 <receive_can_tx>:
    if (error != 0) {
  4022e4:	34000361 	cbz	w1, 402350 <receive_can_tx+0x6c>
{
  4022e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4022ec:	2a0103e7 	mov	w7, w1
        LOG_ERR("Error sending FC frame (%d)", error);
  4022f0:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
{
  4022f4:	910003fd 	mov	x29, sp
        LOG_ERR("Error sending FC frame (%d)", error);
  4022f8:	f9478821 	ldr	x1, [x1, #3856]
{
  4022fc:	f9000bf3 	str	x19, [sp, #16]
  402300:	aa0203f3 	mov	x19, x2
        LOG_ERR("Error sending FC frame (%d)", error);
  402304:	52800005 	mov	w5, #0x0                   	// #0
  402308:	d2800004 	mov	x4, #0x0                   	// #0
  40230c:	d2800003 	mov	x3, #0x0                   	// #0
  402310:	52800000 	mov	w0, #0x0                   	// #0
  402314:	52800022 	mov	w2, #0x1                   	// #1
  402318:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  40231c:	911810c6 	add	x6, x6, #0x604
  402320:	97ffffa5 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  402324:	b9413261 	ldr	w1, [x19, #304]
  402328:	528e0000 	mov	w0, #0x7000                	// #28672
  40232c:	72bee000 	movk	w0, #0xf700, lsl #16
  402330:	12005c21 	and	w1, w1, #0xffffff
  402334:	120c5c21 	and	w1, w1, #0xfff00fff
  402338:	2a000021 	orr	w1, w1, w0
  40233c:	b9013261 	str	w1, [x19, #304]
        k_work_submit(&rctx->work);
  402340:	91006260 	add	x0, x19, #0x18
}
  402344:	f9400bf3 	ldr	x19, [sp, #16]
  402348:	a8c27bfd 	ldp	x29, x30, [sp], #32
        k_work_submit(&rctx->work);
  40234c:	1400372d 	b	410000 <k_work_submit>
  402350:	d65f03c0 	ret

0000000000402354 <receive_timeout_handler>:
{
  402354:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402358:	910003fd 	mov	x29, sp
  40235c:	f9000bf3 	str	x19, [sp, #16]
  402360:	aa0003f3 	mov	x19, x0
    switch (rctx->state) {
  402364:	f9407c00 	ldr	x0, [x0, #248]
  402368:	530c4c00 	ubfx	w0, w0, #12, #8
  40236c:	71000c1f 	cmp	w0, #0x3
  402370:	54000300 	b.eq	4023d0 <receive_timeout_handler+0x7c>  // b.none
  402374:	7100141f 	cmp	w0, #0x5
  402378:	54000241 	b.ne	4023c0 <receive_timeout_handler+0x6c>  // b.any
            LOG_ERR("Timeout while waiting for CF");
  40237c:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  402380:	52800000 	mov	w0, #0x0                   	// #0
  402384:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  402388:	52800005 	mov	w5, #0x0                   	// #0
  40238c:	f9478821 	ldr	x1, [x1, #3856]
  402390:	911880c6 	add	x6, x6, #0x620
  402394:	d2800004 	mov	x4, #0x0                   	// #0
  402398:	d2800003 	mov	x3, #0x0                   	// #0
  40239c:	52800022 	mov	w2, #0x1                   	// #1
  4023a0:	97ffff85 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  4023a4:	b940fa60 	ldr	w0, [x19, #248]
  4023a8:	528e0001 	mov	w1, #0x7000                	// #28672
  4023ac:	72bfa001 	movk	w1, #0xfd00, lsl #16
  4023b0:	12005c00 	and	w0, w0, #0xffffff
  4023b4:	120c5c00 	and	w0, w0, #0xfff00fff
  4023b8:	2a010000 	orr	w0, w0, w1
  4023bc:	b900fa60 	str	w0, [x19, #248]
    k_work_submit(&rctx->work);
  4023c0:	d1008260 	sub	x0, x19, #0x20
}
  4023c4:	f9400bf3 	ldr	x19, [sp, #16]
  4023c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&rctx->work);
  4023cc:	1400370d 	b	410000 <k_work_submit>
            rctx->state = ISOTP_RX_STATE_SEND_WAIT;
  4023d0:	7941f260 	ldrh	w0, [x19, #248]
  4023d4:	9103e261 	add	x1, x19, #0xf8
  4023d8:	12002c00 	and	w0, w0, #0xfff
  4023dc:	32130400 	orr	w0, w0, #0x6000
  4023e0:	7901f260 	strh	w0, [x19, #248]
  4023e4:	aa0103e0 	mov	x0, x1
  4023e8:	39400821 	ldrb	w1, [x1, #2]
  4023ec:	121c6c21 	and	w1, w1, #0xfffffff0
  4023f0:	39000801 	strb	w1, [x0, #2]
            break;
  4023f4:	17fffff3 	b	4023c0 <receive_timeout_handler+0x6c>

00000000004023f8 <sys_slist_find_and_remove.isra.0>:
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  4023f8:	f9400002 	ldr	x2, [x0]
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  4023fc:	d2800003 	mov	x3, #0x0                   	// #0
  402400:	b4000162 	cbz	x2, 40242c <sys_slist_find_and_remove.isra.0+0x34>
  402404:	eb01005f 	cmp	x2, x1
  402408:	54000201 	b.ne	402448 <sys_slist_find_and_remove.isra.0+0x50>  // b.any
	return node->next;
  40240c:	f9400022 	ldr	x2, [x1]
Z_GENLIST_REMOVE(slist, snode)
  402410:	b5000103 	cbnz	x3, 402430 <sys_slist_find_and_remove.isra.0+0x38>
  402414:	f9400403 	ldr	x3, [x0, #8]
	list->head = node;
  402418:	f9000002 	str	x2, [x0]
Z_GENLIST_REMOVE(slist, snode)
  40241c:	eb03003f 	cmp	x1, x3
  402420:	54000041 	b.ne	402428 <sys_slist_find_and_remove.isra.0+0x30>  // b.any
	list->tail = node;
  402424:	f9000402 	str	x2, [x0, #8]
	parent->next = child;
  402428:	f900003f 	str	xzr, [x1]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  40242c:	d65f03c0 	ret
	parent->next = child;
  402430:	f9000062 	str	x2, [x3]
Z_GENLIST_REMOVE(slist, snode)
  402434:	f9400402 	ldr	x2, [x0, #8]
  402438:	eb02003f 	cmp	x1, x2
  40243c:	54ffff61 	b.ne	402428 <sys_slist_find_and_remove.isra.0+0x30>  // b.any
	list->tail = node;
  402440:	f9000403 	str	x3, [x0, #8]
}
  402444:	17fffff9 	b	402428 <sys_slist_find_and_remove.isra.0+0x30>
	return node->next;
  402448:	aa0203e3 	mov	x3, x2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  40244c:	f9400042 	ldr	x2, [x2]
  402450:	17ffffec 	b	402400 <sys_slist_find_and_remove.isra.0+0x8>

0000000000402454 <free_recv_ctx>:
{
  402454:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402458:	910003fd 	mov	x29, sp
  40245c:	f9000bf3 	str	x19, [sp, #16]
  402460:	aa0003f3 	mov	x19, x0
    k_timer_stop(&(*rctx)->timer);
  402464:	f9400000 	ldr	x0, [x0]
  402468:	9100e000 	add	x0, x0, #0x38
  40246c:	97ffff17 	bl	4020c8 <k_timer_stop>
    sys_slist_find_and_remove(&isotp_recv_ctx_list, &(*rctx)->node);
  402470:	f9400261 	ldr	x1, [x19]
  402474:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  402478:	912b0000 	add	x0, x0, #0xac0
  40247c:	97ffffdf 	bl	4023f8 <sys_slist_find_and_remove.isra.0>
    net_buf_unref((*rctx)->buffer);
  402480:	f9400260 	ldr	x0, [x19]
  402484:	f9404800 	ldr	x0, [x0, #144]
  402488:	94002883 	bl	40c694 <net_buf_unref>
    k_msgq_purge(&(*rctx)->recv_queue);
  40248c:	f9400260 	ldr	x0, [x19]
  402490:	91028000 	add	x0, x0, #0xa0
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MSGQ_PURGE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_msgq_purge(msgq);
  402494:	940031ed 	bl	40ec48 <z_impl_k_msgq_purge>
    k_msgq_cleanup(&(*rctx)->recv_queue);
  402498:	f9400260 	ldr	x0, [x19]
  40249c:	91028000 	add	x0, x0, #0xa0
  4024a0:	94003082 	bl	40e6a8 <k_msgq_cleanup>
    k_mem_slab_free(&isotp_recv_ctx_slab, (void **)rctx);
  4024a4:	aa1303e1 	mov	x1, x19
  4024a8:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
}
  4024ac:	f9400bf3 	ldr	x19, [sp, #16]
  4024b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_recv_ctx_slab, (void **)rctx);
  4024b4:	f947a000 	ldr	x0, [x0, #3904]
  4024b8:	14002ed1 	b	40dffc <k_mem_slab_free>

00000000004024bc <free_send_ctx>:
{
  4024bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4024c0:	910003fd 	mov	x29, sp
  4024c4:	f9000bf3 	str	x19, [sp, #16]
  4024c8:	aa0003f3 	mov	x19, x0
    k_timer_stop(&(*ctx)->timer);
  4024cc:	f9400000 	ldr	x0, [x0]
  4024d0:	9100e000 	add	x0, x0, #0x38
  4024d4:	97fffefd 	bl	4020c8 <k_timer_stop>
    sys_slist_find_and_remove(&isotp_send_ctx_list, &(*ctx)->node);
  4024d8:	f9400261 	ldr	x1, [x19]
  4024dc:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  4024e0:	912b4000 	add	x0, x0, #0xad0
  4024e4:	97ffffc5 	bl	4023f8 <sys_slist_find_and_remove.isra.0>
    k_mem_slab_free(&isotp_send_ctx_slab, (void **)ctx);
  4024e8:	aa1303e1 	mov	x1, x19
  4024ec:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
}
  4024f0:	f9400bf3 	ldr	x19, [sp, #16]
  4024f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_send_ctx_slab, (void **)ctx);
  4024f8:	f947f000 	ldr	x0, [x0, #4064]
  4024fc:	14002ec0 	b	40dffc <k_mem_slab_free>

0000000000402500 <get_send_ctx>:
{
  402500:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  402504:	910003fd 	mov	x29, sp
  402508:	f9001bf7 	str	x23, [sp, #48]
  40250c:	aa0003f7 	mov	x23, x0
  402510:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  402514:	a9025bf5 	stp	x21, x22, [sp, #32]
	return list->head;
  402518:	d0000156 	adrp	x22, 42c000 <__dso_handle>
  40251c:	f9476800 	ldr	x0, [x0, #3792]
  402520:	a90153f3 	stp	x19, x20, [sp, #16]
  402524:	2a0103f4 	mov	w20, w1
  402528:	f9456ac3 	ldr	x3, [x22, #2768]
  40252c:	f9400001 	ldr	x1, [x0]
  402530:	f90027e1 	str	x1, [sp, #72]
  402534:	d2800001 	mov	x1, #0x0                   	// #0
  402538:	aa0203f5 	mov	x21, x2
    return (isotp_fast_node_id)(frame->id & ISOTP_FIXED_ADDR_SA_MASK);
}

static inline isotp_fast_node_id isotp_fast_get_addr_recipient(isotp_fast_msg_id addr)
{
    return (isotp_fast_node_id)((addr & ISOTP_FIXED_ADDR_TA_MASK) >> ISOTP_FIXED_ADDR_TA_POS);
  40253c:	d3483e80 	ubfx	x0, x20, #8, #8
    SYS_SLIST_FOR_EACH_CONTAINER(&isotp_send_ctx_list, context, node)
  402540:	f90023e3 	str	x3, [sp, #64]
  402544:	b50003e3 	cbnz	x3, 4025c0 <get_send_ctx+0xc0>
    int err = k_mem_slab_alloc(&isotp_send_ctx_slab, (void **)&context, K_NO_WAIT);
  402548:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40254c:	910103e1 	add	x1, sp, #0x40
  402550:	d2800002 	mov	x2, #0x0                   	// #0
  402554:	f947f000 	ldr	x0, [x0, #4064]
  402558:	94002e4b 	bl	40de84 <k_mem_slab_alloc>
  40255c:	2a0003f3 	mov	w19, w0
    if (err != 0) {
  402560:	35000540 	cbnz	w0, 402608 <get_send_ctx+0x108>
    *sctx = context;
  402564:	f94023e0 	ldr	x0, [sp, #64]
  402568:	f90002a0 	str	x0, [x21]
    k_work_init(&context->work, receive_work_handler);
  40256c:	b0000001 	adrp	x1, 403000 <send_work_handler+0x264>
  402570:	9118b021 	add	x1, x1, #0x62c
  402574:	91006000 	add	x0, x0, #0x18
    context->ctx = ctx;
  402578:	f81f0017 	stur	x23, [x0, #-16]
    context->recipient_addr = recipient_addr;
  40257c:	b81f8014 	stur	w20, [x0, #-8]
    context->error = 0;
  402580:	3902ac1f 	strb	wzr, [x0, #171]
    k_work_init(&context->work, receive_work_handler);
  402584:	94003612 	bl	40fdcc <k_work_init>
    k_timer_init(&context->timer, receive_timeout_handler, NULL);
  402588:	f94023e0 	ldr	x0, [sp, #64]
  40258c:	d2800002 	mov	x2, #0x0                   	// #0
  402590:	90000001 	adrp	x1, 402000 <__floatunditf+0x60>
  402594:	910d5021 	add	x1, x1, #0x354
  402598:	9100e000 	add	x0, x0, #0x38
  40259c:	94004302 	bl	4131a4 <k_timer_init>
    sys_slist_append(&isotp_send_ctx_list, &context->node);
  4025a0:	f94023e0 	ldr	x0, [sp, #64]
	return list->tail;
  4025a4:	912b42c1 	add	x1, x22, #0xad0
	parent->next = child;
  4025a8:	f900001f 	str	xzr, [x0]
	return list->tail;
  4025ac:	f9400422 	ldr	x2, [x1, #8]
Z_GENLIST_APPEND(slist, snode)
  4025b0:	b5000262 	cbnz	x2, 4025fc <get_send_ctx+0xfc>
	list->head = node;
  4025b4:	f9056ac0 	str	x0, [x22, #2768]
	list->tail = node;
  4025b8:	f9000420 	str	x0, [x1, #8]
}
  4025bc:	14000006 	b	4025d4 <get_send_ctx+0xd4>
        if (isotp_fast_get_addr_recipient(context->recipient_addr) == recipient_id) {
  4025c0:	39404461 	ldrb	w1, [x3, #17]
  4025c4:	6b00003f 	cmp	w1, w0
  4025c8:	54000161 	b.ne	4025f4 <get_send_ctx+0xf4>  // b.any
            return 0;
  4025cc:	52800013 	mov	w19, #0x0                   	// #0
            *sctx = context;
  4025d0:	f90002a3 	str	x3, [x21]
}
  4025d4:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4025d8:	f9476800 	ldr	x0, [x0, #3792]
  4025dc:	f94027e2 	ldr	x2, [sp, #72]
  4025e0:	f9400001 	ldr	x1, [x0]
  4025e4:	eb010042 	subs	x2, x2, x1
  4025e8:	d2800001 	mov	x1, #0x0                   	// #0
  4025ec:	54000120 	b.eq	402610 <get_send_ctx+0x110>  // b.none
  4025f0:	97fffb4c 	bl	401320 <__stack_chk_fail@plt>
	return node->next;
  4025f4:	f9400063 	ldr	x3, [x3]
  4025f8:	17ffffd2 	b	402540 <get_send_ctx+0x40>
	parent->next = child;
  4025fc:	f9000040 	str	x0, [x2]
	list->tail = node;
  402600:	f9000420 	str	x0, [x1, #8]
}
  402604:	17fffff4 	b	4025d4 <get_send_ctx+0xd4>
        return ISOTP_NO_CTX_LEFT;
  402608:	12800193 	mov	w19, #0xfffffff3            	// #-13
  40260c:	17fffff2 	b	4025d4 <get_send_ctx+0xd4>
}
  402610:	2a1303e0 	mov	w0, w19
  402614:	a94153f3 	ldp	x19, x20, [sp, #16]
  402618:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40261c:	f9401bf7 	ldr	x23, [sp, #48]
  402620:	a8c57bfd 	ldp	x29, x30, [sp], #80
  402624:	d65f03c0 	ret

0000000000402628 <can_rx_callback>:
{
  402628:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  40262c:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  402630:	910003fd 	mov	x29, sp
  402634:	a90153f3 	stp	x19, x20, [sp, #16]
  402638:	aa0103f4 	mov	x20, x1
  40263c:	a9025bf5 	stp	x21, x22, [sp, #32]
  402640:	aa0203f6 	mov	x22, x2
  402644:	a90363f7 	stp	x23, x24, [sp, #48]
  402648:	f9476800 	ldr	x0, [x0, #3792]
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  40264c:	b9400033 	ldr	w19, [x1]
{
  402650:	f90023f9 	str	x25, [sp, #64]
  402654:	f9400001 	ldr	x1, [x0]
  402658:	f90037e1 	str	x1, [sp, #104]
  40265c:	d2800001 	mov	x1, #0x0                   	// #0
    if ((frame->data[index++] & ISOTP_PCI_TYPE_MASK) == ISOTP_PCI_TYPE_FC) {
  402660:	39402280 	ldrb	w0, [x20, #8]
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402664:	d3407273 	ubfx	x19, x19, #0, #29
    if ((frame->data[index++] & ISOTP_PCI_TYPE_MASK) == ISOTP_PCI_TYPE_FC) {
  402668:	121c0c00 	and	w0, w0, #0xf0
  40266c:	7100c01f 	cmp	w0, #0x30
  402670:	54001061 	b.ne	40287c <can_rx_callback+0x254>  // b.any
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402674:	53181e60 	ubfiz	w0, w19, #8, #8
  402678:	d3483e61 	ubfx	x1, x19, #8, #8
    isotp_fast_msg_id sender_id =
  40267c:	2a000021 	orr	w1, w1, w0
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402680:	12103e73 	and	w19, w19, #0xffff0000
        if (get_send_ctx(ctx, sender_id, &sctx) != 0) {
  402684:	910183e2 	add	x2, sp, #0x60
  402688:	2a130021 	orr	w1, w1, w19
  40268c:	aa1603e0 	mov	x0, x22
  402690:	97ffff9c 	bl	402500 <get_send_ctx>
  402694:	35001680 	cbnz	w0, 402964 <can_rx_callback+0x33c>
        send_can_rx(sctx, frame);
  402698:	f94033f3 	ldr	x19, [sp, #96]
    if (sctx->state == ISOTP_TX_WAIT_FC) {
  40269c:	f9406260 	ldr	x0, [x19, #192]
  4026a0:	530c4c00 	ubfx	w0, w0, #12, #8
  4026a4:	71000c1f 	cmp	w0, #0x3
  4026a8:	54000d61 	b.ne	402854 <can_rx_callback+0x22c>  // b.any
        k_timer_stop(&sctx->timer);
  4026ac:	9100e275 	add	x21, x19, #0x38
  4026b0:	aa1503e0 	mov	x0, x21
  4026b4:	97fffe85 	bl	4020c8 <k_timer_stop>
    if ((*data & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_FC) {
  4026b8:	39402281 	ldrb	w1, [x20, #8]
  4026bc:	121c0c20 	and	w0, w1, #0xf0
  4026c0:	7100c01f 	cmp	w0, #0x30
  4026c4:	54000220 	b.eq	402708 <can_rx_callback+0xe0>  // b.none
        LOG_ERR("Got unexpected PDU expected FC");
  4026c8:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  4026cc:	9118f4c6 	add	x6, x6, #0x63d
        LOG_ERR("Got unexpected PDU");
  4026d0:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4026d4:	52800000 	mov	w0, #0x0                   	// #0
  4026d8:	52800005 	mov	w5, #0x0                   	// #0
  4026dc:	d2800004 	mov	x4, #0x0                   	// #0
  4026e0:	f9478821 	ldr	x1, [x1, #3856]
  4026e4:	d2800003 	mov	x3, #0x0                   	// #0
  4026e8:	52800022 	mov	w2, #0x1                   	// #1
  4026ec:	97fffeb2 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  4026f0:	b940c260 	ldr	w0, [x19, #192]
  4026f4:	52900001 	mov	w1, #0x8000                	// #32768
  4026f8:	72bf4001 	movk	w1, #0xfa00, lsl #16
  4026fc:	12005c00 	and	w0, w0, #0xffffff
  402700:	120c5c00 	and	w0, w0, #0xfff00fff
  402704:	1400004b 	b	402830 <can_rx_callback+0x208>
    switch (*data++ & ISOTP_PCI_FS_MASK) {
  402708:	12000c21 	and	w1, w1, #0xf
  40270c:	7100043f 	cmp	w1, #0x1
  402710:	540003a0 	b.eq	402784 <can_rx_callback+0x15c>  // b.none
  402714:	7100083f 	cmp	w1, #0x2
  402718:	540006e0 	b.eq	4027f4 <can_rx_callback+0x1cc>  // b.none
  40271c:	35000901 	cbnz	w1, 40283c <can_rx_callback+0x214>
            sctx->state = ISOTP_TX_SEND_CF;
  402720:	79418260 	ldrh	w0, [x19, #192]
  402724:	91030261 	add	x1, x19, #0xc0
  402728:	12002c00 	and	w0, w0, #0xfff
  40272c:	32120000 	orr	w0, w0, #0x4000
  402730:	79018260 	strh	w0, [x19, #192]
  402734:	aa0103e0 	mov	x0, x1
  402738:	39400821 	ldrb	w1, [x1, #2]
  40273c:	121c6c21 	and	w1, w1, #0xfffffff0
  402740:	39000801 	strb	w1, [x0, #2]
            sctx->wft = 0;
  402744:	3903427f 	strb	wzr, [x19, #208]
            sctx->backlog = 0;
  402748:	39034e7f 	strb	wzr, [x19, #211]
	z_impl_k_sem_reset(sem);
  40274c:	91024260 	add	x0, x19, #0x90
  402750:	94003452 	bl	40f898 <z_impl_k_sem_reset>
            sctx->bs = *data++;
  402754:	39402680 	ldrb	w0, [x20, #9]
  402758:	39034660 	strb	w0, [x19, #209]
            sctx->stmin = *data++;
  40275c:	39402a80 	ldrb	w0, [x20, #10]
  402760:	39035260 	strb	w0, [x19, #212]
    k_work_submit(&sctx->work);
  402764:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  402768:	f9476800 	ldr	x0, [x0, #3792]
  40276c:	f94037e2 	ldr	x2, [sp, #104]
  402770:	f9400001 	ldr	x1, [x0]
  402774:	eb010042 	subs	x2, x2, x1
  402778:	d2800001 	mov	x1, #0x0                   	// #0
  40277c:	54000720 	b.eq	402860 <can_rx_callback+0x238>  // b.none
}
  402780:	97fffae8 	bl	401320 <__stack_chk_fail@plt>
	z_impl_k_timer_start(timer, duration, period);
  402784:	d2800002 	mov	x2, #0x0                   	// #0
  402788:	aa1503e0 	mov	x0, x21
  40278c:	d2800c81 	mov	x1, #0x64                  	// #100
  402790:	9400428c 	bl	4131c0 <z_impl_k_timer_start>
            if (sctx->wft >= CONFIG_ISOTP_WFTMAX) {
  402794:	39434260 	ldrb	w0, [x19, #208]
  402798:	7100241f 	cmp	w0, #0x9
  40279c:	54000249 	b.ls	4027e4 <can_rx_callback+0x1bc>  // b.plast
                LOG_WRN("Got too many wait frames");
  4027a0:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4027a4:	52800000 	mov	w0, #0x0                   	// #0
  4027a8:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  4027ac:	52800005 	mov	w5, #0x0                   	// #0
  4027b0:	f9478821 	ldr	x1, [x1, #3856]
  4027b4:	911970c6 	add	x6, x6, #0x65c
  4027b8:	d2800004 	mov	x4, #0x0                   	// #0
  4027bc:	d2800003 	mov	x3, #0x0                   	// #0
  4027c0:	52800042 	mov	w2, #0x2                   	// #2
  4027c4:	97fffe7c 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  4027c8:	b940c260 	ldr	w0, [x19, #192]
  4027cc:	52900001 	mov	w1, #0x8000                	// #32768
  4027d0:	72bf2001 	movk	w1, #0xf900, lsl #16
  4027d4:	12005c00 	and	w0, w0, #0xffffff
  4027d8:	120c5c00 	and	w0, w0, #0xfff00fff
  4027dc:	2a010000 	orr	w0, w0, w1
  4027e0:	b900c260 	str	w0, [x19, #192]
            sctx->wft++;
  4027e4:	39434260 	ldrb	w0, [x19, #208]
  4027e8:	11000400 	add	w0, w0, #0x1
  4027ec:	39034260 	strb	w0, [x19, #208]
            break;
  4027f0:	17ffffdd 	b	402764 <can_rx_callback+0x13c>
            LOG_ERR("Got overflow FC frame");
  4027f4:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4027f8:	52800000 	mov	w0, #0x0                   	// #0
  4027fc:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  402800:	52800005 	mov	w5, #0x0                   	// #0
  402804:	f9478821 	ldr	x1, [x1, #3856]
  402808:	9119d4c6 	add	x6, x6, #0x675
  40280c:	d2800004 	mov	x4, #0x0                   	// #0
  402810:	d2800003 	mov	x3, #0x0                   	// #0
  402814:	52800022 	mov	w2, #0x1                   	// #1
  402818:	97fffe67 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  40281c:	b940c260 	ldr	w0, [x19, #192]
  402820:	52900001 	mov	w1, #0x8000                	// #32768
  402824:	72bf0001 	movk	w1, #0xf800, lsl #16
  402828:	12005c00 	and	w0, w0, #0xffffff
  40282c:	120c5c00 	and	w0, w0, #0xfff00fff
  402830:	2a010000 	orr	w0, w0, w1
  402834:	b900c260 	str	w0, [x19, #192]
}
  402838:	17ffffcb 	b	402764 <can_rx_callback+0x13c>
    sctx->state = ISOTP_TX_ERR;
  40283c:	b940c260 	ldr	w0, [x19, #192]
  402840:	52900001 	mov	w1, #0x8000                	// #32768
  402844:	72bf6001 	movk	w1, #0xfb00, lsl #16
  402848:	12005c00 	and	w0, w0, #0xffffff
  40284c:	120c5c00 	and	w0, w0, #0xfff00fff
  402850:	17fffff8 	b	402830 <can_rx_callback+0x208>
        LOG_ERR("Got unexpected PDU");
  402854:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  402858:	911a2cc6 	add	x6, x6, #0x68b
  40285c:	17ffff9d 	b	4026d0 <can_rx_callback+0xa8>
    k_work_submit(&sctx->work);
  402860:	91006260 	add	x0, x19, #0x18
}
  402864:	a94153f3 	ldp	x19, x20, [sp, #16]
  402868:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40286c:	a94363f7 	ldp	x23, x24, [sp, #48]
  402870:	f94023f9 	ldr	x25, [sp, #64]
  402874:	a8c77bfd 	ldp	x29, x30, [sp], #112
    k_work_submit(&sctx->work);
  402878:	140035e2 	b	410000 <k_work_submit>
	return list->head;
  40287c:	d0000157 	adrp	x23, 42c000 <__dso_handle>
    return (isotp_fast_node_id)(addr & ISOTP_FIXED_ADDR_SA_MASK);
  402880:	12001e60 	and	w0, w19, #0xff
  402884:	f94562f5 	ldr	x21, [x23, #2752]
    SYS_SLIST_FOR_EACH_CONTAINER(&isotp_recv_ctx_list, context, node)
  402888:	f90033f5 	str	x21, [sp, #96]
  40288c:	b50002b5 	cbnz	x21, 4028e0 <can_rx_callback+0x2b8>
    int err = k_mem_slab_alloc(&isotp_recv_ctx_slab, (void **)&context, K_NO_WAIT);
  402890:	b0000155 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
  402894:	910183f8 	add	x24, sp, #0x60
  402898:	aa1803e1 	mov	x1, x24
  40289c:	d2800002 	mov	x2, #0x0                   	// #0
  4028a0:	f947a2b5 	ldr	x21, [x21, #3904]
  4028a4:	aa1503e0 	mov	x0, x21
  4028a8:	94002d77 	bl	40de84 <k_mem_slab_alloc>
  4028ac:	2a0003e7 	mov	w7, w0
    if (err != 0) {
  4028b0:	34000780 	cbz	w0, 4029a0 <can_rx_callback+0x378>
        LOG_ERR("No space for receive context - error %d.", err);
  4028b4:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4028b8:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  4028bc:	52800005 	mov	w5, #0x0                   	// #0
  4028c0:	911ab8c6 	add	x6, x6, #0x6ae
  4028c4:	f9478821 	ldr	x1, [x1, #3856]
  4028c8:	d2800004 	mov	x4, #0x0                   	// #0
  4028cc:	d2800003 	mov	x3, #0x0                   	// #0
  4028d0:	52800022 	mov	w2, #0x1                   	// #1
  4028d4:	52800000 	mov	w0, #0x0                   	// #0
  4028d8:	97fffe37 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
        return ISOTP_NO_CTX_LEFT;
  4028dc:	14000018 	b	40293c <can_rx_callback+0x314>
        if (isotp_fast_get_addr_sender(context->sender_addr) == sender_id) {
  4028e0:	394042a1 	ldrb	w1, [x21, #16]
  4028e4:	6b01001f 	cmp	w0, w1
  4028e8:	54000581 	b.ne	402998 <can_rx_callback+0x370>  // b.any
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf * __must_check net_buf_alloc(struct net_buf_pool *pool,
							  k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
  4028ec:	d2800001 	mov	x1, #0x0                   	// #0
  4028f0:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  4028f4:	9124a000 	add	x0, x0, #0x928
            *rctx = context;
  4028f8:	f9002ff5 	str	x21, [sp, #88]
  4028fc:	94002761 	bl	40c680 <net_buf_alloc_fixed>
            context->frag = net_buf_alloc(&isotp_rx_pool, K_NO_WAIT);
  402900:	f9004ea0 	str	x0, [x21, #152]
            if (context->frag == NULL) {
  402904:	f94033e0 	ldr	x0, [sp, #96]
  402908:	f9404c00 	ldr	x0, [x0, #152]
  40290c:	b5000b60 	cbnz	x0, 402a78 <can_rx_callback+0x450>
                LOG_ERR("No free buffers");
  402910:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  402914:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  402918:	911a78c6 	add	x6, x6, #0x69e
  40291c:	52800005 	mov	w5, #0x0                   	// #0
  402920:	f9478821 	ldr	x1, [x1, #3856]
  402924:	d2800004 	mov	x4, #0x0                   	// #0
  402928:	d2800003 	mov	x3, #0x0                   	// #0
  40292c:	52800022 	mov	w2, #0x1                   	// #1
  402930:	97fffe21 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
                free_recv_ctx(rctx);
  402934:	910163e0 	add	x0, sp, #0x58
  402938:	97fffec7 	bl	402454 <free_recv_ctx>
            LOG_ERR("RX buffer full");
  40293c:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  402940:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  402944:	52800005 	mov	w5, #0x0                   	// #0
  402948:	911b90c6 	add	x6, x6, #0x6e4
  40294c:	f9478821 	ldr	x1, [x1, #3856]
  402950:	d2800004 	mov	x4, #0x0                   	// #0
  402954:	d2800003 	mov	x3, #0x0                   	// #0
  402958:	52800022 	mov	w2, #0x1                   	// #1
  40295c:	52800000 	mov	w0, #0x0                   	// #0
  402960:	97fffe15 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
}
  402964:	b0000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  402968:	f9476800 	ldr	x0, [x0, #3792]
  40296c:	f94037e2 	ldr	x2, [sp, #104]
  402970:	f9400001 	ldr	x1, [x0]
  402974:	eb010042 	subs	x2, x2, x1
  402978:	d2800001 	mov	x1, #0x0                   	// #0
  40297c:	54fff021 	b.ne	402780 <can_rx_callback+0x158>  // b.any
  402980:	a94153f3 	ldp	x19, x20, [sp, #16]
  402984:	a9425bf5 	ldp	x21, x22, [sp, #32]
  402988:	a94363f7 	ldp	x23, x24, [sp, #48]
  40298c:	f94023f9 	ldr	x25, [sp, #64]
  402990:	a8c77bfd 	ldp	x29, x30, [sp], #112
  402994:	d65f03c0 	ret
	return node->next;
  402998:	f94002b5 	ldr	x21, [x21]
  40299c:	17ffffbb 	b	402888 <can_rx_callback+0x260>
    context->buffer = net_buf_alloc(&isotp_rx_pool, K_NO_WAIT);
  4029a0:	f94033f9 	ldr	x25, [sp, #96]
  4029a4:	d2800001 	mov	x1, #0x0                   	// #0
  4029a8:	d0000140 	adrp	x0, 42c000 <__dso_handle>
  4029ac:	9124a000 	add	x0, x0, #0x928
  4029b0:	94002734 	bl	40c680 <net_buf_alloc_fixed>
  4029b4:	f9004b20 	str	x0, [x25, #144]
    if (!context->buffer) {
  4029b8:	f94033e0 	ldr	x0, [sp, #96]
  4029bc:	f9404801 	ldr	x1, [x0, #144]
  4029c0:	b50001e1 	cbnz	x1, 4029fc <can_rx_callback+0x3d4>
        k_mem_slab_free(&isotp_recv_ctx_slab, (void **)&context);
  4029c4:	aa1803e1 	mov	x1, x24
  4029c8:	aa1503e0 	mov	x0, x21
  4029cc:	94002d8c 	bl	40dffc <k_mem_slab_free>
        LOG_ERR("No net bufs.");
  4029d0:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4029d4:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  4029d8:	52800005 	mov	w5, #0x0                   	// #0
  4029dc:	911b5cc6 	add	x6, x6, #0x6d7
  4029e0:	f9478821 	ldr	x1, [x1, #3856]
  4029e4:	d2800004 	mov	x4, #0x0                   	// #0
  4029e8:	d2800003 	mov	x3, #0x0                   	// #0
  4029ec:	52800022 	mov	w2, #0x1                   	// #1
  4029f0:	52800000 	mov	w0, #0x0                   	// #0
  4029f4:	97fffdf0 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
        return ISOTP_NO_NET_BUF_LEFT;
  4029f8:	17ffffd1 	b	40293c <can_rx_callback+0x314>
    context->frag = context->buffer;
  4029fc:	f9004c01 	str	x1, [x0, #152]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  402a00:	528000a3 	mov	w3, #0x5                   	// #5
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  402a04:	b9413001 	ldr	w1, [x0, #304]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  402a08:	d2800102 	mov	x2, #0x8                   	// #8
    context->ctx = ctx;
  402a0c:	f9000416 	str	x22, [x0, #8]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  402a10:	12005c21 	and	w1, w1, #0xffffff
    context->sender_addr = sender_addr;
  402a14:	b9001013 	str	w19, [x0, #16]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  402a18:	120c5c21 	and	w1, w1, #0xfff00fff
  402a1c:	b9013001 	str	w1, [x0, #304]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  402a20:	91042001 	add	x1, x0, #0x108
    *rctx = context;
  402a24:	f9002fe0 	str	x0, [sp, #88]
    k_msgq_init(&context->recv_queue, context->recv_queue_pool, sizeof(struct net_buf *),
  402a28:	91028000 	add	x0, x0, #0xa0
  402a2c:	94002f12 	bl	40e674 <k_msgq_init>
    k_work_init(&context->work, receive_work_handler);
  402a30:	f94033e0 	ldr	x0, [sp, #96]
  402a34:	b0000001 	adrp	x1, 403000 <send_work_handler+0x264>
  402a38:	9118b021 	add	x1, x1, #0x62c
  402a3c:	91006000 	add	x0, x0, #0x18
  402a40:	940034e3 	bl	40fdcc <k_work_init>
    k_timer_init(&context->timer, receive_timeout_handler, NULL);
  402a44:	f94033e0 	ldr	x0, [sp, #96]
  402a48:	d2800002 	mov	x2, #0x0                   	// #0
  402a4c:	90000001 	adrp	x1, 402000 <__floatunditf+0x60>
  402a50:	910d5021 	add	x1, x1, #0x354
  402a54:	9100e000 	add	x0, x0, #0x38
  402a58:	940041d3 	bl	4131a4 <k_timer_init>
    sys_slist_append(&isotp_recv_ctx_list, &context->node);
  402a5c:	f94033e0 	ldr	x0, [sp, #96]
	return list->tail;
  402a60:	912b02e1 	add	x1, x23, #0xac0
	parent->next = child;
  402a64:	f900001f 	str	xzr, [x0]
	return list->tail;
  402a68:	f9400422 	ldr	x2, [x1, #8]
Z_GENLIST_APPEND(slist, snode)
  402a6c:	b50001a2 	cbnz	x2, 402aa0 <can_rx_callback+0x478>
	list->head = node;
  402a70:	f90562e0 	str	x0, [x23, #2752]
	list->tail = node;
  402a74:	f9000420 	str	x0, [x1, #8]
        receive_can_rx(rctx, frame);
  402a78:	f9402ff3 	ldr	x19, [sp, #88]
    switch (rctx->state) {
  402a7c:	f9409a60 	ldr	x0, [x19, #304]
  402a80:	530c4c01 	ubfx	w1, w0, #12, #8
  402a84:	72141c1f 	tst	w0, #0xff000
  402a88:	54000120 	b.eq	402aac <can_rx_callback+0x484>  // b.none
  402a8c:	7100143f 	cmp	w1, #0x5
  402a90:	54000aa0 	b.eq	402be4 <can_rx_callback+0x5bc>  // b.none
    k_work_submit(&rctx->work);
  402a94:	91006260 	add	x0, x19, #0x18
  402a98:	9400355a 	bl	410000 <k_work_submit>
  402a9c:	17ffffb2 	b	402964 <can_rx_callback+0x33c>
	parent->next = child;
  402aa0:	f9000040 	str	x0, [x2]
	list->tail = node;
  402aa4:	f9000420 	str	x0, [x1, #8]
  402aa8:	17fffff4 	b	402a78 <can_rx_callback+0x450>
    switch (frame->data[index] & ISOTP_PCI_TYPE_MASK) {
  402aac:	39402280 	ldrb	w0, [x20, #8]
  402ab0:	721c0c01 	ands	w1, w0, #0xf0
  402ab4:	540005a0 	b.eq	402b68 <can_rx_callback+0x540>  // b.none
  402ab8:	7100403f 	cmp	w1, #0x10
  402abc:	54fffec1 	b.ne	402a94 <can_rx_callback+0x46c>  // b.any
            if (frame->dlc != ISOTP_FF_DL_MIN) {
  402ac0:	39401281 	ldrb	w1, [x20, #4]
  402ac4:	71003c3f 	cmp	w1, #0xf
  402ac8:	54fffe61 	b.ne	402a94 <can_rx_callback+0x46c>  // b.any
    len = ((pci & ISOTP_PCI_FF_DL_UPPER_MASK) << 8) | data[1];
  402acc:	39402681 	ldrb	w1, [x20, #9]
  402ad0:	53180c00 	ubfiz	w0, w0, #8, #4
  402ad4:	2a010000 	orr	w0, w0, w1
    if (!len) {
  402ad8:	35000060 	cbnz	w0, 402ae4 <can_rx_callback+0x4bc>
        len = UNALIGNED_GET((uint32_t *)data);
  402adc:	b9400a80 	ldr	w0, [x20, #8]
  402ae0:	5ac00800 	rev	w0, w0
            rctx->state = ISOTP_RX_STATE_PROCESS_FF;
  402ae4:	9104c261 	add	x1, x19, #0x130
  402ae8:	12002c00 	and	w0, w0, #0xfff
  402aec:	32130000 	orr	w0, w0, #0x2000
  402af0:	79026260 	strh	w0, [x19, #304]
  402af4:	aa0103e0 	mov	x0, x1
            payload_len = CAN_MAX_DLEN - index;
  402af8:	528007d5 	mov	w21, #0x3e                  	// #62
            rctx->state = ISOTP_RX_STATE_PROCESS_FF;
  402afc:	39400821 	ldrb	w1, [x1, #2]
  402b00:	121c6c21 	and	w1, w1, #0xfffffff0
  402b04:	39000801 	strb	w1, [x0, #2]
            rctx->sn_expected = 1;
  402b08:	52800021 	mov	w1, #0x1                   	// #1
  402b0c:	3944da60 	ldrb	w0, [x19, #310]
  402b10:	33000c20 	bfxil	w0, w1, #0, #4
            index += 2;
  402b14:	52800041 	mov	w1, #0x2                   	// #2
            rctx->sn_expected = 1;
  402b18:	3904da60 	strb	w0, [x19, #310]
 * @return The original tail of the buffer.
 */
static inline void *net_buf_add_mem(struct net_buf *buf, const void *mem,
				    size_t len)
{
	return net_buf_simple_add_mem(&buf->b, mem, len);
  402b1c:	f9404e60 	ldr	x0, [x19, #152]
    net_buf_add_mem(rctx->frag, &frame->data[index], payload_len);
  402b20:	11002021 	add	w1, w1, #0x8
  402b24:	92401ea2 	and	x2, x21, #0xff
  402b28:	8b21c281 	add	x1, x20, w1, sxtw
  402b2c:	91006000 	add	x0, x0, #0x18
  402b30:	94002748 	bl	40c850 <net_buf_simple_add_mem>
    rctx->rem_len -= payload_len;
  402b34:	f9409a60 	ldr	x0, [x19, #304]
  402b38:	79426261 	ldrh	w1, [x19, #304]
  402b3c:	4b150000 	sub	w0, w0, w21
  402b40:	12002c00 	and	w0, w0, #0xfff
  402b44:	33002c01 	bfxil	w1, w0, #0, #12
  402b48:	79026261 	strh	w1, [x19, #304]
    int *p_rem_len = net_buf_user_data(rctx->frag);
  402b4c:	aa1303e1 	mov	x1, x19
  402b50:	f8498c22 	ldr	x2, [x1, #152]!
    *p_rem_len = rctx->rem_len;
  402b54:	b9003040 	str	w0, [x2, #48]
	return z_impl_k_msgq_put(msgq, data, timeout);
  402b58:	d2800002 	mov	x2, #0x0                   	// #0
  402b5c:	91028260 	add	x0, x19, #0xa0
  402b60:	94002ee7 	bl	40e6fc <z_impl_k_msgq_put>
    LOG_DBG("Enqueued item; remaining length %d, queue size %d", *p_rem_len,
  402b64:	17ffffcc 	b	402a94 <can_rx_callback+0x46c>
    if (IS_ENABLED(CONFIG_CAN_FD_MODE) && !len) {
  402b68:	350003a0 	cbnz	w0, 402bdc <can_rx_callback+0x5b4>
        len = data[1];
  402b6c:	39402680 	ldrb	w0, [x20, #9]
        (*index)++;
  402b70:	52800041 	mov	w1, #0x2                   	// #2
            rctx->rem_len = receive_get_sf_length(frame->data, &index);
  402b74:	79426262 	ldrh	w2, [x19, #304]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402b78:	52800815 	mov	w21, #0x40                  	// #64
  402b7c:	4b0102b5 	sub	w21, w21, w1
  402b80:	6b0002bf 	cmp	w21, w0
            rctx->rem_len = receive_get_sf_length(frame->data, &index);
  402b84:	33002c02 	bfxil	w2, w0, #0, #12
  402b88:	79026262 	strh	w2, [x19, #304]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402b8c:	1a8092b5 	csel	w21, w21, w0, ls  // ls = plast
            if (payload_len > can_dlc_to_bytes(frame->dlc)) {
  402b90:	39401282 	ldrb	w2, [x20, #4]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402b94:	12001eb5 	and	w21, w21, #0xff
	return dlc > 0x0F ? 64 : dlc_table[dlc];
  402b98:	71003c5f 	cmp	w2, #0xf
  402b9c:	540000c8 	b.hi	402bb4 <can_rx_callback+0x58c>  // b.pmore
            if (payload_len > can_dlc_to_bytes(frame->dlc)) {
  402ba0:	b0000080 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  402ba4:	911ecc00 	add	x0, x0, #0x7b3
  402ba8:	3862c800 	ldrb	w0, [x0, w2, sxtw]
  402bac:	6b15001f 	cmp	w0, w21
  402bb0:	54fff723 	b.cc	402a94 <can_rx_callback+0x46c>  // b.lo, b.ul, b.last
            rctx->state = ISOTP_RX_STATE_PROCESS_SF;
  402bb4:	79426260 	ldrh	w0, [x19, #304]
  402bb8:	9104c262 	add	x2, x19, #0x130
  402bbc:	12002c00 	and	w0, w0, #0xfff
  402bc0:	32140000 	orr	w0, w0, #0x1000
  402bc4:	79026260 	strh	w0, [x19, #304]
  402bc8:	aa0203e0 	mov	x0, x2
  402bcc:	39400842 	ldrb	w2, [x2, #2]
  402bd0:	121c6c42 	and	w2, w2, #0xfffffff0
  402bd4:	39000802 	strb	w2, [x0, #2]
            break;
  402bd8:	17ffffd1 	b	402b1c <can_rx_callback+0x4f4>
    (*index)++;
  402bdc:	52800021 	mov	w1, #0x1                   	// #1
  402be0:	17ffffe5 	b	402b74 <can_rx_callback+0x54c>
    if ((frame->data[index] & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_CF) {
  402be4:	39402280 	ldrb	w0, [x20, #8]
  402be8:	121c0c00 	and	w0, w0, #0xf0
  402bec:	7100801f 	cmp	w0, #0x20
  402bf0:	540001e0 	b.eq	402c2c <can_rx_callback+0x604>  // b.none
    rctx->state = ISOTP_RX_STATE_ERR;
  402bf4:	b9413260 	ldr	w0, [x19, #304]
  402bf8:	528e0001 	mov	w1, #0x7000                	// #28672
  402bfc:	72bf4001 	movk	w1, #0xfa00, lsl #16
  402c00:	12005c00 	and	w0, w0, #0xffffff
  402c04:	120c5c00 	and	w0, w0, #0xfff00fff
  402c08:	2a010000 	orr	w0, w0, w1
  402c0c:	b9013260 	str	w0, [x19, #304]
        k_work_submit(&rctx->work); // to dispatch complete message
  402c10:	91006260 	add	x0, x19, #0x18
  402c14:	940034fb 	bl	410000 <k_work_submit>
            if (rctx->state == ISOTP_RX_STATE_WAIT_CF) {
  402c18:	f9409a60 	ldr	x0, [x19, #304]
  402c1c:	530c4c00 	ubfx	w0, w0, #12, #8
  402c20:	7100141f 	cmp	w0, #0x5
  402c24:	54fff381 	b.ne	402a94 <can_rx_callback+0x46c>  // b.any
  402c28:	17ffff4f 	b	402964 <can_rx_callback+0x33c>
	z_impl_k_timer_start(timer, duration, period);
  402c2c:	d2800002 	mov	x2, #0x0                   	// #0
  402c30:	9100e260 	add	x0, x19, #0x38
  402c34:	d2800c81 	mov	x1, #0x64                  	// #100
  402c38:	94004162 	bl	4131c0 <z_impl_k_timer_start>
    if ((frame->data[index++] & ISOTP_PCI_SN_MASK) != rctx->sn_expected++) {
  402c3c:	f9409a60 	ldr	x0, [x19, #304]
  402c40:	3944da62 	ldrb	w2, [x19, #310]
  402c44:	39402281 	ldrb	w1, [x20, #8]
  402c48:	d370cc00 	ubfx	x0, x0, #48, #4
  402c4c:	11000403 	add	w3, w0, #0x1
  402c50:	12000c21 	and	w1, w1, #0xf
  402c54:	33000c62 	bfxil	w2, w3, #0, #4
  402c58:	3904da62 	strb	w2, [x19, #310]
  402c5c:	6b00003f 	cmp	w1, w0
  402c60:	54000220 	b.eq	402ca4 <can_rx_callback+0x67c>  // b.none
        LOG_ERR("Sequence number mismatch");
  402c64:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  402c68:	52800000 	mov	w0, #0x0                   	// #0
  402c6c:	b0000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  402c70:	52800005 	mov	w5, #0x0                   	// #0
  402c74:	f9478821 	ldr	x1, [x1, #3856]
  402c78:	911bccc6 	add	x6, x6, #0x6f3
  402c7c:	d2800004 	mov	x4, #0x0                   	// #0
  402c80:	d2800003 	mov	x3, #0x0                   	// #0
  402c84:	52800022 	mov	w2, #0x1                   	// #1
  402c88:	97fffd4b 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  402c8c:	b9413260 	ldr	w0, [x19, #304]
  402c90:	528e0001 	mov	w1, #0x7000                	// #28672
  402c94:	72bf8001 	movk	w1, #0xfc00, lsl #16
  402c98:	12005c00 	and	w0, w0, #0xffffff
  402c9c:	120c5c00 	and	w0, w0, #0xfff00fff
  402ca0:	17ffffda 	b	402c08 <can_rx_callback+0x5e0>
    data_len = MIN(rctx->rem_len, can_dlc_to_bytes(frame->dlc) - index);
  402ca4:	f9409a62 	ldr	x2, [x19, #304]
  402ca8:	39401281 	ldrb	w1, [x20, #4]
  402cac:	12002c42 	and	w2, w2, #0xfff
  402cb0:	71003c3f 	cmp	w1, #0xf
  402cb4:	54000488 	b.hi	402d44 <can_rx_callback+0x71c>  // b.pmore
  402cb8:	b0000080 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  402cbc:	911ecc00 	add	x0, x0, #0x7b3
  402cc0:	3861c801 	ldrb	w1, [x0, w1, sxtw]
  402cc4:	51000421 	sub	w1, w1, #0x1
  402cc8:	6b01005f 	cmp	w2, w1
  402ccc:	f9404e60 	ldr	x0, [x19, #152]
  402cd0:	1a82a035 	csel	w21, w1, w2, ge  // ge = tcont
  402cd4:	1a82a022 	csel	w2, w1, w2, ge  // ge = tcont
  402cd8:	91002681 	add	x1, x20, #0x9
  402cdc:	91006000 	add	x0, x0, #0x18
  402ce0:	940026dc 	bl	40c850 <net_buf_simple_add_mem>
    rctx->rem_len -= data_len;
  402ce4:	f9409a60 	ldr	x0, [x19, #304]
  402ce8:	79426261 	ldrh	w1, [x19, #304]
  402cec:	4b150000 	sub	w0, w0, w21
  402cf0:	12002c00 	and	w0, w0, #0xfff
  402cf4:	33002c01 	bfxil	w1, w0, #0, #12
  402cf8:	79026261 	strh	w1, [x19, #304]
    int *p_rem_len = net_buf_user_data(rctx->frag);
  402cfc:	aa1303e1 	mov	x1, x19
  402d00:	f8498c22 	ldr	x2, [x1, #152]!
    *p_rem_len = rctx->rem_len;
  402d04:	b9003040 	str	w0, [x2, #48]
	return z_impl_k_msgq_put(msgq, data, timeout);
  402d08:	d2800002 	mov	x2, #0x0                   	// #0
  402d0c:	91028260 	add	x0, x19, #0xa0
  402d10:	94002e7b 	bl	40e6fc <z_impl_k_msgq_put>
    if (rctx->rem_len == 0) {
  402d14:	79426261 	ldrh	w1, [x19, #304]
  402d18:	12002c20 	and	w0, w1, #0xfff
  402d1c:	f2402c3f 	tst	x1, #0xfff
  402d20:	54000161 	b.ne	402d4c <can_rx_callback+0x724>  // b.any
        rctx->state = ISOTP_RX_STATE_RECYCLE;
  402d24:	9104c261 	add	x1, x19, #0x130
  402d28:	32114000 	orr	w0, w0, #0xffff8000
  402d2c:	79026260 	strh	w0, [x19, #304]
  402d30:	aa0103e0 	mov	x0, x1
  402d34:	39400821 	ldrb	w1, [x1, #2]
  402d38:	121c6c21 	and	w1, w1, #0xfffffff0
  402d3c:	39000801 	strb	w1, [x0, #2]
  402d40:	17ffffb4 	b	402c10 <can_rx_callback+0x5e8>
  402d44:	52800801 	mov	w1, #0x40                  	// #64
  402d48:	17ffffdf 	b	402cc4 <can_rx_callback+0x69c>
    if (rctx->ctx->opts->bs && !--rctx->bs) {
  402d4c:	f9400662 	ldr	x2, [x19, #8]
  402d50:	f9400841 	ldr	x1, [x2, #16]
  402d54:	39400021 	ldrb	w1, [x1]
  402d58:	34fff601 	cbz	w1, 402c18 <can_rx_callback+0x5f0>
  402d5c:	3944d661 	ldrb	w1, [x19, #309]
  402d60:	51000421 	sub	w1, w1, #0x1
  402d64:	12001c21 	and	w1, w1, #0xff
  402d68:	3904d661 	strb	w1, [x19, #309]
  402d6c:	35fff561 	cbnz	w1, 402c18 <can_rx_callback+0x5f0>
        rctx->bs = rctx->ctx->opts->bs;
  402d70:	f9400841 	ldr	x1, [x2, #16]
        rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402d74:	32140400 	orr	w0, w0, #0x3000
        rctx->bs = rctx->ctx->opts->bs;
  402d78:	39400021 	ldrb	w1, [x1]
  402d7c:	3904d661 	strb	w1, [x19, #309]
        rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402d80:	9104c261 	add	x1, x19, #0x130
  402d84:	79026260 	strh	w0, [x19, #304]
  402d88:	aa0103e0 	mov	x0, x1
  402d8c:	39400821 	ldrb	w1, [x1, #2]
  402d90:	121c6c21 	and	w1, w1, #0xfffffff0
  402d94:	39000801 	strb	w1, [x0, #2]
            if (rctx->state == ISOTP_RX_STATE_WAIT_CF) {
  402d98:	17ffff3f 	b	402a94 <can_rx_callback+0x46c>

0000000000402d9c <send_work_handler>:
{
  402d9c:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
  402da0:	b0000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  402da4:	910003fd 	mov	x29, sp
  402da8:	f9476821 	ldr	x1, [x1, #3792]
  402dac:	a90153f3 	stp	x19, x20, [sp, #16]
    struct isotp_fast_send_ctx *sctx = CONTAINER_OF(work, struct isotp_fast_send_ctx, work);
  402db0:	d1006013 	sub	x19, x0, #0x18
{
  402db4:	a9025bf5 	stp	x21, x22, [sp, #32]
  402db8:	a90363f7 	stp	x23, x24, [sp, #48]
  402dbc:	a9046bf9 	stp	x25, x26, [sp, #64]
  402dc0:	a90573fb 	stp	x27, x28, [sp, #80]
  402dc4:	f9400022 	ldr	x2, [x1]
  402dc8:	f9005fe2 	str	x2, [sp, #184]
  402dcc:	d2800002 	mov	x2, #0x0                   	// #0
    send_state_machine(sctx);
  402dd0:	f90037f3 	str	x19, [sp, #104]
    switch (sctx->state) {
  402dd4:	f9406261 	ldr	x1, [x19, #192]
  402dd8:	530c4c21 	ubfx	w1, w1, #12, #8
  402ddc:	51000821 	sub	w1, w1, #0x2
  402de0:	7100183f 	cmp	w1, #0x6
  402de4:	54001e08 	b.hi	4031a4 <send_work_handler+0x408>  // b.pmore
  402de8:	b0000082 	adrp	x2, 413000 <z_timer_expiration_handler+0x68>
  402dec:	91154042 	add	x2, x2, #0x550
  402df0:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  402df4:	10000061 	adr	x1, 402e00 <send_work_handler+0x64>
  402df8:	8b22a822 	add	x2, x1, w2, sxth #2
  402dfc:	d61f0040 	br	x2
    frame->id = addr;
  402e00:	b9401262 	ldr	w2, [x19, #16]

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len,
  402e04:	d28007c3 	mov	x3, #0x3e                  	// #62
  402e08:	b94073e1 	ldr	w1, [sp, #112]
    prepare_frame(&frame, sctx->ctx, sctx->recipient_addr);
  402e0c:	f9400678 	ldr	x24, [x19, #8]
    frame->id = addr;
  402e10:	33007041 	bfxil	w1, w2, #0, #29
  402e14:	b90073e1 	str	w1, [sp, #112]
    uint16_t len = sctx->rem_len;
  402e18:	a94b8276 	ldp	x22, x0, [x19, #184]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402e1c:	f9400b01 	ldr	x1, [x24, #16]
  402e20:	39400821 	ldrb	w1, [x1, #2]
    uint16_t len = sctx->rem_len;
  402e24:	12002c14 	and	w20, w0, #0xfff
  402e28:	d3402c15 	ubfx	x21, x0, #0, #12
        frame.data[index++] = ISOTP_PCI_TYPE_FF | (len >> 8);
  402e2c:	53082c00 	ubfx	w0, w0, #8, #4
  402e30:	321c0000 	orr	w0, w0, #0x10
  402e34:	3901e3e0 	strb	w0, [sp, #120]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402e38:	d341fc21 	lsr	x1, x1, #1
    sctx->sn = 1;
  402e3c:	39434a60 	ldrb	w0, [x19, #210]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402e40:	121e0021 	and	w1, w1, #0x4
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402e44:	7101029f 	cmp	w20, #0x40
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402e48:	32000021 	orr	w1, w1, #0x1
  402e4c:	3901d7e1 	strb	w1, [sp, #117]
    sctx->sn = 1;
  402e50:	52800021 	mov	w1, #0x1                   	// #1
        frame.data[index++] = len & 0xFF;
  402e54:	3901e7f4 	strb	w20, [sp, #121]
    sctx->sn = 1;
  402e58:	33000c20 	bfxil	w0, w1, #0, #4
  402e5c:	39034a60 	strb	w0, [x19, #210]
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402e60:	52800800 	mov	w0, #0x40                  	// #64
  402e64:	1a8092b5 	csel	w21, w21, w0, ls  // ls = plast
  402e68:	12003eb5 	and	w21, w21, #0xffff
  402e6c:	aa1603e1 	mov	x1, x22
  402e70:	51000ab7 	sub	w23, w21, #0x2
  402e74:	9101ebe0 	add	x0, sp, #0x7a
    memcpy(&frame.data[index], sctx->data, size);
  402e78:	92403ef7 	and	x23, x23, #0xffff
    sctx->rem_len -= size;
  402e7c:	11000a94 	add	w20, w20, #0x2
  402e80:	aa1703e2 	mov	x2, x23
  402e84:	97fff8f3 	bl	401250 <__memcpy_chk@plt>
  402e88:	79418260 	ldrh	w0, [x19, #192]
  402e8c:	4b150294 	sub	w20, w20, w21
    sctx->data += size;
  402e90:	8b1702d6 	add	x22, x22, x23
  402e94:	f9005e76 	str	x22, [x19, #184]
    sctx->rem_len -= size;
  402e98:	33002e80 	bfxil	w0, w20, #0, #12
  402e9c:	79018260 	strh	w0, [x19, #192]
    frame.dlc = can_bytes_to_dlc(CAN_MAX_DLEN);
  402ea0:	528001e0 	mov	w0, #0xf                   	// #15
  402ea4:	3901d3e0 	strb	w0, [sp, #116]
    ret = can_send(sctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), send_can_tx_callback,
  402ea8:	f9400300 	ldr	x0, [x24]
		union { uintptr_t x; void * val; } parm4 = { .val = user_data };
		return (int) arch_syscall_invoke5(parm0.x, parm1.x, parm2.x, parm3.x, parm4.x, K_SYSCALL_CAN_SEND);
	}
#endif
	compiler_barrier();
	return z_impl_can_send(dev, frame, timeout, callback, user_data);
  402eac:	d2800c82 	mov	x2, #0x64                  	// #100
  402eb0:	aa1303e4 	mov	x4, x19
  402eb4:	9101c3e1 	add	x1, sp, #0x70
  402eb8:	90000003 	adrp	x3, 402000 <__floatunditf+0x60>
  402ebc:	91033063 	add	x3, x3, #0xcc
  402ec0:	940026d2 	bl	40ca08 <z_impl_can_send>
            k_timer_start(&sctx->timer, K_MSEC(ISOTP_BS_TIMEOUT_MS), K_NO_WAIT);
  402ec4:	f94037e0 	ldr	x0, [sp, #104]
  402ec8:	9100e000 	add	x0, x0, #0x38
	z_impl_k_timer_start(timer, duration, period);
  402ecc:	d2800002 	mov	x2, #0x0                   	// #0
  402ed0:	d2800c81 	mov	x1, #0x64                  	// #100
  402ed4:	940040bb 	bl	4131c0 <z_impl_k_timer_start>
                    sctx->state = ISOTP_TX_WAIT_FC;
  402ed8:	f94037e1 	ldr	x1, [sp, #104]
  402edc:	79418020 	ldrh	w0, [x1, #192]
  402ee0:	12002c00 	and	w0, w0, #0xfff
  402ee4:	32140400 	orr	w0, w0, #0x3000
  402ee8:	14000047 	b	403004 <send_work_handler+0x268>
  402eec:	90000015 	adrp	x21, 402000 <__floatunditf+0x60>
  402ef0:	9101c3f7 	add	x23, sp, #0x70
  402ef4:	9101e7f8 	add	x24, sp, #0x79
  402ef8:	910332b5 	add	x21, x21, #0xcc
    len = MIN(sctx->rem_len, CAN_MAX_DLEN - index);
  402efc:	528007f6 	mov	w22, #0x3f                  	// #63
            k_timer_stop(&sctx->timer);
  402f00:	91008000 	add	x0, x0, #0x20
  402f04:	97fffc71 	bl	4020c8 <k_timer_stop>
                ret = send_cf(sctx);
  402f08:	f94037f3 	ldr	x19, [sp, #104]
  402f0c:	d28007e3 	mov	x3, #0x3f                  	// #63
    frame->id = addr;
  402f10:	b94073e0 	ldr	w0, [sp, #112]
  402f14:	b9401261 	ldr	w1, [x19, #16]
    prepare_frame(&frame, sctx->ctx, sctx->recipient_addr);
  402f18:	f940067b 	ldr	x27, [x19, #8]
    frame->id = addr;
  402f1c:	33007020 	bfxil	w0, w1, #0, #29
  402f20:	b90073e0 	str	w0, [sp, #112]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402f24:	f9400b60 	ldr	x0, [x27, #16]
  402f28:	39400800 	ldrb	w0, [x0, #2]
  402f2c:	d341fc00 	lsr	x0, x0, #1
  402f30:	121e0000 	and	w0, w0, #0x4
  402f34:	32000000 	orr	w0, w0, #0x1
  402f38:	3901d7e0 	strb	w0, [sp, #117]
    frame.data[index++] = ISOTP_PCI_TYPE_CF | sctx->sn;
  402f3c:	f9406a60 	ldr	x0, [x19, #208]
  402f40:	d3504c00 	ubfx	x0, x0, #16, #4
  402f44:	321b0000 	orr	w0, w0, #0x20
  402f48:	3901e3e0 	strb	w0, [sp, #120]
  402f4c:	aa1803e0 	mov	x0, x24
    len = MIN(sctx->rem_len, CAN_MAX_DLEN - index);
  402f50:	a94bd27a 	ldp	x26, x20, [x19, #184]
  402f54:	12002e94 	and	w20, w20, #0xfff
  402f58:	aa1a03e1 	mov	x1, x26
  402f5c:	7100fe9f 	cmp	w20, #0x3f
  402f60:	1a969299 	csel	w25, w20, w22, ls  // ls = plast
    memcpy(&frame.data[index], sctx->data, len);
  402f64:	2a1903fc 	mov	w28, w25
    sctx->rem_len -= len;
  402f68:	4b190294 	sub	w20, w20, w25
  402f6c:	aa1c03e2 	mov	x2, x28
  402f70:	97fff8b8 	bl	401250 <__memcpy_chk@plt>
  402f74:	79418260 	ldrh	w0, [x19, #192]
    sctx->data += len;
  402f78:	8b1c035a 	add	x26, x26, x28
  402f7c:	f9005e7a 	str	x26, [x19, #184]
    sctx->rem_len -= len;
  402f80:	33002e80 	bfxil	w0, w20, #0, #12
  402f84:	79018260 	strh	w0, [x19, #192]
    frame.dlc = can_bytes_to_dlc(len + index);
  402f88:	11000720 	add	w0, w25, #0x1
  402f8c:	97fffc6f 	bl	402148 <can_bytes_to_dlc>
  402f90:	3901d3e0 	strb	w0, [sp, #116]
    ret = can_send(sctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), send_can_tx_callback,
  402f94:	f9400360 	ldr	x0, [x27]
  402f98:	d2800c82 	mov	x2, #0x64                  	// #100
  402f9c:	aa1303e4 	mov	x4, x19
  402fa0:	aa1503e3 	mov	x3, x21
  402fa4:	aa1703e1 	mov	x1, x23
  402fa8:	94002698 	bl	40ca08 <z_impl_can_send>
  402fac:	2a0003f4 	mov	w20, w0
    if (ret == 0) {
  402fb0:	7100001f 	cmp	w0, #0x0
  402fb4:	35000ca0 	cbnz	w0, 403148 <send_work_handler+0x3ac>
        sctx->sn++;
  402fb8:	f9406a60 	ldr	x0, [x19, #208]
  402fbc:	39434a61 	ldrb	w1, [x19, #210]
  402fc0:	d3504c00 	ubfx	x0, x0, #16, #4
  402fc4:	11000400 	add	w0, w0, #0x1
  402fc8:	33000c01 	bfxil	w1, w0, #0, #4
        sctx->bs--;
  402fcc:	39434660 	ldrb	w0, [x19, #209]
        sctx->sn++;
  402fd0:	39034a61 	strb	w1, [x19, #210]
        sctx->bs--;
  402fd4:	51000400 	sub	w0, w0, #0x1
  402fd8:	39034660 	strb	w0, [x19, #209]
        sctx->backlog++;
  402fdc:	39434e60 	ldrb	w0, [x19, #211]
  402fe0:	11000400 	add	w0, w0, #0x1
  402fe4:	39034e60 	strb	w0, [x19, #211]
    ret = ret ? ret : sctx->rem_len;
  402fe8:	f9406260 	ldr	x0, [x19, #192]
                if (!ret) {
  402fec:	f2402c1f 	tst	x0, #0xfff
  402ff0:	54000141 	b.ne	403018 <send_work_handler+0x27c>  // b.any
                    sctx->state = ISOTP_TX_WAIT_BACKLOG;
  402ff4:	f94037e1 	ldr	x1, [sp, #104]
  402ff8:	79418020 	ldrh	w0, [x1, #192]
  402ffc:	12002c00 	and	w0, w0, #0xfff
  403000:	32130400 	orr	w0, w0, #0x6000
            sctx->state = ISOTP_TX_SEND_CF;
  403004:	79018020 	strh	w0, [x1, #192]
  403008:	39430820 	ldrb	w0, [x1, #194]
  40300c:	121c6c00 	and	w0, w0, #0xfffffff0
  403010:	39030820 	strb	w0, [x1, #194]
            break;
  403014:	14000064 	b	4031a4 <send_work_handler+0x408>
                if (sctx->ctx->opts->bs && !sctx->bs) {
  403018:	f94037e0 	ldr	x0, [sp, #104]
  40301c:	f9400401 	ldr	x1, [x0, #8]
  403020:	f9400821 	ldr	x1, [x1, #16]
  403024:	39400021 	ldrb	w1, [x1]
  403028:	340000e1 	cbz	w1, 403044 <send_work_handler+0x2a8>
  40302c:	39434401 	ldrb	w1, [x0, #209]
  403030:	350000a1 	cbnz	w1, 403044 <send_work_handler+0x2a8>
  403034:	d2800002 	mov	x2, #0x0                   	// #0
  403038:	9100e000 	add	x0, x0, #0x38
  40303c:	d2800c81 	mov	x1, #0x64                  	// #100
  403040:	17ffffa5 	b	402ed4 <send_work_handler+0x138>
                else if (sctx->stmin) {
  403044:	39435001 	ldrb	w1, [x0, #212]
  403048:	34000161 	cbz	w1, 403074 <send_work_handler+0x2d8>
                    sctx->state = ISOTP_TX_WAIT_ST;
  40304c:	79418001 	ldrh	w1, [x0, #192]
  403050:	91030002 	add	x2, x0, #0xc0
  403054:	528a0003 	mov	w3, #0x5000                	// #20480
  403058:	12002c21 	and	w1, w1, #0xfff
  40305c:	2a030021 	orr	w1, w1, w3
  403060:	79018001 	strh	w1, [x0, #192]
  403064:	39430800 	ldrb	w0, [x0, #194]
  403068:	121c6c00 	and	w0, w0, #0xfffffff0
  40306c:	39000840 	strb	w0, [x2, #2]
                    break;
  403070:	1400004d 	b	4031a4 <send_work_handler+0x408>
	return z_impl_k_sem_take(sem, timeout);
  403074:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  403078:	91024000 	add	x0, x0, #0x90
  40307c:	94003196 	bl	40f6d4 <z_impl_k_sem_take>
            } while (ret > 0);
  403080:	17ffffa2 	b	402f08 <send_work_handler+0x16c>
            k_timer_start(&sctx->timer, stmin_to_timeout(sctx->stmin), K_NO_WAIT);
  403084:	39435261 	ldrb	w1, [x19, #212]
  403088:	91008000 	add	x0, x0, #0x20
    if (stmin > ISOTP_STMIN_MAX || (stmin > ISOTP_STMIN_MS_MAX && stmin < ISOTP_STMIN_US_BEGIN)) {
  40308c:	51020022 	sub	w2, w1, #0x80
  403090:	12001c42 	and	w2, w2, #0xff
  403094:	7101c05f 	cmp	w2, #0x70
  403098:	52801f42 	mov	w2, #0xfa                  	// #250
  40309c:	7a428022 	ccmp	w1, w2, #0x2, hi  // hi = pmore
  4030a0:	540001c8 	b.hi	4030d8 <send_work_handler+0x33c>  // b.pmore
    if (stmin >= ISOTP_STMIN_US_BEGIN) {
  4030a4:	7103c03f 	cmp	w1, #0xf0
  4030a8:	540001c8 	b.hi	4030e0 <send_work_handler+0x344>  // b.pmore
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
  4030ac:	11002421 	add	w1, w1, #0x9
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
  4030b0:	d2800142 	mov	x2, #0xa                   	// #10
		t += off;
  4030b4:	92401c21 	and	x1, x1, #0xff
			return t / ((uint64_t)from_hz / to_hz);
  4030b8:	9ac20821 	udiv	x1, x1, x2
	z_impl_k_timer_start(timer, duration, period);
  4030bc:	d2800002 	mov	x2, #0x0                   	// #0
  4030c0:	94004040 	bl	4131c0 <z_impl_k_timer_start>
            sctx->state = ISOTP_TX_SEND_CF;
  4030c4:	f94037e1 	ldr	x1, [sp, #104]
  4030c8:	79418020 	ldrh	w0, [x1, #192]
  4030cc:	12002c00 	and	w0, w0, #0xfff
  4030d0:	32120000 	orr	w0, w0, #0x4000
  4030d4:	17ffffcc 	b	403004 <send_work_handler+0x268>
        return K_MSEC(ISOTP_STMIN_MS_MAX);
  4030d8:	d28001a1 	mov	x1, #0xd                   	// #13
  4030dc:	17fffff8 	b	4030bc <send_work_handler+0x320>
        return K_USEC((stmin + 1 - ISOTP_STMIN_US_BEGIN) * 100U);
  4030e0:	d2800021 	mov	x1, #0x1                   	// #1
  4030e4:	17fffff6 	b	4030bc <send_work_handler+0x320>
            sctx->ctx->sent_callback(sctx->error, sctx->cb_arg);
  4030e8:	f9400660 	ldr	x0, [x19, #8]
  4030ec:	f9406661 	ldr	x1, [x19, #200]
  4030f0:	f9401802 	ldr	x2, [x0, #48]
  4030f4:	39c30e60 	ldrsb	w0, [x19, #195]
            sctx->ctx->sent_callback(ISOTP_N_OK, sctx->cb_arg);
  4030f8:	d63f0040 	blr	x2
            sctx->state = ISOTP_TX_STATE_RESET;
  4030fc:	f94037e0 	ldr	x0, [sp, #104]
  403100:	91030002 	add	x2, x0, #0xc0
  403104:	79418001 	ldrh	w1, [x0, #192]
  403108:	12002c21 	and	w1, w1, #0xfff
  40310c:	79018001 	strh	w1, [x0, #192]
  403110:	39430800 	ldrb	w0, [x0, #194]
  403114:	121c6c00 	and	w0, w0, #0xfffffff0
  403118:	39000840 	strb	w0, [x2, #2]
            free_send_ctx(&sctx);
  40311c:	9101a3e0 	add	x0, sp, #0x68
  403120:	97fffce7 	bl	4024bc <free_send_ctx>
}
  403124:	14000020 	b	4031a4 <send_work_handler+0x408>
            k_timer_stop(&sctx->timer);
  403128:	91008000 	add	x0, x0, #0x20
  40312c:	97fffbe7 	bl	4020c8 <k_timer_stop>
            sctx->ctx->sent_callback(ISOTP_N_OK, sctx->cb_arg);
  403130:	f94037e0 	ldr	x0, [sp, #104]
  403134:	f9400401 	ldr	x1, [x0, #8]
  403138:	f9401822 	ldr	x2, [x1, #48]
  40313c:	f9406401 	ldr	x1, [x0, #200]
  403140:	52800000 	mov	w0, #0x0                   	// #0
  403144:	17ffffed 	b	4030f8 <send_work_handler+0x35c>
                if (ret < 0) {
  403148:	54fff68a 	b.ge	403018 <send_work_handler+0x27c>  // b.tcont
                    LOG_ERR("Failed to send CF");
  40314c:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  403150:	52800022 	mov	w2, #0x1                   	// #1
  403154:	52800000 	mov	w0, #0x0                   	// #0
  403158:	90000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  40315c:	f9478821 	ldr	x1, [x1, #3856]
  403160:	911c30c6 	add	x6, x6, #0x70c
  403164:	52800005 	mov	w5, #0x0                   	// #0
  403168:	d2800004 	mov	x4, #0x0                   	// #0
  40316c:	d2800003 	mov	x3, #0x0                   	// #0
  403170:	97fffc11 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
                    send_report_error(sctx, ret == -EAGAIN ? ISOTP_N_TIMEOUT_A : ISOTP_N_ERROR);
  403174:	f94037e1 	ldr	x1, [sp, #104]
  403178:	31002e9f 	cmn	w20, #0xb
  40317c:	12800102 	mov	w2, #0xfffffff7            	// #-9
  403180:	5a9f1042 	csinv	w2, w2, wzr, ne  // ne = any
    sctx->state = ISOTP_TX_ERR;
  403184:	79418020 	ldrh	w0, [x1, #192]
    sctx->error = err;
  403188:	39030c22 	strb	w2, [x1, #195]
    sctx->state = ISOTP_TX_ERR;
  40318c:	12002c00 	and	w0, w0, #0xfff
  403190:	32114000 	orr	w0, w0, #0xffff8000
  403194:	79018020 	strh	w0, [x1, #192]
  403198:	39430820 	ldrb	w0, [x1, #194]
  40319c:	121c6c00 	and	w0, w0, #0xfffffff0
  4031a0:	39030820 	strb	w0, [x1, #194]
}
  4031a4:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4031a8:	f9476800 	ldr	x0, [x0, #3792]
  4031ac:	f9405fe2 	ldr	x2, [sp, #184]
  4031b0:	f9400001 	ldr	x1, [x0]
  4031b4:	eb010042 	subs	x2, x2, x1
  4031b8:	d2800001 	mov	x1, #0x0                   	// #0
  4031bc:	54000040 	b.eq	4031c4 <send_work_handler+0x428>  // b.none
  4031c0:	97fff858 	bl	401320 <__stack_chk_fail@plt>
  4031c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4031c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4031cc:	a94363f7 	ldp	x23, x24, [sp, #48]
  4031d0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4031d4:	a94573fb 	ldp	x27, x28, [sp, #80]
  4031d8:	a8cc7bfd 	ldp	x29, x30, [sp], #192
  4031dc:	d65f03c0 	ret

00000000004031e0 <receive_state_machine>:
{
  4031e0:	d10143ff 	sub	sp, sp, #0x50
  4031e4:	a9017bfd 	stp	x29, x30, [sp, #16]
  4031e8:	910043fd 	add	x29, sp, #0x10
  4031ec:	f9001fe0 	str	x0, [sp, #56]
  4031f0:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4031f4:	f90013f3 	str	x19, [sp, #32]
	return z_impl_k_msgq_get(msgq, data, timeout);
  4031f8:	910103f3 	add	x19, sp, #0x40
  4031fc:	f9476800 	ldr	x0, [x0, #3792]
  403200:	f9400001 	ldr	x1, [x0]
  403204:	f90027e1 	str	x1, [sp, #72]
  403208:	d2800001 	mov	x1, #0x0                   	// #0
    while (k_msgq_get(&rctx->recv_queue, &frag, K_NO_WAIT) == 0) {
  40320c:	f9401fe0 	ldr	x0, [sp, #56]
  403210:	91028000 	add	x0, x0, #0xa0
  403214:	d2800002 	mov	x2, #0x0                   	// #0
  403218:	aa1303e1 	mov	x1, x19
  40321c:	94002dde 	bl	40e994 <z_impl_k_msgq_get>
  403220:	2a0003e1 	mov	w1, w0
  403224:	f9401fe0 	ldr	x0, [sp, #56]
  403228:	34000181 	cbz	w1, 403258 <receive_state_machine+0x78>
    switch (rctx->state) {
  40322c:	f9409807 	ldr	x7, [x0, #304]
  403230:	530c4ce1 	ubfx	w1, w7, #12, #8
  403234:	51000421 	sub	w1, w1, #0x1
  403238:	71001c3f 	cmp	w1, #0x7
  40323c:	540002e8 	b.hi	403298 <receive_state_machine+0xb8>  // b.pmore
  403240:	90000082 	adrp	x2, 413000 <z_timer_expiration_handler+0x68>
  403244:	91158042 	add	x2, x2, #0x560
  403248:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  40324c:	10000061 	adr	x1, 403258 <receive_state_machine+0x78>
  403250:	8b22a822 	add	x2, x1, w2, sxth #2
  403254:	d61f0040 	br	x2
        rctx->ctx->recv_callback(frag, *p_rem_len, rctx->sender_addr, rctx->ctx->recv_cb_arg);
  403258:	f9400401 	ldr	x1, [x0, #8]
        int *p_rem_len = net_buf_user_data(frag);
  40325c:	f94023e4 	ldr	x4, [sp, #64]
        rctx->ctx->recv_callback(frag, *p_rem_len, rctx->sender_addr, rctx->ctx->recv_cb_arg);
  403260:	a9418c25 	ldp	x5, x3, [x1, #24]
  403264:	b9401002 	ldr	w2, [x0, #16]
  403268:	aa0403e0 	mov	x0, x4
  40326c:	b9403081 	ldr	w1, [x4, #48]
  403270:	d63f00a0 	blr	x5
        net_buf_unref(frag);
  403274:	f94023e0 	ldr	x0, [sp, #64]
  403278:	94002507 	bl	40c694 <net_buf_unref>
  40327c:	17ffffe4 	b	40320c <receive_state_machine+0x2c>
            rctx->state = ISOTP_RX_STATE_RECYCLE;
  403280:	128fffe1 	mov	w1, #0xffff8000            	// #-32768
  403284:	79026001 	strh	w1, [x0, #304]
  403288:	3944c801 	ldrb	w1, [x0, #306]
  40328c:	121c6c21 	and	w1, w1, #0xfffffff0
  403290:	3904c801 	strb	w1, [x0, #306]
                receive_state_machine(rctx);
  403294:	97ffffd3 	bl	4031e0 <receive_state_machine>
}
  403298:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40329c:	f9476800 	ldr	x0, [x0, #3792]
  4032a0:	f94027e2 	ldr	x2, [sp, #72]
  4032a4:	f9400001 	ldr	x1, [x0]
  4032a8:	eb010042 	subs	x2, x2, x1
  4032ac:	d2800001 	mov	x1, #0x0                   	// #0
  4032b0:	540011c0 	b.eq	4034e8 <receive_state_machine+0x308>  // b.none
  4032b4:	97fff81b 	bl	401320 <__stack_chk_fail@plt>
            if (rctx->ctx->opts->bs == 0
  4032b8:	f9400401 	ldr	x1, [x0, #8]
  4032bc:	f9400821 	ldr	x1, [x1, #16]
  4032c0:	39400021 	ldrb	w1, [x1]
  4032c4:	35000321 	cbnz	w1, 403328 <receive_state_machine+0x148>
                && rctx->rem_len > CONFIG_ISOTP_FAST_RX_MAX_PACKET_COUNT * (CAN_MAX_DLEN - 1))
  4032c8:	12002ce7 	and	w7, w7, #0xfff
  4032cc:	7104ecff 	cmp	w7, #0x13b
  4032d0:	540002e9 	b.ls	40332c <receive_state_machine+0x14c>  // b.plast
                LOG_ERR("Pkt length is %d but buffer has only %d bytes", rctx->rem_len,
  4032d4:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4032d8:	52802760 	mov	w0, #0x13b                 	// #315
  4032dc:	b90003e0 	str	w0, [sp]
  4032e0:	52800022 	mov	w2, #0x1                   	// #1
  4032e4:	f9478821 	ldr	x1, [x1, #3856]
  4032e8:	52800000 	mov	w0, #0x0                   	// #0
  4032ec:	90000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  4032f0:	52800005 	mov	w5, #0x0                   	// #0
  4032f4:	911c78c6 	add	x6, x6, #0x71e
  4032f8:	d2800004 	mov	x4, #0x0                   	// #0
  4032fc:	d2800003 	mov	x3, #0x0                   	// #0
  403300:	97fffbad 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
                receive_report_error(rctx, ISOTP_N_BUFFER_OVERFLW);
  403304:	f9401fe0 	ldr	x0, [sp, #56]
    rctx->state = ISOTP_RX_STATE_ERR;
  403308:	528e0002 	mov	w2, #0x7000                	// #28672
  40330c:	72bf0002 	movk	w2, #0xf800, lsl #16
  403310:	b9413001 	ldr	w1, [x0, #304]
  403314:	12005c21 	and	w1, w1, #0xffffff
  403318:	120c5c21 	and	w1, w1, #0xfff00fff
  40331c:	2a020021 	orr	w1, w1, w2
  403320:	b9013001 	str	w1, [x0, #304]
  403324:	17ffffdc 	b	403294 <receive_state_machine+0xb4>
                rctx->bs = rctx->ctx->opts->bs;
  403328:	3904d401 	strb	w1, [x0, #309]
            rctx->wft = ISOTP_WFT_FIRST;
  40332c:	12800001 	mov	w1, #0xffffffff            	// #-1
  403330:	3904d001 	strb	w1, [x0, #308]
            rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  403334:	79426001 	ldrh	w1, [x0, #304]
  403338:	9104c002 	add	x2, x0, #0x130
  40333c:	12002c21 	and	w1, w1, #0xfff
  403340:	32140421 	orr	w1, w1, #0x3000
  403344:	79026001 	strh	w1, [x0, #304]
  403348:	aa0203e1 	mov	x1, x2
  40334c:	39400842 	ldrb	w2, [x2, #2]
  403350:	121c6c42 	and	w2, w2, #0xfffffff0
  403354:	39000822 	strb	w2, [x1, #2]
            k_timer_stop(&rctx->timer);
  403358:	9100e000 	add	x0, x0, #0x38
  40335c:	97fffb5b 	bl	4020c8 <k_timer_stop>
            rctx->state = ISOTP_RX_STATE_SEND_FC;
  403360:	f9401fe1 	ldr	x1, [sp, #56]
  403364:	79426020 	ldrh	w0, [x1, #304]
  403368:	12002c00 	and	w0, w0, #0xfff
  40336c:	32120000 	orr	w0, w0, #0x4000
  403370:	79026020 	strh	w0, [x1, #304]
  403374:	3944c820 	ldrb	w0, [x1, #306]
  403378:	121c6c00 	and	w0, w0, #0xfffffff0
  40337c:	3904c820 	strb	w0, [x1, #306]
            receive_send_fc(rctx, ISOTP_PCI_FS_CTS);
  403380:	f9401fe0 	ldr	x0, [sp, #56]
  403384:	52800001 	mov	w1, #0x0                   	// #0
  403388:	9400005c 	bl	4034f8 <receive_send_fc>
            k_timer_start(&rctx->timer, K_MSEC(ISOTP_CR_TIMEOUT_MS), K_NO_WAIT);
  40338c:	f9401fe0 	ldr	x0, [sp, #56]
  403390:	9100e000 	add	x0, x0, #0x38
	z_impl_k_timer_start(timer, duration, period);
  403394:	d2800c81 	mov	x1, #0x64                  	// #100
  403398:	d2800002 	mov	x2, #0x0                   	// #0
  40339c:	94003f89 	bl	4131c0 <z_impl_k_timer_start>
            rctx->state = ISOTP_RX_STATE_WAIT_CF;
  4033a0:	f9401fe1 	ldr	x1, [sp, #56]
  4033a4:	528a0003 	mov	w3, #0x5000                	// #20480
  4033a8:	79426020 	ldrh	w0, [x1, #304]
  4033ac:	12002c00 	and	w0, w0, #0xfff
  4033b0:	2a030000 	orr	w0, w0, w3
                rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  4033b4:	79026020 	strh	w0, [x1, #304]
  4033b8:	3944c820 	ldrb	w0, [x1, #306]
  4033bc:	121c6c00 	and	w0, w0, #0xfffffff0
  4033c0:	3904c820 	strb	w0, [x1, #306]
                break;
  4033c4:	17ffffb5 	b	403298 <receive_state_machine+0xb8>
            if (++rctx->wft < CONFIG_ISOTP_WFTMAX) {
  4033c8:	3944d007 	ldrb	w7, [x0, #308]
  4033cc:	110004e7 	add	w7, w7, #0x1
  4033d0:	12001ce7 	and	w7, w7, #0xff
  4033d4:	3904d007 	strb	w7, [x0, #308]
  4033d8:	710024ff 	cmp	w7, #0x9
  4033dc:	540001a8 	b.hi	403410 <receive_state_machine+0x230>  // b.pmore
                receive_send_fc(rctx, ISOTP_PCI_FS_WAIT);
  4033e0:	52800021 	mov	w1, #0x1                   	// #1
  4033e4:	94000045 	bl	4034f8 <receive_send_fc>
                k_timer_start(&rctx->timer, K_MSEC(ISOTP_ALLOC_TIMEOUT_MS), K_NO_WAIT);
  4033e8:	f9401fe0 	ldr	x0, [sp, #56]
  4033ec:	9100e000 	add	x0, x0, #0x38
  4033f0:	d2800b41 	mov	x1, #0x5a                  	// #90
  4033f4:	d2800002 	mov	x2, #0x0                   	// #0
  4033f8:	94003f72 	bl	4131c0 <z_impl_k_timer_start>
                rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  4033fc:	f9401fe1 	ldr	x1, [sp, #56]
  403400:	79426020 	ldrh	w0, [x1, #304]
  403404:	12002c00 	and	w0, w0, #0xfff
  403408:	32140400 	orr	w0, w0, #0x3000
  40340c:	17ffffea 	b	4033b4 <receive_state_machine+0x1d4>
            LOG_ERR("Sent %d wait frames. Giving up to alloc now", rctx->wft);
  403410:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  403414:	52800022 	mov	w2, #0x1                   	// #1
  403418:	52800000 	mov	w0, #0x0                   	// #0
  40341c:	90000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  403420:	f9478821 	ldr	x1, [x1, #3856]
  403424:	911d30c6 	add	x6, x6, #0x74c
  403428:	52800005 	mov	w5, #0x0                   	// #0
  40342c:	d2800004 	mov	x4, #0x0                   	// #0
  403430:	d2800003 	mov	x3, #0x0                   	// #0
  403434:	97fffb60 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
            receive_report_error(rctx, ISOTP_N_BUFFER_OVERFLW);
  403438:	f9401fe1 	ldr	x1, [sp, #56]
    rctx->state = ISOTP_RX_STATE_ERR;
  40343c:	528e0002 	mov	w2, #0x7000                	// #28672
  403440:	72bf0002 	movk	w2, #0xf800, lsl #16
  403444:	b9413020 	ldr	w0, [x1, #304]
  403448:	12005c00 	and	w0, w0, #0xffffff
  40344c:	120c5c00 	and	w0, w0, #0xfff00fff
  403450:	2a020000 	orr	w0, w0, w2
  403454:	b9013020 	str	w0, [x1, #304]
            k_timer_stop(&rctx->timer);
  403458:	f9401fe0 	ldr	x0, [sp, #56]
  40345c:	9100e000 	add	x0, x0, #0x38
  403460:	97fffb1a 	bl	4020c8 <k_timer_stop>
            if (rctx->ctx->recv_error_callback) {
  403464:	f9401fe0 	ldr	x0, [sp, #56]
  403468:	f9400401 	ldr	x1, [x0, #8]
  40346c:	f9401423 	ldr	x3, [x1, #40]
  403470:	b40000a3 	cbz	x3, 403484 <receive_state_machine+0x2a4>
                rctx->ctx->recv_error_callback(rctx->error, rctx->sender_addr,
  403474:	f9401022 	ldr	x2, [x1, #32]
  403478:	b9401001 	ldr	w1, [x0, #16]
  40347c:	3944cc00 	ldrb	w0, [x0, #307]
  403480:	d63f0060 	blr	x3
            if (rctx->error == ISOTP_N_BUFFER_OVERFLW) {
  403484:	f9401fe0 	ldr	x0, [sp, #56]
  403488:	39c4cc01 	ldrsb	w1, [x0, #307]
  40348c:	3100203f 	cmn	w1, #0x8
  403490:	54000061 	b.ne	40349c <receive_state_machine+0x2bc>  // b.any
                receive_send_fc(rctx, ISOTP_PCI_FS_OVFLW);
  403494:	52800041 	mov	w1, #0x2                   	// #2
  403498:	94000018 	bl	4034f8 <receive_send_fc>
    if ((*rctx)->pending) {
  40349c:	f9401fe0 	ldr	x0, [sp, #56]
  4034a0:	3944dc00 	ldrb	w0, [x0, #311]
  4034a4:	35000060 	cbnz	w0, 4034b0 <receive_state_machine+0x2d0>
    free_recv_ctx(rctx);
  4034a8:	9100e3e0 	add	x0, sp, #0x38
  4034ac:	97fffbea 	bl	402454 <free_recv_ctx>
            rctx->state = ISOTP_RX_STATE_UNBOUND;
  4034b0:	f9401fe1 	ldr	x1, [sp, #56]
  4034b4:	128dffe3 	mov	w3, #0xffff9000            	// #-28672
  4034b8:	79426020 	ldrh	w0, [x1, #304]
  4034bc:	12002c00 	and	w0, w0, #0xfff
  4034c0:	2a030000 	orr	w0, w0, w3
  4034c4:	79026020 	strh	w0, [x1, #304]
  4034c8:	3944c820 	ldrb	w0, [x1, #306]
  4034cc:	121c6c00 	and	w0, w0, #0xfffffff0
  4034d0:	3904c820 	strb	w0, [x1, #306]
    if ((*rctx)->pending) {
  4034d4:	3944dc20 	ldrb	w0, [x1, #311]
  4034d8:	35ffee00 	cbnz	w0, 403298 <receive_state_machine+0xb8>
    free_recv_ctx(rctx);
  4034dc:	9100e3e0 	add	x0, sp, #0x38
  4034e0:	97fffbdd 	bl	402454 <free_recv_ctx>
}
  4034e4:	17ffff6d 	b	403298 <receive_state_machine+0xb8>
  4034e8:	a9417bfd 	ldp	x29, x30, [sp, #16]
  4034ec:	f94013f3 	ldr	x19, [sp, #32]
  4034f0:	910143ff 	add	sp, sp, #0x50
  4034f4:	d65f03c0 	ret

00000000004034f8 <receive_send_fc>:
{
  4034f8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    *data++ = ISOTP_PCI_TYPE_FC | fs;
  4034fc:	321c0421 	orr	w1, w1, #0x30
{
  403500:	910003fd 	mov	x29, sp
  403504:	f9000bf3 	str	x19, [sp, #16]
  403508:	aa0003f3 	mov	x19, x0
  40350c:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    struct can_frame frame = {
  403510:	910083e5 	add	x5, sp, #0x20
  403514:	4f000400 	movi	v0.4s, #0x0
{
  403518:	f9476800 	ldr	x0, [x0, #3792]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  40351c:	f9400663 	ldr	x3, [x19, #8]
{
  403520:	f9400002 	ldr	x2, [x0]
  403524:	f90037e2 	str	x2, [sp, #104]
  403528:	d2800002 	mov	x2, #0x0                   	// #0
              | ((rctx->sender_addr & 0xFF) << 8)
  40352c:	79402262 	ldrh	w2, [x19, #16]
        .id = (rctx->sender_addr & 0xFFFF0000) | ((rctx->sender_addr & 0xFF00) >> 8)
  403530:	b9401260 	ldr	w0, [x19, #16]
              | ((rctx->sender_addr & 0xFF) << 8)
  403534:	5ac00442 	rev16	w2, w2
    struct can_frame frame = {
  403538:	ad0000a0 	stp	q0, q0, [x5]
              | ((rctx->sender_addr & 0xFF) << 8)
  40353c:	12003c42 	and	w2, w2, #0xffff
        .id = (rctx->sender_addr & 0xFFFF0000) | ((rctx->sender_addr & 0xFF00) >> 8)
  403540:	12103c00 	and	w0, w0, #0xffff0000
    struct can_frame frame = {
  403544:	f90020bf 	str	xzr, [x5, #64]
              | ((rctx->sender_addr & 0xFF) << 8)
  403548:	2a020000 	orr	w0, w0, w2
    struct can_frame frame = {
  40354c:	b94023e2 	ldr	w2, [sp, #32]
  403550:	ad0100a0 	stp	q0, q0, [x5, #32]
  403554:	33007002 	bfxil	w2, w0, #0, #29
  403558:	b90023e2 	str	w2, [sp, #32]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  40355c:	f9400862 	ldr	x2, [x3, #16]
  403560:	39400840 	ldrb	w0, [x2, #2]
    *data++ = ISOTP_PCI_TYPE_FC | fs;
  403564:	3900a3e1 	strb	w1, [sp, #40]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  403568:	d341fc00 	lsr	x0, x0, #1
  40356c:	121e0000 	and	w0, w0, #0x4
  403570:	32000000 	orr	w0, w0, #0x1
    struct can_frame frame = {
  403574:	390097e0 	strb	w0, [sp, #37]
    *data++ = rctx->ctx->opts->bs;
  403578:	39400040 	ldrb	w0, [x2]
  40357c:	3900a7e0 	strb	w0, [sp, #41]
    *data++ = rctx->ctx->opts->stmin;
  403580:	39400440 	ldrb	w0, [x2, #1]
  403584:	3900abe0 	strb	w0, [sp, #42]
    frame.dlc = can_bytes_to_dlc(payload_len);
  403588:	52800060 	mov	w0, #0x3                   	// #3
  40358c:	390093e0 	strb	w0, [sp, #36]
    ret = can_send(rctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), receive_can_tx, rctx);
  403590:	f9400060 	ldr	x0, [x3]
  403594:	f0ffffe3 	adrp	x3, 402000 <__floatunditf+0x60>
  403598:	aa1303e4 	mov	x4, x19
  40359c:	910b9063 	add	x3, x3, #0x2e4
  4035a0:	aa0503e1 	mov	x1, x5
  4035a4:	d2800c82 	mov	x2, #0x64                  	// #100
  4035a8:	94002518 	bl	40ca08 <z_impl_can_send>
    if (ret) {
  4035ac:	340002a0 	cbz	w0, 403600 <receive_send_fc+0x108>
        LOG_ERR("Can't send FC, (%d)", ret);
  4035b0:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4035b4:	2a0003e7 	mov	w7, w0
  4035b8:	90000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  4035bc:	52800000 	mov	w0, #0x0                   	// #0
  4035c0:	f9478821 	ldr	x1, [x1, #3856]
  4035c4:	911de0c6 	add	x6, x6, #0x778
  4035c8:	52800005 	mov	w5, #0x0                   	// #0
  4035cc:	d2800004 	mov	x4, #0x0                   	// #0
  4035d0:	d2800003 	mov	x3, #0x0                   	// #0
  4035d4:	52800022 	mov	w2, #0x1                   	// #1
  4035d8:	97fffaf7 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  4035dc:	b9413260 	ldr	w0, [x19, #304]
  4035e0:	528e0001 	mov	w1, #0x7000                	// #28672
  4035e4:	72bfe001 	movk	w1, #0xff00, lsl #16
  4035e8:	12005c00 	and	w0, w0, #0xffffff
  4035ec:	120c5c00 	and	w0, w0, #0xfff00fff
  4035f0:	2a010000 	orr	w0, w0, w1
  4035f4:	b9013260 	str	w0, [x19, #304]
        receive_state_machine(rctx);
  4035f8:	aa1303e0 	mov	x0, x19
  4035fc:	97fffef9 	bl	4031e0 <receive_state_machine>
}
  403600:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403604:	f9476800 	ldr	x0, [x0, #3792]
  403608:	f94037e2 	ldr	x2, [sp, #104]
  40360c:	f9400001 	ldr	x1, [x0]
  403610:	eb010042 	subs	x2, x2, x1
  403614:	d2800001 	mov	x1, #0x0                   	// #0
  403618:	54000040 	b.eq	403620 <receive_send_fc+0x128>  // b.none
  40361c:	97fff741 	bl	401320 <__stack_chk_fail@plt>
  403620:	f9400bf3 	ldr	x19, [sp, #16]
  403624:	a8c77bfd 	ldp	x29, x30, [sp], #112
  403628:	d65f03c0 	ret

000000000040362c <receive_work_handler>:
    receive_state_machine(rctx);
  40362c:	d1006000 	sub	x0, x0, #0x18
  403630:	17fffeec 	b	4031e0 <receive_state_machine>

0000000000403634 <isotp_fast_bind>:
int isotp_fast_bind(struct isotp_fast_ctx *ctx, const struct device *can_dev,
                    const isotp_fast_msg_id my_addr, const struct isotp_fast_opts *opts,
                    isotp_fast_recv_callback_t recv_callback, void *recv_cb_arg,
                    isotp_fast_recv_error_callback_t recv_error_callback,
                    isotp_fast_send_callback_t sent_callback)
{
  403634:	d10143ff 	sub	sp, sp, #0x50
  403638:	a9017bfd 	stp	x29, x30, [sp, #16]
  40363c:	910043fd 	add	x29, sp, #0x10
  403640:	f90013f3 	str	x19, [sp, #32]
  403644:	aa0003f3 	mov	x19, x0
  403648:	aa0103e0 	mov	x0, x1
  40364c:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  403650:	f9476821 	ldr	x1, [x1, #3792]
  403654:	f9400028 	ldr	x8, [x1]
  403658:	f90027e8 	str	x8, [sp, #72]
  40365c:	d2800008 	mov	x8, #0x0                   	// #0
	list->head = NULL;
  403660:	b0000141 	adrp	x1, 42c000 <__dso_handle>
  403664:	912b4028 	add	x8, x1, #0xad0
    sys_slist_init(&ctx->wait_recv_list);
#endif

    ctx->can_dev = can_dev;
    ctx->opts = opts;
    ctx->recv_callback = recv_callback;
  403668:	a9011263 	stp	x3, x4, [x19, #16]
  40366c:	f905683f 	str	xzr, [x1, #2768]
  403670:	b0000141 	adrp	x1, 42c000 <__dso_handle>
	list->tail = NULL;
  403674:	f900051f 	str	xzr, [x8, #8]
	list->head = NULL;
  403678:	912b0028 	add	x8, x1, #0xac0
  40367c:	f905603f 	str	xzr, [x1, #2752]
    filter->id = my_addr;
  403680:	f9401fe1 	ldr	x1, [sp, #56]
	list->tail = NULL;
  403684:	f900051f 	str	xzr, [x8, #8]
    ctx->can_dev = can_dev;
  403688:	f9000260 	str	x0, [x19]
    ctx->recv_cb_arg = recv_cb_arg;
    ctx->recv_error_callback = recv_error_callback;
  40368c:	a9021a65 	stp	x5, x6, [x19, #32]
    filter->id = my_addr;
  403690:	92030821 	and	x1, x1, #0xe0000000e0000000
    ctx->sent_callback = sent_callback;
  403694:	f9001a67 	str	x7, [x19, #48]
    ctx->my_addr = my_addr;
  403698:	b9003a62 	str	w2, [x19, #56]
    filter->id = my_addr;
  40369c:	92407042 	and	x2, x2, #0x1fffffff
  4036a0:	b2584442 	orr	x2, x2, #0x3ffff0000000000
  4036a4:	aa010042 	orr	x2, x2, x1
                    | ((opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FILTER_FDF : 0);
  4036a8:	39400861 	ldrb	w1, [x3, #2]
    filter->id = my_addr;
  4036ac:	f9001fe2 	str	x2, [sp, #56]
                    | ((opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FILTER_FDF : 0);
  4036b0:	528000a2 	mov	w2, #0x5                   	// #5
  4036b4:	121d0021 	and	w1, w1, #0x8
	return api->add_rx_filter(dev, callback, user_data, filter);
  4036b8:	9100e3e3 	add	x3, sp, #0x38
  4036bc:	2a020021 	orr	w1, w1, w2
    filter->flags = CAN_FILTER_DATA | CAN_FILTER_IDE
  4036c0:	390103e1 	strb	w1, [sp, #64]
  4036c4:	f9400801 	ldr	x1, [x0, #16]
  4036c8:	aa1303e2 	mov	x2, x19
  4036cc:	f9401824 	ldr	x4, [x1, #48]
  4036d0:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  4036d4:	9118a021 	add	x1, x1, #0x628
  4036d8:	d63f0080 	blr	x4

    struct can_filter filter;
    prepare_filter(&filter, my_addr, opts);
    ctx->filter_id = can_add_rx_filter(ctx->can_dev, can_rx_callback, ctx, &filter);
  4036dc:	b9000a60 	str	w0, [x19, #8]

    LOG_INF("Successfully bound to %x:%x", filter.id, filter.mask);
  4036e0:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4036e4:	52800062 	mov	w2, #0x3                   	// #3
  4036e8:	f9401fe7 	ldr	x7, [sp, #56]
  4036ec:	90000086 	adrp	x6, 413000 <z_timer_expiration_handler+0x68>
  4036f0:	f9478821 	ldr	x1, [x1, #3856]
  4036f4:	911e30c6 	add	x6, x6, #0x78c
  4036f8:	d360f0e0 	ubfx	x0, x7, #32, #29
  4036fc:	b90003e0 	str	w0, [sp]
  403700:	120070e7 	and	w7, w7, #0x1fffffff
  403704:	52800000 	mov	w0, #0x0                   	// #0
  403708:	52800005 	mov	w5, #0x0                   	// #0
  40370c:	d2800004 	mov	x4, #0x0                   	// #0
  403710:	d2800003 	mov	x3, #0x0                   	// #0
  403714:	97fffaa8 	bl	4021b4 <z_log_msg_runtime_create.constprop.0>

    return ISOTP_N_OK;
}
  403718:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40371c:	f9476800 	ldr	x0, [x0, #3792]
  403720:	f94027e2 	ldr	x2, [sp, #72]
  403724:	f9400001 	ldr	x1, [x0]
  403728:	eb010042 	subs	x2, x2, x1
  40372c:	d2800001 	mov	x1, #0x0                   	// #0
  403730:	54000040 	b.eq	403738 <isotp_fast_bind+0x104>  // b.none
  403734:	97fff6fb 	bl	401320 <__stack_chk_fail@plt>
  403738:	52800000 	mov	w0, #0x0                   	// #0
  40373c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  403740:	f94013f3 	ldr	x19, [sp, #32]
  403744:	910143ff 	add	sp, sp, #0x50
  403748:	d65f03c0 	ret

000000000040374c <isotp_fast_unbind>:
}
#endif

int isotp_fast_unbind(struct isotp_fast_ctx *ctx)
{
    if (ctx->filter_id >= 0 && ctx->can_dev) {
  40374c:	b9400801 	ldr	w1, [x0, #8]
  403750:	37f80161 	tbnz	w1, #31, 40377c <isotp_fast_unbind+0x30>
  403754:	f9400000 	ldr	x0, [x0]
  403758:	b4000120 	cbz	x0, 40377c <isotp_fast_unbind+0x30>
{
  40375c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  403760:	910003fd 	mov	x29, sp
	return api->remove_rx_filter(dev, filter_id);
  403764:	f9400802 	ldr	x2, [x0, #16]
  403768:	f9401c42 	ldr	x2, [x2, #56]
  40376c:	d63f0040 	blr	x2
    {
        free_recv_await_ctx(ctx, &actx);
    }
#endif
    return ISOTP_N_OK;
}
  403770:	52800000 	mov	w0, #0x0                   	// #0
  403774:	a8c17bfd 	ldp	x29, x30, [sp], #16
  403778:	d65f03c0 	ret
  40377c:	52800000 	mov	w0, #0x0                   	// #0
  403780:	d65f03c0 	ret

0000000000403784 <isotp_fast_send>:
}
#endif /* CONFIG_ISOTP_FAST_BLOCKING_RECEIVE */

int isotp_fast_send(struct isotp_fast_ctx *ctx, const uint8_t *data, size_t len,
                    const isotp_fast_node_id their_id, void *cb_arg)
{
  403784:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    const isotp_fast_msg_id recipient_addr = (ctx->my_addr & 0xFFFF0000)
                                             | (isotp_fast_get_addr_recipient(ctx->my_addr))
                                             | (their_id << ISOTP_FIXED_ADDR_TA_POS);
  403788:	53181c63 	ubfiz	w3, w3, #8, #8
{
  40378c:	910003fd 	mov	x29, sp
  403790:	f90023f9 	str	x25, [sp, #64]
  403794:	aa0103f9 	mov	x25, x1
  403798:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40379c:	a90153f3 	stp	x19, x20, [sp, #16]
  4037a0:	aa0203f3 	mov	x19, x2
  4037a4:	f9476821 	ldr	x1, [x1, #3792]
  4037a8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4037ac:	aa0003f5 	mov	x21, x0
  4037b0:	a90363f7 	stp	x23, x24, [sp, #48]
  4037b4:	aa0403f8 	mov	x24, x4
  4037b8:	f9400022 	ldr	x2, [x1]
  4037bc:	f90057e2 	str	x2, [sp, #168]
  4037c0:	d2800002 	mov	x2, #0x0                   	// #0
    const isotp_fast_msg_id recipient_addr = (ctx->my_addr & 0xFFFF0000)
  4037c4:	b9403801 	ldr	w1, [x0, #56]
  4037c8:	12103c37 	and	w23, w1, #0xffff0000
  4037cc:	2a0302f7 	orr	w23, w23, w3
  4037d0:	d3483c21 	ubfx	x1, x1, #8, #8
  4037d4:	2a0102f7 	orr	w23, w23, w1
    if (len <= (CAN_MAX_DLEN - ISOTP_FAST_SF_LEN_BYTE)) {
  4037d8:	f100fa7f 	cmp	x19, #0x3e
  4037dc:	54000628 	b.hi	4038a0 <isotp_fast_send+0x11c>  // b.pmore
        struct can_frame frame = {
  4037e0:	4f000400 	movi	v0.4s, #0x0
  4037e4:	910183f4 	add	x20, sp, #0x60
            .dlc = can_bytes_to_dlc(len + ISOTP_FAST_SF_LEN_BYTE),
  4037e8:	12001e61 	and	w1, w19, #0xff
        struct can_frame frame = {
  4037ec:	f900229f 	str	xzr, [x20, #64]
  4037f0:	ad000280 	stp	q0, q0, [x20]
  4037f4:	b94063e0 	ldr	w0, [sp, #96]
  4037f8:	ad010280 	stp	q0, q0, [x20, #32]
  4037fc:	330072e0 	bfxil	w0, w23, #0, #29
  403800:	b90063e0 	str	w0, [sp, #96]
            .dlc = can_bytes_to_dlc(len + ISOTP_FAST_SF_LEN_BYTE),
  403804:	11000820 	add	w0, w1, #0x2
  403808:	97fffa50 	bl	402148 <can_bytes_to_dlc>
        struct can_frame frame = {
  40380c:	390193e0 	strb	w0, [sp, #100]
            .id = recipient_addr,
            .flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  403810:	f9400aa0 	ldr	x0, [x21, #16]
  403814:	39400800 	ldrb	w0, [x0, #2]
  403818:	d341fc00 	lsr	x0, x0, #1
  40381c:	121e0000 	and	w0, w0, #0x4
  403820:	32000000 	orr	w0, w0, #0x1
        struct can_frame frame = {
  403824:	390197e0 	strb	w0, [sp, #101]
        };
        int index = 1;
#ifdef CONFIG_CAN_FD_MODE
        if (len > 0xF) {
  403828:	f1003e7f 	cmp	x19, #0xf
  40382c:	54000349 	b.ls	403894 <isotp_fast_send+0x110>  // b.plast
            frame.data[1] = (uint8_t)len;
            index = 2;
  403830:	52800040 	mov	w0, #0x2                   	// #2
            frame.data[1] = (uint8_t)len;
  403834:	3901a7e1 	strb	w1, [sp, #105]
            frame.data[0] = (uint8_t)len;
        }
#else
        frame.data[0] = (uint8_t)len;
#endif
        memcpy(&frame.data[index], data, len);
  403838:	11002000 	add	w0, w0, #0x8
  40383c:	aa1303e2 	mov	x2, x19
  403840:	aa1903e1 	mov	x1, x25
  403844:	8b20c280 	add	x0, x20, w0, sxtw
  403848:	97fff64a 	bl	401170 <memcpy@plt>
        int ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), NULL, NULL);
  40384c:	f94002a0 	ldr	x0, [x21]
  403850:	d2800c82 	mov	x2, #0x64                  	// #100
  403854:	aa1403e1 	mov	x1, x20
  403858:	d2800004 	mov	x4, #0x0                   	// #0
  40385c:	d2800003 	mov	x3, #0x0                   	// #0
  403860:	9400246a 	bl	40ca08 <z_impl_can_send>
        ctx->sent_callback(ret, cb_arg);
        return ISOTP_N_OK;
  403864:	52800016 	mov	w22, #0x0                   	// #0
        ctx->sent_callback(ret, cb_arg);
  403868:	f9401aa2 	ldr	x2, [x21, #48]
  40386c:	aa1803e1 	mov	x1, x24
  403870:	d63f0040 	blr	x2
        k_timer_init(&context->timer, send_timeout_handler, NULL);

        k_work_submit(&context->work);
    }
    return ISOTP_N_OK;
  403874:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403878:	f9476800 	ldr	x0, [x0, #3792]
  40387c:	f94057e2 	ldr	x2, [sp, #168]
  403880:	f9400001 	ldr	x1, [x0]
  403884:	eb010042 	subs	x2, x2, x1
  403888:	d2800001 	mov	x1, #0x0                   	// #0
  40388c:	54000680 	b.eq	40395c <isotp_fast_send+0x1d8>  // b.none
  403890:	97fff6a4 	bl	401320 <__stack_chk_fail@plt>
        int index = 1;
  403894:	52800020 	mov	w0, #0x1                   	// #1
            frame.data[0] = (uint8_t)len;
  403898:	3901a3e1 	strb	w1, [sp, #104]
  40389c:	17ffffe7 	b	403838 <isotp_fast_send+0xb4>
        if (len > ISOTP_FAST_MAX_LEN) {
  4038a0:	f13ffe7f 	cmp	x19, #0xfff
  4038a4:	54000548 	b.hi	40394c <isotp_fast_send+0x1c8>  // b.pmore
        int ret = get_send_ctx(ctx, recipient_addr, &context);
  4038a8:	910163e2 	add	x2, sp, #0x58
  4038ac:	2a1703e1 	mov	w1, w23
  4038b0:	97fffb14 	bl	402500 <get_send_ctx>
  4038b4:	2a0003f6 	mov	w22, w0
        if (ret) {
  4038b8:	350004e0 	cbnz	w0, 403954 <isotp_fast_send+0x1d0>
        context->ctx = ctx;
  4038bc:	f9402ff4 	ldr	x20, [sp, #88]
        context->state = ISOTP_TX_SEND_FF;
  4038c0:	12002e73 	and	w19, w19, #0xfff
  4038c4:	32130273 	orr	w19, w19, #0x2000
        context->ctx = ctx;
  4038c8:	f9000695 	str	x21, [x20, #8]
        context->recipient_addr = recipient_addr;
  4038cc:	b9001297 	str	w23, [x20, #16]
        context->data = data;
  4038d0:	f9005e99 	str	x25, [x20, #184]
        context->bs = ctx->opts->bs;
  4038d4:	f9400aa0 	ldr	x0, [x21, #16]
  4038d8:	39400000 	ldrb	w0, [x0]
  4038dc:	39034680 	strb	w0, [x20, #209]
        context->stmin = ctx->opts->stmin;
  4038e0:	f9400aa0 	ldr	x0, [x21, #16]
  4038e4:	39400400 	ldrb	w0, [x0, #1]
  4038e8:	39035280 	strb	w0, [x20, #212]
        context->rem_len = len;
  4038ec:	aa1403e0 	mov	x0, x20
  4038f0:	784c0c01 	ldrh	w1, [x0, #192]!
        context->state = ISOTP_TX_SEND_FF;
  4038f4:	79018293 	strh	w19, [x20, #192]
  4038f8:	39400801 	ldrb	w1, [x0, #2]
  4038fc:	121c6c21 	and	w1, w1, #0xfffffff0
  403900:	39000801 	strb	w1, [x0, #2]
        context->cb_arg = cb_arg;
  403904:	f9006698 	str	x24, [x20, #200]
	return z_impl_k_sem_init(sem, initial_count, limit);
  403908:	52800022 	mov	w2, #0x1                   	// #1
        k_work_init(&context->work, send_work_handler);
  40390c:	91006293 	add	x19, x20, #0x18
  403910:	91024280 	add	x0, x20, #0x90
  403914:	52800001 	mov	w1, #0x0                   	// #0
  403918:	94002f2d 	bl	40f5cc <z_impl_k_sem_init>
  40391c:	aa1303e0 	mov	x0, x19
  403920:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  403924:	91367021 	add	x1, x1, #0xd9c
  403928:	94003129 	bl	40fdcc <k_work_init>
        k_timer_init(&context->timer, send_timeout_handler, NULL);
  40392c:	f0ffffe1 	adrp	x1, 402000 <__floatunditf+0x60>
  403930:	9109c021 	add	x1, x1, #0x270
  403934:	d2800002 	mov	x2, #0x0                   	// #0
  403938:	9100e280 	add	x0, x20, #0x38
  40393c:	94003e1a 	bl	4131a4 <k_timer_init>
        k_work_submit(&context->work);
  403940:	aa1303e0 	mov	x0, x19
  403944:	940031af 	bl	410000 <k_work_submit>
    return ISOTP_N_OK;
  403948:	17ffffcb 	b	403874 <isotp_fast_send+0xf0>
            return ISOTP_N_BUFFER_OVERFLW;
  40394c:	128000f6 	mov	w22, #0xfffffff8            	// #-8
  403950:	17ffffc9 	b	403874 <isotp_fast_send+0xf0>
            return ISOTP_NO_NET_BUF_LEFT;
  403954:	12800156 	mov	w22, #0xfffffff5            	// #-11
  403958:	17ffffc7 	b	403874 <isotp_fast_send+0xf0>
  40395c:	2a1603e0 	mov	w0, w22
  403960:	a94153f3 	ldp	x19, x20, [sp, #16]
  403964:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403968:	a94363f7 	ldp	x23, x24, [sp, #48]
  40396c:	f94023f9 	ldr	x25, [sp, #64]
  403970:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  403974:	d65f03c0 	ret

0000000000403978 <isotp_fast_recv_error_handler>:
}

void isotp_fast_recv_error_handler(int8_t error, isotp_fast_msg_id sender_addr, void *arg)
{
    // printk("Error %d received\n", error);
    recv_last_error = error;
  403978:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40397c:	f9474821 	ldr	x1, [x1, #3728]
  403980:	39000020 	strb	w0, [x1]
	z_impl_k_msgq_purge(msgq);
  403984:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403988:	f9479000 	ldr	x0, [x0, #3872]
  40398c:	14002caf 	b	40ec48 <z_impl_k_msgq_purge>

0000000000403990 <blocking_recv>:
{
  403990:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  403994:	910003fd 	mov	x29, sp
  403998:	a9025bf5 	stp	x21, x22, [sp, #32]
  40399c:	aa0003f6 	mov	x22, x0
  4039a0:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4039a4:	90000155 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
  4039a8:	a9046bf9 	stp	x25, x26, [sp, #64]
	return z_impl_k_msgq_get(msgq, data, timeout);
  4039ac:	90000159 	adrp	x25, 42b000 <__FRAME_END__+0x1007c>
  4039b0:	f9476800 	ldr	x0, [x0, #3792]
  4039b4:	a90153f3 	stp	x19, x20, [sp, #16]
  4039b8:	aa0203fa 	mov	x26, x2
  4039bc:	a90363f7 	stp	x23, x24, [sp, #48]
  4039c0:	aa0103f8 	mov	x24, x1
    int rx_len = 0;
  4039c4:	52800013 	mov	w19, #0x0                   	// #0
{
  4039c8:	a90573fb 	stp	x27, x28, [sp, #80]
  4039cc:	910183fc 	add	x28, sp, #0x60
  4039d0:	f9479339 	ldr	x25, [x25, #3872]
  4039d4:	f9400001 	ldr	x1, [x0]
  4039d8:	f90057e1 	str	x1, [sp, #168]
  4039dc:	d2800001 	mov	x1, #0x0                   	// #0
        if (recv_last_error != 0) {
  4039e0:	f9474abb 	ldr	x27, [x21, #3728]
  4039e4:	aa1a03e2 	mov	x2, x26
  4039e8:	aa1c03e1 	mov	x1, x28
  4039ec:	aa1903e0 	mov	x0, x25
  4039f0:	94002be9 	bl	40e994 <z_impl_k_msgq_get>
  4039f4:	2a0003f7 	mov	w23, w0
    while ((ret = k_msgq_get(&recv_msgq, &msg, timeout)) == 0) {
  4039f8:	35000400 	cbnz	w0, 403a78 <blocking_recv+0xe8>
        if (recv_last_error != 0) {
  4039fc:	39c00360 	ldrsb	w0, [x27]
  403a00:	34000160 	cbz	w0, 403a2c <blocking_recv+0x9c>
            ret = recv_last_error;
  403a04:	2a0003f3 	mov	w19, w0
            recv_last_error = 0;
  403a08:	3900037f 	strb	wzr, [x27]
}
  403a0c:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403a10:	f9476800 	ldr	x0, [x0, #3792]
  403a14:	f94057e2 	ldr	x2, [sp, #168]
  403a18:	f9400001 	ldr	x1, [x0]
  403a1c:	eb010042 	subs	x2, x2, x1
  403a20:	d2800001 	mov	x1, #0x0                   	// #0
  403a24:	540003e0 	b.eq	403aa0 <blocking_recv+0x110>  // b.none
  403a28:	97fff63e 	bl	401320 <__stack_chk_fail@plt>
        if (msg.len < 0) {
  403a2c:	79c143e0 	ldrsh	w0, [sp, #160]
  403a30:	36f80060 	tbz	w0, #31, 403a3c <blocking_recv+0xac>
            return msg.len;
  403a34:	2a0003f3 	mov	w19, w0
  403a38:	17fffff5 	b	403a0c <blocking_recv+0x7c>
        int cp_len = MIN(msg.len, size - rx_len);
  403a3c:	cb33c314 	sub	x20, x24, w19, sxtw
  403a40:	93403c01 	sxth	x1, w0
  403a44:	eb20a29f 	cmp	x20, w0, sxth
  403a48:	aa1603e0 	mov	x0, x22
  403a4c:	9a819294 	csel	x20, x20, x1, ls  // ls = plast
  403a50:	aa1c03e1 	mov	x1, x28
  403a54:	aa1403e2 	mov	x2, x20
        rx_len += cp_len;
  403a58:	0b140273 	add	w19, w19, w20
  403a5c:	97fff5c5 	bl	401170 <memcpy@plt>
        buf += cp_len;
  403a60:	8b1402d6 	add	x22, x22, x20
        if (msg.rem_len > (size - rx_len)) {
  403a64:	b940a7e0 	ldr	w0, [sp, #164]
  403a68:	cb33c301 	sub	x1, x24, w19, sxtw
  403a6c:	eb20c03f 	cmp	x1, w0, sxtw
  403a70:	54000043 	b.cc	403a78 <blocking_recv+0xe8>  // b.lo, b.ul, b.last
        if (msg.rem_len == 0) {
  403a74:	35fffb80 	cbnz	w0, 4039e4 <blocking_recv+0x54>
    if (recv_last_error != 0) {
  403a78:	f9474ab5 	ldr	x21, [x21, #3728]
  403a7c:	39c002a0 	ldrsb	w0, [x21]
  403a80:	34000080 	cbz	w0, 403a90 <blocking_recv+0x100>
        ret = recv_last_error;
  403a84:	2a0003f3 	mov	w19, w0
        recv_last_error = 0;
  403a88:	390002bf 	strb	wzr, [x21]
        return ret;
  403a8c:	17ffffe0 	b	403a0c <blocking_recv+0x7c>
        return ISOTP_RECV_TIMEOUT;
  403a90:	31002eff 	cmn	w23, #0xb
  403a94:	128001a0 	mov	w0, #0xfffffff2            	// #-14
  403a98:	1a801273 	csel	w19, w19, w0, ne  // ne = any
  403a9c:	17ffffdc 	b	403a0c <blocking_recv+0x7c>
}
  403aa0:	2a1303e0 	mov	w0, w19
  403aa4:	a94153f3 	ldp	x19, x20, [sp, #16]
  403aa8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403aac:	a94363f7 	ldp	x23, x24, [sp, #48]
  403ab0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  403ab4:	a94573fb 	ldp	x27, x28, [sp, #80]
  403ab8:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  403abc:	d65f03c0 	ret

0000000000403ac0 <k_uptime_get>:
 *    @kconfig{CONFIG_SYS_CLOCK_TICKS_PER_SEC} config option.
 *
 * @return Current uptime in milliseconds.
 */
static inline int64_t k_uptime_get(void)
{
  403ac0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  403ac4:	910003fd 	mov	x29, sp
	return z_impl_k_uptime_ticks();
  403ac8:	94003d1f 	bl	412f44 <z_impl_k_uptime_ticks>
	return k_ticks_to_ms_floor64(k_uptime_ticks());
}
  403acc:	d2800141 	mov	x1, #0xa                   	// #10
  403ad0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  403ad4:	9b017c00 	mul	x0, x0, x1
  403ad8:	d65f03c0 	ret

0000000000403adc <can_bytes_to_dlc>:
{
  403adc:	12001c00 	and	w0, w0, #0xff
	return num_bytes <= 8  ? num_bytes :
  403ae0:	7100201f 	cmp	w0, #0x8
  403ae4:	540001c9 	b.ls	403b1c <can_bytes_to_dlc+0x40>  // b.plast
  403ae8:	7100301f 	cmp	w0, #0xc
  403aec:	540001a9 	b.ls	403b20 <can_bytes_to_dlc+0x44>  // b.plast
  403af0:	7100401f 	cmp	w0, #0x10
  403af4:	540001a9 	b.ls	403b28 <can_bytes_to_dlc+0x4c>  // b.plast
  403af8:	7100501f 	cmp	w0, #0x14
  403afc:	540001a9 	b.ls	403b30 <can_bytes_to_dlc+0x54>  // b.plast
  403b00:	7100601f 	cmp	w0, #0x18
  403b04:	540001a9 	b.ls	403b38 <can_bytes_to_dlc+0x5c>  // b.plast
  403b08:	7100801f 	cmp	w0, #0x20
  403b0c:	540001a9 	b.ls	403b40 <can_bytes_to_dlc+0x64>  // b.plast
  403b10:	7100c01f 	cmp	w0, #0x30
  403b14:	1a9f97e0 	cset	w0, hi  // hi = pmore
  403b18:	11003800 	add	w0, w0, #0xe
}
  403b1c:	d65f03c0 	ret
	return num_bytes <= 8  ? num_bytes :
  403b20:	52800120 	mov	w0, #0x9                   	// #9
  403b24:	17fffffe 	b	403b1c <can_bytes_to_dlc+0x40>
  403b28:	52800140 	mov	w0, #0xa                   	// #10
  403b2c:	17fffffc 	b	403b1c <can_bytes_to_dlc+0x40>
  403b30:	52800160 	mov	w0, #0xb                   	// #11
  403b34:	17fffffa 	b	403b1c <can_bytes_to_dlc+0x40>
  403b38:	52800180 	mov	w0, #0xc                   	// #12
  403b3c:	17fffff8 	b	403b1c <can_bytes_to_dlc+0x40>
  403b40:	528001a0 	mov	w0, #0xd                   	// #13
  403b44:	17fffff6 	b	403b1c <can_bytes_to_dlc+0x40>

0000000000403b48 <prepare_cf_frames.constprop.0>:
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);

    return filter_id;
}

static void prepare_cf_frames(struct frame_desired *frames, size_t frames_cnt, const uint8_t *data,
  403b48:	90000142 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
                              size_t data_len)
{
    int i;
    const uint8_t *data_ptr = data;
  403b4c:	b0000081 	adrp	x1, 414000 <__func__.1+0xd>
  403b50:	9109d021 	add	x1, x1, #0x274
static void prepare_cf_frames(struct frame_desired *frames, size_t frames_cnt, const uint8_t *data,
  403b54:	d2800024 	mov	x4, #0x1                   	// #1
  403b58:	f947bc42 	ldr	x2, [x2, #3960]
    const uint8_t *data_ptr = data;
  403b5c:	9100f821 	add	x1, x1, #0x3e
    size_t remaining_length = data_len;

    for (i = 0; i < frames_cnt && remaining_length; i++) {
        frames[i].data[0] = CF_PCI_BYTE_1 | ((i + 1) & 0x0F);
        frames[i].length = CAN_DL;
  403b60:	52800805 	mov	w5, #0x40                  	// #64
        frames[i].data[0] = CF_PCI_BYTE_1 | ((i + 1) & 0x0F);
  403b64:	321b0083 	orr	w3, w4, #0x20
  403b68:	39000043 	strb	w3, [x2]
  403b6c:	ad400420 	ldp	q0, q1, [x1]
  403b70:	91000443 	add	x3, x2, #0x1
        frames[i].length = CAN_DL;
  403b74:	39010045 	strb	w5, [x2, #64]
  403b78:	ad000460 	stp	q0, q1, [x3]
  403b7c:	3dc00820 	ldr	q0, [x1, #32]
  403b80:	3d800860 	str	q0, [x3, #32]
  403b84:	3cc2f020 	ldur	q0, [x1, #47]
  403b88:	3c82f060 	stur	q0, [x3, #47]
        memcpy(&des_frames[i].data[1], data_ptr, DATA_SIZE_CF);

        if (remaining_length < DATA_SIZE_CF) {
  403b8c:	f100f81f 	cmp	x0, #0x3e
  403b90:	54000088 	b.hi	403ba0 <prepare_cf_frames.constprop.0+0x58>  // b.pmore
            frames[i].length = remaining_length + 1;
  403b94:	11000400 	add	w0, w0, #0x1
  403b98:	39010040 	strb	w0, [x2, #64]
            remaining_length = 0;
  403b9c:	d2800000 	mov	x0, #0x0                   	// #0
        }

        remaining_length -= DATA_SIZE_CF;
  403ba0:	91000484 	add	x4, x4, #0x1
  403ba4:	d100fc00 	sub	x0, x0, #0x3f
        data_ptr += DATA_SIZE_CF;
  403ba8:	9100fc21 	add	x1, x1, #0x3f
    for (i = 0; i < frames_cnt && remaining_length; i++) {
  403bac:	91010442 	add	x2, x2, #0x41
  403bb0:	f100149f 	cmp	x4, #0x5
  403bb4:	54000040 	b.eq	403bbc <prepare_cf_frames.constprop.0+0x74>  // b.none
  403bb8:	b5fffd60 	cbnz	x0, 403b64 <prepare_cf_frames.constprop.0+0x1c>
    }
}
  403bbc:	d65f03c0 	ret

0000000000403bc0 <z_zassert.constprop.0>:

#define z_zexpect(cond, default_msg, file, line, func, msg, ...) z_zexpect_(cond, file, line)

#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  403bc0:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  403bc4:	910003fd 	mov	x29, sp
  403bc8:	a9025bf5 	stp	x21, x22, [sp, #32]
  403bcc:	aa0103f6 	mov	x22, x1
  403bd0:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  403bd4:	a90153f3 	stp	x19, x20, [sp, #16]
  403bd8:	f9476821 	ldr	x1, [x1, #3792]
  403bdc:	f9001bf7 	str	x23, [sp, #48]
  403be0:	3d8027e0 	str	q0, [sp, #144]
			     const char *func, const char *msg, ...)
{
	if (cond == false) {
  403be4:	72001c17 	ands	w23, w0, #0xff
static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  403be8:	3d802be1 	str	q1, [sp, #160]
  403bec:	3d802fe2 	str	q2, [sp, #176]
  403bf0:	3d8033e3 	str	q3, [sp, #192]
  403bf4:	3d8037e4 	str	q4, [sp, #208]
  403bf8:	3d803be5 	str	q5, [sp, #224]
  403bfc:	3d803fe6 	str	q6, [sp, #240]
  403c00:	3d8043e7 	str	q7, [sp, #256]
  403c04:	a9111fe6 	stp	x6, x7, [sp, #272]
  403c08:	f9400022 	ldr	x2, [x1]
  403c0c:	f90047e2 	str	x2, [sp, #136]
  403c10:	d2800002 	mov	x2, #0x0                   	// #0
	if (cond == false) {
  403c14:	54000401 	b.ne	403c94 <z_zassert.constprop.0+0xd4>  // b.any
		va_list vargs;

		va_start(vargs, msg);
  403c18:	910483e0 	add	x0, sp, #0x120
  403c1c:	a90683e0 	stp	x0, x0, [sp, #104]
  403c20:	910443e0 	add	x0, sp, #0x110
  403c24:	f9003fe0 	str	x0, [sp, #120]
  403c28:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  403c2c:	b90083e0 	str	w0, [sp, #128]
  403c30:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  403c34:	aa0503f3 	mov	x19, x5
  403c38:	2a0303f4 	mov	w20, w3
  403c3c:	aa0403f5 	mov	x21, x4
  403c40:	b90087e0 	str	w0, [sp, #132]
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n", ztest_relative_filename(file),
  403c44:	90000080 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  403c48:	911f0c00 	add	x0, x0, #0x7c3
  403c4c:	940020d0 	bl	40bf8c <ztest_relative_filename>
  403c50:	aa0003e1 	mov	x1, x0
  403c54:	aa1603e4 	mov	x4, x22
  403c58:	aa1503e3 	mov	x3, x21
  403c5c:	2a1403e2 	mov	w2, w20
  403c60:	90000080 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  403c64:	9120b800 	add	x0, x0, #0x82e
  403c68:	940009c7 	bl	406384 <printk>
		      line, func, default_msg);
		vprintk(msg, vargs);
  403c6c:	9101a3e0 	add	x0, sp, #0x68
  403c70:	910103e1 	add	x1, sp, #0x40
  403c74:	ad400400 	ldp	q0, q1, [x0]
  403c78:	aa1303e0 	mov	x0, x19
  403c7c:	ad000420 	stp	q0, q1, [x1]
  403c80:	940009b8 	bl	406360 <vprintk>
		printk("\n");
  403c84:	d0000080 	adrp	x0, 415000 <random_data+0xd8c>
  403c88:	91320800 	add	x0, x0, #0xc82
  403c8c:	940009be 	bl	406384 <printk>
		va_end(vargs);
		ztest_test_fail();
  403c90:	94001d9e 	bl	40b308 <ztest_test_fail>
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n", ztest_relative_filename(file),
		      line, func);
	}
#endif
	return true;
}
  403c94:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403c98:	f9476800 	ldr	x0, [x0, #3792]
  403c9c:	f94047e2 	ldr	x2, [sp, #136]
  403ca0:	f9400001 	ldr	x1, [x0]
  403ca4:	eb010042 	subs	x2, x2, x1
  403ca8:	d2800001 	mov	x1, #0x0                   	// #0
  403cac:	54000040 	b.eq	403cb4 <z_zassert.constprop.0+0xf4>  // b.none
  403cb0:	97fff59c 	bl	401320 <__stack_chk_fail@plt>
  403cb4:	2a1703e0 	mov	w0, w23
  403cb8:	a94153f3 	ldp	x19, x20, [sp, #16]
  403cbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403cc0:	f9401bf7 	ldr	x23, [sp, #48]
  403cc4:	a8d27bfd 	ldp	x29, x30, [sp], #288
  403cc8:	d65f03c0 	ret

0000000000403ccc <get_sf_ignore.constprop.0>:
static void get_sf_ignore(struct isotp_fast_ctx *recv_ctx)
  403ccc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403cd0:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403cd4:	d2800282 	mov	x2, #0x14                  	// #20
static void get_sf_ignore(struct isotp_fast_ctx *recv_ctx)
  403cd8:	910003fd 	mov	x29, sp
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403cdc:	f9471000 	ldr	x0, [x0, #3616]
  403ce0:	d2801001 	mov	x1, #0x80                  	// #128
  403ce4:	97ffff2b 	bl	403990 <blocking_recv>
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "recv returned %d", ret);
  403ce8:	3100381f 	cmn	w0, #0xe
}
  403cec:	a8c17bfd 	ldp	x29, x30, [sp], #16
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  403cf0:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "recv returned %d", ret);
  403cf4:	90000085 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  403cf8:	1a9f17e0 	cset	w0, eq  // eq = none
  403cfc:	912158a5 	add	x5, x5, #0x856
  403d00:	b0000084 	adrp	x4, 414000 <__func__.1+0xd>
  403d04:	528008e3 	mov	w3, #0x47                  	// #71
  403d08:	9101c884 	add	x4, x4, #0x72
  403d0c:	90000082 	adrp	x2, 413000 <z_timer_expiration_handler+0x68>
  403d10:	90000081 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  403d14:	911f0c42 	add	x2, x2, #0x7c3
  403d18:	91219c21 	add	x1, x1, #0x867
  403d1c:	17ffffa9 	b	403bc0 <z_zassert.constprop.0>

0000000000403d20 <send_test_data.constprop.0>:
static void send_test_data(const uint8_t *data, size_t len)
  403d20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403d24:	aa0003e2 	mov	x2, x0
  403d28:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
static void send_test_data(const uint8_t *data, size_t len)
  403d2c:	910003fd 	mov	x29, sp
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403d30:	f9470c00 	ldr	x0, [x0, #3608]
  403d34:	d2800004 	mov	x4, #0x0                   	// #0
  403d38:	52800023 	mov	w3, #0x1                   	// #1
  403d3c:	b0000081 	adrp	x1, 414000 <__func__.1+0xd>
  403d40:	9109d021 	add	x1, x1, #0x274
  403d44:	97fffe90 	bl	403784 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  403d48:	7100001f 	cmp	w0, #0x0
}
  403d4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    ret = isotp_fast_send(&ctx, data, len, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  403d50:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  403d54:	90000085 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  403d58:	1a9f17e0 	cset	w0, eq  // eq = none
  403d5c:	912234a5 	add	x5, x5, #0x88d
  403d60:	b0000084 	adrp	x4, 414000 <__func__.1+0xd>
  403d64:	528009e3 	mov	w3, #0x4f                  	// #79
  403d68:	91094884 	add	x4, x4, #0x252
  403d6c:	90000082 	adrp	x2, 413000 <z_timer_expiration_handler+0x68>
  403d70:	90000081 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  403d74:	911f0c42 	add	x2, x2, #0x7c3
  403d78:	91227821 	add	x1, x1, #0x89e
  403d7c:	17ffff91 	b	403bc0 <z_zassert.constprop.0>

0000000000403d80 <add_rx_msgq.constprop.0>:
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403d80:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  403d84:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403d88:	92407000 	and	x0, x0, #0x1fffffff
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403d8c:	910003fd 	mov	x29, sp
  403d90:	f9476821 	ldr	x1, [x1, #3792]
  403d94:	a90153f3 	stp	x19, x20, [sp, #16]
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403d98:	b2607000 	orr	x0, x0, #0x1fffffff00000000
static int add_rx_msgq(uint32_t id, uint32_t mask)
  403d9c:	f90013f5 	str	x21, [sp, #32]
  403da0:	f9400022 	ldr	x2, [x1]
  403da4:	f90027e2 	str	x2, [sp, #72]
  403da8:	d2800002 	mov	x2, #0x0                   	// #0
    struct can_filter filter = { .flags = CAN_FILTER_DATA | ((id > 0x7FF) ? CAN_FILTER_IDE : 0),
  403dac:	b90043ff 	str	wzr, [sp, #64]
  403db0:	f9001fe0 	str	x0, [sp, #56]
    filter.flags |= CAN_FILTER_FDF;
  403db4:	528001a0 	mov	w0, #0xd                   	// #13
  403db8:	390103e0 	strb	w0, [sp, #64]
		union { uintptr_t x; const struct can_filter * val; } parm2 = { .val = filter };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_CAN_ADD_RX_FILTER_MSGQ);
	}
#endif
	compiler_barrier();
	return z_impl_can_add_rx_filter_msgq(dev, msgq, filter);
  403dbc:	90000141 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  403dc0:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403dc4:	9100e3e2 	add	x2, sp, #0x38
    zassert_not_equal(filter_id, -ENOSPC, "Filter full");
  403dc8:	b0000095 	adrp	x21, 414000 <__func__.1+0xd>
  403dcc:	f947e021 	ldr	x1, [x1, #4032]
  403dd0:	9102d2b5 	add	x21, x21, #0xb4
  403dd4:	f9472000 	ldr	x0, [x0, #3648]
  403dd8:	90000094 	adrp	x20, 413000 <z_timer_expiration_handler+0x68>
  403ddc:	911f0e94 	add	x20, x20, #0x7c3
  403de0:	94002345 	bl	40caf4 <z_impl_can_add_rx_filter_msgq>
  403de4:	3100701f 	cmn	w0, #0x1c
  403de8:	2a0003f3 	mov	w19, w0
  403dec:	aa1503e4 	mov	x4, x21
  403df0:	1a9f07e0 	cset	w0, ne  // ne = any
  403df4:	aa1403e2 	mov	x2, x20
  403df8:	52801563 	mov	w3, #0xab                  	// #171
  403dfc:	90000085 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  403e00:	90000081 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  403e04:	9122cca5 	add	x5, x5, #0x8b3
  403e08:	9122fc21 	add	x1, x1, #0x8bf
  403e0c:	97ffff6d 	bl	403bc0 <z_zassert.constprop.0>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  403e10:	2a3303e0 	mvn	w0, w19
  403e14:	aa1403e2 	mov	x2, x20
  403e18:	2a1303e6 	mov	w6, w19
  403e1c:	aa1503e4 	mov	x4, x21
  403e20:	531f7c00 	lsr	w0, w0, #31
  403e24:	90000085 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  403e28:	52801583 	mov	w3, #0xac                  	// #172
  403e2c:	912370a5 	add	x5, x5, #0x8dc
  403e30:	90000081 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  403e34:	9123e021 	add	x1, x1, #0x8f8
  403e38:	97ffff62 	bl	403bc0 <z_zassert.constprop.0>
}
  403e3c:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403e40:	f9476800 	ldr	x0, [x0, #3792]
  403e44:	f94027e2 	ldr	x2, [sp, #72]
  403e48:	f9400001 	ldr	x1, [x0]
  403e4c:	eb010042 	subs	x2, x2, x1
  403e50:	d2800001 	mov	x1, #0x0                   	// #0
  403e54:	54000040 	b.eq	403e5c <add_rx_msgq.constprop.0+0xdc>  // b.none
  403e58:	97fff532 	bl	401320 <__stack_chk_fail@plt>
  403e5c:	2a1303e0 	mov	w0, w19
  403e60:	a94153f3 	ldp	x19, x20, [sp, #16]
  403e64:	f94013f5 	ldr	x21, [sp, #32]
  403e68:	a8c57bfd 	ldp	x29, x30, [sp], #80
  403e6c:	d65f03c0 	ret

0000000000403e70 <send_frame_series>:
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403e70:	4f000400 	movi	v0.4s, #0x0
{
  403e74:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  403e78:	910003fd 	mov	x29, sp
  403e7c:	a90153f3 	stp	x19, x20, [sp, #16]
  403e80:	aa0003f3 	mov	x19, x0
  403e84:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403e88:	910183f4 	add	x20, sp, #0x60
{
  403e8c:	a9025bf5 	stp	x21, x22, [sp, #32]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403e90:	90000096 	adrp	x22, 413000 <z_timer_expiration_handler+0x68>
{
  403e94:	f9476800 	ldr	x0, [x0, #3792]
  403e98:	a90363f7 	stp	x23, x24, [sp, #48]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403e9c:	91227ad6 	add	x22, x22, #0x89e
{
  403ea0:	a9046bf9 	stp	x25, x26, [sp, #64]
	return z_impl_can_send(dev, frame, timeout, callback, user_data);
  403ea4:	9000015a 	adrp	x26, 42b000 <__FRAME_END__+0x1007c>
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403ea8:	90000099 	adrp	x25, 413000 <z_timer_expiration_handler+0x68>
{
  403eac:	f9002bfb 	str	x27, [sp, #80]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403eb0:	b0000098 	adrp	x24, 414000 <__func__.1+0xd>
  403eb4:	f947235a 	ldr	x26, [x26, #3648]
{
  403eb8:	f9400003 	ldr	x3, [x0]
  403ebc:	f90057e3 	str	x3, [sp, #168]
  403ec0:	d2800003 	mov	x3, #0x0                   	// #0
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403ec4:	ad000280 	stp	q0, q0, [x20]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403ec8:	90000097 	adrp	x23, 413000 <z_timer_expiration_handler+0x68>
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403ecc:	b94063e0 	ldr	w0, [sp, #96]
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403ed0:	91245339 	add	x25, x25, #0x914
  403ed4:	91020318 	add	x24, x24, #0x80
  403ed8:	911f0ef7 	add	x23, x23, #0x7c3
  403edc:	2a0103fb 	mov	w27, w1
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403ee0:	33007040 	bfxil	w0, w2, #0, #29
    for (i = 0; i < length; i++) {
  403ee4:	52800015 	mov	w21, #0x0                   	// #0
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403ee8:	f900229f 	str	xzr, [x20, #64]
  403eec:	b90063e0 	str	w0, [sp, #96]
    frame.flags |= CAN_FRAME_FDF;
  403ef0:	528000a0 	mov	w0, #0x5                   	// #5
  403ef4:	390197e0 	strb	w0, [sp, #101]
    struct can_frame frame = { .flags = (id > 0x7FF) ? CAN_FRAME_IDE : 0, .id = id };
  403ef8:	ad010280 	stp	q0, q0, [x20, #32]
        frame.dlc = can_bytes_to_dlc(desired->length);
  403efc:	39410262 	ldrb	w2, [x19, #64]
  403f00:	aa1303e1 	mov	x1, x19
  403f04:	d2800803 	mov	x3, #0x40                  	// #64
  403f08:	2a0203e0 	mov	w0, w2
  403f0c:	97fffef4 	bl	403adc <can_bytes_to_dlc>
  403f10:	92401c42 	and	x2, x2, #0xff
  403f14:	390193e0 	strb	w0, [sp, #100]
  403f18:	9101a3e0 	add	x0, sp, #0x68
  403f1c:	97fff4cd 	bl	401250 <__memcpy_chk@plt>
  403f20:	d2800004 	mov	x4, #0x0                   	// #0
  403f24:	aa1403e1 	mov	x1, x20
  403f28:	d2800003 	mov	x3, #0x0                   	// #0
  403f2c:	d2800642 	mov	x2, #0x32                  	// #50
  403f30:	aa1a03e0 	mov	x0, x26
  403f34:	940022b5 	bl	40ca08 <z_impl_can_send>
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403f38:	7100001f 	cmp	w0, #0x0
  403f3c:	2a0003e7 	mov	w7, w0
  403f40:	2a1503e6 	mov	w6, w21
  403f44:	aa1903e5 	mov	x5, x25
  403f48:	aa1803e4 	mov	x4, x24
  403f4c:	aa1703e2 	mov	x2, x23
  403f50:	aa1603e1 	mov	x1, x22
  403f54:	1a9f17e0 	cset	w0, eq  // eq = none
  403f58:	52800fa3 	mov	w3, #0x7d                  	// #125
    for (i = 0; i < length; i++) {
  403f5c:	110006b5 	add	w21, w21, #0x1
        zassert_equal(ret, 0, "Sending msg %d failed (error %d).", i, ret);
  403f60:	97ffff18 	bl	403bc0 <z_zassert.constprop.0>
        desired++;
  403f64:	91010673 	add	x19, x19, #0x41
    for (i = 0; i < length; i++) {
  403f68:	6b15037f 	cmp	w27, w21
  403f6c:	54fffc81 	b.ne	403efc <send_frame_series+0x8c>  // b.any
}
  403f70:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  403f74:	f9476800 	ldr	x0, [x0, #3792]
  403f78:	f94057e2 	ldr	x2, [sp, #168]
  403f7c:	f9400001 	ldr	x1, [x0]
  403f80:	eb010042 	subs	x2, x2, x1
  403f84:	d2800001 	mov	x1, #0x0                   	// #0
  403f88:	54000040 	b.eq	403f90 <send_frame_series+0x120>  // b.none
  403f8c:	97fff4e5 	bl	401320 <__stack_chk_fail@plt>
  403f90:	a94153f3 	ldp	x19, x20, [sp, #16]
  403f94:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403f98:	a94363f7 	ldp	x23, x24, [sp, #48]
  403f9c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  403fa0:	f9402bfb 	ldr	x27, [sp, #80]
  403fa4:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  403fa8:	d65f03c0 	ret

0000000000403fac <_isotp_fast_conformance_async_fd_test_receive_timeouts_wrapper>:
    zassert_equal(ret, 0, "Timeout too late");
    time_diff = k_uptime_get_32() - start_time;
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
}

ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  403fac:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  403fb0:	90000140 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
    ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
    memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
    ff_frame.length = DATA_SIZE_FF + 2;

    send_frame_series(&ff_frame, 1, rx_addr);
  403fb4:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  403fb8:	910003fd 	mov	x29, sp
  403fbc:	f9476800 	ldr	x0, [x0, #3792]
  403fc0:	a90153f3 	stp	x19, x20, [sp, #16]
    send_frame_series(&ff_frame, 1, rx_addr);
  403fc4:	72a31b42 	movk	w2, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  403fc8:	a9025bf5 	stp	x21, x22, [sp, #32]
    start_time = k_uptime_get_32();

    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  403fcc:	90000155 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  403fd0:	b0000094 	adrp	x20, 414000 <__func__.1+0xd>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  403fd4:	f9400001 	ldr	x1, [x0]
  403fd8:	f9003fe1 	str	x1, [sp, #120]
  403fdc:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  403fe0:	52820220 	mov	w0, #0x1011                	// #4113
  403fe4:	790063e0 	strh	w0, [sp, #48]
  403fe8:	b0000080 	adrp	x0, 414000 <__func__.1+0xd>
  403fec:	9109d000 	add	x0, x0, #0x274
  403ff0:	9100cbe1 	add	x1, sp, #0x32
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  403ff4:	91067a94 	add	x20, x20, #0x19e
  403ff8:	90000093 	adrp	x19, 413000 <z_timer_expiration_handler+0x68>
  403ffc:	911f0e73 	add	x19, x19, #0x7c3
  404000:	ad400400 	ldp	q0, q1, [x0]
  404004:	ad000420 	stp	q0, q1, [x1]
  404008:	3dc00800 	ldr	q0, [x0, #32]
  40400c:	3d800820 	str	q0, [x1, #32]
  404010:	3cc2e000 	ldur	q0, [x0, #46]
    ff_frame.length = DATA_SIZE_FF + 2;
  404014:	52800800 	mov	w0, #0x40                  	// #64
  404018:	3c82e020 	stur	q0, [x1, #46]
    send_frame_series(&ff_frame, 1, rx_addr);
  40401c:	d2800021 	mov	x1, #0x1                   	// #1
    ff_frame.length = DATA_SIZE_FF + 2;
  404020:	3901c3e0 	strb	w0, [sp, #112]
    send_frame_series(&ff_frame, 1, rx_addr);
  404024:	9100c3e0 	add	x0, sp, #0x30
  404028:	97ffff92 	bl	403e70 <send_frame_series>
 *
 * @return The low 32 bits of the current uptime, in milliseconds.
 */
static inline uint32_t k_uptime_get_32(void)
{
	return (uint32_t)k_uptime_get();
  40402c:	97fffea5 	bl	403ac0 <k_uptime_get>
  404030:	aa0003f6 	mov	x22, x0
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  404034:	f94712b5 	ldr	x21, [x21, #3616]
  404038:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  40403c:	d2801001 	mov	x1, #0x80                  	// #128
  404040:	aa1503e0 	mov	x0, x21
  404044:	97fffe53 	bl	403990 <blocking_recv>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  404048:	7100f81f 	cmp	w0, #0x3e
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  40404c:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  404050:	aa1403e4 	mov	x4, x20
  404054:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404058:	9124d8a5 	add	x5, x5, #0x936
  40405c:	528044a3 	mov	w3, #0x225                 	// #549
  404060:	1a9f17e0 	cset	w0, eq  // eq = none
  404064:	aa1303e2 	mov	x2, x19
  404068:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  40406c:	91256421 	add	x1, x1, #0x959
  404070:	97fffed4 	bl	403bc0 <z_zassert.constprop.0>
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  404074:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  404078:	d2801001 	mov	x1, #0x80                  	// #128
  40407c:	aa1503e0 	mov	x0, x21
  404080:	97fffe44 	bl	403990 <blocking_recv>
    zassert_equal(ret, ISOTP_N_TIMEOUT_CR, "Expected timeout but got %d", ret);
  404084:	31000c1f 	cmn	w0, #0x3
    ret = blocking_recv(data_buf, sizeof(data_buf), K_FOREVER);
  404088:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_TIMEOUT_CR, "Expected timeout but got %d", ret);
  40408c:	aa1403e4 	mov	x4, x20
  404090:	aa1303e2 	mov	x2, x19
  404094:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404098:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  40409c:	9125e4a5 	add	x5, x5, #0x979
  4040a0:	91265421 	add	x1, x1, #0x995
  4040a4:	528044e3 	mov	w3, #0x227                 	// #551
  4040a8:	1a9f17e0 	cset	w0, eq  // eq = none
  4040ac:	97fffec5 	bl	403bc0 <z_zassert.constprop.0>
  4040b0:	97fffe84 	bl	403ac0 <k_uptime_get>

    time_diff = k_uptime_get_32() - start_time;
  4040b4:	4b160016 	sub	w22, w0, w22
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4040b8:	710f9edf 	cmp	w22, #0x3e7
  4040bc:	2a1603e6 	mov	w6, w22
  4040c0:	aa1403e4 	mov	x4, x20
  4040c4:	aa1303e2 	mov	x2, x19
  4040c8:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4040cc:	52804543 	mov	w3, #0x22a                 	// #554
  4040d0:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  4040d4:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  4040d8:	9126eca5 	add	x5, x5, #0x9bb
  4040dc:	91275021 	add	x1, x1, #0x9d4
  4040e0:	97fffeb8 	bl	403bc0 <z_zassert.constprop.0>
    zassert_true(time_diff <= BS_TIMEOUT_UPPER_MS, "Timeout too slow (%dms)", time_diff);
  4040e4:	711132df 	cmp	w22, #0x44c
  4040e8:	aa1303e2 	mov	x2, x19
  4040ec:	1a9f87e0 	cset	w0, ls  // ls = plast
  4040f0:	2a1603e6 	mov	w6, w22
  4040f4:	aa1403e4 	mov	x4, x20
  4040f8:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  4040fc:	52804563 	mov	w3, #0x22b                 	// #555
  404100:	912800a5 	add	x5, x5, #0xa00
  404104:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404108:	91286021 	add	x1, x1, #0xa18
  40410c:	97fffead 	bl	403bc0 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_timeouts)
  404110:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404114:	f9476800 	ldr	x0, [x0, #3792]
  404118:	f9403fe2 	ldr	x2, [sp, #120]
  40411c:	f9400001 	ldr	x1, [x0]
  404120:	eb010042 	subs	x2, x2, x1
  404124:	d2800001 	mov	x1, #0x0                   	// #0
  404128:	54000040 	b.eq	404130 <_isotp_fast_conformance_async_fd_test_receive_timeouts_wrapper+0x184>  // b.none
  40412c:	97fff47d 	bl	401320 <__stack_chk_fail@plt>
  404130:	a94153f3 	ldp	x19, x20, [sp, #16]
  404134:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404138:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40413c:	d65f03c0 	ret

0000000000404140 <isotp_fast_sent_handler>:
    zassert_equal(result, expected_err_nr, "Unexpected error nr. expect: %d, got %d",
  404140:	6b00003f 	cmp	w1, w0
{
  404144:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  404148:	2a0003e7 	mov	w7, w0
  40414c:	910003fd 	mov	x29, sp
  404150:	aa0103e6 	mov	x6, x1
    zassert_equal(result, expected_err_nr, "Unexpected error nr. expect: %d, got %d",
  404154:	1a9f17e0 	cset	w0, eq  // eq = none
  404158:	52800323 	mov	w3, #0x19                  	// #25
  40415c:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404160:	90000084 	adrp	x4, 414000 <__func__.1+0xd>
  404164:	912910a5 	add	x5, x5, #0xa44
  404168:	91048c84 	add	x4, x4, #0x123
  40416c:	f0000062 	adrp	x2, 413000 <z_timer_expiration_handler+0x68>
  404170:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404174:	911f0c42 	add	x2, x2, #0x7c3
  404178:	9129b021 	add	x1, x1, #0xa6c
  40417c:	97fffe91 	bl	403bc0 <z_zassert.constprop.0>
	z_impl_k_sem_give(sem);
  404180:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
}
  404184:	a8c17bfd 	ldp	x29, x30, [sp], #16
  404188:	f947f800 	ldr	x0, [x0, #4080]
  40418c:	14002d1b 	b	40f5f8 <z_impl_k_sem_give>

0000000000404190 <isotp_fast_conformance_setup>:
    ret = k_sem_take(&send_compl_sem, K_MSEC(200));
    zassert_equal(ret, 0, "Send complete callback not called");
}

void *isotp_fast_conformance_setup(void)
{
  404190:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    int ret;

    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  404194:	528059c3 	mov	w3, #0x2ce                 	// #718
  404198:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
{
  40419c:	910003fd 	mov	x29, sp
  4041a0:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  4041a4:	f0000074 	adrp	x20, 413000 <z_timer_expiration_handler+0x68>
  4041a8:	f0000073 	adrp	x19, 413000 <z_timer_expiration_handler+0x68>
  4041ac:	913fce94 	add	x20, x20, #0xff3
  4041b0:	911f0e73 	add	x19, x19, #0x7c3
  4041b4:	912a48a5 	add	x5, x5, #0xa92
  4041b8:	aa1403e4 	mov	x4, x20
  4041bc:	aa1303e2 	mov	x2, x19
  4041c0:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  4041c4:	52800020 	mov	w0, #0x1                   	// #1
  4041c8:	912aac21 	add	x1, x1, #0xaab
{
  4041cc:	f90013f5 	str	x21, [sp, #32]
    zassert_true(sizeof(random_data) >= sizeof(data_buf) * 2 + 10, "Test data size too small");
  4041d0:	97fffe7c 	bl	403bc0 <z_zassert.constprop.0>
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
  4041d4:	f0000135 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
  4041d8:	f94722b5 	ldr	x21, [x21, #3648]
  4041dc:	aa1503e0 	mov	x0, x21
  4041e0:	940024ae 	bl	40d498 <z_device_is_ready>

    zassert_true(device_is_ready(can_dev), "CAN device not ready");
  4041e4:	aa1403e4 	mov	x4, x20
  4041e8:	aa1303e2 	mov	x2, x19
  4041ec:	52805a03 	mov	w3, #0x2d0                 	// #720
  4041f0:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  4041f4:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  4041f8:	912b9ca5 	add	x5, x5, #0xae7
  4041fc:	912bf021 	add	x1, x1, #0xafc
  404200:	97fffe70 	bl	403bc0 <z_zassert.constprop.0>
	return api->set_mode(dev, mode);
  404204:	f9400aa0 	ldr	x0, [x21, #16]
  404208:	528000a1 	mov	w1, #0x5                   	// #5
  40420c:	f9400c02 	ldr	x2, [x0, #24]
  404210:	aa1503e0 	mov	x0, x21
  404214:	d63f0040 	blr	x2
    can_mode_t can_mode = CAN_MODE_LOOPBACK;
#ifdef CONFIG_CAN_FD_MODE
    can_mode |= CAN_MODE_FD;
#endif
    ret = can_set_mode(can_dev, can_mode);
    zassert_equal(ret, 0, "Failed to set loopback mode [%d]", ret);
  404218:	7100001f 	cmp	w0, #0x0
  40421c:	2a0003e6 	mov	w6, w0
  404220:	aa1403e4 	mov	x4, x20
  404224:	aa1303e2 	mov	x2, x19
  404228:	1a9f17e0 	cset	w0, eq  // eq = none
  40422c:	52805ae3 	mov	w3, #0x2d7                 	// #727
  404230:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404234:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404238:	912c80a5 	add	x5, x5, #0xb20
  40423c:	91227821 	add	x1, x1, #0x89e
  404240:	97fffe60 	bl	403bc0 <z_zassert.constprop.0>
	return z_impl_k_sem_init(sem, initial_count, limit);
  404244:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404248:	52800022 	mov	w2, #0x1                   	// #1
  40424c:	52800001 	mov	w1, #0x0                   	// #0
  404250:	f947f800 	ldr	x0, [x0, #4080]
  404254:	94002cde 	bl	40f5cc <z_impl_k_sem_init>

    k_sem_init(&send_compl_sem, 0, 1);

    return NULL;
}
  404258:	d2800000 	mov	x0, #0x0                   	// #0
  40425c:	a94153f3 	ldp	x19, x20, [sp, #16]
  404260:	f94013f5 	ldr	x21, [sp, #32]
  404264:	a8c37bfd 	ldp	x29, x30, [sp], #48
  404268:	d65f03c0 	ret

000000000040426c <isotp_fast_recv_handler>:
{
  40426c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  404270:	f0000122 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
    struct recv_msg msg = {
  404274:	4f000400 	movi	v0.4s, #0x0
{
  404278:	910003fd 	mov	x29, sp
  40427c:	f9476842 	ldr	x2, [x2, #3792]
    struct recv_msg msg = {
  404280:	910043e4 	add	x4, sp, #0x10
{
  404284:	f9400043 	ldr	x3, [x2]
  404288:	f9002fe3 	str	x3, [sp, #88]
  40428c:	d2800003 	mov	x3, #0x0                   	// #0
        .len = buffer->len,
  404290:	79404002 	ldrh	w2, [x0, #32]
    struct recv_msg msg = {
  404294:	ad000080 	stp	q0, q0, [x4]
  404298:	d2800903 	mov	x3, #0x48                  	// #72
    memcpy(&msg.data, buffer->data, MIN(sizeof(msg.data), buffer->len));
  40429c:	7101005f 	cmp	w2, #0x40
    struct recv_msg msg = {
  4042a0:	ad010080 	stp	q0, q0, [x4, #32]
  4042a4:	b900409f 	str	wzr, [x4, #64]
  4042a8:	b90057e1 	str	w1, [sp, #84]
    memcpy(&msg.data, buffer->data, MIN(sizeof(msg.data), buffer->len));
  4042ac:	52800801 	mov	w1, #0x40                  	// #64
    struct recv_msg msg = {
  4042b0:	7900a3e2 	strh	w2, [sp, #80]
    memcpy(&msg.data, buffer->data, MIN(sizeof(msg.data), buffer->len));
  4042b4:	1a819042 	csel	w2, w2, w1, ls  // ls = plast
  4042b8:	f9400c01 	ldr	x1, [x0, #24]
  4042bc:	92403c42 	and	x2, x2, #0xffff
  4042c0:	aa0403e0 	mov	x0, x4
  4042c4:	97fff3e3 	bl	401250 <__memcpy_chk@plt>
	return z_impl_k_msgq_put(msgq, data, timeout);
  4042c8:	aa0003e1 	mov	x1, x0
  4042cc:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4042d0:	d2800002 	mov	x2, #0x0                   	// #0
  4042d4:	f9479000 	ldr	x0, [x0, #3872]
  4042d8:	94002909 	bl	40e6fc <z_impl_k_msgq_put>
}
  4042dc:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4042e0:	f9476800 	ldr	x0, [x0, #3792]
  4042e4:	f9402fe2 	ldr	x2, [sp, #88]
  4042e8:	f9400001 	ldr	x1, [x0]
  4042ec:	eb010042 	subs	x2, x2, x1
  4042f0:	d2800001 	mov	x1, #0x0                   	// #0
  4042f4:	54000040 	b.eq	4042fc <isotp_fast_recv_handler+0x90>  // b.none
  4042f8:	97fff40a 	bl	401320 <__stack_chk_fail@plt>
  4042fc:	a8c67bfd 	ldp	x29, x30, [sp], #96
  404300:	d65f03c0 	ret

0000000000404304 <_isotp_fast_conformance_async_fd_test_send_timeouts_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_timeouts)
  404304:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  404308:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40430c:	910003fd 	mov	x29, sp
  404310:	f9476800 	ldr	x0, [x0, #3792]
  404314:	a90153f3 	stp	x19, x20, [sp, #16]
  404318:	a9025bf5 	stp	x21, x22, [sp, #32]
  40431c:	a90363f7 	stp	x23, x24, [sp, #48]
  404320:	a9046bf9 	stp	x25, x26, [sp, #64]
  404324:	a90573fb 	stp	x27, x28, [sp, #80]
  404328:	f9400001 	ldr	x1, [x0]
  40432c:	f90067e1 	str	x1, [sp, #200]
  404330:	d2800001 	mov	x1, #0x0                   	// #0
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404334:	52810600 	mov	w0, #0x830                 	// #2096
  404338:	790103e0 	strh	w0, [sp, #128]
    fc_cts_frame.length = DATA_SIZE_FC;
  40433c:	52800060 	mov	w0, #0x3                   	// #3
    fc_cts_frame.data[2] = FC_PCI_BYTE_3(0);
  404340:	39020bff 	strb	wzr, [sp, #130]
    fc_cts_frame.length = DATA_SIZE_FC;
  404344:	390303e0 	strb	w0, [sp, #192]
	z_impl_k_sem_reset(sem);
  404348:	f0000135 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
    isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  40434c:	f000013a 	adrp	x26, 42b000 <__FRAME_END__+0x1007c>
  404350:	9000009b 	adrp	x27, 414000 <__func__.1+0xd>
  404354:	9109d37b 	add	x27, x27, #0x274
  404358:	f947fab5 	ldr	x21, [x21, #4080]
  40435c:	aa1503e0 	mov	x0, x21
  404360:	94002d4e 	bl	40f898 <z_impl_k_sem_reset>
  404364:	97fffdd7 	bl	403ac0 <k_uptime_get>
  404368:	aa0003fc 	mov	x28, x0
  40436c:	f9470f5a 	ldr	x26, [x26, #3608]
  404370:	aa1b03e1 	mov	x1, x27
  404374:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  404378:	52800023 	mov	w3, #0x1                   	// #1
  40437c:	aa1a03e0 	mov	x0, x26
  404380:	d2808002 	mov	x2, #0x400                 	// #1024
  404384:	97fffd00 	bl	403784 <isotp_fast_send>
	return z_impl_k_sem_take(sem, timeout);
  404388:	d2800dc1 	mov	x1, #0x6e                  	// #110
  40438c:	aa1503e0 	mov	x0, x21
  404390:	94002cd1 	bl	40f6d4 <z_impl_k_sem_take>
  404394:	2a0003f6 	mov	w22, w0
  404398:	97fffdca 	bl	403ac0 <k_uptime_get>
    zassert_equal(ret, 0, "Timeout too late");
  40439c:	f0000079 	adrp	x25, 413000 <z_timer_expiration_handler+0x68>
  4043a0:	710002df 	cmp	w22, #0x0
  4043a4:	912d0739 	add	x25, x25, #0xb41
  4043a8:	90000094 	adrp	x20, 414000 <__func__.1+0xd>
  4043ac:	f0000073 	adrp	x19, 413000 <z_timer_expiration_handler+0x68>
  4043b0:	91075294 	add	x20, x20, #0x1d4
  4043b4:	911f0e73 	add	x19, x19, #0x7c3
  4043b8:	f0000078 	adrp	x24, 413000 <z_timer_expiration_handler+0x68>
  4043bc:	91227b18 	add	x24, x24, #0x89e
    time_diff = k_uptime_get_32() - start_time;
  4043c0:	4b1c001c 	sub	w28, w0, w28
    zassert_equal(ret, 0, "Timeout too late");
  4043c4:	aa1903e5 	mov	x5, x25
  4043c8:	aa1403e4 	mov	x4, x20
  4043cc:	aa1303e2 	mov	x2, x19
  4043d0:	aa1803e1 	mov	x1, x24
  4043d4:	1a9f17e0 	cset	w0, eq  // eq = none
  4043d8:	52803e23 	mov	w3, #0x1f1                 	// #497
  4043dc:	97fffdf9 	bl	403bc0 <z_zassert.constprop.0>
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4043e0:	710f9f9f 	cmp	w28, #0x3e7
  4043e4:	f0000077 	adrp	x23, 413000 <z_timer_expiration_handler+0x68>
  4043e8:	f0000076 	adrp	x22, 413000 <z_timer_expiration_handler+0x68>
  4043ec:	9126eef7 	add	x23, x23, #0x9bb
  4043f0:	912752d6 	add	x22, x22, #0x9d4
  4043f4:	2a1c03e6 	mov	w6, w28
  4043f8:	aa1703e5 	mov	x5, x23
  4043fc:	aa1403e4 	mov	x4, x20
  404400:	aa1303e2 	mov	x2, x19
  404404:	aa1603e1 	mov	x1, x22
  404408:	1a9f97e0 	cset	w0, hi  // hi = pmore
  40440c:	52803e43 	mov	w3, #0x1f2                 	// #498
  404410:	97fffdec 	bl	403bc0 <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  404414:	aa1503e0 	mov	x0, x21
  404418:	94002d20 	bl	40f898 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  40441c:	aa1b03e1 	mov	x1, x27
  404420:	aa1a03e0 	mov	x0, x26
  404424:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  404428:	52800023 	mov	w3, #0x1                   	// #1
  40442c:	d2808002 	mov	x2, #0x400                 	// #1024
  404430:	97fffcd5 	bl	403784 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404434:	f0000068 	adrp	x8, 413000 <z_timer_expiration_handler+0x68>
  404438:	7100001f 	cmp	w0, #0x0
  40443c:	91223508 	add	x8, x8, #0x88d
  404440:	f0000067 	adrp	x7, 413000 <z_timer_expiration_handler+0x68>
  404444:	912d48e7 	add	x7, x7, #0xb52
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  404448:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  40444c:	aa0703e1 	mov	x1, x7
  404450:	aa0803e5 	mov	x5, x8
  404454:	aa1403e4 	mov	x4, x20
  404458:	1a9f17e0 	cset	w0, eq  // eq = none
  40445c:	52803f03 	mov	w3, #0x1f8                 	// #504
  404460:	aa1303e2 	mov	x2, x19
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  404464:	910203fc 	add	x28, sp, #0x80
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404468:	a90723e7 	stp	x7, x8, [sp, #112]
  40446c:	97fffdd5 	bl	403bc0 <z_zassert.constprop.0>
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  404470:	aa1c03e0 	mov	x0, x28
  404474:	52804022 	mov	w2, #0x201                 	// #513
  404478:	72a31b42 	movk	w2, #0x18da, lsl #16
  40447c:	d2800021 	mov	x1, #0x1                   	// #1
  404480:	97fffe7c 	bl	403e70 <send_frame_series>
  404484:	97fffd8f 	bl	403ac0 <k_uptime_get>
  404488:	f90037e0 	str	x0, [sp, #104]
	return z_impl_k_sem_take(sem, timeout);
  40448c:	d2800dc1 	mov	x1, #0x6e                  	// #110
  404490:	aa1503e0 	mov	x0, x21
  404494:	94002c90 	bl	40f6d4 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Timeout too late");
  404498:	7100001f 	cmp	w0, #0x0
  40449c:	aa1903e5 	mov	x5, x25
  4044a0:	aa1403e4 	mov	x4, x20
  4044a4:	aa1303e2 	mov	x2, x19
  4044a8:	aa1803e1 	mov	x1, x24
  4044ac:	52803fc3 	mov	w3, #0x1fe                 	// #510
  4044b0:	1a9f17e0 	cset	w0, eq  // eq = none
  4044b4:	97fffdc3 	bl	403bc0 <z_zassert.constprop.0>
  4044b8:	97fffd82 	bl	403ac0 <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  4044bc:	f94037e6 	ldr	x6, [sp, #104]
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4044c0:	aa1703e5 	mov	x5, x23
  4044c4:	aa1403e4 	mov	x4, x20
  4044c8:	aa1303e2 	mov	x2, x19
    time_diff = k_uptime_get_32() - start_time;
  4044cc:	4b060006 	sub	w6, w0, w6
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4044d0:	aa1603e1 	mov	x1, x22
  4044d4:	710f9cdf 	cmp	w6, #0x3e7
  4044d8:	52804023 	mov	w3, #0x201                 	// #513
  4044dc:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4044e0:	97fffdb8 	bl	403bc0 <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  4044e4:	aa1503e0 	mov	x0, x21
  4044e8:	94002cec 	bl	40f898 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  4044ec:	aa1b03e1 	mov	x1, x27
  4044f0:	aa1a03e0 	mov	x0, x26
  4044f4:	92800024 	mov	x4, #0xfffffffffffffffe    	// #-2
  4044f8:	52800023 	mov	w3, #0x1                   	// #1
  4044fc:	d2808002 	mov	x2, #0x400                 	// #1024
  404500:	97fffca1 	bl	403784 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404504:	a94723e7 	ldp	x7, x8, [sp, #112]
  404508:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, sizeof(random_data), rx_node_id,
  40450c:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404510:	aa1403e4 	mov	x4, x20
  404514:	aa1303e2 	mov	x2, x19
  404518:	1a9f17e0 	cset	w0, eq  // eq = none
  40451c:	528040e3 	mov	w3, #0x207                 	// #519
  404520:	aa0803e5 	mov	x5, x8
  404524:	aa0703e1 	mov	x1, x7
  404528:	97fffda6 	bl	403bc0 <z_zassert.constprop.0>
	return z_impl_k_sem_take(sem, timeout);
  40452c:	d2800a01 	mov	x1, #0x50                  	// #80
  404530:	aa1503e0 	mov	x0, x21
  404534:	94002c68 	bl	40f6d4 <z_impl_k_sem_take>
    zassert_equal(ret, -EAGAIN, "Timeout too early");
  404538:	31002c1f 	cmn	w0, #0xb
  40453c:	aa1403e4 	mov	x4, x20
  404540:	1a9f17e0 	cset	w0, eq  // eq = none
  404544:	52804143 	mov	w3, #0x20a                 	// #522
  404548:	aa1303e2 	mov	x2, x19
  40454c:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404550:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404554:	912dc0a5 	add	x5, x5, #0xb70
  404558:	912e0821 	add	x1, x1, #0xb82
  40455c:	97fffd99 	bl	403bc0 <z_zassert.constprop.0>
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404560:	52800600 	mov	w0, #0x30                  	// #48
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  404564:	52804022 	mov	w2, #0x201                 	// #513
    fc_cts_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  404568:	390203e0 	strb	w0, [sp, #128]
    send_frame_series(&fc_cts_frame, 1, rx_addr);
  40456c:	aa1c03e0 	mov	x0, x28
  404570:	72a31b42 	movk	w2, #0x18da, lsl #16
  404574:	d2800021 	mov	x1, #0x1                   	// #1
  404578:	97fffe3e 	bl	403e70 <send_frame_series>
  40457c:	97fffd51 	bl	403ac0 <k_uptime_get>
  404580:	aa0003fa 	mov	x26, x0
  404584:	d2800dc1 	mov	x1, #0x6e                  	// #110
  404588:	aa1503e0 	mov	x0, x21
  40458c:	94002c52 	bl	40f6d4 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Timeout too late");
  404590:	7100001f 	cmp	w0, #0x0
  404594:	aa1903e5 	mov	x5, x25
  404598:	aa1403e4 	mov	x4, x20
  40459c:	aa1303e2 	mov	x2, x19
  4045a0:	aa1803e1 	mov	x1, x24
  4045a4:	52804223 	mov	w3, #0x211                 	// #529
  4045a8:	1a9f17e0 	cset	w0, eq  // eq = none
  4045ac:	97fffd85 	bl	403bc0 <z_zassert.constprop.0>
  4045b0:	97fffd44 	bl	403ac0 <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  4045b4:	4b1a0006 	sub	w6, w0, w26
    zassert_true(time_diff >= BS_TIMEOUT_LOWER_MS, "Timeout too early (%dms)", time_diff);
  4045b8:	710f9cdf 	cmp	w6, #0x3e7
  4045bc:	aa1303e2 	mov	x2, x19
  4045c0:	aa1603e1 	mov	x1, x22
  4045c4:	1a9f97e0 	cset	w0, hi  // hi = pmore
  4045c8:	aa1703e5 	mov	x5, x23
  4045cc:	aa1403e4 	mov	x4, x20
  4045d0:	52804263 	mov	w3, #0x213                 	// #531
  4045d4:	97fffd7b 	bl	403bc0 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_timeouts)
  4045d8:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4045dc:	f9476800 	ldr	x0, [x0, #3792]
  4045e0:	f94067e2 	ldr	x2, [sp, #200]
  4045e4:	f9400001 	ldr	x1, [x0]
  4045e8:	eb010042 	subs	x2, x2, x1
  4045ec:	d2800001 	mov	x1, #0x0                   	// #0
  4045f0:	54000040 	b.eq	4045f8 <_isotp_fast_conformance_async_fd_test_send_timeouts_wrapper+0x2f4>  // b.none
  4045f4:	97fff34b 	bl	401320 <__stack_chk_fail@plt>
  4045f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4045fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404600:	a94363f7 	ldp	x23, x24, [sp, #48]
  404604:	a9446bf9 	ldp	x25, x26, [sp, #64]
  404608:	a94573fb 	ldp	x27, x28, [sp, #80]
  40460c:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  404610:	d65f03c0 	ret

0000000000404614 <check_data>:
{
  404614:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  404618:	910003fd 	mov	x29, sp
  40461c:	a90153f3 	stp	x19, x20, [sp, #16]
  404620:	aa0003f4 	mov	x20, x0
  404624:	aa0203f3 	mov	x19, x2
  404628:	a9025bf5 	stp	x21, x22, [sp, #32]
  40462c:	aa0103f5 	mov	x21, x1
  404630:	a90363f7 	stp	x23, x24, [sp, #48]
    ret = memcmp(frame, desired, length);
  404634:	97fff353 	bl	401380 <memcmp@plt>
  404638:	2a0003f6 	mov	w22, w0
    if (ret) {
  40463c:	340002a0 	cbz	w0, 404690 <check_data+0x7c>
int filter_id;

static void print_hex(const uint8_t *ptr, size_t len)
{
    while (len--) {
        printk("%02x ", *ptr++);
  404640:	f0000077 	adrp	x23, 413000 <z_timer_expiration_handler+0x68>
  404644:	8b1302b8 	add	x24, x21, x19
  404648:	912eb6f7 	add	x23, x23, #0xbad
        printk("desired bytes:\n");
  40464c:	f0000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  404650:	912e7400 	add	x0, x0, #0xb9d
  404654:	9400074c 	bl	406384 <printk>
    while (len--) {
  404658:	eb1802bf 	cmp	x21, x24
  40465c:	54000261 	b.ne	4046a8 <check_data+0x94>  // b.any
        printk("\nreceived (%zu bytes):\n", length);
  404660:	aa1303e1 	mov	x1, x19
        printk("%02x ", *ptr++);
  404664:	f0000075 	adrp	x21, 413000 <z_timer_expiration_handler+0x68>
  404668:	8b130293 	add	x19, x20, x19
  40466c:	912eb6b5 	add	x21, x21, #0xbad
  404670:	f0000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  404674:	912ecc00 	add	x0, x0, #0xbb3
  404678:	94000743 	bl	406384 <printk>
    while (len--) {
  40467c:	eb13029f 	cmp	x20, x19
  404680:	540001c1 	b.ne	4046b8 <check_data+0xa4>  // b.any
        printk("\n");
  404684:	b0000080 	adrp	x0, 415000 <random_data+0xd8c>
  404688:	91320800 	add	x0, x0, #0xc82
  40468c:	9400073e 	bl	406384 <printk>
}
  404690:	2a1603e0 	mov	w0, w22
  404694:	a94153f3 	ldp	x19, x20, [sp, #16]
  404698:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40469c:	a94363f7 	ldp	x23, x24, [sp, #48]
  4046a0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4046a4:	d65f03c0 	ret
        printk("%02x ", *ptr++);
  4046a8:	384016a1 	ldrb	w1, [x21], #1
  4046ac:	aa1703e0 	mov	x0, x23
  4046b0:	94000735 	bl	406384 <printk>
  4046b4:	17ffffe9 	b	404658 <check_data+0x44>
  4046b8:	38401681 	ldrb	w1, [x20], #1
  4046bc:	aa1503e0 	mov	x0, x21
  4046c0:	94000731 	bl	406384 <printk>
  4046c4:	17ffffee 	b	40467c <check_data+0x68>

00000000004046c8 <receive_test_data.constprop.0>:
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4046c8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  4046cc:	910003fd 	mov	x29, sp
  4046d0:	a90153f3 	stp	x19, x20, [sp, #16]
   case no work is done at all.  We detect these problems by referring
   non-existing functions.  */
__fortify_function void *
__NTH (memset (void *__dest, int __ch, size_t __len))
{
  return __builtin___memset_chk (__dest, __ch, __len,
  4046d4:	f0000133 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  4046d8:	f0000074 	adrp	x20, 413000 <z_timer_expiration_handler+0x68>
  4046dc:	f9471273 	ldr	x19, [x19, #3616]
  4046e0:	911f0e94 	add	x20, x20, #0x7c3
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4046e4:	a9025bf5 	stp	x21, x22, [sp, #32]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  4046e8:	90000095 	adrp	x21, 414000 <__func__.1+0xd>
  4046ec:	910902b5 	add	x21, x21, #0x240
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4046f0:	a90363f7 	stp	x23, x24, [sp, #48]
    const uint8_t *data_ptr = data;
  4046f4:	90000097 	adrp	x23, 414000 <__func__.1+0xd>
  4046f8:	9109d2f7 	add	x23, x23, #0x274
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  4046fc:	a9046bf9 	stp	x25, x26, [sp, #64]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  404700:	f000007a 	adrp	x26, 413000 <z_timer_expiration_handler+0x68>
  404704:	912f6b5a 	add	x26, x26, #0xbda
static void receive_test_data(struct isotp_fast_ctx *recv_ctx, const uint8_t *data, size_t len,
  404708:	f9002bfb 	str	x27, [sp, #80]
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  40470c:	f000007b 	adrp	x27, 413000 <z_timer_expiration_handler+0x68>
  404710:	912f2f7b 	add	x27, x27, #0xbcb
    size_t remaining_len = len;
  404714:	d2802219 	mov	x25, #0x110                 	// #272
  404718:	4f000400 	movi	v0.4s, #0x0
        recv_len = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  40471c:	d2800c82 	mov	x2, #0x64                  	// #100
  404720:	d2801001 	mov	x1, #0x80                  	// #128
  404724:	aa1303e0 	mov	x0, x19
  404728:	ad000260 	stp	q0, q0, [x19]
  40472c:	ad010260 	stp	q0, q0, [x19, #32]
  404730:	ad020260 	stp	q0, q0, [x19, #64]
  404734:	ad030260 	stp	q0, q0, [x19, #96]
  404738:	97fffc96 	bl	403990 <blocking_recv>
  40473c:	93407c18 	sxtw	x24, w0
        zassert_true(recv_len >= 0, "recv error: %d", recv_len);
  404740:	2a3803e0 	mvn	w0, w24
  404744:	2a1803e6 	mov	w6, w24
  404748:	aa1b03e5 	mov	x5, x27
  40474c:	aa1503e4 	mov	x4, x21
  404750:	aa1403e2 	mov	x2, x20
  404754:	aa1a03e1 	mov	x1, x26
  404758:	52800b83 	mov	w3, #0x5c                  	// #92
  40475c:	531f7c00 	lsr	w0, w0, #31
  404760:	97fffd18 	bl	403bc0 <z_zassert.constprop.0>
        zassert_true(remaining_len >= recv_len, "More data than expected");
  404764:	eb38c33f 	cmp	x25, w24, sxtw
  404768:	aa1503e4 	mov	x4, x21
  40476c:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404770:	912fcca5 	add	x5, x5, #0xbf3
  404774:	52800bc3 	mov	w3, #0x5e                  	// #94
  404778:	1a9f37e0 	cset	w0, cs  // cs = hs, nlast
  40477c:	aa1403e2 	mov	x2, x20
  404780:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404784:	91302c21 	add	x1, x1, #0xc0b
  404788:	97fffd0e 	bl	403bc0 <z_zassert.constprop.0>
        ret = check_data(data_buf, data_ptr, recv_len);
  40478c:	aa1703e1 	mov	x1, x23
  404790:	aa1803e2 	mov	x2, x24
  404794:	aa1303e0 	mov	x0, x19
  404798:	97ffff9f 	bl	404614 <check_data>
        zassert_equal(ret, 0, "Data differ");
  40479c:	7100001f 	cmp	w0, #0x0
  4047a0:	aa1503e4 	mov	x4, x21
  4047a4:	1a9f17e0 	cset	w0, eq  // eq = none
  4047a8:	aa1403e2 	mov	x2, x20
  4047ac:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  4047b0:	52800c03 	mov	w3, #0x60                  	// #96
  4047b4:	9130c0a5 	add	x5, x5, #0xc30
  4047b8:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  4047bc:	91227821 	add	x1, x1, #0x89e
  4047c0:	97fffd00 	bl	403bc0 <z_zassert.constprop.0>
        data_ptr += recv_len;
  4047c4:	8b1802f7 	add	x23, x23, x24
    } while (remaining_len);
  4047c8:	eb180339 	subs	x25, x25, x24
  4047cc:	54fffa61 	b.ne	404718 <receive_test_data.constprop.0+0x50>  // b.any
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(50));
  4047d0:	aa1303e0 	mov	x0, x19
  4047d4:	d28000a2 	mov	x2, #0x5                   	// #5
  4047d8:	d2801001 	mov	x1, #0x80                  	// #128
  4047dc:	97fffc6d 	bl	403990 <blocking_recv>
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4047e0:	aa1503e4 	mov	x4, x21
  4047e4:	aa1403e2 	mov	x2, x20
}
  4047e8:	a94153f3 	ldp	x19, x20, [sp, #16]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4047ec:	3100381f 	cmn	w0, #0xe
}
  4047f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(50));
  4047f4:	2a0003e6 	mov	w6, w0
}
  4047f8:	a94363f7 	ldp	x23, x24, [sp, #48]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  4047fc:	1a9f17e0 	cset	w0, eq  // eq = none
}
  404800:	a9446bf9 	ldp	x25, x26, [sp, #64]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  404804:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
}
  404808:	f9402bfb 	ldr	x27, [sp, #80]
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  40480c:	9125e4a5 	add	x5, x5, #0x979
}
  404810:	a8c67bfd 	ldp	x29, x30, [sp], #96
    zassert_equal(ret, ISOTP_RECV_TIMEOUT, "Expected timeout but got %d", ret);
  404814:	52800d43 	mov	w3, #0x6a                  	// #106
  404818:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  40481c:	91219c21 	add	x1, x1, #0x867
  404820:	17fffce8 	b	403bc0 <z_zassert.constprop.0>

0000000000404824 <get_sf.constprop.0>:
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  404824:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  404828:	d2800c82 	mov	x2, #0x64                  	// #100
  40482c:	d2801001 	mov	x1, #0x80                  	// #128
  404830:	4f000400 	movi	v0.4s, #0x0
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  404834:	910003fd 	mov	x29, sp
  404838:	a90153f3 	stp	x19, x20, [sp, #16]
  40483c:	f0000133 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
    zassert_equal(ret, data_size, "recv returned %d", ret);
  404840:	f0000074 	adrp	x20, 413000 <z_timer_expiration_handler+0x68>
  404844:	f9471273 	ldr	x19, [x19, #3616]
static void get_sf(struct isotp_fast_ctx *recv_ctx, size_t data_size)
  404848:	f90013f5 	str	x21, [sp, #32]
    zassert_equal(ret, data_size, "recv returned %d", ret);
  40484c:	90000095 	adrp	x21, 414000 <__func__.1+0xd>
  404850:	91024ab5 	add	x21, x21, #0x92
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  404854:	aa1303e0 	mov	x0, x19
    zassert_equal(ret, data_size, "recv returned %d", ret);
  404858:	911f0e94 	add	x20, x20, #0x7c3
  40485c:	ad000260 	stp	q0, q0, [x19]
  404860:	ad010260 	stp	q0, q0, [x19, #32]
  404864:	ad020260 	stp	q0, q0, [x19, #64]
  404868:	ad030260 	stp	q0, q0, [x19, #96]
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  40486c:	97fffc49 	bl	403990 <blocking_recv>
    zassert_equal(ret, data_size, "recv returned %d", ret);
  404870:	7100f81f 	cmp	w0, #0x3e
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(1000));
  404874:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, data_size, "recv returned %d", ret);
  404878:	aa1503e4 	mov	x4, x21
  40487c:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404880:	912158a5 	add	x5, x5, #0x856
  404884:	52800783 	mov	w3, #0x3c                  	// #60
  404888:	aa1403e2 	mov	x2, x20
  40488c:	1a9f17e0 	cset	w0, eq  // eq = none
  404890:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404894:	9130f021 	add	x1, x1, #0xc3c
  404898:	97fffcca 	bl	403bc0 <z_zassert.constprop.0>
    ret = check_data(data_buf, random_data, data_size);
  40489c:	aa1303e0 	mov	x0, x19
  4048a0:	d28007c2 	mov	x2, #0x3e                  	// #62
  4048a4:	90000081 	adrp	x1, 414000 <__func__.1+0xd>
  4048a8:	9109d021 	add	x1, x1, #0x274
  4048ac:	97ffff5a 	bl	404614 <check_data>
    zassert_equal(ret, 0, "Data differ");
  4048b0:	7100001f 	cmp	w0, #0x0
  4048b4:	aa1503e4 	mov	x4, x21
  4048b8:	aa1403e2 	mov	x2, x20
}
  4048bc:	a94153f3 	ldp	x19, x20, [sp, #16]
    zassert_equal(ret, 0, "Data differ");
  4048c0:	1a9f17e0 	cset	w0, eq  // eq = none
}
  4048c4:	f94013f5 	ldr	x21, [sp, #32]
    zassert_equal(ret, 0, "Data differ");
  4048c8:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
}
  4048cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    zassert_equal(ret, 0, "Data differ");
  4048d0:	9130c0a5 	add	x5, x5, #0xc30
  4048d4:	528007e3 	mov	w3, #0x3f                  	// #63
  4048d8:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  4048dc:	91227821 	add	x1, x1, #0x89e
  4048e0:	17fffcb8 	b	403bc0 <z_zassert.constprop.0>

00000000004048e4 <_isotp_fast_conformance_async_fd_test_receive_sf_fixed_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  4048e4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  4048e8:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    send_frame_series(&single_frame, 1, rx_addr);
  4048ec:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  4048f0:	910003fd 	mov	x29, sp
  4048f4:	f9476800 	ldr	x0, [x0, #3792]
  4048f8:	f9000bf3 	str	x19, [sp, #16]
  return __builtin___memcpy_chk (__dest, __src, __len,
  4048fc:	910083f3 	add	x19, sp, #0x20
    send_frame_series(&single_frame, 1, rx_addr);
  404900:	72a31b42 	movk	w2, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  404904:	f9400001 	ldr	x1, [x0]
  404908:	f90037e1 	str	x1, [sp, #104]
  40490c:	d2800001 	mov	x1, #0x0                   	// #0
    single_frame.data[0] = (SF_PCI_TYPE << PCI_TYPE_POS);
  404910:	5287c000 	mov	w0, #0x3e00                	// #15872
  404914:	790043e0 	strh	w0, [sp, #32]
  404918:	90000080 	adrp	x0, 414000 <__func__.1+0xd>
  40491c:	9109d000 	add	x0, x0, #0x274
  404920:	91008be1 	add	x1, sp, #0x22
  404924:	ad400400 	ldp	q0, q1, [x0]
  404928:	ad000420 	stp	q0, q1, [x1]
  40492c:	3dc00800 	ldr	q0, [x0, #32]
  404930:	3d800820 	str	q0, [x1, #32]
  404934:	3cc2e000 	ldur	q0, [x0, #46]
    single_frame.length = CAN_MAX_DLEN;
  404938:	52800800 	mov	w0, #0x40                  	// #64
  40493c:	3c82e020 	stur	q0, [x1, #46]
    send_frame_series(&single_frame, 1, rx_addr);
  404940:	d2800021 	mov	x1, #0x1                   	// #1
    single_frame.length = CAN_MAX_DLEN;
  404944:	390183e0 	strb	w0, [sp, #96]
    send_frame_series(&single_frame, 1, rx_addr);
  404948:	aa1303e0 	mov	x0, x19
  40494c:	97fffd49 	bl	403e70 <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  404950:	97ffffb5 	bl	404824 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | 0xFF);
  404954:	aa1303e0 	mov	x0, x19
  404958:	52805fe2 	mov	w2, #0x2ff                 	// #767
  40495c:	72a31b42 	movk	w2, #0x18da, lsl #16
  404960:	d2800021 	mov	x1, #0x1                   	// #1
  404964:	97fffd43 	bl	403e70 <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  404968:	97ffffaf 	bl	404824 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | (7U << 26));
  40496c:	aa1303e0 	mov	x0, x19
  404970:	52804022 	mov	w2, #0x201                 	// #513
  404974:	72a39b42 	movk	w2, #0x1cda, lsl #16
  404978:	d2800021 	mov	x1, #0x1                   	// #1
  40497c:	97fffd3d 	bl	403e70 <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  404980:	97ffffa9 	bl	404824 <get_sf.constprop.0>
    send_frame_series(&single_frame, 1, rx_addr | 0xFF00);
  404984:	aa1303e0 	mov	x0, x19
  404988:	529fe022 	mov	w2, #0xff01                	// #65281
  40498c:	72a31b42 	movk	w2, #0x18da, lsl #16
  404990:	d2800021 	mov	x1, #0x1                   	// #1
  404994:	97fffd37 	bl	403e70 <send_frame_series>
    get_sf_ignore(&ctx);
  404998:	97fffccd 	bl	403ccc <get_sf_ignore.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf_fixed)
  40499c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4049a0:	f9476800 	ldr	x0, [x0, #3792]
  4049a4:	f94037e2 	ldr	x2, [sp, #104]
  4049a8:	f9400001 	ldr	x1, [x0]
  4049ac:	eb010042 	subs	x2, x2, x1
  4049b0:	d2800001 	mov	x1, #0x0                   	// #0
  4049b4:	54000040 	b.eq	4049bc <_isotp_fast_conformance_async_fd_test_receive_sf_fixed_wrapper+0xd8>  // b.none
  4049b8:	97fff25a 	bl	401320 <__stack_chk_fail@plt>
  4049bc:	f9400bf3 	ldr	x19, [sp, #16]
  4049c0:	a8c77bfd 	ldp	x29, x30, [sp], #112
  4049c4:	d65f03c0 	ret

00000000004049c8 <_isotp_fast_conformance_async_fd_test_receive_sf_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  4049c8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  4049cc:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    send_frame_series(&single_frame, 1, rx_addr);
  4049d0:	52804022 	mov	w2, #0x201                 	// #513
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  4049d4:	910003fd 	mov	x29, sp
  4049d8:	f9476800 	ldr	x0, [x0, #3792]
  4049dc:	f9000bf3 	str	x19, [sp, #16]
  4049e0:	910083f3 	add	x19, sp, #0x20
    send_frame_series(&single_frame, 1, rx_addr);
  4049e4:	72a31b42 	movk	w2, #0x18da, lsl #16
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  4049e8:	f9400001 	ldr	x1, [x0]
  4049ec:	f90037e1 	str	x1, [sp, #104]
  4049f0:	d2800001 	mov	x1, #0x0                   	// #0
    single_frame.data[0] = (SF_PCI_TYPE << PCI_TYPE_POS);
  4049f4:	5287c000 	mov	w0, #0x3e00                	// #15872
  4049f8:	90000081 	adrp	x1, 414000 <__func__.1+0xd>
  4049fc:	9109d021 	add	x1, x1, #0x274
  404a00:	790043e0 	strh	w0, [sp, #32]
  404a04:	91008be0 	add	x0, sp, #0x22
  404a08:	ad400420 	ldp	q0, q1, [x1]
  404a0c:	ad000400 	stp	q0, q1, [x0]
  404a10:	3dc00820 	ldr	q0, [x1, #32]
  404a14:	3d800800 	str	q0, [x0, #32]
  404a18:	3cc2e020 	ldur	q0, [x1, #46]
    send_frame_series(&single_frame, 1, rx_addr);
  404a1c:	d2800021 	mov	x1, #0x1                   	// #1
  404a20:	3c82e000 	stur	q0, [x0, #46]
    single_frame.length = CAN_MAX_DLEN;
  404a24:	52800800 	mov	w0, #0x40                  	// #64
  404a28:	390183e0 	strb	w0, [sp, #96]
    send_frame_series(&single_frame, 1, rx_addr);
  404a2c:	aa1303e0 	mov	x0, x19
  404a30:	97fffd10 	bl	403e70 <send_frame_series>
    get_sf(&ctx, DATA_SIZE_SF);
  404a34:	97ffff7c 	bl	404824 <get_sf.constprop.0>
    single_frame.data[0] = SF_PCI_BYTE_LEN_8;
  404a38:	528007e0 	mov	w0, #0x3f                  	// #63
    send_frame_series(&single_frame, 1, rx_addr);
  404a3c:	52804022 	mov	w2, #0x201                 	// #513
    single_frame.data[0] = SF_PCI_BYTE_LEN_8;
  404a40:	390083e0 	strb	w0, [sp, #32]
    send_frame_series(&single_frame, 1, rx_addr);
  404a44:	aa1303e0 	mov	x0, x19
  404a48:	72a31b42 	movk	w2, #0x18da, lsl #16
  404a4c:	d2800021 	mov	x1, #0x1                   	// #1
  404a50:	97fffd08 	bl	403e70 <send_frame_series>
    get_sf_ignore(&ctx);
  404a54:	97fffc9e 	bl	403ccc <get_sf_ignore.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_sf)
  404a58:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404a5c:	f9476800 	ldr	x0, [x0, #3792]
  404a60:	f94037e2 	ldr	x2, [sp, #104]
  404a64:	f9400001 	ldr	x1, [x0]
  404a68:	eb010042 	subs	x2, x2, x1
  404a6c:	d2800001 	mov	x1, #0x0                   	// #0
  404a70:	54000040 	b.eq	404a78 <_isotp_fast_conformance_async_fd_test_receive_sf_wrapper+0xb0>  // b.none
  404a74:	97fff22b 	bl	401320 <__stack_chk_fail@plt>
  404a78:	f9400bf3 	ldr	x19, [sp, #16]
  404a7c:	a8c77bfd 	ldp	x29, x30, [sp], #112
  404a80:	d65f03c0 	ret

0000000000404a84 <isotp_fast_conformance_after>:
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
                    isotp_fast_recv_error_handler, isotp_fast_sent_handler);
}

void isotp_fast_conformance_after(void *)
{
  404a84:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    isotp_fast_unbind(&ctx);
  404a88:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
{
  404a8c:	910003fd 	mov	x29, sp
    isotp_fast_unbind(&ctx);
  404a90:	f9470c00 	ldr	x0, [x0, #3608]
{
  404a94:	f9000bf3 	str	x19, [sp, #16]
    isotp_fast_unbind(&ctx);
  404a98:	97fffb2d 	bl	40374c <isotp_fast_unbind>
	z_impl_k_msgq_purge(msgq);
  404a9c:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404aa0:	f0000133 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  404aa4:	f947e000 	ldr	x0, [x0, #4032]
  404aa8:	94002868 	bl	40ec48 <z_impl_k_msgq_purge>

    k_msgq_purge(&frame_msgq);
    if (filter_id >= 0) {
  404aac:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404ab0:	f947b400 	ldr	x0, [x0, #3944]
  404ab4:	b9400001 	ldr	w1, [x0]
  404ab8:	37f800a1 	tbnz	w1, #31, 404acc <isotp_fast_conformance_after+0x48>
	return api->remove_rx_filter(dev, filter_id);
  404abc:	f9472260 	ldr	x0, [x19, #3648]
  404ac0:	f9400802 	ldr	x2, [x0, #16]
  404ac4:	f9401c42 	ldr	x2, [x2, #56]
  404ac8:	d63f0040 	blr	x2
	return api->stop(dev);
  404acc:	f9472260 	ldr	x0, [x19, #3648]
        can_remove_rx_filter(can_dev, filter_id);
    }
    can_stop(can_dev);
}
  404ad0:	f9400bf3 	ldr	x19, [sp, #16]
  404ad4:	f9400801 	ldr	x1, [x0, #16]
  404ad8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  404adc:	f9400821 	ldr	x1, [x1, #16]
  404ae0:	aa0103f0 	mov	x16, x1
  404ae4:	d61f0200 	br	x16

0000000000404ae8 <isotp_fast_conformance_before>:
{
  404ae8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  404aec:	910003fd 	mov	x29, sp
  404af0:	f9000bf3 	str	x19, [sp, #16]
	return api->start(dev);
  404af4:	f0000133 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  404af8:	f9472273 	ldr	x19, [x19, #3648]
  404afc:	f9400a60 	ldr	x0, [x19, #16]
  404b00:	f9400401 	ldr	x1, [x0, #8]
  404b04:	aa1303e0 	mov	x0, x19
  404b08:	d63f0020 	blr	x1
    zassert_equal(ret, 0, "Failed to start CAN controller [%d]", ret);
  404b0c:	7100001f 	cmp	w0, #0x0
  404b10:	2a0003e6 	mov	w6, w0
  404b14:	52805c23 	mov	w3, #0x2e1                 	// #737
  404b18:	1a9f17e0 	cset	w0, eq  // eq = none
  404b1c:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404b20:	f0000064 	adrp	x4, 413000 <z_timer_expiration_handler+0x68>
  404b24:	913164a5 	add	x5, x5, #0xc59
  404b28:	913f5484 	add	x4, x4, #0xfd5
  404b2c:	f0000062 	adrp	x2, 413000 <z_timer_expiration_handler+0x68>
  404b30:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404b34:	911f0c42 	add	x2, x2, #0x7c3
  404b38:	91227821 	add	x1, x1, #0x89e
  404b3c:	97fffc21 	bl	403bc0 <z_zassert.constprop.0>
    filter_id = -1;
  404b40:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404b44:	12800001 	mov	w1, #0xffffffff            	// #-1
  404b48:	f947b400 	ldr	x0, [x0, #3944]
  404b4c:	b9000001 	str	w1, [x0]
  404b50:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404b54:	f947e000 	ldr	x0, [x0, #4032]
  404b58:	9400283c 	bl	40ec48 <z_impl_k_msgq_purge>
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  404b5c:	aa1303e1 	mov	x1, x19
  404b60:	f0000127 	adrp	x7, 42b000 <__FRAME_END__+0x1007c>
  404b64:	f0000126 	adrp	x6, 42b000 <__FRAME_END__+0x1007c>
  404b68:	f0000124 	adrp	x4, 42b000 <__FRAME_END__+0x1007c>
  404b6c:	f0000123 	adrp	x3, 42b000 <__FRAME_END__+0x1007c>
  404b70:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
}
  404b74:	f9400bf3 	ldr	x19, [sp, #16]
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  404b78:	52804022 	mov	w2, #0x201                 	// #513
}
  404b7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    isotp_fast_bind(&ctx, can_dev, rx_addr, &fc_opts, isotp_fast_recv_handler, NULL,
  404b80:	d2800005 	mov	x5, #0x0                   	// #0
  404b84:	f947c4e7 	ldr	x7, [x7, #3976]
  404b88:	72a31b42 	movk	w2, #0x18da, lsl #16
  404b8c:	f947c0c6 	ldr	x6, [x6, #3968]
  404b90:	f9470084 	ldr	x4, [x4, #3584]
  404b94:	f947ac63 	ldr	x3, [x3, #3928]
  404b98:	f9470c00 	ldr	x0, [x0, #3608]
  404b9c:	17fffaa6 	b	403634 <isotp_fast_bind>

0000000000404ba0 <check_frame_series.constprop.0>:
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  404ba0:	d10403ff 	sub	sp, sp, #0x100
  404ba4:	a9047bfd 	stp	x29, x30, [sp, #64]
  404ba8:	910103fd 	add	x29, sp, #0x40
  404bac:	a90553f3 	stp	x19, x20, [sp, #80]
  404bb0:	aa0003f3 	mov	x19, x0
  404bb4:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404bb8:	a9065bf5 	stp	x21, x22, [sp, #96]
  404bbc:	f9476800 	ldr	x0, [x0, #3792]
  404bc0:	a90763f7 	stp	x23, x24, [sp, #112]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404bc4:	f0000078 	adrp	x24, 413000 <z_timer_expiration_handler+0x68>
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  404bc8:	a9086bf9 	stp	x25, x26, [sp, #128]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404bcc:	9131f718 	add	x24, x24, #0xc7d
    for (i = 0; i < length; i++) {
  404bd0:	52800017 	mov	w23, #0x0                   	// #0
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  404bd4:	a90973fb 	stp	x27, x28, [sp, #144]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404bd8:	9000009b 	adrp	x27, 414000 <__func__.1+0xd>
  404bdc:	f000007c 	adrp	x28, 413000 <z_timer_expiration_handler+0x68>
        zassert_equal(can_dlc_to_bytes(frame.dlc),
  404be0:	91026776 	add	x22, x27, #0x99
  404be4:	911f0f95 	add	x21, x28, #0x7c3
static void check_frame_series(struct frame_desired *frames, size_t length, struct k_msgq *msgq)
  404be8:	f9400002 	ldr	x2, [x0]
  404bec:	f9007fe2 	str	x2, [sp, #248]
  404bf0:	d2800002 	mov	x2, #0x0                   	// #0
    for (i = 0; i < length; i++) {
  404bf4:	b900afe1 	str	w1, [sp, #172]
	return z_impl_k_msgq_get(msgq, data, timeout);
  404bf8:	f0000134 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  404bfc:	9102c3f9 	add	x25, sp, #0xb0
  404c00:	aa1903e1 	mov	x1, x25
  404c04:	d2800642 	mov	x2, #0x32                  	// #50
  404c08:	f947e280 	ldr	x0, [x20, #4032]
        zassert_equal(ret, 0, "Timeout waiting for msg nr %d. ret: %d", i, ret);
  404c0c:	f000007a 	adrp	x26, 413000 <z_timer_expiration_handler+0x68>
  404c10:	94002761 	bl	40e994 <z_impl_k_msgq_get>
  404c14:	7100001f 	cmp	w0, #0x0
  404c18:	2a0003e7 	mov	w7, w0
  404c1c:	91227b41 	add	x1, x26, #0x89e
  404c20:	2a1703e6 	mov	w6, w23
  404c24:	aa1803e5 	mov	x5, x24
  404c28:	91026764 	add	x4, x27, #0x99
  404c2c:	911f0f82 	add	x2, x28, #0x7c3
  404c30:	1a9f17e0 	cset	w0, eq  // eq = none
  404c34:	52801143 	mov	w3, #0x8a                  	// #138
  404c38:	97fffbe2 	bl	403bc0 <z_zassert.constprop.0>
        zassert_equal(can_dlc_to_bytes(frame.dlc),
  404c3c:	3942d3e1 	ldrb	w1, [sp, #180]
	return dlc > 0x0F ? 64 : dlc_table[dlc];
  404c40:	71003c3f 	cmp	w1, #0xf
  404c44:	54000a28 	b.hi	404d88 <check_frame_series.constprop.0+0x1e8>  // b.pmore
  404c48:	90000080 	adrp	x0, 414000 <__func__.1+0xd>
  404c4c:	91098400 	add	x0, x0, #0x261
  404c50:	3861c801 	ldrb	w1, [x0, w1, sxtw]
  404c54:	39410267 	ldrb	w7, [x19, #64]
  404c58:	2a0703e0 	mov	w0, w7
  404c5c:	97fffba0 	bl	403adc <can_bytes_to_dlc>
  404c60:	12001c00 	and	w0, w0, #0xff
  404c64:	71003c1f 	cmp	w0, #0xf
  404c68:	54000948 	b.hi	404d90 <check_frame_series.constprop.0+0x1f0>  // b.pmore
  404c6c:	90000082 	adrp	x2, 414000 <__func__.1+0xd>
  404c70:	91098442 	add	x2, x2, #0x261
  404c74:	3860c840 	ldrb	w0, [x2, w0, sxtw]
  404c78:	6b01001f 	cmp	w0, w1
  404c7c:	b90003e1 	str	w1, [sp]
  404c80:	2a1703e6 	mov	w6, w23
  404c84:	aa1603e4 	mov	x4, x22
  404c88:	1a9f17e0 	cset	w0, eq  // eq = none
  404c8c:	528011e3 	mov	w3, #0x8f                  	// #143
  404c90:	aa1503e2 	mov	x2, x21
  404c94:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404c98:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404c9c:	913290a5 	add	x5, x5, #0xca4
  404ca0:	91335021 	add	x1, x1, #0xcd4
  404ca4:	97fffbc7 	bl	403bc0 <z_zassert.constprop.0>
        ret = check_data(frame.data, desired->data, desired->length);
  404ca8:	39410262 	ldrb	w2, [x19, #64]
  404cac:	aa1303e1 	mov	x1, x19
  404cb0:	9102e3e0 	add	x0, sp, #0xb8
    for (i = 0; i < length; i++) {
  404cb4:	110006f7 	add	w23, w23, #0x1
        desired++;
  404cb8:	91010673 	add	x19, x19, #0x41
        ret = check_data(frame.data, desired->data, desired->length);
  404cbc:	97fffe56 	bl	404614 <check_data>
        zassert_equal(ret, 0, "Data differ");
  404cc0:	7100001f 	cmp	w0, #0x0
  404cc4:	aa1603e4 	mov	x4, x22
  404cc8:	aa1503e2 	mov	x2, x21
  404ccc:	91227b41 	add	x1, x26, #0x89e
  404cd0:	1a9f17e0 	cset	w0, eq  // eq = none
  404cd4:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404cd8:	528012a3 	mov	w3, #0x95                  	// #149
  404cdc:	9130c0a5 	add	x5, x5, #0xc30
  404ce0:	97fffbb8 	bl	403bc0 <z_zassert.constprop.0>
    for (i = 0; i < length; i++) {
  404ce4:	b940afe0 	ldr	w0, [sp, #172]
  404ce8:	6b0002ff 	cmp	w23, w0
  404cec:	54fff861 	b.ne	404bf8 <check_frame_series.constprop.0+0x58>  // b.any
  404cf0:	f947e280 	ldr	x0, [x20, #4032]
  404cf4:	aa1903e1 	mov	x1, x25
  404cf8:	d2800282 	mov	x2, #0x14                  	// #20
  404cfc:	94002726 	bl	40e994 <z_impl_k_msgq_get>
    zassert_equal(ret, -EAGAIN,
  404d00:	31002c1f 	cmn	w0, #0xb
  404d04:	2a0003e6 	mov	w6, w0
  404d08:	3942ffe0 	ldrb	w0, [sp, #191]
  404d0c:	b90033e0 	str	w0, [sp, #48]
  404d10:	aa1503e2 	mov	x2, x21
  404d14:	3942fbe0 	ldrb	w0, [sp, #190]
  404d18:	aa1603e4 	mov	x4, x22
  404d1c:	b9002be0 	str	w0, [sp, #40]
  404d20:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404d24:	3942f7e0 	ldrb	w0, [sp, #189]
  404d28:	9134cca5 	add	x5, x5, #0xd33
  404d2c:	b90023e0 	str	w0, [sp, #32]
  404d30:	52801343 	mov	w3, #0x9a                  	// #154
  404d34:	3942f3e0 	ldrb	w0, [sp, #188]
  404d38:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404d3c:	b9001be0 	str	w0, [sp, #24]
  404d40:	912e0821 	add	x1, x1, #0xb82
  404d44:	3942efe0 	ldrb	w0, [sp, #187]
  404d48:	3942e3e7 	ldrb	w7, [sp, #184]
  404d4c:	b90013e0 	str	w0, [sp, #16]
  404d50:	3942ebe0 	ldrb	w0, [sp, #186]
  404d54:	b9000be0 	str	w0, [sp, #8]
  404d58:	3942e7e0 	ldrb	w0, [sp, #185]
  404d5c:	b90003e0 	str	w0, [sp]
  404d60:	1a9f17e0 	cset	w0, eq  // eq = none
  404d64:	97fffb97 	bl	403bc0 <z_zassert.constprop.0>
}
  404d68:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404d6c:	f9476800 	ldr	x0, [x0, #3792]
  404d70:	f9407fe2 	ldr	x2, [sp, #248]
  404d74:	f9400001 	ldr	x1, [x0]
  404d78:	eb010042 	subs	x2, x2, x1
  404d7c:	d2800001 	mov	x1, #0x0                   	// #0
  404d80:	540000c0 	b.eq	404d98 <check_frame_series.constprop.0+0x1f8>  // b.none
  404d84:	97fff167 	bl	401320 <__stack_chk_fail@plt>
  404d88:	52800801 	mov	w1, #0x40                  	// #64
  404d8c:	17ffffb2 	b	404c54 <check_frame_series.constprop.0+0xb4>
  404d90:	52800800 	mov	w0, #0x40                  	// #64
  404d94:	17ffffb9 	b	404c78 <check_frame_series.constprop.0+0xd8>
  404d98:	a9447bfd 	ldp	x29, x30, [sp, #64]
  404d9c:	a94553f3 	ldp	x19, x20, [sp, #80]
  404da0:	a9465bf5 	ldp	x21, x22, [sp, #96]
  404da4:	a94763f7 	ldp	x23, x24, [sp, #112]
  404da8:	a9486bf9 	ldp	x25, x26, [sp, #128]
  404dac:	a94973fb 	ldp	x27, x28, [sp, #144]
  404db0:	910403ff 	add	sp, sp, #0x100
  404db4:	d65f03c0 	ret

0000000000404db8 <_isotp_fast_conformance_async_fd_test_sender_fc_errors_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  404db8:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  404dbc:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404dc0:	910003fd 	mov	x29, sp
  404dc4:	f9476800 	ldr	x0, [x0, #3792]
  404dc8:	a90153f3 	stp	x19, x20, [sp, #16]
  404dcc:	90000093 	adrp	x19, 414000 <__func__.1+0xd>
  404dd0:	9109d273 	add	x19, x19, #0x274
  404dd4:	a9025bf5 	stp	x21, x22, [sp, #32]
  404dd8:	9101e3f5 	add	x21, sp, #0x78
  404ddc:	a90363f7 	stp	x23, x24, [sp, #48]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404de0:	f0000137 	adrp	x23, 42b000 <__FRAME_END__+0x1007c>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  404de4:	a9046bf9 	stp	x25, x26, [sp, #64]
  404de8:	a90573fb 	stp	x27, x28, [sp, #80]
  404dec:	f9400001 	ldr	x1, [x0]
  404df0:	f90087e1 	str	x1, [sp, #264]
  404df4:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  404df8:	52820220 	mov	w0, #0x1011                	// #4113
  404dfc:	ad400660 	ldp	q0, q1, [x19]
  404e00:	9101ebe1 	add	x1, sp, #0x7a
  404e04:	7900f3e0 	strh	w0, [sp, #120]
    ff_frame.length = DATA_SIZE_FF + 2;
  404e08:	52800800 	mov	w0, #0x40                  	// #64
  404e0c:	ad000420 	stp	q0, q1, [x1]
  404e10:	3dc00a60 	ldr	q0, [x19, #32]
  404e14:	3d800820 	str	q0, [x1, #32]
  404e18:	3cc2e260 	ldur	q0, [x19, #46]
  404e1c:	3c82e020 	stur	q0, [x1, #46]
  404e20:	3902e3e0 	strb	w0, [sp, #184]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404e24:	52802040 	mov	w0, #0x102                 	// #258
  404e28:	72a31b40 	movk	w0, #0x18da, lsl #16
  404e2c:	97fffbd5 	bl	403d80 <add_rx_msgq.constprop.0>
  404e30:	f947b6f7 	ldr	x23, [x23, #3944]
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  404e34:	39030bff 	strb	wzr, [sp, #194]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404e38:	b90002e0 	str	w0, [x23]
    fc_frame.data[0] = FC_PCI_BYTE_1(3);
  404e3c:	52810660 	mov	w0, #0x833                 	// #2099
  404e40:	790183e0 	strh	w0, [sp, #192]
    fc_frame.length = DATA_SIZE_FC;
  404e44:	52800060 	mov	w0, #0x3                   	// #3
  404e48:	390403e0 	strb	w0, [sp, #256]
	z_impl_k_sem_reset(sem);
  404e4c:	f0000138 	adrp	x24, 42b000 <__FRAME_END__+0x1007c>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404e50:	f0000134 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
    send_frame_series(&fc_frame, 1, rx_addr);
  404e54:	910303f9 	add	x25, sp, #0xc0
  404e58:	f947fb16 	ldr	x22, [x24, #4080]
  404e5c:	aa1603e0 	mov	x0, x22
  404e60:	94002a8e 	bl	40f898 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404e64:	f9470e94 	ldr	x20, [x20, #3608]
  404e68:	aa1303e1 	mov	x1, x19
  404e6c:	92800084 	mov	x4, #0xfffffffffffffffb    	// #-5
  404e70:	52800023 	mov	w3, #0x1                   	// #1
  404e74:	aa1403e0 	mov	x0, x20
  404e78:	d2802202 	mov	x2, #0x110                 	// #272
  404e7c:	97fffa42 	bl	403784 <isotp_fast_send>
  404e80:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_OK, "Send returned %d", ret);
  404e84:	90000080 	adrp	x0, 414000 <__func__.1+0xd>
  404e88:	710000df 	cmp	w6, #0x0
  404e8c:	9103b41b 	add	x27, x0, #0xed
  404e90:	f0000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  404e94:	911f0c1a 	add	x26, x0, #0x7c3
  404e98:	aa1b03e4 	mov	x4, x27
  404e9c:	aa1a03e2 	mov	x2, x26
  404ea0:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404ea4:	912234a5 	add	x5, x5, #0x88d
  404ea8:	52805463 	mov	w3, #0x2a3                 	// #675
  404eac:	1a9f17e0 	cset	w0, eq  // eq = none
  404eb0:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404eb4:	912d4821 	add	x1, x1, #0xb52
  404eb8:	97fffb42 	bl	403bc0 <z_zassert.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404ebc:	aa1503e0 	mov	x0, x21
  404ec0:	d2800021 	mov	x1, #0x1                   	// #1
  404ec4:	97ffff37 	bl	404ba0 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  404ec8:	52804022 	mov	w2, #0x201                 	// #513
  404ecc:	aa1903e0 	mov	x0, x25
  404ed0:	72a31b42 	movk	w2, #0x18da, lsl #16
  404ed4:	d2800021 	mov	x1, #0x1                   	// #1
  404ed8:	97fffbe6 	bl	403e70 <send_frame_series>
	return z_impl_k_sem_take(sem, timeout);
  404edc:	d2800281 	mov	x1, #0x14                  	// #20
  404ee0:	aa1603e0 	mov	x0, x22
  404ee4:	940029fc 	bl	40f6d4 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  404ee8:	f000007c 	adrp	x28, 413000 <z_timer_expiration_handler+0x68>
  404eec:	7100001f 	cmp	w0, #0x0
  404ef0:	9135fb8b 	add	x11, x28, #0xd7e
  404ef4:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404ef8:	9122782a 	add	x10, x1, #0x89e
  404efc:	aa0a03e1 	mov	x1, x10
  404f00:	aa0b03e5 	mov	x5, x11
  404f04:	aa1b03e4 	mov	x4, x27
  404f08:	aa1a03e2 	mov	x2, x26
  404f0c:	1a9f17e0 	cset	w0, eq  // eq = none
  404f10:	52805503 	mov	w3, #0x2a8                 	// #680
  404f14:	a9062fea 	stp	x10, x11, [sp, #96]
  404f18:	97fffb2a 	bl	403bc0 <z_zassert.constprop.0>
    can_remove_rx_filter(can_dev, filter_id);
  404f1c:	b94002e1 	ldr	w1, [x23]
	return api->remove_rx_filter(dev, filter_id);
  404f20:	f0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  404f24:	f9472000 	ldr	x0, [x0, #3648]
  404f28:	f9400802 	ldr	x2, [x0, #16]
  404f2c:	f9401c42 	ldr	x2, [x2, #56]
  404f30:	d63f0040 	blr	x2
    ret = isotp_fast_send(&ctx, random_data, 5 * 1024, rx_node_id, NULL);
  404f34:	aa1303e1 	mov	x1, x19
  404f38:	aa1403e0 	mov	x0, x20
  404f3c:	d2800004 	mov	x4, #0x0                   	// #0
  404f40:	52800023 	mov	w3, #0x1                   	// #1
  404f44:	d2828002 	mov	x2, #0x1400                	// #5120
  404f48:	97fffa0f 	bl	403784 <isotp_fast_send>
    zassert_equal(ret, ISOTP_N_BUFFER_OVERFLW, "Expected overflow but got %d", ret);
  404f4c:	3100201f 	cmn	w0, #0x8
    ret = isotp_fast_send(&ctx, random_data, 5 * 1024, rx_node_id, NULL);
  404f50:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_BUFFER_OVERFLW, "Expected overflow but got %d", ret);
  404f54:	aa1b03e4 	mov	x4, x27
  404f58:	aa1a03e2 	mov	x2, x26
  404f5c:	f0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  404f60:	f0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  404f64:	913680a5 	add	x5, x5, #0xda0
  404f68:	9136f421 	add	x1, x1, #0xdbd
  404f6c:	1a9f17e0 	cset	w0, eq  // eq = none
  404f70:	528055c3 	mov	w3, #0x2ae                 	// #686
  404f74:	97fffb13 	bl	403bc0 <z_zassert.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  404f78:	52802040 	mov	w0, #0x102                 	// #258
  404f7c:	72a31b40 	movk	w0, #0x18da, lsl #16
  404f80:	97fffb80 	bl	403d80 <add_rx_msgq.constprop.0>
  404f84:	b90002e0 	str	w0, [x23]
	z_impl_k_sem_reset(sem);
  404f88:	aa1603e0 	mov	x0, x22
  404f8c:	94002a43 	bl	40f898 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  404f90:	928000e4 	mov	x4, #0xfffffffffffffff8    	// #-8
  404f94:	52800023 	mov	w3, #0x1                   	// #1
  404f98:	d2802202 	mov	x2, #0x110                 	// #272
  404f9c:	aa1303e1 	mov	x1, x19
  404fa0:	aa1403e0 	mov	x0, x20
  404fa4:	97fff9f8 	bl	403784 <isotp_fast_send>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  404fa8:	aa1503e0 	mov	x0, x21
  404fac:	d2800021 	mov	x1, #0x1                   	// #1
  404fb0:	97fffefc 	bl	404ba0 <check_frame_series.constprop.0>
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_OVFLW);
  404fb4:	52800640 	mov	w0, #0x32                  	// #50
    send_frame_series(&fc_frame, 1, rx_addr);
  404fb8:	52804022 	mov	w2, #0x201                 	// #513
  404fbc:	72a31b42 	movk	w2, #0x18da, lsl #16
  404fc0:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_OVFLW);
  404fc4:	390303e0 	strb	w0, [sp, #192]
    send_frame_series(&fc_frame, 1, rx_addr);
  404fc8:	aa1903e0 	mov	x0, x25
  404fcc:	97fffba9 	bl	403e70 <send_frame_series>
	return z_impl_k_sem_take(sem, timeout);
  404fd0:	d2800281 	mov	x1, #0x14                  	// #20
  404fd4:	aa1603e0 	mov	x0, x22
  404fd8:	940029bf 	bl	40f6d4 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  404fdc:	7100001f 	cmp	w0, #0x0
  404fe0:	a9462fea 	ldp	x10, x11, [sp, #96]
  404fe4:	aa1b03e4 	mov	x4, x27
  404fe8:	aa1a03e2 	mov	x2, x26
  404fec:	1a9f17e0 	cset	w0, eq  // eq = none
  404ff0:	52805723 	mov	w3, #0x2b9                 	// #697
  404ff4:	aa0b03e5 	mov	x5, x11
  404ff8:	aa0a03e1 	mov	x1, x10
  404ffc:	97fffaf1 	bl	403bc0 <z_zassert.constprop.0>
	z_impl_k_sem_reset(sem);
  405000:	aa1603e0 	mov	x0, x22
  405004:	94002a25 	bl	40f898 <z_impl_k_sem_reset>
    ret = isotp_fast_send(&ctx, random_data, DATA_SEND_LENGTH, rx_node_id,
  405008:	928000c4 	mov	x4, #0xfffffffffffffff9    	// #-7
  40500c:	52800023 	mov	w3, #0x1                   	// #1
  405010:	d2802202 	mov	x2, #0x110                 	// #272
  405014:	aa1303e1 	mov	x1, x19
  405018:	aa1403e0 	mov	x0, x20
  40501c:	97fff9da 	bl	403784 <isotp_fast_send>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  405020:	aa1503e0 	mov	x0, x21
  405024:	d2800021 	mov	x1, #0x1                   	// #1
        send_frame_series(&fc_frame, 1, rx_addr);
  405028:	52804034 	mov	w20, #0x201                 	// #513
    check_frame_series(&ff_frame, 1, &frame_msgq);
  40502c:	97fffedd 	bl	404ba0 <check_frame_series.constprop.0>
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_WAIT);
  405030:	52800620 	mov	w0, #0x31                  	// #49
  405034:	52800173 	mov	w19, #0xb                   	// #11
        send_frame_series(&fc_frame, 1, rx_addr);
  405038:	72a31b54 	movk	w20, #0x18da, lsl #16
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_WAIT);
  40503c:	390303e0 	strb	w0, [sp, #192]
        send_frame_series(&fc_frame, 1, rx_addr);
  405040:	2a1403e2 	mov	w2, w20
  405044:	aa1903e0 	mov	x0, x25
  405048:	d2800021 	mov	x1, #0x1                   	// #1
  40504c:	97fffb89 	bl	403e70 <send_frame_series>
    for (i = 0; i < CONFIG_ISOTP_WFTMAX + 1; i++) {
  405050:	71000673 	subs	w19, w19, #0x1
  405054:	54ffff61 	b.ne	405040 <_isotp_fast_conformance_async_fd_test_sender_fc_errors_wrapper+0x288>  // b.any
	return z_impl_k_sem_take(sem, timeout);
  405058:	f947fb00 	ldr	x0, [x24, #4080]
  40505c:	d2800281 	mov	x1, #0x14                  	// #20
  405060:	9400299d 	bl	40f6d4 <z_impl_k_sem_take>
    zassert_equal(ret, 0, "Send complete callback not called");
  405064:	7100001f 	cmp	w0, #0x0
  405068:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  40506c:	9103b404 	add	x4, x0, #0xed
  405070:	d0000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  405074:	911f0c02 	add	x2, x0, #0x7c3
  405078:	d0000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  40507c:	9135fb85 	add	x5, x28, #0xd7e
  405080:	91227801 	add	x1, x0, #0x89e
  405084:	528058e3 	mov	w3, #0x2c7                 	// #711
  405088:	1a9f17e0 	cset	w0, eq  // eq = none
  40508c:	97fffacd 	bl	403bc0 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_sender_fc_errors)
  405090:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405094:	f9476800 	ldr	x0, [x0, #3792]
  405098:	f94087e2 	ldr	x2, [sp, #264]
  40509c:	f9400001 	ldr	x1, [x0]
  4050a0:	eb010042 	subs	x2, x2, x1
  4050a4:	d2800001 	mov	x1, #0x0                   	// #0
  4050a8:	54000040 	b.eq	4050b0 <_isotp_fast_conformance_async_fd_test_sender_fc_errors_wrapper+0x2f8>  // b.none
  4050ac:	97fff09d 	bl	401320 <__stack_chk_fail@plt>
  4050b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4050b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4050b8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4050bc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4050c0:	a94573fb 	ldp	x27, x28, [sp, #80]
  4050c4:	a8d17bfd 	ldp	x29, x30, [sp], #272
  4050c8:	d65f03c0 	ret

00000000004050cc <_isotp_fast_conformance_async_fd_test_receive_data_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data)
  4050cc:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  4050d0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4050d4:	910003fd 	mov	x29, sp
  4050d8:	f9476800 	ldr	x0, [x0, #3792]
  4050dc:	f9400001 	ldr	x1, [x0]
  4050e0:	f90057e1 	str	x1, [sp, #168]
  4050e4:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  4050e8:	52820220 	mov	w0, #0x1011                	// #4113
  4050ec:	7900c3e0 	strh	w0, [sp, #96]
  4050f0:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4050f4:	9109d000 	add	x0, x0, #0x274
  4050f8:	91018be1 	add	x1, sp, #0x62
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  4050fc:	39006bff 	strb	wzr, [sp, #26]
  405100:	ad400400 	ldp	q0, q1, [x0]
  405104:	ad000420 	stp	q0, q1, [x1]
  405108:	3dc00800 	ldr	q0, [x0, #32]
  40510c:	3d800820 	str	q0, [x1, #32]
  405110:	3cc2e000 	ldur	q0, [x0, #46]
    ff_frame.length = CAN_DL;
  405114:	52800800 	mov	w0, #0x40                  	// #64
  405118:	3c82e020 	stur	q0, [x1, #46]
  40511c:	390283e0 	strb	w0, [sp, #160]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  405120:	52810600 	mov	w0, #0x830                 	// #2096
  405124:	790033e0 	strh	w0, [sp, #24]
    fc_frame.length = DATA_SIZE_FC;
  405128:	52800060 	mov	w0, #0x3                   	// #3
  40512c:	390163e0 	strb	w0, [sp, #88]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  405130:	d2801a40 	mov	x0, #0xd2                  	// #210
  405134:	97fffa85 	bl	403b48 <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405138:	52802040 	mov	w0, #0x102                 	// #258
  40513c:	72a31b40 	movk	w0, #0x18da, lsl #16
  405140:	97fffb10 	bl	403d80 <add_rx_msgq.constprop.0>
  405144:	d0000121 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
    send_frame_series(&ff_frame, 1, rx_addr);
  405148:	52804022 	mov	w2, #0x201                 	// #513
  40514c:	72a31b42 	movk	w2, #0x18da, lsl #16
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405150:	f947b421 	ldr	x1, [x1, #3944]
  405154:	b9000020 	str	w0, [x1]
    send_frame_series(&ff_frame, 1, rx_addr);
  405158:	910183e0 	add	x0, sp, #0x60
  40515c:	d2800021 	mov	x1, #0x1                   	// #1
  405160:	97fffb44 	bl	403e70 <send_frame_series>
    check_frame_series(&fc_frame, 1, &frame_msgq);
  405164:	910063e0 	add	x0, sp, #0x18
  405168:	d2800021 	mov	x1, #0x1                   	// #1
  40516c:	97fffe8d 	bl	404ba0 <check_frame_series.constprop.0>
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  405170:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405174:	52804022 	mov	w2, #0x201                 	// #513
  405178:	72a31b42 	movk	w2, #0x18da, lsl #16
  40517c:	d2800081 	mov	x1, #0x4                   	// #4
  405180:	f947bc00 	ldr	x0, [x0, #3960]
  405184:	97fffb3b 	bl	403e70 <send_frame_series>
    receive_test_data(&ctx, random_data, DATA_SEND_LENGTH, 0);
  405188:	97fffd50 	bl	4046c8 <receive_test_data.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data)
  40518c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405190:	f9476800 	ldr	x0, [x0, #3792]
  405194:	f94057e2 	ldr	x2, [sp, #168]
  405198:	f9400001 	ldr	x1, [x0]
  40519c:	eb010042 	subs	x2, x2, x1
  4051a0:	d2800001 	mov	x1, #0x0                   	// #0
  4051a4:	54000040 	b.eq	4051ac <_isotp_fast_conformance_async_fd_test_receive_data_wrapper+0xe0>  // b.none
  4051a8:	97fff05e 	bl	401320 <__stack_chk_fail@plt>
  4051ac:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  4051b0:	d65f03c0 	ret

00000000004051b4 <_isotp_fast_conformance_async_fd_test_receiver_fc_errors_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  4051b4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  4051b8:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4051bc:	910003fd 	mov	x29, sp
  4051c0:	f9476800 	ldr	x0, [x0, #3792]
  4051c4:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4051c8:	f0000074 	adrp	x20, 414000 <__func__.1+0xd>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  4051cc:	f9400001 	ldr	x1, [x0]
  4051d0:	f9007fe1 	str	x1, [sp, #248]
  4051d4:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  4051d8:	52820220 	mov	w0, #0x1011                	// #4113
  4051dc:	790053e0 	strh	w0, [sp, #40]
  4051e0:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4051e4:	9109d000 	add	x0, x0, #0x274
  4051e8:	9100abe1 	add	x1, sp, #0x2a
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  4051ec:	3901cbff 	strb	wzr, [sp, #114]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4051f0:	9104ee94 	add	x20, x20, #0x13b
  4051f4:	d0000073 	adrp	x19, 413000 <z_timer_expiration_handler+0x68>
  4051f8:	911f0e73 	add	x19, x19, #0x7c3
  4051fc:	ad400400 	ldp	q0, q1, [x0]
  405200:	ad000420 	stp	q0, q1, [x1]
  405204:	3dc00800 	ldr	q0, [x0, #32]
  405208:	3d800820 	str	q0, [x1, #32]
  40520c:	3cc2e000 	ldur	q0, [x0, #46]
    ff_frame.length = DATA_SIZE_FF + 2;
  405210:	52800800 	mov	w0, #0x40                  	// #64
  405214:	3c82e020 	stur	q0, [x1, #46]
  405218:	3901a3e0 	strb	w0, [sp, #104]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  40521c:	52810600 	mov	w0, #0x830                 	// #2096
  405220:	7900e3e0 	strh	w0, [sp, #112]
    fc_frame.length = DATA_SIZE_FC;
  405224:	52800060 	mov	w0, #0x3                   	// #3
  405228:	3902c3e0 	strb	w0, [sp, #176]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  40522c:	52802040 	mov	w0, #0x102                 	// #258
  405230:	72a31b40 	movk	w0, #0x18da, lsl #16
  405234:	97fffad3 	bl	403d80 <add_rx_msgq.constprop.0>
  405238:	2a0003e6 	mov	w6, w0
  40523c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405240:	aa1403e4 	mov	x4, x20
  405244:	52804ea3 	mov	w3, #0x275                 	// #629
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405248:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40524c:	aa1303e2 	mov	x2, x19
  405250:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405254:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  405258:	912370a5 	add	x5, x5, #0x8dc
  40525c:	9123e021 	add	x1, x1, #0x8f8
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405260:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405264:	2a2603e0 	mvn	w0, w6
  405268:	531f7c00 	lsr	w0, w0, #31
  40526c:	97fffa55 	bl	403bc0 <z_zassert.constprop.0>
    send_frame_series(&ff_frame, 1, rx_addr);
  405270:	52804022 	mov	w2, #0x201                 	// #513
  405274:	9100a3e0 	add	x0, sp, #0x28
  405278:	72a31b42 	movk	w2, #0x18da, lsl #16
  40527c:	d2800021 	mov	x1, #0x1                   	// #1
  405280:	97fffafc 	bl	403e70 <send_frame_series>
    check_frame_series(&fc_frame, 1, &frame_msgq);
  405284:	9101c3e0 	add	x0, sp, #0x70
  405288:	d2800021 	mov	x1, #0x1                   	// #1
  40528c:	97fffe45 	bl	404ba0 <check_frame_series.constprop.0>
    ret = blocking_recv(tiny_buf, sizeof(tiny_buf), K_MSEC(200));
  405290:	d2800282 	mov	x2, #0x14                  	// #20
  405294:	d2800801 	mov	x1, #0x40                  	// #64
  405298:	9102e3e0 	add	x0, sp, #0xb8
  40529c:	97fff9bd 	bl	403990 <blocking_recv>
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  4052a0:	7100f81f 	cmp	w0, #0x3e
  4052a4:	aa1403e4 	mov	x4, x20
  4052a8:	aa1303e2 	mov	x2, x19
  4052ac:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  4052b0:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  4052b4:	9124d8a5 	add	x5, x5, #0x936
  4052b8:	91256421 	add	x1, x1, #0x959
  4052bc:	52805043 	mov	w3, #0x282                 	// #642
    ret = blocking_recv(tiny_buf, sizeof(tiny_buf), K_MSEC(200));
  4052c0:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, DATA_SIZE_FF, "Expected FF data length but got %d", ret);
  4052c4:	1a9f17e0 	cset	w0, eq  // eq = none
  4052c8:	97fffa3e 	bl	403bc0 <z_zassert.constprop.0>
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), random_data + DATA_SIZE_FF,
  4052cc:	d2807840 	mov	x0, #0x3c2                 	// #962
  4052d0:	97fffa1e 	bl	403b48 <prepare_cf_frames.constprop.0>
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  4052d4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4052d8:	52800461 	mov	w1, #0x23                  	// #35
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  4052dc:	52804022 	mov	w2, #0x201                 	// #513
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  4052e0:	f947bc00 	ldr	x0, [x0, #3960]
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  4052e4:	72a31b42 	movk	w2, #0x18da, lsl #16
    des_frames[1].data[0] = CF_PCI_BYTE_1 | (3 & 0x0F);
  4052e8:	39010401 	strb	w1, [x0, #65]
    send_frame_series(des_frames, ARRAY_SIZE(des_frames), rx_addr);
  4052ec:	d2800081 	mov	x1, #0x4                   	// #4
  4052f0:	97fffae0 	bl	403e70 <send_frame_series>
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  4052f4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4052f8:	d2800282 	mov	x2, #0x14                  	// #20
  4052fc:	d2801001 	mov	x1, #0x80                  	// #128
  405300:	f9471000 	ldr	x0, [x0, #3616]
  405304:	97fff9a3 	bl	403990 <blocking_recv>
    zassert_equal(ret, ISOTP_N_WRONG_SN, "Expected wrong SN but got %d", ret);
  405308:	3100101f 	cmn	w0, #0x4
    ret = blocking_recv(data_buf, sizeof(data_buf), K_MSEC(200));
  40530c:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, ISOTP_N_WRONG_SN, "Expected wrong SN but got %d", ret);
  405310:	aa1303e2 	mov	x2, x19
  405314:	1a9f17e0 	cset	w0, eq  // eq = none
  405318:	aa1403e4 	mov	x4, x20
  40531c:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405320:	52805163 	mov	w3, #0x28b                 	// #651
  405324:	91379ca5 	add	x5, x5, #0xde7
  405328:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  40532c:	91381021 	add	x1, x1, #0xe04
  405330:	97fffa24 	bl	403bc0 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receiver_fc_errors)
  405334:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405338:	f9476800 	ldr	x0, [x0, #3792]
  40533c:	f9407fe2 	ldr	x2, [sp, #248]
  405340:	f9400001 	ldr	x1, [x0]
  405344:	eb010042 	subs	x2, x2, x1
  405348:	d2800001 	mov	x1, #0x0                   	// #0
  40534c:	54000040 	b.eq	405354 <_isotp_fast_conformance_async_fd_test_receiver_fc_errors_wrapper+0x1a0>  // b.none
  405350:	97ffeff4 	bl	401320 <__stack_chk_fail@plt>
  405354:	a94153f3 	ldp	x19, x20, [sp, #16]
  405358:	a8d07bfd 	ldp	x29, x30, [sp], #256
  40535c:	d65f03c0 	ret

0000000000405360 <_isotp_fast_conformance_async_fd_test_send_data_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data)
  405360:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  405364:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405368:	910003fd 	mov	x29, sp
  40536c:	f9476800 	ldr	x0, [x0, #3792]
  405370:	f9400001 	ldr	x1, [x0]
  405374:	f90057e1 	str	x1, [sp, #168]
  405378:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  40537c:	52820220 	mov	w0, #0x1011                	// #4113
  405380:	7900c3e0 	strh	w0, [sp, #96]
  405384:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  405388:	9109d000 	add	x0, x0, #0x274
  40538c:	91018be1 	add	x1, sp, #0x62
    fc_frame.data[2] = FC_PCI_BYTE_3(0);
  405390:	39006bff 	strb	wzr, [sp, #26]
  405394:	ad400400 	ldp	q0, q1, [x0]
  405398:	ad000420 	stp	q0, q1, [x1]
  40539c:	3dc00800 	ldr	q0, [x0, #32]
  4053a0:	3d800820 	str	q0, [x1, #32]
  4053a4:	3cc2e000 	ldur	q0, [x0, #46]
    ff_frame.length = CAN_DL;
  4053a8:	52800800 	mov	w0, #0x40                  	// #64
  4053ac:	3c82e020 	stur	q0, [x1, #46]
  4053b0:	390283e0 	strb	w0, [sp, #160]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  4053b4:	52800600 	mov	w0, #0x30                  	// #48
  4053b8:	790033e0 	strh	w0, [sp, #24]
    fc_frame.length = DATA_SIZE_FC;
  4053bc:	52800060 	mov	w0, #0x3                   	// #3
  4053c0:	390163e0 	strb	w0, [sp, #88]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  4053c4:	d2801a40 	mov	x0, #0xd2                  	// #210
  4053c8:	97fff9e0 	bl	403b48 <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4053cc:	52802040 	mov	w0, #0x102                 	// #258
  4053d0:	72a31b40 	movk	w0, #0x18da, lsl #16
  4053d4:	97fffa6b 	bl	403d80 <add_rx_msgq.constprop.0>
  4053d8:	2a0003e6 	mov	w6, w0
  4053dc:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4053e0:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  4053e4:	f0000064 	adrp	x4, 414000 <__func__.1+0xd>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4053e8:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4053ec:	912370a5 	add	x5, x5, #0x8dc
  4053f0:	91004084 	add	x4, x4, #0x10
  4053f4:	d0000062 	adrp	x2, 413000 <z_timer_expiration_handler+0x68>
  4053f8:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  4053fc:	911f0c42 	add	x2, x2, #0x7c3
  405400:	9123e021 	add	x1, x1, #0x8f8
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405404:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405408:	2a2603e0 	mvn	w0, w6
  40540c:	528027c3 	mov	w3, #0x13e                 	// #318
  405410:	531f7c00 	lsr	w0, w0, #31
  405414:	97fff9eb 	bl	403bc0 <z_zassert.constprop.0>
    send_test_data(random_data, DATA_SEND_LENGTH);
  405418:	d2802200 	mov	x0, #0x110                 	// #272
  40541c:	97fffa41 	bl	403d20 <send_test_data.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  405420:	910183e0 	add	x0, sp, #0x60
  405424:	d2800021 	mov	x1, #0x1                   	// #1
  405428:	97fffdde 	bl	404ba0 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, rx_addr);
  40542c:	52804022 	mov	w2, #0x201                 	// #513
  405430:	910063e0 	add	x0, sp, #0x18
  405434:	72a31b42 	movk	w2, #0x18da, lsl #16
  405438:	d2800021 	mov	x1, #0x1                   	// #1
  40543c:	97fffa8d 	bl	403e70 <send_frame_series>
    check_frame_series(des_frames, ARRAY_SIZE(des_frames), &frame_msgq);
  405440:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405444:	d2800081 	mov	x1, #0x4                   	// #4
  405448:	f947bc00 	ldr	x0, [x0, #3960]
  40544c:	97fffdd5 	bl	404ba0 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_data)
  405450:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405454:	f9476800 	ldr	x0, [x0, #3792]
  405458:	f94057e2 	ldr	x2, [sp, #168]
  40545c:	f9400001 	ldr	x1, [x0]
  405460:	eb010042 	subs	x2, x2, x1
  405464:	d2800001 	mov	x1, #0x0                   	// #0
  405468:	54000040 	b.eq	405470 <_isotp_fast_conformance_async_fd_test_send_data_wrapper+0x110>  // b.none
  40546c:	97ffefad 	bl	401320 <__stack_chk_fail@plt>
  405470:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  405474:	d65f03c0 	ret

0000000000405478 <_isotp_fast_conformance_async_fd_test_send_sf_fixed_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  405478:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40547c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405480:	910003fd 	mov	x29, sp
  405484:	f9476800 	ldr	x0, [x0, #3792]
  405488:	a90153f3 	stp	x19, x20, [sp, #16]
  40548c:	f0000073 	adrp	x19, 414000 <__func__.1+0xd>
  405490:	9109d273 	add	x19, x19, #0x274
  405494:	f90013f5 	str	x21, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405498:	d0000074 	adrp	x20, 413000 <z_timer_expiration_handler+0x68>
  40549c:	f0000075 	adrp	x21, 414000 <__func__.1+0xd>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  4054a0:	f9400001 	ldr	x1, [x0]
  4054a4:	f9003fe1 	str	x1, [sp, #120]
  4054a8:	d2800001 	mov	x1, #0x0                   	// #0
    des_frame.data[0] = (SF_PCI_TYPE << PCI_TYPE_POS);
  4054ac:	5287c000 	mov	w0, #0x3e00                	// #15872
  4054b0:	ad400660 	ldp	q0, q1, [x19]
  4054b4:	790063e0 	strh	w0, [sp, #48]
  4054b8:	9100cbe0 	add	x0, sp, #0x32
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4054bc:	911f0e94 	add	x20, x20, #0x7c3
  4054c0:	9100feb5 	add	x21, x21, #0x3f
  4054c4:	ad000400 	stp	q0, q1, [x0]
  4054c8:	3dc00a60 	ldr	q0, [x19, #32]
  4054cc:	3d800800 	str	q0, [x0, #32]
  4054d0:	3cc2e260 	ldur	q0, [x19, #46]
  4054d4:	3c82e000 	stur	q0, [x0, #46]
    des_frame.length = CAN_MAX_DLEN;
  4054d8:	52800800 	mov	w0, #0x40                  	// #64
  4054dc:	3901c3e0 	strb	w0, [sp, #112]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4054e0:	52802040 	mov	w0, #0x102                 	// #258
  4054e4:	72a31b40 	movk	w0, #0x18da, lsl #16
  4054e8:	97fffa26 	bl	403d80 <add_rx_msgq.constprop.0>
  4054ec:	2a0003e6 	mov	w6, w0
  4054f0:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4054f4:	aa1503e4 	mov	x4, x21
  4054f8:	aa1403e2 	mov	x2, x20
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  4054fc:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405500:	52802063 	mov	w3, #0x103                 	// #259
  405504:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405508:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  40550c:	912370a5 	add	x5, x5, #0x8dc
  405510:	9123e021 	add	x1, x1, #0x8f8
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405514:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405518:	2a2603e0 	mvn	w0, w6
  40551c:	531f7c00 	lsr	w0, w0, #31
  405520:	97fff9a8 	bl	403bc0 <z_zassert.constprop.0>
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  405524:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405528:	aa1303e1 	mov	x1, x19
  40552c:	d2800004 	mov	x4, #0x0                   	// #0
  405530:	52800023 	mov	w3, #0x1                   	// #1
  405534:	f9470c00 	ldr	x0, [x0, #3608]
  405538:	d28007c2 	mov	x2, #0x3e                  	// #62
  40553c:	97fff892 	bl	403784 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  405540:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, INT_TO_POINTER(ISOTP_N_OK));
  405544:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  405548:	aa1403e2 	mov	x2, x20
  40554c:	aa1503e4 	mov	x4, x21
  405550:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405554:	912234a5 	add	x5, x5, #0x88d
  405558:	528020c3 	mov	w3, #0x106                 	// #262
  40555c:	1a9f17e0 	cset	w0, eq  // eq = none
  405560:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  405564:	91227821 	add	x1, x1, #0x89e
  405568:	97fff996 	bl	403bc0 <z_zassert.constprop.0>
    check_frame_series(&des_frame, 1, &frame_msgq);
  40556c:	9100c3e0 	add	x0, sp, #0x30
  405570:	d2800021 	mov	x1, #0x1                   	// #1
  405574:	97fffd8b 	bl	404ba0 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf_fixed)
  405578:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40557c:	f9476800 	ldr	x0, [x0, #3792]
  405580:	f9403fe2 	ldr	x2, [sp, #120]
  405584:	f9400001 	ldr	x1, [x0]
  405588:	eb010042 	subs	x2, x2, x1
  40558c:	d2800001 	mov	x1, #0x0                   	// #0
  405590:	54000040 	b.eq	405598 <_isotp_fast_conformance_async_fd_test_send_sf_fixed_wrapper+0x120>  // b.none
  405594:	97ffef63 	bl	401320 <__stack_chk_fail@plt>
  405598:	a94153f3 	ldp	x19, x20, [sp, #16]
  40559c:	f94013f5 	ldr	x21, [sp, #32]
  4055a0:	a8c87bfd 	ldp	x29, x30, [sp], #128
  4055a4:	d65f03c0 	ret

00000000004055a8 <_isotp_fast_conformance_async_fd_test_send_sf_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf)
  4055a8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  4055ac:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4055b0:	910003fd 	mov	x29, sp
  4055b4:	f9476800 	ldr	x0, [x0, #3792]
  4055b8:	a90153f3 	stp	x19, x20, [sp, #16]
  4055bc:	f0000073 	adrp	x19, 414000 <__func__.1+0xd>
  4055c0:	9109d273 	add	x19, x19, #0x274
  4055c4:	f9400001 	ldr	x1, [x0]
  4055c8:	f90037e1 	str	x1, [sp, #104]
  4055cc:	d2800001 	mov	x1, #0x0                   	// #0
    des_frame.data[0] = (SF_PCI_TYPE << PCI_TYPE_POS);
  4055d0:	5287c000 	mov	w0, #0x3e00                	// #15872
  4055d4:	790043e0 	strh	w0, [sp, #32]
  4055d8:	91008be0 	add	x0, sp, #0x22
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4055dc:	d0000074 	adrp	x20, 413000 <z_timer_expiration_handler+0x68>
  4055e0:	ad400660 	ldp	q0, q1, [x19]
  4055e4:	911f0e94 	add	x20, x20, #0x7c3
  4055e8:	ad000400 	stp	q0, q1, [x0]
  4055ec:	3dc00a60 	ldr	q0, [x19, #32]
  4055f0:	3d800800 	str	q0, [x0, #32]
  4055f4:	3cc2e260 	ldur	q0, [x19, #46]
  4055f8:	3c82e000 	stur	q0, [x0, #46]
    des_frame.length = CAN_MAX_DLEN;
  4055fc:	52800800 	mov	w0, #0x40                  	// #64
  405600:	390183e0 	strb	w0, [sp, #96]
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405604:	52802040 	mov	w0, #0x102                 	// #258
  405608:	72a31b40 	movk	w0, #0x18da, lsl #16
  40560c:	97fff9dd 	bl	403d80 <add_rx_msgq.constprop.0>
  405610:	2a0003e6 	mov	w6, w0
  405614:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405618:	aa1403e2 	mov	x2, x20
  40561c:	52801aa3 	mov	w3, #0xd5                  	// #213
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405620:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405624:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405628:	f0000064 	adrp	x4, 414000 <__func__.1+0xd>
  40562c:	912370a5 	add	x5, x5, #0x8dc
  405630:	91030084 	add	x4, x4, #0xc0
  405634:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405638:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40563c:	2a2603e0 	mvn	w0, w6
  405640:	9123e021 	add	x1, x1, #0x8f8
  405644:	531f7c00 	lsr	w0, w0, #31
  405648:	97fff95e 	bl	403bc0 <z_zassert.constprop.0>
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, NULL);
  40564c:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405650:	aa1303e1 	mov	x1, x19
  405654:	d2800004 	mov	x4, #0x0                   	// #0
  405658:	52800023 	mov	w3, #0x1                   	// #1
  40565c:	f9470c00 	ldr	x0, [x0, #3608]
  405660:	d28007c2 	mov	x2, #0x3e                  	// #62
  405664:	97fff848 	bl	403784 <isotp_fast_send>
    zassert_equal(ret, 0, "Send returned %d", ret);
  405668:	7100001f 	cmp	w0, #0x0
    ret = isotp_fast_send(&ctx, random_data, DATA_SIZE_SF, rx_node_id, NULL);
  40566c:	2a0003e6 	mov	w6, w0
    zassert_equal(ret, 0, "Send returned %d", ret);
  405670:	aa1403e2 	mov	x2, x20
  405674:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405678:	f0000064 	adrp	x4, 414000 <__func__.1+0xd>
  40567c:	912234a5 	add	x5, x5, #0x88d
  405680:	9102b084 	add	x4, x4, #0xac
  405684:	52800663 	mov	w3, #0x33                  	// #51
  405688:	1a9f17e0 	cset	w0, eq  // eq = none
  40568c:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  405690:	91227821 	add	x1, x1, #0x89e
  405694:	97fff94b 	bl	403bc0 <z_zassert.constprop.0>
    check_frame_series(&des_frame, 1, &frame_msgq);
  405698:	910083e0 	add	x0, sp, #0x20
  40569c:	d2800021 	mov	x1, #0x1                   	// #1
  4056a0:	97fffd40 	bl	404ba0 <check_frame_series.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_send_sf)
  4056a4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4056a8:	f9476800 	ldr	x0, [x0, #3792]
  4056ac:	f94037e2 	ldr	x2, [sp, #104]
  4056b0:	f9400001 	ldr	x1, [x0]
  4056b4:	eb010042 	subs	x2, x2, x1
  4056b8:	d2800001 	mov	x1, #0x0                   	// #0
  4056bc:	54000040 	b.eq	4056c4 <_isotp_fast_conformance_async_fd_test_send_sf_wrapper+0x11c>  // b.none
  4056c0:	97ffef18 	bl	401320 <__stack_chk_fail@plt>
  4056c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4056c8:	a8c77bfd 	ldp	x29, x30, [sp], #112
  4056cc:	d65f03c0 	ret

00000000004056d0 <_isotp_fast_conformance_async_fd_test_stmin_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  4056d0:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  4056d4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4056d8:	910003fd 	mov	x29, sp
  4056dc:	f9476800 	ldr	x0, [x0, #3792]
  4056e0:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4056e4:	f0000074 	adrp	x20, 414000 <__func__.1+0xd>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  4056e8:	a9025bf5 	stp	x21, x22, [sp, #32]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4056ec:	9105ce94 	add	x20, x20, #0x173
  4056f0:	d0000073 	adrp	x19, 413000 <z_timer_expiration_handler+0x68>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  4056f4:	a90363f7 	stp	x23, x24, [sp, #48]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4056f8:	911f0e73 	add	x19, x19, #0x7c3
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  4056fc:	a9046bf9 	stp	x25, x26, [sp, #64]
  405700:	a90573fb 	stp	x27, x28, [sp, #80]
    send_frame_series(&fc_frame, 1, tx_addr);
  405704:	910183fb 	add	x27, sp, #0x60
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  405708:	f9400001 	ldr	x1, [x0]
  40570c:	f9009fe1 	str	x1, [sp, #312]
  405710:	d2800001 	mov	x1, #0x0                   	// #0
        ztest_test_skip();
  405714:	94001718 	bl	40b374 <ztest_test_skip>
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SIZE_FF + DATA_SIZE_CF * 4);
  405718:	52874220 	mov	w0, #0x3a11                	// #14865
  40571c:	790153e0 	strh	w0, [sp, #168]
  405720:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  405724:	9109d000 	add	x0, x0, #0x274
  405728:	9102abe1 	add	x1, sp, #0xaa
  40572c:	ad400400 	ldp	q0, q1, [x0]
  405730:	ad000420 	stp	q0, q1, [x1]
  405734:	3dc00800 	ldr	q0, [x0, #32]
  405738:	3d800820 	str	q0, [x1, #32]
  40573c:	3cc2e000 	ldur	q0, [x0, #46]
    ff_frame.length = DATA_SIZE_FF + 2;
  405740:	52800800 	mov	w0, #0x40                  	// #64
  405744:	3c82e020 	stur	q0, [x1, #46]
  405748:	3903a3e0 	strb	w0, [sp, #232]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  40574c:	52804600 	mov	w0, #0x230                 	// #560
  405750:	7900c3e0 	strh	w0, [sp, #96]
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_1);
  405754:	528000a0 	mov	w0, #0x5                   	// #5
  405758:	39018be0 	strb	w0, [sp, #98]
    fc_frame.length = DATA_SIZE_FC;
  40575c:	52800060 	mov	w0, #0x3                   	// #3
  405760:	390283e0 	strb	w0, [sp, #160]
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  405764:	52804020 	mov	w0, #0x201                 	// #513
  405768:	72a31b40 	movk	w0, #0x18da, lsl #16
  40576c:	97fff985 	bl	403d80 <add_rx_msgq.constprop.0>
  405770:	2a0003e6 	mov	w6, w0
  405774:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405778:	aa1403e4 	mov	x4, x20
  40577c:	aa1303e2 	mov	x2, x19
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  405780:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405784:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405788:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  40578c:	912370a5 	add	x5, x5, #0x8dc
  405790:	9123e021 	add	x1, x1, #0x8f8
  405794:	528048a3 	mov	w3, #0x245                 	// #581
    filter_id = add_rx_msgq(rx_addr, CAN_EXT_ID_MASK);
  405798:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  40579c:	2a2603e0 	mvn	w0, w6
  4057a0:	531f7c00 	lsr	w0, w0, #31
  4057a4:	97fff907 	bl	403bc0 <z_zassert.constprop.0>
    send_test_data(random_data, DATA_SIZE_FF + DATA_SIZE_CF * 4);
  4057a8:	d2802740 	mov	x0, #0x13a                 	// #314
  4057ac:	97fff95d 	bl	403d20 <send_test_data.constprop.0>
    check_frame_series(&ff_frame, 1, &frame_msgq);
  4057b0:	9102a3e0 	add	x0, sp, #0xa8
  4057b4:	d2800021 	mov	x1, #0x1                   	// #1
  4057b8:	97fffcfa 	bl	404ba0 <check_frame_series.constprop.0>
    send_frame_series(&fc_frame, 1, tx_addr);
  4057bc:	52802042 	mov	w2, #0x102                 	// #258
  4057c0:	aa1b03e0 	mov	x0, x27
  4057c4:	72a31b42 	movk	w2, #0x18da, lsl #16
  4057c8:	d2800021 	mov	x1, #0x1                   	// #1
  4057cc:	97fff9a9 	bl	403e70 <send_frame_series>
	return z_impl_k_msgq_get(msgq, data, timeout);
  4057d0:	d0000136 	adrp	x22, 42b000 <__FRAME_END__+0x1007c>
  4057d4:	9103c3f7 	add	x23, sp, #0xf0
  4057d8:	aa1703e1 	mov	x1, x23
  4057dc:	d2800142 	mov	x2, #0xa                   	// #10
  4057e0:	f947e2d6 	ldr	x22, [x22, #4032]
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  4057e4:	d000007a 	adrp	x26, 413000 <z_timer_expiration_handler+0x68>
  4057e8:	d0000075 	adrp	x21, 413000 <z_timer_expiration_handler+0x68>
  4057ec:	9138a35a 	add	x26, x26, #0xe28
  4057f0:	aa1603e0 	mov	x0, x22
  4057f4:	91227ab5 	add	x21, x21, #0x89e
  4057f8:	94002467 	bl	40e994 <z_impl_k_msgq_get>
  4057fc:	7100001f 	cmp	w0, #0x0
  405800:	2a0003e6 	mov	w6, w0
  405804:	aa1a03e5 	mov	x5, x26
  405808:	aa1403e4 	mov	x4, x20
  40580c:	aa1303e2 	mov	x2, x19
  405810:	aa1503e1 	mov	x1, x21
  405814:	528049c3 	mov	w3, #0x24e                 	// #590
  405818:	1a9f17e0 	cset	w0, eq  // eq = none
  40581c:	97fff8e9 	bl	403bc0 <z_zassert.constprop.0>
  405820:	97fff8a8 	bl	403ac0 <k_uptime_get>
  405824:	aa0003fc 	mov	x28, x0
  405828:	aa1703e1 	mov	x1, x23
  40582c:	d2800022 	mov	x2, #0x1                   	// #1
  405830:	aa1603e0 	mov	x0, x22
  405834:	94002458 	bl	40e994 <z_impl_k_msgq_get>
  405838:	2a0003f8 	mov	w24, w0
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  40583c:	d0000079 	adrp	x25, 413000 <z_timer_expiration_handler+0x68>
  405840:	97fff8a0 	bl	403ac0 <k_uptime_get>
  405844:	91392339 	add	x25, x25, #0xe48
  405848:	7100031f 	cmp	w24, #0x0
  40584c:	2a1803e7 	mov	w7, w24
    time_diff = k_uptime_get_32() - start_time;
  405850:	4b1c001c 	sub	w28, w0, w28
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  405854:	aa1903e5 	mov	x5, x25
  405858:	aa1403e4 	mov	x4, x20
  40585c:	aa1303e2 	mov	x2, x19
  405860:	aa1503e1 	mov	x1, x21
  405864:	1a9f17e0 	cset	w0, eq  // eq = none
  405868:	52800146 	mov	w6, #0xa                   	// #10
  40586c:	52804a63 	mov	w3, #0x253                 	// #595
  405870:	97fff8d4 	bl	403bc0 <z_zassert.constprop.0>
    zassert_true(time_diff >= STMIN_VAL_1, "STmin too short (%dms)", time_diff);
  405874:	d0000078 	adrp	x24, 413000 <z_timer_expiration_handler+0x68>
  405878:	7100139f 	cmp	w28, #0x4
  40587c:	9139d318 	add	x24, x24, #0xe74
  405880:	2a1c03e6 	mov	w6, w28
  405884:	aa1803e5 	mov	x5, x24
  405888:	aa1403e4 	mov	x4, x20
  40588c:	aa1303e2 	mov	x2, x19
  405890:	1a9f97e0 	cset	w0, hi  // hi = pmore
  405894:	52804aa3 	mov	w3, #0x255                 	// #597
  405898:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  40589c:	913a2c21 	add	x1, x1, #0xe8b
  4058a0:	97fff8c8 	bl	403bc0 <z_zassert.constprop.0>
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_2);
  4058a4:	52800640 	mov	w0, #0x32                  	// #50
    send_frame_series(&fc_frame, 1, tx_addr);
  4058a8:	52802042 	mov	w2, #0x102                 	// #258
  4058ac:	72a31b42 	movk	w2, #0x18da, lsl #16
  4058b0:	d2800021 	mov	x1, #0x1                   	// #1
    fc_frame.data[2] = FC_PCI_BYTE_3(STMIN_VAL_2);
  4058b4:	39018be0 	strb	w0, [sp, #98]
    send_frame_series(&fc_frame, 1, tx_addr);
  4058b8:	aa1b03e0 	mov	x0, x27
  4058bc:	97fff96d 	bl	403e70 <send_frame_series>
  4058c0:	d2800142 	mov	x2, #0xa                   	// #10
  4058c4:	aa1703e1 	mov	x1, x23
  4058c8:	aa1603e0 	mov	x0, x22
  4058cc:	94002432 	bl	40e994 <z_impl_k_msgq_get>
    zassert_equal(ret, 0, "Expected to get a message. [%d]", ret);
  4058d0:	7100001f 	cmp	w0, #0x0
  4058d4:	2a0003e6 	mov	w6, w0
  4058d8:	aa1a03e5 	mov	x5, x26
  4058dc:	aa1403e4 	mov	x4, x20
  4058e0:	aa1303e2 	mov	x2, x19
  4058e4:	aa1503e1 	mov	x1, x21
  4058e8:	52804b63 	mov	w3, #0x25b                 	// #603
  4058ec:	1a9f17e0 	cset	w0, eq  // eq = none
  4058f0:	97fff8b4 	bl	403bc0 <z_zassert.constprop.0>
  4058f4:	97fff873 	bl	403ac0 <k_uptime_get>
  4058f8:	aa0003fa 	mov	x26, x0
  4058fc:	aa1703e1 	mov	x1, x23
  405900:	d28000c2 	mov	x2, #0x6                   	// #6
  405904:	aa1603e0 	mov	x0, x22
  405908:	94002423 	bl	40e994 <z_impl_k_msgq_get>
  40590c:	2a0003f7 	mov	w23, w0
  405910:	97fff86c 	bl	403ac0 <k_uptime_get>
    time_diff = k_uptime_get_32() - start_time;
  405914:	4b1a001a 	sub	w26, w0, w26
    zassert_equal(ret, 0, "Expected to get a message within %dms. [%d]",
  405918:	710002ff 	cmp	w23, #0x0
  40591c:	2a1703e7 	mov	w7, w23
  405920:	aa1903e5 	mov	x5, x25
  405924:	aa1403e4 	mov	x4, x20
  405928:	aa1303e2 	mov	x2, x19
  40592c:	aa1503e1 	mov	x1, x21
  405930:	1a9f17e0 	cset	w0, eq  // eq = none
  405934:	528006e6 	mov	w6, #0x37                  	// #55
  405938:	52804c03 	mov	w3, #0x260                 	// #608
  40593c:	97fff8a1 	bl	403bc0 <z_zassert.constprop.0>
    zassert_true(time_diff >= STMIN_VAL_2, "STmin too short (%dms)", time_diff);
  405940:	7100c75f 	cmp	w26, #0x31
  405944:	aa1303e2 	mov	x2, x19
  405948:	1a9f97e0 	cset	w0, hi  // hi = pmore
  40594c:	2a1a03e6 	mov	w6, w26
  405950:	aa1803e5 	mov	x5, x24
  405954:	aa1403e4 	mov	x4, x20
  405958:	52804c43 	mov	w3, #0x262                 	// #610
  40595c:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  405960:	913abc21 	add	x1, x1, #0xeaf
  405964:	97fff897 	bl	403bc0 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_stmin)
  405968:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40596c:	f9476800 	ldr	x0, [x0, #3792]
  405970:	f9409fe2 	ldr	x2, [sp, #312]
  405974:	f9400001 	ldr	x1, [x0]
  405978:	eb010042 	subs	x2, x2, x1
  40597c:	d2800001 	mov	x1, #0x0                   	// #0
  405980:	54000040 	b.eq	405988 <_isotp_fast_conformance_async_fd_test_stmin_wrapper+0x2b8>  // b.none
  405984:	97ffee67 	bl	401320 <__stack_chk_fail@plt>
  405988:	a94153f3 	ldp	x19, x20, [sp, #16]
  40598c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  405990:	a94363f7 	ldp	x23, x24, [sp, #48]
  405994:	a9446bf9 	ldp	x25, x26, [sp, #64]
  405998:	a94573fb 	ldp	x27, x28, [sp, #80]
  40599c:	a8d47bfd 	ldp	x29, x30, [sp], #320
  4059a0:	d65f03c0 	ret

00000000004059a4 <_isotp_fast_conformance_async_fd_test_receive_data_blocks_wrapper>:
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  4059a4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  4059a8:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4059ac:	910003fd 	mov	x29, sp
  4059b0:	f9476800 	ldr	x0, [x0, #3792]
  4059b4:	a90153f3 	stp	x19, x20, [sp, #16]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4059b8:	f0000074 	adrp	x20, 414000 <__func__.1+0xd>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  4059bc:	f9400001 	ldr	x1, [x0]
  4059c0:	f9007fe1 	str	x1, [sp, #248]
  4059c4:	d2800001 	mov	x1, #0x0                   	// #0
    ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
  4059c8:	52820220 	mov	w0, #0x1011                	// #4113
  4059cc:	7900d3e0 	strh	w0, [sp, #104]
  4059d0:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4059d4:	9109d000 	add	x0, x0, #0x274
  4059d8:	9101abe1 	add	x1, sp, #0x6a
    fc_frame.data[2] = FC_PCI_BYTE_3(fc_opts.stmin);
  4059dc:	39008bff 	strb	wzr, [sp, #34]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  4059e0:	91081e94 	add	x20, x20, #0x207
  4059e4:	d0000073 	adrp	x19, 413000 <z_timer_expiration_handler+0x68>
  4059e8:	911f0e73 	add	x19, x19, #0x7c3
  4059ec:	ad400400 	ldp	q0, q1, [x0]
  4059f0:	ad000420 	stp	q0, q1, [x1]
  4059f4:	3dc00800 	ldr	q0, [x0, #32]
  4059f8:	3d800820 	str	q0, [x1, #32]
  4059fc:	3cc2e000 	ldur	q0, [x0, #46]
    ff_frame.length = DATA_SIZE_FF + 2;
  405a00:	52800800 	mov	w0, #0x40                  	// #64
  405a04:	3c82e020 	stur	q0, [x1, #46]
  405a08:	3902a3e0 	strb	w0, [sp, #168]
    fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
  405a0c:	52810600 	mov	w0, #0x830                 	// #2096
  405a10:	790043e0 	strh	w0, [sp, #32]
    fc_frame.length = DATA_SIZE_FC;
  405a14:	52800060 	mov	w0, #0x3                   	// #3
  405a18:	390183e0 	strb	w0, [sp, #96]
    prepare_cf_frames(des_frames, ARRAY_SIZE(des_frames), data_ptr, remaining_length);
  405a1c:	d2801a40 	mov	x0, #0xd2                  	// #210
  405a20:	97fff84a 	bl	403b48 <prepare_cf_frames.constprop.0>
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405a24:	52802040 	mov	w0, #0x102                 	// #258
  405a28:	72a31b40 	movk	w0, #0x18da, lsl #16
  405a2c:	97fff8d5 	bl	403d80 <add_rx_msgq.constprop.0>
  405a30:	2a0003e6 	mov	w6, w0
  405a34:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405a38:	aa1403e4 	mov	x4, x20
  405a3c:	52803863 	mov	w3, #0x1c3                 	// #451
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405a40:	f947b400 	ldr	x0, [x0, #3944]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405a44:	aa1303e2 	mov	x2, x19
  405a48:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405a4c:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  405a50:	912370a5 	add	x5, x5, #0x8dc
  405a54:	9123e021 	add	x1, x1, #0x8f8
    filter_id = add_rx_msgq(tx_addr, CAN_EXT_ID_MASK);
  405a58:	b9000006 	str	w6, [x0]
    zassert_true((filter_id >= 0), "Negative filter number [%d]", filter_id);
  405a5c:	2a2603e0 	mvn	w0, w6
  405a60:	531f7c00 	lsr	w0, w0, #31
  405a64:	97fff857 	bl	403bc0 <z_zassert.constprop.0>
    send_frame_series(&ff_frame, 1, rx_addr);
  405a68:	52804022 	mov	w2, #0x201                 	// #513
  405a6c:	9101a3e0 	add	x0, sp, #0x68
  405a70:	72a31b42 	movk	w2, #0x18da, lsl #16
  405a74:	d2800021 	mov	x1, #0x1                   	// #1
  405a78:	97fff8fe 	bl	403e70 <send_frame_series>
        check_frame_series(&fc_frame, 1, &frame_msgq);
  405a7c:	910083e0 	add	x0, sp, #0x20
  405a80:	d2800021 	mov	x1, #0x1                   	// #1
  405a84:	97fffc47 	bl	404ba0 <check_frame_series.constprop.0>
            send_frame_series(data_frame_ptr, remaining_frames, rx_addr);
  405a88:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405a8c:	52804022 	mov	w2, #0x201                 	// #513
  405a90:	72a31b42 	movk	w2, #0x18da, lsl #16
  405a94:	d2800081 	mov	x1, #0x4                   	// #4
  405a98:	f947bc00 	ldr	x0, [x0, #3960]
  405a9c:	97fff8f5 	bl	403e70 <send_frame_series>
    receive_test_data(&ctx, random_data, DATA_SEND_LENGTH, 0);
  405aa0:	97fffb0a 	bl	4046c8 <receive_test_data.constprop.0>
  405aa4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405aa8:	9102c3e1 	add	x1, sp, #0xb0
  405aac:	d28000a2 	mov	x2, #0x5                   	// #5
  405ab0:	f947e000 	ldr	x0, [x0, #4032]
  405ab4:	940023b8 	bl	40e994 <z_impl_k_msgq_get>
    zassert_equal(ret, -EAGAIN, "Expected timeout but got %d", ret);
  405ab8:	31002c1f 	cmn	w0, #0xb
  405abc:	2a0003e6 	mov	w6, w0
  405ac0:	aa1303e2 	mov	x2, x19
  405ac4:	1a9f17e0 	cset	w0, eq  // eq = none
  405ac8:	aa1403e4 	mov	x4, x20
  405acc:	d0000065 	adrp	x5, 413000 <z_timer_expiration_handler+0x68>
  405ad0:	52803b83 	mov	w3, #0x1dc                 	// #476
  405ad4:	9125e4a5 	add	x5, x5, #0x979
  405ad8:	d0000061 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  405adc:	912e0821 	add	x1, x1, #0xb82
  405ae0:	97fff838 	bl	403bc0 <z_zassert.constprop.0>
ZTEST(ISOTP_FAST_CONFORMANCE_TEST_SUITE, test_receive_data_blocks)
  405ae4:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405ae8:	f9476800 	ldr	x0, [x0, #3792]
  405aec:	f9407fe2 	ldr	x2, [sp, #248]
  405af0:	f9400001 	ldr	x1, [x0]
  405af4:	eb010042 	subs	x2, x2, x1
  405af8:	d2800001 	mov	x1, #0x0                   	// #0
  405afc:	54000040 	b.eq	405b04 <_isotp_fast_conformance_async_fd_test_receive_data_blocks_wrapper+0x160>  // b.none
  405b00:	97ffee08 	bl	401320 <__stack_chk_fail@plt>
  405b04:	a94153f3 	ldp	x19, x20, [sp, #16]
  405b08:	a8d07bfd 	ldp	x29, x30, [sp], #256
  405b0c:	d65f03c0 	ret

0000000000405b10 <cbvprintf_package>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
  405b10:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  405b14:	910003fd 	mov	x29, sp
  405b18:	a90153f3 	stp	x19, x20, [sp, #16]
  405b1c:	aa0003f4 	mov	x20, x0
  405b20:	d0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  405b24:	a9025bf5 	stp	x21, x22, [sp, #32]
  405b28:	aa0103f5 	mov	x21, x1
  405b2c:	f9476800 	ldr	x0, [x0, #3792]
  405b30:	a90363f7 	stp	x23, x24, [sp, #48]
  405b34:	a9046bf9 	stp	x25, x26, [sp, #64]
  405b38:	a90573fb 	stp	x27, x28, [sp, #80]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
	bool is_str_arg = false;
	union cbprintf_package_hdr *pkg_hdr = packaged;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
  405b3c:	f2400a9c 	ands	x28, x20, #0x7
{
  405b40:	f9400001 	ldr	x1, [x0]
  405b44:	f90067e1 	str	x1, [sp, #200]
  405b48:	d2800001 	mov	x1, #0x0                   	// #0
  405b4c:	121e0040 	and	w0, w2, #0x4
  405b50:	b90083e0 	str	w0, [sp, #128]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
  405b54:	d3431441 	ubfx	x1, x2, #3, #3
  405b58:	29436488 	ldp	w8, w25, [x4, #24]
  405b5c:	a940289b 	ldp	x27, x10, [x4]
  405b60:	f940088c 	ldr	x12, [x4, #16]
	if ((uintptr_t)packaged % sizeof(void *)) {
  405b64:	54003781 	b.ne	406254 <cbvprintf_package+0x744>  // b.any
  405b68:	aa0303fa 	mov	x26, x3
  405b6c:	11000421 	add	w1, w1, #0x1
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * multiple of pointer size for the above to preserve alignment.
	 *
	 * Refer to union cbprintf_package_hdr for more details.
	 */
	buf += sizeof(*pkg_hdr);
  405b70:	91002293 	add	x19, x20, #0x8
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
  405b74:	b5003754 	cbnz	x20, 40625c <cbvprintf_package+0x74c>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  405b78:	92400ab5 	and	x21, x21, #0x7
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  405b7c:	d2800100 	mov	x0, #0x8                   	// #8
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  405b80:	910022b3 	add	x19, x21, #0x8
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  405b84:	cb150015 	sub	x21, x0, x21
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
	align = VA_STACK_ALIGN(char *);
  405b88:	52800118 	mov	w24, #0x8                   	// #8
					align = VA_STACK_ALIGN(int);
					size = sizeof(int);
				}
				continue;
			}
			switch (*fmt) {
  405b8c:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  405b90:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  405b94:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  405b98:	d000006b 	adrp	x11, 413000 <z_timer_expiration_handler+0x68>
	s = fmt--;
  405b9c:	d1000749 	sub	x9, x26, #0x1
	size = sizeof(char *);
  405ba0:	2a1803f6 	mov	w22, w24
			switch (*fmt) {
  405ba4:	9116116b 	add	x11, x11, #0x584
  405ba8:	d0000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
	bool parsing = false;
  405bac:	52800017 	mov	w23, #0x0                   	// #0
			switch (*fmt) {
  405bb0:	9115c000 	add	x0, x0, #0x570
	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
  405bb4:	12800006 	mov	w6, #0xffffffff            	// #-1
	unsigned int s_ro_cnt = 0; /* number of ro strings */
  405bb8:	52800005 	mov	w5, #0x0                   	// #0
	unsigned int s_rw_cnt = 0; /* number of rw strings */
  405bbc:	52800004 	mov	w4, #0x0                   	// #0
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
  405bc0:	52800003 	mov	w3, #0x0                   	// #0
  405bc4:	d280002d 	mov	x13, #0x1                   	// #1
			switch (*fmt) {
  405bc8:	f2c0004e 	movk	x14, #0x2, lsl #32
  405bcc:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  405bd0:	f2e06012 	movk	x18, #0x300, lsl #48
  405bd4:	f90033e0 	str	x0, [sp, #96]

		/* copy va_list data over to our buffer */
		if (is_str_arg) {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
  405bd8:	b4000054 	cbz	x20, 405be0 <cbvprintf_package+0xd0>
				*(const char **)buf = s;
  405bdc:	f900027a 	str	x26, [x19]
			}

			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);

			if (is_ro && !do_ro) {
  405be0:	721f0050 	ands	w16, w2, #0x2
  405be4:	7a400824 	ccmp	w1, #0x0, #0x4, eq  // eq = none
  405be8:	54001aec 	b.gt	405f44 <cbvprintf_package+0x434>
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
  405bec:	cb140260 	sub	x0, x19, x20
  405bf0:	d342fc00 	lsr	x0, x0, #2
				 * In the do_ro case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
  405bf4:	7101fc1f 	cmp	w0, #0x7f
  405bf8:	7a408a04 	ccmp	w16, #0x0, #0x4, hi  // hi = pmore
  405bfc:	54001640 	b.eq	405ec4 <cbvprintf_package+0x3b4>  // b.none
					__ASSERT(false, "String with too many arguments");
  405c00:	f0000073 	adrp	x19, 414000 <__func__.1+0xd>
  405c04:	9119d273 	add	x19, x19, #0x674
  405c08:	aa1303e2 	mov	x2, x19
  405c0c:	b0000081 	adrp	x1, 416000 <__func__.0+0xc27>
  405c10:	911f5821 	add	x1, x1, #0x7d6
  405c14:	52804f63 	mov	w3, #0x27b                 	// #635
  405c18:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  405c1c:	911a8800 	add	x0, x0, #0x6a2
  405c20:	94000796 	bl	407a78 <assert_print>
  405c24:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  405c28:	911afc00 	add	x0, x0, #0x6bf
  405c2c:	94000793 	bl	407a78 <assert_print>
  405c30:	aa1303e0 	mov	x0, x19
  405c34:	52804f61 	mov	w1, #0x27b                 	// #635
  405c38:	940007ba 	bl	407b20 <assert_post_action>
  405c3c:	52804f62 	mov	w2, #0x27b                 	// #635
					return -EINVAL;
				}

				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
					__ASSERT(false, "str_ptr_pos[] too small");
  405c40:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  405c44:	aa1303e1 	mov	x1, x19
  405c48:	911b8000 	add	x0, x0, #0x6e0
  405c4c:	940011a7 	bl	40a2e8 <posix_print_error_and_exit>
			switch (*fmt) {
  405c50:	7101e91f 	cmp	w8, #0x7a
  405c54:	540000e8 	b.hi	405c70 <cbvprintf_package+0x160>  // b.pmore
  405c58:	71019d1f 	cmp	w8, #0x67
  405c5c:	54000208 	b.hi	405c9c <cbvprintf_package+0x18c>  // b.pmore
  405c60:	7100a91f 	cmp	w8, #0x2a
  405c64:	54000408 	b.hi	405ce4 <cbvprintf_package+0x1d4>  // b.pmore
  405c68:	71007d1f 	cmp	w8, #0x1f
  405c6c:	540002e8 	b.hi	405cc8 <cbvprintf_package+0x1b8>  // b.pmore
				parsing = false;
  405c70:	52800017 	mov	w23, #0x0                   	// #0
			if (*++fmt == '\0') {
  405c74:	38401d28 	ldrb	w8, [x9, #1]!
  405c78:	340022a8 	cbz	w8, 4060cc <cbvprintf_package+0x5bc>
			if (!parsing) {
  405c7c:	35fffeb7 	cbnz	w23, 405c50 <cbvprintf_package+0x140>
				if (*fmt == '%') {
  405c80:	7100951f 	cmp	w8, #0x25
  405c84:	54ffff81 	b.ne	405c74 <cbvprintf_package+0x164>  // b.any
					arg_idx++;
  405c88:	110004c6 	add	w6, w6, #0x1
					parsing = true;
  405c8c:	52800037 	mov	w23, #0x1                   	// #1
					align = VA_STACK_ALIGN(int);
  405c90:	52800118 	mov	w24, #0x8                   	// #8
					size = sizeof(int);
  405c94:	52800096 	mov	w22, #0x4                   	// #4
  405c98:	17fffff7 	b	405c74 <cbvprintf_package+0x164>
			switch (*fmt) {
  405c9c:	5101a108 	sub	w8, w8, #0x68
  405ca0:	7100491f 	cmp	w8, #0x12
  405ca4:	54fffe68 	b.hi	405c70 <cbvprintf_package+0x160>  // b.pmore
  405ca8:	f94033e7 	ldr	x7, [sp, #96]
  405cac:	386848e8 	ldrb	w8, [x7, w8, uxtw]
  405cb0:	10000070 	adr	x16, 405cbc <cbvprintf_package+0x1ac>
  405cb4:	8b288a08 	add	x8, x16, w8, sxtb #2
  405cb8:	d61f0100 	br	x8
  405cbc:	52800118 	mov	w24, #0x8                   	// #8
  405cc0:	2a1803f6 	mov	w22, w24
  405cc4:	17ffffec 	b	405c74 <cbvprintf_package+0x164>
  405cc8:	51008108 	sub	w8, w8, #0x20
  405ccc:	7100291f 	cmp	w8, #0xa
  405cd0:	54fffd08 	b.hi	405c70 <cbvprintf_package+0x160>  // b.pmore
  405cd4:	38684968 	ldrb	w8, [x11, w8, uxtw]
  405cd8:	10000070 	adr	x16, 405ce4 <cbvprintf_package+0x1d4>
  405cdc:	8b288a08 	add	x8, x16, w8, sxtb #2
  405ce0:	d61f0100 	br	x8
  405ce4:	5100ad08 	sub	w8, w8, #0x2b
  405ce8:	9ac821a8 	lsl	x8, x13, x8
  405cec:	ea0e011f 	tst	x8, x14
  405cf0:	54fffc21 	b.ne	405c74 <cbvprintf_package+0x164>  // b.any
  405cf4:	ea0f011f 	tst	x8, x15
  405cf8:	540003e1 	b.ne	405d74 <cbvprintf_package+0x264>  // b.any
  405cfc:	ea12011f 	tst	x8, x18
  405d00:	54fffb80 	b.eq	405c70 <cbvprintf_package+0x160>  // b.none
				if (fmt[-1] == 'l') {
  405d04:	385ff128 	ldurb	w8, [x9, #-1]
				parsing = false;
  405d08:	52800017 	mov	w23, #0x0                   	// #0
				if (fmt[-1] == 'l') {
  405d0c:	7101b11f 	cmp	w8, #0x6c
  405d10:	52800008 	mov	w8, #0x0                   	// #0
  405d14:	54000061 	b.ne	405d20 <cbvprintf_package+0x210>  // b.any
				align = VA_STACK_ALIGN(void *);
  405d18:	52800118 	mov	w24, #0x8                   	// #8
				size = sizeof(void *);
  405d1c:	2a1803f6 	mov	w22, w24
		buf = (void *) ROUND_UP(buf, align);
  405d20:	2a1803f0 	mov	w16, w24
  405d24:	d1000673 	sub	x19, x19, #0x1
  405d28:	8b384273 	add	x19, x19, w24, uxtw
  405d2c:	cb1003f0 	neg	x16, x16
  405d30:	8a100273 	and	x19, x19, x16
		if (buf0 != NULL && BUF_OFFSET + size > len) {
  405d34:	b40000d4 	cbz	x20, 405d4c <cbvprintf_package+0x23c>
  405d38:	2a1603f0 	mov	w16, w22
  405d3c:	cb140210 	sub	x16, x16, x20
  405d40:	8b130210 	add	x16, x16, x19
  405d44:	eb15021f 	cmp	x16, x21
  405d48:	54000408 	b.hi	405dc8 <cbvprintf_package+0x2b8>  // b.pmore
		if (is_str_arg) {
  405d4c:	34001488 	cbz	w8, 405fdc <cbvprintf_package+0x4cc>
			s = va_arg(ap, char *);
  405d50:	37f80a80 	tbnz	w0, #31, 405ea0 <cbvprintf_package+0x390>
  405d54:	91003fdb 	add	x27, x30, #0xf
  405d58:	2a0003e8 	mov	w8, w0
  405d5c:	927df37b 	and	x27, x27, #0xfffffffffffffff8
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
  405d60:	51000421 	sub	w1, w1, #0x1
			s = va_arg(ap, char *);
  405d64:	f94003da 	ldr	x26, [x30]
  405d68:	17ffff9c 	b	405bd8 <cbvprintf_package+0xc8>
				arg_idx--;
  405d6c:	510004c6 	sub	w6, w6, #0x1
				continue;
  405d70:	17ffffc0 	b	405c70 <cbvprintf_package+0x160>
				if (fmt[-1] == 'L') {
  405d74:	385ff138 	ldurb	w24, [x9, #-1]
  405d78:	7101331f 	cmp	w24, #0x4c
  405d7c:	540004a1 	b.ne	405e10 <cbvprintf_package+0x300>  // b.any
					v.ld = va_arg(ap, long double);
  405d80:	37f80379 	tbnz	w25, #31, 405dec <cbvprintf_package+0x2dc>
  405d84:	91003fc8 	add	x8, x30, #0xf
  405d88:	2a1903f7 	mov	w23, w25
  405d8c:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  405d90:	9100411e 	add	x30, x8, #0x10
  405d94:	a9404510 	ldp	x16, x17, [x8]
					size = sizeof(long double);
  405d98:	aa1e03e8 	mov	x8, x30
  405d9c:	52800216 	mov	w22, #0x10                  	// #16
				buf = (void *) ROUND_UP(buf, align);
  405da0:	2a1603f9 	mov	w25, w22
  405da4:	d1000673 	sub	x19, x19, #0x1
  405da8:	8b364273 	add	x19, x19, w22, uxtw
  405dac:	cb1903fb 	neg	x27, x25
  405db0:	8a1b0273 	and	x19, x19, x27
				if (buf0 != NULL) {
  405db4:	b40005b4 	cbz	x20, 405e68 <cbvprintf_package+0x358>
					if (BUF_OFFSET + size > len) {
  405db8:	cb14033b 	sub	x27, x25, x20
  405dbc:	8b13037b 	add	x27, x27, x19
  405dc0:	eb15037f 	cmp	x27, x21
  405dc4:	54000489 	b.ls	405e54 <cbvprintf_package+0x344>  // b.plast
			return -ENOSPC;
  405dc8:	12800360 	mov	w0, #0xffffffe4            	// #-28
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
  405dcc:	d0000121 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  405dd0:	f9476821 	ldr	x1, [x1, #3792]
  405dd4:	f94067e3 	ldr	x3, [sp, #200]
  405dd8:	f9400022 	ldr	x2, [x1]
  405ddc:	eb020063 	subs	x3, x3, x2
  405de0:	d2800002 	mov	x2, #0x0                   	// #0
  405de4:	54002420 	b.eq	406268 <cbvprintf_package+0x758>  // b.none
  405de8:	97ffed4e 	bl	401320 <__stack_chk_fail@plt>
					v.ld = va_arg(ap, long double);
  405dec:	11004337 	add	w23, w25, #0x10
  405df0:	710002ff 	cmp	w23, #0x0
  405df4:	540000ad 	b.le	405e08 <cbvprintf_package+0x2f8>
  405df8:	91003fc8 	add	x8, x30, #0xf
  405dfc:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  405e00:	9100411e 	add	x30, x8, #0x10
  405e04:	17ffffe4 	b	405d94 <cbvprintf_package+0x284>
  405e08:	8b39c188 	add	x8, x12, w25, sxtw
  405e0c:	17ffffe2 	b	405d94 <cbvprintf_package+0x284>
					v.d = va_arg(ap, double);
  405e10:	37f80119 	tbnz	w25, #31, 405e30 <cbvprintf_package+0x320>
  405e14:	91003fc8 	add	x8, x30, #0xf
  405e18:	2a1903f7 	mov	w23, w25
  405e1c:	927df108 	and	x8, x8, #0xfffffffffffffff8
  405e20:	d2800011 	mov	x17, #0x0                   	// #0
					size = sizeof(double);
  405e24:	52800116 	mov	w22, #0x8                   	// #8
					v.d = va_arg(ap, double);
  405e28:	f94003d0 	ldr	x16, [x30]
					size = sizeof(double);
  405e2c:	17ffffdd 	b	405da0 <cbvprintf_package+0x290>
					v.d = va_arg(ap, double);
  405e30:	11004337 	add	w23, w25, #0x10
  405e34:	710002ff 	cmp	w23, #0x0
  405e38:	5400008d 	b.le	405e48 <cbvprintf_package+0x338>
  405e3c:	91003fc8 	add	x8, x30, #0xf
  405e40:	927df108 	and	x8, x8, #0xfffffffffffffff8
  405e44:	17fffff7 	b	405e20 <cbvprintf_package+0x310>
  405e48:	aa1e03e8 	mov	x8, x30
  405e4c:	8b39c19e 	add	x30, x12, w25, sxtw
  405e50:	17fffff4 	b	405e20 <cbvprintf_package+0x310>
					} else if (fmt[-1] == 'L') {
  405e54:	7101331f 	cmp	w24, #0x4c
  405e58:	54000121 	b.ne	405e7c <cbvprintf_package+0x36c>  // b.any
						*(long double *)buf = v.ld;
  405e5c:	9e670200 	fmov	d0, x16
  405e60:	9eaf0220 	fmov	v0.d[1], x17
  405e64:	3d800260 	str	q0, [x19]
				buf += size;
  405e68:	8b190273 	add	x19, x19, x25
				continue;
  405e6c:	aa0803fe 	mov	x30, x8
  405e70:	2a1703f9 	mov	w25, w23
  405e74:	2a1603f8 	mov	w24, w22
  405e78:	17ffff7e 	b	405c70 <cbvprintf_package+0x160>
						*(double *)buf = v.d;
  405e7c:	f9000270 	str	x16, [x19]
  405e80:	17fffffa 	b	405e68 <cbvprintf_package+0x358>
			switch (*fmt) {
  405e84:	52800008 	mov	w8, #0x0                   	// #0
				parsing = false;
  405e88:	52800017 	mov	w23, #0x0                   	// #0
  405e8c:	17ffffa3 	b	405d18 <cbvprintf_package+0x208>
				is_str_arg = true;
  405e90:	2a1703e8 	mov	w8, w23
  405e94:	17fffffd 	b	405e88 <cbvprintf_package+0x378>
			switch (*fmt) {
  405e98:	52800008 	mov	w8, #0x0                   	// #0
  405e9c:	17ffffa1 	b	405d20 <cbvprintf_package+0x210>
			s = va_arg(ap, char *);
  405ea0:	11002008 	add	w8, w0, #0x8
  405ea4:	7100011f 	cmp	w8, #0x0
  405ea8:	5400008d 	b.le	405eb8 <cbvprintf_package+0x3a8>
  405eac:	91003fdb 	add	x27, x30, #0xf
  405eb0:	927df37b 	and	x27, x27, #0xfffffffffffffff8
  405eb4:	17ffffab 	b	405d60 <cbvprintf_package+0x250>
  405eb8:	aa1e03fb 	mov	x27, x30
  405ebc:	8b20c15e 	add	x30, x10, w0, sxtw
  405ec0:	17ffffa8 	b	405d60 <cbvprintf_package+0x250>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
  405ec4:	71003c7f 	cmp	w3, #0xf
  405ec8:	54000249 	b.ls	405f10 <cbvprintf_package+0x400>  // b.plast
					__ASSERT(false, "str_ptr_pos[] too small");
  405ecc:	f0000073 	adrp	x19, 414000 <__func__.1+0xd>
  405ed0:	9119d273 	add	x19, x19, #0x674
  405ed4:	aa1303e2 	mov	x2, x19
  405ed8:	b0000081 	adrp	x1, 416000 <__func__.0+0xc27>
  405edc:	911f5821 	add	x1, x1, #0x7d6
  405ee0:	52805003 	mov	w3, #0x280                 	// #640
  405ee4:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  405ee8:	911a8800 	add	x0, x0, #0x6a2
  405eec:	940006e3 	bl	407a78 <assert_print>
  405ef0:	f0000060 	adrp	x0, 414000 <__func__.1+0xd>
  405ef4:	911c1400 	add	x0, x0, #0x705
  405ef8:	940006e0 	bl	407a78 <assert_print>
  405efc:	aa1303e0 	mov	x0, x19
  405f00:	52805001 	mov	w1, #0x280                 	// #640
  405f04:	94000707 	bl	407b20 <assert_post_action>
  405f08:	52805002 	mov	w2, #0x280                 	// #640
  405f0c:	17ffff4d 	b	405c40 <cbvprintf_package+0x130>
				if (buf0 != NULL) {
  405f10:	b4000274 	cbz	x20, 405f5c <cbvprintf_package+0x44c>
					str_ptr_pos[s_idx] = s_ptr_idx;
  405f14:	2a0303f0 	mov	w16, w3
  405f18:	9102a3f1 	add	x17, sp, #0xa8
					str_ptr_arg[s_idx] = arg_idx;
  405f1c:	9102e3fe 	add	x30, sp, #0xb8
					str_ptr_pos[s_idx] = s_ptr_idx;
  405f20:	12001c00 	and	w0, w0, #0xff
  405f24:	38306a20 	strb	w0, [x17, x16]
					str_ptr_arg[s_idx] = arg_idx;
  405f28:	38306bc6 	strb	w6, [x30, x16]
					if (is_ro) {
  405f2c:	7100003f 	cmp	w1, #0x0
  405f30:	5400012d 	b.le	405f54 <cbvprintf_package+0x444>
						s_ro_cnt++;
  405f34:	110004a5 	add	w5, w5, #0x1
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
  405f38:	32196000 	orr	w0, w0, #0xffffff80
  405f3c:	38306a20 	strb	w0, [x17, x16]
				s_idx++;
  405f40:	11000463 	add	w3, w3, #0x1
			buf += sizeof(char *);
  405f44:	91002273 	add	x19, x19, #0x8
			is_str_arg = false;
  405f48:	2a0803e0 	mov	w0, w8
  405f4c:	aa1b03fe 	mov	x30, x27
  405f50:	17ffff49 	b	405c74 <cbvprintf_package+0x164>
						s_rw_cnt++;
  405f54:	11000484 	add	w4, w4, #0x1
  405f58:	17fffffa 	b	405f40 <cbvprintf_package+0x430>
				} else if (is_ro) {
  405f5c:	7100003f 	cmp	w1, #0x0
  405f60:	5400006d 	b.le	405f6c <cbvprintf_package+0x45c>
					len += 1;
  405f64:	910006b5 	add	x21, x21, #0x1
  405f68:	17fffff6 	b	405f40 <cbvprintf_package+0x430>
				} else if (rws_pos_en) {
  405f6c:	b94083e0 	ldr	w0, [sp, #128]
					len += 2;
  405f70:	91000ab5 	add	x21, x21, #0x2
				} else if (rws_pos_en) {
  405f74:	35fffe60 	cbnz	w0, 405f40 <cbvprintf_package+0x430>
					len += strlen(s) + 1 + 1;
  405f78:	aa1a03e0 	mov	x0, x26
  405f7c:	a906b3ea 	stp	x10, x12, [sp, #104]
  405f80:	f9003fe9 	str	x9, [sp, #120]
  405f84:	291093e3 	stp	w3, w4, [sp, #132]
  405f88:	29119be5 	stp	w5, w6, [sp, #140]
  405f8c:	2912a3e1 	stp	w1, w8, [sp, #148]
  405f90:	b9009fe2 	str	w2, [sp, #156]
  405f94:	97ffec83 	bl	4011a0 <strlen@plt>
  405f98:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  405f9c:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  405fa0:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  405fa4:	8b0002b5 	add	x21, x21, x0
  405fa8:	295093e3 	ldp	w3, w4, [sp, #132]
  405fac:	d0000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  405fb0:	29519be5 	ldp	w5, w6, [sp, #140]
  405fb4:	9116100b 	add	x11, x0, #0x584
  405fb8:	2952a3e1 	ldp	w1, w8, [sp, #148]
  405fbc:	f2e06012 	movk	x18, #0x300, lsl #48
  405fc0:	b9409fe2 	ldr	w2, [sp, #156]
  405fc4:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  405fc8:	f2c0004e 	movk	x14, #0x2, lsl #32
  405fcc:	d280002d 	mov	x13, #0x1                   	// #1
  405fd0:	a946b3ea 	ldp	x10, x12, [sp, #104]
  405fd4:	f9403fe9 	ldr	x9, [sp, #120]
  405fd8:	17ffffda 	b	405f40 <cbvprintf_package+0x430>
		} else if (size == sizeof(int)) {
  405fdc:	710012df 	cmp	w22, #0x4
  405fe0:	540002a1 	b.ne	406034 <cbvprintf_package+0x524>  // b.any
			int v = va_arg(ap, int);
  405fe4:	37f80160 	tbnz	w0, #31, 406010 <cbvprintf_package+0x500>
  405fe8:	91002fc8 	add	x8, x30, #0xb
  405fec:	2a0003f0 	mov	w16, w0
  405ff0:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  405ff4:	b4000074 	cbz	x20, 406000 <cbvprintf_package+0x4f0>
			int v = va_arg(ap, int);
  405ff8:	b94003c0 	ldr	w0, [x30]
				*(int *)buf = v;
  405ffc:	b9000260 	str	w0, [x19]
			buf += sizeof(int);
  406000:	91001273 	add	x19, x19, #0x4
  406004:	2a1003e0 	mov	w0, w16
  406008:	aa0803fe 	mov	x30, x8
  40600c:	17ffff1a 	b	405c74 <cbvprintf_package+0x164>
			int v = va_arg(ap, int);
  406010:	11002010 	add	w16, w0, #0x8
  406014:	7100021f 	cmp	w16, #0x0
  406018:	5400008d 	b.le	406028 <cbvprintf_package+0x518>
  40601c:	91002fc8 	add	x8, x30, #0xb
  406020:	927df108 	and	x8, x8, #0xfffffffffffffff8
  406024:	17fffff4 	b	405ff4 <cbvprintf_package+0x4e4>
  406028:	aa1e03e8 	mov	x8, x30
  40602c:	8b20c15e 	add	x30, x10, w0, sxtw
  406030:	17fffff1 	b	405ff4 <cbvprintf_package+0x4e4>
		} else if (size == sizeof(long)) {
  406034:	710022df 	cmp	w22, #0x8
  406038:	54000261 	b.ne	406084 <cbvprintf_package+0x574>  // b.any
			long v = va_arg(ap, long);
  40603c:	37f80120 	tbnz	w0, #31, 406060 <cbvprintf_package+0x550>
  406040:	91003fc8 	add	x8, x30, #0xf
  406044:	2a0003f0 	mov	w16, w0
  406048:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  40604c:	b4000074 	cbz	x20, 406058 <cbvprintf_package+0x548>
			long v = va_arg(ap, long);
  406050:	f94003c0 	ldr	x0, [x30]
				*(long *)buf = v;
  406054:	f9000260 	str	x0, [x19]
			buf += sizeof(long);
  406058:	91002273 	add	x19, x19, #0x8
  40605c:	17ffffea 	b	406004 <cbvprintf_package+0x4f4>
			long v = va_arg(ap, long);
  406060:	11002010 	add	w16, w0, #0x8
  406064:	7100021f 	cmp	w16, #0x0
  406068:	5400008d 	b.le	406078 <cbvprintf_package+0x568>
  40606c:	91003fc8 	add	x8, x30, #0xf
  406070:	927df108 	and	x8, x8, #0xfffffffffffffff8
  406074:	17fffff6 	b	40604c <cbvprintf_package+0x53c>
  406078:	aa1e03e8 	mov	x8, x30
  40607c:	8b20c15e 	add	x30, x10, w0, sxtw
  406080:	17fffff3 	b	40604c <cbvprintf_package+0x53c>
			__ASSERT(false, "unexpected size %u", size);
  406084:	d0000073 	adrp	x19, 414000 <__func__.1+0xd>
  406088:	9119d273 	add	x19, x19, #0x674
  40608c:	aa1303e2 	mov	x2, x19
  406090:	528058a3 	mov	w3, #0x2c5                 	// #709
  406094:	90000081 	adrp	x1, 416000 <__func__.0+0xc27>
  406098:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  40609c:	911f5821 	add	x1, x1, #0x7d6
  4060a0:	911a8800 	add	x0, x0, #0x6a2
  4060a4:	94000675 	bl	407a78 <assert_print>
  4060a8:	2a1603e1 	mov	w1, w22
  4060ac:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4060b0:	911c7c00 	add	x0, x0, #0x71f
  4060b4:	94000671 	bl	407a78 <assert_print>
  4060b8:	aa1303e0 	mov	x0, x19
  4060bc:	528058a1 	mov	w1, #0x2c5                 	// #709
  4060c0:	94000698 	bl	407b20 <assert_post_action>
  4060c4:	528058a2 	mov	w2, #0x2c5                 	// #709
  4060c8:	17fffede 	b	405c40 <cbvprintf_package+0x130>
	if (BUF_OFFSET / sizeof(int) > 255) {
  4060cc:	cb140261 	sub	x1, x19, x20
  4060d0:	f10ffc3f 	cmp	x1, #0x3ff
  4060d4:	54000249 	b.ls	40611c <cbvprintf_package+0x60c>  // b.plast
		__ASSERT(false, "too many format args");
  4060d8:	d0000073 	adrp	x19, 414000 <__func__.1+0xd>
  4060dc:	9119d273 	add	x19, x19, #0x674
  4060e0:	aa1303e2 	mov	x2, x19
  4060e4:	90000081 	adrp	x1, 416000 <__func__.0+0xc27>
  4060e8:	911f5821 	add	x1, x1, #0x7d6
  4060ec:	52805a23 	mov	w3, #0x2d1                 	// #721
  4060f0:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4060f4:	911a8800 	add	x0, x0, #0x6a2
  4060f8:	94000660 	bl	407a78 <assert_print>
  4060fc:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406100:	911cd000 	add	x0, x0, #0x734
  406104:	9400065d 	bl	407a78 <assert_print>
  406108:	aa1303e0 	mov	x0, x19
  40610c:	52805a21 	mov	w1, #0x2d1                 	// #721
  406110:	94000684 	bl	407b20 <assert_post_action>
  406114:	52805a22 	mov	w2, #0x2d1                 	// #721
  406118:	17fffeca 	b	405c40 <cbvprintf_package+0x130>
	if (buf0 == NULL) {
  40611c:	b5000094 	cbnz	x20, 40612c <cbvprintf_package+0x61c>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
  406120:	510022a0 	sub	w0, w21, #0x8
  406124:	0b010000 	add	w0, w0, w1
  406128:	17ffff29 	b	405dcc <cbvprintf_package+0x2bc>
	if (rws_pos_en) {
  40612c:	b94083e0 	ldr	w0, [sp, #128]
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  406130:	d342fc21 	lsr	x1, x1, #2
	*(char **)buf0 = NULL;
  406134:	f900029f 	str	xzr, [x20]
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  406138:	12001c84 	and	w4, w4, #0xff
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  40613c:	39000281 	strb	w1, [x20]
	if (rws_pos_en) {
  406140:	34000120 	cbz	w0, 406164 <cbvprintf_package+0x654>
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  406144:	39000e84 	strb	w4, [x20, #3]
	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
  406148:	39000a85 	strb	w5, [x20, #2]
	if (s_ro_cnt) {
  40614c:	9102a3f8 	add	x24, sp, #0xa8
  406150:	35000265 	cbnz	w5, 40619c <cbvprintf_package+0x68c>
		if (BUF_OFFSET + 1 + size > len) {
  406154:	d2800036 	mov	x22, #0x1                   	// #1
			*buf++ = str_ptr_arg[i];
  406158:	9102e3f7 	add	x23, sp, #0xb8
		if (BUF_OFFSET + 1 + size > len) {
  40615c:	cb1402d6 	sub	x22, x22, x20
  406160:	1400002d 	b	406214 <cbvprintf_package+0x704>
		pkg_hdr->desc.str_cnt = s_rw_cnt;
  406164:	39000684 	strb	w4, [x20, #1]
		pkg_hdr->desc.rw_str_cnt = 0;
  406168:	17fffff8 	b	406148 <cbvprintf_package+0x638>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
  40616c:	38e16b04 	ldrsb	w4, [x24, x1]
  406170:	38786820 	ldrb	w0, [x1, x24]
  406174:	36f800c4 	tbz	w4, #31, 40618c <cbvprintf_package+0x67c>
			if (BUF_OFFSET + 1 > len) {
  406178:	8b020264 	add	x4, x19, x2
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
  40617c:	12001800 	and	w0, w0, #0x7f
			if (BUF_OFFSET + 1 > len) {
  406180:	eb15009f 	cmp	x4, x21
  406184:	54ffe228 	b.hi	405dc8 <cbvprintf_package+0x2b8>  // b.pmore
			*buf++ = pos;
  406188:	38001660 	strb	w0, [x19], #1
		for (i = 0; i < s_idx; i++) {
  40618c:	91000421 	add	x1, x1, #0x1
  406190:	6b01007f 	cmp	w3, w1
  406194:	54fffec8 	b.hi	40616c <cbvprintf_package+0x65c>  // b.pmore
  406198:	17ffffef 	b	406154 <cbvprintf_package+0x644>
			if (BUF_OFFSET + 1 > len) {
  40619c:	d2800022 	mov	x2, #0x1                   	// #1
  4061a0:	d2800001 	mov	x1, #0x0                   	// #0
  4061a4:	cb140042 	sub	x2, x2, x20
  4061a8:	17fffffa 	b	406190 <cbvprintf_package+0x680>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
  4061ac:	34000065 	cbz	w5, 4061b8 <cbvprintf_package+0x6a8>
  4061b0:	39c00300 	ldrsb	w0, [x24]
  4061b4:	37f802c0 	tbnz	w0, #31, 40620c <cbvprintf_package+0x6fc>
		if (rws_pos_en) {
  4061b8:	b94083e0 	ldr	w0, [sp, #128]
  4061bc:	34000340 	cbz	w0, 406224 <cbvprintf_package+0x714>
			*buf++ = str_ptr_arg[i];
  4061c0:	38776b80 	ldrb	w0, [x28, x23]
  4061c4:	38001660 	strb	w0, [x19], #1
			size = 0;
  4061c8:	52800000 	mov	w0, #0x0                   	// #0
		if (BUF_OFFSET + 1 + size > len) {
  4061cc:	2a0003f9 	mov	w25, w0
  4061d0:	8b204260 	add	x0, x19, w0, uxtw
  4061d4:	8b160000 	add	x0, x0, x22
  4061d8:	b90063e3 	str	w3, [sp, #96]
  4061dc:	b9006be5 	str	w5, [sp, #104]
  4061e0:	eb15001f 	cmp	x0, x21
  4061e4:	54ffdf28 	b.hi	405dc8 <cbvprintf_package+0x2b8>  // b.pmore
		*buf++ = str_ptr_pos[i];
  4061e8:	39400300 	ldrb	w0, [x24]
  4061ec:	aa1903e2 	mov	x2, x25
  4061f0:	38001660 	strb	w0, [x19], #1
  4061f4:	aa1a03e1 	mov	x1, x26
  4061f8:	aa1303e0 	mov	x0, x19
  4061fc:	97ffebdd 	bl	401170 <memcpy@plt>
		buf += size;
  406200:	b94063e3 	ldr	w3, [sp, #96]
  406204:	8b190273 	add	x19, x19, x25
  406208:	b9406be5 	ldr	w5, [sp, #104]
	for (i = 0; i < s_idx; i++) {
  40620c:	9100079c 	add	x28, x28, #0x1
  406210:	91000718 	add	x24, x24, #0x1
  406214:	6b1c007f 	cmp	w3, w28
  406218:	54fffca8 	b.hi	4061ac <cbvprintf_package+0x69c>  // b.pmore
	return BUF_OFFSET;
  40621c:	4b140260 	sub	w0, w19, w20
  406220:	17fffeeb 	b	405dcc <cbvprintf_package+0x2bc>
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
  406224:	39400300 	ldrb	w0, [x24]
  406228:	b90063e3 	str	w3, [sp, #96]
  40622c:	b9006be5 	str	w5, [sp, #104]
  406230:	d37ef400 	lsl	x0, x0, #2
  406234:	f8606a9a 	ldr	x26, [x20, x0]
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
  406238:	f8206a9f 	str	xzr, [x20, x0]
			size = strlen(s) + 1;
  40623c:	aa1a03e0 	mov	x0, x26
  406240:	97ffebd8 	bl	4011a0 <strlen@plt>
  406244:	b94063e3 	ldr	w3, [sp, #96]
  406248:	11000400 	add	w0, w0, #0x1
  40624c:	b9406be5 	ldr	w5, [sp, #104]
  406250:	17ffffdf 	b	4061cc <cbvprintf_package+0x6bc>
		return -EFAULT;
  406254:	128001a0 	mov	w0, #0xfffffff2            	// #-14
  406258:	17fffedd 	b	405dcc <cbvprintf_package+0x2bc>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
  40625c:	f1003ebf 	cmp	x21, #0xf
  406260:	54ffc948 	b.hi	405b88 <cbvprintf_package+0x78>  // b.pmore
  406264:	17fffed9 	b	405dc8 <cbvprintf_package+0x2b8>
}
  406268:	a94153f3 	ldp	x19, x20, [sp, #16]
  40626c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406270:	a94363f7 	ldp	x23, x24, [sp, #48]
  406274:	a9446bf9 	ldp	x25, x26, [sp, #64]
  406278:	a94573fb 	ldp	x27, x28, [sp, #80]
  40627c:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  406280:	d65f03c0 	ret

0000000000406284 <cbpprintf_external>:
	uint8_t *buf = packaged;
	struct cbprintf_package_hdr_ext *hdr = packaged;
	char *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, rws_nbr, s_idx;

	if (buf == NULL) {
  406284:	b40005e3 	cbz	x3, 406340 <cbpprintf_external+0xbc>
{
  406288:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  40628c:	910003fd 	mov	x29, sp
  406290:	a90153f3 	stp	x19, x20, [sp, #16]
  406294:	aa0303f4 	mov	x20, x3
  406298:	a9025bf5 	stp	x21, x22, [sp, #32]
  40629c:	aa0003f6 	mov	x22, x0
  4062a0:	aa0103f5 	mov	x21, x1
  4062a4:	a90363f7 	stp	x23, x24, [sp, #48]
  4062a8:	aa0203f7 	mov	x23, x2
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
  4062ac:	52800018 	mov	w24, #0x0                   	// #0
{
  4062b0:	f90023f9 	str	x25, [sp, #64]
	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
  4062b4:	39400c60 	ldrb	w0, [x3, #3]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  4062b8:	39400073 	ldrb	w19, [x3]
	s_nbr     = hdr->hdr.desc.str_cnt;
  4062bc:	39400479 	ldrb	w25, [x3, #1]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  4062c0:	d37f1c00 	ubfiz	x0, x0, #1, #8
  4062c4:	8b334813 	add	x19, x0, w19, uxtw #2
  4062c8:	39400860 	ldrb	w0, [x3, #2]
  4062cc:	8b000273 	add	x19, x19, x0
  4062d0:	8b130073 	add	x19, x3, x19
	for (i = 0; i < s_nbr; i++) {
  4062d4:	6b19031f 	cmp	w24, w25
  4062d8:	54000223 	b.cc	40631c <cbpprintf_external+0x98>  // b.lo, b.ul, b.last
		/* move to next string */
		s += strlen(s) + 1;
	}

	/* Skip past the header */
	buf += sizeof(*hdr);
  4062dc:	91004280 	add	x0, x20, #0x10
	u.__ap.__gr_top = NULL;
  4062e0:	a9077fe0 	stp	x0, xzr, [sp, #112]
	return formatter(out, ctx, fmt, u.ap);
  4062e4:	910143e3 	add	x3, sp, #0x50
	u.__ap.__gr_offs = 0;
  4062e8:	a9087fff 	stp	xzr, xzr, [sp, #128]
	return formatter(out, ctx, fmt, u.ap);
  4062ec:	aa1703e1 	mov	x1, x23
  4062f0:	aa1603e0 	mov	x0, x22
  4062f4:	ad4387e0 	ldp	q0, q1, [sp, #112]
  4062f8:	ad000460 	stp	q0, q1, [x3]
  4062fc:	f9400682 	ldr	x2, [x20, #8]
  406300:	d63f02a0 	blr	x21

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
}
  406304:	a94153f3 	ldp	x19, x20, [sp, #16]
  406308:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40630c:	a94363f7 	ldp	x23, x24, [sp, #48]
  406310:	f94023f9 	ldr	x25, [sp, #64]
  406314:	a8c97bfd 	ldp	x29, x30, [sp], #144
  406318:	d65f03c0 	ret
		ps = (char **)(buf + s_idx * sizeof(int));
  40631c:	38401660 	ldrb	w0, [x19], #1
	for (i = 0; i < s_nbr; i++) {
  406320:	11000718 	add	w24, w24, #0x1
		ps = (char **)(buf + s_idx * sizeof(int));
  406324:	d37ef400 	lsl	x0, x0, #2
		*ps = s;
  406328:	f8206a93 	str	x19, [x20, x0]
		s += strlen(s) + 1;
  40632c:	aa1303e0 	mov	x0, x19
  406330:	97ffeb9c 	bl	4011a0 <strlen@plt>
  406334:	91000400 	add	x0, x0, #0x1
  406338:	8b000273 	add	x19, x19, x0
	for (i = 0; i < s_nbr; i++) {
  40633c:	17ffffe6 	b	4062d4 <cbpprintf_external+0x50>
		return -EINVAL;
  406340:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  406344:	d65f03c0 	ret

0000000000406348 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  406348:	52800000 	mov	w0, #0x0                   	// #0
  40634c:	d65f03c0 	ret

0000000000406350 <__printk_hook_install>:
 * routine that outputs one ASCII character at a time.
 * @param fn putc routine to install
 */
void __printk_hook_install(int (*fn)(int c))
{
	_char_out = fn;
  406350:	b0000121 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  406354:	f947b821 	ldr	x1, [x1, #3952]
  406358:	f9000020 	str	x0, [x1]
}
  40635c:	d65f03c0 	ret

0000000000406360 <vprintk>:
	(void) ctx_p;
	return _char_out(c);
}

void vprintk(const char *fmt, va_list ap)
{
  406360:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  406364:	910003fd 	mov	x29, sp
	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		z_log_vprintk(fmt, ap);
  406368:	ad400420 	ldp	q0, q1, [x1]
  40636c:	910043e2 	add	x2, sp, #0x10
  406370:	aa0203e1 	mov	x1, x2
  406374:	ad000440 	stp	q0, q1, [x2]
  406378:	94000687 	bl	407d94 <z_log_vprintk>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
  40637c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  406380:	d65f03c0 	ret

0000000000406384 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
  406384:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  406388:	910003fd 	mov	x29, sp
  40638c:	a90e8be1 	stp	x1, x2, [sp, #232]
  406390:	b0000121 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  406394:	f9476821 	ldr	x1, [x1, #3792]
  406398:	3d801be0 	str	q0, [sp, #96]
  40639c:	3d801fe1 	str	q1, [sp, #112]
  4063a0:	3d8023e2 	str	q2, [sp, #128]
  4063a4:	3d8027e3 	str	q3, [sp, #144]
  4063a8:	3d802be4 	str	q4, [sp, #160]
  4063ac:	3d802fe5 	str	q5, [sp, #176]
  4063b0:	3d8033e6 	str	q6, [sp, #192]
  4063b4:	3d8037e7 	str	q7, [sp, #208]
  4063b8:	a90f93e3 	stp	x3, x4, [sp, #248]
  4063bc:	a9109be5 	stp	x5, x6, [sp, #264]
  4063c0:	f9008fe7 	str	x7, [sp, #280]
  4063c4:	f9400022 	ldr	x2, [x1]
  4063c8:	f9002fe2 	str	x2, [sp, #88]
  4063cc:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  4063d0:	910483e1 	add	x1, sp, #0x120
  4063d4:	a90387e1 	stp	x1, x1, [sp, #56]
  4063d8:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  4063dc:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  4063e0:	f90027e1 	str	x1, [sp, #72]
  4063e4:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  4063e8:	b90053e1 	str	w1, [sp, #80]
  4063ec:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  4063f0:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  4063f4:	910043e1 	add	x1, sp, #0x10
  4063f8:	ad400440 	ldp	q0, q1, [x2]
  4063fc:	ad000420 	stp	q0, q1, [x1]
  406400:	97ffffd8 	bl	406360 <vprintk>

	va_end(ap);
}
  406404:	b0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  406408:	f9476800 	ldr	x0, [x0, #3792]
  40640c:	f9402fe2 	ldr	x2, [sp, #88]
  406410:	f9400001 	ldr	x1, [x0]
  406414:	eb010042 	subs	x2, x2, x1
  406418:	d2800001 	mov	x1, #0x0                   	// #0
  40641c:	54000040 	b.eq	406424 <printk+0xa0>  // b.none
  406420:	97ffebc0 	bl	401320 <__stack_chk_fail@plt>
  406424:	a8d27bfd 	ldp	x29, x30, [sp], #288
  406428:	d65f03c0 	ret

000000000040642c <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  40642c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406430:	aa0003e4 	mov	x4, x0
  406434:	aa0103e0 	mov	x0, x1
  406438:	910003fd 	mov	x29, sp
  40643c:	aa0203e1 	mov	x1, x2
  406440:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
  406444:	d63f0080 	blr	x4
	return z_impl_z_current_get();
  406448:	94002f43 	bl	412154 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
  40644c:	94000b3e 	bl	409144 <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  406450:	d0000061 	adrp	x1, 414000 <__func__.1+0xd>
  406454:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406458:	911d7021 	add	x1, x1, #0x75c
  40645c:	911b8000 	add	x0, x0, #0x6e0
  406460:	528005a2 	mov	w2, #0x2d                  	// #45
  406464:	94000fa1 	bl	40a2e8 <posix_print_error_and_exit>

0000000000406468 <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
  406468:	d2800082 	mov	x2, #0x4                   	// #4
  40646c:	8b214c41 	add	x1, x2, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  406470:	b8616800 	ldr	w0, [x0, x1]
}
  406474:	53017c00 	lsr	w0, w0, #1
  406478:	d65f03c0 	ret

000000000040647c <free_list_remove_bidx>:
		return ((uint32_t *)cmem)[f];
  40647c:	8b214c04 	add	x4, x0, w1, uxtw #3
  406480:	b9400c83 	ldr	w3, [x4, #12]

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & BIT(bidx));

	if (next_free_chunk(h, c) == c) {
  406484:	6b03003f 	cmp	w1, w3
  406488:	93407c41 	sxtw	x1, w2
  40648c:	54000121 	b.ne	4064b0 <free_list_remove_bidx+0x34>  // b.any
		/* this is the last chunk */
		h->avail_buckets &= ~BIT(bidx);
  406490:	d2800023 	mov	x3, #0x1                   	// #1
		b->next = 0;
  406494:	91001021 	add	x1, x1, #0x4
		h->avail_buckets &= ~BIT(bidx);
  406498:	9ac22062 	lsl	x2, x3, x2
  40649c:	b9400c03 	ldr	w3, [x0, #12]
  4064a0:	0a220062 	bic	w2, w3, w2
  4064a4:	b9000c02 	str	w2, [x0, #12]
		b->next = 0;
  4064a8:	b821781f 	str	wzr, [x0, x1, lsl #2]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes -= chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
  4064ac:	d65f03c0 	ret
		b->next = second;
  4064b0:	91001021 	add	x1, x1, #0x4
  4064b4:	b9400882 	ldr	w2, [x4, #8]
  4064b8:	b8217803 	str	w3, [x0, x1, lsl #2]
		((uint32_t *)cmem)[f] = val;
  4064bc:	d2800181 	mov	x1, #0xc                   	// #12
  4064c0:	8b224c21 	add	x1, x1, w2, uxtw #3
  4064c4:	b8216803 	str	w3, [x0, x1]
  4064c8:	d37d7c63 	ubfiz	x3, x3, #3, #32
  4064cc:	91002063 	add	x3, x3, #0x8
  4064d0:	b8236802 	str	w2, [x0, x3]
}
  4064d4:	17fffff6 	b	4064ac <free_list_remove_bidx+0x30>

00000000004064d8 <alloc_chunk>:
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  4064d8:	51000424 	sub	w4, w1, #0x1
	return 31 - __builtin_clz(usable_sz);
  4064dc:	528003e6 	mov	w6, #0x1f                  	// #31
  4064e0:	5ac01084 	clz	w4, w4

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
  4064e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4064e8:	4b0400c6 	sub	w6, w6, w4
  4064ec:	910003fd 	mov	x29, sp
  4064f0:	8b26c808 	add	x8, x0, w6, sxtw #2
  4064f4:	aa0003e3 	mov	x3, x0
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
  4064f8:	b940110a 	ldr	w10, [x8, #16]
  4064fc:	3400030a 	cbz	w10, 40655c <alloc_chunk+0x84>
  406500:	2a0103e7 	mov	w7, w1
  406504:	52800069 	mov	w9, #0x3                   	// #3
		return ((uint32_t *)cmem)[f];
  406508:	d280018b 	mov	x11, #0xc                   	// #12
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
  40650c:	b9401105 	ldr	w5, [x8, #16]
			if (chunk_size(h, c) >= sz) {
  406510:	aa0303e0 	mov	x0, x3
  406514:	2a0503e1 	mov	w1, w5
  406518:	97ffffd4 	bl	406468 <chunk_size>
  40651c:	6b07001f 	cmp	w0, w7
  406520:	54000103 	b.cc	406540 <alloc_chunk+0x68>  // b.lo, b.ul, b.last
				free_list_remove_bidx(h, c, bi);
  406524:	2a0603e2 	mov	w2, w6

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
  406528:	2a0503e1 	mov	w1, w5
  40652c:	aa0303e0 	mov	x0, x3
  406530:	97ffffd3 	bl	40647c <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
  406534:	2a0503e0 	mov	w0, w5
  406538:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40653c:	d65f03c0 	ret
  406540:	8b254d65 	add	x5, x11, w5, uxtw #3
		} while (--i && b->next != first);
  406544:	71000529 	subs	w9, w9, #0x1
  406548:	b8656860 	ldr	w0, [x3, x5]
			b->next = next_free_chunk(h, c);
  40654c:	b9001100 	str	w0, [x8, #16]
		} while (--i && b->next != first);
  406550:	54000060 	b.eq	40655c <alloc_chunk+0x84>  // b.none
  406554:	6b00015f 	cmp	w10, w0
  406558:	54fffda1 	b.ne	40650c <alloc_chunk+0x34>  // b.any
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
  40655c:	52800400 	mov	w0, #0x20                  	// #32
  406560:	4b040000 	sub	w0, w0, w4
  406564:	d2800025 	mov	x5, #0x1                   	// #1
  406568:	9ac020a5 	lsl	x5, x5, x0
  40656c:	b9400c60 	ldr	w0, [x3, #12]
  406570:	4b0503e5 	neg	w5, w5
	if (bmask != 0U) {
  406574:	6a0000a5 	ands	w5, w5, w0
  406578:	54fffde0 	b.eq	406534 <alloc_chunk+0x5c>  // b.none
		int minbucket = __builtin_ctz(bmask);
  40657c:	5ac000a2 	rbit	w2, w5
  406580:	5ac01042 	clz	w2, w2
		chunkid_t c = h->buckets[minbucket].next;
  406584:	8b22c860 	add	x0, x3, w2, sxtw #2
  406588:	b9401005 	ldr	w5, [x0, #16]
  40658c:	17ffffe7 	b	406528 <alloc_chunk+0x50>

0000000000406590 <free_list_remove>:
{
  406590:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406594:	aa0003e3 	mov	x3, x0
  406598:	2a0103e4 	mov	w4, w1
  40659c:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  4065a0:	97ffffb2 	bl	406468 <chunk_size>
	if (!solo_free_header(h, c)) {
  4065a4:	7100041f 	cmp	w0, #0x1
  4065a8:	54000120 	b.eq	4065cc <free_list_remove+0x3c>  // b.none
}
  4065ac:	a8c17bfd 	ldp	x29, x30, [sp], #16
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  4065b0:	51000402 	sub	w2, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  4065b4:	5ac01042 	clz	w2, w2
		free_list_remove_bidx(h, c, bidx);
  4065b8:	528003e0 	mov	w0, #0x1f                  	// #31
  4065bc:	2a0403e1 	mov	w1, w4
  4065c0:	4b020002 	sub	w2, w0, w2
  4065c4:	aa0303e0 	mov	x0, x3
  4065c8:	17ffffad 	b	40647c <free_list_remove_bidx>
}
  4065cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4065d0:	d65f03c0 	ret

00000000004065d4 <free_list_add>:
{
  4065d4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4065d8:	aa0003e3 	mov	x3, x0
  4065dc:	2a0103e4 	mov	w4, w1
  4065e0:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  4065e4:	97ffffa1 	bl	406468 <chunk_size>
	if (!solo_free_header(h, c)) {
  4065e8:	7100041f 	cmp	w0, #0x1
  4065ec:	54000260 	b.eq	406638 <free_list_add+0x64>  // b.none
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  4065f0:	51000400 	sub	w0, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  4065f4:	528003e1 	mov	w1, #0x1f                  	// #31
  4065f8:	5ac01000 	clz	w0, w0
  4065fc:	4b000021 	sub	w1, w1, w0
	if (b->next == 0U) {
  406600:	d37d7c80 	ubfiz	x0, x4, #3, #32
  406604:	91002006 	add	x6, x0, #0x8
		((uint32_t *)cmem)[f] = val;
  406608:	91003000 	add	x0, x0, #0xc
  40660c:	8b21c867 	add	x7, x3, w1, sxtw #2
  406610:	b94010e5 	ldr	w5, [x7, #16]
  406614:	35000165 	cbnz	w5, 406640 <free_list_add+0x6c>
		h->avail_buckets |= BIT(bidx);
  406618:	d2800022 	mov	x2, #0x1                   	// #1
  40661c:	9ac12042 	lsl	x2, x2, x1
  406620:	b9400c61 	ldr	w1, [x3, #12]
  406624:	2a020021 	orr	w1, w1, w2
  406628:	b9000c61 	str	w1, [x3, #12]
		b->next = c;
  40662c:	b90010e4 	str	w4, [x7, #16]
  406630:	b8266864 	str	w4, [x3, x6]
  406634:	b8206864 	str	w4, [x3, x0]
}
  406638:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40663c:	d65f03c0 	ret
		return ((uint32_t *)cmem)[f];
  406640:	d37d7ca1 	ubfiz	x1, x5, #3, #32
  406644:	91002021 	add	x1, x1, #0x8
  406648:	b8616862 	ldr	w2, [x3, x1]
		((uint32_t *)cmem)[f] = val;
  40664c:	b8266862 	str	w2, [x3, x6]
  406650:	b8206865 	str	w5, [x3, x0]
  406654:	d2800180 	mov	x0, #0xc                   	// #12
  406658:	8b224c02 	add	x2, x0, w2, uxtw #3
  40665c:	b8226864 	str	w4, [x3, x2]
  406660:	b8216864 	str	w4, [x3, x1]
  406664:	17fffff5 	b	406638 <free_list_add+0x64>

0000000000406668 <merge_chunks>:
{
  406668:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40666c:	2a0203e3 	mov	w3, w2
  406670:	aa0003e4 	mov	x4, x0
  406674:	910003fd 	mov	x29, sp
  406678:	2a0103e6 	mov	w6, w1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
  40667c:	97ffff7b 	bl	406468 <chunk_size>
  406680:	2a0303e1 	mov	w1, w3
  406684:	2a0003e5 	mov	w5, w0
  406688:	aa0403e0 	mov	x0, x4
  40668c:	97ffff77 	bl	406468 <chunk_size>
  406690:	0b0000a5 	add	w5, w5, w0
  406694:	d2800080 	mov	x0, #0x4                   	// #4
  406698:	8b264c06 	add	x6, x0, w6, uxtw #3
	return c + chunk_size(h, c);
  40669c:	2a0303e1 	mov	w1, w3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  4066a0:	531f78a0 	lsl	w0, w5, #1
		((uint32_t *)cmem)[f] = val;
  4066a4:	b8266880 	str	w0, [x4, x6]
	return c + chunk_size(h, c);
  4066a8:	aa0403e0 	mov	x0, x4
  4066ac:	97ffff6f 	bl	406468 <chunk_size>
	void *cmem = &buf[c];
  4066b0:	0b000063 	add	w3, w3, w0
  4066b4:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  4066b8:	b8236885 	str	w5, [x4, x3]
}
  4066bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4066c0:	d65f03c0 	ret

00000000004066c4 <free_chunk>:
{
  4066c4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4066c8:	2a0103e8 	mov	w8, w1
  4066cc:	aa0003e7 	mov	x7, x0
  4066d0:	910003fd 	mov	x29, sp
	return c + chunk_size(h, c);
  4066d4:	97ffff65 	bl	406468 <chunk_size>
  4066d8:	0b000101 	add	w1, w8, w0
		return ((uint32_t *)cmem)[f];
  4066dc:	d2800080 	mov	x0, #0x4                   	// #4
  4066e0:	8b214c00 	add	x0, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  4066e4:	b86068e0 	ldr	w0, [x7, x0]
	if (!chunk_used(h, right_chunk(h, c))) {
  4066e8:	37000140 	tbnz	w0, #0, 406710 <free_chunk+0x4c>
		free_list_remove(h, right_chunk(h, c));
  4066ec:	aa0703e0 	mov	x0, x7
  4066f0:	97ffffa8 	bl	406590 <free_list_remove>
	return c + chunk_size(h, c);
  4066f4:	2a0803e1 	mov	w1, w8
  4066f8:	aa0703e0 	mov	x0, x7
  4066fc:	97ffff5b 	bl	406468 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
  406700:	0b000102 	add	w2, w8, w0
  406704:	2a0803e1 	mov	w1, w8
  406708:	aa0703e0 	mov	x0, x7
  40670c:	97ffffd7 	bl	406668 <merge_chunks>
	void *cmem = &buf[c];
  406710:	d37d7d09 	ubfiz	x9, x8, #3, #32
		return ((uint32_t *)cmem)[f];
  406714:	d2800080 	mov	x0, #0x4                   	// #4
	return c - chunk_field(h, c, LEFT_SIZE);
  406718:	b86968e1 	ldr	w1, [x7, x9]
  40671c:	4b010101 	sub	w1, w8, w1
		return ((uint32_t *)cmem)[f];
  406720:	8b214c00 	add	x0, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  406724:	b86068e0 	ldr	w0, [x7, x0]
	if (!chunk_used(h, left_chunk(h, c))) {
  406728:	37000140 	tbnz	w0, #0, 406750 <free_chunk+0x8c>
		free_list_remove(h, left_chunk(h, c));
  40672c:	aa0703e0 	mov	x0, x7
  406730:	97ffff98 	bl	406590 <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
  406734:	b86968e1 	ldr	w1, [x7, x9]
		merge_chunks(h, left_chunk(h, c), c);
  406738:	2a0803e2 	mov	w2, w8
  40673c:	aa0703e0 	mov	x0, x7
  406740:	4b010101 	sub	w1, w8, w1
  406744:	97ffffc9 	bl	406668 <merge_chunks>
  406748:	b86968e0 	ldr	w0, [x7, x9]
  40674c:	4b000108 	sub	w8, w8, w0
}
  406750:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free_list_add(h, c);
  406754:	2a0803e1 	mov	w1, w8
  406758:	aa0703e0 	mov	x0, x7
  40675c:	17ffff9e 	b	4065d4 <free_list_add>

0000000000406760 <split_chunks>:
{
  406760:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406764:	2a0203e3 	mov	w3, w2
  406768:	2a0103e5 	mov	w5, w1
  40676c:	aa0003e4 	mov	x4, x0
  406770:	910003fd 	mov	x29, sp
	chunksz_t rsz = sz0 - lsz;
  406774:	4b0300a6 	sub	w6, w5, w3
	chunksz_t sz0 = chunk_size(h, lc);
  406778:	97ffff3c 	bl	406468 <chunk_size>
	chunksz_t rsz = sz0 - lsz;
  40677c:	0b0000c6 	add	w6, w6, w0
		((uint32_t *)cmem)[f] = val;
  406780:	d2800080 	mov	x0, #0x4                   	// #4
	chunksz_t lsz = rc - lc;
  406784:	4b050061 	sub	w1, w3, w5
  406788:	8b254c05 	add	x5, x0, w5, uxtw #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  40678c:	531f7820 	lsl	w0, w1, #1
		((uint32_t *)cmem)[f] = val;
  406790:	b8256880 	str	w0, [x4, x5]
	void *cmem = &buf[c];
  406794:	d37d7c60 	ubfiz	x0, x3, #3, #32
		((uint32_t *)cmem)[f] = val;
  406798:	8b000082 	add	x2, x4, x0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  40679c:	531f78c5 	lsl	w5, w6, #1
		((uint32_t *)cmem)[f] = val;
  4067a0:	b9000445 	str	w5, [x2, #4]
  4067a4:	b8206881 	str	w1, [x4, x0]
	return c + chunk_size(h, c);
  4067a8:	2a0303e1 	mov	w1, w3
  4067ac:	aa0403e0 	mov	x0, x4
  4067b0:	97ffff2e 	bl	406468 <chunk_size>
	void *cmem = &buf[c];
  4067b4:	0b000063 	add	w3, w3, w0
  4067b8:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  4067bc:	b8236886 	str	w6, [x4, x3]
}
  4067c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4067c4:	d65f03c0 	ret

00000000004067c8 <sys_heap_free>:
	if (mem == NULL) {
  4067c8:	b4000901 	cbz	x1, 4068e8 <sys_heap_free+0x120>
{
  4067cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  4067d0:	d1002023 	sub	x3, x1, #0x8
{
  4067d4:	910003fd 	mov	x29, sp
  4067d8:	a90153f3 	stp	x19, x20, [sp, #16]
  4067dc:	aa0103f3 	mov	x19, x1
	struct z_heap *h = heap->heap;
  4067e0:	f9400004 	ldr	x4, [x0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  4067e4:	d2800100 	mov	x0, #0x8                   	// #8
  4067e8:	cb040063 	sub	x3, x3, x4
  4067ec:	9ac00c63 	sdiv	x3, x3, x0
		return ((uint32_t *)cmem)[f];
  4067f0:	8b234c86 	add	x6, x4, w3, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  4067f4:	b94004c5 	ldr	w5, [x6, #4]
	__ASSERT(chunk_used(h, c),
  4067f8:	370002c5 	tbnz	w5, #0, 406850 <sys_heap_free+0x88>
  4067fc:	d0000074 	adrp	x20, 414000 <__func__.1+0xd>
  406800:	911e1694 	add	x20, x20, #0x785
  406804:	aa1403e2 	mov	x2, x20
  406808:	528015e3 	mov	w3, #0xaf                  	// #175
  40680c:	d0000061 	adrp	x1, 414000 <__func__.1+0xd>
  406810:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406814:	911e9821 	add	x1, x1, #0x7a6
  406818:	911a8800 	add	x0, x0, #0x6a2
  40681c:	94000497 	bl	407a78 <assert_print>
  406820:	aa1303e1 	mov	x1, x19
  406824:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406828:	911edc00 	add	x0, x0, #0x7b7
  40682c:	94000493 	bl	407a78 <assert_print>
  406830:	aa1403e0 	mov	x0, x20
  406834:	528015e1 	mov	w1, #0xaf                  	// #175
  406838:	940004ba 	bl	407b20 <assert_post_action>
  40683c:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406840:	aa1403e1 	mov	x1, x20
  406844:	911b8000 	add	x0, x0, #0x6e0
  406848:	528015e2 	mov	w2, #0xaf                  	// #175
  40684c:	94000ea7 	bl	40a2e8 <posix_print_error_and_exit>
	return c + chunk_size(h, c);
  406850:	2a0303e1 	mov	w1, w3
  406854:	aa0403e0 	mov	x0, x4
  406858:	97ffff04 	bl	406468 <chunk_size>
  40685c:	0b030001 	add	w1, w0, w3
	void *cmem = &buf[c];
  406860:	0b030000 	add	w0, w0, w3
  406864:	d37df000 	lsl	x0, x0, #3
	return c - chunk_field(h, c, LEFT_SIZE);
  406868:	b8606880 	ldr	w0, [x4, x0]
  40686c:	4b000021 	sub	w1, w1, w0
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
  406870:	6b01007f 	cmp	w3, w1
  406874:	540002c0 	b.eq	4068cc <sys_heap_free+0x104>  // b.none
  406878:	d0000074 	adrp	x20, 414000 <__func__.1+0xd>
  40687c:	911e1694 	add	x20, x20, #0x785
  406880:	aa1403e2 	mov	x2, x20
  406884:	528016e3 	mov	w3, #0xb7                  	// #183
  406888:	d0000061 	adrp	x1, 414000 <__func__.1+0xd>
  40688c:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406890:	911fbc21 	add	x1, x1, #0x7ef
  406894:	911a8800 	add	x0, x0, #0x6a2
  406898:	94000478 	bl	407a78 <assert_print>
  40689c:	aa1303e1 	mov	x1, x19
  4068a0:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4068a4:	91205400 	add	x0, x0, #0x815
  4068a8:	94000474 	bl	407a78 <assert_print>
  4068ac:	aa1403e0 	mov	x0, x20
  4068b0:	528016e1 	mov	w1, #0xb7                  	// #183
  4068b4:	9400049b 	bl	407b20 <assert_post_action>
  4068b8:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4068bc:	aa1403e1 	mov	x1, x20
  4068c0:	911b8000 	add	x0, x0, #0x6e0
  4068c4:	528016e2 	mov	w2, #0xb7                  	// #183
  4068c8:	94000e88 	bl	40a2e8 <posix_print_error_and_exit>
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
  4068cc:	121f78a5 	and	w5, w5, #0xfffffffe
  4068d0:	b90004c5 	str	w5, [x6, #4]
	free_chunk(h, c);
  4068d4:	2a0303e1 	mov	w1, w3
  4068d8:	aa0403e0 	mov	x0, x4
}
  4068dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4068e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free_chunk(h, c);
  4068e4:	17ffff78 	b	4066c4 <free_chunk>
  4068e8:	d65f03c0 	ret

00000000004068ec <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
	struct z_heap *h = heap->heap;
  4068ec:	f940000d 	ldr	x13, [x0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
  4068f0:	b50000c1 	cbnz	x1, 406908 <sys_heap_alloc+0x1c>
		return NULL;
  4068f4:	d2800000 	mov	x0, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  4068f8:	d65f03c0 	ret
		return NULL;
  4068fc:	d2800000 	mov	x0, #0x0                   	// #0
}
  406900:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406904:	d65f03c0 	ret
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  406908:	b94009a0 	ldr	w0, [x13, #8]
	if (bytes == 0U || size_too_big(h, bytes)) {
  40690c:	eb410c1f 	cmp	x0, x1, lsr #3
  406910:	54ffff29 	b.ls	4068f4 <sys_heap_alloc+0x8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406914:	91003c21 	add	x1, x1, #0xf
{
  406918:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	chunkid_t c = alloc_chunk(h, chunk_sz);
  40691c:	aa0d03e0 	mov	x0, x13
  406920:	d343fc2c 	lsr	x12, x1, #3
{
  406924:	910003fd 	mov	x29, sp
	chunkid_t c = alloc_chunk(h, chunk_sz);
  406928:	2a0c03e1 	mov	w1, w12
  40692c:	97fffeeb 	bl	4064d8 <alloc_chunk>
  406930:	2a0003e8 	mov	w8, w0
	if (c == 0U) {
  406934:	34fffe40 	cbz	w0, 4068fc <sys_heap_alloc+0x10>
	if (chunk_size(h, c) > chunk_sz) {
  406938:	2a0003e1 	mov	w1, w0
  40693c:	aa0d03e0 	mov	x0, x13
  406940:	97fffeca 	bl	406468 <chunk_size>
  406944:	6b0c001f 	cmp	w0, w12
  406948:	54000129 	b.ls	40696c <sys_heap_alloc+0x80>  // b.plast
		split_chunks(h, c, c + chunk_sz);
  40694c:	0b0c010c 	add	w12, w8, w12
  406950:	2a0803e1 	mov	w1, w8
  406954:	2a0c03e2 	mov	w2, w12
  406958:	aa0d03e0 	mov	x0, x13
  40695c:	97ffff81 	bl	406760 <split_chunks>
		free_list_add(h, c + chunk_sz);
  406960:	2a0c03e1 	mov	w1, w12
  406964:	aa0d03e0 	mov	x0, x13
  406968:	97ffff1b 	bl	4065d4 <free_list_add>
	void *cmem = &buf[c];
  40696c:	d37d7d08 	ubfiz	x8, x8, #3, #32
  406970:	8b0801a1 	add	x1, x13, x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406974:	91002108 	add	x8, x8, #0x8
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406978:	b9400420 	ldr	w0, [x1, #4]
  40697c:	32000000 	orr	w0, w0, #0x1
  406980:	b9000420 	str	w0, [x1, #4]
  406984:	8b0801a0 	add	x0, x13, x8
	return mem;
  406988:	17ffffde 	b	406900 <sys_heap_alloc+0x14>

000000000040698c <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
  40698c:	aa0203ec 	mov	x12, x2
  406990:	91003c43 	add	x3, x2, #0xf
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
  406994:	cb0103e2 	neg	x2, x1
  406998:	8a01004e 	and	x14, x2, x1
	struct z_heap *h = heap->heap;
  40699c:	f940000d 	ldr	x13, [x0]
	if (align != rew) {
  4069a0:	ea22003f 	bics	xzr, x1, x2
  4069a4:	54000400 	b.eq	406a24 <sys_heap_aligned_alloc+0x98>  // b.none
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
  4069a8:	f10021df 	cmp	x14, #0x8
  4069ac:	aa0e03ef 	mov	x15, x14
  4069b0:	d2800100 	mov	x0, #0x8                   	// #8
  4069b4:	9a8091c0 	csel	x0, x14, x0, ls  // ls = plast
		align -= rew;
  4069b8:	cb0e002e 	sub	x14, x1, x14
{
  4069bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  4069c0:	d10005d2 	sub	x18, x14, #0x1
{
  4069c4:	910003fd 	mov	x29, sp
  4069c8:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  4069cc:	ea0e025f 	tst	x18, x14
  4069d0:	54000380 	b.eq	406a40 <sys_heap_aligned_alloc+0xb4>  // b.none
  4069d4:	d0000073 	adrp	x19, 414000 <__func__.1+0xd>
  4069d8:	911e1673 	add	x19, x19, #0x785
  4069dc:	aa1303e2 	mov	x2, x19
  4069e0:	d0000061 	adrp	x1, 414000 <__func__.1+0xd>
  4069e4:	91214421 	add	x1, x1, #0x851
  4069e8:	52802883 	mov	w3, #0x144                 	// #324
  4069ec:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4069f0:	911a8800 	add	x0, x0, #0x6a2
  4069f4:	94000421 	bl	407a78 <assert_print>
  4069f8:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  4069fc:	9121b000 	add	x0, x0, #0x86c
  406a00:	9400041e 	bl	407a78 <assert_print>
  406a04:	aa1303e0 	mov	x0, x19
  406a08:	52802881 	mov	w1, #0x144                 	// #324
  406a0c:	94000445 	bl	407b20 <assert_post_action>
  406a10:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406a14:	aa1303e1 	mov	x1, x19
  406a18:	911b8000 	add	x0, x0, #0x6e0
  406a1c:	52802882 	mov	w2, #0x144                 	// #324
  406a20:	94000e32 	bl	40a2e8 <posix_print_error_and_exit>
		if (align <= chunk_header_bytes(h)) {
  406a24:	f100203f 	cmp	x1, #0x8
  406a28:	54000068 	b.hi	406a34 <sys_heap_aligned_alloc+0xa8>  // b.pmore
			return sys_heap_alloc(heap, bytes);
  406a2c:	aa0c03e1 	mov	x1, x12
  406a30:	17ffffaf 	b	4068ec <sys_heap_alloc>
		rew = 0;
  406a34:	d280000f 	mov	x15, #0x0                   	// #0
		gap = chunk_header_bytes(h);
  406a38:	d2800100 	mov	x0, #0x8                   	// #8
  406a3c:	17ffffe0 	b	4069bc <sys_heap_aligned_alloc+0x30>

	if (bytes == 0 || size_too_big(h, bytes)) {
  406a40:	b50000cc 	cbnz	x12, 406a58 <sys_heap_aligned_alloc+0xcc>
		return NULL;
  406a44:	d2800009 	mov	x9, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  406a48:	aa0903e0 	mov	x0, x9
  406a4c:	f9400bf3 	ldr	x19, [sp, #16]
  406a50:	a8c27bfd 	ldp	x29, x30, [sp], #32
  406a54:	d65f03c0 	ret
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  406a58:	b94009a1 	ldr	w1, [x13, #8]
	if (bytes == 0 || size_too_big(h, bytes)) {
  406a5c:	eb4c0c3f 	cmp	x1, x12, lsr #3
  406a60:	54ffff29 	b.ls	406a44 <sys_heap_aligned_alloc+0xb8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406a64:	cb0001c1 	sub	x1, x14, x0
	chunkid_t c0 = alloc_chunk(h, padded_sz);
  406a68:	aa0d03e0 	mov	x0, x13
  406a6c:	8b030021 	add	x1, x1, x3
  406a70:	d3438821 	ubfx	x1, x1, #3, #32
  406a74:	97fffe99 	bl	4064d8 <alloc_chunk>
  406a78:	2a0003e7 	mov	w7, w0
	if (c0 == 0) {
  406a7c:	34fffe40 	cbz	w0, 406a44 <sys_heap_aligned_alloc+0xb8>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406a80:	d37d7ce9 	ubfiz	x9, x7, #3, #32
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  406a84:	cb0e03ee 	neg	x14, x14
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  406a88:	91002129 	add	x9, x9, #0x8
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406a8c:	d2800100 	mov	x0, #0x8                   	// #8
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  406a90:	8b0f0129 	add	x9, x9, x15
  406a94:	8b0901a9 	add	x9, x13, x9
  406a98:	8b120129 	add	x9, x9, x18
  406a9c:	8a0e0129 	and	x9, x9, x14
  406aa0:	cb0f0129 	sub	x9, x9, x15
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406aa4:	d100212a 	sub	x10, x9, #0x8
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  406aa8:	8b0c0128 	add	x8, x9, x12
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406aac:	cb0d014a 	sub	x10, x10, x13
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  406ab0:	91001d08 	add	x8, x8, #0x7
  406ab4:	927df108 	and	x8, x8, #0xfffffffffffffff8
	chunkid_t c_end = end - chunk_buf(h);
  406ab8:	cb0d0108 	sub	x8, x8, x13
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  406abc:	9ac00d4a 	sdiv	x10, x10, x0
	chunkid_t c_end = end - chunk_buf(h);
  406ac0:	9343fd08 	asr	x8, x8, #3
	if (c > c0) {
  406ac4:	6b0a00ff 	cmp	w7, w10
  406ac8:	54000102 	b.cs	406ae8 <sys_heap_aligned_alloc+0x15c>  // b.hs, b.nlast
		split_chunks(h, c0, c);
  406acc:	2a0a03e2 	mov	w2, w10
  406ad0:	2a0703e1 	mov	w1, w7
  406ad4:	aa0d03e0 	mov	x0, x13
  406ad8:	97ffff22 	bl	406760 <split_chunks>
		free_list_add(h, c0);
  406adc:	2a0703e1 	mov	w1, w7
  406ae0:	aa0d03e0 	mov	x0, x13
  406ae4:	97fffebc 	bl	4065d4 <free_list_add>
	return c + chunk_size(h, c);
  406ae8:	2a0a03e1 	mov	w1, w10
  406aec:	aa0d03e0 	mov	x0, x13
  406af0:	97fffe5e 	bl	406468 <chunk_size>
  406af4:	0b0a0000 	add	w0, w0, w10
	if (right_chunk(h, c) > c_end) {
  406af8:	6b00011f 	cmp	w8, w0
  406afc:	54000102 	b.cs	406b1c <sys_heap_aligned_alloc+0x190>  // b.hs, b.nlast
		split_chunks(h, c, c_end);
  406b00:	2a0803e2 	mov	w2, w8
  406b04:	2a0a03e1 	mov	w1, w10
  406b08:	aa0d03e0 	mov	x0, x13
  406b0c:	97ffff15 	bl	406760 <split_chunks>
		free_list_add(h, c_end);
  406b10:	2a0803e1 	mov	w1, w8
  406b14:	aa0d03e0 	mov	x0, x13
  406b18:	97fffeaf 	bl	4065d4 <free_list_add>
	void *cmem = &buf[c];
  406b1c:	8b2a4daa 	add	x10, x13, w10, uxtw #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406b20:	b9400540 	ldr	w0, [x10, #4]
  406b24:	32000000 	orr	w0, w0, #0x1
  406b28:	b9000540 	str	w0, [x10, #4]
  406b2c:	17ffffc7 	b	406a48 <sys_heap_aligned_alloc+0xbc>

0000000000406b30 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
  406b30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		/* Must fit in a 15 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
	} else {
		/* Must fit in a 31 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  406b34:	b24087e3 	mov	x3, #0x3ffffffff           	// #17179869183
{
  406b38:	910003fd 	mov	x29, sp
  406b3c:	a90153f3 	stp	x19, x20, [sp, #16]
  406b40:	f90013f5 	str	x21, [sp, #32]
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  406b44:	eb03005f 	cmp	x2, x3
  406b48:	540002a9 	b.ls	406b9c <sys_heap_init+0x6c>  // b.plast
  406b4c:	d0000073 	adrp	x19, 414000 <__func__.1+0xd>
  406b50:	911e1673 	add	x19, x19, #0x785
  406b54:	aa1303e2 	mov	x2, x19
  406b58:	d0000061 	adrp	x1, 414000 <__func__.1+0xd>
  406b5c:	91222421 	add	x1, x1, #0x889
  406b60:	52803dc3 	mov	w3, #0x1ee                 	// #494
  406b64:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406b68:	911a8800 	add	x0, x0, #0x6a2
  406b6c:	940003c3 	bl	407a78 <assert_print>
  406b70:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406b74:	91228c00 	add	x0, x0, #0x8a3
  406b78:	940003c0 	bl	407a78 <assert_print>
  406b7c:	aa1303e0 	mov	x0, x19
  406b80:	52803dc1 	mov	w1, #0x1ee                 	// #494
  406b84:	940003e7 	bl	407b20 <assert_post_action>
  406b88:	52803dc2 	mov	w2, #0x1ee                 	// #494
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
  406b8c:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406b90:	aa1303e1 	mov	x1, x19
  406b94:	911b8000 	add	x0, x0, #0x6e0
  406b98:	94000dd4 	bl	40a2e8 <posix_print_error_and_exit>
  406b9c:	f100205f 	cmp	x2, #0x8
  406ba0:	54000248 	b.hi	406be8 <sys_heap_init+0xb8>  // b.pmore
  406ba4:	d0000073 	adrp	x19, 414000 <__func__.1+0xd>
  406ba8:	911e1673 	add	x19, x19, #0x785
  406bac:	aa1303e2 	mov	x2, x19
  406bb0:	d0000061 	adrp	x1, 414000 <__func__.1+0xd>
  406bb4:	9122e821 	add	x1, x1, #0x8ba
  406bb8:	52803e43 	mov	w3, #0x1f2                 	// #498
  406bbc:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406bc0:	911a8800 	add	x0, x0, #0x6a2
  406bc4:	940003ad 	bl	407a78 <assert_print>
  406bc8:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406bcc:	91236c00 	add	x0, x0, #0x8db
  406bd0:	940003aa 	bl	407a78 <assert_print>
  406bd4:	aa1303e0 	mov	x0, x19
  406bd8:	52803e41 	mov	w1, #0x1f2                 	// #498
  406bdc:	940003d1 	bl	407b20 <assert_post_action>
  406be0:	52803e42 	mov	w2, #0x1f2                 	// #498
  406be4:	17ffffea 	b	406b8c <sys_heap_init+0x5c>
	bytes -= heap_footer_bytes(bytes);
  406be8:	d1002042 	sub	x2, x2, #0x8

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  406bec:	91001c34 	add	x20, x1, #0x7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  406bf0:	8b020033 	add	x19, x1, x2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  406bf4:	927df294 	and	x20, x20, #0xfffffffffffffff8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  406bf8:	927df273 	and	x19, x19, #0xfffffffffffffff8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
  406bfc:	cb140273 	sub	x19, x19, x20
  406c00:	d343fe73 	lsr	x19, x19, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
  406c04:	71000a7f 	cmp	w19, #0x2
  406c08:	54000248 	b.hi	406c50 <sys_heap_init+0x120>  // b.pmore
  406c0c:	d0000073 	adrp	x19, 414000 <__func__.1+0xd>
  406c10:	911e1673 	add	x19, x19, #0x785
  406c14:	aa1303e2 	mov	x2, x19
  406c18:	d0000061 	adrp	x1, 414000 <__func__.1+0xd>
  406c1c:	9123d021 	add	x1, x1, #0x8f4
  406c20:	52803f63 	mov	w3, #0x1fb                 	// #507
  406c24:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406c28:	911a8800 	add	x0, x0, #0x6a2
  406c2c:	94000393 	bl	407a78 <assert_print>
  406c30:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406c34:	91236c00 	add	x0, x0, #0x8db
  406c38:	94000390 	bl	407a78 <assert_print>
  406c3c:	aa1303e0 	mov	x0, x19
  406c40:	52803f61 	mov	w1, #0x1fb                 	// #507
  406c44:	940003b7 	bl	407b20 <assert_post_action>
  406c48:	52803f62 	mov	w2, #0x1fb                 	// #507
  406c4c:	17ffffd0 	b	406b8c <sys_heap_init+0x5c>

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
  406c50:	f9000014 	str	x20, [x0]
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  406c54:	51000660 	sub	w0, w19, #0x1
	return 31 - __builtin_clz(usable_sz);
  406c58:	5ac01000 	clz	w0, w0
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  406c5c:	52800495 	mov	w21, #0x24                  	// #36
  406c60:	4b0002b5 	sub	w21, w21, w0
  406c64:	d28000e1 	mov	x1, #0x7                   	// #7
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
  406c68:	29017e93 	stp	w19, wzr, [x20, #8]
  406c6c:	8b35c835 	add	x21, x1, w21, sxtw #2
  406c70:	d343feb5 	lsr	x21, x21, #3

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
  406c74:	11000aa1 	add	w1, w21, #0x2
  406c78:	6b13003f 	cmp	w1, w19
  406c7c:	54000249 	b.ls	406cc4 <sys_heap_init+0x194>  // b.plast
  406c80:	d0000073 	adrp	x19, 414000 <__func__.1+0xd>
  406c84:	911e1673 	add	x19, x19, #0x785
  406c88:	aa1303e2 	mov	x2, x19
  406c8c:	d0000061 	adrp	x1, 414000 <__func__.1+0xd>
  406c90:	91247421 	add	x1, x1, #0x91d
  406c94:	52804183 	mov	w3, #0x20c                 	// #524
  406c98:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406c9c:	911a8800 	add	x0, x0, #0x6a2
  406ca0:	94000376 	bl	407a78 <assert_print>
  406ca4:	d0000060 	adrp	x0, 414000 <__func__.1+0xd>
  406ca8:	91236c00 	add	x0, x0, #0x8db
  406cac:	94000373 	bl	407a78 <assert_print>
  406cb0:	aa1303e0 	mov	x0, x19
  406cb4:	52804181 	mov	w1, #0x20c                 	// #524
  406cb8:	9400039a 	bl	407b20 <assert_post_action>
  406cbc:	52804182 	mov	w2, #0x20c                 	// #524
  406cc0:	17ffffb3 	b	406b8c <sys_heap_init+0x5c>

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
  406cc4:	52800402 	mov	w2, #0x20                  	// #32
  406cc8:	4b000042 	sub	w2, w2, w0
  406ccc:	52800001 	mov	w1, #0x0                   	// #0
  406cd0:	91004280 	add	x0, x20, #0x10
  406cd4:	d37ef442 	lsl	x2, x2, #2
  406cd8:	97ffe972 	bl	4012a0 <memset@plt>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406cdc:	531f7aa0 	lsl	w0, w21, #1
		((uint32_t *)cmem)[f] = val;
  406ce0:	8b150e82 	add	x2, x20, x21, lsl #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406ce4:	32000000 	orr	w0, w0, #0x1
	void *cmem = &buf[c];
  406ce8:	d37df2a1 	lsl	x1, x21, #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406cec:	2900029f 	stp	wzr, w0, [x20]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  406cf0:	4b150260 	sub	w0, w19, w21
	void *cmem = &buf[c];
  406cf4:	d37d7e73 	ubfiz	x19, x19, #3, #32
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406cf8:	531f7803 	lsl	w3, w0, #1
		((uint32_t *)cmem)[f] = val;
  406cfc:	b9000443 	str	w3, [x2, #4]
  406d00:	b8216a95 	str	w21, [x20, x1]
  406d04:	8b130281 	add	x1, x20, x19
  406d08:	b8336a80 	str	w0, [x20, x19]
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406d0c:	52800020 	mov	w0, #0x1                   	// #1
  406d10:	b9000420 	str	w0, [x1, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
  406d14:	2a1503e1 	mov	w1, w21
  406d18:	aa1403e0 	mov	x0, x20
}
  406d1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  406d20:	f94013f5 	ldr	x21, [sp, #32]
  406d24:	a8c37bfd 	ldp	x29, x30, [sp], #48
	free_list_add(h, chunk0_size);
  406d28:	17fffe2b 	b	4065d4 <free_list_add>

0000000000406d2c <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
  406d2c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  406d30:	910003fd 	mov	x29, sp
  406d34:	a90153f3 	stp	x19, x20, [sp, #16]
  406d38:	aa0203f4 	mov	x20, x2
	size_t count = 0;
  406d3c:	d2800013 	mov	x19, #0x0                   	// #0
{
  406d40:	a9025bf5 	stp	x21, x22, [sp, #32]
  406d44:	aa0003f6 	mov	x22, x0
  406d48:	aa0303f5 	mov	x21, x3
  406d4c:	f9001bf7 	str	x23, [sp, #48]
  406d50:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
  406d54:	8b130280 	add	x0, x20, x19
  406d58:	eb0002bf 	cmp	x21, x0
  406d5c:	54000148 	b.hi	406d84 <outs+0x58>  // b.pmore
  406d60:	b40000f5 	cbz	x21, 406d7c <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
  406d64:	2a1303e0 	mov	w0, w19
}
  406d68:	a94153f3 	ldp	x19, x20, [sp, #16]
  406d6c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406d70:	f9401bf7 	ldr	x23, [sp, #48]
  406d74:	a8c47bfd 	ldp	x29, x30, [sp], #64
  406d78:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
  406d7c:	38736a80 	ldrb	w0, [x20, x19]
  406d80:	34ffff20 	cbz	w0, 406d64 <outs+0x38>
		int rc = out((int)*sp++, ctx);
  406d84:	38736a80 	ldrb	w0, [x20, x19]
  406d88:	aa1703e1 	mov	x1, x23
  406d8c:	d63f02c0 	blr	x22
		if (rc < 0) {
  406d90:	37fffec0 	tbnz	w0, #31, 406d68 <outs+0x3c>
		++count;
  406d94:	91000673 	add	x19, x19, #0x1
  406d98:	17ffffef 	b	406d54 <outs+0x28>

0000000000406d9c <extract_decimal>:
{
  406d9c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  406da0:	910003fd 	mov	x29, sp
  406da4:	a90153f3 	stp	x19, x20, [sp, #16]
  406da8:	aa0003f4 	mov	x20, x0
	const char *sp = *str;
  406dac:	f9400013 	ldr	x19, [x0]
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406db0:	97ffe980 	bl	4013b0 <__ctype_b_loc@plt>
		val = 10U * val + *sp++ - '0';
  406db4:	d2800144 	mov	x4, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406db8:	f9400002 	ldr	x2, [x0]
	size_t val = 0;
  406dbc:	d2800000 	mov	x0, #0x0                   	// #0
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406dc0:	39400263 	ldrb	w3, [x19]
  406dc4:	78637841 	ldrh	w1, [x2, x3, lsl #1]
  406dc8:	375800a1 	tbnz	w1, #11, 406ddc <extract_decimal+0x40>
	*str = sp;
  406dcc:	f9000293 	str	x19, [x20]
}
  406dd0:	a94153f3 	ldp	x19, x20, [sp, #16]
  406dd4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  406dd8:	d65f03c0 	ret
		val = 10U * val + *sp++ - '0';
  406ddc:	9b040c00 	madd	x0, x0, x4, x3
  406de0:	91000673 	add	x19, x19, #0x1
  406de4:	d100c000 	sub	x0, x0, #0x30
  406de8:	17fffff6 	b	406dc0 <extract_decimal+0x24>

0000000000406dec <encode_uint>:
{
  406dec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  406df0:	910003fd 	mov	x29, sp
  406df4:	a90153f3 	stp	x19, x20, [sp, #16]
  406df8:	aa0103f3 	mov	x19, x1
  406dfc:	aa0303f4 	mov	x20, x3
  406e00:	a9025bf5 	stp	x21, x22, [sp, #32]
  406e04:	aa0203f6 	mov	x22, x2
  406e08:	aa0003f5 	mov	x21, x0
	bool upcase = isupper((int)conv->specifier) != 0;
  406e0c:	97ffe969 	bl	4013b0 <__ctype_b_loc@plt>
  406e10:	39400e62 	ldrb	w2, [x19, #3]
  406e14:	f9400000 	ldr	x0, [x0]
  406e18:	39400e61 	ldrb	w1, [x19, #3]
  406e1c:	78627802 	ldrh	w2, [x0, x2, lsl #1]
  406e20:	12180042 	and	w2, w2, #0x100
	switch (specifier) {
  406e24:	7101bc3f 	cmp	w1, #0x6f
  406e28:	54000400 	b.eq	406ea8 <encode_uint+0xbc>  // b.none
  406e2c:	54000388 	b.hi	406e9c <encode_uint+0xb0>  // b.pmore
		return 16;
  406e30:	7101603f 	cmp	w1, #0x58
  406e34:	d2800145 	mov	x5, #0xa                   	// #10
  406e38:	d2800200 	mov	x0, #0x10                  	// #16
  406e3c:	9a8010a5 	csel	x5, x5, x0, ne  // ne = any
	char *bp = bps + (bpe - bps);
  406e40:	aa1403e0 	mov	x0, x20
		unsigned int lsv = (unsigned int)(value % radix);
  406e44:	9ac50aa3 	udiv	x3, x21, x5
  406e48:	9b05d461 	msub	x1, x3, x5, x21
		*--bp = (lsv <= 9) ? ('0' + lsv)
  406e4c:	12001c24 	and	w4, w1, #0xff
  406e50:	f100243f 	cmp	x1, #0x9
  406e54:	54000328 	b.hi	406eb8 <encode_uint+0xcc>  // b.pmore
  406e58:	1100c084 	add	w4, w4, #0x30
  406e5c:	12001c84 	and	w4, w4, #0xff
  406e60:	381ffc04 	strb	w4, [x0, #-1]!
	} while ((value != 0) && (bps < bp));
  406e64:	eb0502bf 	cmp	x21, x5
  406e68:	fa562000 	ccmp	x0, x22, #0x0, cs  // cs = hs, nlast
  406e6c:	54000228 	b.hi	406eb0 <encode_uint+0xc4>  // b.pmore
	if (conv->flag_hash) {
  406e70:	79400261 	ldrh	w1, [x19]
  406e74:	362800c1 	tbz	w1, #5, 406e8c <encode_uint+0xa0>
		if (radix == 8) {
  406e78:	f10020bf 	cmp	x5, #0x8
  406e7c:	540002c1 	b.ne	406ed4 <encode_uint+0xe8>  // b.any
			conv->altform_0 = true;
  406e80:	39400a61 	ldrb	w1, [x19, #2]
  406e84:	321d0021 	orr	w1, w1, #0x8
			conv->altform_0c = true;
  406e88:	39000a61 	strb	w1, [x19, #2]
}
  406e8c:	a94153f3 	ldp	x19, x20, [sp, #16]
  406e90:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406e94:	a8c37bfd 	ldp	x29, x30, [sp], #48
  406e98:	d65f03c0 	ret
	switch (specifier) {
  406e9c:	121c7821 	and	w1, w1, #0xfffffff7
		return 16;
  406ea0:	7101c03f 	cmp	w1, #0x70
  406ea4:	17ffffe4 	b	406e34 <encode_uint+0x48>
	switch (specifier) {
  406ea8:	d2800105 	mov	x5, #0x8                   	// #8
  406eac:	17ffffe5 	b	406e40 <encode_uint+0x54>
		value /= radix;
  406eb0:	aa0303f5 	mov	x21, x3
  406eb4:	17ffffe4 	b	406e44 <encode_uint+0x58>
		*--bp = (lsv <= 9) ? ('0' + lsv)
  406eb8:	1100dc81 	add	w1, w4, #0x37
  406ebc:	11015c84 	add	w4, w4, #0x57
  406ec0:	12001c21 	and	w1, w1, #0xff
  406ec4:	12001c84 	and	w4, w4, #0xff
  406ec8:	7100005f 	cmp	w2, #0x0
  406ecc:	1a810084 	csel	w4, w4, w1, eq  // eq = none
  406ed0:	17ffffe4 	b	406e60 <encode_uint+0x74>
		} else if (radix == 16) {
  406ed4:	f10040bf 	cmp	x5, #0x10
  406ed8:	54fffda1 	b.ne	406e8c <encode_uint+0xa0>  // b.any
			conv->altform_0c = true;
  406edc:	39400a61 	ldrb	w1, [x19, #2]
  406ee0:	321c0021 	orr	w1, w1, #0x10
  406ee4:	17ffffe9 	b	406e88 <encode_uint+0x9c>

0000000000406ee8 <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
  406ee8:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  406eec:	910003fd 	mov	x29, sp
  406ef0:	a9046bf9 	stp	x25, x26, [sp, #64]
  406ef4:	aa0003f9 	mov	x25, x0
  406ef8:	b0000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  406efc:	a90153f3 	stp	x19, x20, [sp, #16]
  406f00:	aa0103fa 	mov	x26, x1
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
  406f04:	d2800013 	mov	x19, #0x0                   	// #0
{
  406f08:	a9025bf5 	stp	x21, x22, [sp, #32]
  406f0c:	aa0203f5 	mov	x21, x2
  406f10:	a90363f7 	stp	x23, x24, [sp, #48]
  406f14:	a90573fb 	stp	x27, x28, [sp, #80]
  406f18:	f9476800 	ldr	x0, [x0, #3792]
  406f1c:	a940607c 	ldp	x28, x24, [x3]
  406f20:	f9400001 	ldr	x1, [x0]
  406f24:	f90067e1 	str	x1, [sp, #200]
  406f28:	d2800001 	mov	x1, #0x0                   	// #0
  406f2c:	b940187b 	ldr	w27, [x3, #24]
  406f30:	f9400860 	ldr	x0, [x3, #16]
  406f34:	f9003be0 	str	x0, [sp, #112]
  406f38:	b9401c60 	ldr	w0, [x3, #28]
  406f3c:	b90067e0 	str	w0, [sp, #100]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
  406f40:	91031be0 	add	x0, sp, #0xc6
  406f44:	f90037e0 	str	x0, [sp, #104]
  406f48:	394002a0 	ldrb	w0, [x21]
  406f4c:	35000140 	cbnz	w0, 406f74 <z_cbvprintf_impl+0x8c>
			OUTC(' ');
			--width;
		}
	}

	return count;
  406f50:	2a1303e0 	mov	w0, w19
#undef OUTS
#undef OUTC
}
  406f54:	b0000121 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  406f58:	f9476821 	ldr	x1, [x1, #3792]
  406f5c:	f94067e3 	ldr	x3, [sp, #200]
  406f60:	f9400022 	ldr	x2, [x1]
  406f64:	eb020063 	subs	x3, x3, x2
  406f68:	d2800002 	mov	x2, #0x0                   	// #0
  406f6c:	54005780 	b.eq	407a5c <z_cbvprintf_impl+0xb74>  // b.none
  406f70:	97ffe8ec 	bl	401320 <__stack_chk_fail@plt>
			OUTC(*fp++);
  406f74:	910006b4 	add	x20, x21, #0x1
		if (*fp != '%') {
  406f78:	7100941f 	cmp	w0, #0x25
  406f7c:	540000c0 	b.eq	406f94 <z_cbvprintf_impl+0xac>  // b.none
			OUTC('%');
  406f80:	aa1a03e1 	mov	x1, x26
  406f84:	d63f0320 	blr	x25
  406f88:	37fffe60 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  406f8c:	91000673 	add	x19, x19, #0x1
			break;
  406f90:	14000140 	b	407490 <z_cbvprintf_impl+0x5a8>
		} state = {
  406f94:	a9097fff 	stp	xzr, xzr, [sp, #144]
  406f98:	a90a7fff 	stp	xzr, xzr, [sp, #160]
	if (*sp == '%') {
  406f9c:	394006a0 	ldrb	w0, [x21, #1]
  406fa0:	7100941f 	cmp	w0, #0x25
  406fa4:	54000661 	b.ne	407070 <z_cbvprintf_impl+0x188>  // b.any
		conv->specifier = *sp++;
  406fa8:	91000ab4 	add	x20, x21, #0x2
  406fac:	39028fe0 	strb	w0, [sp, #163]
		if (conv->width_star) {
  406fb0:	794143e0 	ldrh	w0, [sp, #160]
  406fb4:	364021c0 	tbz	w0, #8, 4073ec <z_cbvprintf_impl+0x504>
			width = va_arg(ap, int);
  406fb8:	37f8205b 	tbnz	w27, #31, 4073c0 <z_cbvprintf_impl+0x4d8>
  406fbc:	91002f81 	add	x1, x28, #0xb
  406fc0:	aa1c03e0 	mov	x0, x28
  406fc4:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  406fc8:	b9400016 	ldr	w22, [x0]
			if (width < 0) {
  406fcc:	36f800b6 	tbz	w22, #31, 406fe0 <z_cbvprintf_impl+0xf8>
				conv->flag_dash = true;
  406fd0:	794143e0 	ldrh	w0, [sp, #160]
				width = -width;
  406fd4:	4b1603f6 	neg	w22, w22
				conv->flag_dash = true;
  406fd8:	321e0000 	orr	w0, w0, #0x4
  406fdc:	790143e0 	strh	w0, [sp, #160]
		if (conv->prec_star) {
  406fe0:	794143e0 	ldrh	w0, [sp, #160]
  406fe4:	36502220 	tbz	w0, #10, 407428 <z_cbvprintf_impl+0x540>
			int arg = va_arg(ap, int);
  406fe8:	37f820bb 	tbnz	w27, #31, 4073fc <z_cbvprintf_impl+0x514>
  406fec:	91002f81 	add	x1, x28, #0xb
  406ff0:	aa1c03e0 	mov	x0, x28
  406ff4:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  406ff8:	b9400017 	ldr	w23, [x0]
			if (arg < 0) {
  406ffc:	36f800b7 	tbz	w23, #31, 407010 <z_cbvprintf_impl+0x128>
				conv->prec_present = false;
  407000:	794143e0 	ldrh	w0, [sp, #160]
		int precision = -1;
  407004:	12800017 	mov	w23, #0xffffffff            	// #-1
				conv->prec_present = false;
  407008:	12167800 	and	w0, w0, #0xfffffdff
  40700c:	790143e0 	strh	w0, [sp, #160]
		conv->pad0_value = 0;
  407010:	f80a43ff 	stur	xzr, [sp, #164]
			= (enum specifier_cat_enum)conv->specifier_cat;
  407014:	f94053e1 	ldr	x1, [sp, #160]
		enum specifier_cat_enum specifier_cat
  407018:	53104820 	ubfx	w0, w1, #16, #3
			= (enum length_mod_enum)conv->length_mod;
  40701c:	530b3821 	ubfx	w1, w1, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
  407020:	7100041f 	cmp	w0, #0x1
  407024:	54002721 	b.ne	407508 <z_cbvprintf_impl+0x620>  // b.any
			switch (length_mod) {
  407028:	51000c22 	sub	w2, w1, #0x3
  40702c:	7100105f 	cmp	w2, #0x4
  407030:	54002048 	b.hi	407438 <z_cbvprintf_impl+0x550>  // b.pmore
  407034:	90000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  407038:	91164000 	add	x0, x0, #0x590
  40703c:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
  407040:	10000062 	adr	x2, 40704c <z_cbvprintf_impl+0x164>
  407044:	8b20a840 	add	x0, x2, w0, sxth #2
  407048:	d61f0000 	br	x0
		switch (*sp) {
  40704c:	7100b43f 	cmp	w1, #0x2d
  407050:	540000a0 	b.eq	407064 <z_cbvprintf_impl+0x17c>  // b.none
  407054:	7100c03f 	cmp	w1, #0x30
  407058:	540001e1 	b.ne	407094 <z_cbvprintf_impl+0x1ac>  // b.any
			conv->flag_zero = true;
  40705c:	321a0000 	orr	w0, w0, #0x40
  407060:	14000002 	b	407068 <z_cbvprintf_impl+0x180>
			conv->flag_dash = true;
  407064:	321e0000 	orr	w0, w0, #0x4
			++sp;
  407068:	91000694 	add	x20, x20, #0x1
			conv->flag_zero = true;
  40706c:	790143e0 	strh	w0, [sp, #160]
		switch (*sp) {
  407070:	39400281 	ldrb	w1, [x20]
  407074:	794143e0 	ldrh	w0, [sp, #160]
  407078:	7100ac3f 	cmp	w1, #0x2b
  40707c:	54000b00 	b.eq	4071dc <z_cbvprintf_impl+0x2f4>  // b.none
  407080:	54fffe68 	b.hi	40704c <z_cbvprintf_impl+0x164>  // b.pmore
  407084:	7100803f 	cmp	w1, #0x20
  407088:	54000ae0 	b.eq	4071e4 <z_cbvprintf_impl+0x2fc>  // b.none
  40708c:	71008c3f 	cmp	w1, #0x23
  407090:	54000ae0 	b.eq	4071ec <z_cbvprintf_impl+0x304>  // b.none
	if (conv->flag_zero && conv->flag_dash) {
  407094:	b940a3e1 	ldr	w1, [sp, #160]
  407098:	52800882 	mov	w2, #0x44                  	// #68
  40709c:	0a020021 	and	w1, w1, w2
  4070a0:	6b02003f 	cmp	w1, w2
  4070a4:	54000061 	b.ne	4070b0 <z_cbvprintf_impl+0x1c8>  // b.any
		conv->flag_zero = false;
  4070a8:	12197800 	and	w0, w0, #0xffffffbf
  4070ac:	790143e0 	strh	w0, [sp, #160]
	conv->width_present = true;
  4070b0:	794143e0 	ldrh	w0, [sp, #160]
  4070b4:	f90047f4 	str	x20, [sp, #136]
  4070b8:	32190001 	orr	w1, w0, #0x80
  4070bc:	790143e1 	strh	w1, [sp, #160]
	if (*sp == '*') {
  4070c0:	39400281 	ldrb	w1, [x20]
  4070c4:	7100a83f 	cmp	w1, #0x2a
  4070c8:	54000961 	b.ne	4071f4 <z_cbvprintf_impl+0x30c>  // b.any
		return ++sp;
  4070cc:	91000694 	add	x20, x20, #0x1
		conv->width_star = true;
  4070d0:	32190400 	orr	w0, w0, #0x180
  4070d4:	790143e0 	strh	w0, [sp, #160]
	sp = extract_prec(conv, sp);
  4070d8:	f90047f4 	str	x20, [sp, #136]
	conv->prec_present = (*sp == '.');
  4070dc:	39400280 	ldrb	w0, [x20]
  4070e0:	7100b81f 	cmp	w0, #0x2e
  4070e4:	794143e0 	ldrh	w0, [sp, #160]
  4070e8:	1a9f17e1 	cset	w1, eq  // eq = none
  4070ec:	33170020 	bfi	w0, w1, #9, #1
  4070f0:	790143e0 	strh	w0, [sp, #160]
	if (!conv->prec_present) {
  4070f4:	54000121 	b.ne	407118 <z_cbvprintf_impl+0x230>  // b.any
	++sp;
  4070f8:	91000681 	add	x1, x20, #0x1
  4070fc:	f90047e1 	str	x1, [sp, #136]
	if (*sp == '*') {
  407100:	39400681 	ldrb	w1, [x20, #1]
  407104:	7100a83f 	cmp	w1, #0x2a
  407108:	54000961 	b.ne	407234 <z_cbvprintf_impl+0x34c>  // b.any
		return ++sp;
  40710c:	91000a94 	add	x20, x20, #0x2
		conv->prec_star = true;
  407110:	32160000 	orr	w0, w0, #0x400
  407114:	790143e0 	strh	w0, [sp, #160]
	switch (*sp) {
  407118:	aa1403e1 	mov	x1, x20
  40711c:	38401420 	ldrb	w0, [x1], #1
  407120:	7101b01f 	cmp	w0, #0x6c
  407124:	54000d00 	b.eq	4072c4 <z_cbvprintf_impl+0x3dc>  // b.none
  407128:	54000a68 	b.hi	407274 <z_cbvprintf_impl+0x38c>  // b.pmore
  40712c:	7101a01f 	cmp	w0, #0x68
  407130:	54000b00 	b.eq	407290 <z_cbvprintf_impl+0x3a8>  // b.none
  407134:	7101a81f 	cmp	w0, #0x6a
  407138:	54000d60 	b.eq	4072e4 <z_cbvprintf_impl+0x3fc>  // b.none
  40713c:	7101301f 	cmp	w0, #0x4c
  407140:	54000de0 	b.eq	4072fc <z_cbvprintf_impl+0x414>  // b.none
  407144:	aa1403e1 	mov	x1, x20
	conv->specifier = *sp++;
  407148:	aa0103f4 	mov	x20, x1
  40714c:	38401682 	ldrb	w2, [x20], #1
  407150:	39028fe2 	strb	w2, [sp, #163]
	switch (conv->specifier) {
  407154:	7101a45f 	cmp	w2, #0x69
  407158:	54001028 	b.hi	40735c <z_cbvprintf_impl+0x474>  // b.pmore
  40715c:	7101005f 	cmp	w2, #0x40
  407160:	54001069 	b.ls	40736c <z_cbvprintf_impl+0x484>  // b.plast
  407164:	51010441 	sub	w1, w2, #0x41
  407168:	d2800020 	mov	x0, #0x1                   	// #1
  40716c:	d2800e23 	mov	x3, #0x71                  	// #113
  407170:	9ac12001 	lsl	x1, x0, x1
  407174:	f2c00e23 	movk	x3, #0x71, lsl #32
  407178:	ea03003f 	tst	x1, x3
  40717c:	54001021 	b.ne	407380 <z_cbvprintf_impl+0x498>  // b.any
  407180:	d2c02103 	mov	x3, #0x10800000000         	// #1133871366144
  407184:	ea03003f 	tst	x1, x3
  407188:	540000c1 	b.ne	4071a0 <z_cbvprintf_impl+0x2b8>  // b.any
  40718c:	d2a01000 	mov	x0, #0x800000              	// #8388608
  407190:	f2c00080 	movk	x0, #0x4, lsl #32
  407194:	ea00003f 	tst	x1, x0
  407198:	54000ea0 	b.eq	40736c <z_cbvprintf_impl+0x484>  // b.none
  40719c:	52800040 	mov	w0, #0x2                   	// #2
		conv->specifier_cat = SPECIFIER_SINT;
  4071a0:	39428be1 	ldrb	w1, [sp, #162]
  4071a4:	33000801 	bfxil	w1, w0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
  4071a8:	794143e0 	ldrh	w0, [sp, #160]
		conv->specifier_cat = SPECIFIER_SINT;
  4071ac:	39028be1 	strb	w1, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  4071b0:	12150c01 	and	w1, w0, #0x7800
  4071b4:	7140103f 	cmp	w1, #0x4, lsl #12
  4071b8:	54000061 	b.ne	4071c4 <z_cbvprintf_impl+0x2dc>  // b.any
			conv->invalid = true;
  4071bc:	32000000 	orr	w0, w0, #0x1
  4071c0:	790143e0 	strh	w0, [sp, #160]
		if (conv->specifier == 'c') {
  4071c4:	71018c5f 	cmp	w2, #0x63
  4071c8:	54000d81 	b.ne	407378 <z_cbvprintf_impl+0x490>  // b.any
		if (conv->length_mod != LENGTH_NONE) {
  4071cc:	794143e0 	ldrh	w0, [sp, #160]
  4071d0:	72150c1f 	tst	w0, #0x7800
  4071d4:	1a9f07e0 	cset	w0, ne  // ne = any
  4071d8:	1400006e 	b	407390 <z_cbvprintf_impl+0x4a8>
			conv->flag_plus = true;
  4071dc:	321d0000 	orr	w0, w0, #0x8
  4071e0:	17ffffa2 	b	407068 <z_cbvprintf_impl+0x180>
			conv->flag_space = true;
  4071e4:	321c0000 	orr	w0, w0, #0x10
  4071e8:	17ffffa0 	b	407068 <z_cbvprintf_impl+0x180>
			conv->flag_hash = true;
  4071ec:	321b0000 	orr	w0, w0, #0x20
  4071f0:	17ffff9e 	b	407068 <z_cbvprintf_impl+0x180>
	size_t width = extract_decimal(&sp);
  4071f4:	910223e0 	add	x0, sp, #0x88
  4071f8:	97fffee9 	bl	406d9c <extract_decimal>
	if (sp != wp) {
  4071fc:	f94047e1 	ldr	x1, [sp, #136]
  407200:	eb14003f 	cmp	x1, x20
  407204:	54fff6a0 	b.eq	4070d8 <z_cbvprintf_impl+0x1f0>  // b.none
		conv->width_value = width;
  407208:	b900a7e0 	str	w0, [sp, #164]
				      || (width != (size_t)conv->width_value));
  40720c:	37f80100 	tbnz	w0, #31, 40722c <z_cbvprintf_impl+0x344>
  407210:	eb20c01f 	cmp	x0, w0, sxtw
  407214:	1a9f07e2 	cset	w2, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
  407218:	794143e0 	ldrh	w0, [sp, #160]
  40721c:	aa0103f4 	mov	x20, x1
  407220:	331f0040 	bfi	w0, w2, #1, #1
  407224:	790143e0 	strh	w0, [sp, #160]
  407228:	17ffffac 	b	4070d8 <z_cbvprintf_impl+0x1f0>
				      || (width != (size_t)conv->width_value));
  40722c:	52800022 	mov	w2, #0x1                   	// #1
  407230:	17fffffa 	b	407218 <z_cbvprintf_impl+0x330>
	size_t prec = extract_decimal(&sp);
  407234:	910223e0 	add	x0, sp, #0x88
  407238:	97fffed9 	bl	406d9c <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
  40723c:	f94053e1 	ldr	x1, [sp, #160]
	conv->prec_value = prec;
  407240:	b900abe0 	str	w0, [sp, #168]
	conv->unsupported |= ((conv->prec_value < 0)
  407244:	53010421 	ubfx	w1, w1, #1, #1
			      || (prec != (size_t)conv->prec_value));
  407248:	37f80120 	tbnz	w0, #31, 40726c <z_cbvprintf_impl+0x384>
  40724c:	eb20c01f 	cmp	x0, w0, sxtw
  407250:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
  407254:	2a000020 	orr	w0, w1, w0
  407258:	794143e1 	ldrh	w1, [sp, #160]
	return sp;
  40725c:	f94047f4 	ldr	x20, [sp, #136]
	conv->unsupported |= ((conv->prec_value < 0)
  407260:	331f0001 	bfi	w1, w0, #1, #1
  407264:	790143e1 	strh	w1, [sp, #160]
	return sp;
  407268:	17ffffac 	b	407118 <z_cbvprintf_impl+0x230>
			      || (prec != (size_t)conv->prec_value));
  40726c:	52800020 	mov	w0, #0x1                   	// #1
  407270:	17fffff9 	b	407254 <z_cbvprintf_impl+0x36c>
	switch (*sp) {
  407274:	7101d01f 	cmp	w0, #0x74
  407278:	540003c0 	b.eq	4072f0 <z_cbvprintf_impl+0x408>  // b.none
  40727c:	7101e81f 	cmp	w0, #0x7a
  407280:	54fff621 	b.ne	407144 <z_cbvprintf_impl+0x25c>  // b.any
		conv->length_mod = LENGTH_Z;
  407284:	794143e0 	ldrh	w0, [sp, #160]
  407288:	528000c2 	mov	w2, #0x6                   	// #6
  40728c:	1400000b 	b	4072b8 <z_cbvprintf_impl+0x3d0>
		if (*++sp == 'h') {
  407290:	39400680 	ldrb	w0, [x20, #1]
  407294:	7101a01f 	cmp	w0, #0x68
  407298:	794143e0 	ldrh	w0, [sp, #160]
  40729c:	540000c1 	b.ne	4072b4 <z_cbvprintf_impl+0x3cc>  // b.any
			conv->length_mod = LENGTH_HH;
  4072a0:	52800021 	mov	w1, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
  4072a4:	33150c20 	bfi	w0, w1, #11, #4
			++sp;
  4072a8:	91000a81 	add	x1, x20, #0x2
			conv->length_mod = LENGTH_LL;
  4072ac:	790143e0 	strh	w0, [sp, #160]
			++sp;
  4072b0:	17ffffa6 	b	407148 <z_cbvprintf_impl+0x260>
			conv->length_mod = LENGTH_H;
  4072b4:	52800042 	mov	w2, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
  4072b8:	33150c40 	bfi	w0, w2, #11, #4
		conv->unsupported = true;
  4072bc:	790143e0 	strh	w0, [sp, #160]
		break;
  4072c0:	17ffffa2 	b	407148 <z_cbvprintf_impl+0x260>
		if (*++sp == 'l') {
  4072c4:	39400680 	ldrb	w0, [x20, #1]
  4072c8:	7101b01f 	cmp	w0, #0x6c
  4072cc:	794143e0 	ldrh	w0, [sp, #160]
  4072d0:	54000061 	b.ne	4072dc <z_cbvprintf_impl+0x3f4>  // b.any
			conv->length_mod = LENGTH_LL;
  4072d4:	52800081 	mov	w1, #0x4                   	// #4
  4072d8:	17fffff3 	b	4072a4 <z_cbvprintf_impl+0x3bc>
			conv->length_mod = LENGTH_L;
  4072dc:	52800062 	mov	w2, #0x3                   	// #3
  4072e0:	17fffff6 	b	4072b8 <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_J;
  4072e4:	794143e0 	ldrh	w0, [sp, #160]
  4072e8:	528000a2 	mov	w2, #0x5                   	// #5
  4072ec:	17fffff3 	b	4072b8 <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_T;
  4072f0:	794143e0 	ldrh	w0, [sp, #160]
  4072f4:	528000e2 	mov	w2, #0x7                   	// #7
  4072f8:	17fffff0 	b	4072b8 <z_cbvprintf_impl+0x3d0>
		conv->unsupported = true;
  4072fc:	794143e0 	ldrh	w0, [sp, #160]
  407300:	128f0042 	mov	w2, #0xffff87fd            	// #-30723
  407304:	0a020000 	and	w0, w0, w2
  407308:	52880042 	mov	w2, #0x4002                	// #16386
  40730c:	2a020000 	orr	w0, w0, w2
  407310:	17ffffeb 	b	4072bc <z_cbvprintf_impl+0x3d4>
  407314:	d2800020 	mov	x0, #0x1                   	// #1
  407318:	9ac12000 	lsl	x0, x0, x1
	switch (conv->specifier) {
  40731c:	d2809041 	mov	x1, #0x482                 	// #1154
  407320:	ea01001f 	tst	x0, x1
  407324:	54fff3c1 	b.ne	40719c <z_cbvprintf_impl+0x2b4>  // b.any
  407328:	d2800481 	mov	x1, #0x24                  	// #36
  40732c:	ea01001f 	tst	x0, x1
  407330:	540003e1 	b.ne	4073ac <z_cbvprintf_impl+0x4c4>  // b.any
  407334:	360001c0 	tbz	w0, #0, 40736c <z_cbvprintf_impl+0x484>
		conv->specifier_cat = SPECIFIER_PTR;
  407338:	39428be0 	ldrb	w0, [sp, #162]
  40733c:	52800061 	mov	w1, #0x3                   	// #3
  407340:	33000820 	bfxil	w0, w1, #0, #3
  407344:	39028be0 	strb	w0, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  407348:	794143e0 	ldrh	w0, [sp, #160]
  40734c:	12150c00 	and	w0, w0, #0x7800
  407350:	7140101f 	cmp	w0, #0x4, lsl #12
  407354:	1a9f17e0 	cset	w0, eq  // eq = none
  407358:	1400000e 	b	407390 <z_cbvprintf_impl+0x4a8>
	switch (conv->specifier) {
  40735c:	5101b841 	sub	w1, w2, #0x6e
  407360:	12001c21 	and	w1, w1, #0xff
  407364:	7100283f 	cmp	w1, #0xa
  407368:	54fffd69 	b.ls	407314 <z_cbvprintf_impl+0x42c>  // b.plast
		conv->invalid = true;
  40736c:	794143e0 	ldrh	w0, [sp, #160]
  407370:	32000000 	orr	w0, w0, #0x1
  407374:	790143e0 	strh	w0, [sp, #160]
	bool unsupported = false;
  407378:	52800000 	mov	w0, #0x0                   	// #0
  40737c:	14000005 	b	407390 <z_cbvprintf_impl+0x4a8>
		conv->specifier_cat = SPECIFIER_FP;
  407380:	39428be1 	ldrb	w1, [sp, #162]
  407384:	52800082 	mov	w2, #0x4                   	// #4
  407388:	33000841 	bfxil	w1, w2, #0, #3
  40738c:	39028be1 	strb	w1, [sp, #162]
	conv->unsupported |= unsupported;
  407390:	f94053e1 	ldr	x1, [sp, #160]
  407394:	d3410421 	ubfx	x1, x1, #1, #1
  407398:	2a010000 	orr	w0, w0, w1
  40739c:	794143e1 	ldrh	w1, [sp, #160]
  4073a0:	331f0001 	bfi	w1, w0, #1, #1
  4073a4:	790143e1 	strh	w1, [sp, #160]
	return sp;
  4073a8:	17ffff02 	b	406fb0 <z_cbvprintf_impl+0xc8>
		conv->specifier_cat = SPECIFIER_PTR;
  4073ac:	39428be0 	ldrb	w0, [sp, #162]
  4073b0:	52800061 	mov	w1, #0x3                   	// #3
  4073b4:	33000820 	bfxil	w0, w1, #0, #3
  4073b8:	39028be0 	strb	w0, [sp, #162]
  4073bc:	17ffff84 	b	4071cc <z_cbvprintf_impl+0x2e4>
			width = va_arg(ap, int);
  4073c0:	11002361 	add	w1, w27, #0x8
  4073c4:	7100003f 	cmp	w1, #0x0
  4073c8:	540000cd 	b.le	4073e0 <z_cbvprintf_impl+0x4f8>
  4073cc:	91002f82 	add	x2, x28, #0xb
  4073d0:	aa1c03e0 	mov	x0, x28
  4073d4:	2a0103fb 	mov	w27, w1
  4073d8:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  4073dc:	17fffefb 	b	406fc8 <z_cbvprintf_impl+0xe0>
  4073e0:	8b3bc300 	add	x0, x24, w27, sxtw
  4073e4:	2a0103fb 	mov	w27, w1
  4073e8:	17fffef8 	b	406fc8 <z_cbvprintf_impl+0xe0>
			width = conv->width_value;
  4073ec:	b940a7f6 	ldr	w22, [sp, #164]
  4073f0:	f279001f 	tst	x0, #0x80
  4073f4:	5a9f12d6 	csinv	w22, w22, wzr, ne  // ne = any
  4073f8:	17fffefa 	b	406fe0 <z_cbvprintf_impl+0xf8>
			int arg = va_arg(ap, int);
  4073fc:	11002361 	add	w1, w27, #0x8
  407400:	7100003f 	cmp	w1, #0x0
  407404:	540000cd 	b.le	40741c <z_cbvprintf_impl+0x534>
  407408:	91002f82 	add	x2, x28, #0xb
  40740c:	aa1c03e0 	mov	x0, x28
  407410:	2a0103fb 	mov	w27, w1
  407414:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  407418:	17fffef8 	b	406ff8 <z_cbvprintf_impl+0x110>
  40741c:	8b3bc300 	add	x0, x24, w27, sxtw
  407420:	2a0103fb 	mov	w27, w1
  407424:	17fffef5 	b	406ff8 <z_cbvprintf_impl+0x110>
			precision = conv->prec_value;
  407428:	b940abf7 	ldr	w23, [sp, #168]
  40742c:	f277001f 	tst	x0, #0x200
  407430:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
  407434:	17fffef7 	b	407010 <z_cbvprintf_impl+0x128>
				value->sint = va_arg(ap, int);
  407438:	37f8031b 	tbnz	w27, #31, 407498 <z_cbvprintf_impl+0x5b0>
  40743c:	91002f82 	add	x2, x28, #0xb
  407440:	2a1b03e3 	mov	w3, w27
  407444:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407448:	b9800380 	ldrsw	x0, [x28]
  40744c:	f9004be0 	str	x0, [sp, #144]
				break;
  407450:	2a0303fb 	mov	w27, w3
  407454:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  407458:	7100043f 	cmp	w1, #0x1
  40745c:	540004e1 	b.ne	4074f8 <z_cbvprintf_impl+0x610>  // b.any
				value->sint = (signed char)value->sint;
  407460:	93401c00 	sxtb	x0, w0
				value->uint = (unsigned short)value->uint;
  407464:	f9004be0 	str	x0, [sp, #144]
		if (conv->invalid || conv->unsupported) {
  407468:	b940a3e0 	ldr	w0, [sp, #160]
  40746c:	f240041f 	tst	x0, #0x3
  407470:	540015a0 	b.eq	407724 <z_cbvprintf_impl+0x83c>  // b.none
			OUTS(sp, fp);
  407474:	aa1403e3 	mov	x3, x20
  407478:	aa1503e2 	mov	x2, x21
  40747c:	aa1a03e1 	mov	x1, x26
  407480:	aa1903e0 	mov	x0, x25
  407484:	97fffe2a 	bl	406d2c <outs>
  407488:	37ffd660 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  40748c:	8b20c273 	add	x19, x19, w0, sxtw
			continue;
  407490:	aa1403f5 	mov	x21, x20
  407494:	17fffead 	b	406f48 <z_cbvprintf_impl+0x60>
				value->sint = va_arg(ap, int);
  407498:	11002363 	add	w3, w27, #0x8
  40749c:	7100007f 	cmp	w3, #0x0
  4074a0:	5400008d 	b.le	4074b0 <z_cbvprintf_impl+0x5c8>
  4074a4:	91002f82 	add	x2, x28, #0xb
  4074a8:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4074ac:	17ffffe7 	b	407448 <z_cbvprintf_impl+0x560>
  4074b0:	aa1c03e2 	mov	x2, x28
  4074b4:	8b3bc31c 	add	x28, x24, w27, sxtw
  4074b8:	17ffffe4 	b	407448 <z_cbvprintf_impl+0x560>
					(sint_value_type)va_arg(ap, ptrdiff_t);
  4074bc:	37f800db 	tbnz	w27, #31, 4074d4 <z_cbvprintf_impl+0x5ec>
  4074c0:	91003f82 	add	x2, x28, #0xf
  4074c4:	2a1b03e3 	mov	w3, w27
  4074c8:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4074cc:	f9400380 	ldr	x0, [x28]
  4074d0:	17ffffdf 	b	40744c <z_cbvprintf_impl+0x564>
  4074d4:	11002363 	add	w3, w27, #0x8
  4074d8:	7100007f 	cmp	w3, #0x0
  4074dc:	5400008d 	b.le	4074ec <z_cbvprintf_impl+0x604>
  4074e0:	91003f82 	add	x2, x28, #0xf
  4074e4:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4074e8:	17fffff9 	b	4074cc <z_cbvprintf_impl+0x5e4>
  4074ec:	aa1c03e2 	mov	x2, x28
  4074f0:	8b3bc31c 	add	x28, x24, w27, sxtw
  4074f4:	17fffff6 	b	4074cc <z_cbvprintf_impl+0x5e4>
			} else if (length_mod == LENGTH_H) {
  4074f8:	7100083f 	cmp	w1, #0x2
  4074fc:	54fffb61 	b.ne	407468 <z_cbvprintf_impl+0x580>  // b.any
				value->sint = (short)value->sint;
  407500:	93403c00 	sxth	x0, w0
  407504:	17ffffd8 	b	407464 <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_UINT) {
  407508:	7100081f 	cmp	w0, #0x2
  40750c:	540008c1 	b.ne	407624 <z_cbvprintf_impl+0x73c>  // b.any
			switch (length_mod) {
  407510:	51000c22 	sub	w2, w1, #0x3
  407514:	7100105f 	cmp	w2, #0x4
  407518:	540000e8 	b.hi	407534 <z_cbvprintf_impl+0x64c>  // b.pmore
  40751c:	90000060 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  407520:	91167000 	add	x0, x0, #0x59c
  407524:	38624800 	ldrb	w0, [x0, w2, uxtw]
  407528:	10000062 	adr	x2, 407534 <z_cbvprintf_impl+0x64c>
  40752c:	8b208840 	add	x0, x2, w0, sxtb #2
  407530:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
  407534:	37f8019b 	tbnz	w27, #31, 407564 <z_cbvprintf_impl+0x67c>
  407538:	91002f82 	add	x2, x28, #0xb
  40753c:	2a1b03e3 	mov	w3, w27
  407540:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407544:	b9400380 	ldr	w0, [x28]
  407548:	f9004be0 	str	x0, [sp, #144]
				break;
  40754c:	2a0303fb 	mov	w27, w3
  407550:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  407554:	7100043f 	cmp	w1, #0x1
  407558:	540005e1 	b.ne	407614 <z_cbvprintf_impl+0x72c>  // b.any
				value->uint = (unsigned char)value->uint;
  40755c:	92401c00 	and	x0, x0, #0xff
  407560:	17ffffc1 	b	407464 <z_cbvprintf_impl+0x57c>
				value->uint = va_arg(ap, unsigned int);
  407564:	11002363 	add	w3, w27, #0x8
  407568:	7100007f 	cmp	w3, #0x0
  40756c:	5400008d 	b.le	40757c <z_cbvprintf_impl+0x694>
  407570:	91002f82 	add	x2, x28, #0xb
  407574:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407578:	17fffff3 	b	407544 <z_cbvprintf_impl+0x65c>
  40757c:	aa1c03e2 	mov	x2, x28
  407580:	8b3bc31c 	add	x28, x24, w27, sxtw
  407584:	17fffff0 	b	407544 <z_cbvprintf_impl+0x65c>
				if ((!WCHAR_IS_SIGNED)
  407588:	39428fe0 	ldrb	w0, [sp, #163]
  40758c:	71018c1f 	cmp	w0, #0x63
  407590:	54000ac1 	b.ne	4076e8 <z_cbvprintf_impl+0x800>  // b.any
					value->uint = (wchar_t)va_arg(ap,
  407594:	37f8011b 	tbnz	w27, #31, 4075b4 <z_cbvprintf_impl+0x6cc>
  407598:	91002f80 	add	x0, x28, #0xb
  40759c:	2a1b03e2 	mov	w2, w27
  4075a0:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4075a4:	b9400383 	ldr	w3, [x28]
			value->ptr = va_arg(ap, void *);
  4075a8:	2a0203fb 	mov	w27, w2
  4075ac:	f9004be3 	str	x3, [sp, #144]
  4075b0:	1400003e 	b	4076a8 <z_cbvprintf_impl+0x7c0>
					value->uint = (wchar_t)va_arg(ap,
  4075b4:	11002362 	add	w2, w27, #0x8
  4075b8:	7100005f 	cmp	w2, #0x0
  4075bc:	5400008d 	b.le	4075cc <z_cbvprintf_impl+0x6e4>
  4075c0:	91002f80 	add	x0, x28, #0xb
  4075c4:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4075c8:	17fffff7 	b	4075a4 <z_cbvprintf_impl+0x6bc>
  4075cc:	aa1c03e0 	mov	x0, x28
  4075d0:	8b3bc31c 	add	x28, x24, w27, sxtw
  4075d4:	17fffff4 	b	4075a4 <z_cbvprintf_impl+0x6bc>
					(uint_value_type)va_arg(ap, size_t);
  4075d8:	37f800db 	tbnz	w27, #31, 4075f0 <z_cbvprintf_impl+0x708>
  4075dc:	91003f82 	add	x2, x28, #0xf
  4075e0:	2a1b03e3 	mov	w3, w27
  4075e4:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4075e8:	f9400380 	ldr	x0, [x28]
  4075ec:	17ffffd7 	b	407548 <z_cbvprintf_impl+0x660>
  4075f0:	11002363 	add	w3, w27, #0x8
  4075f4:	7100007f 	cmp	w3, #0x0
  4075f8:	5400008d 	b.le	407608 <z_cbvprintf_impl+0x720>
  4075fc:	91003f82 	add	x2, x28, #0xf
  407600:	927df042 	and	x2, x2, #0xfffffffffffffff8
  407604:	17fffff9 	b	4075e8 <z_cbvprintf_impl+0x700>
  407608:	aa1c03e2 	mov	x2, x28
  40760c:	8b3bc31c 	add	x28, x24, w27, sxtw
  407610:	17fffff6 	b	4075e8 <z_cbvprintf_impl+0x700>
			} else if (length_mod == LENGTH_H) {
  407614:	7100083f 	cmp	w1, #0x2
  407618:	54fff281 	b.ne	407468 <z_cbvprintf_impl+0x580>  // b.any
				value->uint = (unsigned short)value->uint;
  40761c:	92403c00 	and	x0, x0, #0xffff
  407620:	17ffff91 	b	407464 <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_FP) {
  407624:	7100101f 	cmp	w0, #0x4
  407628:	540005c1 	b.ne	4076e0 <z_cbvprintf_impl+0x7f8>  // b.any
				value->ldbl = va_arg(ap, long double);
  40762c:	b94067e0 	ldr	w0, [sp, #100]
			if (length_mod == LENGTH_UPPER_L) {
  407630:	7100203f 	cmp	w1, #0x8
  407634:	540002c1 	b.ne	40768c <z_cbvprintf_impl+0x7a4>  // b.any
				value->ldbl = va_arg(ap, long double);
  407638:	37f80120 	tbnz	w0, #31, 40765c <z_cbvprintf_impl+0x774>
  40763c:	91003f80 	add	x0, x28, #0xf
  407640:	b94067e2 	ldr	w2, [sp, #100]
  407644:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  407648:	9100401c 	add	x28, x0, #0x10
  40764c:	3dc00000 	ldr	q0, [x0]
  407650:	b90067e2 	str	w2, [sp, #100]
  407654:	3d8027e0 	str	q0, [sp, #144]
  407658:	17ffff84 	b	407468 <z_cbvprintf_impl+0x580>
  40765c:	b94067e0 	ldr	w0, [sp, #100]
  407660:	11004002 	add	w2, w0, #0x10
  407664:	7100005f 	cmp	w2, #0x0
  407668:	540000ad 	b.le	40767c <z_cbvprintf_impl+0x794>
  40766c:	91003f80 	add	x0, x28, #0xf
  407670:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  407674:	9100401c 	add	x28, x0, #0x10
  407678:	17fffff5 	b	40764c <z_cbvprintf_impl+0x764>
  40767c:	f9403be3 	ldr	x3, [sp, #112]
  407680:	b94067e0 	ldr	w0, [sp, #100]
  407684:	8b20c060 	add	x0, x3, w0, sxtw
  407688:	17fffff1 	b	40764c <z_cbvprintf_impl+0x764>
				value->dbl = va_arg(ap, double);
  40768c:	37f80120 	tbnz	w0, #31, 4076b0 <z_cbvprintf_impl+0x7c8>
  407690:	91003f80 	add	x0, x28, #0xf
  407694:	b94067e2 	ldr	w2, [sp, #100]
  407698:	927df000 	and	x0, x0, #0xfffffffffffffff8
  40769c:	fd400380 	ldr	d0, [x28]
  4076a0:	b90067e2 	str	w2, [sp, #100]
  4076a4:	fd004be0 	str	d0, [sp, #144]
			value->ptr = va_arg(ap, void *);
  4076a8:	aa0003fc 	mov	x28, x0
  4076ac:	17ffff6f 	b	407468 <z_cbvprintf_impl+0x580>
				value->dbl = va_arg(ap, double);
  4076b0:	b94067e0 	ldr	w0, [sp, #100]
  4076b4:	11004002 	add	w2, w0, #0x10
  4076b8:	7100005f 	cmp	w2, #0x0
  4076bc:	5400008d 	b.le	4076cc <z_cbvprintf_impl+0x7e4>
  4076c0:	91003f80 	add	x0, x28, #0xf
  4076c4:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4076c8:	17fffff5 	b	40769c <z_cbvprintf_impl+0x7b4>
  4076cc:	f9403be4 	ldr	x4, [sp, #112]
  4076d0:	aa1c03e0 	mov	x0, x28
  4076d4:	b94067e3 	ldr	w3, [sp, #100]
  4076d8:	8b23c09c 	add	x28, x4, w3, sxtw
  4076dc:	17fffff0 	b	40769c <z_cbvprintf_impl+0x7b4>
		} else if (specifier_cat == SPECIFIER_PTR) {
  4076e0:	71000c1f 	cmp	w0, #0x3
  4076e4:	54ffec21 	b.ne	407468 <z_cbvprintf_impl+0x580>  // b.any
			value->ptr = va_arg(ap, void *);
  4076e8:	37f800db 	tbnz	w27, #31, 407700 <z_cbvprintf_impl+0x818>
  4076ec:	91003f80 	add	x0, x28, #0xf
  4076f0:	2a1b03e2 	mov	w2, w27
  4076f4:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4076f8:	f9400383 	ldr	x3, [x28]
  4076fc:	17ffffab 	b	4075a8 <z_cbvprintf_impl+0x6c0>
  407700:	11002362 	add	w2, w27, #0x8
  407704:	7100005f 	cmp	w2, #0x0
  407708:	5400008d 	b.le	407718 <z_cbvprintf_impl+0x830>
  40770c:	91003f80 	add	x0, x28, #0xf
  407710:	927df000 	and	x0, x0, #0xfffffffffffffff8
  407714:	17fffff9 	b	4076f8 <z_cbvprintf_impl+0x810>
  407718:	aa1c03e0 	mov	x0, x28
  40771c:	8b3bc31c 	add	x28, x24, w27, sxtw
  407720:	17fffff6 	b	4076f8 <z_cbvprintf_impl+0x810>
		switch (conv->specifier) {
  407724:	39428fe0 	ldrb	w0, [sp, #163]
  407728:	7101e01f 	cmp	w0, #0x78
  40772c:	54ffeb28 	b.hi	407490 <z_cbvprintf_impl+0x5a8>  // b.pmore
  407730:	7101881f 	cmp	w0, #0x62
  407734:	540000e8 	b.hi	407750 <z_cbvprintf_impl+0x868>  // b.pmore
  407738:	7100941f 	cmp	w0, #0x25
  40773c:	54ffc220 	b.eq	406f80 <z_cbvprintf_impl+0x98>  // b.none
  407740:	7101601f 	cmp	w0, #0x58
  407744:	54ffea61 	b.ne	407490 <z_cbvprintf_impl+0x5a8>  // b.any
  407748:	52800006 	mov	w6, #0x0                   	// #0
  40774c:	14000043 	b	407858 <z_cbvprintf_impl+0x970>
  407750:	51018c00 	sub	w0, w0, #0x63
  407754:	7100541f 	cmp	w0, #0x15
  407758:	54ffe9c8 	b.hi	407490 <z_cbvprintf_impl+0x5a8>  // b.pmore
  40775c:	90000062 	adrp	x2, 413000 <z_timer_expiration_handler+0x68>
  407760:	91169042 	add	x2, x2, #0x5a4
  407764:	78605842 	ldrh	w2, [x2, w0, uxtw #1]
  407768:	10000060 	adr	x0, 407774 <z_cbvprintf_impl+0x88c>
  40776c:	8b22a802 	add	x2, x0, w2, sxth #2
  407770:	d61f0040 	br	x2
			bps = (const char *)value->ptr;
  407774:	f9404bf5 	ldr	x21, [sp, #144]
			if (precision >= 0) {
  407778:	37f80497 	tbnz	w23, #31, 407808 <z_cbvprintf_impl+0x920>
				len = strnlen(bps, precision);
  40777c:	93407ee1 	sxtw	x1, w23
  407780:	aa1503e0 	mov	x0, x21
  407784:	97ffe697 	bl	4011e0 <strnlen@plt>
			bpe = bps + len;
  407788:	8b0002b7 	add	x23, x21, x0
		char sign = 0;
  40778c:	52800006 	mov	w6, #0x0                   	// #0
		if (bps == NULL) {
  407790:	b4ffe815 	cbz	x21, 407490 <z_cbvprintf_impl+0x5a8>
		size_t nj_len = (bpe - bps);
  407794:	cb1502e0 	sub	x0, x23, x21
		if (sign != 0) {
  407798:	34000046 	cbz	w6, 4077a0 <z_cbvprintf_impl+0x8b8>
			nj_len += 1U;
  40779c:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
  4077a0:	39428be2 	ldrb	w2, [sp, #162]
  4077a4:	36200ce2 	tbz	w2, #4, 407940 <z_cbvprintf_impl+0xa58>
			nj_len += 2U;
  4077a8:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
  4077ac:	b980a7e1 	ldrsw	x1, [sp, #164]
  4077b0:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
  4077b4:	36300062 	tbz	w2, #6, 4077c0 <z_cbvprintf_impl+0x8d8>
			nj_len += conv->pad0_pre_exp;
  4077b8:	b980abe1 	ldrsw	x1, [sp, #168]
  4077bc:	8b010000 	add	x0, x0, x1
		if (width > 0) {
  4077c0:	710002df 	cmp	w22, #0x0
  4077c4:	54000dad 	b.le	407978 <z_cbvprintf_impl+0xa90>
			width -= (int)nj_len;
  4077c8:	4b0002d6 	sub	w22, w22, w0
			if (!conv->flag_dash) {
  4077cc:	f94053e0 	ldr	x0, [sp, #160]
  4077d0:	721e001f 	tst	w0, #0x4
  4077d4:	54000d21 	b.ne	407978 <z_cbvprintf_impl+0xa90>  // b.any
				if (conv->flag_zero) {
  4077d8:	794143e0 	ldrh	w0, [sp, #160]
  4077dc:	36301280 	tbz	w0, #6, 407a2c <z_cbvprintf_impl+0xb44>
					if (sign != 0) {
  4077e0:	340012a6 	cbz	w6, 407a34 <z_cbvprintf_impl+0xb4c>
						OUTC(sign);
  4077e4:	aa1a03e1 	mov	x1, x26
  4077e8:	2a0603e0 	mov	w0, w6
  4077ec:	d63f0320 	blr	x25
  4077f0:	37ffbb20 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  4077f4:	91000673 	add	x19, x19, #0x1
					pad = '0';
  4077f8:	52800602 	mov	w2, #0x30                  	// #48
						OUTC(sign);
  4077fc:	52800006 	mov	w6, #0x0                   	// #0
					pad = '0';
  407800:	2a1603e0 	mov	w0, w22
  407804:	1400005a 	b	40796c <z_cbvprintf_impl+0xa84>
				len = strlen(bps);
  407808:	aa1503e0 	mov	x0, x21
  40780c:	97ffe665 	bl	4011a0 <strlen@plt>
  407810:	17ffffde 	b	407788 <z_cbvprintf_impl+0x8a0>
			bps = buf;
  407814:	9102c3f5 	add	x21, sp, #0xb0
			bpe = buf + 1;
  407818:	9102c7f7 	add	x23, sp, #0xb1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  40781c:	f9404be0 	ldr	x0, [sp, #144]
  407820:	3902c3e0 	strb	w0, [sp, #176]
			break;
  407824:	52800006 	mov	w6, #0x0                   	// #0
  407828:	17ffffdb 	b	407794 <z_cbvprintf_impl+0x8ac>
			if (conv->flag_plus) {
  40782c:	794143e0 	ldrh	w0, [sp, #160]
			} else if (conv->flag_space) {
  407830:	d3441006 	ubfx	x6, x0, #4, #1
  407834:	f27d001f 	tst	x0, #0x8
  407838:	52800560 	mov	w0, #0x2b                  	// #43
  40783c:	531b68c6 	lsl	w6, w6, #5
  407840:	1a8000c6 	csel	w6, w6, w0, eq  // eq = none
			sint = value->sint;
  407844:	f9404be0 	ldr	x0, [sp, #144]
			if (sint < 0) {
  407848:	b6f80080 	tbz	x0, #63, 407858 <z_cbvprintf_impl+0x970>
				value->uint = (uint_value_type)-sint;
  40784c:	cb0003e0 	neg	x0, x0
				sign = '-';
  407850:	528005a6 	mov	w6, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
  407854:	f9004be0 	str	x0, [sp, #144]
			bps = encode_uint(value->uint, conv, buf, bpe);
  407858:	f94037e3 	ldr	x3, [sp, #104]
  40785c:	9102c3e2 	add	x2, sp, #0xb0
  407860:	f9404be0 	ldr	x0, [sp, #144]
  407864:	910283e1 	add	x1, sp, #0xa0
  407868:	b9007be6 	str	w6, [sp, #120]
  40786c:	97fffd60 	bl	406dec <encode_uint>
  407870:	aa0003f5 	mov	x21, x0
  407874:	b9407be6 	ldr	w6, [sp, #120]
			if (precision >= 0) {
  407878:	37f80157 	tbnz	w23, #31, 4078a0 <z_cbvprintf_impl+0x9b8>
				size_t len = bpe - bps;
  40787c:	f94037e0 	ldr	x0, [sp, #104]
				conv->flag_zero = false;
  407880:	794143e1 	ldrh	w1, [sp, #160]
				size_t len = bpe - bps;
  407884:	cb150000 	sub	x0, x0, x21
				conv->flag_zero = false;
  407888:	12197821 	and	w1, w1, #0xffffffbf
  40788c:	790143e1 	strh	w1, [sp, #160]
				if (len < (size_t)precision) {
  407890:	eb37c01f 	cmp	x0, w23, sxtw
  407894:	54000062 	b.cs	4078a0 <z_cbvprintf_impl+0x9b8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
  407898:	4b0002e0 	sub	w0, w23, w0
  40789c:	b900a7e0 	str	w0, [sp, #164]
		const char *bpe = buf + sizeof(buf);
  4078a0:	f94037f7 	ldr	x23, [sp, #104]
  4078a4:	17ffffbb 	b	407790 <z_cbvprintf_impl+0x8a8>
			if (value->ptr != NULL) {
  4078a8:	f9404be0 	ldr	x0, [sp, #144]
  4078ac:	b4000400 	cbz	x0, 40792c <z_cbvprintf_impl+0xa44>
				bps = encode_uint((uintptr_t)value->ptr, conv,
  4078b0:	f94037e3 	ldr	x3, [sp, #104]
  4078b4:	910283e1 	add	x1, sp, #0xa0
  4078b8:	9102c3e2 	add	x2, sp, #0xb0
  4078bc:	97fffd4c 	bl	406dec <encode_uint>
  4078c0:	aa0003f5 	mov	x21, x0
				conv->altform_0c = true;
  4078c4:	794147e0 	ldrh	w0, [sp, #162]
  4078c8:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
  4078cc:	52800006 	mov	w6, #0x0                   	// #0
				conv->altform_0c = true;
  4078d0:	0a010000 	and	w0, w0, w1
  4078d4:	528f0201 	mov	w1, #0x7810                	// #30736
  4078d8:	2a010000 	orr	w0, w0, w1
  4078dc:	790147e0 	strh	w0, [sp, #162]
				goto prec_int_pad0;
  4078e0:	17ffffe6 	b	407878 <z_cbvprintf_impl+0x990>
				store_count(conv, value->ptr, count);
  4078e4:	93407e60 	sxtw	x0, w19
  4078e8:	f9404be2 	ldr	x2, [sp, #144]
	switch ((enum length_mod_enum)conv->length_mod) {
  4078ec:	71001c3f 	cmp	w1, #0x7
  4078f0:	54ffdd08 	b.hi	407490 <z_cbvprintf_impl+0x5a8>  // b.pmore
  4078f4:	90000063 	adrp	x3, 413000 <z_timer_expiration_handler+0x68>
  4078f8:	91174063 	add	x3, x3, #0x5d0
  4078fc:	38614863 	ldrb	w3, [x3, w1, uxtw]
  407900:	10000061 	adr	x1, 40790c <z_cbvprintf_impl+0xa24>
  407904:	8b238823 	add	x3, x1, w3, sxtb #2
  407908:	d61f0060 	br	x3
		*(int *)dp = count;
  40790c:	b9000040 	str	w0, [x2]
		break;
  407910:	17fffee0 	b	407490 <z_cbvprintf_impl+0x5a8>
		*(signed char *)dp = (signed char)count;
  407914:	39000053 	strb	w19, [x2]
		break;
  407918:	17fffede 	b	407490 <z_cbvprintf_impl+0x5a8>
		*(short *)dp = (short)count;
  40791c:	79000053 	strh	w19, [x2]
		break;
  407920:	17fffedc 	b	407490 <z_cbvprintf_impl+0x5a8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
  407924:	f9000040 	str	x0, [x2]
		break;
  407928:	17fffeda 	b	407490 <z_cbvprintf_impl+0x5a8>
			bps = "(nil)";
  40792c:	b0000075 	adrp	x21, 414000 <__func__.1+0xd>
			bpe = bps + 5;
  407930:	b0000077 	adrp	x23, 414000 <__func__.1+0xd>
			bps = "(nil)";
  407934:	912522b5 	add	x21, x21, #0x948
			bpe = bps + 5;
  407938:	912536f7 	add	x23, x23, #0x94d
  40793c:	17ffffba 	b	407824 <z_cbvprintf_impl+0x93c>
		} else if (conv->altform_0) {
  407940:	361ff362 	tbz	w2, #3, 4077ac <z_cbvprintf_impl+0x8c4>
			nj_len += 1U;
  407944:	91000400 	add	x0, x0, #0x1
  407948:	17ffff99 	b	4077ac <z_cbvprintf_impl+0x8c4>
  40794c:	290f1be2 	stp	w2, w6, [sp, #120]
					OUTC(pad);
  407950:	aa1a03e1 	mov	x1, x26
  407954:	2a0203e0 	mov	w0, w2
  407958:	d63f0320 	blr	x25
  40795c:	37ffafc0 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  407960:	294f1be2 	ldp	w2, w6, [sp, #120]
  407964:	91000673 	add	x19, x19, #0x1
				while (width-- > 0) {
  407968:	2a1603e0 	mov	w0, w22
  40796c:	510006d6 	sub	w22, w22, #0x1
  407970:	7100001f 	cmp	w0, #0x0
  407974:	54fffecc 	b.gt	40794c <z_cbvprintf_impl+0xa64>
		if (sign != 0) {
  407978:	340000c6 	cbz	w6, 407990 <z_cbvprintf_impl+0xaa8>
			OUTC(sign);
  40797c:	aa1a03e1 	mov	x1, x26
  407980:	2a0603e0 	mov	w0, w6
  407984:	d63f0320 	blr	x25
  407988:	37ffae60 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  40798c:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c | conv->altform_0) {
  407990:	f94053e0 	ldr	x0, [sp, #160]
  407994:	d3545001 	ubfx	x1, x0, #20, #1
  407998:	d3534c00 	ubfx	x0, x0, #19, #1
  40799c:	2a000020 	orr	w0, w1, w0
  4079a0:	360000c0 	tbz	w0, #0, 4079b8 <z_cbvprintf_impl+0xad0>
				OUTC('0');
  4079a4:	aa1a03e1 	mov	x1, x26
  4079a8:	52800600 	mov	w0, #0x30                  	// #48
  4079ac:	d63f0320 	blr	x25
  4079b0:	37ffad20 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  4079b4:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c) {
  4079b8:	39428be0 	ldrb	w0, [sp, #162]
  4079bc:	362000c0 	tbz	w0, #4, 4079d4 <z_cbvprintf_impl+0xaec>
				OUTC(conv->specifier);
  4079c0:	39428fe0 	ldrb	w0, [sp, #163]
  4079c4:	aa1a03e1 	mov	x1, x26
  4079c8:	d63f0320 	blr	x25
  4079cc:	37ffac40 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  4079d0:	91000673 	add	x19, x19, #0x1
			while (pad_len-- > 0) {
  4079d4:	b940a7e2 	ldr	w2, [sp, #164]
  4079d8:	0b130042 	add	w2, w2, w19
  4079dc:	4b130040 	sub	w0, w2, w19
  4079e0:	7100001f 	cmp	w0, #0x0
  4079e4:	540002cc 	b.gt	407a3c <z_cbvprintf_impl+0xb54>
			OUTS(bps, bpe);
  4079e8:	aa1703e3 	mov	x3, x23
  4079ec:	aa1503e2 	mov	x2, x21
  4079f0:	aa1a03e1 	mov	x1, x26
  4079f4:	aa1903e0 	mov	x0, x25
  4079f8:	97fffccd 	bl	406d2c <outs>
  4079fc:	37ffaac0 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  407a00:	8b20c273 	add	x19, x19, w0, sxtw
		while (width > 0) {
  407a04:	0b1302d6 	add	w22, w22, w19
  407a08:	4b1302c0 	sub	w0, w22, w19
  407a0c:	7100001f 	cmp	w0, #0x0
  407a10:	54ffd40d 	b.le	407490 <z_cbvprintf_impl+0x5a8>
			OUTC(' ');
  407a14:	aa1a03e1 	mov	x1, x26
  407a18:	52800400 	mov	w0, #0x20                  	// #32
  407a1c:	d63f0320 	blr	x25
  407a20:	37ffa9a0 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  407a24:	91000673 	add	x19, x19, #0x1
			--width;
  407a28:	17fffff8 	b	407a08 <z_cbvprintf_impl+0xb20>
				char pad = ' ';
  407a2c:	52800402 	mov	w2, #0x20                  	// #32
  407a30:	17ffff74 	b	407800 <z_cbvprintf_impl+0x918>
					pad = '0';
  407a34:	52800602 	mov	w2, #0x30                  	// #48
  407a38:	17ffff72 	b	407800 <z_cbvprintf_impl+0x918>
  407a3c:	b9007be2 	str	w2, [sp, #120]
				OUTC('0');
  407a40:	aa1a03e1 	mov	x1, x26
  407a44:	52800600 	mov	w0, #0x30                  	// #48
  407a48:	d63f0320 	blr	x25
  407a4c:	37ffa840 	tbnz	w0, #31, 406f54 <z_cbvprintf_impl+0x6c>
  407a50:	b9407be2 	ldr	w2, [sp, #120]
  407a54:	91000673 	add	x19, x19, #0x1
  407a58:	17ffffe1 	b	4079dc <z_cbvprintf_impl+0xaf4>
}
  407a5c:	a94153f3 	ldp	x19, x20, [sp, #16]
  407a60:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407a64:	a94363f7 	ldp	x23, x24, [sp, #48]
  407a68:	a9446bf9 	ldp	x25, x26, [sp, #64]
  407a6c:	a94573fb 	ldp	x27, x28, [sp, #80]
  407a70:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  407a74:	d65f03c0 	ret

0000000000407a78 <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
  407a78:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  407a7c:	910003fd 	mov	x29, sp
  407a80:	a90e8be1 	stp	x1, x2, [sp, #232]
  407a84:	90000121 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  407a88:	f9476821 	ldr	x1, [x1, #3792]
  407a8c:	3d801be0 	str	q0, [sp, #96]
  407a90:	3d801fe1 	str	q1, [sp, #112]
  407a94:	3d8023e2 	str	q2, [sp, #128]
  407a98:	3d8027e3 	str	q3, [sp, #144]
  407a9c:	3d802be4 	str	q4, [sp, #160]
  407aa0:	3d802fe5 	str	q5, [sp, #176]
  407aa4:	3d8033e6 	str	q6, [sp, #192]
  407aa8:	3d8037e7 	str	q7, [sp, #208]
  407aac:	a90f93e3 	stp	x3, x4, [sp, #248]
  407ab0:	a9109be5 	stp	x5, x6, [sp, #264]
  407ab4:	f9008fe7 	str	x7, [sp, #280]
  407ab8:	f9400022 	ldr	x2, [x1]
  407abc:	f9002fe2 	str	x2, [sp, #88]
  407ac0:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  407ac4:	910483e1 	add	x1, sp, #0x120
  407ac8:	a90387e1 	stp	x1, x1, [sp, #56]
  407acc:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  407ad0:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  407ad4:	f90027e1 	str	x1, [sp, #72]
  407ad8:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  407adc:	b90053e1 	str	w1, [sp, #80]
  407ae0:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  407ae4:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  407ae8:	910043e1 	add	x1, sp, #0x10
  407aec:	ad400440 	ldp	q0, q1, [x2]
  407af0:	ad000420 	stp	q0, q1, [x1]
  407af4:	97fffa1b 	bl	406360 <vprintk>

	va_end(ap);
}
  407af8:	90000120 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  407afc:	f9476800 	ldr	x0, [x0, #3792]
  407b00:	f9402fe2 	ldr	x2, [sp, #88]
  407b04:	f9400001 	ldr	x1, [x0]
  407b08:	eb010042 	subs	x2, x2, x1
  407b0c:	d2800001 	mov	x1, #0x0                   	// #0
  407b10:	54000040 	b.eq	407b18 <assert_print+0xa0>  // b.none
  407b14:	97ffe603 	bl	401320 <__stack_chk_fail@plt>
  407b18:	a8d27bfd 	ldp	x29, x30, [sp], #288
  407b1c:	d65f03c0 	ret

0000000000407b20 <assert_post_action>:
{
  407b20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	k_panic();
  407b24:	52800562 	mov	w2, #0x2b                  	// #43
  407b28:	b0000061 	adrp	x1, 414000 <__func__.1+0xd>
{
  407b2c:	910003fd 	mov	x29, sp
	k_panic();
  407b30:	91253821 	add	x1, x1, #0x94e
  407b34:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407b38:	911ad800 	add	x0, x0, #0x6b6
  407b3c:	97ffffcf 	bl	407a78 <assert_print>
}
  407b40:	a8c17bfd 	ldp	x29, x30, [sp], #16
	k_panic();
  407b44:	d2800001 	mov	x1, #0x0                   	// #0
  407b48:	52800080 	mov	w0, #0x4                   	// #4
  407b4c:	1400169e 	b	40d5c4 <z_fatal_error>

0000000000407b50 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_EXPERIMENTAL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  407b50:	d65f03c0 	ret

0000000000407b54 <dummy_timestamp>:
static void msg_process(union log_msg_generic *msg);

static log_timestamp_t dummy_timestamp(void)
{
	return 0;
}
  407b54:	52800000 	mov	w0, #0x0                   	// #0
  407b58:	d65f03c0 	ret

0000000000407b5c <default_get_timestamp>:

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
  407b5c:	14001615 	b	40d3b0 <sys_clock_cycle_get_32>

0000000000407b60 <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  407b60:	f9400400 	ldr	x0, [x0, #8]
}
  407b64:	39402400 	ldrb	w0, [x0, #9]
  407b68:	d65f03c0 	ret

0000000000407b6c <log_backend_is_ready>:
	if (backend->api->is_ready != NULL) {
  407b6c:	f9400001 	ldr	x1, [x0]
  407b70:	f9401021 	ldr	x1, [x1, #32]
  407b74:	b4000061 	cbz	x1, 407b80 <log_backend_is_ready+0x14>
		return backend->api->is_ready(backend);
  407b78:	aa0103f0 	mov	x16, x1
  407b7c:	d61f0200 	br	x16
}
  407b80:	52800000 	mov	w0, #0x0                   	// #0
  407b84:	d65f03c0 	ret

0000000000407b88 <z_log_init.isra.0>:
	}

	return mask;
}

static uint32_t z_log_init(bool blocking, bool can_sleep)
  407b88:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  407b8c:	910003fd 	mov	x29, sp
  407b90:	a9025bf5 	stp	x21, x22, [sp, #32]
	STRUCT_SECTION_COUNT(log_backend, &cnt);
  407b94:	90000136 	adrp	x22, 42b000 <__FRAME_END__+0x1007c>
  407b98:	90000135 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
  407b9c:	f947fed6 	ldr	x22, [x22, #4088]
  407ba0:	a90153f3 	stp	x19, x20, [sp, #16]
  407ba4:	f947b2b3 	ldr	x19, [x21, #3936]
  407ba8:	a9046bf9 	stp	x25, x26, [sp, #64]
  407bac:	12001c19 	and	w25, w0, #0xff
  407bb0:	cb1302c0 	sub	x0, x22, x19
  407bb4:	a90363f7 	stp	x23, x24, [sp, #48]
  407bb8:	d345fc00 	lsr	x0, x0, #5

	if (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY)) {
		return 0;
	}

	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
  407bbc:	7100241f 	cmp	w0, #0x9
  407bc0:	54000249 	b.ls	407c08 <z_log_init.isra.0+0x80>  // b.plast
  407bc4:	b0000073 	adrp	x19, 414000 <__func__.1+0xd>
  407bc8:	9125c673 	add	x19, x19, #0x971
  407bcc:	aa1303e2 	mov	x2, x19
  407bd0:	52802323 	mov	w3, #0x119                 	// #281
  407bd4:	b0000061 	adrp	x1, 414000 <__func__.1+0xd>
  407bd8:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407bdc:	91267821 	add	x1, x1, #0x99e
  407be0:	911a8800 	add	x0, x0, #0x6a2
  407be4:	97ffffa5 	bl	407a78 <assert_print>
  407be8:	aa1303e0 	mov	x0, x19
  407bec:	52802321 	mov	w1, #0x119                 	// #281
  407bf0:	97ffffcc 	bl	407b20 <assert_post_action>
  407bf4:	52802322 	mov	w2, #0x119                 	// #281
		z_log_links_initiate();
	}


	/* Assign ids to backends. */
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407bf8:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407bfc:	aa1303e1 	mov	x1, x19
  407c00:	911b8000 	add	x0, x0, #0x6e0
  407c04:	940009b9 	bl	40a2e8 <posix_print_error_and_exit>
  407c08:	12001c37 	and	w23, w1, #0xff
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  407c0c:	d2800020 	mov	x0, #0x1                   	// #1
  407c10:	b0000121 	adrp	x1, 42c000 <__dso_handle>
  407c14:	912d6021 	add	x1, x1, #0xb58
  407c18:	97ffe67e 	bl	401610 <__aarch64_ldadd8_acq_rel>
	if (atomic_inc(&initialized) != 0) {
  407c1c:	b40005c0 	cbz	x0, 407cd4 <z_log_init.isra.0+0x14c>
			}
		}
	}

	return mask;
}
  407c20:	a94153f3 	ldp	x19, x20, [sp, #16]
  407c24:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407c28:	a94363f7 	ldp	x23, x24, [sp, #48]
  407c2c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  407c30:	a8c57bfd 	ldp	x29, x30, [sp], #80
  407c34:	d65f03c0 	ret
		if (backend->autostart) {
  407c38:	39406260 	ldrb	w0, [x19, #24]
  407c3c:	340001e0 	cbz	w0, 407c78 <z_log_init.isra.0+0xf0>
	if (backend->api->init) {
  407c40:	f9400260 	ldr	x0, [x19]
  407c44:	f9400c01 	ldr	x1, [x0, #24]
  407c48:	b4000061 	cbz	x1, 407c54 <z_log_init.isra.0+0xcc>
		backend->api->init(backend);
  407c4c:	aa1303e0 	mov	x0, x19
  407c50:	d63f0020 	blr	x1
			if (log_backend_is_ready(backend) == 0) {
  407c54:	aa1303e0 	mov	x0, x19
  407c58:	97ffffc5 	bl	407b6c <log_backend_is_ready>
  407c5c:	35000360 	cbnz	w0, 407cc8 <z_log_init.isra.0+0x140>
				log_backend_enable(backend,
  407c60:	f9400660 	ldr	x0, [x19, #8]
  407c64:	52800082 	mov	w2, #0x4                   	// #4
  407c68:	f9400001 	ldr	x1, [x0]
  407c6c:	aa1303e0 	mov	x0, x19
  407c70:	94000125 	bl	408104 <log_backend_enable>
			i++;
  407c74:	11000718 	add	w24, w24, #0x1
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407c78:	91008273 	add	x19, x19, #0x20
  407c7c:	eb16027f 	cmp	x19, x22
  407c80:	54000329 	b.ls	407ce4 <z_log_init.isra.0+0x15c>  // b.plast
  407c84:	b0000073 	adrp	x19, 414000 <__func__.1+0xd>
  407c88:	9125c673 	add	x19, x19, #0x971
  407c8c:	aa1303e2 	mov	x2, x19
  407c90:	b0000061 	adrp	x1, 414000 <__func__.1+0xd>
  407c94:	91270821 	add	x1, x1, #0x9c2
  407c98:	528024c3 	mov	w3, #0x126                 	// #294
  407c9c:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407ca0:	911a8800 	add	x0, x0, #0x6a2
  407ca4:	97ffff75 	bl	407a78 <assert_print>
  407ca8:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407cac:	91278c00 	add	x0, x0, #0x9e3
  407cb0:	97ffff72 	bl	407a78 <assert_print>
  407cb4:	aa1303e0 	mov	x0, x19
  407cb8:	528024c1 	mov	w1, #0x126                 	// #294
  407cbc:	97ffff99 	bl	407b20 <assert_post_action>
  407cc0:	528024c2 	mov	w2, #0x126                 	// #294
  407cc4:	17ffffcd 	b	407bf8 <z_log_init.isra.0+0x70>
				mask |= BIT(i);
  407cc8:	9ad82340 	lsl	x0, x26, x24
  407ccc:	2a000294 	orr	w20, w20, w0
  407cd0:	17ffffe9 	b	407c74 <z_log_init.isra.0+0xec>
	int i = 0;
  407cd4:	52800018 	mov	w24, #0x0                   	// #0
	uint32_t mask = 0;
  407cd8:	52800014 	mov	w20, #0x0                   	// #0
				mask |= BIT(i);
  407cdc:	d280003a 	mov	x26, #0x1                   	// #1
  407ce0:	17ffffe7 	b	407c7c <z_log_init.isra.0+0xf4>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407ce4:	54fffaa3 	b.cc	407c38 <z_log_init.isra.0+0xb0>  // b.lo, b.ul, b.last
	if (blocking) {
  407ce8:	34fff9d9 	cbz	w25, 407c20 <z_log_init.isra.0+0x98>
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407cec:	f947b2b5 	ldr	x21, [x21, #3936]
		mask_cpy &= ~BIT(i);
  407cf0:	d2800039 	mov	x25, #0x1                   	// #1
		while (mask) {
  407cf4:	34fff974 	cbz	w20, 407c20 <z_log_init.isra.0+0x98>
  407cf8:	2a1403f8 	mov	w24, w20
		uint32_t i = __builtin_ctz(mask_cpy);
  407cfc:	5ac00280 	rbit	w0, w20
  407d00:	5ac01000 	clz	w0, w0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407d04:	d37b1416 	ubfiz	x22, x0, #5, #6
		mask_cpy &= ~BIT(i);
  407d08:	9ac02321 	lsl	x1, x25, x0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407d0c:	8b1602b6 	add	x22, x21, x22
		mask_cpy &= ~BIT(i);
  407d10:	2a2103fa 	mvn	w26, w1
  407d14:	0a210294 	bic	w20, w20, w1
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  407d18:	394062c1 	ldrb	w1, [x22, #24]
  407d1c:	34000181 	cbz	w1, 407d4c <z_log_init.isra.0+0x1c4>
	STRUCT_SECTION_GET(log_backend, idx, &backend);
  407d20:	937b7c00 	sbfiz	x0, x0, #5, #32
  407d24:	8b150013 	add	x19, x0, x21
  407d28:	aa1303e0 	mov	x0, x19
  407d2c:	97ffff90 	bl	407b6c <log_backend_is_ready>
  407d30:	350000e0 	cbnz	w0, 407d4c <z_log_init.isra.0+0x1c4>
			log_backend_enable(backend,
  407d34:	f94006c0 	ldr	x0, [x22, #8]
			mask &= ~BIT(i);
  407d38:	0a1a0318 	and	w24, w24, w26
			log_backend_enable(backend,
  407d3c:	52800082 	mov	w2, #0x4                   	// #4
  407d40:	f9400001 	ldr	x1, [x0]
  407d44:	aa1303e0 	mov	x0, x19
  407d48:	940000ef 	bl	408104 <log_backend_enable>
	while (mask_cpy) {
  407d4c:	35fffd94 	cbnz	w20, 407cfc <z_log_init.isra.0+0x174>
			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
  407d50:	34000077 	cbz	w23, 407d5c <z_log_init.isra.0+0x1d4>
	return z_impl_k_sleep(timeout);
  407d54:	d2800020 	mov	x0, #0x1                   	// #1
  407d58:	940028d7 	bl	4120b4 <z_impl_k_sleep>
  407d5c:	2a1803f4 	mov	w20, w24
  407d60:	17ffffe5 	b	407cf4 <z_log_init.isra.0+0x16c>

0000000000407d64 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(void)
{
  407d64:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
				COND_CODE_1(CONFIG_LOG_PROCESS_THREAD,
					K_MSEC(CONFIG_LOG_PROCESS_THREAD_STARTUP_DELAY_MS),
					K_NO_WAIT));
		k_thread_name_set(&logging_thread, "logging");
	} else {
		(void)z_log_init(false, false);
  407d68:	52800001 	mov	w1, #0x0                   	// #0
  407d6c:	52800000 	mov	w0, #0x0                   	// #0
{
  407d70:	910003fd 	mov	x29, sp
		(void)z_log_init(false, false);
  407d74:	97ffff85 	bl	407b88 <z_log_init.isra.0>
	}

	return 0;
}
  407d78:	52800000 	mov	w0, #0x0                   	// #0
  407d7c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  407d80:	d65f03c0 	ret

0000000000407d84 <log_format_func_t_get>:
}
  407d84:	90000121 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  407d88:	9124e021 	add	x1, x1, #0x938
  407d8c:	f8605820 	ldr	x0, [x1, w0, uxtw #3]
  407d90:	d65f03c0 	ret

0000000000407d94 <z_log_vprintk>:
{
  407d94:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  407d98:	aa0003e6 	mov	x6, x0
  407d9c:	910003fd 	mov	x29, sp
  407da0:	ad400420 	ldp	q0, q1, [x1]
  407da4:	9100c3e2 	add	x2, sp, #0x30
  407da8:	ad000440 	stp	q0, q1, [x2]
  407dac:	ad400440 	ldp	q0, q1, [x2]
  407db0:	910043e7 	add	x7, sp, #0x10
  407db4:	52800005 	mov	w5, #0x0                   	// #0
  407db8:	d2800004 	mov	x4, #0x0                   	// #0
  407dbc:	d2800003 	mov	x3, #0x0                   	// #0
  407dc0:	52800002 	mov	w2, #0x0                   	// #0
  407dc4:	d2800001 	mov	x1, #0x0                   	// #0
  407dc8:	52800000 	mov	w0, #0x0                   	// #0
  407dcc:	ad0004e0 	stp	q0, q1, [x7]
  407dd0:	9400010a 	bl	4081f8 <z_impl_z_log_msg_runtime_vcreate>
}
  407dd4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  407dd8:	d65f03c0 	ret

0000000000407ddc <log_set_timestamp_func>:
{
  407ddc:	aa0003e2 	mov	x2, x0
	if (timestamp_getter == NULL) {
  407de0:	b4000140 	cbz	x0, 407e08 <log_set_timestamp_func+0x2c>
{
  407de4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  407de8:	2a0103e0 	mov	w0, w1
	timestamp_func = timestamp_getter;
  407dec:	b0000121 	adrp	x1, 42c000 <__dso_handle>
{
  407df0:	910003fd 	mov	x29, sp
	timestamp_func = timestamp_getter;
  407df4:	f9000822 	str	x2, [x1, #16]
		log_output_timestamp_freq_set(freq);
  407df8:	9400033c 	bl	408ae8 <log_output_timestamp_freq_set>
	return 0;
  407dfc:	52800000 	mov	w0, #0x0                   	// #0
}
  407e00:	a8c17bfd 	ldp	x29, x30, [sp], #16
  407e04:	d65f03c0 	ret
		return -EINVAL;
  407e08:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  407e0c:	d65f03c0 	ret

0000000000407e10 <log_core_init>:
	panic_mode = false;
  407e10:	f0000120 	adrp	x0, 42e000 <des_frames+0x27>
		log_set_timestamp_func(default_get_timestamp,
  407e14:	52884801 	mov	w1, #0x4240                	// #16960
  407e18:	72a001e1 	movk	w1, #0xf, lsl #16
	panic_mode = false;
  407e1c:	3903781f 	strb	wzr, [x0, #222]
	dropped_cnt = 0;
  407e20:	b0000120 	adrp	x0, 42c000 <__dso_handle>
  407e24:	f905a81f 	str	xzr, [x0, #2896]
	buffered_cnt = 0;
  407e28:	b0000120 	adrp	x0, 42c000 <__dso_handle>
  407e2c:	f905a41f 	str	xzr, [x0, #2888]
		log_set_timestamp_func(default_get_timestamp,
  407e30:	90000000 	adrp	x0, 407000 <z_cbvprintf_impl+0x118>
  407e34:	912d7000 	add	x0, x0, #0xb5c
  407e38:	17ffffe9 	b	407ddc <log_set_timestamp_func>

0000000000407e3c <z_impl_log_panic>:
{
  407e3c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  407e40:	910003fd 	mov	x29, sp
  407e44:	f90013f5 	str	x21, [sp, #32]
	if (panic_mode) {
  407e48:	f0000135 	adrp	x21, 42e000 <des_frames+0x27>
{
  407e4c:	a90153f3 	stp	x19, x20, [sp, #16]
	if (panic_mode) {
  407e50:	39437aa0 	ldrb	w0, [x21, #222]
  407e54:	35000740 	cbnz	w0, 407f3c <z_impl_log_panic+0x100>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407e58:	90000133 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  407e5c:	90000134 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
	(void)z_log_init(true, false);
  407e60:	52800001 	mov	w1, #0x0                   	// #0
  407e64:	52800020 	mov	w0, #0x1                   	// #1
  407e68:	97ffff48 	bl	407b88 <z_log_init.isra.0>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407e6c:	f947b273 	ldr	x19, [x19, #3936]
  407e70:	f947fe94 	ldr	x20, [x20, #4088]
  407e74:	eb14027f 	cmp	x19, x20
  407e78:	540005c9 	b.ls	407f30 <z_impl_log_panic+0xf4>  // b.plast
  407e7c:	b0000073 	adrp	x19, 414000 <__func__.1+0xd>
  407e80:	9125c673 	add	x19, x19, #0x971
  407e84:	aa1303e2 	mov	x2, x19
  407e88:	b0000061 	adrp	x1, 414000 <__func__.1+0xd>
  407e8c:	91270821 	add	x1, x1, #0x9c2
  407e90:	52803103 	mov	w3, #0x188                 	// #392
  407e94:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407e98:	911a8800 	add	x0, x0, #0x6a2
  407e9c:	97fffef7 	bl	407a78 <assert_print>
  407ea0:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407ea4:	91278c00 	add	x0, x0, #0x9e3
  407ea8:	97fffef4 	bl	407a78 <assert_print>
  407eac:	aa1303e0 	mov	x0, x19
  407eb0:	52803101 	mov	w1, #0x188                 	// #392
  407eb4:	97ffff1b 	bl	407b20 <assert_post_action>
  407eb8:	52803102 	mov	w2, #0x188                 	// #392
  407ebc:	14000013 	b	407f08 <z_impl_log_panic+0xcc>
		if (log_backend_is_active(backend)) {
  407ec0:	aa1303e0 	mov	x0, x19
  407ec4:	97ffff27 	bl	407b60 <log_backend_is_active>
  407ec8:	72001c1f 	tst	w0, #0xff
  407ecc:	540002e0 	b.eq	407f28 <z_impl_log_panic+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  407ed0:	b5000253 	cbnz	x19, 407f18 <z_impl_log_panic+0xdc>
  407ed4:	b0000073 	adrp	x19, 414000 <__func__.1+0xd>
  407ed8:	91280a73 	add	x19, x19, #0xa02
  407edc:	aa1303e2 	mov	x2, x19
  407ee0:	52801a03 	mov	w3, #0xd0                  	// #208
  407ee4:	b0000061 	adrp	x1, 414000 <__func__.1+0xd>
  407ee8:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407eec:	9128e821 	add	x1, x1, #0xa3a
  407ef0:	911a8800 	add	x0, x0, #0x6a2
  407ef4:	97fffee1 	bl	407a78 <assert_print>
  407ef8:	aa1303e0 	mov	x0, x19
  407efc:	52801a01 	mov	w1, #0xd0                  	// #208
  407f00:	97ffff08 	bl	407b20 <assert_post_action>
  407f04:	52801a02 	mov	w2, #0xd0                  	// #208
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407f08:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407f0c:	aa1303e1 	mov	x1, x19
  407f10:	911b8000 	add	x0, x0, #0x6e0
  407f14:	940008f5 	bl	40a2e8 <posix_print_error_and_exit>
	backend->api->panic(backend);
  407f18:	f9400260 	ldr	x0, [x19]
  407f1c:	f9400801 	ldr	x1, [x0, #16]
  407f20:	aa1303e0 	mov	x0, x19
  407f24:	d63f0020 	blr	x1
  407f28:	91008273 	add	x19, x19, #0x20
  407f2c:	17ffffd2 	b	407e74 <z_impl_log_panic+0x38>
  407f30:	54fffc83 	b.cc	407ec0 <z_impl_log_panic+0x84>  // b.lo, b.ul, b.last
	panic_mode = true;
  407f34:	52800020 	mov	w0, #0x1                   	// #1
  407f38:	39037aa0 	strb	w0, [x21, #222]
}
  407f3c:	a94153f3 	ldp	x19, x20, [sp, #16]
  407f40:	f94013f5 	ldr	x21, [sp, #32]
  407f44:	a8c37bfd 	ldp	x29, x30, [sp], #48
  407f48:	d65f03c0 	ret

0000000000407f4c <z_log_notify_backend_enabled>:
}
  407f4c:	d65f03c0 	ret

0000000000407f50 <z_impl_log_process>:
  407f50:	52800000 	mov	w0, #0x0                   	// #0
  407f54:	d65f03c0 	ret

0000000000407f58 <z_log_dropped>:
{
  407f58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  407f5c:	b0000121 	adrp	x1, 42c000 <__dso_handle>
  407f60:	912d4021 	add	x1, x1, #0xb50
  407f64:	910003fd 	mov	x29, sp
  407f68:	f9000bf3 	str	x19, [sp, #16]
  407f6c:	12001c13 	and	w19, w0, #0xff
  407f70:	d2800020 	mov	x0, #0x1                   	// #1
  407f74:	97ffe5a7 	bl	401610 <__aarch64_ldadd8_acq_rel>
	if (buffered) {
  407f78:	340000b3 	cbz	w19, 407f8c <z_log_dropped+0x34>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  407f7c:	b0000121 	adrp	x1, 42c000 <__dso_handle>
  407f80:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  407f84:	912d2021 	add	x1, x1, #0xb48
  407f88:	97ffe5a2 	bl	401610 <__aarch64_ldadd8_acq_rel>
}
  407f8c:	f9400bf3 	ldr	x19, [sp, #16]
  407f90:	a8c27bfd 	ldp	x29, x30, [sp], #32
  407f94:	d65f03c0 	ret

0000000000407f98 <z_log_msg_commit>:
{
  407f98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  407f9c:	910003fd 	mov	x29, sp
  407fa0:	a90153f3 	stp	x19, x20, [sp, #16]
  407fa4:	aa0003f4 	mov	x20, x0
	msg->hdr.timestamp = timestamp_func();
  407fa8:	b0000120 	adrp	x0, 42c000 <__dso_handle>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407fac:	90000133 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
{
  407fb0:	f90013f5 	str	x21, [sp, #32]
	msg->hdr.timestamp = timestamp_func();
  407fb4:	f9400800 	ldr	x0, [x0, #16]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407fb8:	90000135 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
	msg->hdr.timestamp = timestamp_func();
  407fbc:	d63f0000 	blr	x0
  407fc0:	b9000680 	str	w0, [x20, #4]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407fc4:	f947b273 	ldr	x19, [x19, #3936]
  407fc8:	f947feb5 	ldr	x21, [x21, #4088]
  407fcc:	eb15027f 	cmp	x19, x21
  407fd0:	540005e9 	b.ls	40808c <z_log_msg_commit+0xf4>  // b.plast
  407fd4:	b0000073 	adrp	x19, 414000 <__func__.1+0xd>
  407fd8:	9125c673 	add	x19, x19, #0x971
  407fdc:	aa1303e2 	mov	x2, x19
  407fe0:	b0000061 	adrp	x1, 414000 <__func__.1+0xd>
  407fe4:	91270821 	add	x1, x1, #0x9c2
  407fe8:	528038a3 	mov	w3, #0x1c5                 	// #453
  407fec:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407ff0:	911a8800 	add	x0, x0, #0x6a2
  407ff4:	97fffea1 	bl	407a78 <assert_print>
  407ff8:	b0000060 	adrp	x0, 414000 <__func__.1+0xd>
  407ffc:	91278c00 	add	x0, x0, #0x9e3
  408000:	97fffe9e 	bl	407a78 <assert_print>
  408004:	aa1303e0 	mov	x0, x19
  408008:	528038a1 	mov	w1, #0x1c5                 	// #453
  40800c:	97fffec5 	bl	407b20 <assert_post_action>
  408010:	528038a2 	mov	w2, #0x1c5                 	// #453
  408014:	14000013 	b	408060 <z_log_msg_commit+0xc8>
		if (log_backend_is_active(backend) &&
  408018:	aa1303e0 	mov	x0, x19
  40801c:	97fffed1 	bl	407b60 <log_backend_is_active>
  408020:	72001c1f 	tst	w0, #0xff
  408024:	54000300 	b.eq	408084 <z_log_msg_commit+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  408028:	b5000253 	cbnz	x19, 408070 <z_log_msg_commit+0xd8>
  40802c:	90000073 	adrp	x19, 414000 <__func__.1+0xd>
  408030:	91280a73 	add	x19, x19, #0xa02
  408034:	aa1303e2 	mov	x2, x19
  408038:	52801643 	mov	w3, #0xb2                  	// #178
  40803c:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408040:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408044:	9128e821 	add	x1, x1, #0xa3a
  408048:	911a8800 	add	x0, x0, #0x6a2
  40804c:	97fffe8b 	bl	407a78 <assert_print>
  408050:	aa1303e0 	mov	x0, x19
  408054:	52801641 	mov	w1, #0xb2                  	// #178
  408058:	97fffeb2 	bl	407b20 <assert_post_action>
  40805c:	52801642 	mov	w2, #0xb2                  	// #178
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  408060:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408064:	aa1303e1 	mov	x1, x19
  408068:	911b8000 	add	x0, x0, #0x6e0
  40806c:	9400089f 	bl	40a2e8 <posix_print_error_and_exit>
	backend->api->process(backend, msg);
  408070:	f9400260 	ldr	x0, [x19]
  408074:	aa1403e1 	mov	x1, x20
  408078:	f9400002 	ldr	x2, [x0]
  40807c:	aa1303e0 	mov	x0, x19
  408080:	d63f0040 	blr	x2
  408084:	91008273 	add	x19, x19, #0x20
  408088:	17ffffd1 	b	407fcc <z_log_msg_commit+0x34>
  40808c:	54fffc63 	b.cc	408018 <z_log_msg_commit+0x80>  // b.lo, b.ul, b.last
}
  408090:	a94153f3 	ldp	x19, x20, [sp, #16]
  408094:	f94013f5 	ldr	x21, [sp, #32]
  408098:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40809c:	d65f03c0 	ret

00000000004080a0 <z_log_get_tag>:
}
  4080a0:	d2800000 	mov	x0, #0x0                   	// #0
  4080a4:	d65f03c0 	ret

00000000004080a8 <log_src_cnt_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
  4080a8:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4080ac:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4080b0:	f9475c00 	ldr	x0, [x0, #3768]
  4080b4:	f9472821 	ldr	x1, [x1, #3664]
  4080b8:	cb010000 	sub	x0, x0, x1
	if (z_log_is_local_domain(domain_id)) {
		return z_log_sources_count();
	}

	return link_source_count(domain_id);
}
  4080bc:	d3448c00 	ubfx	x0, x0, #4, #32
  4080c0:	d65f03c0 	ret

00000000004080c4 <log_source_name_get>:

	return (const char *)cached;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t source_id)
{
  4080c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4080c8:	910003fd 	mov	x29, sp
  4080cc:	f9000bf3 	str	x19, [sp, #16]
  4080d0:	2a0103f3 	mov	w19, w1
	if (z_log_is_local_domain(domain_id)) {
		if (source_id < log_src_cnt_get(domain_id)) {
  4080d4:	97fffff5 	bl	4080a8 <log_src_cnt_get>
  4080d8:	6b13001f 	cmp	w0, w19
  4080dc:	54000109 	b.ls	4080fc <log_source_name_get+0x38>  // b.plast
			return TYPE_SECTION_START(log_const)[source_id].name;
  4080e0:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4080e4:	d37c7e73 	ubfiz	x19, x19, #4, #32
  4080e8:	f9472800 	ldr	x0, [x0, #3664]
  4080ec:	f8736800 	ldr	x0, [x0, x19]
			return NULL;
		}
	}

	return link_source_name_get(domain_id, source_id);
}
  4080f0:	f9400bf3 	ldr	x19, [sp, #16]
  4080f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4080f8:	d65f03c0 	ret
			return NULL;
  4080fc:	d2800000 	mov	x0, #0x0                   	// #0
  408100:	17fffffc 	b	4080f0 <log_source_name_get+0x2c>

0000000000408104 <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
  408104:	f0000103 	adrp	x3, 42b000 <__FRAME_END__+0x1007c>
  408108:	f947b063 	ldr	x3, [x3, #3936]
  40810c:	cb030003 	sub	x3, x0, x3
	__ASSERT_NO_MSG(backend != NULL);
  408110:	b50002a0 	cbnz	x0, 408164 <log_backend_enable+0x60>
{
  408114:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408118:	52801be3 	mov	w3, #0xdf                  	// #223
  40811c:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408120:	910003fd 	mov	x29, sp
  408124:	f9000bf3 	str	x19, [sp, #16]
  408128:	90000073 	adrp	x19, 414000 <__func__.1+0xd>
  40812c:	91280a73 	add	x19, x19, #0xa02
  408130:	9128e821 	add	x1, x1, #0xa3a
  408134:	aa1303e2 	mov	x2, x19
  408138:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  40813c:	911a8800 	add	x0, x0, #0x6a2
  408140:	97fffe4e 	bl	407a78 <assert_print>
  408144:	aa1303e0 	mov	x0, x19
  408148:	52801be1 	mov	w1, #0xdf                  	// #223
  40814c:	97fffe75 	bl	407b20 <assert_post_action>
  408150:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408154:	aa1303e1 	mov	x1, x19
  408158:	911b8000 	add	x0, x0, #0x6e0
  40815c:	52801be2 	mov	w2, #0xdf                  	// #223
  408160:	94000862 	bl	40a2e8 <posix_print_error_and_exit>
	backend->cb->id = id;
  408164:	f9400404 	ldr	x4, [x0, #8]
  408168:	9345fc63 	asr	x3, x3, #5
  40816c:	11000463 	add	w3, w3, #0x1
  408170:	12001c63 	and	w3, w3, #0xff
  408174:	39002083 	strb	w3, [x4, #8]

	log_backend_id_set(backend, id);
	backend->cb->level = level;
  408178:	f9400403 	ldr	x3, [x0, #8]
  40817c:	39002862 	strb	w2, [x3, #10]
	backend->cb->ctx = ctx;
  408180:	f9400402 	ldr	x2, [x0, #8]
  408184:	f9000041 	str	x1, [x2]
	backend->cb->active = true;
  408188:	52800021 	mov	w1, #0x1                   	// #1
  40818c:	f9400400 	ldr	x0, [x0, #8]
  408190:	39002401 	strb	w1, [x0, #9]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
  408194:	17ffff6e 	b	407f4c <z_log_notify_backend_enabled>

0000000000408198 <z_log_msg_finalize>:
	 (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY) || log_backend_count_get() == 0))

void z_log_msg_finalize(struct log_msg *msg, const void *source,
			 const struct log_msg_desc desc, const void *data)
{
	if (!msg) {
  408198:	b5000060 	cbnz	x0, 4081a4 <z_log_msg_finalize+0xc>
		z_log_dropped(false);
  40819c:	52800000 	mov	w0, #0x0                   	// #0
  4081a0:	17ffff6e 	b	407f58 <z_log_dropped>
{
  4081a4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4081a8:	910003fd 	mov	x29, sp
  4081ac:	a90153f3 	stp	x19, x20, [sp, #16]
  4081b0:	aa0003f3 	mov	x19, x0
  4081b4:	2a0203f4 	mov	w20, w2
  4081b8:	f90013f5 	str	x21, [sp, #32]
  4081bc:	aa0103f5 	mov	x21, x1
  4081c0:	aa0303e1 	mov	x1, x3

		return;
	}

	if (data) {
  4081c4:	b40000c3 	cbz	x3, 4081dc <z_log_msg_finalize+0x44>
		uint8_t *d = msg->data + desc.package_len;
  4081c8:	d3494e83 	ubfx	x3, x20, #9, #11
  4081cc:	91004000 	add	x0, x0, #0x10
  4081d0:	53147c42 	lsr	w2, w2, #20
  4081d4:	8b030000 	add	x0, x0, x3
  4081d8:	97ffe3e6 	bl	401170 <memcpy@plt>

		memcpy(d, data, desc.data_len);
	}

	msg->hdr.desc = desc;
  4081dc:	b9000274 	str	w20, [x19]
	msg->hdr.source = source;
	z_log_msg_commit(msg);
  4081e0:	aa1303e0 	mov	x0, x19
	msg->hdr.source = source;
  4081e4:	f9000675 	str	x21, [x19, #8]
}
  4081e8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4081ec:	f94013f5 	ldr	x21, [sp, #32]
  4081f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_log_msg_commit(msg);
  4081f4:	17ffff69 	b	407f98 <z_log_msg_commit>

00000000004081f8 <z_impl_z_log_msg_runtime_vcreate>:
#endif

void z_impl_z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				uint32_t package_flags, const char *fmt, va_list ap)
{
  4081f8:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  4081fc:	910003fd 	mov	x29, sp
  408200:	a9046bf9 	stp	x25, x26, [sp, #64]
  408204:	12001c1a 	and	w26, w0, #0xff
  408208:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40820c:	a90153f3 	stp	x19, x20, [sp, #16]
  408210:	aa0103f4 	mov	x20, x1
  408214:	12001c53 	and	w19, w2, #0xff
  408218:	f9476800 	ldr	x0, [x0, #3792]
  40821c:	a9025bf5 	stp	x21, x22, [sp, #32]
  408220:	2a0503f9 	mov	w25, w5
  408224:	a90363f7 	stp	x23, x24, [sp, #48]
  408228:	aa0303f5 	mov	x21, x3
  40822c:	d10043ff 	sub	sp, sp, #0x10
  408230:	f9400001 	ldr	x1, [x0]
  408234:	f9004fa1 	str	x1, [x29, #152]
  408238:	d2800001 	mov	x1, #0x0                   	// #0
  40823c:	aa0403f8 	mov	x24, x4
  408240:	aa0603f6 	mov	x22, x6
  408244:	aa0703f7 	mov	x23, x7
	int plen;

	if (fmt) {
  408248:	b40003a6 	cbz	x6, 4082bc <z_impl_z_log_msg_runtime_vcreate+0xc4>
		va_list ap2;

		va_copy(ap2, ap);
  40824c:	ad4004e0 	ldp	q0, q1, [x7]
  408250:	9101e3a0 	add	x0, x29, #0x78
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  408254:	910143a4 	add	x4, x29, #0x50
  408258:	aa0603e3 	mov	x3, x6
  40825c:	2a0503e2 	mov	w2, w5
  408260:	d2800201 	mov	x1, #0x10                  	// #16
		va_copy(ap2, ap);
  408264:	ad000400 	stp	q0, q1, [x0]
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  408268:	d2800000 	mov	x0, #0x0                   	// #0
  40826c:	ad000480 	stp	q0, q1, [x4]
  408270:	97fff628 	bl	405b10 <cbvprintf_package>
					 package_flags, fmt, ap2);
		__ASSERT_NO_MSG(plen >= 0);
  408274:	36f80260 	tbz	w0, #31, 4082c0 <z_impl_z_log_msg_runtime_vcreate+0xc8>
  408278:	90000073 	adrp	x19, 414000 <__func__.1+0xd>
  40827c:	912a9a73 	add	x19, x19, #0xaa6
  408280:	aa1303e2 	mov	x2, x19
  408284:	52800ea3 	mov	w3, #0x75                  	// #117
  408288:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  40828c:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408290:	912b4821 	add	x1, x1, #0xad2
  408294:	911a8800 	add	x0, x0, #0x6a2
  408298:	97fffdf8 	bl	407a78 <assert_print>
  40829c:	aa1303e0 	mov	x0, x19
  4082a0:	52800ea1 	mov	w1, #0x75                  	// #117
  4082a4:	97fffe1f 	bl	407b20 <assert_post_action>
  4082a8:	52800ea2 	mov	w2, #0x75                  	// #117
		pkg = msg->data;
	}

	if (pkg && fmt) {
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
		__ASSERT_NO_MSG(plen >= 0);
  4082ac:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  4082b0:	aa1303e1 	mov	x1, x19
  4082b4:	911b8000 	add	x0, x0, #0x6e0
  4082b8:	9400080c 	bl	40a2e8 <posix_print_error_and_exit>
		plen = 0;
  4082bc:	52800000 	mov	w0, #0x0                   	// #0
	struct log_msg_desc desc =
  4082c0:	531a0a73 	ubfiz	w19, w19, #6, #3
  4082c4:	531d0b5a 	ubfiz	w26, w26, #3, #3
  4082c8:	53172802 	ubfiz	w2, w0, #9, #11
  4082cc:	2a1a0273 	orr	w19, w19, w26
  4082d0:	2a020273 	orr	w19, w19, w2
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  4082d4:	93407c01 	sxtw	x1, w0
	struct log_msg_desc desc =
  4082d8:	2a185273 	orr	w19, w19, w24, lsl #20
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  4082dc:	91005f18 	add	x24, x24, #0x17
  4082e0:	8b20c300 	add	x0, x24, w0, sxtw
		msg = alloca(msg_wlen * sizeof(int));
  4082e4:	927df000 	and	x0, x0, #0xfffffffffffffff8
  4082e8:	91003c00 	add	x0, x0, #0xf
  4082ec:	927cec02 	and	x2, x0, #0xfffffffffffffff0
  4082f0:	9270bc00 	and	x0, x0, #0xffffffffffff0000
  4082f4:	cb2063e0 	sub	x0, sp, x0
  4082f8:	eb2063ff 	cmp	sp, x0
  4082fc:	54000080 	b.eq	40830c <z_impl_z_log_msg_runtime_vcreate+0x114>  // b.none
  408300:	d14043ff 	sub	sp, sp, #0x10, lsl #12
  408304:	f90203ff 	str	xzr, [sp, #1024]
  408308:	17fffffc 	b	4082f8 <z_impl_z_log_msg_runtime_vcreate+0x100>
  40830c:	92403c40 	and	x0, x2, #0xffff
  408310:	cb2063ff 	sub	sp, sp, x0
  408314:	f90003ff 	str	xzr, [sp]
  408318:	f110001f 	cmp	x0, #0x400
  40831c:	54000043 	b.cc	408324 <z_impl_z_log_msg_runtime_vcreate+0x12c>  // b.lo, b.ul, b.last
  408320:	f90203ff 	str	xzr, [sp, #1024]
  408324:	910043f8 	add	x24, sp, #0x10
	if (pkg && fmt) {
  408328:	b40002f6 	cbz	x22, 408384 <z_impl_z_log_msg_runtime_vcreate+0x18c>
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
  40832c:	ad4006e0 	ldp	q0, q1, [x23]
  408330:	910143a4 	add	x4, x29, #0x50
  408334:	aa1603e3 	mov	x3, x22
  408338:	2a1903e2 	mov	w2, w25
  40833c:	91004300 	add	x0, x24, #0x10
  408340:	ad000480 	stp	q0, q1, [x4]
  408344:	97fff5f3 	bl	405b10 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
  408348:	36f801e0 	tbz	w0, #31, 408384 <z_impl_z_log_msg_runtime_vcreate+0x18c>
  40834c:	90000073 	adrp	x19, 414000 <__func__.1+0xd>
  408350:	912a9a73 	add	x19, x19, #0xaa6
  408354:	aa1303e2 	mov	x2, x19
  408358:	528011e3 	mov	w3, #0x8f                  	// #143
  40835c:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408360:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408364:	912b4821 	add	x1, x1, #0xad2
  408368:	911a8800 	add	x0, x0, #0x6a2
  40836c:	97fffdc3 	bl	407a78 <assert_print>
  408370:	aa1303e0 	mov	x0, x19
  408374:	528011e1 	mov	w1, #0x8f                  	// #143
  408378:	97fffdea 	bl	407b20 <assert_post_action>
  40837c:	528011e2 	mov	w2, #0x8f                  	// #143
  408380:	17ffffcb 	b	4082ac <z_impl_z_log_msg_runtime_vcreate+0xb4>
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_msg(source, desc, pkg, data);
	}

	if (BACKENDS_IN_USE()) {
		z_log_msg_finalize(msg, source, desc, data);
  408384:	2a1303e2 	mov	w2, w19
  408388:	aa1403e1 	mov	x1, x20
  40838c:	aa1803e0 	mov	x0, x24
  408390:	aa1503e3 	mov	x3, x21
  408394:	97ffff81 	bl	408198 <z_log_msg_finalize>
	}
}
  408398:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40839c:	f9476800 	ldr	x0, [x0, #3792]
  4083a0:	f9404fa2 	ldr	x2, [x29, #152]
  4083a4:	f9400001 	ldr	x1, [x0]
  4083a8:	eb010042 	subs	x2, x2, x1
  4083ac:	d2800001 	mov	x1, #0x0                   	// #0
  4083b0:	54000040 	b.eq	4083b8 <z_impl_z_log_msg_runtime_vcreate+0x1c0>  // b.none
  4083b4:	97ffe3db 	bl	401320 <__stack_chk_fail@plt>
  4083b8:	910003bf 	mov	sp, x29
  4083bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4083c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4083c4:	a94363f7 	ldp	x23, x24, [sp, #48]
  4083c8:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4083cc:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  4083d0:	d65f03c0 	ret

00000000004083d4 <out_func>:

	return ret;
}

static int out_func(int c, void *ctx)
{
  4083d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4083d8:	f0000102 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
  4083dc:	910003fd 	mov	x29, sp
  4083e0:	f9476842 	ldr	x2, [x2, #3792]
  4083e4:	f9400043 	ldr	x3, [x2]
  4083e8:	f9000fe3 	str	x3, [sp, #24]
  4083ec:	d2800003 	mov	x3, #0x0                   	// #0
	int idx;

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		/* Backend must be thread safe in synchronous operation. */
		/* Need that step for big endian */
		char x = (char)c;
  4083f0:	39005fe0 	strb	w0, [sp, #23]

		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
  4083f4:	a9400023 	ldp	x3, x0, [x1]
  4083f8:	d2800021 	mov	x1, #0x1                   	// #1
  4083fc:	f9400402 	ldr	x2, [x0, #8]
  408400:	91005fe0 	add	x0, sp, #0x17
  408404:	d63f0060 	blr	x3
	out_ctx->buf[idx] = (uint8_t)c;

	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);

	return 0;
}
  408408:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40840c:	f9476800 	ldr	x0, [x0, #3792]
  408410:	f9400fe2 	ldr	x2, [sp, #24]
  408414:	f9400001 	ldr	x1, [x0]
  408418:	eb010042 	subs	x2, x2, x1
  40841c:	d2800001 	mov	x1, #0x0                   	// #0
  408420:	54000040 	b.eq	408428 <out_func+0x54>  // b.none
  408424:	97ffe3bf 	bl	401320 <__stack_chk_fail@plt>
  408428:	52800000 	mov	w0, #0x0                   	// #0
  40842c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408430:	d65f03c0 	ret

0000000000408434 <cr_out_func>:

static int cr_out_func(int c, void *ctx)
{
  408434:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408438:	910003fd 	mov	x29, sp
  40843c:	a90153f3 	stp	x19, x20, [sp, #16]
  408440:	2a0003f3 	mov	w19, w0
  408444:	aa0103f4 	mov	x20, x1
	if (c == '\n') {
  408448:	7100281f 	cmp	w0, #0xa
  40844c:	54000061 	b.ne	408458 <cr_out_func+0x24>  // b.any
		out_func((int)'\r', ctx);
  408450:	528001a0 	mov	w0, #0xd                   	// #13
  408454:	97ffffe0 	bl	4083d4 <out_func>
	}
	out_func(c, ctx);
  408458:	aa1403e1 	mov	x1, x20
  40845c:	2a1303e0 	mov	w0, w19
  408460:	97ffffdd 	bl	4083d4 <out_func>

	return 0;
}
  408464:	52800000 	mov	w0, #0x0                   	// #0
  408468:	a94153f3 	ldp	x19, x20, [sp, #16]
  40846c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408470:	d65f03c0 	ret

0000000000408474 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
  408474:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  408478:	910003fd 	mov	x29, sp
  40847c:	a90153f3 	stp	x19, x20, [sp, #16]
  408480:	aa0103f4 	mov	x20, x1
  408484:	aa0203f3 	mov	x19, x2
  408488:	a9025bf5 	stp	x21, x22, [sp, #32]
  40848c:	aa0003f5 	mov	x21, x0
  408490:	aa0303f6 	mov	x22, x3
	int processed;

	do {
		processed = outf(buf, len, ctx);
  408494:	aa1303e1 	mov	x1, x19
  408498:	aa1403e0 	mov	x0, x20
  40849c:	aa1603e2 	mov	x2, x22
  4084a0:	d63f02a0 	blr	x21
		len -= processed;
		buf += processed;
  4084a4:	8b20c294 	add	x20, x20, w0, sxtw
	} while (len != 0);
  4084a8:	eb20c273 	subs	x19, x19, w0, sxtw
  4084ac:	54ffff41 	b.ne	408494 <buffer_write+0x20>  // b.any
}
  4084b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4084b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4084b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4084bc:	d65f03c0 	ret

00000000004084c0 <cbvprintf>:
#ifdef CONFIG_PICOLIBC
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
  4084c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4084c4:	910003fd 	mov	x29, sp
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
  4084c8:	ad400460 	ldp	q0, q1, [x3]
  4084cc:	910043e4 	add	x4, sp, #0x10
  4084d0:	aa0403e3 	mov	x3, x4
  4084d4:	ad000480 	stp	q0, q1, [x4]
  4084d8:	52800004 	mov	w4, #0x0                   	// #0
  4084dc:	97fffa83 	bl	406ee8 <z_cbvprintf_impl>
}
  4084e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4084e4:	d65f03c0 	ret

00000000004084e8 <print_formatted>:
{
  4084e8:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  4084ec:	910003fd 	mov	x29, sp
  4084f0:	a90e0fe2 	stp	x2, x3, [sp, #224]
  4084f4:	f0000102 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
  4084f8:	f9476842 	ldr	x2, [x2, #3792]
  4084fc:	3d801be0 	str	q0, [sp, #96]
  408500:	3d801fe1 	str	q1, [sp, #112]
  408504:	3d8023e2 	str	q2, [sp, #128]
  408508:	3d8027e3 	str	q3, [sp, #144]
  40850c:	3d802be4 	str	q4, [sp, #160]
  408510:	3d802fe5 	str	q5, [sp, #176]
  408514:	3d8033e6 	str	q6, [sp, #192]
  408518:	3d8037e7 	str	q7, [sp, #208]
  40851c:	a90f17e4 	stp	x4, x5, [sp, #240]
  408520:	a9101fe6 	stp	x6, x7, [sp, #256]
  408524:	f9400043 	ldr	x3, [x2]
  408528:	f9002fe3 	str	x3, [sp, #88]
  40852c:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(args, fmt);
  408530:	910443e2 	add	x2, sp, #0x110
  408534:	a9038be2 	stp	x2, x2, [sp, #56]
  408538:	910383e2 	add	x2, sp, #0xe0
	length = cbvprintf(out_func, (void *)output, fmt, args);
  40853c:	910043e3 	add	x3, sp, #0x10
	va_start(args, fmt);
  408540:	f90027e2 	str	x2, [sp, #72]
  408544:	128005e2 	mov	w2, #0xffffffd0            	// #-48
  408548:	b90053e2 	str	w2, [sp, #80]
  40854c:	12800fe2 	mov	w2, #0xffffff80            	// #-128
  408550:	b90057e2 	str	w2, [sp, #84]
	length = cbvprintf(out_func, (void *)output, fmt, args);
  408554:	9100e3e2 	add	x2, sp, #0x38
  408558:	ad400440 	ldp	q0, q1, [x2]
  40855c:	aa0103e2 	mov	x2, x1
  408560:	aa0003e1 	mov	x1, x0
  408564:	90000000 	adrp	x0, 408000 <z_log_msg_commit+0x68>
  408568:	910f5000 	add	x0, x0, #0x3d4
  40856c:	ad000460 	stp	q0, q1, [x3]
  408570:	97ffffd4 	bl	4084c0 <cbvprintf>
}
  408574:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  408578:	f9476821 	ldr	x1, [x1, #3792]
  40857c:	f9402fe3 	ldr	x3, [sp, #88]
  408580:	f9400022 	ldr	x2, [x1]
  408584:	eb020063 	subs	x3, x3, x2
  408588:	d2800002 	mov	x2, #0x0                   	// #0
  40858c:	54000040 	b.eq	408594 <print_formatted+0xac>  // b.none
  408590:	97ffe364 	bl	401320 <__stack_chk_fail@plt>
  408594:	a8d17bfd 	ldp	x29, x30, [sp], #272
  408598:	d65f03c0 	ret

000000000040859c <log_output_flush>:


void log_output_flush(const struct log_output *output)
{
  40859c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4085a0:	910003fd 	mov	x29, sp
  4085a4:	f9000bf3 	str	x19, [sp, #16]
  4085a8:	aa0003f3 	mov	x19, x0
	buffer_write(output->func, output->buf,
  4085ac:	a9408400 	ldp	x0, x1, [x0, #8]
  4085b0:	a9400c02 	ldp	x2, x3, [x0]
  4085b4:	f9400260 	ldr	x0, [x19]
  4085b8:	97ffffaf 	bl	408474 <buffer_write>
		     output->control_block->offset,
		     output->control_block->ctx);

	output->control_block->offset = 0;
  4085bc:	f9400660 	ldr	x0, [x19, #8]
  4085c0:	f900001f 	str	xzr, [x0]
}
  4085c4:	f9400bf3 	ldr	x19, [sp, #16]
  4085c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4085cc:	d65f03c0 	ret

00000000004085d0 <log_output_process>:
			uint8_t level,
			const uint8_t *package,
			const uint8_t *data,
			size_t data_len,
			uint32_t flags)
{
  4085d0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  4085d4:	910003fd 	mov	x29, sp
  4085d8:	a90153f3 	stp	x19, x20, [sp, #16]
  4085dc:	aa0003f3 	mov	x19, x0
  4085e0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4085e4:	aa0703f5 	mov	x21, x7
  4085e8:	b94083f6 	ldr	w22, [sp, #128]
  4085ec:	a90363f7 	stp	x23, x24, [sp, #48]
  4085f0:	aa0603f7 	mov	x23, x6
  4085f4:	a9046bf9 	stp	x25, x26, [sp, #64]
  4085f8:	aa0303fa 	mov	x26, x3
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	uint32_t prefix_offset;
	cbprintf_cb cb;

	if (!raw_string) {
  4085fc:	72001c99 	ands	w25, w4, #0xff
{
  408600:	a90573fb 	stp	x27, x28, [sp, #80]
  408604:	aa0503fb 	mov	x27, x5
	if (!raw_string) {
  408608:	54001100 	b.eq	408828 <log_output_process+0x258>  // b.none
	__ASSERT_NO_MSG(level <= LOG_LEVEL_DBG);
  40860c:	7100133f 	cmp	w25, #0x4
  408610:	54000249 	b.ls	408658 <log_output_process+0x88>  // b.plast
  408614:	90000073 	adrp	x19, 414000 <__func__.1+0xd>
  408618:	912b8673 	add	x19, x19, #0xae1
  40861c:	aa1303e2 	mov	x2, x19
  408620:	52803663 	mov	w3, #0x1b3                 	// #435
  408624:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408628:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  40862c:	912c4021 	add	x1, x1, #0xb10
  408630:	911a8800 	add	x0, x0, #0x6a2
  408634:	97fffd11 	bl	407a78 <assert_print>
  408638:	aa1303e0 	mov	x0, x19
  40863c:	52803661 	mov	w1, #0x1b3                 	// #435
  408640:	97fffd38 	bl	407b20 <assert_post_action>
  408644:	52803662 	mov	w2, #0x1b3                 	// #435

	if (package) {
		int err = cbpprintf(cb, (void *)output, (void *)package);

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
  408648:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  40864c:	aa1303e1 	mov	x1, x19
  408650:	911b8000 	add	x0, x0, #0x6e0
  408654:	94000725 	bl	40a2e8 <posix_print_error_and_exit>
  408658:	121d02c0 	and	w0, w22, #0x8
  40865c:	aa0203fc 	mov	x28, x2
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  408660:	2a0103f4 	mov	w20, w1
  408664:	b9007be0 	str	w0, [sp, #120]
	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
  408668:	97fffe8e 	bl	4080a0 <z_log_get_tag>
  40866c:	aa0003e2 	mov	x2, x0
	if (tag) {
  408670:	b40009e0 	cbz	x0, 4087ac <log_output_process+0x1dc>
		length += print_formatted(output, "%s ", tag);
  408674:	aa1303e0 	mov	x0, x19
  408678:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  40867c:	912c7021 	add	x1, x1, #0xb1c
  408680:	97ffff9a 	bl	4084e8 <print_formatted>
  408684:	2a0003f8 	mov	w24, w0
	if (stamp) {
  408688:	121f02c0 	and	w0, w22, #0x2
  40868c:	34000140 	cbz	w0, 4086b4 <log_output_process+0xe4>
	if (!format) {
  408690:	52800880 	mov	w0, #0x44                  	// #68
  408694:	6a0002df 	tst	w22, w0
  408698:	540008e1 	b.ne	4087b4 <log_output_process+0x1e4>  // b.any
		length = print_formatted(output, "[%08lu] ", timestamp);
  40869c:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  4086a0:	2a1403e2 	mov	w2, w20
  4086a4:	912c8021 	add	x1, x1, #0xb20
  4086a8:	aa1303e0 	mov	x0, x19
  4086ac:	97ffff8f 	bl	4084e8 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
  4086b0:	0b000318 	add	w24, w24, w0
	if (color) {
  4086b4:	120002c0 	and	w0, w22, #0x1
  4086b8:	34000180 	cbz	w0, 4086e8 <log_output_process+0x118>
		const char *log_color = start && (colors[level] != NULL) ?
  4086bc:	2a1903e1 	mov	w1, w25
  4086c0:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4086c4:	911e4000 	add	x0, x0, #0x790
  4086c8:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  4086cc:	b5000062 	cbnz	x2, 4086d8 <log_output_process+0x108>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
  4086d0:	90000062 	adrp	x2, 414000 <__func__.1+0xd>
  4086d4:	912b7042 	add	x2, x2, #0xadc
		print_formatted(output, "%s", log_color);
  4086d8:	b0000061 	adrp	x1, 415000 <random_data+0xd8c>
  4086dc:	aa1303e0 	mov	x0, x19
  4086e0:	9112bc21 	add	x1, x1, #0x4af
  4086e4:	97ffff81 	bl	4084e8 <print_formatted>
	if (level_on) {
  4086e8:	121d02c0 	and	w0, w22, #0x8
  4086ec:	340009a0 	cbz	w0, 408820 <log_output_process+0x250>
		total += print_formatted(output, "<%s> ", severity[level]);
  4086f0:	2a1903e1 	mov	w1, w25
  4086f4:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4086f8:	911ee000 	add	x0, x0, #0x7b8
  4086fc:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  408700:	aa1303e0 	mov	x0, x19
  408704:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408708:	912d1421 	add	x1, x1, #0xb45
  40870c:	97ffff77 	bl	4084e8 <print_formatted>
  408710:	2a0003f4 	mov	w20, w0
	if (domain) {
  408714:	b40000fc 	cbz	x28, 408730 <log_output_process+0x160>
		total += print_formatted(output, "%s/", domain);
  408718:	aa1c03e2 	mov	x2, x28
  40871c:	aa1303e0 	mov	x0, x19
  408720:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408724:	912d2c21 	add	x1, x1, #0xb4b
  408728:	97ffff70 	bl	4084e8 <print_formatted>
  40872c:	0b000294 	add	w20, w20, w0
	if (source) {
  408730:	b40000fa 	cbz	x26, 40874c <log_output_process+0x17c>
		total += print_formatted(output,
  408734:	aa1a03e2 	mov	x2, x26
  408738:	aa1303e0 	mov	x0, x19
  40873c:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408740:	912d3c21 	add	x1, x1, #0xb4f
  408744:	97ffff69 	bl	4084e8 <print_formatted>
  408748:	0b000294 	add	w20, w20, w0
		cb = out_func;
  40874c:	90000000 	adrp	x0, 408000 <z_log_msg_commit+0x68>
	length += ids_print(output, level_on, func_on, domain, source, level);
  408750:	0b180294 	add	w20, w20, w24
		cb = out_func;
  408754:	910f5000 	add	x0, x0, #0x3d4
	if (package) {
  408758:	b40007bb 	cbz	x27, 40884c <log_output_process+0x27c>
		return cbpprintf_external(out, cbvprintf_tagged_args,
					  ctx, packaged);
	}
#endif

	return cbpprintf_external(out, cbvprintf, ctx, packaged);
  40875c:	90000001 	adrp	x1, 408000 <z_log_msg_commit+0x68>
  408760:	aa1b03e3 	mov	x3, x27
  408764:	aa1303e2 	mov	x2, x19
  408768:	91130021 	add	x1, x1, #0x4c0
  40876c:	97fff6c6 	bl	406284 <cbpprintf_external>
		__ASSERT_NO_MSG(err >= 0);
  408770:	36f806e0 	tbz	w0, #31, 40884c <log_output_process+0x27c>
  408774:	90000073 	adrp	x19, 414000 <__func__.1+0xd>
  408778:	912b8673 	add	x19, x19, #0xae1
  40877c:	aa1303e2 	mov	x2, x19
  408780:	52804123 	mov	w3, #0x209                 	// #521
  408784:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408788:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  40878c:	912d5021 	add	x1, x1, #0xb54
  408790:	911a8800 	add	x0, x0, #0x6a2
  408794:	97fffcb9 	bl	407a78 <assert_print>
  408798:	aa1303e0 	mov	x0, x19
  40879c:	52804121 	mov	w1, #0x209                 	// #521
  4087a0:	97fffce0 	bl	407b20 <assert_post_action>
  4087a4:	52804122 	mov	w2, #0x209                 	// #521
  4087a8:	17ffffa8 	b	408648 <log_output_process+0x78>
	uint32_t length = 0U;
  4087ac:	52800018 	mov	w24, #0x0                   	// #0
  4087b0:	17ffffb6 	b	408688 <log_output_process+0xb8>
	} else if (freq != 0U) {
  4087b4:	b0000120 	adrp	x0, 42d000 <counter_value>
  4087b8:	b94f0006 	ldr	w6, [x0, #3840]
  4087bc:	340002e6 	cbz	w6, 408818 <log_output_process+0x248>
		timestamp /= timestamp_div;
  4087c0:	b0000120 	adrp	x0, 42d000 <counter_value>
  4087c4:	5281c201 	mov	w1, #0xe10                 	// #3600
		ms = (remainder * 1000U) / freq;
  4087c8:	52807d03 	mov	w3, #0x3e8                 	// #1000
				length = print_formatted(output,
  4087cc:	52800784 	mov	w4, #0x3c                  	// #60
		timestamp /= timestamp_div;
  4087d0:	b94f0400 	ldr	w0, [x0, #3844]
  4087d4:	1ac00a94 	udiv	w20, w20, w0
		total_seconds = timestamp / freq;
  4087d8:	1ac60a80 	udiv	w0, w20, w6
		seconds -= hours * 3600U;
  4087dc:	1ac10802 	udiv	w2, w0, w1
  4087e0:	1b018041 	msub	w1, w2, w1, w0
		remainder = timestamp % freq;
  4087e4:	1b06d000 	msub	w0, w0, w6, w20
		ms = (remainder * 1000U) / freq;
  4087e8:	1b037c00 	mul	w0, w0, w3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  4087ec:	1ac60805 	udiv	w5, w0, w6
  4087f0:	1b0680a0 	msub	w0, w5, w6, w0
  4087f4:	1b037c00 	mul	w0, w0, w3
				length = print_formatted(output,
  4087f8:	1ac40823 	udiv	w3, w1, w4
  4087fc:	1ac60806 	udiv	w6, w0, w6
  408800:	aa1303e0 	mov	x0, x19
  408804:	1b048464 	msub	w4, w3, w4, w1
  408808:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  40880c:	912ca421 	add	x1, x1, #0xb29
  408810:	97ffff36 	bl	4084e8 <print_formatted>
  408814:	17ffffa7 	b	4086b0 <log_output_process+0xe0>
		length = 0;
  408818:	52800000 	mov	w0, #0x0                   	// #0
  40881c:	17ffffa5 	b	4086b0 <log_output_process+0xe0>
	int total = 0;
  408820:	52800014 	mov	w20, #0x0                   	// #0
  408824:	17ffffbc 	b	408714 <log_output_process+0x144>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  408828:	f100047f 	cmp	x3, #0x1
  40882c:	540000a0 	b.eq	408840 <log_output_process+0x270>  // b.none
  408830:	90000000 	adrp	x0, 408000 <z_log_msg_commit+0x68>
  408834:	9110d000 	add	x0, x0, #0x434
		prefix_offset = 0;
  408838:	52800014 	mov	w20, #0x0                   	// #0
  40883c:	17ffffc7 	b	408758 <log_output_process+0x188>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  408840:	90000000 	adrp	x0, 408000 <z_log_msg_commit+0x68>
  408844:	910f5000 	add	x0, x0, #0x3d4
  408848:	17fffffc 	b	408838 <log_output_process+0x268>
	}

	if (data_len) {
  40884c:	b4000895 	cbz	x21, 40895c <log_output_process+0x38c>
		print_formatted(output, " ");
  408850:	90000078 	adrp	x24, 414000 <__func__.1+0xd>
  408854:	912d8b18 	add	x24, x24, #0xb62
		print_formatted(ctx, "\r\n");
  408858:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  40885c:	912d7400 	add	x0, x0, #0xb5d
  408860:	f9003be0 	str	x0, [sp, #112]
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
  408864:	52800200 	mov	w0, #0x10                  	// #16
  408868:	6b0002bf 	cmp	w21, w0
  40886c:	1a8092a1 	csel	w1, w21, w0, ls  // ls = plast
  408870:	1a8092a0 	csel	w0, w21, w0, ls  // ls = plast
  408874:	f90033e0 	str	x0, [sp, #96]
  408878:	b9007be1 	str	w1, [sp, #120]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  40887c:	372000d6 	tbnz	w22, #4, 408894 <log_output_process+0x2c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  408880:	362809b6 	tbz	w22, #5, 4089b4 <log_output_process+0x3e4>
		print_formatted(ctx, "\n");
  408884:	b0000061 	adrp	x1, 415000 <random_data+0xd8c>
  408888:	91320821 	add	x1, x1, #0xc82
		print_formatted(ctx, "\r\n");
  40888c:	aa1303e0 	mov	x0, x19
  408890:	97ffff16 	bl	4084e8 <print_formatted>
		prefix_offset = 0;
  408894:	5280001b 	mov	w27, #0x0                   	// #0
	for (int i = 0; i < prefix_offset; i++) {
  408898:	6b1b029f 	cmp	w20, w27
  40889c:	5400090c 	b.gt	4089bc <log_output_process+0x3ec>
			print_formatted(output, "%02x ", data[i]);
  4088a0:	f000005c 	adrp	x28, 413000 <z_timer_expiration_handler+0x68>
  4088a4:	912eb79c 	add	x28, x28, #0xbad
			print_formatted(output, "   ");
  4088a8:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  4088ac:	d280001a 	mov	x26, #0x0                   	// #0
  4088b0:	912d8000 	add	x0, x0, #0xb60
  4088b4:	f90037e0 	str	x0, [sp, #104]
		if (i < length) {
  4088b8:	b9407be0 	ldr	w0, [sp, #120]
  4088bc:	2a1a03fb 	mov	w27, w26
  4088c0:	6b1a001f 	cmp	w0, w26
  4088c4:	54000969 	b.ls	4089f0 <log_output_process+0x420>  // b.plast
			print_formatted(output, "%02x ", data[i]);
  4088c8:	387a6ae2 	ldrb	w2, [x23, x26]
  4088cc:	aa1c03e1 	mov	x1, x28
  4088d0:	aa1303e0 	mov	x0, x19
  4088d4:	97ffff05 	bl	4084e8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  4088d8:	f1003f5f 	cmp	x26, #0xf
  4088dc:	540007a1 	b.ne	4089d0 <log_output_process+0x400>  // b.any
			print_formatted(output, "%c",
  4088e0:	9000007b 	adrp	x27, 414000 <__func__.1+0xd>
  4088e4:	912d9b7b 	add	x27, x27, #0xb66
	print_formatted(output, "|");
  4088e8:	d280001c 	mov	x28, #0x0                   	// #0
  4088ec:	528005da 	mov	w26, #0x2e                  	// #46
  4088f0:	aa1303e0 	mov	x0, x19
  4088f4:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  4088f8:	912d9021 	add	x1, x1, #0xb64
  4088fc:	97fffefb 	bl	4084e8 <print_formatted>
		if (i < length) {
  408900:	b9407be0 	ldr	w0, [sp, #120]
  408904:	b9006bfc 	str	w28, [sp, #104]
  408908:	6b1c001f 	cmp	w0, w28
  40890c:	540008c9 	b.ls	408a24 <log_output_process+0x454>  // b.plast
			unsigned char c = (unsigned char)data[i];
  408910:	387c6ae2 	ldrb	w2, [x23, x28]
  408914:	b9007fe2 	str	w2, [sp, #124]
			      isprint((int)c) != 0 ? c : '.');
  408918:	97ffe2a6 	bl	4013b0 <__ctype_b_loc@plt>
  40891c:	b9407fe2 	ldr	w2, [sp, #124]
  408920:	f9400000 	ldr	x0, [x0]
  408924:	d37f1c41 	ubfiz	x1, x2, #1, #8
			print_formatted(output, "%c",
  408928:	78616800 	ldrh	w0, [x0, x1]
  40892c:	aa1b03e1 	mov	x1, x27
  408930:	f272001f 	tst	x0, #0x4000
  408934:	aa1303e0 	mov	x0, x19
  408938:	1a9a1042 	csel	w2, w2, w26, ne  // ne = any
  40893c:	97fffeeb 	bl	4084e8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  408940:	f1003f9f 	cmp	x28, #0xf
  408944:	540005e1 	b.ne	408a00 <log_output_process+0x430>  // b.any
		data += length;
  408948:	f94033e0 	ldr	x0, [sp, #96]
  40894c:	8b0002f7 	add	x23, x23, x0
	} while (len);
  408950:	b9407be0 	ldr	w0, [sp, #120]
  408954:	6b0002b5 	subs	w21, w21, w0
  408958:	54fff861 	b.ne	408864 <log_output_process+0x294>  // b.any
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
	}

	if (!raw_string) {
  40895c:	340001d9 	cbz	w25, 408994 <log_output_process+0x3c4>
	if (color) {
  408960:	360000f6 	tbz	w22, #0, 40897c <log_output_process+0x3ac>
		print_formatted(output, "%s", log_color);
  408964:	90000062 	adrp	x2, 414000 <__func__.1+0xd>
  408968:	b0000061 	adrp	x1, 415000 <random_data+0xd8c>
  40896c:	912b7042 	add	x2, x2, #0xadc
  408970:	9112bc21 	add	x1, x1, #0x4af
  408974:	aa1303e0 	mov	x0, x19
  408978:	97fffedc 	bl	4084e8 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  40897c:	372000d6 	tbnz	w22, #4, 408994 <log_output_process+0x3c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  408980:	362805b6 	tbz	w22, #5, 408a34 <log_output_process+0x464>
		print_formatted(ctx, "\n");
  408984:	b0000061 	adrp	x1, 415000 <random_data+0xd8c>
  408988:	91320821 	add	x1, x1, #0xc82
		print_formatted(ctx, "\r\n");
  40898c:	aa1303e0 	mov	x0, x19
  408990:	97fffed6 	bl	4084e8 <print_formatted>
		postfix_print(output, flags, level);
	}

	log_output_flush(output);
  408994:	aa1303e0 	mov	x0, x19
}
  408998:	a94153f3 	ldp	x19, x20, [sp, #16]
  40899c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4089a0:	a94363f7 	ldp	x23, x24, [sp, #48]
  4089a4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4089a8:	a94573fb 	ldp	x27, x28, [sp, #80]
  4089ac:	a8c87bfd 	ldp	x29, x30, [sp], #128
	log_output_flush(output);
  4089b0:	17fffefb 	b	40859c <log_output_flush>
		print_formatted(ctx, "\r\n");
  4089b4:	f9403be1 	ldr	x1, [sp, #112]
  4089b8:	17ffffb5 	b	40888c <log_output_process+0x2bc>
		print_formatted(output, " ");
  4089bc:	aa1803e1 	mov	x1, x24
  4089c0:	aa1303e0 	mov	x0, x19
	for (int i = 0; i < prefix_offset; i++) {
  4089c4:	1100077b 	add	w27, w27, #0x1
		print_formatted(output, " ");
  4089c8:	97fffec8 	bl	4084e8 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
  4089cc:	17ffffb3 	b	408898 <log_output_process+0x2c8>
		if (i > 0 && !(i % 8)) {
  4089d0:	1100077b 	add	w27, w27, #0x1
  4089d4:	f2400b7f 	tst	x27, #0x7
  4089d8:	54000081 	b.ne	4089e8 <log_output_process+0x418>  // b.any
			print_formatted(output, " ");
  4089dc:	aa1803e1 	mov	x1, x24
  4089e0:	aa1303e0 	mov	x0, x19
  4089e4:	97fffec1 	bl	4084e8 <print_formatted>
  4089e8:	9100075a 	add	x26, x26, #0x1
  4089ec:	17ffffb3 	b	4088b8 <log_output_process+0x2e8>
			print_formatted(output, "   ");
  4089f0:	f94037e1 	ldr	x1, [sp, #104]
  4089f4:	aa1303e0 	mov	x0, x19
  4089f8:	97fffebc 	bl	4084e8 <print_formatted>
  4089fc:	17ffffb7 	b	4088d8 <log_output_process+0x308>
		if (i > 0 && !(i % 8)) {
  408a00:	b9406be0 	ldr	w0, [sp, #104]
  408a04:	11000400 	add	w0, w0, #0x1
  408a08:	f240081f 	tst	x0, #0x7
  408a0c:	54000081 	b.ne	408a1c <log_output_process+0x44c>  // b.any
			print_formatted(output, " ");
  408a10:	aa1803e1 	mov	x1, x24
  408a14:	aa1303e0 	mov	x0, x19
  408a18:	97fffeb4 	bl	4084e8 <print_formatted>
  408a1c:	9100079c 	add	x28, x28, #0x1
  408a20:	17ffffb8 	b	408900 <log_output_process+0x330>
			print_formatted(output, " ");
  408a24:	aa1803e1 	mov	x1, x24
  408a28:	aa1303e0 	mov	x0, x19
  408a2c:	97fffeaf 	bl	4084e8 <print_formatted>
  408a30:	17ffffc4 	b	408940 <log_output_process+0x370>
		print_formatted(ctx, "\r\n");
  408a34:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408a38:	912d7421 	add	x1, x1, #0xb5d
  408a3c:	17ffffd4 	b	40898c <log_output_process+0x3bc>

0000000000408a40 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg, uint32_t flags)
{
  408a40:	d10143ff 	sub	sp, sp, #0x50
  408a44:	a9017bfd 	stp	x29, x30, [sp, #16]
  408a48:	910043fd 	add	x29, sp, #0x10
  408a4c:	a90253f3 	stp	x19, x20, [sp, #32]
  408a50:	aa0003f4 	mov	x20, x0
  408a54:	aa0103f3 	mov	x19, x1
  408a58:	a9035bf5 	stp	x21, x22, [sp, #48]
  408a5c:	2a0203f5 	mov	w21, w2
  408a60:	f90023f7 	str	x23, [sp, #64]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg_get_source(struct log_msg *msg)
{
	return msg->hdr.source;
  408a64:	a9400c20 	ldp	x0, x3, [x1]
 *
 * @return Timestamp.
 */
static inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)
{
	return msg->hdr.timestamp;
  408a68:	b9400436 	ldr	w22, [x1, #4]
	return msg->hdr.desc.level;
  408a6c:	d3462017 	ubfx	x23, x0, #6, #3
		/* Remote domain is converting source pointer to ID */
		source_id = (int16_t)(uintptr_t)log_msg_get_source(msg);
	} else {
		void *source = (void *)log_msg_get_source(msg);

		if (source != NULL) {
  408a70:	b4000143 	cbz	x3, 408a98 <log_output_msg_process+0x58>
  408a74:	f0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  408a78:	f9472821 	ldr	x1, [x1, #3664]
  408a7c:	cb010063 	sub	x3, x3, x1
  408a80:	d344fc63 	lsr	x3, x3, #4
			source_id = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
  408a84:	13003c61 	sxth	w1, w3
		} else {
			source_id = -1;
		}
	}

	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  408a88:	377802c3 	tbnz	w3, #15, 408ae0 <log_output_msg_process+0xa0>
  408a8c:	53031400 	ubfx	w0, w0, #3, #3
  408a90:	97fffd8d 	bl	4080c4 <log_source_name_get>
  408a94:	aa0003e3 	mov	x3, x0
 *
 * @return pointer to the package.
 */
static inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;
  408a98:	f8410667 	ldr	x7, [x19], #16
	size_t plen, dlen;
	uint8_t *package = log_msg_get_package(msg, &plen);
	uint8_t *data = log_msg_get_data(msg, &dlen);

	log_output_process(output, timestamp, NULL, sname, level,
  408a9c:	b90003f5 	str	w21, [sp]
  408aa0:	2a1703e4 	mov	w4, w23
  408aa4:	2a1603e1 	mov	w1, w22
  408aa8:	d2800002 	mov	x2, #0x0                   	// #0
  408aac:	d3494ce0 	ubfx	x0, x7, #9, #11
  408ab0:	53147ce7 	lsr	w7, w7, #20
  408ab4:	f100001f 	cmp	x0, #0x0
	return msg->data + msg->hdr.desc.package_len;
  408ab8:	8b000266 	add	x6, x19, x0
  408abc:	9a9f1265 	csel	x5, x19, xzr, ne  // ne = any
  408ac0:	aa1403e0 	mov	x0, x20
  408ac4:	97fffec3 	bl	4085d0 <log_output_process>
			   plen > 0 ? package : NULL, data, dlen, flags);
}
  408ac8:	a9417bfd 	ldp	x29, x30, [sp, #16]
  408acc:	a94253f3 	ldp	x19, x20, [sp, #32]
  408ad0:	a9435bf5 	ldp	x21, x22, [sp, #48]
  408ad4:	f94023f7 	ldr	x23, [sp, #64]
  408ad8:	910143ff 	add	sp, sp, #0x50
  408adc:	d65f03c0 	ret
	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  408ae0:	d2800003 	mov	x3, #0x0                   	// #0
  408ae4:	17ffffed 	b	408a98 <log_output_msg_process+0x58>

0000000000408ae8 <log_output_timestamp_freq_set>:
		     output->control_block->ctx);
}

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
  408ae8:	b0000122 	adrp	x2, 42d000 <counter_value>
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  408aec:	52884804 	mov	w4, #0x4240                	// #16960
	timestamp_div = 1U;
  408af0:	52800021 	mov	w1, #0x1                   	// #1
	while (frequency > 1000000) {
  408af4:	52800003 	mov	w3, #0x0                   	// #0
	timestamp_div = 1U;
  408af8:	b90f0441 	str	w1, [x2, #3844]
	while (frequency > 1000000) {
  408afc:	72a001e4 	movk	w4, #0xf, lsl #16
  408b00:	6b04001f 	cmp	w0, w4
  408b04:	540000c8 	b.hi	408b1c <log_output_timestamp_freq_set+0x34>  // b.pmore
  408b08:	34000043 	cbz	w3, 408b10 <log_output_timestamp_freq_set+0x28>
  408b0c:	b90f0441 	str	w1, [x2, #3844]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
  408b10:	b0000121 	adrp	x1, 42d000 <counter_value>
  408b14:	b90f0020 	str	w0, [x1, #3840]
}
  408b18:	d65f03c0 	ret
		frequency /= 2U;
  408b1c:	53017c00 	lsr	w0, w0, #1
		timestamp_div *= 2U;
  408b20:	531f7821 	lsl	w1, w1, #1
  408b24:	52800023 	mov	w3, #0x1                   	// #1
  408b28:	17fffff6 	b	408b00 <log_output_timestamp_freq_set+0x18>

0000000000408b2c <format_set>:
	log_output_func(&log_output_posix, &msg->log, flags);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
	log_format_current = log_type;
  408b2c:	b0000120 	adrp	x0, 42d000 <counter_value>
  408b30:	b90f0801 	str	w1, [x0, #3848]
	return 0;
}
  408b34:	52800000 	mov	w0, #0x0                   	// #0
  408b38:	d65f03c0 	ret

0000000000408b3c <panic>:
	log_output_flush(&log_output_posix);
  408b3c:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  408b40:	91206000 	add	x0, x0, #0x818
  408b44:	17fffe96 	b	40859c <log_output_flush>

0000000000408b48 <char_out>:
{
  408b48:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  408b4c:	910003fd 	mov	x29, sp
  408b50:	a90153f3 	stp	x19, x20, [sp, #16]
  408b54:	b0000134 	adrp	x20, 42d000 <counter_value>
  408b58:	aa0003f3 	mov	x19, x0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  408b5c:	913c3294 	add	x20, x20, #0xf0c
{
  408b60:	a9025bf5 	stp	x21, x22, [sp, #32]
		posix_print_trace("%s\n", stdout_buff);
  408b64:	d0000135 	adrp	x21, 42e000 <des_frames+0x27>
{
  408b68:	aa0103f6 	mov	x22, x1
		posix_print_trace("%s\n", stdout_buff);
  408b6c:	91077eb5 	add	x21, x21, #0x1df
{
  408b70:	a90363f7 	stp	x23, x24, [sp, #48]
  408b74:	8b010017 	add	x23, x0, x1
		posix_print_trace("%s\n", stdout_buff);
  408b78:	b0000078 	adrp	x24, 415000 <random_data+0xd8c>
	for (size_t i = 0; i < length; i++) {
  408b7c:	eb17027f 	cmp	x19, x23
  408b80:	540000e1 	b.ne	408b9c <char_out+0x54>  // b.any
}
  408b84:	2a1603e0 	mov	w0, w22
  408b88:	a94153f3 	ldp	x19, x20, [sp, #16]
  408b8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408b90:	a94363f7 	ldp	x23, x24, [sp, #48]
  408b94:	a8c47bfd 	ldp	x29, x30, [sp], #64
  408b98:	d65f03c0 	ret
		preprint_char(data[i]);
  408b9c:	39400260 	ldrb	w0, [x19]
	if (c == '\r') {
  408ba0:	7100341f 	cmp	w0, #0xd
  408ba4:	54000240 	b.eq	408bec <char_out+0xa4>  // b.none
	if (c != '\n') {
  408ba8:	7100281f 	cmp	w0, #0xa
  408bac:	54000240 	b.eq	408bf4 <char_out+0xac>  // b.none
		stdout_buff[n_pend++] = c;
  408bb0:	b9400282 	ldr	w2, [x20]
  408bb4:	11000441 	add	w1, w2, #0x1
  408bb8:	b9000281 	str	w1, [x20]
  408bbc:	3822caa0 	strb	w0, [x21, w2, sxtw]
	int printnow = 0;
  408bc0:	52800000 	mov	w0, #0x0                   	// #0
		stdout_buff[n_pend] = 0;
  408bc4:	3821cabf 	strb	wzr, [x21, w1, sxtw]
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  408bc8:	b9400281 	ldr	w1, [x20]
  408bcc:	7103f83f 	cmp	w1, #0xfe
  408bd0:	5400004c 	b.gt	408bd8 <char_out+0x90>
	if (printnow) {
  408bd4:	340000c0 	cbz	w0, 408bec <char_out+0xa4>
		posix_print_trace("%s\n", stdout_buff);
  408bd8:	aa1503e1 	mov	x1, x21
  408bdc:	9122ff00 	add	x0, x24, #0x8bf
  408be0:	94000628 	bl	40a480 <posix_print_trace>
		stdout_buff[0] = 0;
  408be4:	390002bf 	strb	wzr, [x21]
		n_pend = 0;
  408be8:	b900029f 	str	wzr, [x20]
	for (size_t i = 0; i < length; i++) {
  408bec:	91000673 	add	x19, x19, #0x1
  408bf0:	17ffffe3 	b	408b7c <char_out+0x34>
		printnow = 1;
  408bf4:	52800020 	mov	w0, #0x1                   	// #1
  408bf8:	17fffff4 	b	408bc8 <char_out+0x80>

0000000000408bfc <process>:
{
  408bfc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408c00:	b0000120 	adrp	x0, 42d000 <counter_value>
{
  408c04:	910003fd 	mov	x29, sp
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408c08:	b94f0800 	ldr	w0, [x0, #3848]
{
  408c0c:	f9000bf3 	str	x19, [sp, #16]
  408c10:	aa0103f3 	mov	x19, x1
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  408c14:	97fffc5c 	bl	407d84 <log_format_func_t_get>
  408c18:	aa0003f0 	mov	x16, x0
	log_output_func(&log_output_posix, &msg->log, flags);
  408c1c:	aa1303e1 	mov	x1, x19
  408c20:	528001e2 	mov	w2, #0xf                   	// #15
}
  408c24:	f9400bf3 	ldr	x19, [sp, #16]
	log_output_func(&log_output_posix, &msg->log, flags);
  408c28:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
}
  408c2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	log_output_func(&log_output_posix, &msg->log, flags);
  408c30:	91206000 	add	x0, x0, #0x818
  408c34:	d61f0200 	br	x16

0000000000408c38 <sys_trace_isr_enter>:
 *
 * SPDX-License-Identifier: Apache-2.0
 */


void sys_trace_isr_enter(void) {}
  408c38:	d65f03c0 	ret

0000000000408c3c <sys_trace_isr_exit>:
  408c3c:	d65f03c0 	ret

0000000000408c40 <sys_trace_idle>:
  408c40:	d65f03c0 	ret

0000000000408c44 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
  408c44:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  408c48:	910003fd 	mov	x29, sp
	sys_trace_idle();
  408c4c:	97fffffd 	bl	408c40 <sys_trace_idle>
	posix_irq_full_unlock();
  408c50:	94000493 	bl	409e9c <posix_irq_full_unlock>
	posix_halt_cpu();
}
  408c54:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_halt_cpu();
  408c58:	140001d9 	b	4093bc <posix_halt_cpu>

0000000000408c5c <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
  408c5c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
  408c60:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408c64:	912e8800 	add	x0, x0, #0xba2
{
  408c68:	910003fd 	mov	x29, sp
	posix_print_error_and_exit("Exiting due to fatal error\n");
  408c6c:	9400059f 	bl	40a2e8 <posix_print_error_and_exit>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  408c70:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408c74:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408c78:	912ef821 	add	x1, x1, #0xbbe
  408c7c:	911b8000 	add	x0, x0, #0x6e0
  408c80:	528002a2 	mov	w2, #0x15                  	// #21
  408c84:	94000599 	bl	40a2e8 <posix_print_error_and_exit>

0000000000408c88 <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
  408c88:	14000487 	b	409ea4 <posix_irq_enable>

0000000000408c8c <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
  408c8c:	34000080 	cbz	w0, 408c9c <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  408c90:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408c94:	912fa400 	add	x0, x0, #0xbe9
  408c98:	14000594 	b	40a2e8 <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
  408c9c:	d65f03c0 	ret

0000000000408ca0 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
  408ca0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408ca4:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408ca8:	912ee000 	add	x0, x0, #0xbb8
{
  408cac:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408cb0:	97ffe1fc 	bl	4014a0 <pthread_mutex_unlock@plt>
  408cb4:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408cb8:	91300c21 	add	x1, x1, #0xc03
  408cbc:	97fffff4 	bl	408c8c <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  408cc0:	97ffe1ec 	bl	401470 <pthread_self@plt>
}
  408cc4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  408cc8:	17ffe1be 	b	4013c0 <pthread_detach@plt>

0000000000408ccc <abort_tail>:
{
  408ccc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	threads_table[this_th_nbr].running = false;
  408cd0:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408cd4:	937b7c00 	sbfiz	x0, x0, #5, #32
{
  408cd8:	910003fd 	mov	x29, sp
	threads_table[this_th_nbr].running = false;
  408cdc:	f945f421 	ldr	x1, [x1, #3048]
  408ce0:	8b000022 	add	x2, x1, x0
  408ce4:	3900105f 	strb	wzr, [x2, #4]
	threads_table[this_th_nbr].state = ABORTED;
  408ce8:	52800062 	mov	w2, #0x3                   	// #3
  408cec:	b8206822 	str	w2, [x1, x0]
	posix_preexit_cleanup();
  408cf0:	97ffffec 	bl	408ca0 <posix_preexit_cleanup>
	pthread_exit(NULL);
  408cf4:	d2800000 	mov	x0, #0x0                   	// #0
  408cf8:	97ffe19e 	bl	401370 <pthread_exit@plt>

0000000000408cfc <posix_wait_until_allowed>:
{
  408cfc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  408d00:	910003fd 	mov	x29, sp
  408d04:	a9025bf5 	stp	x21, x22, [sp, #32]
	threads_table[this_th_nbr].running = false;
  408d08:	90000135 	adrp	x21, 42c000 <__dso_handle>
	while (this_th_nbr != currently_allowed_thread) {
  408d0c:	b0000136 	adrp	x22, 42d000 <counter_value>
{
  408d10:	a90153f3 	stp	x19, x20, [sp, #16]
	threads_table[this_th_nbr].running = false;
  408d14:	937b7c14 	sbfiz	x20, x0, #5, #32
{
  408d18:	2a0003f3 	mov	w19, w0
	threads_table[this_th_nbr].running = false;
  408d1c:	f945f6a0 	ldr	x0, [x21, #3048]
	while (this_th_nbr != currently_allowed_thread) {
  408d20:	913c42d6 	add	x22, x22, #0xf10
{
  408d24:	a90363f7 	stp	x23, x24, [sp, #48]
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408d28:	90000137 	adrp	x23, 42c000 <__dso_handle>
	threads_table[this_th_nbr].running = false;
  408d2c:	8b140000 	add	x0, x0, x20
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408d30:	90000138 	adrp	x24, 42c000 <__dso_handle>
  408d34:	912ee2f7 	add	x23, x23, #0xbb8
  408d38:	912e2318 	add	x24, x24, #0xb88
	threads_table[this_th_nbr].running = false;
  408d3c:	3900101f 	strb	wzr, [x0, #4]
	while (this_th_nbr != currently_allowed_thread) {
  408d40:	b94002c0 	ldr	w0, [x22]
  408d44:	6b13001f 	cmp	w0, w19
  408d48:	54000141 	b.ne	408d70 <posix_wait_until_allowed+0x74>  // b.any
	threads_table[this_th_nbr].running = true;
  408d4c:	f945f6a0 	ldr	x0, [x21, #3048]
  408d50:	52800021 	mov	w1, #0x1                   	// #1
  408d54:	8b140000 	add	x0, x0, x20
  408d58:	39001001 	strb	w1, [x0, #4]
}
  408d5c:	a94153f3 	ldp	x19, x20, [sp, #16]
  408d60:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408d64:	a94363f7 	ldp	x23, x24, [sp, #48]
  408d68:	a8c47bfd 	ldp	x29, x30, [sp], #64
  408d6c:	d65f03c0 	ret
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408d70:	aa1703e1 	mov	x1, x23
  408d74:	aa1803e0 	mov	x0, x24
  408d78:	97ffe19e 	bl	4013f0 <pthread_cond_wait@plt>
		if (threads_table &&
  408d7c:	f945f6a0 	ldr	x0, [x21, #3048]
  408d80:	b4fffe00 	cbz	x0, 408d40 <posix_wait_until_allowed+0x44>
  408d84:	b8746800 	ldr	w0, [x0, x20]
  408d88:	7100081f 	cmp	w0, #0x2
  408d8c:	54fffda1 	b.ne	408d40 <posix_wait_until_allowed+0x44>  // b.any
			abort_tail(this_th_nbr);
  408d90:	2a1303e0 	mov	w0, w19
  408d94:	97ffffce 	bl	408ccc <abort_tail>

0000000000408d98 <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
  408d98:	d0000120 	adrp	x0, 42e000 <des_frames+0x27>
  408d9c:	394b7c00 	ldrb	w0, [x0, #735]
  408da0:	34000180 	cbz	w0, 408dd0 <posix_cleanup_handler+0x38>
{
  408da4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408da8:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408dac:	912ee000 	add	x0, x0, #0xbb8
{
  408db0:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408db4:	97ffe1bb 	bl	4014a0 <pthread_mutex_unlock@plt>
  408db8:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408dbc:	91300c21 	add	x1, x1, #0xc03
  408dc0:	97ffffb3 	bl	408c8c <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  408dc4:	97ffe1ab 	bl	401470 <pthread_self@plt>
}
  408dc8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  408dcc:	17ffe17d 	b	4013c0 <pthread_detach@plt>
  408dd0:	d65f03c0 	ret

0000000000408dd4 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
  408dd4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  408dd8:	910003fd 	mov	x29, sp
  408ddc:	f9000be0 	str	x0, [sp, #16]
  408de0:	f0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  408de4:	f9476800 	ldr	x0, [x0, #3792]
  408de8:	f9400001 	ldr	x1, [x0]
  408dec:	f9007fe1 	str	x1, [sp, #248]
  408df0:	d2800001 	mov	x1, #0x0                   	// #0

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  408df4:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408df8:	912ee000 	add	x0, x0, #0xbb8
  408dfc:	97ffe1a5 	bl	401490 <pthread_mutex_lock@plt>
  408e00:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408e04:	91309821 	add	x1, x1, #0xc26
  408e08:	97ffffa1 	bl	408c8c <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
  408e0c:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408e10:	f945f400 	ldr	x0, [x0, #3048]
  408e14:	b50000a0 	cbnz	x0, 408e28 <posix_thread_starter+0x54>
		posix_cleanup_handler(arg);
  408e18:	f9400be0 	ldr	x0, [sp, #16]
  408e1c:	97ffffdf 	bl	408d98 <posix_cleanup_handler>
		pthread_exit(NULL);
  408e20:	d2800000 	mov	x0, #0x0                   	// #0
  408e24:	97ffe153 	bl	401370 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
  408e28:	90000000 	adrp	x0, 408000 <z_log_msg_commit+0x68>
  408e2c:	91366000 	add	x0, x0, #0xd98
  408e30:	52800001 	mov	w1, #0x0                   	// #0
  408e34:	f9000fe0 	str	x0, [sp, #24]
  408e38:	910083e0 	add	x0, sp, #0x20
  408e3c:	97ffe0f1 	bl	401200 <__sigsetjmp@plt>
  408e40:	340000a0 	cbz	w0, 408e54 <posix_thread_starter+0x80>
  408e44:	a94107e0 	ldp	x0, x1, [sp, #16]
  408e48:	d63f0020 	blr	x1
  408e4c:	910083e0 	add	x0, sp, #0x20
  408e50:	97ffe170 	bl	401410 <__pthread_unwind_next@plt>
  408e54:	910083e0 	add	x0, sp, #0x20
  408e58:	97ffe182 	bl	401460 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
  408e5c:	b94013e0 	ldr	w0, [sp, #16]
  408e60:	97ffffa7 	bl	408cfc <posix_wait_until_allowed>

	posix_new_thread_pre_start();
  408e64:	94000108 	bl	409284 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
  408e68:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408e6c:	b94013e0 	ldr	w0, [sp, #16]
  408e70:	f945f421 	ldr	x1, [x1, #3048]
  408e74:	937b7c00 	sbfiz	x0, x0, #5, #32
  408e78:	8b000020 	add	x0, x1, x0
  408e7c:	f9400c00 	ldr	x0, [x0, #24]

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
  408e80:	a9410c02 	ldp	x2, x3, [x0, #16]
  408e84:	f9400401 	ldr	x1, [x0, #8]
  408e88:	f9400000 	ldr	x0, [x0]
  408e8c:	97fff568 	bl	40642c <z_thread_entry>

0000000000408e90 <posix_swap>:
{
  408e90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408e94:	910003fd 	mov	x29, sp
  408e98:	f9000bf3 	str	x19, [sp, #16]
  408e9c:	2a0103f3 	mov	w19, w1
	currently_allowed_thread = next_allowed_th;
  408ea0:	b0000121 	adrp	x1, 42d000 <counter_value>
  408ea4:	b90f1020 	str	w0, [x1, #3856]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  408ea8:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408eac:	912e2000 	add	x0, x0, #0xb88
  408eb0:	97ffe10c 	bl	4012e0 <pthread_cond_broadcast@plt>
  408eb4:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408eb8:	91311c21 	add	x1, x1, #0xc47
  408ebc:	97ffff74 	bl	408c8c <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
  408ec0:	90000121 	adrp	x1, 42c000 <__dso_handle>
  408ec4:	937b7e60 	sbfiz	x0, x19, #5, #32
  408ec8:	f945f421 	ldr	x1, [x1, #3048]
  408ecc:	b8606820 	ldr	w0, [x1, x0]
  408ed0:	7100081f 	cmp	w0, #0x2
		abort_tail(this_th_nbr);
  408ed4:	2a1303e0 	mov	w0, w19
	if (threads_table[this_th_nbr].state == ABORTING) {
  408ed8:	54000041 	b.ne	408ee0 <posix_swap+0x50>  // b.any
		abort_tail(this_th_nbr);
  408edc:	97ffff7c 	bl	408ccc <abort_tail>
}
  408ee0:	f9400bf3 	ldr	x19, [sp, #16]
  408ee4:	a8c27bfd 	ldp	x29, x30, [sp], #32
		posix_wait_until_allowed(this_th_nbr);
  408ee8:	17ffff85 	b	408cfc <posix_wait_until_allowed>

0000000000408eec <posix_main_thread_start>:
{
  408eec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	currently_allowed_thread = next_allowed_th;
  408ef0:	b0000121 	adrp	x1, 42d000 <counter_value>
{
  408ef4:	910003fd 	mov	x29, sp
	currently_allowed_thread = next_allowed_th;
  408ef8:	b90f1020 	str	w0, [x1, #3856]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  408efc:	90000120 	adrp	x0, 42c000 <__dso_handle>
  408f00:	912e2000 	add	x0, x0, #0xb88
  408f04:	97ffe0f7 	bl	4012e0 <pthread_cond_broadcast@plt>
  408f08:	90000061 	adrp	x1, 414000 <__func__.1+0xd>
  408f0c:	91311c21 	add	x1, x1, #0xc47
  408f10:	97ffff5f 	bl	408c8c <pc_safe_call>
	posix_preexit_cleanup();
  408f14:	97ffff63 	bl	408ca0 <posix_preexit_cleanup>
	pthread_exit(NULL);
  408f18:	d2800000 	mov	x0, #0x0                   	// #0
  408f1c:	97ffe115 	bl	401370 <pthread_exit@plt>

0000000000408f20 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
  408f20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (int i = 0; i < threads_table_size; i++) {
  408f24:	d2800002 	mov	x2, #0x0                   	// #0
{
  408f28:	910003fd 	mov	x29, sp
  408f2c:	a9025bf5 	stp	x21, x22, [sp, #32]
		if ((threads_table[i].state == NOTUSED)
  408f30:	90000135 	adrp	x21, 42c000 <__dso_handle>
	for (int i = 0; i < threads_table_size; i++) {
  408f34:	b0000136 	adrp	x22, 42d000 <counter_value>
{
  408f38:	a90153f3 	stp	x19, x20, [sp, #16]
  408f3c:	aa0003f4 	mov	x20, x0
	for (int i = 0; i < threads_table_size; i++) {
  408f40:	b94f1ac1 	ldr	w1, [x22, #3864]
		if ((threads_table[i].state == NOTUSED)
  408f44:	f945f6a0 	ldr	x0, [x21, #3048]
  408f48:	d1008003 	sub	x3, x0, #0x20
  408f4c:	2a0203f3 	mov	w19, w2
	for (int i = 0; i < threads_table_size; i++) {
  408f50:	6b02003f 	cmp	w1, w2
  408f54:	5400026c 	b.gt	408fa0 <posix_new_thread+0x80>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
  408f58:	11010021 	add	w1, w1, #0x40
	threads_table = realloc(threads_table,
  408f5c:	937b7c21 	sbfiz	x1, x1, #5, #32
  408f60:	97ffe0e8 	bl	401300 <realloc@plt>
  408f64:	f905f6a0 	str	x0, [x21, #3048]
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  408f68:	b5000080 	cbnz	x0, 408f78 <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  408f6c:	90000060 	adrp	x0, 414000 <__func__.1+0xd>
  408f70:	9131b400 	add	x0, x0, #0xc6d
  408f74:	940004dd 	bl	40a2e8 <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
  408f78:	b94f1ad3 	ldr	w19, [x22, #3864]
  return __builtin___memset_chk (__dest, __ch, __len,
  408f7c:	d2810002 	mov	x2, #0x800                 	// #2048
  408f80:	f945f6a3 	ldr	x3, [x21, #3048]
  408f84:	52800001 	mov	w1, #0x0                   	// #0
  408f88:	937b7e60 	sbfiz	x0, x19, #5, #32
  408f8c:	8b000060 	add	x0, x3, x0
  408f90:	97ffe0c4 	bl	4012a0 <memset@plt>
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
  408f94:	11010260 	add	w0, w19, #0x40
  408f98:	b90f1ac0 	str	w0, [x22, #3864]
	return threads_table_size - PC_ALLOC_CHUNK_SIZE;
  408f9c:	14000005 	b	408fb0 <posix_new_thread+0x90>
		if ((threads_table[i].state == NOTUSED)
  408fa0:	91000442 	add	x2, x2, #0x1
  408fa4:	d37be844 	lsl	x4, x2, #5
  408fa8:	b8646864 	ldr	w4, [x3, x4]
  408fac:	35fffd04 	cbnz	w4, 408f4c <posix_new_thread+0x2c>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
  408fb0:	f945f6a1 	ldr	x1, [x21, #3048]
  408fb4:	937b7e60 	sbfiz	x0, x19, #5, #32
  408fb8:	52800022 	mov	w2, #0x1                   	// #1
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  408fbc:	93407e63 	sxtw	x3, w19
	threads_table[t_slot].state = USED;
  408fc0:	8b000024 	add	x4, x1, x0
  408fc4:	b8206822 	str	w2, [x1, x0]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  408fc8:	b0000121 	adrp	x1, 42d000 <counter_value>
  408fcc:	b94f1420 	ldr	w0, [x1, #3860]
	threads_table[t_slot].running = false;
  408fd0:	3900109f 	strb	wzr, [x4, #4]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  408fd4:	b9001080 	str	w0, [x4, #16]
  408fd8:	0b020002 	add	w2, w0, w2
	threads_table[t_slot].t_status = ptr;
  408fdc:	f9000c94 	str	x20, [x4, #24]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  408fe0:	91002080 	add	x0, x4, #0x8
	ptr->thread_idx = t_slot;
  408fe4:	b9002293 	str	w19, [x20, #32]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  408fe8:	b90f1422 	str	w2, [x1, #3860]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  408fec:	d2800001 	mov	x1, #0x0                   	// #0
  408ff0:	90000002 	adrp	x2, 408000 <z_log_msg_commit+0x68>
  408ff4:	91375042 	add	x2, x2, #0xdd4
  408ff8:	97ffe10e 	bl	401430 <pthread_create@plt>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
  408ffc:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409000:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
}
  409004:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409008:	91325421 	add	x1, x1, #0xc95
}
  40900c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  409010:	17ffff1f 	b	408c8c <pc_safe_call>

0000000000409014 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
  409014:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_create_count = 0;
  409018:	90000120 	adrp	x0, 42d000 <counter_value>

	currently_allowed_thread = -1;
  40901c:	12800001 	mov	w1, #0xffffffff            	// #-1
{
  409020:	910003fd 	mov	x29, sp
	thread_create_count = 0;
  409024:	b90f141f 	str	wzr, [x0, #3860]
	currently_allowed_thread = -1;
  409028:	90000120 	adrp	x0, 42d000 <counter_value>
  40902c:	b90f1001 	str	w1, [x0, #3856]

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
  409030:	d2800401 	mov	x1, #0x20                  	// #32
  409034:	d2800800 	mov	x0, #0x40                  	// #64
  409038:	97ffe0a6 	bl	4012d0 <calloc@plt>
  40903c:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409040:	f905f420 	str	x0, [x1, #3048]
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  409044:	b5000080 	cbnz	x0, 409054 <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  409048:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  40904c:	9131b400 	add	x0, x0, #0xc6d
  409050:	940004a6 	bl	40a2e8 <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
  409054:	52800801 	mov	w1, #0x40                  	// #64
  409058:	90000120 	adrp	x0, 42d000 <counter_value>
  40905c:	b90f1801 	str	w1, [x0, #3864]


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  409060:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409064:	912ee000 	add	x0, x0, #0xbb8
  409068:	97ffe10a 	bl	401490 <pthread_mutex_lock@plt>
}
  40906c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  409070:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409074:	91309821 	add	x1, x1, #0xc26
  409078:	17ffff05 	b	408c8c <pc_safe_call>

000000000040907c <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
  40907c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  409080:	910003fd 	mov	x29, sp
  409084:	a9025bf5 	stp	x21, x22, [sp, #32]

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  409088:	f0000115 	adrp	x21, 42c000 <__dso_handle>
  40908c:	f945f6a0 	ldr	x0, [x21, #3048]
{
  409090:	a90153f3 	stp	x19, x20, [sp, #16]
  409094:	f9001bf7 	str	x23, [sp, #48]
	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  409098:	b4000200 	cbz	x0, 4090d8 <posix_core_clean_up+0x5c>
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;
  40909c:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>

	for (int i = 0; i < threads_table_size; i++) {
  4090a0:	90000134 	adrp	x20, 42d000 <counter_value>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
  4090a4:	f0000056 	adrp	x22, 414000 <__func__.1+0xd>
	for (int i = 0; i < threads_table_size; i++) {
  4090a8:	913c6294 	add	x20, x20, #0xf18
			posix_print_warning(
  4090ac:	9133e6d6 	add	x22, x22, #0xcf9
	terminate = true;
  4090b0:	52800021 	mov	w1, #0x1                   	// #1
	for (int i = 0; i < threads_table_size; i++) {
  4090b4:	d2800013 	mov	x19, #0x0                   	// #0
	terminate = true;
  4090b8:	390b7c01 	strb	w1, [x0, #735]
	for (int i = 0; i < threads_table_size; i++) {
  4090bc:	b9400281 	ldr	w1, [x20]
		if (threads_table[i].state != USED) {
  4090c0:	912fa2b7 	add	x23, x21, #0xbe8
  4090c4:	f945f6a0 	ldr	x0, [x21, #3048]
	for (int i = 0; i < threads_table_size; i++) {
  4090c8:	6b13003f 	cmp	w1, w19
  4090cc:	5400010c 	b.gt	4090ec <posix_core_clean_up+0x70>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
  4090d0:	97ffe0c4 	bl	4013e0 <free@plt>
	threads_table = NULL;
  4090d4:	f90002ff 	str	xzr, [x23]
}
  4090d8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4090dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4090e0:	f9401bf7 	ldr	x23, [sp, #48]
  4090e4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4090e8:	d65f03c0 	ret
		if (threads_table[i].state != USED) {
  4090ec:	d37bea61 	lsl	x1, x19, #5
  4090f0:	8b131402 	add	x2, x0, x19, lsl #5
  4090f4:	b8616800 	ldr	w0, [x0, x1]
  4090f8:	7100041f 	cmp	w0, #0x1
  4090fc:	540000e1 	b.ne	409118 <posix_core_clean_up+0x9c>  // b.any
		if (pthread_cancel(threads_table[i].thread)) {
  409100:	f9400440 	ldr	x0, [x2, #8]
  409104:	97ffe0df 	bl	401480 <pthread_cancel@plt>
  409108:	34000080 	cbz	w0, 409118 <posix_core_clean_up+0x9c>
			posix_print_warning(
  40910c:	2a1303e1 	mov	w1, w19
  409110:	aa1603e0 	mov	x0, x22
  409114:	940004a9 	bl	40a3b8 <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
  409118:	91000673 	add	x19, x19, #0x1
  40911c:	17ffffe8 	b	4090bc <posix_core_clean_up+0x40>

0000000000409120 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
  409120:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409124:	937b7c00 	sbfiz	x0, x0, #5, #32
  409128:	f945f421 	ldr	x1, [x1, #3048]
  40912c:	b8606822 	ldr	w2, [x1, x0]
  409130:	7100045f 	cmp	w2, #0x1
  409134:	54000061 	b.ne	409140 <posix_abort_thread+0x20>  // b.any

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
  409138:	52800042 	mov	w2, #0x2                   	// #2
  40913c:	b8206822 	str	w2, [x1, x0]
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
  409140:	d65f03c0 	ret

0000000000409144 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
  409144:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409148:	910003fd 	mov	x29, sp
  40914c:	a90153f3 	stp	x19, x20, [sp, #16]
  409150:	aa0003f4 	mov	x20, x0
  409154:	a9025bf5 	stp	x21, x22, [sp, #32]
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
  409158:	f9402813 	ldr	x19, [x0, #80]
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
  40915c:	b9402276 	ldr	w22, [x19, #32]
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
  409160:	9400034c 	bl	409e90 <posix_irq_lock>
  409164:	2a0003f5 	mov	w21, w0

	key = irq_lock();

	if (_current == thread) {
  409168:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40916c:	f9472c00 	ldr	x0, [x0, #3672]
  409170:	f9400800 	ldr	x0, [x0, #16]
  409174:	eb14001f 	cmp	x0, x20
  409178:	54000141 	b.ne	4091a0 <z_impl_k_thread_abort+0x5c>  // b.any
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
  40917c:	b9402660 	ldr	w0, [x19, #36]
  409180:	350002a0 	cbnz	w0, 4091d4 <z_impl_k_thread_abort+0x90>
			tstatus->aborted = 1;
  409184:	52800020 	mov	w0, #0x1                   	// #1
  409188:	b9002660 	str	w0, [x19, #36]
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
  40918c:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409190:	937b7ec0 	sbfiz	x0, x22, #5, #32
  409194:	52800042 	mov	w2, #0x2                   	// #2
  409198:	f945f421 	ldr	x1, [x1, #3048]
  40919c:	b8206822 	str	w2, [x1, x0]
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
  4091a0:	aa1403e0 	mov	x0, x20
  4091a4:	940023f0 	bl	412164 <z_thread_abort>

	if (tstatus->aborted == 0) {
  4091a8:	b9402660 	ldr	w0, [x19, #36]
  4091ac:	350000a0 	cbnz	w0, 4091c0 <z_impl_k_thread_abort+0x7c>
		PC_DEBUG("%s aborting now [%i] %i\n",
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
  4091b0:	52800020 	mov	w0, #0x1                   	// #1
  4091b4:	b9002660 	str	w0, [x19, #36]
		posix_abort_thread(thread_idx);
  4091b8:	2a1603e0 	mov	w0, w22
  4091bc:	97ffffd9 	bl	409120 <posix_abort_thread>
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
  4091c0:	2a1503e0 	mov	w0, w21
}
  4091c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4091c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4091cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule_irqlock(key);
  4091d0:	14001cd7 	b	41052c <z_reschedule_irqlock>
			posix_print_warning(/* LCOV_EXCL_LINE */
  4091d4:	2a1603e1 	mov	w1, w22
  4091d8:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  4091dc:	9134b400 	add	x0, x0, #0xd2d
  4091e0:	94000476 	bl	40a3b8 <posix_print_warning>
  4091e4:	17ffffea 	b	40918c <z_impl_k_thread_abort+0x48>

00000000004091e8 <arch_swap>:
#include <zephyr/irq.h>
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
  4091e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4091ec:	910003fd 	mov	x29, sp
  4091f0:	f9000bf3 	str	x19, [sp, #16]
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
  4091f4:	d0000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  4091f8:	f9472e73 	ldr	x19, [x19, #3672]
  4091fc:	f9400a61 	ldr	x1, [x19, #16]
  409200:	b9004820 	str	w0, [x1, #72]
	_current->callee_saved.retval = -EAGAIN;
  409204:	12800140 	mov	w0, #0xfffffff5            	// #-11
  409208:	b9004c20 	str	w0, [x1, #76]
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
  40920c:	f9401660 	ldr	x0, [x19, #40]
	posix_thread_status_t *this_thread_ptr  =
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
  409210:	f9000a60 	str	x0, [x19, #16]
	posix_thread_status_t *this_thread_ptr  =
  409214:	f9402821 	ldr	x1, [x1, #80]
	posix_thread_status_t *ready_thread_ptr =
  409218:	f9402802 	ldr	x2, [x0, #80]
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
  40921c:	b9402021 	ldr	w1, [x1, #32]
  409220:	b9402040 	ldr	w0, [x2, #32]
  409224:	97ffff1b 	bl	408e90 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
  409228:	f9400a60 	ldr	x0, [x19, #16]
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
  40922c:	b9404800 	ldr	w0, [x0, #72]
  409230:	9400031a 	bl	409e98 <posix_irq_unlock>

	return _current->callee_saved.retval;
  409234:	f9400a60 	ldr	x0, [x19, #16]
}
  409238:	f9400bf3 	ldr	x19, [sp, #16]
  40923c:	b9404c00 	ldr	w0, [x0, #76]
  409240:	a8c27bfd 	ldp	x29, x30, [sp], #32
  409244:	d65f03c0 	ret

0000000000409248 <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
  409248:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40924c:	f9472c00 	ldr	x0, [x0, #3672]
  409250:	f9401401 	ldr	x1, [x0, #40]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
  409254:	f9000801 	str	x1, [x0, #16]
	posix_thread_status_t *ready_thread_ptr =
  409258:	f9402822 	ldr	x2, [x1, #80]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
  40925c:	b9402040 	ldr	w0, [x2, #32]
  409260:	17ffff23 	b	408eec <posix_main_thread_start>

0000000000409264 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
  409264:	aa0003e1 	mov	x1, x0
	posix_thread_status_t *thread_status;

	/* We store it in the same place where normal archs store the
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
  409268:	d100a040 	sub	x0, x2, #0x28

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
  40926c:	f81d8043 	stur	x3, [x2, #-40]
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
  409270:	a9009404 	stp	x4, x5, [x0, #8]
	thread_status->arg3 = p3;
  409274:	f9000c06 	str	x6, [x0, #24]
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
  409278:	b900241f 	str	wzr, [x0, #36]
#endif

	thread->callee_saved.thread_status = thread_status;
  40927c:	f9002820 	str	x0, [x1, #80]

	posix_new_thread(thread_status);
  409280:	17ffff28 	b	408f20 <posix_new_thread>

0000000000409284 <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
  409284:	14000306 	b	409e9c <posix_irq_full_unlock>

0000000000409288 <pc_safe_call>:
	if (unlikely(test)) {
  409288:	34000080 	cbz	w0, 409298 <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  40928c:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  409290:	912fa400 	add	x0, x0, #0xbe9
  409294:	14000415 	b	40a2e8 <posix_print_error_and_exit>
}
  409298:	d65f03c0 	ret

000000000040929c <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
  40929c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4092a0:	910003fd 	mov	x29, sp
  4092a4:	f9000bf3 	str	x19, [sp, #16]
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4092a8:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  4092ac:	91308273 	add	x19, x19, #0xc20
  4092b0:	aa1303e0 	mov	x0, x19
  4092b4:	97ffe077 	bl	401490 <pthread_mutex_lock@plt>
  4092b8:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  4092bc:	9136a421 	add	x1, x1, #0xda9
  4092c0:	97fffff2 	bl	409288 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  4092c4:	aa1303e0 	mov	x0, x19
  4092c8:	97ffe076 	bl	4014a0 <pthread_mutex_unlock@plt>
  4092cc:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  4092d0:	91371821 	add	x1, x1, #0xdc6
  4092d4:	97ffffed 	bl	409288 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
  4092d8:	97ffff4f 	bl	409014 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
  4092dc:	9400117f 	bl	40d8d8 <z_cstart>

00000000004092e0 <posix_is_cpu_running>:
	return !cpu_halted;
  4092e0:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  4092e4:	39504000 	ldrb	w0, [x0, #1040]
}
  4092e8:	52000000 	eor	w0, w0, #0x1
  4092ec:	d65f03c0 	ret

00000000004092f0 <posix_change_cpu_state_and_wait>:
{
  4092f0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4092f4:	910003fd 	mov	x29, sp
  4092f8:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4092fc:	f0000115 	adrp	x21, 42c000 <__dso_handle>
{
  409300:	12001c16 	and	w22, w0, #0xff
  409304:	f9001bf7 	str	x23, [sp, #48]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409308:	913082b7 	add	x23, x21, #0xc20
  40930c:	aa1703e0 	mov	x0, x23
{
  409310:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409314:	97ffe05f 	bl	401490 <pthread_mutex_lock@plt>
	cpu_halted = halted;
  409318:	f0000113 	adrp	x19, 42c000 <__dso_handle>
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  40931c:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409320:	9136a421 	add	x1, x1, #0xda9
  409324:	97ffffd9 	bl	409288 <pc_safe_call>
	cpu_halted = halted;
  409328:	39104276 	strb	w22, [x19, #1040]
	while (cpu_halted == halted) {
  40932c:	91104273 	add	x19, x19, #0x410
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  409330:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  409334:	912fc294 	add	x20, x20, #0xbf0
  409338:	aa1403e0 	mov	x0, x20
  40933c:	97ffdfe9 	bl	4012e0 <pthread_cond_broadcast@plt>
  409340:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409344:	91379421 	add	x1, x1, #0xde5
  409348:	97ffffd0 	bl	409288 <pc_safe_call>
	while (cpu_halted == halted) {
  40934c:	39400260 	ldrb	w0, [x19]
  409350:	6b16001f 	cmp	w0, w22
  409354:	54000140 	b.eq	40937c <posix_change_cpu_state_and_wait+0x8c>  // b.none
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409358:	913082a0 	add	x0, x21, #0xc20
  40935c:	97ffe051 	bl	4014a0 <pthread_mutex_unlock@plt>
}
  409360:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409364:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
}
  409368:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  40936c:	91371821 	add	x1, x1, #0xdc6
}
  409370:	f9401bf7 	ldr	x23, [sp, #48]
  409374:	a8c47bfd 	ldp	x29, x30, [sp], #64
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409378:	17ffffc4 	b	409288 <pc_safe_call>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  40937c:	aa1703e1 	mov	x1, x23
  409380:	aa1403e0 	mov	x0, x20
  409384:	97ffe01b 	bl	4013f0 <pthread_cond_wait@plt>
  409388:	17fffff1 	b	40934c <posix_change_cpu_state_and_wait+0x5c>

000000000040938c <posix_interrupt_raised>:
{
  40938c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(false);
  409390:	52800000 	mov	w0, #0x0                   	// #0
{
  409394:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(false);
  409398:	97ffffd6 	bl	4092f0 <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
  40939c:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  4093a0:	394b8000 	ldrb	w0, [x0, #736]
  4093a4:	34000080 	cbz	w0, 4093b4 <posix_interrupt_raised+0x28>
}
  4093a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_exit(0);
  4093ac:	52800000 	mov	w0, #0x0                   	// #0
  4093b0:	14000378 	b	40a190 <posix_exit>
}
  4093b4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4093b8:	d65f03c0 	ret

00000000004093bc <posix_halt_cpu>:
{
  4093bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(true);
  4093c0:	52800020 	mov	w0, #0x1                   	// #1
{
  4093c4:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(true);
  4093c8:	97ffffca 	bl	4092f0 <posix_change_cpu_state_and_wait>
}
  4093cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_irq_handler();
  4093d0:	14000245 	b	409ce4 <posix_irq_handler>

00000000004093d4 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
  4093d4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4093d8:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4093dc:	910003fd 	mov	x29, sp
  4093e0:	f9476800 	ldr	x0, [x0, #3792]
  4093e4:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));

	cpu_halted = false;
  4093e8:	f0000113 	adrp	x19, 42c000 <__dso_handle>
{
  4093ec:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4093f0:	f0000115 	adrp	x21, 42c000 <__dso_handle>
  4093f4:	913082b6 	add	x22, x21, #0xc20
{
  4093f8:	f9400001 	ldr	x1, [x0]
  4093fc:	f9001fe1 	str	x1, [sp, #56]
  409400:	d2800001 	mov	x1, #0x0                   	// #0
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409404:	aa1603e0 	mov	x0, x22
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  409408:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  40940c:	912fc294 	add	x20, x20, #0xbf0
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409410:	97ffe020 	bl	401490 <pthread_mutex_lock@plt>
  409414:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409418:	9136a421 	add	x1, x1, #0xda9
  40941c:	97ffff9b 	bl	409288 <pc_safe_call>
	cpu_halted = false;
  409420:	3910427f 	strb	wzr, [x19, #1040]
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  409424:	90000002 	adrp	x2, 409000 <posix_new_thread+0xe0>
	while (cpu_halted == false) {
  409428:	91104273 	add	x19, x19, #0x410
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  40942c:	910a7042 	add	x2, x2, #0x29c
  409430:	d2800003 	mov	x3, #0x0                   	// #0
  409434:	d2800001 	mov	x1, #0x0                   	// #0
  409438:	9100c3e0 	add	x0, sp, #0x30
  40943c:	97ffdffd 	bl	401430 <pthread_create@plt>
  409440:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409444:	91381c21 	add	x1, x1, #0xe07
  409448:	97ffff90 	bl	409288 <pc_safe_call>
	while (cpu_halted == false) {
  40944c:	39400260 	ldrb	w0, [x19]
  409450:	34000260 	cbz	w0, 40949c <posix_boot_cpu+0xc8>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409454:	913082a0 	add	x0, x21, #0xc20
  409458:	97ffe012 	bl	4014a0 <pthread_mutex_unlock@plt>
  40945c:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409460:	91371821 	add	x1, x1, #0xdc6
  409464:	97ffff89 	bl	409288 <pc_safe_call>

	if (soc_terminate) {
  409468:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  40946c:	394b8000 	ldrb	w0, [x0, #736]
  409470:	34000060 	cbz	w0, 40947c <posix_boot_cpu+0xa8>
		posix_exit(0);
  409474:	52800000 	mov	w0, #0x0                   	// #0
  409478:	94000346 	bl	40a190 <posix_exit>
	}
}
  40947c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409480:	f9476800 	ldr	x0, [x0, #3792]
  409484:	f9401fe2 	ldr	x2, [sp, #56]
  409488:	f9400001 	ldr	x1, [x0]
  40948c:	eb010042 	subs	x2, x2, x1
  409490:	d2800001 	mov	x1, #0x0                   	// #0
  409494:	540000c0 	b.eq	4094ac <posix_boot_cpu+0xd8>  // b.none
  409498:	97ffdfa2 	bl	401320 <__stack_chk_fail@plt>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  40949c:	aa1603e1 	mov	x1, x22
  4094a0:	aa1403e0 	mov	x0, x20
  4094a4:	97ffdfd3 	bl	4013f0 <pthread_cond_wait@plt>
  4094a8:	17ffffe9 	b	40944c <posix_boot_cpu+0x78>
}
  4094ac:	a94153f3 	ldp	x19, x20, [sp, #16]
  4094b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4094b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4094b8:	d65f03c0 	ret

00000000004094bc <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
  4094bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  4094c0:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4094c4:	91256021 	add	x1, x1, #0x958
{
  4094c8:	910003fd 	mov	x29, sp
  4094cc:	a90153f3 	stp	x19, x20, [sp, #16]
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  4094d0:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
  4094d4:	11000400 	add	w0, w0, #0x1
  4094d8:	f860d834 	ldr	x20, [x1, w0, sxtw #3]
  4094dc:	eb13029f 	cmp	x20, x19
  4094e0:	54000088 	b.hi	4094f0 <run_native_tasks+0x34>  // b.pmore
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
			(*fptr)();
		}
	}
}
  4094e4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4094e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4094ec:	d65f03c0 	ret
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
  4094f0:	f9400260 	ldr	x0, [x19]
  4094f4:	b4000040 	cbz	x0, 4094fc <run_native_tasks+0x40>
			(*fptr)();
  4094f8:	d63f0000 	blr	x0
		fptr++) {
  4094fc:	91002273 	add	x19, x19, #0x8
  409500:	17fffff7 	b	4094dc <run_native_tasks+0x20>

0000000000409504 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
  409504:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409508:	910003fd 	mov	x29, sp
  40950c:	a90153f3 	stp	x19, x20, [sp, #16]
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
  409510:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  409514:	39504280 	ldrb	w0, [x20, #1040]
{
  409518:	f90013f5 	str	x21, [sp, #32]
	if (cpu_halted) {
  40951c:	340000e0 	cbz	w0, 409538 <posix_soc_clean_up+0x34>

		posix_core_clean_up();
  409520:	97fffed7 	bl	40907c <posix_core_clean_up>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
  409524:	a94153f3 	ldp	x19, x20, [sp, #16]
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  409528:	52800080 	mov	w0, #0x4                   	// #4
}
  40952c:	f94013f5 	ldr	x21, [sp, #32]
  409530:	a8c37bfd 	ldp	x29, x30, [sp], #48
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  409534:	17ffffe2 	b	4094bc <run_native_tasks>
	} else if (soc_terminate == false) {
  409538:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  40953c:	394b8001 	ldrb	w1, [x0, #736]
  409540:	35000321 	cbnz	w1, 4095a4 <posix_soc_clean_up+0xa0>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409544:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409548:	91308273 	add	x19, x19, #0xc20
		soc_terminate = true;
  40954c:	52800035 	mov	w21, #0x1                   	// #1
  409550:	390b8015 	strb	w21, [x0, #736]
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  409554:	aa1303e0 	mov	x0, x19
  409558:	97ffdfce 	bl	401490 <pthread_mutex_lock@plt>
  40955c:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409560:	9136a421 	add	x1, x1, #0xda9
  409564:	97ffff49 	bl	409288 <pc_safe_call>
		cpu_halted = true;
  409568:	39104295 	strb	w21, [x20, #1040]
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  40956c:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409570:	912fc000 	add	x0, x0, #0xbf0
  409574:	97ffdf5b 	bl	4012e0 <pthread_cond_broadcast@plt>
  409578:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  40957c:	91379421 	add	x1, x1, #0xde5
  409580:	97ffff42 	bl	409288 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  409584:	aa1303e0 	mov	x0, x19
  409588:	97ffdfc6 	bl	4014a0 <pthread_mutex_unlock@plt>
  40958c:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409590:	91371821 	add	x1, x1, #0xdc6
  409594:	97ffff3d 	bl	409288 <pc_safe_call>
			sleep(1);
  409598:	52800020 	mov	w0, #0x1                   	// #1
  40959c:	97ffdf45 	bl	4012b0 <sleep@plt>
		while (1) {
  4095a0:	17fffffe 	b	409598 <posix_soc_clean_up+0x94>
}
  4095a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4095a8:	f94013f5 	ldr	x21, [sp, #32]
  4095ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4095b0:	d65f03c0 	ret

00000000004095b4 <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
  4095b4:	90000120 	adrp	x0, 42d000 <counter_value>
  4095b8:	52800021 	mov	w1, #0x1                   	// #1
  4095bc:	b90f1c01 	str	w1, [x0, #3868]
}
  4095c0:	d65f03c0 	ret

00000000004095c4 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
  4095c4:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
  4095c8:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4095cc:	910003fd 	mov	x29, sp
  4095d0:	f9476800 	ldr	x0, [x0, #3792]
  4095d4:	f9000bf3 	str	x19, [sp, #16]
  4095d8:	f9400001 	ldr	x1, [x0]
  4095dc:	f9005fe1 	str	x1, [sp, #184]
  4095e0:	d2800001 	mov	x1, #0x0                   	// #0
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
  4095e4:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4095e8:	f9475400 	ldr	x0, [x0, #3752]
  4095ec:	f90013e0 	str	x0, [sp, #32]
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
  4095f0:	9100a3e0 	add	x0, sp, #0x28
  4095f4:	97ffdf23 	bl	401280 <sigemptyset@plt>
	if (unlikely(test)) {
  4095f8:	340000c0 	cbz	w0, 409610 <hwm_set_sig_handler+0x4c>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  4095fc:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409600:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  409604:	91390821 	add	x1, x1, #0xe42
  409608:	912fa400 	add	x0, x0, #0xbe9
  40960c:	94000337 	bl	40a2e8 <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;
  409610:	52b00000 	mov	w0, #0x80000000            	// #-2147483648

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  409614:	910083f3 	add	x19, sp, #0x20
  409618:	aa1303e1 	mov	x1, x19
  40961c:	d2800002 	mov	x2, #0x0                   	// #0
	act.sa_flags = SA_RESETHAND;
  409620:	b900abe0 	str	w0, [sp, #168]
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  409624:	528001e0 	mov	w0, #0xf                   	// #15
  409628:	97ffdf42 	bl	401330 <sigaction@plt>
	if (unlikely(test)) {
  40962c:	340000c0 	cbz	w0, 409644 <hwm_set_sig_handler+0x80>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  409630:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  409634:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  409638:	91397021 	add	x1, x1, #0xe5c
  40963c:	912fa400 	add	x0, x0, #0xbe9
  409640:	9400032a 	bl	40a2e8 <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
  409644:	aa1303e1 	mov	x1, x19
  409648:	d2800002 	mov	x2, #0x0                   	// #0
  40964c:	52800040 	mov	w0, #0x2                   	// #2
  409650:	97ffdf38 	bl	401330 <sigaction@plt>
	if (unlikely(test)) {
  409654:	340000c0 	cbz	w0, 40966c <hwm_set_sig_handler+0xa8>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  409658:	f0000041 	adrp	x1, 414000 <__func__.1+0xd>
  40965c:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  409660:	9139ec21 	add	x1, x1, #0xe7b
  409664:	912fa400 	add	x0, x0, #0xbe9
  409668:	94000320 	bl	40a2e8 <posix_print_error_and_exit>
}
  40966c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409670:	f9476800 	ldr	x0, [x0, #3792]
  409674:	f9405fe2 	ldr	x2, [sp, #184]
  409678:	f9400001 	ldr	x1, [x0]
  40967c:	eb010042 	subs	x2, x2, x1
  409680:	d2800001 	mov	x1, #0x0                   	// #0
  409684:	54000040 	b.eq	40968c <hwm_set_sig_handler+0xc8>  // b.none
  409688:	97ffdf26 	bl	401320 <__stack_chk_fail@plt>
  40968c:	f9400bf3 	ldr	x19, [sp, #16]
  409690:	a8cc7bfd 	ldp	x29, x30, [sp], #192
  409694:	d65f03c0 	ret

0000000000409698 <hwm_find_next_timer>:
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
  409698:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
  40969c:	d0000102 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
	next_timer_index = 0;
  4096a0:	f0000101 	adrp	x1, 42c000 <__dso_handle>
	next_timer_time  = *Timer_list[0];
  4096a4:	f9475800 	ldr	x0, [x0, #3760]
	next_timer_index = 0;
  4096a8:	b903f83f 	str	wzr, [x1, #1016]
		if (next_timer_time > *Timer_list[i]) {
  4096ac:	f9478c42 	ldr	x2, [x2, #3864]
	next_timer_time  = *Timer_list[0];
  4096b0:	f9400003 	ldr	x3, [x0]
  4096b4:	f0000100 	adrp	x0, 42c000 <__dso_handle>
		if (next_timer_time > *Timer_list[i]) {
  4096b8:	f9400042 	ldr	x2, [x2]
	next_timer_time  = *Timer_list[0];
  4096bc:	f9062803 	str	x3, [x0, #3152]
		if (next_timer_time > *Timer_list[i]) {
  4096c0:	eb02007f 	cmp	x3, x2
  4096c4:	54000089 	b.ls	4096d4 <hwm_find_next_timer+0x3c>  // b.plast
			next_timer_index = i;
  4096c8:	52800023 	mov	w3, #0x1                   	// #1
			next_timer_time = *Timer_list[i];
  4096cc:	f9062802 	str	x2, [x0, #3152]
			next_timer_index = i;
  4096d0:	b903f823 	str	w3, [x1, #1016]
		if (next_timer_time > *Timer_list[i]) {
  4096d4:	d0000102 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
  4096d8:	f9462803 	ldr	x3, [x0, #3152]
  4096dc:	f947d042 	ldr	x2, [x2, #4000]
  4096e0:	f9400042 	ldr	x2, [x2]
  4096e4:	eb03005f 	cmp	x2, x3
  4096e8:	54000082 	b.cs	4096f8 <hwm_find_next_timer+0x60>  // b.hs, b.nlast
			next_timer_index = i;
  4096ec:	52800043 	mov	w3, #0x2                   	// #2
			next_timer_time = *Timer_list[i];
  4096f0:	f9062802 	str	x2, [x0, #3152]
			next_timer_index = i;
  4096f4:	b903f823 	str	w3, [x1, #1016]
		}
	}
}
  4096f8:	d65f03c0 	ret

00000000004096fc <hwm_one_event>:

/**
 * Execute the next scheduled HW event/timer
 */
void hwm_one_event(void)
{
  4096fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  409700:	f0000100 	adrp	x0, 42c000 <__dso_handle>
{
  409704:	910003fd 	mov	x29, sp
  409708:	a90153f3 	stp	x19, x20, [sp, #16]
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  40970c:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409710:	f0000114 	adrp	x20, 42c000 <__dso_handle>
  409714:	f9462801 	ldr	x1, [x0, #3152]
  409718:	f9462e62 	ldr	x2, [x19, #3160]
  40971c:	eb02003f 	cmp	x1, x2
  409720:	540003c3 	b.cc	409798 <hwm_one_event+0x9c>  // b.lo, b.ul, b.last
		simu_time = next_timer_time;
  409724:	f9062e61 	str	x1, [x19, #3160]
	if (signaled_end || (simu_time > end_of_time)) {
  409728:	90000120 	adrp	x0, 42d000 <counter_value>
  40972c:	b94f1c01 	ldr	w1, [x0, #3868]
  409730:	f9462e60 	ldr	x0, [x19, #3160]
  409734:	350000a1 	cbnz	w1, 409748 <hwm_one_event+0x4c>
  409738:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  40973c:	f9400c21 	ldr	x1, [x1, #24]
  409740:	eb00003f 	cmp	x1, x0
  409744:	54000162 	b.cs	409770 <hwm_one_event+0x74>  // b.hs, b.nlast
				((long double)simu_time)/1.0e6L);
  409748:	97ffe216 	bl	401fa0 <__floatunditf>
		posix_print_trace("\nStopped at %.3Lfs\n",
  40974c:	d0000040 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  409750:	9114c000 	add	x0, x0, #0x530
  409754:	3dc00001 	ldr	q1, [x0]
  409758:	97ffdfba 	bl	401640 <__divtf3>
  40975c:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  409760:	913b3800 	add	x0, x0, #0xece
  409764:	94000347 	bl	40a480 <posix_print_trace>
		posix_exit(0);
  409768:	52800000 	mov	w0, #0x0                   	// #0
  40976c:	94000289 	bl	40a190 <posix_exit>
	hwm_sleep_until_next_timer();

	switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
  409770:	b943fa80 	ldr	w0, [x20, #1016]
  409774:	7100041f 	cmp	w0, #0x1
  409778:	540001a0 	b.eq	4097ac <hwm_one_event+0xb0>  // b.none
  40977c:	7100081f 	cmp	w0, #0x2
  409780:	540001a0 	b.eq	4097b4 <hwm_one_event+0xb8>  // b.none
  409784:	350001c0 	cbnz	w0, 4097bc <hwm_one_event+0xc0>
	case HWTIMER:
		hwtimer_timer_reached();
  409788:	940000b7 	bl	409a64 <hwtimer_timer_reached>
		break;
		/* LCOV_EXCL_STOP */
	}

	hwm_find_next_timer();
}
  40978c:	a94153f3 	ldp	x19, x20, [sp, #16]
  409790:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  409794:	17ffffc1 	b	409698 <hwm_find_next_timer>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
  409798:	b943fa83 	ldr	w3, [x20, #1016]
  40979c:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  4097a0:	913a6400 	add	x0, x0, #0xe99
  4097a4:	94000305 	bl	40a3b8 <posix_print_warning>
  4097a8:	17ffffe0 	b	409728 <hwm_one_event+0x2c>
		hw_irq_ctrl_timer_triggered();
  4097ac:	94000274 	bl	40a17c <hw_irq_ctrl_timer_triggered>
		break;
  4097b0:	17fffff7 	b	40978c <hwm_one_event+0x90>
		hw_counter_triggered();
  4097b4:	94000615 	bl	40b008 <hw_counter_triggered>
		break;
  4097b8:	17fffff5 	b	40978c <hwm_one_event+0x90>
		posix_print_error_and_exit(
  4097bc:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  4097c0:	913b8800 	add	x0, x0, #0xee2
  4097c4:	940002c9 	bl	40a2e8 <posix_print_error_and_exit>
		break;
  4097c8:	17fffff1 	b	40978c <hwm_one_event+0x90>

00000000004097cc <hwm_set_end_of_time>:
/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
	end_of_time = new_end_of_time;
  4097cc:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  4097d0:	f9000c20 	str	x0, [x1, #24]
}
  4097d4:	d65f03c0 	ret

00000000004097d8 <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
  4097d8:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  4097dc:	f9462c00 	ldr	x0, [x0, #3160]
  4097e0:	d65f03c0 	ret

00000000004097e4 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
  4097e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4097e8:	910003fd 	mov	x29, sp
	hwm_set_sig_handler();
  4097ec:	97ffff76 	bl	4095c4 <hwm_set_sig_handler>
	hwtimer_init();
  4097f0:	94000055 	bl	409944 <hwtimer_init>
	hw_counter_init();
  4097f4:	940005f8 	bl	40afd4 <hw_counter_init>
	hw_irq_ctrl_init();
  4097f8:	940001da 	bl	409f60 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
  4097fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hwm_find_next_timer();
  409800:	17ffffa6 	b	409698 <hwm_find_next_timer>

0000000000409804 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
  409804:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409808:	910003fd 	mov	x29, sp
	hwtimer_cleanup();
  40980c:	94000086 	bl	409a24 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
  409810:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hw_irq_ctrl_cleanup();
  409814:	140001e0 	b	409f94 <hw_irq_ctrl_cleanup>

0000000000409818 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
  409818:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40981c:	f947a800 	ldr	x0, [x0, #3920]
  409820:	f9400001 	ldr	x1, [x0]
  409824:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409828:	f9477c00 	ldr	x0, [x0, #3832]
  40982c:	f9400000 	ldr	x0, [x0]
  409830:	eb01001f 	cmp	x0, x1
  409834:	9a819000 	csel	x0, x0, x1, ls  // ls = plast
  409838:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40983c:	f9475821 	ldr	x1, [x1, #3760]
  409840:	f9000020 	str	x0, [x1]
}
  409844:	d65f03c0 	ret

0000000000409848 <native_add_time_options>:
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
  409848:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  40984c:	9100a000 	add	x0, x0, #0x28
  409850:	14000573 	b	40ae1c <native_add_command_line_opts>

0000000000409854 <cmd_stop_at_found>:
{
  409854:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409858:	910003fd 	mov	x29, sp
  40985c:	f9000bf3 	str	x19, [sp, #16]
	if (args.stop_at < 0) {
  409860:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409864:	fd463260 	ldr	d0, [x19, #3168]
  409868:	1e602018 	fcmpe	d0, #0.0
  40986c:	54000144 	b.mi	409894 <cmd_stop_at_found+0x40>  // b.first
	hwm_set_end_of_time(args.stop_at*1e6);
  409870:	fd463260 	ldr	d0, [x19, #3168]
  409874:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409878:	f2e825c0 	movk	x0, #0x412e, lsl #48
  40987c:	9e670001 	fmov	d1, x0
}
  409880:	f9400bf3 	ldr	x19, [sp, #16]
	hwm_set_end_of_time(args.stop_at*1e6);
  409884:	1e610800 	fmul	d0, d0, d1
}
  409888:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_set_end_of_time(args.stop_at*1e6);
  40988c:	9e790000 	fcvtzu	x0, d0
  409890:	17ffffcf 	b	4097cc <hwm_set_end_of_time>
  409894:	aa0003e1 	mov	x1, x0
		posix_print_error_and_exit("Error: stop-at must be positive "
  409898:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  40989c:	913bf800 	add	x0, x0, #0xefe
  4098a0:	94000292 	bl	40a2e8 <posix_print_error_and_exit>
  4098a4:	17fffff3 	b	409870 <cmd_stop_at_found+0x1c>

00000000004098a8 <hwtimer_set_real_time_mode>:
	real_time_mode = new_rt;
  4098a8:	b0000121 	adrp	x1, 42e000 <des_frames+0x27>
  4098ac:	390b8420 	strb	w0, [x1, #737]
}
  4098b0:	d65f03c0 	ret

00000000004098b4 <cmd_no_realtime_found>:
	hwtimer_set_real_time_mode(false);
  4098b4:	52800000 	mov	w0, #0x0                   	// #0
  4098b8:	17fffffc 	b	4098a8 <hwtimer_set_real_time_mode>

00000000004098bc <cmd_realtime_found>:
	hwtimer_set_real_time_mode(true);
  4098bc:	52800020 	mov	w0, #0x1                   	// #1
  4098c0:	17fffffa 	b	4098a8 <hwtimer_set_real_time_mode>

00000000004098c4 <get_host_us_time>:
{
  4098c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4098c8:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4098cc:	910003fd 	mov	x29, sp
  4098d0:	f9476800 	ldr	x0, [x0, #3792]
  4098d4:	f9400001 	ldr	x1, [x0]
  4098d8:	f90017e1 	str	x1, [sp, #40]
  4098dc:	d2800001 	mov	x1, #0x0                   	// #0
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
  4098e0:	52800080 	mov	w0, #0x4                   	// #4
  4098e4:	910063e1 	add	x1, sp, #0x18
  4098e8:	97ffde4e 	bl	401220 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  4098ec:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  4098f0:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  4098f4:	f2e825c0 	movk	x0, #0x412e, lsl #48
  4098f8:	9e670001 	fmov	d1, x0
  4098fc:	fd400fe0 	ldr	d0, [sp, #24]
  409900:	f94013e0 	ldr	x0, [sp, #32]
  409904:	7e61d800 	ucvtf	d0, d0
  409908:	9ac10c00 	sdiv	x0, x0, x1
}
  40990c:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409910:	1e610800 	fmul	d0, d0, d1
}
  409914:	f9476821 	ldr	x1, [x1, #3792]
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  409918:	9e620001 	scvtf	d1, x0
}
  40991c:	f94017e3 	ldr	x3, [sp, #40]
  409920:	f9400022 	ldr	x2, [x1]
  409924:	eb020063 	subs	x3, x3, x2
  409928:	d2800002 	mov	x2, #0x0                   	// #0
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  40992c:	1e612800 	fadd	d0, d0, d1
}
  409930:	54000040 	b.eq	409938 <get_host_us_time+0x74>  // b.none
  409934:	97ffde7b 	bl	401320 <__stack_chk_fail@plt>
  409938:	9e790000 	fcvtzu	x0, d0
  40993c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409940:	d65f03c0 	ret

0000000000409944 <hwtimer_init>:
{
  409944:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409948:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40994c:	910003fd 	mov	x29, sp
  409950:	f9476800 	ldr	x0, [x0, #3792]
  409954:	f9400001 	ldr	x1, [x0]
  409958:	f90017e1 	str	x1, [sp, #40]
  40995c:	d2800001 	mov	x1, #0x0                   	// #0
	silent_ticks = 0;
  409960:	f0000100 	adrp	x0, 42c000 <__dso_handle>
	hw_timer_tick_timer = NEVER;
  409964:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	silent_ticks = 0;
  409968:	f906581f 	str	xzr, [x0, #3248]
	hw_timer_tick_timer = NEVER;
  40996c:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409970:	f947a800 	ldr	x0, [x0, #3920]
  409974:	f9000001 	str	x1, [x0]
	hw_timer_awake_timer = NEVER;
  409978:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40997c:	f9477c00 	ldr	x0, [x0, #3832]
  409980:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409984:	97ffffa5 	bl	409818 <hwtimer_update_timer>
	if (real_time_mode) {
  409988:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  40998c:	394b8400 	ldrb	w0, [x0, #737]
  409990:	340000c0 	cbz	w0, 4099a8 <hwtimer_init+0x64>
		boot_time = get_host_us_time();
  409994:	97ffffcc 	bl	4098c4 <get_host_us_time>
		last_radj_rtime = boot_time;
  409998:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  40999c:	f9064c20 	str	x0, [x1, #3224]
		last_radj_stime = 0U;
  4099a0:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  4099a4:	f906501f 	str	xzr, [x0, #3232]
	if (!reset_rtc) {
  4099a8:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  4099ac:	394b8800 	ldrb	w0, [x0, #738]
  4099b0:	35000260 	cbnz	w0, 4099fc <hwtimer_init+0xb8>
		clock_gettime(CLOCK_REALTIME, &tv);
  4099b4:	910063e1 	add	x1, sp, #0x18
  4099b8:	97ffde1a 	bl	401220 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  4099bc:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  4099c0:	d2807d02 	mov	x2, #0x3e8                 	// #1000
  4099c4:	f2e825c0 	movk	x0, #0x412e, lsl #48
  4099c8:	9e670001 	fmov	d1, x0
  4099cc:	fd400fe0 	ldr	d0, [sp, #24]
		rtc_offset += realhosttime;
  4099d0:	f0000101 	adrp	x1, 42c000 <__dso_handle>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  4099d4:	f94013e0 	ldr	x0, [sp, #32]
  4099d8:	7e61d800 	ucvtf	d0, d0
  4099dc:	9ac20c00 	sdiv	x0, x0, x2
		rtc_offset += realhosttime;
  4099e0:	f9465422 	ldr	x2, [x1, #3240]
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  4099e4:	1e610800 	fmul	d0, d0, d1
  4099e8:	9e620001 	scvtf	d1, x0
  4099ec:	1e612800 	fadd	d0, d0, d1
  4099f0:	9e790000 	fcvtzu	x0, d0
		rtc_offset += realhosttime;
  4099f4:	8b020000 	add	x0, x0, x2
  4099f8:	f9065420 	str	x0, [x1, #3240]
}
  4099fc:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409a00:	f9476800 	ldr	x0, [x0, #3792]
  409a04:	f94017e2 	ldr	x2, [sp, #40]
  409a08:	f9400001 	ldr	x1, [x0]
  409a0c:	eb010042 	subs	x2, x2, x1
  409a10:	d2800001 	mov	x1, #0x0                   	// #0
  409a14:	54000040 	b.eq	409a1c <hwtimer_init+0xd8>  // b.none
  409a18:	97ffde42 	bl	401320 <__stack_chk_fail@plt>
  409a1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409a20:	d65f03c0 	ret

0000000000409a24 <hwtimer_cleanup>:
}
  409a24:	d65f03c0 	ret

0000000000409a28 <hwtimer_enable>:
{
  409a28:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409a2c:	910003fd 	mov	x29, sp
  409a30:	f9000bf3 	str	x19, [sp, #16]
	tick_p = period;
  409a34:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409a38:	f9065e60 	str	x0, [x19, #3256]
	hw_timer_tick_timer = hwm_get_time() + tick_p;
  409a3c:	97ffff67 	bl	4097d8 <hwm_get_time>
  409a40:	f9465e61 	ldr	x1, [x19, #3256]
  409a44:	8b000020 	add	x0, x1, x0
  409a48:	d0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  409a4c:	f947a821 	ldr	x1, [x1, #3920]
  409a50:	f9000020 	str	x0, [x1]
	hwtimer_update_timer();
  409a54:	97ffff71 	bl	409818 <hwtimer_update_timer>
}
  409a58:	f9400bf3 	ldr	x19, [sp, #16]
  409a5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  409a60:	17ffff0e 	b	409698 <hwm_find_next_timer>

0000000000409a64 <hwtimer_timer_reached>:
{
  409a64:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  409a68:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409a6c:	910003fd 	mov	x29, sp
  409a70:	f9476800 	ldr	x0, [x0, #3792]
  409a74:	a90153f3 	stp	x19, x20, [sp, #16]
  409a78:	f90013f5 	str	x21, [sp, #32]
  409a7c:	f9400001 	ldr	x1, [x0]
  409a80:	f9002fe1 	str	x1, [sp, #88]
  409a84:	d2800001 	mov	x1, #0x0                   	// #0
	uint64_t Now = hw_timer_timer;
  409a88:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409a8c:	f9475800 	ldr	x0, [x0, #3760]
  409a90:	f9400013 	ldr	x19, [x0]
	if (hw_timer_awake_timer == Now) {
  409a94:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409a98:	f9477c00 	ldr	x0, [x0, #3832]
  409a9c:	f9400001 	ldr	x1, [x0]
  409aa0:	eb13003f 	cmp	x1, x19
  409aa4:	540000c1 	b.ne	409abc <hwtimer_timer_reached+0x58>  // b.any
	hw_timer_awake_timer = NEVER;
  409aa8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  409aac:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409ab0:	97ffff5a 	bl	409818 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
  409ab4:	529fffe0 	mov	w0, #0xffff                	// #65535
  409ab8:	9400018a 	bl	40a0e0 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
  409abc:	d0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  409ac0:	d0000114 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  409ac4:	aa0003f5 	mov	x21, x0
  409ac8:	f947a801 	ldr	x1, [x0, #3920]
  409acc:	f9400021 	ldr	x1, [x1]
  409ad0:	eb13003f 	cmp	x1, x19
  409ad4:	54000661 	b.ne	409ba0 <hwtimer_timer_reached+0x13c>  // b.any
	if (real_time_mode) {
  409ad8:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409adc:	394b8400 	ldrb	w0, [x0, #737]
  409ae0:	34000460 	cbz	w0, 409b6c <hwtimer_timer_reached+0x108>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  409ae4:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409ae8:	f9465000 	ldr	x0, [x0, #3232]
  409aec:	cb000273 	sub	x19, x19, x0
				    / clock_ratio
  409af0:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409af4:	9e630260 	ucvtf	d0, x19
  409af8:	fd401001 	ldr	d1, [x0, #32]
				    + last_radj_rtime;
  409afc:	f0000100 	adrp	x0, 42c000 <__dso_handle>
				    / clock_ratio
  409b00:	1e611800 	fdiv	d0, d0, d1
				    + last_radj_rtime;
  409b04:	fd464c01 	ldr	d1, [x0, #3224]
  409b08:	7e61d821 	ucvtf	d1, d1
  409b0c:	1e612800 	fadd	d0, d0, d1
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  409b10:	9e790013 	fcvtzu	x19, d0
		uint64_t real_time = get_host_us_time();
  409b14:	97ffff6c 	bl	4098c4 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
  409b18:	cb000260 	sub	x0, x19, x0
		if (diff > 0) { /* we need to slow down */
  409b1c:	f100001f 	cmp	x0, #0x0
  409b20:	5400026d 	b.le	409b6c <hwtimer_timer_reached+0x108>
			requested_time.tv_sec  = diff / 1e6;
  409b24:	9e620000 	scvtf	d0, x0
  409b28:	d0000040 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
			(void) nanosleep(&requested_time, &remaining);
  409b2c:	910123e1 	add	x1, sp, #0x48
			requested_time.tv_sec  = diff / 1e6;
  409b30:	fd42a002 	ldr	d2, [x0, #1344]
						 requested_time.tv_sec*1e6)*1e3;
  409b34:	d2c80000 	mov	x0, #0x400000000000        	// #70368744177664
  409b38:	f2e811e0 	movk	x0, #0x408f, lsl #48
			requested_time.tv_sec  = diff / 1e6;
  409b3c:	1e621801 	fdiv	d1, d0, d2
  409b40:	5ee1b821 	fcvtzs	d1, d1
  409b44:	fd001fe1 	str	d1, [sp, #56]
						 requested_time.tv_sec*1e6)*1e3;
  409b48:	5e61d821 	scvtf	d1, d1
  409b4c:	1e620821 	fmul	d1, d1, d2
			requested_time.tv_nsec = (diff -
  409b50:	1e613800 	fsub	d0, d0, d1
						 requested_time.tv_sec*1e6)*1e3;
  409b54:	9e670001 	fmov	d1, x0
			(void) nanosleep(&requested_time, &remaining);
  409b58:	9100e3e0 	add	x0, sp, #0x38
						 requested_time.tv_sec*1e6)*1e3;
  409b5c:	1e610800 	fmul	d0, d0, d1
			requested_time.tv_nsec = (diff -
  409b60:	5ee1b800 	fcvtzs	d0, d0
  409b64:	fd0023e0 	str	d0, [sp, #64]
			(void) nanosleep(&requested_time, &remaining);
  409b68:	97ffde26 	bl	401400 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
  409b6c:	f947aaa0 	ldr	x0, [x21, #3920]
  409b70:	f0000102 	adrp	x2, 42c000 <__dso_handle>
  409b74:	f9465c42 	ldr	x2, [x2, #3256]
  409b78:	f9400001 	ldr	x1, [x0]
  409b7c:	8b020021 	add	x1, x1, x2
  409b80:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  409b84:	97ffff25 	bl	409818 <hwtimer_update_timer>
	if (silent_ticks > 0) {
  409b88:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409b8c:	f9465820 	ldr	x0, [x1, #3248]
  409b90:	f100001f 	cmp	x0, #0x0
  409b94:	540001ad 	b.le	409bc8 <hwtimer_timer_reached+0x164>
		silent_ticks -= 1;
  409b98:	d1000400 	sub	x0, x0, #0x1
  409b9c:	f9065820 	str	x0, [x1, #3248]
}
  409ba0:	f9476a80 	ldr	x0, [x20, #3792]
  409ba4:	f9402fe2 	ldr	x2, [sp, #88]
  409ba8:	f9400001 	ldr	x1, [x0]
  409bac:	eb010042 	subs	x2, x2, x1
  409bb0:	d2800001 	mov	x1, #0x0                   	// #0
  409bb4:	54000161 	b.ne	409be0 <hwtimer_timer_reached+0x17c>  // b.any
  409bb8:	a94153f3 	ldp	x19, x20, [sp, #16]
  409bbc:	f94013f5 	ldr	x21, [sp, #32]
  409bc0:	a8c67bfd 	ldp	x29, x30, [sp], #96
  409bc4:	d65f03c0 	ret
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409bc8:	f9476a80 	ldr	x0, [x20, #3792]
  409bcc:	f9402fe2 	ldr	x2, [sp, #88]
  409bd0:	f9400001 	ldr	x1, [x0]
  409bd4:	eb010042 	subs	x2, x2, x1
  409bd8:	d2800001 	mov	x1, #0x0                   	// #0
  409bdc:	54000040 	b.eq	409be4 <hwtimer_timer_reached+0x180>  // b.none
}
  409be0:	97ffddd0 	bl	401320 <__stack_chk_fail@plt>
  409be4:	a94153f3 	ldp	x19, x20, [sp, #16]
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409be8:	52800000 	mov	w0, #0x0                   	// #0
}
  409bec:	f94013f5 	ldr	x21, [sp, #32]
  409bf0:	a8c67bfd 	ldp	x29, x30, [sp], #96
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  409bf4:	1400013b 	b	40a0e0 <hw_irq_ctrl_set_irq>

0000000000409bf8 <hwtimer_set_silent_ticks>:
	silent_ticks = sys_ticks;
  409bf8:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409bfc:	f9065820 	str	x0, [x1, #3248]
}
  409c00:	d65f03c0 	ret

0000000000409c04 <hwtimer_reset_rtc>:
	reset_rtc = true;
  409c04:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409c08:	52800021 	mov	w1, #0x1                   	// #1
  409c0c:	390b8801 	strb	w1, [x0, #738]
}
  409c10:	d65f03c0 	ret

0000000000409c14 <cmd_rtcreset_found>:
	hwtimer_reset_rtc();
  409c14:	17fffffc 	b	409c04 <hwtimer_reset_rtc>

0000000000409c18 <hwtimer_set_rtc_offset>:
	rtc_offset = offset;
  409c18:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409c1c:	f9065420 	str	x0, [x1, #3240]
}
  409c20:	d65f03c0 	ret

0000000000409c24 <cmd_rtcoffset_found>:
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
  409c24:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409c28:	fd463400 	ldr	d0, [x0, #3176]
  409c2c:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  409c30:	f2e825c0 	movk	x0, #0x412e, lsl #48
  409c34:	9e670001 	fmov	d1, x0
  409c38:	1e610800 	fmul	d0, d0, d1
  409c3c:	9e780000 	fcvtzs	x0, d0
  409c40:	17fffff6 	b	409c18 <hwtimer_set_rtc_offset>

0000000000409c44 <hwtimer_set_rt_ratio>:
	clock_ratio = ratio;
  409c44:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409c48:	fd001000 	str	d0, [x0, #32]
}
  409c4c:	d65f03c0 	ret

0000000000409c50 <cmd_rt_ratio_found>:
{
  409c50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409c54:	910003fd 	mov	x29, sp
  409c58:	f9000bf3 	str	x19, [sp, #16]
	if ((args.rt_ratio <= 0)) {
  409c5c:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409c60:	91318260 	add	x0, x19, #0xc60
  409c64:	fd400c00 	ldr	d0, [x0, #24]
  409c68:	1e602018 	fcmpe	d0, #0.0
  409c6c:	540000c9 	b.ls	409c84 <cmd_rt_ratio_found+0x34>  // b.plast
	hwtimer_set_rt_ratio(args.rt_ratio);
  409c70:	91318273 	add	x19, x19, #0xc60
  409c74:	fd400e60 	ldr	d0, [x19, #24]
}
  409c78:	f9400bf3 	ldr	x19, [sp, #16]
  409c7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  409c80:	17fffff1 	b	409c44 <hwtimer_set_rt_ratio>
		posix_print_error_and_exit("The ratio needs to be > 0. "
  409c84:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  409c88:	913c9000 	add	x0, x0, #0xf24
  409c8c:	94000197 	bl	40a2e8 <posix_print_error_and_exit>
  409c90:	17fffff8 	b	409c70 <cmd_rt_ratio_found+0x20>

0000000000409c94 <cmd_rt_drift_found>:
{
  409c94:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!(args.rt_drift > -1)) {
  409c98:	1e7e1000 	fmov	d0, #-1.000000000000000000e+00
{
  409c9c:	910003fd 	mov	x29, sp
  409ca0:	f9000bf3 	str	x19, [sp, #16]
	if (!(args.rt_drift > -1)) {
  409ca4:	f0000113 	adrp	x19, 42c000 <__dso_handle>
  409ca8:	91318260 	add	x0, x19, #0xc60
  409cac:	fd400801 	ldr	d1, [x0, #16]
  409cb0:	1e602030 	fcmpe	d1, d0
  409cb4:	5400008c 	b.gt	409cc4 <cmd_rt_drift_found+0x30>
		posix_print_error_and_exit("The drift needs to be > -1. "
  409cb8:	f0000040 	adrp	x0, 414000 <__func__.1+0xd>
  409cbc:	913d8000 	add	x0, x0, #0xf60
  409cc0:	9400018a 	bl	40a2e8 <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
  409cc4:	91318273 	add	x19, x19, #0xc60
  409cc8:	1e6e1001 	fmov	d1, #1.000000000000000000e+00
  409ccc:	fd400a60 	ldr	d0, [x19, #16]
  409cd0:	1e612800 	fadd	d0, d0, d1
  409cd4:	fd000e60 	str	d0, [x19, #24]
}
  409cd8:	f9400bf3 	ldr	x19, [sp, #16]
  409cdc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  409ce0:	17ffffd9 	b	409c44 <hwtimer_set_rt_ratio>

0000000000409ce4 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
  409ce4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  409ce8:	910003fd 	mov	x29, sp
  409cec:	a90153f3 	stp	x19, x20, [sp, #16]
  409cf0:	a9025bf5 	stp	x21, x22, [sp, #32]
  409cf4:	a90363f7 	stp	x23, x24, [sp, #48]
  409cf8:	f90023f9 	str	x25, [sp, #64]
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
  409cfc:	940000b5 	bl	409fd0 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
  409d00:	350009c0 	cbnz	w0, 409e38 <posix_irq_handler+0x154>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
  409d04:	d0000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  409d08:	aa1303f4 	mov	x20, x19
  409d0c:	f9472e60 	ldr	x0, [x19, #3672]
  409d10:	b9400000 	ldr	w0, [x0]
  409d14:	35000060 	cbnz	w0, 409d20 <posix_irq_handler+0x3c>
		may_swap = 0;
  409d18:	90000121 	adrp	x1, 42d000 <counter_value>
  409d1c:	b90f203f 	str	wzr, [x1, #3872]
	}

	_kernel.cpus[0].nested++;
  409d20:	f9472e81 	ldr	x1, [x20, #3672]

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
		int last_running_irq = currently_running_irq;
  409d24:	f0000115 	adrp	x21, 42c000 <__dso_handle>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  409d28:	f0000116 	adrp	x22, 42c000 <__dso_handle>
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
		hw_irq_ctrl_clear_irq(irq_nbr);

		currently_running_irq = irq_nbr;
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;
  409d2c:	910ff2b8 	add	x24, x21, #0x3fc
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  409d30:	913302d6 	add	x22, x22, #0xcc0
	_kernel.cpus[0].nested++;
  409d34:	11000400 	add	w0, w0, #0x1
  409d38:	b9000020 	str	w0, [x1]
	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
  409d3c:	940000bd 	bl	40a030 <hw_irq_ctrl_get_highest_prio_irq>
  409d40:	2a0003f3 	mov	w19, w0
  409d44:	3100041f 	cmn	w0, #0x1
  409d48:	540002c1 	b.ne	409da0 <posix_irq_handler+0xbc>  // b.any

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
	}

	_kernel.cpus[0].nested--;
  409d4c:	f9472e94 	ldr	x20, [x20, #3672]
  409d50:	b9400280 	ldr	w0, [x20]
  409d54:	51000400 	sub	w0, w0, #0x1
  409d58:	b9000280 	str	w0, [x20]
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
  409d5c:	90000120 	adrp	x0, 42d000 <counter_value>
  409d60:	b94f2000 	ldr	w0, [x0, #3872]
  409d64:	340006a0 	cbz	w0, 409e38 <posix_irq_handler+0x154>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
  409d68:	9400008f 	bl	409fa4 <hw_irq_ctrl_get_cur_prio>
  409d6c:	7104001f 	cmp	w0, #0x100
  409d70:	54000641 	b.ne	409e38 <posix_irq_handler+0x154>  // b.any
		&& (_kernel.ready_q.cache != _current)) {
  409d74:	f9400a80 	ldr	x0, [x20, #16]
  409d78:	f9401681 	ldr	x1, [x20, #40]
  409d7c:	eb00003f 	cmp	x1, x0
  409d80:	540005c0 	b.eq	409e38 <posix_irq_handler+0x154>  // b.none

		(void)z_swap_irqlock(irq_lock);
	}
}
  409d84:	a94153f3 	ldp	x19, x20, [sp, #16]

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
  409d88:	52800000 	mov	w0, #0x0                   	// #0
  409d8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409d90:	a94363f7 	ldp	x23, x24, [sp, #48]
  409d94:	f94023f9 	ldr	x25, [sp, #64]
  409d98:	a8c57bfd 	ldp	x29, x30, [sp], #80
  409d9c:	17fffd13 	b	4091e8 <arch_swap>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  409da0:	94000081 	bl	409fa4 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;
  409da4:	b943feb9 	ldr	w25, [x21, #1020]
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  409da8:	2a0003f7 	mov	w23, w0
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
  409dac:	2a1303e0 	mov	w0, w19
  409db0:	94000084 	bl	409fc0 <hw_irq_ctrl_get_prio>
  409db4:	12001c00 	and	w0, w0, #0xff
  409db8:	94000078 	bl	409f98 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
  409dbc:	2a1303e0 	mov	w0, w19
  409dc0:	940000bd 	bl	40a0b4 <hw_irq_ctrl_clear_irq>
		currently_running_irq = irq_nbr;
  409dc4:	b903feb3 	str	w19, [x21, #1020]
	sys_trace_isr_enter();
  409dc8:	97fffb9c 	bl	408c38 <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  409dcc:	93407e61 	sxtw	x1, w19
  409dd0:	d2800300 	mov	x0, #0x18                  	// #24
  409dd4:	9b005821 	madd	x1, x1, x0, x22
  409dd8:	f9400422 	ldr	x2, [x1, #8]
  409ddc:	b5000142 	cbnz	x2, 409e04 <posix_irq_handler+0x120>
		posix_print_error_and_exit("Received irq %i without a "
  409de0:	90000060 	adrp	x0, 415000 <random_data+0xd8c>
  409de4:	2a1303e1 	mov	w1, w19
  409de8:	910dd800 	add	x0, x0, #0x376
  409dec:	9400013f 	bl	40a2e8 <posix_print_error_and_exit>
	sys_trace_isr_exit();
  409df0:	97fffb93 	bl	408c3c <sys_trace_isr_exit>
		currently_running_irq = last_running_irq;
  409df4:	b9000319 	str	w25, [x24]
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
  409df8:	2a1703e0 	mov	w0, w23
  409dfc:	94000067 	bl	409f98 <hw_irq_ctrl_set_cur_prio>
  409e00:	17ffffcf 	b	409d3c <posix_irq_handler+0x58>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
  409e04:	b9400420 	ldr	w0, [x1, #4]
  409e08:	90000133 	adrp	x19, 42d000 <counter_value>
  409e0c:	360000c0 	tbz	w0, #0, 409e24 <posix_irq_handler+0x140>
			*may_swap |= ((direct_irq_f_ptr)
  409e10:	d63f0040 	blr	x2
  409e14:	b94f2261 	ldr	w1, [x19, #3872]
  409e18:	2a000021 	orr	w1, w1, w0
  409e1c:	b90f2261 	str	w1, [x19, #3872]
  409e20:	17fffff4 	b	409df0 <posix_irq_handler+0x10c>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
  409e24:	f9400820 	ldr	x0, [x1, #16]
  409e28:	d63f0040 	blr	x2
			*may_swap = 1;
  409e2c:	52800020 	mov	w0, #0x1                   	// #1
  409e30:	b90f2260 	str	w0, [x19, #3872]
  409e34:	17ffffef 	b	409df0 <posix_irq_handler+0x10c>
}
  409e38:	a94153f3 	ldp	x19, x20, [sp, #16]
  409e3c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409e40:	a94363f7 	ldp	x23, x24, [sp, #48]
  409e44:	f94023f9 	ldr	x25, [sp, #64]
  409e48:	a8c57bfd 	ldp	x29, x30, [sp], #80
  409e4c:	d65f03c0 	ret

0000000000409e50 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
  409e50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409e54:	910003fd 	mov	x29, sp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
  409e58:	94000076 	bl	40a030 <hw_irq_ctrl_get_highest_prio_irq>
  409e5c:	3100041f 	cmn	w0, #0x1
  409e60:	54000140 	b.eq	409e88 <posix_irq_handler_im_from_sw+0x38>  // b.none
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
  409e64:	97fffd1f 	bl	4092e0 <posix_is_cpu_running>
  409e68:	350000c0 	cbnz	w0, 409e80 <posix_irq_handler_im_from_sw+0x30>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
  409e6c:	90000061 	adrp	x1, 415000 <random_data+0xd8c>
  409e70:	90000060 	adrp	x0, 415000 <random_data+0xd8c>
  409e74:	910f6421 	add	x1, x1, #0x3d9
  409e78:	910e9000 	add	x0, x0, #0x3a4
  409e7c:	9400011b 	bl	40a2e8 <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
  409e80:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler();
  409e84:	17ffff98 	b	409ce4 <posix_irq_handler>
}
  409e88:	a8c17bfd 	ldp	x29, x30, [sp], #16
  409e8c:	d65f03c0 	ret

0000000000409e90 <posix_irq_lock>:
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
	return hw_irq_ctrl_change_lock(true);
  409e90:	52800020 	mov	w0, #0x1                   	// #1
  409e94:	14000052 	b	409fdc <hw_irq_ctrl_change_lock>

0000000000409e98 <posix_irq_unlock>:
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
  409e98:	14000051 	b	409fdc <hw_irq_ctrl_change_lock>

0000000000409e9c <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
	hw_irq_ctrl_change_lock(false);
  409e9c:	52800000 	mov	w0, #0x0                   	// #0
  409ea0:	1400004f 	b	409fdc <hw_irq_ctrl_change_lock>

0000000000409ea4 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
  409ea4:	140000aa 	b	40a14c <hw_irq_ctrl_enable_irq>

0000000000409ea8 <posix_isr_declare>:
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
	irq_vector_table[irq_p].irq   = irq_p;
  409ea8:	2a0003e4 	mov	w4, w0
  409eac:	d2800306 	mov	x6, #0x18                  	// #24
  409eb0:	f0000105 	adrp	x5, 42c000 <__dso_handle>
  409eb4:	913300a5 	add	x5, x5, #0xcc0
  409eb8:	9b067c84 	mul	x4, x4, x6
  409ebc:	8b0400a6 	add	x6, x5, x4
  409ec0:	b82468a0 	str	w0, [x5, x4]
	irq_vector_table[irq_p].func  = isr_p;
	irq_vector_table[irq_p].param = isr_param_p;
	irq_vector_table[irq_p].flags = flags;
  409ec4:	b90004c1 	str	w1, [x6, #4]
	irq_vector_table[irq_p].param = isr_param_p;
  409ec8:	a9008cc2 	stp	x2, x3, [x6, #8]
}
  409ecc:	d65f03c0 	ret

0000000000409ed0 <posix_irq_priority_set>:
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
  409ed0:	14000038 	b	409fb0 <hw_irq_ctrl_prio_set>

0000000000409ed4 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
  409ed4:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409ed8:	394c0c01 	ldrb	w1, [x0, #771]
  409edc:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409ee0:	34000061 	cbz	w1, 409eec <irq_raising_from_hw_now+0x18>
  409ee4:	394c1001 	ldrb	w1, [x0, #772]
  409ee8:	34000061 	cbz	w1, 409ef4 <irq_raising_from_hw_now+0x20>
		lock_ignore = false;
  409eec:	390c101f 	strb	wzr, [x0, #772]
		posix_interrupt_raised();
  409ef0:	17fffd27 	b	40938c <posix_interrupt_raised>
	}
}
  409ef4:	d65f03c0 	ret

0000000000409ef8 <hw_irq_ctrl_irq_raise_prefix>:
	if (irq < N_IRQS) {
  409ef8:	71007c1f 	cmp	w0, #0x1f
  409efc:	54000248 	b.hi	409f44 <hw_irq_ctrl_irq_raise_prefix+0x4c>  // b.pmore
		irq_premask |= ((uint64_t)1<<irq);
  409f00:	d2800021 	mov	x1, #0x1                   	// #1
  409f04:	f0000104 	adrp	x4, 42c000 <__dso_handle>
  409f08:	9ac02023 	lsl	x3, x1, x0
		if (irq_mask & (1 << irq)) {
  409f0c:	1ac02021 	lsl	w1, w1, w0
  409f10:	f0000100 	adrp	x0, 42c000 <__dso_handle>
		irq_premask |= ((uint64_t)1<<irq);
  409f14:	f947e482 	ldr	x2, [x4, #4040]
		if (irq_mask & (1 << irq)) {
  409f18:	93407c21 	sxtw	x1, w1
  409f1c:	f947e000 	ldr	x0, [x0, #4032]
		irq_premask |= ((uint64_t)1<<irq);
  409f20:	aa030042 	orr	x2, x2, x3
  409f24:	f907e482 	str	x2, [x4, #4040]
		if (irq_mask & (1 << irq)) {
  409f28:	ea00003f 	tst	x1, x0
  409f2c:	540000a0 	b.eq	409f40 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.none
			irq_status |= ((uint64_t)1<<irq);
  409f30:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409f34:	f947e820 	ldr	x0, [x1, #4048]
  409f38:	aa030000 	orr	x0, x0, x3
  409f3c:	f907e820 	str	x0, [x1, #4048]
}
  409f40:	d65f03c0 	ret
	} else if (irq == PHONY_HARD_IRQ) {
  409f44:	529fffe1 	mov	w1, #0xffff                	// #65535
  409f48:	6b01001f 	cmp	w0, w1
  409f4c:	54ffffa1 	b.ne	409f40 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.any
		lock_ignore = true;
  409f50:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409f54:	52800021 	mov	w1, #0x1                   	// #1
  409f58:	390c1001 	strb	w1, [x0, #772]
}
  409f5c:	17fffff9 	b	409f40 <hw_irq_ctrl_irq_raise_prefix+0x48>

0000000000409f60 <hw_irq_ctrl_init>:
		irq_prio[i] = 255U;
  409f60:	6f000400 	mvni	v0.4s, #0x0
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
  409f64:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409f68:	f907e01f 	str	xzr, [x0, #4032]
	irq_premask = 0U;
  409f6c:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409f70:	f907e41f 	str	xzr, [x0, #4040]
	irqs_locked = false;
  409f74:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409f78:	390c0c1f 	strb	wzr, [x0, #771]
	lock_ignore = false;
  409f7c:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409f80:	390c101f 	strb	wzr, [x0, #772]
		irq_prio[i] = 255U;
  409f84:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409f88:	910b8c00 	add	x0, x0, #0x2e3
  409f8c:	ad000000 	stp	q0, q0, [x0]
}
  409f90:	d65f03c0 	ret

0000000000409f94 <hw_irq_ctrl_cleanup>:
}
  409f94:	d65f03c0 	ret

0000000000409f98 <hw_irq_ctrl_set_cur_prio>:
	currently_running_prio = new;
  409f98:	f0000101 	adrp	x1, 42c000 <__dso_handle>
  409f9c:	b9040020 	str	w0, [x1, #1024]
}
  409fa0:	d65f03c0 	ret

0000000000409fa4 <hw_irq_ctrl_get_cur_prio>:
}
  409fa4:	f0000100 	adrp	x0, 42c000 <__dso_handle>
  409fa8:	b9440000 	ldr	w0, [x0, #1024]
  409fac:	d65f03c0 	ret

0000000000409fb0 <hw_irq_ctrl_prio_set>:
	irq_prio[irq] = prio;
  409fb0:	b0000122 	adrp	x2, 42e000 <des_frames+0x27>
  409fb4:	910b8c42 	add	x2, x2, #0x2e3
  409fb8:	38204841 	strb	w1, [x2, w0, uxtw]
}
  409fbc:	d65f03c0 	ret

0000000000409fc0 <hw_irq_ctrl_get_prio>:
}
  409fc0:	b0000121 	adrp	x1, 42e000 <des_frames+0x27>
  409fc4:	910b8c21 	add	x1, x1, #0x2e3
  409fc8:	38604820 	ldrb	w0, [x1, w0, uxtw]
  409fcc:	d65f03c0 	ret

0000000000409fd0 <hw_irq_ctrl_get_current_lock>:
}
  409fd0:	b0000120 	adrp	x0, 42e000 <des_frames+0x27>
  409fd4:	394c0c00 	ldrb	w0, [x0, #771]
  409fd8:	d65f03c0 	ret

0000000000409fdc <hw_irq_ctrl_change_lock>:
{
  409fdc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t previous_lock = irqs_locked;
  409fe0:	b0000121 	adrp	x1, 42e000 <des_frames+0x27>
	irqs_locked = new_lock;
  409fe4:	7100001f 	cmp	w0, #0x0
{
  409fe8:	910003fd 	mov	x29, sp
	irqs_locked = new_lock;
  409fec:	1a9f07e0 	cset	w0, ne  // ne = any
{
  409ff0:	f9000bf3 	str	x19, [sp, #16]
	uint32_t previous_lock = irqs_locked;
  409ff4:	394c0c33 	ldrb	w19, [x1, #771]
	irqs_locked = new_lock;
  409ff8:	390c0c20 	strb	w0, [x1, #771]
	if ((previous_lock == true) && (new_lock == false)) {
  409ffc:	7a400a64 	ccmp	w19, #0x0, #0x4, eq  // eq = none
  40a000:	540000a0 	b.eq	40a014 <hw_irq_ctrl_change_lock+0x38>  // b.none
		if (irq_status != 0U) {
  40a004:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a008:	f947e800 	ldr	x0, [x0, #4048]
  40a00c:	b4000040 	cbz	x0, 40a014 <hw_irq_ctrl_change_lock+0x38>
			posix_irq_handler_im_from_sw();
  40a010:	97ffff90 	bl	409e50 <posix_irq_handler_im_from_sw>
}
  40a014:	2a1303e0 	mov	w0, w19
  40a018:	f9400bf3 	ldr	x19, [sp, #16]
  40a01c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a020:	d65f03c0 	ret

000000000040a024 <hw_irq_ctrl_get_irq_status>:
}
  40a024:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a028:	f947e800 	ldr	x0, [x0, #4048]
  40a02c:	d65f03c0 	ret

000000000040a030 <hw_irq_ctrl_get_highest_prio_irq>:
	if (irqs_locked) {
  40a030:	90000120 	adrp	x0, 42e000 <des_frames+0x27>
  40a034:	394c0c00 	ldrb	w0, [x0, #771]
  40a038:	350003a0 	cbnz	w0, 40a0ac <hw_irq_ctrl_get_highest_prio_irq+0x7c>
{
  40a03c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a040:	910003fd 	mov	x29, sp
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
  40a044:	97fffff8 	bl	40a024 <hw_irq_ctrl_get_irq_status>
  40a048:	aa0003e2 	mov	x2, x0
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a04c:	d0000100 	adrp	x0, 42c000 <__dso_handle>
		if ((winner_prio > (int)irq_prio[irq_nbr])
  40a050:	90000124 	adrp	x4, 42e000 <des_frames+0x27>
  40a054:	910b8c84 	add	x4, x4, #0x2e3
	int winner_prio = 256;
  40a058:	52802003 	mov	w3, #0x100                 	// #256
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a05c:	b9440006 	ldr	w6, [x0, #1024]
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  40a060:	d2800027 	mov	x7, #0x1                   	// #1
	int winner = -1;
  40a064:	12800000 	mov	w0, #0xffffffff            	// #-1
	while (irq_status != 0U) {
  40a068:	b5000062 	cbnz	x2, 40a074 <hw_irq_ctrl_get_highest_prio_irq+0x44>
}
  40a06c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a070:	d65f03c0 	ret
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
  40a074:	5ac00041 	rbit	w1, w2
  40a078:	7100005f 	cmp	w2, #0x0
  40a07c:	5ac01021 	clz	w1, w1
  40a080:	1a8107e1 	csinc	w1, wzr, w1, eq  // eq = none
		int irq_nbr = find_lsb_set(irq_status) - 1;
  40a084:	51000421 	sub	w1, w1, #0x1
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  40a088:	9ac120e5 	lsl	x5, x7, x1
  40a08c:	8a250042 	bic	x2, x2, x5
		if ((winner_prio > (int)irq_prio[irq_nbr])
  40a090:	3861c885 	ldrb	w5, [x4, w1, sxtw]
  40a094:	6b0300bf 	cmp	w5, w3
  40a098:	54fffe8a 	b.ge	40a068 <hw_irq_ctrl_get_highest_prio_irq+0x38>  // b.tcont
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40a09c:	6b0600bf 	cmp	w5, w6
  40a0a0:	1a85a063 	csel	w3, w3, w5, ge  // ge = tcont
  40a0a4:	1a81a000 	csel	w0, w0, w1, ge  // ge = tcont
  40a0a8:	17fffff0 	b	40a068 <hw_irq_ctrl_get_highest_prio_irq+0x38>
		return -1;
  40a0ac:	12800000 	mov	w0, #0xffffffff            	// #-1
}
  40a0b0:	d65f03c0 	ret

000000000040a0b4 <hw_irq_ctrl_clear_irq>:
	irq_status  &= ~((uint64_t)1<<irq);
  40a0b4:	d0000102 	adrp	x2, 42c000 <__dso_handle>
  40a0b8:	d2800021 	mov	x1, #0x1                   	// #1
  40a0bc:	9ac02020 	lsl	x0, x1, x0
  40a0c0:	f947e841 	ldr	x1, [x2, #4048]
  40a0c4:	8a200021 	bic	x1, x1, x0
  40a0c8:	f907e841 	str	x1, [x2, #4048]
	irq_premask &= ~((uint64_t)1<<irq);
  40a0cc:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a0d0:	f947e422 	ldr	x2, [x1, #4040]
  40a0d4:	8a200040 	bic	x0, x2, x0
  40a0d8:	f907e420 	str	x0, [x1, #4040]
}
  40a0dc:	d65f03c0 	ret

000000000040a0e0 <hw_irq_ctrl_set_irq>:
{
  40a0e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a0e4:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  40a0e8:	97ffff84 	bl	409ef8 <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
  40a0ec:	90000120 	adrp	x0, 42e000 <des_frames+0x27>
  40a0f0:	394c0c00 	ldrb	w0, [x0, #771]
  40a0f4:	34000080 	cbz	w0, 40a104 <hw_irq_ctrl_set_irq+0x24>
  40a0f8:	90000120 	adrp	x0, 42e000 <des_frames+0x27>
  40a0fc:	394c1000 	ldrb	w0, [x0, #772]
  40a100:	340000e0 	cbz	w0, 40a11c <hw_irq_ctrl_set_irq+0x3c>
		irq_ctrl_timer = hwm_get_time();
  40a104:	97fffdb5 	bl	4097d8 <hwm_get_time>
  40a108:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40a10c:	f9478c21 	ldr	x1, [x1, #3864]
  40a110:	f9000020 	str	x0, [x1]
}
  40a114:	a8c17bfd 	ldp	x29, x30, [sp], #16
		hwm_find_next_timer();
  40a118:	17fffd60 	b	409698 <hwm_find_next_timer>
}
  40a11c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a120:	d65f03c0 	ret

000000000040a124 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
  40a124:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a128:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  40a12c:	97ffff73 	bl	409ef8 <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
  40a130:	90000120 	adrp	x0, 42e000 <des_frames+0x27>
  40a134:	394c0c00 	ldrb	w0, [x0, #771]
  40a138:	35000060 	cbnz	w0, 40a144 <hw_irq_ctrl_raise_im_from_sw+0x20>
		posix_irq_handler_im_from_sw();
	}
}
  40a13c:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler_im_from_sw();
  40a140:	17ffff44 	b	409e50 <posix_irq_handler_im_from_sw>
}
  40a144:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a148:	d65f03c0 	ret

000000000040a14c <hw_irq_ctrl_enable_irq>:
	irq_mask |= ((uint64_t)1<<irq);
  40a14c:	d0000103 	adrp	x3, 42c000 <__dso_handle>
  40a150:	d2800021 	mov	x1, #0x1                   	// #1
  40a154:	9ac02021 	lsl	x1, x1, x0
  40a158:	f947e064 	ldr	x4, [x3, #4032]
  40a15c:	aa040021 	orr	x1, x1, x4
  40a160:	f907e061 	str	x1, [x3, #4032]
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
  40a164:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40a168:	f947e421 	ldr	x1, [x1, #4040]
  40a16c:	9ac02421 	lsr	x1, x1, x0
  40a170:	36000041 	tbz	w1, #0, 40a178 <hw_irq_ctrl_enable_irq+0x2c>
		hw_irq_ctrl_raise_im_from_sw(irq);
  40a174:	17ffffec 	b	40a124 <hw_irq_ctrl_raise_im_from_sw>
}
  40a178:	d65f03c0 	ret

000000000040a17c <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
  40a17c:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40a180:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40a184:	f9478c00 	ldr	x0, [x0, #3864]
  40a188:	f9000001 	str	x1, [x0]
	irq_raising_from_hw_now();
  40a18c:	17ffff52 	b	409ed4 <irq_raising_from_hw_now>

000000000040a190 <posix_exit>:
#include <zephyr/sys/time_units.h>
#include "cmdline.h"
#include "irq_ctrl.h"

void posix_exit(int exit_code)
{
  40a190:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a194:	910003fd 	mov	x29, sp
  40a198:	f9000bf3 	str	x19, [sp, #16]
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
  40a19c:	f0000113 	adrp	x19, 42d000 <counter_value>
  40a1a0:	b94f2661 	ldr	w1, [x19, #3876]
  40a1a4:	6b00003f 	cmp	w1, w0
  40a1a8:	1a80a021 	csel	w1, w1, w0, ge  // ge = tcont
  40a1ac:	b90f2661 	str	w1, [x19, #3876]
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
  40a1b0:	97fffcd5 	bl	409504 <posix_soc_clean_up>
	hwm_cleanup();
  40a1b4:	97fffd94 	bl	409804 <hwm_cleanup>
	native_cleanup_cmd_line();
  40a1b8:	9400030e 	bl	40adf0 <native_cleanup_cmd_line>
	exit(max_exit_code);
  40a1bc:	b94f2660 	ldr	w0, [x19, #3876]
  40a1c0:	97ffdbfc 	bl	4011b0 <exit@plt>

000000000040a1c4 <posix_init>:
 * Run all early native_posix initialization steps, including command
 * line parsing and CPU start, until we are ready to let the HW models
 * run via hwm_one_event()
 */
void posix_init(int argc, char *argv[])
{
  40a1c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	 * Let's ensure that even if we are redirecting to a file, we get stdout
	 * and stderr line buffered (default for console)
	 * Note that glibc ignores size. But just in case we set a reasonable
	 * number in case somebody tries to compile against a different library
	 */
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a1c8:	d2804003 	mov	x3, #0x200                 	// #512
  40a1cc:	52800022 	mov	w2, #0x1                   	// #1
{
  40a1d0:	910003fd 	mov	x29, sp
  40a1d4:	a90153f3 	stp	x19, x20, [sp, #16]
  40a1d8:	2a0003f3 	mov	w19, w0
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a1dc:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
{
  40a1e0:	aa0103f4 	mov	x20, x1
	setvbuf(stdout, NULL, _IOLBF, 512);
  40a1e4:	d2800001 	mov	x1, #0x0                   	// #0
  40a1e8:	f9474000 	ldr	x0, [x0, #3712]
  40a1ec:	f9400000 	ldr	x0, [x0]
  40a1f0:	97ffdc10 	bl	401230 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
  40a1f4:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40a1f8:	d2804003 	mov	x3, #0x200                 	// #512
  40a1fc:	52800022 	mov	w2, #0x1                   	// #1
  40a200:	d2800001 	mov	x1, #0x0                   	// #0
  40a204:	f9471800 	ldr	x0, [x0, #3632]
  40a208:	f9400000 	ldr	x0, [x0]
  40a20c:	97ffdc09 	bl	401230 <setvbuf@plt>

	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
  40a210:	52800000 	mov	w0, #0x0                   	// #0
  40a214:	97fffcaa 	bl	4094bc <run_native_tasks>

	native_handle_cmd_line(argc, argv);
  40a218:	aa1403e1 	mov	x1, x20
  40a21c:	2a1303e0 	mov	w0, w19
  40a220:	94000335 	bl	40aef4 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
  40a224:	52800020 	mov	w0, #0x1                   	// #1
  40a228:	97fffca5 	bl	4094bc <run_native_tasks>

	hwm_init();
  40a22c:	97fffd6e 	bl	4097e4 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
  40a230:	52800040 	mov	w0, #0x2                   	// #2
  40a234:	97fffca2 	bl	4094bc <run_native_tasks>

	posix_boot_cpu();
  40a238:	97fffc67 	bl	4093d4 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
}
  40a23c:	a94153f3 	ldp	x19, x20, [sp, #16]
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  40a240:	52800060 	mov	w0, #0x3                   	// #3
}
  40a244:	a8c27bfd 	ldp	x29, x30, [sp], #32
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  40a248:	17fffc9d 	b	4094bc <run_native_tasks>

000000000040a24c <main>:
 *
 * Not used when building fuzz cases, as libfuzzer has its own main()
 * and calls the "OS" through a per-case fuzz test entry point.
 */
int main(int argc, char *argv[])
{
  40a24c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a250:	910003fd 	mov	x29, sp
	posix_init(argc, argv);
  40a254:	97ffffdc 	bl	40a1c4 <posix_init>
	while (true) {
		hwm_one_event();
  40a258:	97fffd29 	bl	4096fc <hwm_one_event>
	while (true) {
  40a25c:	17ffffff 	b	40a258 <main+0xc>

000000000040a260 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
  40a260:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a264:	91101000 	add	x0, x0, #0x404
  40a268:	f900001f 	str	xzr, [x0]
	is_a_tty[1] = 0;
}
  40a26c:	d65f03c0 	ret

000000000040a270 <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
  40a270:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a274:	91101000 	add	x0, x0, #0x404
  40a278:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40a27c:	f9000001 	str	x1, [x0]
	is_a_tty[1] = -1;

}
  40a280:	d65f03c0 	ret

000000000040a284 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
  40a284:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a288:	91101000 	add	x0, x0, #0x404
  40a28c:	b20003e1 	mov	x1, #0x100000001           	// #4294967297
  40a290:	f9000001 	str	x1, [x0]
	is_a_tty[1] = 1;
}
  40a294:	d65f03c0 	ret

000000000040a298 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
  40a298:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a29c:	910003fd 	mov	x29, sp
  40a2a0:	f9000bf3 	str	x19, [sp, #16]
	if (is_a_tty[0] == -1) {
  40a2a4:	d0000113 	adrp	x19, 42c000 <__dso_handle>
  40a2a8:	b9440660 	ldr	w0, [x19, #1028]
  40a2ac:	3100041f 	cmn	w0, #0x1
  40a2b0:	54000081 	b.ne	40a2c0 <decide_about_color+0x28>  // b.any
		is_a_tty[0] = isatty(STDOUT_FILENO);
  40a2b4:	52800020 	mov	w0, #0x1                   	// #1
  40a2b8:	97ffdc62 	bl	401440 <isatty@plt>
  40a2bc:	b9040660 	str	w0, [x19, #1028]
	}
	if (is_a_tty[1] == -1) {
  40a2c0:	91101273 	add	x19, x19, #0x404
  40a2c4:	b9400660 	ldr	w0, [x19, #4]
  40a2c8:	3100041f 	cmn	w0, #0x1
  40a2cc:	54000081 	b.ne	40a2dc <decide_about_color+0x44>  // b.any
		is_a_tty[1] = isatty(STDERR_FILENO);
  40a2d0:	52800040 	mov	w0, #0x2                   	// #2
  40a2d4:	97ffdc5b 	bl	401440 <isatty@plt>
  40a2d8:	b9000660 	str	w0, [x19, #4]
	}
}
  40a2dc:	f9400bf3 	ldr	x19, [sp, #16]
  40a2e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a2e4:	d65f03c0 	ret

000000000040a2e8 <posix_print_error_and_exit>:
{
  40a2e8:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a2ec:	aa0003e8 	mov	x8, x0
  40a2f0:	910003fd 	mov	x29, sp
  40a2f4:	a9108be1 	stp	x1, x2, [sp, #264]
  40a2f8:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
  40a2fc:	aa0803e2 	mov	x2, x8
  40a300:	f9476821 	ldr	x1, [x1, #3792]
  40a304:	3d8023e0 	str	q0, [sp, #128]
  40a308:	3d8027e1 	str	q1, [sp, #144]
  40a30c:	3d802be2 	str	q2, [sp, #160]
  40a310:	3d802fe3 	str	q3, [sp, #176]
  40a314:	3d8033e4 	str	q4, [sp, #192]
  40a318:	3d8037e5 	str	q5, [sp, #208]
  40a31c:	3d803be6 	str	q6, [sp, #224]
  40a320:	3d803fe7 	str	q7, [sp, #240]
  40a324:	a91193e3 	stp	x3, x4, [sp, #280]
  40a328:	910043e3 	add	x3, sp, #0x10
  40a32c:	a9129be5 	stp	x5, x6, [sp, #296]
  40a330:	f9009fe7 	str	x7, [sp, #312]
  40a334:	f9400020 	ldr	x0, [x1]
  40a338:	f9003fe0 	str	x0, [sp, #120]
  40a33c:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  40a340:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
	va_start(variable_args, format);
  40a344:	910503e0 	add	x0, sp, #0x140
  40a348:	a90383e0 	stp	x0, x0, [sp, #56]
  40a34c:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  40a350:	f9471821 	ldr	x1, [x1, #3632]
	va_start(variable_args, format);
  40a354:	f90027e0 	str	x0, [sp, #72]
  40a358:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a35c:	b90053e0 	str	w0, [sp, #80]
  40a360:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a364:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  40a368:	f9400020 	ldr	x0, [x1]
  40a36c:	9100e3e1 	add	x1, sp, #0x38
  40a370:	ad400420 	ldp	q0, q1, [x1]
  40a374:	910163e1 	add	x1, sp, #0x58
  40a378:	ad000420 	stp	q0, q1, [x1]
  40a37c:	52800021 	mov	w1, #0x1                   	// #1
  40a380:	ad000460 	stp	q0, q1, [x3]
  40a384:	97ffdbcf 	bl	4012c0 <__vfprintf_chk@plt>
	posix_exit(1);
  40a388:	52800020 	mov	w0, #0x1                   	// #1
  40a38c:	97ffff81 	bl	40a190 <posix_exit>
}
  40a390:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40a394:	f9476800 	ldr	x0, [x0, #3792]
  40a398:	f9403fe2 	ldr	x2, [sp, #120]
  40a39c:	f9400001 	ldr	x1, [x0]
  40a3a0:	eb010042 	subs	x2, x2, x1
  40a3a4:	d2800001 	mov	x1, #0x0                   	// #0
  40a3a8:	54000040 	b.eq	40a3b0 <posix_print_error_and_exit+0xc8>  // b.none
  40a3ac:	97ffdbdd 	bl	401320 <__stack_chk_fail@plt>
  40a3b0:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a3b4:	d65f03c0 	ret

000000000040a3b8 <posix_print_warning>:
{
  40a3b8:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a3bc:	aa0003e8 	mov	x8, x0
  40a3c0:	910003fd 	mov	x29, sp
  40a3c4:	a9108be1 	stp	x1, x2, [sp, #264]
  40a3c8:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40a3cc:	aa0803e2 	mov	x2, x8
  40a3d0:	f9476821 	ldr	x1, [x1, #3792]
  40a3d4:	3d8023e0 	str	q0, [sp, #128]
  40a3d8:	3d8027e1 	str	q1, [sp, #144]
  40a3dc:	3d802be2 	str	q2, [sp, #160]
  40a3e0:	3d802fe3 	str	q3, [sp, #176]
  40a3e4:	3d8033e4 	str	q4, [sp, #192]
  40a3e8:	3d8037e5 	str	q5, [sp, #208]
  40a3ec:	3d803be6 	str	q6, [sp, #224]
  40a3f0:	3d803fe7 	str	q7, [sp, #240]
  40a3f4:	a91193e3 	stp	x3, x4, [sp, #280]
  40a3f8:	910043e3 	add	x3, sp, #0x10
  40a3fc:	a9129be5 	stp	x5, x6, [sp, #296]
  40a400:	f9009fe7 	str	x7, [sp, #312]
  40a404:	f9400020 	ldr	x0, [x1]
  40a408:	f9003fe0 	str	x0, [sp, #120]
  40a40c:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  40a410:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
	va_start(variable_args, format);
  40a414:	910503e0 	add	x0, sp, #0x140
  40a418:	a90383e0 	stp	x0, x0, [sp, #56]
  40a41c:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  40a420:	f9471821 	ldr	x1, [x1, #3632]
	va_start(variable_args, format);
  40a424:	f90027e0 	str	x0, [sp, #72]
  40a428:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a42c:	b90053e0 	str	w0, [sp, #80]
  40a430:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a434:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  40a438:	f9400020 	ldr	x0, [x1]
  40a43c:	9100e3e1 	add	x1, sp, #0x38
  40a440:	ad400420 	ldp	q0, q1, [x1]
  40a444:	910163e1 	add	x1, sp, #0x58
  40a448:	ad000420 	stp	q0, q1, [x1]
  40a44c:	52800021 	mov	w1, #0x1                   	// #1
  40a450:	ad000460 	stp	q0, q1, [x3]
  40a454:	97ffdb9b 	bl	4012c0 <__vfprintf_chk@plt>
}
  40a458:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40a45c:	f9476800 	ldr	x0, [x0, #3792]
  40a460:	f9403fe2 	ldr	x2, [sp, #120]
  40a464:	f9400001 	ldr	x1, [x0]
  40a468:	eb010042 	subs	x2, x2, x1
  40a46c:	d2800001 	mov	x1, #0x0                   	// #0
  40a470:	54000040 	b.eq	40a478 <posix_print_warning+0xc0>  // b.none
  40a474:	97ffdbab 	bl	401320 <__stack_chk_fail@plt>
  40a478:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a47c:	d65f03c0 	ret

000000000040a480 <posix_print_trace>:
{
  40a480:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40a484:	aa0003e8 	mov	x8, x0
  40a488:	910003fd 	mov	x29, sp
  40a48c:	a9108be1 	stp	x1, x2, [sp, #264]
  40a490:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40a494:	aa0803e2 	mov	x2, x8
  40a498:	f9476821 	ldr	x1, [x1, #3792]
  40a49c:	3d8023e0 	str	q0, [sp, #128]
  40a4a0:	3d8027e1 	str	q1, [sp, #144]
  40a4a4:	3d802be2 	str	q2, [sp, #160]
  40a4a8:	3d802fe3 	str	q3, [sp, #176]
  40a4ac:	3d8033e4 	str	q4, [sp, #192]
  40a4b0:	3d8037e5 	str	q5, [sp, #208]
  40a4b4:	3d803be6 	str	q6, [sp, #224]
  40a4b8:	3d803fe7 	str	q7, [sp, #240]
  40a4bc:	a91193e3 	stp	x3, x4, [sp, #280]
  40a4c0:	910043e3 	add	x3, sp, #0x10
  40a4c4:	a9129be5 	stp	x5, x6, [sp, #296]
  40a4c8:	f9009fe7 	str	x7, [sp, #312]
  40a4cc:	f9400020 	ldr	x0, [x1]
  40a4d0:	f9003fe0 	str	x0, [sp, #120]
  40a4d4:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stdout, format, variable_args);
  40a4d8:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
	va_start(variable_args, format);
  40a4dc:	910503e0 	add	x0, sp, #0x140
  40a4e0:	a90383e0 	stp	x0, x0, [sp, #56]
  40a4e4:	910403e0 	add	x0, sp, #0x100
	vfprintf(stdout, format, variable_args);
  40a4e8:	f9474021 	ldr	x1, [x1, #3712]
	va_start(variable_args, format);
  40a4ec:	f90027e0 	str	x0, [sp, #72]
  40a4f0:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40a4f4:	b90053e0 	str	w0, [sp, #80]
  40a4f8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a4fc:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stdout, format, variable_args);
  40a500:	f9400020 	ldr	x0, [x1]
  40a504:	9100e3e1 	add	x1, sp, #0x38
  40a508:	ad400420 	ldp	q0, q1, [x1]
  40a50c:	910163e1 	add	x1, sp, #0x58
  40a510:	ad000420 	stp	q0, q1, [x1]
  40a514:	52800021 	mov	w1, #0x1                   	// #1
  40a518:	ad000460 	stp	q0, q1, [x3]
  40a51c:	97ffdb69 	bl	4012c0 <__vfprintf_chk@plt>
}
  40a520:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40a524:	f9476800 	ldr	x0, [x0, #3792]
  40a528:	f9403fe2 	ldr	x2, [sp, #120]
  40a52c:	f9400001 	ldr	x1, [x0]
  40a530:	eb010042 	subs	x2, x2, x1
  40a534:	d2800001 	mov	x1, #0x0                   	// #0
  40a538:	54000040 	b.eq	40a540 <posix_print_trace+0xc0>  // b.none
  40a53c:	97ffdb79 	bl	401320 <__stack_chk_fail@plt>
  40a540:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40a544:	d65f03c0 	ret

000000000040a548 <native_add_tracing_options>:
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
  40a548:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40a54c:	9107c000 	add	x0, x0, #0x1f0
  40a550:	14000233 	b	40ae1c <native_add_command_line_opts>

000000000040a554 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
  40a554:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a558:	910003fd 	mov	x29, sp
  40a55c:	a90153f3 	stp	x19, x20, [sp, #16]
  40a560:	aa0003f4 	mov	x20, x0
  40a564:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a568:	aa0103f6 	mov	x22, x1

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
  40a56c:	39400420 	ldrb	w0, [x1, #1]
  40a570:	35000440 	cbnz	w0, 40a5f8 <cmd_gen_switch_syntax.constprop.0+0xa4>
		*buf++ = '[';
  40a574:	52800b60 	mov	w0, #0x5b                  	// #91
		size--;
  40a578:	528008b5 	mov	w21, #0x45                  	// #69
		*buf++ = '[';
  40a57c:	38001680 	strb	w0, [x20], #1
	}

	if (args_s_el->is_switch == true) {
  40a580:	39400ac0 	ldrb	w0, [x22, #2]
		ret = snprintf(buf, size, "-%s", args_s_el->option);
  40a584:	93407ea1 	sxtw	x1, w21
  40a588:	f94006c5 	ldr	x5, [x22, #8]
	if (args_s_el->is_switch == true) {
  40a58c:	340003a0 	cbz	w0, 40a600 <cmd_gen_switch_syntax.constprop.0+0xac>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40a590:	f0000044 	adrp	x4, 415000 <random_data+0xd8c>
  40a594:	aa1403e0 	mov	x0, x20
  40a598:	9112b884 	add	x4, x4, #0x4ae
  40a59c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40a5a0:	52800022 	mov	w2, #0x1                   	// #1
  40a5a4:	97ffdb2f 	bl	401260 <__snprintf_chk@plt>
  40a5a8:	2a0003f3 	mov	w19, w0
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
  40a5ac:	36f800e0 	tbz	w0, #31, 40a5c8 <cmd_gen_switch_syntax.constprop.0+0x74>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
  40a5b0:	f0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40a5b4:	f0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40a5b8:	91131c21 	add	x1, x1, #0x4c7
  40a5bc:	91141400 	add	x0, x0, #0x505
  40a5c0:	528020e2 	mov	w2, #0x107                 	// #263
  40a5c4:	97ffff49 	bl	40a2e8 <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
  40a5c8:	6b1302a1 	subs	w1, w21, w19
  40a5cc:	540003c4 	b.mi	40a644 <cmd_gen_switch_syntax.constprop.0+0xf0>  // b.first
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
  40a5d0:	394006c2 	ldrb	w2, [x22, #1]
	buf += ret;
  40a5d4:	8b33c280 	add	x0, x20, w19, sxtw
		snprintf(buf, size, "] ");
  40a5d8:	93407c21 	sxtw	x1, w1
	if (args_s_el->is_mandatory == false) {
  40a5dc:	350002e2 	cbnz	w2, 40a638 <cmd_gen_switch_syntax.constprop.0+0xe4>
  40a5e0:	d0000042 	adrp	x2, 414000 <__func__.1+0xd>
  40a5e4:	912d0842 	add	x2, x2, #0xb42
	} else {
		snprintf(buf, size, " ");
	}
}
  40a5e8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a5ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a5f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a5f4:	17ffdb13 	b	401240 <snprintf@plt>
  40a5f8:	528008d5 	mov	w21, #0x46                  	// #70
  40a5fc:	17ffffe1 	b	40a580 <cmd_gen_switch_syntax.constprop.0+0x2c>
		if (args_s_el->type != 'l') {
  40a600:	394062c0 	ldrb	w0, [x22, #24]
			ret = snprintf(buf, size, "-%s=<%s>",
  40a604:	f9400ac6 	ldr	x6, [x22, #16]
		if (args_s_el->type != 'l') {
  40a608:	7101b01f 	cmp	w0, #0x6c
  40a60c:	54000100 	b.eq	40a62c <cmd_gen_switch_syntax.constprop.0+0xd8>  // b.none
  40a610:	f0000044 	adrp	x4, 415000 <random_data+0xd8c>
  40a614:	9112c884 	add	x4, x4, #0x4b2
  40a618:	aa1403e0 	mov	x0, x20
  40a61c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40a620:	52800022 	mov	w2, #0x1                   	// #1
  40a624:	97ffdb0f 	bl	401260 <__snprintf_chk@plt>
  40a628:	17ffffe0 	b	40a5a8 <cmd_gen_switch_syntax.constprop.0+0x54>
  40a62c:	f0000044 	adrp	x4, 415000 <random_data+0xd8c>
  40a630:	9112ec84 	add	x4, x4, #0x4bb
  40a634:	17fffff9 	b	40a618 <cmd_gen_switch_syntax.constprop.0+0xc4>
  40a638:	d0000042 	adrp	x2, 414000 <__func__.1+0xd>
  40a63c:	912d8842 	add	x2, x2, #0xb62
  40a640:	17ffffea 	b	40a5e8 <cmd_gen_switch_syntax.constprop.0+0x94>
}
  40a644:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a648:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a64c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a650:	d65f03c0 	ret

000000000040a654 <cmd_is_option>:
{
  40a654:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40a658:	910003fd 	mov	x29, sp
  40a65c:	a90153f3 	stp	x19, x20, [sp, #16]
  40a660:	aa0003f4 	mov	x20, x0
  40a664:	2a0203f3 	mov	w19, w2
	size_t to_match_len = strlen(option);
  40a668:	aa0103e0 	mov	x0, x1
{
  40a66c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a670:	aa0103f5 	mov	x21, x1
  40a674:	f9001bf7 	str	x23, [sp, #48]
	size_t to_match_len = strlen(option);
  40a678:	97ffdaca 	bl	4011a0 <strlen@plt>
  40a67c:	aa0003f7 	mov	x23, x0
	if (arg[of] == '-') {
  40a680:	39400280 	ldrb	w0, [x20]
  40a684:	7100b41f 	cmp	w0, #0x2d
	if (arg[of] == '-') {
  40a688:	9a9f17e0 	cset	x0, eq  // eq = none
	if (arg[of] == '-') {
  40a68c:	1a9f17f6 	cset	w22, eq  // eq = none
	if (arg[of] == '-') {
  40a690:	38606a80 	ldrb	w0, [x20, x0]
		of++;
  40a694:	7100b41f 	cmp	w0, #0x2d
  40a698:	1a9616d6 	cinc	w22, w22, eq  // eq = none
	if (!with_value) {
  40a69c:	93407ec2 	sxtw	x2, w22
  40a6a0:	34000293 	cbz	w19, 40a6f0 <cmd_is_option+0x9c>
		if (*option == 0) {
  40a6a4:	cb0202b5 	sub	x21, x21, x2
	while (!(arg[of] == 0 && *option == 0)) {
  40a6a8:	38626a80 	ldrb	w0, [x20, x2]
  40a6ac:	2a0203f3 	mov	w19, w2
		if (*option == 0) {
  40a6b0:	38626aa1 	ldrb	w1, [x21, x2]
	while (!(arg[of] == 0 && *option == 0)) {
  40a6b4:	2a010003 	orr	w3, w0, w1
  40a6b8:	34000123 	cbz	w3, 40a6dc <cmd_is_option+0x88>
		if (*option == 0) {
  40a6bc:	35000301 	cbnz	w1, 40a71c <cmd_is_option+0xc8>
			if ((arg[of] == ':') || (arg[of] == '=')) {
  40a6c0:	7100e81f 	cmp	w0, #0x3a
  40a6c4:	528007a1 	mov	w1, #0x3d                  	// #61
  40a6c8:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40a6cc:	540002e1 	b.ne	40a728 <cmd_is_option+0xd4>  // b.any
				of++;
  40a6d0:	11000673 	add	w19, w19, #0x1
	if (arg[of] == 0) { /* we need a value to follow */
  40a6d4:	3873ca80 	ldrb	w0, [x20, w19, sxtw]
  40a6d8:	35000160 	cbnz	w0, 40a704 <cmd_is_option+0xb0>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
  40a6dc:	aa1403e1 	mov	x1, x20
  40a6e0:	f0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40a6e4:	91148000 	add	x0, x0, #0x520
  40a6e8:	97ffff00 	bl	40a2e8 <posix_print_error_and_exit>
  40a6ec:	14000006 	b	40a704 <cmd_is_option+0xb0>
		if (strcmp(&arg[of], option) != 0) {
  40a6f0:	aa1503e1 	mov	x1, x21
  40a6f4:	8b020280 	add	x0, x20, x2
  40a6f8:	97ffdb2a 	bl	4013a0 <strcmp@plt>
  40a6fc:	35000040 	cbnz	w0, 40a704 <cmd_is_option+0xb0>
			return of + to_match_len;
  40a700:	0b1702d3 	add	w19, w22, w23
}
  40a704:	2a1303e0 	mov	w0, w19
  40a708:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a70c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a710:	f9401bf7 	ldr	x23, [sp, #48]
  40a714:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40a718:	d65f03c0 	ret
		if (arg[of] != *option) {
  40a71c:	91000442 	add	x2, x2, #0x1
  40a720:	6b01001f 	cmp	w0, w1
  40a724:	54fffc20 	b.eq	40a6a8 <cmd_is_option+0x54>  // b.none
			return 0;
  40a728:	52800013 	mov	w19, #0x0                   	// #0
  40a72c:	17fffff6 	b	40a704 <cmd_is_option+0xb0>

000000000040a730 <cmd_is_help_option>:
{
  40a730:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a734:	910003fd 	mov	x29, sp
  40a738:	f9000bf3 	str	x19, [sp, #16]
  40a73c:	aa0003f3 	mov	x19, x0
	if (arg[0] == '-') {
  40a740:	39400000 	ldrb	w0, [x0]
  40a744:	7100b41f 	cmp	w0, #0x2d
  40a748:	540000c1 	b.ne	40a760 <cmd_is_help_option+0x30>  // b.any
	if (arg[0] == '-') {
  40a74c:	aa1303e0 	mov	x0, x19
		arg++;
  40a750:	91000a73 	add	x19, x19, #0x2
	if (arg[0] == '-') {
  40a754:	38401c01 	ldrb	w1, [x0, #1]!
		arg++;
  40a758:	7100b43f 	cmp	w1, #0x2d
  40a75c:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	if ((strcasecmp(arg, "?") == 0) ||
  40a760:	f0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40a764:	aa1303e0 	mov	x0, x19
  40a768:	9115e821 	add	x1, x1, #0x57a
  40a76c:	97ffdae1 	bl	4012f0 <strcasecmp@plt>
  40a770:	340001e0 	cbz	w0, 40a7ac <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "h") == 0) ||
  40a774:	90000061 	adrp	x1, 416000 <__func__.0+0xc27>
  40a778:	aa1303e0 	mov	x0, x19
  40a77c:	9116b821 	add	x1, x1, #0x5ae
  40a780:	97ffdadc 	bl	4012f0 <strcasecmp@plt>
	if ((strcasecmp(arg, "?") == 0) ||
  40a784:	34000140 	cbz	w0, 40a7ac <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "help") == 0)) {
  40a788:	aa1303e0 	mov	x0, x19
  40a78c:	f0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40a790:	91185821 	add	x1, x1, #0x616
  40a794:	97ffdad7 	bl	4012f0 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
  40a798:	7100001f 	cmp	w0, #0x0
  40a79c:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40a7a0:	f9400bf3 	ldr	x19, [sp, #16]
  40a7a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a7a8:	d65f03c0 	ret
		return 1;
  40a7ac:	52800020 	mov	w0, #0x1                   	// #1
  40a7b0:	17fffffc 	b	40a7a0 <cmd_is_help_option+0x70>

000000000040a7b4 <cmd_read_option_value>:
{
  40a7b4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40a7b8:	910003fd 	mov	x29, sp
  40a7bc:	a90153f3 	stp	x19, x20, [sp, #16]
  40a7c0:	aa0103f4 	mov	x20, x1
  40a7c4:	12001c41 	and	w1, w2, #0xff
  40a7c8:	b0000102 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
  40a7cc:	f90013f5 	str	x21, [sp, #32]
  40a7d0:	aa0303f5 	mov	x21, x3
  40a7d4:	aa0003f3 	mov	x19, x0
  40a7d8:	f9476842 	ldr	x2, [x2, #3792]
  40a7dc:	f9400043 	ldr	x3, [x2]
  40a7e0:	f9001fe3 	str	x3, [sp, #56]
  40a7e4:	d2800003 	mov	x3, #0x0                   	// #0
	char *endptr = NULL;
  40a7e8:	f9001bff 	str	xzr, [sp, #48]
	switch (type) {
  40a7ec:	7101903f 	cmp	w1, #0x64
  40a7f0:	54000b40 	b.eq	40a958 <cmd_read_option_value+0x1a4>  // b.none
  40a7f4:	54000168 	b.hi	40a820 <cmd_read_option_value+0x6c>  // b.pmore
  40a7f8:	7101543f 	cmp	w1, #0x55
  40a7fc:	540009c0 	b.eq	40a934 <cmd_read_option_value+0x180>  // b.none
  40a800:	7101883f 	cmp	w1, #0x62
  40a804:	54000220 	b.eq	40a848 <cmd_read_option_value+0x94>  // b.none
  40a808:	7101243f 	cmp	w1, #0x49
  40a80c:	540009e0 	b.eq	40a948 <cmd_read_option_value+0x194>  // b.none
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
  40a810:	f0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40a814:	91172c00 	add	x0, x0, #0x5cb
  40a818:	97fffeb4 	bl	40a2e8 <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
  40a81c:	14000012 	b	40a864 <cmd_read_option_value+0xb0>
	switch (type) {
  40a820:	7101cc3f 	cmp	w1, #0x73
  40a824:	54000760 	b.eq	40a910 <cmd_read_option_value+0x15c>  // b.none
  40a828:	7101d43f 	cmp	w1, #0x75
  40a82c:	540007a0 	b.eq	40a920 <cmd_read_option_value+0x16c>  // b.none
  40a830:	7101a43f 	cmp	w1, #0x69
  40a834:	54fffee1 	b.ne	40a810 <cmd_read_option_value+0x5c>  // b.any
		*(int32_t *)dest = strtol(str, &endptr, 0);
  40a838:	9100c3e1 	add	x1, sp, #0x30
  40a83c:	52800002 	mov	w2, #0x0                   	// #0
  40a840:	97ffdae4 	bl	4013d0 <strtol@plt>
  40a844:	1400003a 	b	40a92c <cmd_read_option_value+0x178>
		if (strcasecmp(str, "false") == 0) {
  40a848:	f0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40a84c:	9115f021 	add	x1, x1, #0x57c
  40a850:	97ffdaa8 	bl	4012f0 <strcasecmp@plt>
  40a854:	35000120 	cbnz	w0, 40a878 <cmd_read_option_value+0xc4>
			endptr = (char *)str + 5;
  40a858:	91001660 	add	x0, x19, #0x5
			*(bool *)dest = false;
  40a85c:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  40a860:	f9001be0 	str	x0, [sp, #48]
	if (!error && endptr && *endptr != 0) {
  40a864:	f9401be0 	ldr	x0, [sp, #48]
  40a868:	b40003e0 	cbz	x0, 40a8e4 <cmd_read_option_value+0x130>
  40a86c:	39400000 	ldrb	w0, [x0]
  40a870:	35000300 	cbnz	w0, 40a8d0 <cmd_read_option_value+0x11c>
  40a874:	1400001c 	b	40a8e4 <cmd_read_option_value+0x130>
		} else if (strcmp(str, "0") == 0) {
  40a878:	90000061 	adrp	x1, 416000 <__func__.0+0xc27>
  40a87c:	aa1303e0 	mov	x0, x19
  40a880:	911f5821 	add	x1, x1, #0x7d6
  40a884:	97ffdac7 	bl	4013a0 <strcmp@plt>
  40a888:	35000080 	cbnz	w0, 40a898 <cmd_read_option_value+0xe4>
			*(bool *)dest = false;
  40a88c:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  40a890:	91000660 	add	x0, x19, #0x1
  40a894:	17fffff3 	b	40a860 <cmd_read_option_value+0xac>
		} else if (strcasecmp(str, "true") == 0) {
  40a898:	f0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40a89c:	aa1303e0 	mov	x0, x19
  40a8a0:	91160821 	add	x1, x1, #0x582
  40a8a4:	97ffda93 	bl	4012f0 <strcasecmp@plt>
  40a8a8:	350000a0 	cbnz	w0, 40a8bc <cmd_read_option_value+0x108>
			*(bool *)dest = true;
  40a8ac:	52800020 	mov	w0, #0x1                   	// #1
  40a8b0:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 4;
  40a8b4:	91001260 	add	x0, x19, #0x4
  40a8b8:	17ffffea 	b	40a860 <cmd_read_option_value+0xac>
		} else if (strcmp(str, "1") == 0) {
  40a8bc:	f0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40a8c0:	aa1303e0 	mov	x0, x19
  40a8c4:	91161c21 	add	x1, x1, #0x587
  40a8c8:	97ffdab6 	bl	4013a0 <strcmp@plt>
  40a8cc:	340001c0 	cbz	w0, 40a904 <cmd_read_option_value+0x150>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
  40a8d0:	f0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40a8d4:	aa1303e2 	mov	x2, x19
  40a8d8:	aa1503e1 	mov	x1, x21
  40a8dc:	91162400 	add	x0, x0, #0x589
  40a8e0:	97fffe82 	bl	40a2e8 <posix_print_error_and_exit>
}
  40a8e4:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40a8e8:	f9476800 	ldr	x0, [x0, #3792]
  40a8ec:	f9401fe2 	ldr	x2, [sp, #56]
  40a8f0:	f9400001 	ldr	x1, [x0]
  40a8f4:	eb010042 	subs	x2, x2, x1
  40a8f8:	d2800001 	mov	x1, #0x0                   	// #0
  40a8fc:	54000360 	b.eq	40a968 <cmd_read_option_value+0x1b4>  // b.none
  40a900:	97ffda88 	bl	401320 <__stack_chk_fail@plt>
			*(bool *)dest = true;
  40a904:	52800020 	mov	w0, #0x1                   	// #1
  40a908:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 1;
  40a90c:	17ffffe1 	b	40a890 <cmd_read_option_value+0xdc>
		*(char **)dest = (char *)str;
  40a910:	f9000280 	str	x0, [x20]
		endptr = (char *)str + strlen(str);
  40a914:	97ffda23 	bl	4011a0 <strlen@plt>
  40a918:	8b000260 	add	x0, x19, x0
  40a91c:	17ffffd1 	b	40a860 <cmd_read_option_value+0xac>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
  40a920:	9100c3e1 	add	x1, sp, #0x30
  40a924:	52800002 	mov	w2, #0x0                   	// #0
  40a928:	97ffda1a 	bl	401190 <strtoul@plt>
		*(int32_t *)dest = strtol(str, &endptr, 0);
  40a92c:	b9000280 	str	w0, [x20]
	if (!error && endptr && *endptr != 0) {
  40a930:	17ffffcd 	b	40a864 <cmd_read_option_value+0xb0>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
  40a934:	9100c3e1 	add	x1, sp, #0x30
  40a938:	52800002 	mov	w2, #0x0                   	// #0
  40a93c:	97ffdab9 	bl	401420 <strtoull@plt>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  40a940:	f9000280 	str	x0, [x20]
	if (!error && endptr && *endptr != 0) {
  40a944:	17ffffc8 	b	40a864 <cmd_read_option_value+0xb0>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  40a948:	9100c3e1 	add	x1, sp, #0x30
  40a94c:	52800002 	mov	w2, #0x0                   	// #0
  40a950:	97ffda20 	bl	4011d0 <strtoll@plt>
  40a954:	17fffffb 	b	40a940 <cmd_read_option_value+0x18c>
		*(double *)dest = strtod(str, &endptr);
  40a958:	9100c3e1 	add	x1, sp, #0x30
  40a95c:	97ffda25 	bl	4011f0 <strtod@plt>
  40a960:	fd000280 	str	d0, [x20]
	if (!error && endptr && *endptr != 0) {
  40a964:	17ffffc0 	b	40a864 <cmd_read_option_value+0xb0>
}
  40a968:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a96c:	f94013f5 	ldr	x21, [sp, #32]
  40a970:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40a974:	d65f03c0 	ret

000000000040a978 <cmd_args_set_defaults>:
{
  40a978:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40a97c:	910003fd 	mov	x29, sp
  40a980:	a90153f3 	stp	x19, x20, [sp, #16]
  40a984:	91002013 	add	x19, x0, #0x8
			*(double *)args_struct[count].dest = (double)NAN;
  40a988:	b0000040 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  40a98c:	f0000054 	adrp	x20, 415000 <random_data+0xd8c>
  40a990:	91172e94 	add	x20, x20, #0x5cb
{
  40a994:	fd001be8 	str	d8, [sp, #48]
			*(double *)args_struct[count].dest = (double)NAN;
  40a998:	fd42a408 	ldr	d8, [x0, #1352]
{
  40a99c:	a9025bf5 	stp	x21, x22, [sp, #32]
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  40a9a0:	12800015 	mov	w21, #0xffffffff            	// #-1
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  40a9a4:	12b00016 	mov	w22, #0x7fffffff            	// #2147483647
	while (args_struct[count].option != NULL) {
  40a9a8:	f9400260 	ldr	x0, [x19]
  40a9ac:	b50000c0 	cbnz	x0, 40a9c4 <cmd_args_set_defaults+0x4c>
}
  40a9b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a9b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a9b8:	fd401be8 	ldr	d8, [sp, #48]
  40a9bc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40a9c0:	d65f03c0 	ret
		if (args_struct[count].dest == NULL) {
  40a9c4:	f9400e62 	ldr	x2, [x19, #24]
  40a9c8:	b4000222 	cbz	x2, 40aa0c <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  40a9cc:	39404261 	ldrb	w1, [x19, #16]
  40a9d0:	7101903f 	cmp	w1, #0x64
  40a9d4:	54000420 	b.eq	40aa58 <cmd_args_set_defaults+0xe0>  // b.none
  40a9d8:	540001e8 	b.hi	40aa14 <cmd_args_set_defaults+0x9c>  // b.pmore
  40a9dc:	7101543f 	cmp	w1, #0x55
  40a9e0:	54000320 	b.eq	40aa44 <cmd_args_set_defaults+0xcc>  // b.none
  40a9e4:	540000e8 	b.hi	40aa00 <cmd_args_set_defaults+0x88>  // b.pmore
  40a9e8:	34000121 	cbz	w1, 40aa0c <cmd_args_set_defaults+0x94>
  40a9ec:	7101243f 	cmp	w1, #0x49
  40a9f0:	54000300 	b.eq	40aa50 <cmd_args_set_defaults+0xd8>  // b.none
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  40a9f4:	aa1403e0 	mov	x0, x20
  40a9f8:	97fffe3c 	bl	40a2e8 <posix_print_error_and_exit>
			break;
  40a9fc:	14000004 	b	40aa0c <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  40aa00:	7101883f 	cmp	w1, #0x62
  40aa04:	54ffff81 	b.ne	40a9f4 <cmd_args_set_defaults+0x7c>  // b.any
			*(bool *)args_struct[count].dest = false;
  40aa08:	3900005f 	strb	wzr, [x2]
			break;
  40aa0c:	9100e273 	add	x19, x19, #0x38
  40aa10:	17ffffe6 	b	40a9a8 <cmd_args_set_defaults+0x30>
		switch (args_struct[count].type) {
  40aa14:	7101cc3f 	cmp	w1, #0x73
  40aa18:	540000e0 	b.eq	40aa34 <cmd_args_set_defaults+0xbc>  // b.none
  40aa1c:	7101d43f 	cmp	w1, #0x75
  40aa20:	540000e0 	b.eq	40aa3c <cmd_args_set_defaults+0xc4>  // b.none
  40aa24:	7101a43f 	cmp	w1, #0x69
  40aa28:	54fffe61 	b.ne	40a9f4 <cmd_args_set_defaults+0x7c>  // b.any
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  40aa2c:	b9000056 	str	w22, [x2]
			break;
  40aa30:	17fffff7 	b	40aa0c <cmd_args_set_defaults+0x94>
			*(char **)args_struct[count].dest = NULL;
  40aa34:	f900005f 	str	xzr, [x2]
			break;
  40aa38:	17fffff5 	b	40aa0c <cmd_args_set_defaults+0x94>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  40aa3c:	b9000055 	str	w21, [x2]
			break;
  40aa40:	17fffff3 	b	40aa0c <cmd_args_set_defaults+0x94>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
  40aa44:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  40aa48:	f9000040 	str	x0, [x2]
			break;
  40aa4c:	17fffff0 	b	40aa0c <cmd_args_set_defaults+0x94>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  40aa50:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  40aa54:	17fffffd 	b	40aa48 <cmd_args_set_defaults+0xd0>
			*(double *)args_struct[count].dest = (double)NAN;
  40aa58:	fd000048 	str	d8, [x2]
			break;
  40aa5c:	17ffffec 	b	40aa0c <cmd_args_set_defaults+0x94>

000000000040aa60 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
  40aa60:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  40aa64:	f0000043 	adrp	x3, 415000 <random_data+0xd8c>
  40aa68:	d0000042 	adrp	x2, 414000 <__func__.1+0xd>
  40aa6c:	910003fd 	mov	x29, sp
  40aa70:	a90153f3 	stp	x19, x20, [sp, #16]
  40aa74:	aa0003f4 	mov	x20, x0
  40aa78:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;

	fprintf(stdout, "%s ", _HELP_SWITCH);
  40aa7c:	b0000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
{
  40aa80:	a9025bf5 	stp	x21, x22, [sp, #32]
  40aa84:	9117c063 	add	x3, x3, #0x5f0
  40aa88:	f9476800 	ldr	x0, [x0, #3792]
  40aa8c:	a90363f7 	stp	x23, x24, [sp, #48]
  40aa90:	912c7042 	add	x2, x2, #0xb1c
  40aa94:	f9400001 	ldr	x1, [x0]
  40aa98:	f90047e1 	str	x1, [sp, #136]
  40aa9c:	d2800001 	mov	x1, #0x0                   	// #0
  40aaa0:	f0000057 	adrp	x23, 415000 <random_data+0xd8c>
	fprintf(stdout, "%s ", _HELP_SWITCH);
  40aaa4:	f9474260 	ldr	x0, [x19, #3712]
  40aaa8:	f0000058 	adrp	x24, 415000 <random_data+0xd8c>

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40aaac:	910103f6 	add	x22, sp, #0x40
  40aab0:	91320af7 	add	x23, x23, #0xc82
  40aab4:	9112bf18 	add	x24, x24, #0x4af
  40aab8:	52800021 	mov	w1, #0x1                   	// #1
  40aabc:	f9400000 	ldr	x0, [x0]
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
  40aac0:	52800335 	mov	w21, #0x19                  	// #25
  40aac4:	97ffda33 	bl	401390 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
  40aac8:	f9400680 	ldr	x0, [x20, #8]
  40aacc:	b5000120 	cbnz	x0, 40aaf0 <cmd_print_switches_help+0x90>
  40aad0:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40aad4:	f9476800 	ldr	x0, [x0, #3792]
  40aad8:	f94047e2 	ldr	x2, [sp, #136]
  40aadc:	f9400001 	ldr	x1, [x0]
  40aae0:	eb010042 	subs	x2, x2, x1
  40aae4:	d2800001 	mov	x1, #0x0                   	// #0
  40aae8:	54000360 	b.eq	40ab54 <cmd_print_switches_help+0xf4>  // b.none
  40aaec:	97ffda0d 	bl	401320 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40aaf0:	aa1403e1 	mov	x1, x20
  40aaf4:	aa1603e0 	mov	x0, x22
  40aaf8:	97fffe97 	bl	40a554 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
  40aafc:	aa1603e0 	mov	x0, x22
  40ab00:	97ffd9a8 	bl	4011a0 <strlen@plt>
  40ab04:	8b35c000 	add	x0, x0, w21, sxtw
  40ab08:	f101901f 	cmp	x0, #0x64
  40ab0c:	540000e9 	b.ls	40ab28 <cmd_print_switches_help+0xc8>  // b.plast
			fprintf(stdout, "\n");
  40ab10:	f9474260 	ldr	x0, [x19, #3712]
  40ab14:	aa1703e2 	mov	x2, x23
  40ab18:	52800021 	mov	w1, #0x1                   	// #1
			printed_in_line = 0;
  40ab1c:	52800015 	mov	w21, #0x0                   	// #0
  40ab20:	f9400000 	ldr	x0, [x0]
  40ab24:	97ffda1b 	bl	401390 <__fprintf_chk@plt>
		}

		fprintf(stdout, "%s", stringy);
  40ab28:	f9474260 	ldr	x0, [x19, #3712]
  40ab2c:	aa1603e3 	mov	x3, x22
  40ab30:	aa1803e2 	mov	x2, x24
  40ab34:	52800021 	mov	w1, #0x1                   	// #1
  40ab38:	9100e294 	add	x20, x20, #0x38
  40ab3c:	f9400000 	ldr	x0, [x0]
  40ab40:	97ffda14 	bl	401390 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
  40ab44:	aa1603e0 	mov	x0, x22
  40ab48:	97ffd996 	bl	4011a0 <strlen@plt>
  40ab4c:	0b0002b5 	add	w21, w21, w0
		count++;
  40ab50:	17ffffde 	b	40aac8 <cmd_print_switches_help+0x68>
	}

	fprintf(stdout, "\n");
  40ab54:	f9474273 	ldr	x19, [x19, #3712]
  40ab58:	f0000042 	adrp	x2, 415000 <random_data+0xd8c>
}
  40ab5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ab60:	91320842 	add	x2, x2, #0xc82
  40ab64:	f9400260 	ldr	x0, [x19]
  40ab68:	52800021 	mov	w1, #0x1                   	// #1
  40ab6c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ab70:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ab74:	a8c97bfd 	ldp	x29, x30, [sp], #144
  40ab78:	17ffda06 	b	401390 <__fprintf_chk@plt>

000000000040ab7c <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
  40ab7c:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  40ab80:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40ab84:	910003fd 	mov	x29, sp
  40ab88:	f9476821 	ldr	x1, [x1, #3792]
  40ab8c:	a90153f3 	stp	x19, x20, [sp, #16]
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  40ab90:	b0000114 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
{
  40ab94:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ab98:	aa0003f3 	mov	x19, x0
  40ab9c:	a90363f7 	stp	x23, x24, [sp, #48]
  40aba0:	f0000057 	adrp	x23, 415000 <random_data+0xd8c>
  40aba4:	f0000058 	adrp	x24, 415000 <random_data+0xd8c>
  40aba8:	a9046bf9 	stp	x25, x26, [sp, #64]
  40abac:	91189af7 	add	x23, x23, #0x626
  40abb0:	91320f18 	add	x24, x24, #0xc83
  40abb4:	a90573fb 	stp	x27, x28, [sp, #80]
  40abb8:	f9400022 	ldr	x2, [x1]
  40abbc:	f90057e2 	str	x2, [sp, #168]
  40abc0:	d2800002 	mov	x2, #0x0                   	// #0
	cmd_print_switches_help(args_struct);
  40abc4:	97ffffa7 	bl	40aa60 <cmd_print_switches_help>
	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  40abc8:	f9474280 	ldr	x0, [x20, #3712]
  40abcc:	f0000045 	adrp	x5, 415000 <random_data+0xd8c>
  40abd0:	f0000044 	adrp	x4, 415000 <random_data+0xd8c>
  40abd4:	f0000042 	adrp	x2, 415000 <random_data+0xd8c>
  40abd8:	911824a5 	add	x5, x5, #0x609
  40abdc:	9117c084 	add	x4, x4, #0x5f0
  40abe0:	f9400000 	ldr	x0, [x0]
  40abe4:	91186c42 	add	x2, x2, #0x61b
  40abe8:	528003a3 	mov	w3, #0x1d                  	// #29
  40abec:	52800021 	mov	w1, #0x1                   	// #1
  40abf0:	97ffd9e8 	bl	401390 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
  40abf4:	f9400660 	ldr	x0, [x19, #8]
  40abf8:	b5000280 	cbnz	x0, 40ac48 <cmd_print_long_help+0xcc>
				      &toprint[printed_right]);
			printed_right += ret - 1;
		}
		count++;
	}
	fprintf(stdout, "\n");
  40abfc:	f9474294 	ldr	x20, [x20, #3712]
  40ac00:	52800021 	mov	w1, #0x1                   	// #1
  40ac04:	f0000042 	adrp	x2, 415000 <random_data+0xd8c>
  40ac08:	91320842 	add	x2, x2, #0xc82
  40ac0c:	f9400280 	ldr	x0, [x20]
  40ac10:	97ffd9e0 	bl	401390 <__fprintf_chk@plt>
  40ac14:	f9400280 	ldr	x0, [x20]
  40ac18:	52800021 	mov	w1, #0x1                   	// #1
  40ac1c:	f0000042 	adrp	x2, 415000 <random_data+0xd8c>
  40ac20:	9118dc42 	add	x2, x2, #0x637
  40ac24:	97ffd9db 	bl	401390 <__fprintf_chk@plt>
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
  40ac28:	b0000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40ac2c:	f9476800 	ldr	x0, [x0, #3792]
  40ac30:	f94057e2 	ldr	x2, [sp, #168]
  40ac34:	f9400001 	ldr	x1, [x0]
  40ac38:	eb010042 	subs	x2, x2, x1
  40ac3c:	d2800001 	mov	x1, #0x0                   	// #0
  40ac40:	54000600 	b.eq	40ad00 <cmd_print_long_help+0x184>  // b.none
  40ac44:	97ffd9b7 	bl	401320 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40ac48:	910183f5 	add	x21, sp, #0x60
  40ac4c:	aa1303e1 	mov	x1, x19
  40ac50:	aa1503e0 	mov	x0, x21
  40ac54:	97fffe40 	bl	40a554 <cmd_gen_switch_syntax.constprop.0>
		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
  40ac58:	f9474296 	ldr	x22, [x20, #3712]
  40ac5c:	aa1503e4 	mov	x4, x21
  40ac60:	aa1703e2 	mov	x2, x23
  40ac64:	528003a3 	mov	w3, #0x1d                  	// #29
  40ac68:	52800021 	mov	w1, #0x1                   	// #1
  40ac6c:	f000005b 	adrp	x27, 415000 <random_data+0xd8c>
  40ac70:	f94002c0 	ldr	x0, [x22]
  40ac74:	f000005c 	adrp	x28, 415000 <random_data+0xd8c>
  40ac78:	9118cf9c 	add	x28, x28, #0x633
  40ac7c:	97ffd9c5 	bl	401390 <__fprintf_chk@plt>
  40ac80:	2a0003f5 	mov	w21, w0
		toprint = args_struct[count].descript;
  40ac84:	f9401a7a 	ldr	x26, [x19, #48]
		total_to_print = strlen(toprint);
  40ac88:	aa1a03e0 	mov	x0, x26
  40ac8c:	97ffd945 	bl	4011a0 <strlen@plt>
  40ac90:	2a0003f9 	mov	w25, w0
  40ac94:	aa1a03e4 	mov	x4, x26
  40ac98:	f94002c0 	ldr	x0, [x22]
  40ac9c:	9118b762 	add	x2, x27, #0x62d
  40aca0:	52800c83 	mov	w3, #0x64                  	// #100
  40aca4:	52800021 	mov	w1, #0x1                   	// #1
  40aca8:	4b150063 	sub	w3, w3, w21
  40acac:	97ffd9b9 	bl	401390 <__fprintf_chk@plt>
		printed_right += ret - 1;
  40acb0:	51000415 	sub	w21, w0, #0x1
		while (printed_right < total_to_print) {
  40acb4:	6b1902bf 	cmp	w21, w25
  40acb8:	5400006b 	b.lt	40acc4 <cmd_print_long_help+0x148>  // b.tstop
		count++;
  40acbc:	9100e273 	add	x19, x19, #0x38
  40acc0:	17ffffcd 	b	40abf4 <cmd_print_long_help+0x78>
  40acc4:	f94002c0 	ldr	x0, [x22]
  40acc8:	aa1803e4 	mov	x4, x24
  40accc:	aa1c03e2 	mov	x2, x28
  40acd0:	528003c3 	mov	w3, #0x1e                  	// #30
  40acd4:	52800021 	mov	w1, #0x1                   	// #1
  40acd8:	97ffd9ae 	bl	401390 <__fprintf_chk@plt>
  40acdc:	f94002c0 	ldr	x0, [x22]
  40ace0:	8b35c344 	add	x4, x26, w21, sxtw
  40ace4:	9118b762 	add	x2, x27, #0x62d
  40ace8:	528008c3 	mov	w3, #0x46                  	// #70
  40acec:	52800021 	mov	w1, #0x1                   	// #1
  40acf0:	97ffd9a8 	bl	401390 <__fprintf_chk@plt>
			printed_right += ret - 1;
  40acf4:	51000400 	sub	w0, w0, #0x1
  40acf8:	0b0002b5 	add	w21, w21, w0
  40acfc:	17ffffee 	b	40acb4 <cmd_print_long_help+0x138>
}
  40ad00:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ad04:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ad08:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ad0c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40ad10:	a94573fb 	ldp	x27, x28, [sp, #80]
  40ad14:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  40ad18:	d65f03c0 	ret

000000000040ad1c <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
  40ad1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ad20:	910003fd 	mov	x29, sp
  40ad24:	a90153f3 	stp	x19, x20, [sp, #16]
  40ad28:	aa0003f4 	mov	x20, x0
  40ad2c:	aa0103f3 	mov	x19, x1
  40ad30:	f90013f5 	str	x21, [sp, #32]
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
  40ad34:	97fffe7f 	bl	40a730 <cmd_is_help_option>
  40ad38:	340000a0 	cbz	w0, 40ad4c <cmd_parse_one_arg+0x30>
		cmd_print_long_help(args_struct);
  40ad3c:	aa1303e0 	mov	x0, x19
  40ad40:	97ffff8f 	bl	40ab7c <cmd_print_long_help>
		posix_exit(0);
  40ad44:	52800000 	mov	w0, #0x0                   	// #0
  40ad48:	97fffd12 	bl	40a190 <posix_exit>
	}

	while (args_struct[count].option != NULL) {
  40ad4c:	f9400661 	ldr	x1, [x19, #8]
  40ad50:	b50000c1 	cbnz	x1, 40ad68 <cmd_parse_one_arg+0x4c>
						    &args_struct[count]);
			return true;
		}
		count++;
	}
	return false;
  40ad54:	52800000 	mov	w0, #0x0                   	// #0
}
  40ad58:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ad5c:	f94013f5 	ldr	x21, [sp, #32]
  40ad60:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40ad64:	d65f03c0 	ret
		if (args_struct[count].manual) {
  40ad68:	39400260 	ldrb	w0, [x19]
  40ad6c:	350003e0 	cbnz	w0, 40ade8 <cmd_parse_one_arg+0xcc>
				    !args_struct[count].is_switch);
  40ad70:	39400a62 	ldrb	w2, [x19, #2]
		ret = cmd_is_option(argv, args_struct[count].option,
  40ad74:	aa1403e0 	mov	x0, x20
  40ad78:	52000042 	eor	w2, w2, #0x1
  40ad7c:	97fffe36 	bl	40a654 <cmd_is_option>
  40ad80:	2a0003f5 	mov	w21, w0
		if (ret) {
  40ad84:	34000320 	cbz	w0, 40ade8 <cmd_parse_one_arg+0xcc>
	if (arg_element->dest != NULL) {
  40ad88:	f9401261 	ldr	x1, [x19, #32]
  40ad8c:	b4000101 	cbz	x1, 40adac <cmd_parse_one_arg+0x90>
		if (arg_element->is_switch) {
  40ad90:	39400a60 	ldrb	w0, [x19, #2]
			if (arg_element->type == 'b') {
  40ad94:	39406262 	ldrb	w2, [x19, #24]
		if (arg_element->is_switch) {
  40ad98:	34000200 	cbz	w0, 40add8 <cmd_parse_one_arg+0xbc>
			if (arg_element->type == 'b') {
  40ad9c:	7101885f 	cmp	w2, #0x62
  40ada0:	54000141 	b.ne	40adc8 <cmd_parse_one_arg+0xac>  // b.any
				*(bool *)arg_element->dest = true;
  40ada4:	52800020 	mov	w0, #0x1                   	// #1
  40ada8:	39000020 	strb	w0, [x1]
	if (arg_element->call_when_found) {
  40adac:	f9401662 	ldr	x2, [x19, #40]
  40adb0:	b4000082 	cbz	x2, 40adc0 <cmd_parse_one_arg+0xa4>
		arg_element->call_when_found(argv, offset);
  40adb4:	2a1503e1 	mov	w1, w21
  40adb8:	aa1403e0 	mov	x0, x20
  40adbc:	d63f0040 	blr	x2
			return true;
  40adc0:	52800020 	mov	w0, #0x1                   	// #1
  40adc4:	17ffffe5 	b	40ad58 <cmd_parse_one_arg+0x3c>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
  40adc8:	f0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40adcc:	911a1c00 	add	x0, x0, #0x687
  40add0:	97fffd46 	bl	40a2e8 <posix_print_error_and_exit>
  40add4:	17fffff6 	b	40adac <cmd_parse_one_arg+0x90>
			cmd_read_option_value(&argv[offset],
  40add8:	f9400663 	ldr	x3, [x19, #8]
  40addc:	8b35c280 	add	x0, x20, w21, sxtw
  40ade0:	97fffe75 	bl	40a7b4 <cmd_read_option_value>
  40ade4:	17fffff2 	b	40adac <cmd_parse_one_arg+0x90>
  40ade8:	9100e273 	add	x19, x19, #0x38
  40adec:	17ffffd8 	b	40ad4c <cmd_parse_one_arg+0x30>

000000000040adf0 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
  40adf0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40adf4:	910003fd 	mov	x29, sp
  40adf8:	f9000bf3 	str	x19, [sp, #16]
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
  40adfc:	d0000113 	adrp	x19, 42c000 <__dso_handle>
  40ae00:	f947ee60 	ldr	x0, [x19, #4056]
  40ae04:	b4000060 	cbz	x0, 40ae10 <native_cleanup_cmd_line+0x20>
		free(args_struct);
  40ae08:	97ffd976 	bl	4013e0 <free@plt>
		args_struct = NULL;
  40ae0c:	f907ee7f 	str	xzr, [x19, #4056]
	}
}
  40ae10:	f9400bf3 	ldr	x19, [sp, #16]
  40ae14:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40ae18:	d65f03c0 	ret

000000000040ae1c <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
  40ae1c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ae20:	910003fd 	mov	x29, sp
  40ae24:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ae28:	aa0003f5 	mov	x21, x0
  40ae2c:	91002000 	add	x0, x0, #0x8
  40ae30:	a90153f3 	stp	x19, x20, [sp, #16]
	int count = 0;
  40ae34:	52800013 	mov	w19, #0x0                   	// #0
{
  40ae38:	a90363f7 	stp	x23, x24, [sp, #48]
  40ae3c:	f90023f9 	str	x25, [sp, #64]

	while (args[count].option != NULL) {
  40ae40:	f8438401 	ldr	x1, [x0], #56
  40ae44:	2a1303f7 	mov	w23, w19
		count++;
  40ae48:	11000673 	add	w19, w19, #0x1
	while (args[count].option != NULL) {
  40ae4c:	b5ffffa1 	cbnz	x1, 40ae40 <native_add_command_line_opts+0x24>
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
  40ae50:	f0000116 	adrp	x22, 42d000 <counter_value>
  40ae54:	f0000119 	adrp	x25, 42d000 <counter_value>
  40ae58:	d0000118 	adrp	x24, 42c000 <__dso_handle>
  40ae5c:	b94f36c0 	ldr	w0, [x22, #3892]
  40ae60:	b94f2b21 	ldr	w1, [x25, #3880]
  40ae64:	0b000260 	add	w0, w19, w0
  40ae68:	6b01001f 	cmp	w0, w1
  40ae6c:	540001cb 	b.lt	40aea4 <native_add_command_line_opts+0x88>  // b.tstop
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
  40ae70:	7100527f 	cmp	w19, #0x14
  40ae74:	52800294 	mov	w20, #0x14                  	// #20
  40ae78:	1a94a274 	csel	w20, w19, w20, ge  // ge = tcont
  40ae7c:	0b010294 	add	w20, w20, w1
		struct args_struct_t *new_args_struct = realloc(args_struct,
  40ae80:	52800701 	mov	w1, #0x38                  	// #56
  40ae84:	f947ef00 	ldr	x0, [x24, #4056]
  40ae88:	9b217e81 	smull	x1, w20, w1
  40ae8c:	97ffd91d 	bl	401300 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
  40ae90:	b90f2b34 	str	w20, [x25, #3880]
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
  40ae94:	b5000260 	cbnz	x0, 40aee0 <native_add_command_line_opts+0xc4>
			posix_print_error_and_exit("Could not allocate memory");
  40ae98:	f0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40ae9c:	911b4800 	add	x0, x0, #0x6d2
  40aea0:	97fffd12 	bl	40a2e8 <posix_print_error_and_exit>
			args_struct = new_args_struct;
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
  40aea4:	b94f36d4 	ldr	w20, [x22, #3892]
  40aea8:	52800700 	mov	w0, #0x38                  	// #56
  40aeac:	f947ef03 	ldr	x3, [x24, #4056]
  return __builtin___memcpy_chk (__dest, __src, __len,
  40aeb0:	9b207e62 	smull	x2, w19, w0
  40aeb4:	aa1503e1 	mov	x1, x21
  40aeb8:	9b200e80 	smaddl	x0, w20, w0, x3
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
  40aebc:	0b170294 	add	w20, w20, w23
  40aec0:	97ffd8ac 	bl	401170 <memcpy@plt>
  40aec4:	b90f36d4 	str	w20, [x22, #3892]
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
  40aec8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40aecc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40aed0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40aed4:	f94023f9 	ldr	x25, [sp, #64]
  40aed8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40aedc:	d65f03c0 	ret
			args_struct = new_args_struct;
  40aee0:	f907ef00 	str	x0, [x24, #4056]
  40aee4:	17fffff0 	b	40aea4 <native_add_command_line_opts+0x88>

000000000040aee8 <native_add_testargs_option>:
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
  40aee8:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40aeec:	910b4000 	add	x0, x0, #0x2d0
  40aef0:	17ffffcb 	b	40ae1c <native_add_command_line_opts>

000000000040aef4 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
  40aef4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40aef8:	910003fd 	mov	x29, sp
  40aefc:	a90153f3 	stp	x19, x20, [sp, #16]
  40af00:	aa0103f4 	mov	x20, x1
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
  40af04:	d2800033 	mov	x19, #0x1                   	// #1
{
  40af08:	a9025bf5 	stp	x21, x22, [sp, #32]
  40af0c:	2a0003f5 	mov	w21, w0
  40af10:	a90363f7 	stp	x23, x24, [sp, #48]
	cmd_args_set_defaults(args_struct);
  40af14:	d0000118 	adrp	x24, 42c000 <__dso_handle>
{
  40af18:	a9046bf9 	stp	x25, x26, [sp, #64]
	native_add_tracing_options();
  40af1c:	97fffd8b 	bl	40a548 <native_add_tracing_options>
	native_add_testargs_option();
  40af20:	97fffff2 	bl	40aee8 <native_add_testargs_option>
	s_argv = argv;
  40af24:	d0000100 	adrp	x0, 42c000 <__dso_handle>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40af28:	f0000059 	adrp	x25, 415000 <random_data+0xd8c>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40af2c:	f000005a 	adrp	x26, 415000 <random_data+0xd8c>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40af30:	911bb339 	add	x25, x25, #0x6ec
	s_argv = argv;
  40af34:	f907f014 	str	x20, [x0, #4064]
	s_argc = argc;
  40af38:	f0000100 	adrp	x0, 42d000 <counter_value>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40af3c:	911bd75a 	add	x26, x26, #0x6f5
	s_argc = argc;
  40af40:	b90f2c15 	str	w21, [x0, #3884]
	cmd_args_set_defaults(args_struct);
  40af44:	f947ef00 	ldr	x0, [x24, #4056]
  40af48:	97fffe8c 	bl	40a978 <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
  40af4c:	2a1303f6 	mov	w22, w19
  40af50:	6b1302bf 	cmp	w21, w19
  40af54:	540001cd 	b.le	40af8c <native_handle_cmd_line+0x98>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40af58:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  40af5c:	aa1903e1 	mov	x1, x25
  40af60:	52800002 	mov	w2, #0x0                   	// #0
  40af64:	91000677 	add	x23, x19, #0x1
  40af68:	97fffdbb 	bl	40a654 <cmd_is_option>
  40af6c:	340001c0 	cbz	w0, 40afa4 <native_handle_cmd_line+0xb0>
			test_argc = argc - i - 1;
  40af70:	f0000100 	adrp	x0, 42d000 <counter_value>
  40af74:	4b1602b6 	sub	w22, w21, w22
  40af78:	510006d6 	sub	w22, w22, #0x1
			test_argv = &argv[i+1];
  40af7c:	8b170e97 	add	x23, x20, x23, lsl #3
			test_argc = argc - i - 1;
  40af80:	b90f3016 	str	w22, [x0, #3888]
			test_argv = &argv[i+1];
  40af84:	d0000100 	adrp	x0, 42c000 <__dso_handle>
  40af88:	f907f417 	str	x23, [x0, #4072]
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
			cmd_print_switches_help(args_struct);
			print_invalid_opt_error(argv[i]);
		}
	}
}
  40af8c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40af90:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40af94:	a94363f7 	ldp	x23, x24, [sp, #48]
  40af98:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40af9c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40afa0:	d65f03c0 	ret
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
  40afa4:	f947ef01 	ldr	x1, [x24, #4056]
  40afa8:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  40afac:	97ffff5c 	bl	40ad1c <cmd_parse_one_arg>
  40afb0:	72001c1f 	tst	w0, #0xff
  40afb4:	540000c1 	b.ne	40afcc <native_handle_cmd_line+0xd8>  // b.any
			cmd_print_switches_help(args_struct);
  40afb8:	f947ef00 	ldr	x0, [x24, #4056]
  40afbc:	97fffea9 	bl	40aa60 <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40afc0:	f8737a81 	ldr	x1, [x20, x19, lsl #3]
  40afc4:	aa1a03e0 	mov	x0, x26
  40afc8:	97fffcc8 	bl	40a2e8 <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
  40afcc:	aa1703f3 	mov	x19, x23
  40afd0:	17ffffdf 	b	40af4c <native_handle_cmd_line+0x58>

000000000040afd4 <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
  40afd4:	b0000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40afd8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40afdc:	f947d021 	ldr	x1, [x1, #4000]
  40afe0:	f9000020 	str	x0, [x1]
	counter_target = NEVER;
  40afe4:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40afe8:	f907fc20 	str	x0, [x1, #4088]
	counter_value = 0;
  40afec:	f0000101 	adrp	x1, 42d000 <counter_value>
  40aff0:	f900003f 	str	xzr, [x1]
	counter_running = false;
  40aff4:	90000121 	adrp	x1, 42e000 <des_frames+0x27>
  40aff8:	390c143f 	strb	wzr, [x1, #773]
	counter_period = NEVER;
  40affc:	d0000101 	adrp	x1, 42c000 <__dso_handle>
  40b000:	f907f820 	str	x0, [x1, #4080]
}
  40b004:	d65f03c0 	ret

000000000040b008 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
  40b008:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!counter_running) {
  40b00c:	f0000100 	adrp	x0, 42e000 <des_frames+0x27>
{
  40b010:	910003fd 	mov	x29, sp
	if (!counter_running) {
  40b014:	394c1400 	ldrb	w0, [x0, #773]
{
  40b018:	f9000bf3 	str	x19, [sp, #16]
  40b01c:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
	if (!counter_running) {
  40b020:	350000e0 	cbnz	w0, 40b03c <hw_counter_triggered+0x34>
		hw_counter_timer = NEVER;
  40b024:	f947d273 	ldr	x19, [x19, #4000]
  40b028:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40b02c:	f9000260 	str	x0, [x19]
	counter_value = counter_value + 1;

	if (counter_value == counter_target) {
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
	}
}
  40b030:	f9400bf3 	ldr	x19, [sp, #16]
  40b034:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b038:	d65f03c0 	ret
	hw_counter_timer = hwm_get_time() + counter_period;
  40b03c:	97fff9e7 	bl	4097d8 <hwm_get_time>
  40b040:	b0000101 	adrp	x1, 42c000 <__dso_handle>
  40b044:	f947d273 	ldr	x19, [x19, #4000]
  40b048:	f947f821 	ldr	x1, [x1, #4080]
  40b04c:	8b000021 	add	x1, x1, x0
  40b050:	f9000261 	str	x1, [x19]
	counter_value = counter_value + 1;
  40b054:	d0000101 	adrp	x1, 42d000 <counter_value>
  40b058:	f9400020 	ldr	x0, [x1]
  40b05c:	91000400 	add	x0, x0, #0x1
  40b060:	f9000020 	str	x0, [x1]
	if (counter_value == counter_target) {
  40b064:	b0000101 	adrp	x1, 42c000 <__dso_handle>
  40b068:	f947fc21 	ldr	x1, [x1, #4088]
  40b06c:	eb01001f 	cmp	x0, x1
  40b070:	54fffe01 	b.ne	40b030 <hw_counter_triggered+0x28>  // b.any
}
  40b074:	f9400bf3 	ldr	x19, [sp, #16]
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  40b078:	52800040 	mov	w0, #0x2                   	// #2
}
  40b07c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  40b080:	17fffc18 	b	40a0e0 <hw_irq_ctrl_set_irq>

000000000040b084 <receive_pool_free>:

/*
 * Wake every context that is waiting for a buffer
 */
static void receive_pool_free(struct net_buf *buf)
{
  40b084:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b088:	910003fd 	mov	x29, sp
  40b08c:	f9000bf3 	str	x19, [sp, #16]
  40b090:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b094:	39404800 	ldrb	w0, [x0, #18]
  40b098:	94000425 	bl	40c12c <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40b09c:	aa1303e1 	mov	x1, x19
  40b0a0:	940010ea 	bl	40f448 <k_queue_prepend>
	return list->head;
  40b0a4:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b0a8:	f9400813 	ldr	x19, [x0, #16]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.alloc_list, ctx_node) {
  40b0ac:	b5000093 	cbnz	x19, 40b0bc <receive_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  40b0b0:	f9400bf3 	ldr	x19, [sp, #16]
  40b0b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b0b8:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  40b0bc:	91004260 	add	x0, x19, #0x10
  40b0c0:	940013d0 	bl	410000 <k_work_submit>
	return node->next;
  40b0c4:	f9400273 	ldr	x19, [x19]
  40b0c8:	17fffff9 	b	40b0ac <receive_pool_free+0x28>

000000000040b0cc <receive_ff_sf_pool_free>:

static void receive_ff_sf_pool_free(struct net_buf *buf)
{
  40b0cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b0d0:	910003fd 	mov	x29, sp
  40b0d4:	f9000bf3 	str	x19, [sp, #16]
  40b0d8:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b0dc:	39404800 	ldrb	w0, [x0, #18]
  40b0e0:	94000413 	bl	40c12c <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40b0e4:	aa1303e1 	mov	x1, x19
  40b0e8:	940010d8 	bl	40f448 <k_queue_prepend>
	return list->head;
  40b0ec:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b0f0:	f9401013 	ldr	x19, [x0, #32]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.ff_sf_alloc_list, ctx_node) {
  40b0f4:	b5000093 	cbnz	x19, 40b104 <receive_ff_sf_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  40b0f8:	f9400bf3 	ldr	x19, [sp, #16]
  40b0fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b100:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  40b104:	91004260 	add	x0, x19, #0x10
  40b108:	940013be 	bl	410000 <k_work_submit>
	return node->next;
  40b10c:	f9400273 	ldr	x19, [x19]
  40b110:	17fffff9 	b	40b0f4 <receive_ff_sf_pool_free+0x28>

000000000040b114 <TC_RESULT_TO_STR>:
#define TC_SKIP_STR "SKIP"
#endif

static inline const char *TC_RESULT_TO_STR(int result)
{
	switch (result) {
  40b114:	7100041f 	cmp	w0, #0x1
  40b118:	54000140 	b.eq	40b140 <TC_RESULT_TO_STR+0x2c>  // b.none
  40b11c:	7100081f 	cmp	w0, #0x2
  40b120:	54000160 	b.eq	40b14c <TC_RESULT_TO_STR+0x38>  // b.none
	case TC_PASS:
		return TC_PASS_STR;
  40b124:	7100001f 	cmp	w0, #0x0
  40b128:	d0000042 	adrp	x2, 415000 <random_data+0xd8c>
  40b12c:	d0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40b130:	911edc42 	add	x2, x2, #0x7b7
  40b134:	9115e820 	add	x0, x1, #0x57a
  40b138:	9a821000 	csel	x0, x0, x2, ne  // ne = any
	case TC_SKIP:
		return TC_SKIP_STR;
	default:
		return "?";
	}
}
  40b13c:	d65f03c0 	ret
	switch (result) {
  40b140:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b144:	911ef000 	add	x0, x0, #0x7bc
  40b148:	17fffffd 	b	40b13c <TC_RESULT_TO_STR+0x28>
		return TC_SKIP_STR;
  40b14c:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b150:	911f0400 	add	x0, x0, #0x7c1
  40b154:	17fffffa 	b	40b13c <TC_RESULT_TO_STR+0x28>

000000000040b158 <get_friendly_phase_name>:
 * @param phase an enum ztest_phase value describing the desired test phase
 * @returns a string name for `phase`
 */
static inline const char *get_friendly_phase_name(enum ztest_phase phase)
{
	switch (phase) {
  40b158:	7100141f 	cmp	w0, #0x5
  40b15c:	540002c8 	b.hi	40b1b4 <get_friendly_phase_name+0x5c>  // b.pmore
  40b160:	90000041 	adrp	x1, 413000 <z_timer_expiration_handler+0x68>
  40b164:	91176021 	add	x1, x1, #0x5d8
  40b168:	38604821 	ldrb	w1, [x1, w0, uxtw]
  40b16c:	10000060 	adr	x0, 40b178 <get_friendly_phase_name+0x20>
  40b170:	8b218801 	add	x1, x0, w1, sxtb #2
  40b174:	d61f0020 	br	x1
  40b178:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b17c:	911f3000 	add	x0, x0, #0x7cc
	case TEST_PHASE_FRAMEWORK:
		return "framework";
	default:
		return "(unknown)";
	}
}
  40b180:	d65f03c0 	ret
		return "test";
  40b184:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b188:	912bc000 	add	x0, x0, #0xaf0
  40b18c:	17fffffd 	b	40b180 <get_friendly_phase_name+0x28>
		return "after";
  40b190:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b194:	911f4c00 	add	x0, x0, #0x7d3
  40b198:	17fffffa 	b	40b180 <get_friendly_phase_name+0x28>
		return "teardown";
  40b19c:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b1a0:	911f6400 	add	x0, x0, #0x7d9
  40b1a4:	17fffff7 	b	40b180 <get_friendly_phase_name+0x28>
		return "framework";
  40b1a8:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b1ac:	911f8800 	add	x0, x0, #0x7e2
  40b1b0:	17fffff4 	b	40b180 <get_friendly_phase_name+0x28>
		return "(unknown)";
  40b1b4:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b1b8:	911fb000 	add	x0, x0, #0x7ec
  40b1bc:	17fffff1 	b	40b180 <get_friendly_phase_name+0x28>
		return "setup";
  40b1c0:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b1c4:	911f1800 	add	x0, x0, #0x7c6
  40b1c8:	17ffffee 	b	40b180 <get_friendly_phase_name+0x28>

000000000040b1cc <ztest_find_test_suite>:
}

#endif /* !KERNEL */

static struct ztest_suite_node *ztest_find_test_suite(const char *name)
{
  40b1cc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40b1d0:	910003fd 	mov	x29, sp
  40b1d4:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_suite_node *node;

	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b1d8:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  40b1dc:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  40b1e0:	f9471e73 	ldr	x19, [x19, #3640]
{
  40b1e4:	f90013f5 	str	x21, [sp, #32]
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b1e8:	f9473a94 	ldr	x20, [x20, #3696]
{
  40b1ec:	aa0003f5 	mov	x21, x0
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b1f0:	eb14027f 	cmp	x19, x20
  40b1f4:	540000e3 	b.cc	40b210 <ztest_find_test_suite+0x44>  // b.lo, b.ul, b.last
		if (strcmp(name, node->name) == 0) {
			return node;
		}
	}

	return NULL;
  40b1f8:	d2800013 	mov	x19, #0x0                   	// #0
}
  40b1fc:	aa1303e0 	mov	x0, x19
  40b200:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b204:	f94013f5 	ldr	x21, [sp, #32]
  40b208:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b20c:	d65f03c0 	ret
		if (strcmp(name, node->name) == 0) {
  40b210:	f9400261 	ldr	x1, [x19]
  40b214:	aa1503e0 	mov	x0, x21
  40b218:	97ffd862 	bl	4013a0 <strcmp@plt>
  40b21c:	34ffff00 	cbz	w0, 40b1fc <ztest_find_test_suite+0x30>
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40b220:	9100e273 	add	x19, x19, #0x38
  40b224:	17fffff3 	b	40b1f0 <ztest_find_test_suite+0x24>

000000000040b228 <flush_log>:
		test->stats->duration_worst_ms = 0;
	}
}

static void flush_log(void)
{
  40b228:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b22c:	910003fd 	mov	x29, sp
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke0(K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process();
  40b230:	97fff348 	bl	407f50 <z_impl_log_process>
		while (log_data_pending()) {
			k_sleep(K_MSEC(10));
		}
		k_sleep(K_MSEC(10));
	} else {
		while (LOG_PROCESS()) {
  40b234:	72001c1f 	tst	w0, #0xff
  40b238:	54ffffc1 	b.ne	40b230 <flush_log+0x8>  // b.any
		}
	}
}
  40b23c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b240:	d65f03c0 	ret

000000000040b244 <test_cb>:
{
  40b244:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40b248:	910003fd 	mov	x29, sp
  40b24c:	a90153f3 	stp	x19, x20, [sp, #16]
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40b250:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
{
  40b254:	aa0203f4 	mov	x20, x2
  40b258:	a90363f7 	stp	x23, x24, [sp, #48]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b25c:	90000117 	adrp	x23, 42b000 <__FRAME_END__+0x1007c>
	test_result = ZTEST_RESULT_PENDING;
  40b260:	d0000118 	adrp	x24, 42d000 <counter_value>
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40b264:	f9476e73 	ldr	x19, [x19, #3800]
{
  40b268:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b26c:	aa0003f6 	mov	x22, x0
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b270:	f947d6f7 	ldr	x23, [x23, #4008]
{
  40b274:	aa0103f5 	mov	x21, x1
	test_result = ZTEST_RESULT_PENDING;
  40b278:	b90f431f 	str	wzr, [x24, #3904]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b27c:	eb17027f 	cmp	x19, x23
  40b280:	54000263 	b.cc	40b2cc <test_cb+0x88>  // b.lo, b.ul, b.last
	if (suite->before) {
  40b284:	f9400ac1 	ldr	x1, [x22, #16]
  40b288:	b4000061 	cbz	x1, 40b294 <test_cb+0x50>
		suite->before(/*data=*/c);
  40b28c:	aa1403e0 	mov	x0, x20
  40b290:	d63f0020 	blr	x1
	phase = TEST_PHASE_TEST;
  40b294:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40b298:	52800042 	mov	w2, #0x2                   	// #2
  40b29c:	f9400aa1 	ldr	x1, [x21, #16]
  40b2a0:	f947cc00 	ldr	x0, [x0, #3992]
  40b2a4:	b9000002 	str	w2, [x0]
	test->test(data);
  40b2a8:	aa1403e0 	mov	x0, x20
  40b2ac:	d63f0020 	blr	x1
	test_result = ZTEST_RESULT_PASS;
  40b2b0:	52800020 	mov	w0, #0x1                   	// #1
  40b2b4:	b90f4300 	str	w0, [x24, #3904]
}
  40b2b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b2bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b2c0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b2c4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40b2c8:	d65f03c0 	ret
		if (is_before && rule->before_each) {
  40b2cc:	f9400262 	ldr	x2, [x19]
  40b2d0:	b4000082 	cbz	x2, 40b2e0 <test_cb+0x9c>
			rule->before_each(test, data);
  40b2d4:	aa1403e1 	mov	x1, x20
  40b2d8:	aa1503e0 	mov	x0, x21
  40b2dc:	d63f0040 	blr	x2
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b2e0:	91004273 	add	x19, x19, #0x10
  40b2e4:	17ffffe6 	b	40b27c <test_cb+0x38>

000000000040b2e8 <test_finalize>:
{
  40b2e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b2ec:	910003fd 	mov	x29, sp
	z_impl_k_thread_abort(thread);
  40b2f0:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b2f4:	9100c000 	add	x0, x0, #0x30
  40b2f8:	97fff793 	bl	409144 <z_impl_k_thread_abort>
	return z_impl_z_current_get();
  40b2fc:	94001b96 	bl	412154 <z_impl_z_current_get>
}
  40b300:	a8c17bfd 	ldp	x29, x30, [sp], #16
	z_impl_k_thread_abort(thread);
  40b304:	17fff790 	b	409144 <z_impl_k_thread_abort>

000000000040b308 <ztest_test_fail>:
	switch (phase) {
  40b308:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40b30c:	f947cc00 	ldr	x0, [x0, #3992]
  40b310:	b9400000 	ldr	w0, [x0]
  40b314:	34000200 	cbz	w0, 40b354 <ztest_test_fail+0x4c>
  40b318:	51000401 	sub	w1, w0, #0x1
  40b31c:	7100043f 	cmp	w1, #0x1
  40b320:	54000229 	b.ls	40b364 <ztest_test_fail+0x5c>  // b.plast
{
  40b324:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b328:	910003fd 	mov	x29, sp
		PRINT(" ERROR: cannot fail in test phase '%s()', bailing\n",
  40b32c:	97ffff8b 	bl	40b158 <get_friendly_phase_name>
  40b330:	aa0003e1 	mov	x1, x0
  40b334:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b338:	911fd800 	add	x0, x0, #0x7f6
  40b33c:	97ffec12 	bl	406384 <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b340:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b344:	52800041 	mov	w1, #0x2                   	// #2
}
  40b348:	a8c17bfd 	ldp	x29, x30, [sp], #16
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b34c:	b90f4401 	str	w1, [x0, #3908]
}
  40b350:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SUITE_FAIL;
  40b354:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b358:	528000a1 	mov	w1, #0x5                   	// #5
  40b35c:	b90f4001 	str	w1, [x0, #3904]
		break;
  40b360:	d65f03c0 	ret
		test_result = ZTEST_RESULT_FAIL;
  40b364:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b368:	52800041 	mov	w1, #0x2                   	// #2
  40b36c:	b90f4001 	str	w1, [x0, #3904]
		test_finalize();
  40b370:	17ffffde 	b	40b2e8 <test_finalize>

000000000040b374 <ztest_test_skip>:
	switch (phase) {
  40b374:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40b378:	f947cc00 	ldr	x0, [x0, #3992]
  40b37c:	b9400000 	ldr	w0, [x0]
  40b380:	34000200 	cbz	w0, 40b3c0 <ztest_test_skip+0x4c>
  40b384:	51000401 	sub	w1, w0, #0x1
  40b388:	7100043f 	cmp	w1, #0x1
  40b38c:	54000229 	b.ls	40b3d0 <ztest_test_skip+0x5c>  // b.plast
{
  40b390:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b394:	910003fd 	mov	x29, sp
		PRINT(" ERROR: cannot skip in test phase '%s()', bailing\n",
  40b398:	97ffff70 	bl	40b158 <get_friendly_phase_name>
  40b39c:	aa0003e1 	mov	x1, x0
  40b3a0:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b3a4:	9120a400 	add	x0, x0, #0x829
  40b3a8:	97ffebf7 	bl	406384 <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b3ac:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b3b0:	52800041 	mov	w1, #0x2                   	// #2
}
  40b3b4:	a8c17bfd 	ldp	x29, x30, [sp], #16
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b3b8:	b90f4401 	str	w1, [x0, #3908]
}
  40b3bc:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SUITE_SKIP;
  40b3c0:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b3c4:	52800081 	mov	w1, #0x4                   	// #4
  40b3c8:	b90f4001 	str	w1, [x0, #3904]
		break;
  40b3cc:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SKIP;
  40b3d0:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b3d4:	52800061 	mov	w1, #0x3                   	// #3
  40b3d8:	b90f4001 	str	w1, [x0, #3904]
		test_finalize();
  40b3dc:	17ffffc3 	b	40b2e8 <test_finalize>

000000000040b3e0 <z_ztest_get_next_test>:
{
  40b3e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b3e4:	f100003f 	cmp	x1, #0x0
{
  40b3e8:	910003fd 	mov	x29, sp
  40b3ec:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b3f0:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b3f4:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b3f8:	f946ea73 	ldr	x19, [x19, #3536]
{
  40b3fc:	f90013f5 	str	x21, [sp, #32]
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b400:	f9473e94 	ldr	x20, [x20, #3704]
{
  40b404:	aa0003f5 	mov	x21, x0
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40b408:	9100a020 	add	x0, x1, #0x28
  40b40c:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b410:	eb14027f 	cmp	x19, x20
  40b414:	540000e3 	b.cc	40b430 <z_ztest_get_next_test+0x50>  // b.lo, b.ul, b.last
	return NULL;
  40b418:	d2800013 	mov	x19, #0x0                   	// #0
}
  40b41c:	aa1303e0 	mov	x0, x19
  40b420:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b424:	f94013f5 	ldr	x21, [sp, #32]
  40b428:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b42c:	d65f03c0 	ret
		if (strcmp(suite, test->test_suite_name) == 0) {
  40b430:	f9400261 	ldr	x1, [x19]
  40b434:	aa1503e0 	mov	x0, x21
  40b438:	97ffd7da 	bl	4013a0 <strcmp@plt>
  40b43c:	34ffff00 	cbz	w0, 40b41c <z_ztest_get_next_test+0x3c>
	for (; test < _ztest_unit_test_list_end; ++test) {
  40b440:	9100a273 	add	x19, x19, #0x28
  40b444:	17fffff3 	b	40b410 <z_ztest_get_next_test+0x30>

000000000040b448 <z_ztest_run_test_suite_ptr>:
{
  40b448:	d10203ff 	sub	sp, sp, #0x80
  40b44c:	a9017bfd 	stp	x29, x30, [sp, #16]
  40b450:	910043fd 	add	x29, sp, #0x10
  40b454:	a90253f3 	stp	x19, x20, [sp, #32]
  40b458:	a9035bf5 	stp	x21, x22, [sp, #48]
  40b45c:	a90463f7 	stp	x23, x24, [sp, #64]
  40b460:	a9056bf9 	stp	x25, x26, [sp, #80]
  40b464:	a90673fb 	stp	x27, x28, [sp, #96]
	if (suite == NULL) {
  40b468:	b50001c0 	cbnz	x0, 40b4a0 <z_ztest_run_test_suite_ptr+0x58>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b46c:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b470:	52800041 	mov	w1, #0x2                   	// #2
		return -1;
  40b474:	12800016 	mov	w22, #0xffffffff            	// #-1
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40b478:	b90f4401 	str	w1, [x0, #3908]
}
  40b47c:	2a1603e0 	mov	w0, w22
  40b480:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40b484:	a94253f3 	ldp	x19, x20, [sp, #32]
  40b488:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40b48c:	a94463f7 	ldp	x23, x24, [sp, #64]
  40b490:	a9456bf9 	ldp	x25, x26, [sp, #80]
  40b494:	a94673fb 	ldp	x27, x28, [sp, #96]
  40b498:	910203ff 	add	sp, sp, #0x80
  40b49c:	d65f03c0 	ret
  40b4a0:	aa0003f4 	mov	x20, x0
	TC_SUITE_START(suite->name);
  40b4a4:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b4a8:	91217000 	add	x0, x0, #0x85c
	phase = TEST_PHASE_SETUP;
  40b4ac:	90000115 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
	test_result = ZTEST_RESULT_PENDING;
  40b4b0:	d0000118 	adrp	x24, 42d000 <counter_value>
	TC_SUITE_START(suite->name);
  40b4b4:	f9400281 	ldr	x1, [x20]
  40b4b8:	97ffebb3 	bl	406384 <printk>
  40b4bc:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b4c0:	9121c800 	add	x0, x0, #0x872
  40b4c4:	97ffebb0 	bl	406384 <printk>
	test_result = ZTEST_RESULT_PENDING;
  40b4c8:	b90f431f 	str	wzr, [x24, #3904]
	current_test_failed_assumption = false;
  40b4cc:	f0000100 	adrp	x0, 42e000 <des_frames+0x27>
  40b4d0:	390c181f 	strb	wzr, [x0, #774]
	phase = TEST_PHASE_SETUP;
  40b4d4:	f947cea0 	ldr	x0, [x21, #3992]
  40b4d8:	b900001f 	str	wzr, [x0]
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
  40b4dc:	f9400680 	ldr	x0, [x20, #8]
  40b4e0:	b4000340 	cbz	x0, 40b548 <z_ztest_run_test_suite_ptr+0x100>
		data = suite->setup();
  40b4e4:	d63f0000 	blr	x0
  40b4e8:	aa0003f7 	mov	x23, x0
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b4ec:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
		fail = 0;
  40b4f0:	52800016 	mov	w22, #0x0                   	// #0
	struct ztest_unit_test *test = NULL;
  40b4f4:	d2800013 	mov	x19, #0x0                   	// #0
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b4f8:	f9479400 	ldr	x0, [x0, #3880]
  40b4fc:	f9003fe0 	str	x0, [sp, #120]
	tc_start_time = k_cycle_get_32();
}

static inline void get_test_duration_ms(void)
{
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40b500:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b504:	913cf01c 	add	x28, x0, #0xf3c
		while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40b508:	f9400280 	ldr	x0, [x20]
  40b50c:	aa1303e1 	mov	x1, x19
  40b510:	97ffffb4 	bl	40b3e0 <z_ztest_get_next_test>
  40b514:	aa0003f3 	mov	x19, x0
  40b518:	b50001c0 	cbnz	x0, 40b550 <z_ztest_run_test_suite_ptr+0x108>
		if (test_status == ZTEST_STATUS_OK && fail != 0) {
  40b51c:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b520:	b94f4401 	ldr	w1, [x0, #3908]
  40b524:	35001741 	cbnz	w1, 40b80c <z_ztest_run_test_suite_ptr+0x3c4>
  40b528:	34001756 	cbz	w22, 40b810 <z_ztest_run_test_suite_ptr+0x3c8>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  40b52c:	52800021 	mov	w1, #0x1                   	// #1
  40b530:	b90f4401 	str	w1, [x0, #3908]
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  40b534:	f9400281 	ldr	x1, [x20]
  40b538:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b53c:	9123e000 	add	x0, x0, #0x8f8
  40b540:	97ffeb91 	bl	406384 <printk>
  40b544:	140000b8 	b	40b824 <z_ztest_run_test_suite_ptr+0x3dc>
	void *data = NULL;
  40b548:	d2800017 	mov	x23, #0x0                   	// #0
  40b54c:	17ffffe8 	b	40b4ec <z_ztest_run_test_suite_ptr+0xa4>
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40b550:	f9403fe0 	ldr	x0, [sp, #120]
  40b554:	f9400661 	ldr	x1, [x19, #8]
  40b558:	f9400802 	ldr	x2, [x0, #16]
  40b55c:	f9400280 	ldr	x0, [x20]
  40b560:	d63f0040 	blr	x2
  40b564:	72001c1f 	tst	w0, #0xff
  40b568:	540014a0 	b.eq	40b7fc <z_ztest_run_test_suite_ptr+0x3b4>  // b.none
				test->stats->run_count++;
  40b56c:	f9401261 	ldr	x1, [x19, #32]
  40b570:	b9400020 	ldr	w0, [x1]
  40b574:	11000400 	add	w0, w0, #0x1
  40b578:	b9000020 	str	w0, [x1]
	TC_START(test->name);
  40b57c:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b580:	9122dc00 	add	x0, x0, #0x8b7
  40b584:	f9400661 	ldr	x1, [x19, #8]
  40b588:	97ffeb7f 	bl	406384 <printk>
	phase = TEST_PHASE_BEFORE;
  40b58c:	f947cea0 	ldr	x0, [x21, #3992]
  40b590:	52800021 	mov	w1, #0x1                   	// #1
  40b594:	b9000001 	str	w1, [x0]
	return sys_clock_cycle_get_32();
  40b598:	94000786 	bl	40d3b0 <sys_clock_cycle_get_32>
	tc_start_time = k_cycle_get_32();
  40b59c:	d0000101 	adrp	x1, 42d000 <counter_value>
  40b5a0:	92800007 	mov	x7, #0xffffffffffffffff    	// #-1
  40b5a4:	b90f3c20 	str	w0, [x1, #3900]
		k_thread_create(&ztest_thread, ztest_thread_stack,
  40b5a8:	b9401a60 	ldr	w0, [x19, #24]
  40b5ac:	321d0000 	orr	w0, w0, #0x8
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40b5b0:	90000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40b5b4:	b90003e0 	str	w0, [sp]
  40b5b8:	f90007e7 	str	x7, [sp, #8]
  40b5bc:	d0000119 	adrp	x25, 42d000 <counter_value>
  40b5c0:	f947ec21 	ldr	x1, [x1, #4056]
  40b5c4:	9100c33b 	add	x27, x25, #0x30
  40b5c8:	aa1703e6 	mov	x6, x23
  40b5cc:	aa1303e5 	mov	x5, x19
  40b5d0:	aa1403e4 	mov	x4, x20
  40b5d4:	aa1b03e0 	mov	x0, x27
  40b5d8:	d2808002 	mov	x2, #0x400                 	// #1024
  40b5dc:	90000003 	adrp	x3, 40b000 <hw_counter_init+0x2c>
  40b5e0:	91091063 	add	x3, x3, #0x244
  40b5e4:	94000b57 	bl	40e340 <z_impl_k_thread_create>
		if (test->name != NULL) {
  40b5e8:	f9400661 	ldr	x1, [x19, #8]
  40b5ec:	b4000061 	cbz	x1, 40b5f8 <z_ztest_run_test_suite_ptr+0x1b0>
	return z_impl_k_thread_name_set(thread, str);
  40b5f0:	aa1b03e0 	mov	x0, x27
  40b5f4:	94000ade 	bl	40e16c <z_impl_k_thread_name_set>
		if (test_result != ZTEST_RESULT_SUITE_SKIP &&
  40b5f8:	b94f4300 	ldr	w0, [x24, #3904]
  40b5fc:	51001000 	sub	w0, w0, #0x4
  40b600:	7100041f 	cmp	w0, #0x1
  40b604:	540000e9 	b.ls	40b620 <z_ztest_run_test_suite_ptr+0x1d8>  // b.plast
	z_impl_k_thread_start(thread);
  40b608:	9100c33b 	add	x27, x25, #0x30
  40b60c:	aa1b03e0 	mov	x0, x27
  40b610:	94000aea 	bl	40e1b8 <z_impl_k_thread_start>
	return z_impl_k_thread_join(thread, timeout);
  40b614:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40b618:	aa1b03e0 	mov	x0, x27
  40b61c:	94001b88 	bl	41243c <z_impl_k_thread_join>
	phase = TEST_PHASE_AFTER;
  40b620:	f947cea0 	ldr	x0, [x21, #3992]
  40b624:	52800061 	mov	w1, #0x3                   	// #3
  40b628:	b9000001 	str	w1, [x0]
	if (suite->after != NULL) {
  40b62c:	f9400e81 	ldr	x1, [x20, #24]
  40b630:	b4000061 	cbz	x1, 40b63c <z_ztest_run_test_suite_ptr+0x1f4>
		suite->after(data);
  40b634:	aa1703e0 	mov	x0, x23
  40b638:	d63f0020 	blr	x1
	void *data = NULL;
  40b63c:	9000011b 	adrp	x27, 42b000 <__FRAME_END__+0x1007c>
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b640:	90000102 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
	void *data = NULL;
  40b644:	f9476f7b 	ldr	x27, [x27, #3800]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b648:	f947d45a 	ldr	x26, [x2, #4008]
  40b64c:	14000007 	b	40b668 <z_ztest_run_test_suite_ptr+0x220>
		} else if (!is_before && rule->after_each) {
  40b650:	f9400763 	ldr	x3, [x27, #8]
  40b654:	b4000083 	cbz	x3, 40b664 <z_ztest_run_test_suite_ptr+0x21c>
			rule->after_each(test, data);
  40b658:	aa1703e1 	mov	x1, x23
  40b65c:	aa1303e0 	mov	x0, x19
  40b660:	d63f0060 	blr	x3
	     rule < _ztest_test_rule_list_end; ++rule) {
  40b664:	9100437b 	add	x27, x27, #0x10
  40b668:	eb1a037f 	cmp	x27, x26
  40b66c:	54ffff23 	b.cc	40b650 <z_ztest_run_test_suite_ptr+0x208>  // b.lo, b.ul, b.last
  40b670:	94000750 	bl	40d3b0 <sys_clock_cycle_get_32>
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40b674:	b9400382 	ldr	w2, [x28]
  40b678:	4b020001 	sub	w1, w0, w2
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_cyc_to_ms_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
  40b67c:	4b020000 	sub	w0, w0, w2
		t += off;
  40b680:	910f9c00 	add	x0, x0, #0x3e7
		if (result32 && (t < BIT64(32))) {
  40b684:	b2407fe2 	mov	x2, #0xffffffff            	// #4294967295
  40b688:	eb02001f 	cmp	x0, x2
  40b68c:	540007c8 	b.hi	40b784 <z_ztest_run_test_suite_ptr+0x33c>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
  40b690:	110f9c21 	add	w1, w1, #0x3e7
  40b694:	52807d00 	mov	w0, #0x3e8                 	// #1000
  40b698:	1ac00820 	udiv	w0, w1, w0

	tc_spend_time = k_cyc_to_ms_ceil32(spend_cycle);
  40b69c:	d0000101 	adrp	x1, 42d000 <counter_value>
  40b6a0:	b90f3820 	str	w0, [x1, #3896]
	if (tc_spend_time > test->stats->duration_worst_ms) {
  40b6a4:	f9401261 	ldr	x1, [x19, #32]
  40b6a8:	b9401022 	ldr	w2, [x1, #16]
  40b6ac:	6b00005f 	cmp	w2, w0
  40b6b0:	54000042 	b.cs	40b6b8 <z_ztest_run_test_suite_ptr+0x270>  // b.hs, b.nlast
		test->stats->duration_worst_ms = tc_spend_time;
  40b6b4:	b9001020 	str	w0, [x1, #16]
	phase = TEST_PHASE_FRAMEWORK;
  40b6b8:	f947cea0 	ldr	x0, [x21, #3992]
  40b6bc:	528000a1 	mov	w1, #0x5                   	// #5
  40b6c0:	b9000001 	str	w1, [x0]
	if (test_result == ZTEST_RESULT_FAIL || test_result == ZTEST_RESULT_SUITE_FAIL ||
  40b6c4:	b94f4300 	ldr	w0, [x24, #3904]
  40b6c8:	7100081f 	cmp	w0, #0x2
  40b6cc:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40b6d0:	f0000101 	adrp	x1, 42e000 <des_frames+0x27>
  40b6d4:	54000060 	b.eq	40b6e0 <z_ztest_run_test_suite_ptr+0x298>  // b.none
  40b6d8:	394c1c22 	ldrb	w2, [x1, #775]
  40b6dc:	340005a2 	cbz	w2, 40b790 <z_ztest_run_test_suite_ptr+0x348>
		failed_expectation = false;
  40b6e0:	390c1c3f 	strb	wzr, [x1, #775]
		ret = TC_FAIL;
  40b6e4:	5280003a 	mov	w26, #0x1                   	// #1
	z_impl_k_thread_abort(thread);
  40b6e8:	9100c320 	add	x0, x25, #0x30
  40b6ec:	97fff696 	bl	409144 <z_impl_k_thread_abort>
	for (struct ztest_expected_result_entry *expectation =
  40b6f0:	90000102 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40b6f4:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40b6f8:	f9400679 	ldr	x25, [x19, #8]
	for (struct ztest_expected_result_entry *expectation =
  40b6fc:	f947745b 	ldr	x27, [x2, #3816]
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40b700:	f9478000 	ldr	x0, [x0, #3840]
  40b704:	f9003be0 	str	x0, [sp, #112]
  40b708:	f9403be0 	ldr	x0, [sp, #112]
  40b70c:	eb00037f 	cmp	x27, x0
  40b710:	540004a3 	b.cc	40b7a4 <z_ztest_run_test_suite_ptr+0x35c>  // b.lo, b.ul, b.last
	Z_TC_END_RESULT(ret, test->name);
  40b714:	2a1a03e0 	mov	w0, w26
  40b718:	97fffe7f 	bl	40b114 <TC_RESULT_TO_STR>
  40b71c:	d0000101 	adrp	x1, 42d000 <counter_value>
  40b720:	52807d02 	mov	w2, #0x3e8                 	// #1000
  40b724:	b94f3824 	ldr	w4, [x1, #3896]
  40b728:	aa0003e1 	mov	x1, x0
  40b72c:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b730:	91230c00 	add	x0, x0, #0x8c3
  40b734:	1ac20883 	udiv	w3, w4, w2
  40b738:	1b029064 	msub	w4, w3, w2, w4
  40b73c:	aa1903e2 	mov	x2, x25
  40b740:	97ffeb11 	bl	406384 <printk>
  40b744:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b748:	9121c800 	add	x0, x0, #0x872
  40b74c:	97ffeb0e 	bl	406384 <printk>
	if (ret == TC_SKIP && current_test_failed_assumption) {
  40b750:	71000b5f 	cmp	w26, #0x2
  40b754:	f9401260 	ldr	x0, [x19, #32]
  40b758:	54000761 	b.ne	40b844 <z_ztest_run_test_suite_ptr+0x3fc>  // b.any
  40b75c:	f0000101 	adrp	x1, 42e000 <des_frames+0x27>
  40b760:	394c1821 	ldrb	w1, [x1, #774]
  40b764:	34000081 	cbz	w1, 40b774 <z_ztest_run_test_suite_ptr+0x32c>
		test_status = 1;
  40b768:	d0000101 	adrp	x1, 42d000 <counter_value>
  40b76c:	52800022 	mov	w2, #0x1                   	// #1
  40b770:	b90f4422 	str	w2, [x1, #3908]
					test->stats->skip_count++;
  40b774:	b9400401 	ldr	w1, [x0, #4]
  40b778:	11000421 	add	w1, w1, #0x1
  40b77c:	b9000401 	str	w1, [x0, #4]
				if (tc_result == TC_FAIL) {
  40b780:	1400001f 	b	40b7fc <z_ztest_run_test_suite_ptr+0x3b4>
			return t / ((uint64_t)from_hz / to_hz);
  40b784:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  40b788:	9ac10800 	udiv	x0, x0, x1
  40b78c:	17ffffc4 	b	40b69c <z_ztest_run_test_suite_ptr+0x254>
	} else if (test_result == ZTEST_RESULT_SKIP || test_result == ZTEST_RESULT_SUITE_SKIP) {
  40b790:	51000c00 	sub	w0, w0, #0x3
  40b794:	7100041f 	cmp	w0, #0x1
  40b798:	1a9f87e5 	cset	w5, ls  // ls = plast
  40b79c:	531f78ba 	lsl	w26, w5, #1
  40b7a0:	17ffffd2 	b	40b6e8 <z_ztest_run_test_suite_ptr+0x2a0>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40b7a4:	f9400760 	ldr	x0, [x27, #8]
  40b7a8:	aa1903e1 	mov	x1, x25
  40b7ac:	97ffd6fd 	bl	4013a0 <strcmp@plt>
  40b7b0:	35000160 	cbnz	w0, 40b7dc <z_ztest_run_test_suite_ptr+0x394>
		    strcmp(expectation->test_suite_name, test->test_suite_name) == 0) {
  40b7b4:	f9400261 	ldr	x1, [x19]
  40b7b8:	f9400360 	ldr	x0, [x27]
  40b7bc:	97ffd6f9 	bl	4013a0 <strcmp@plt>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40b7c0:	350000e0 	cbnz	w0, 40b7dc <z_ztest_run_test_suite_ptr+0x394>
			expected_result = expectation->expected_result;
  40b7c4:	b9401360 	ldr	w0, [x27, #16]
	if (expected_result == ZTEST_EXPECTED_RESULT_FAIL) {
  40b7c8:	340000e0 	cbz	w0, 40b7e4 <z_ztest_run_test_suite_ptr+0x39c>
	if (expected_result == ZTEST_EXPECTED_RESULT_SKIP) {
  40b7cc:	7100041f 	cmp	w0, #0x1
  40b7d0:	54fffa21 	b.ne	40b714 <z_ztest_run_test_suite_ptr+0x2cc>  // b.any
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  40b7d4:	71000b5f 	cmp	w26, #0x2
  40b7d8:	14000004 	b	40b7e8 <z_ztest_run_test_suite_ptr+0x3a0>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40b7dc:	9100637b 	add	x27, x27, #0x18
  40b7e0:	17ffffca 	b	40b708 <z_ztest_run_test_suite_ptr+0x2c0>
		return (ret == TC_FAIL) ? TC_PASS : TC_FAIL;
  40b7e4:	7100075f 	cmp	w26, #0x1
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  40b7e8:	1a9f07fa 	cset	w26, ne  // ne = any
  40b7ec:	17ffffca 	b	40b714 <z_ztest_run_test_suite_ptr+0x2cc>
					test->stats->pass_count++;
  40b7f0:	b9400c01 	ldr	w1, [x0, #12]
  40b7f4:	11000421 	add	w1, w1, #0x1
  40b7f8:	b9000c01 	str	w1, [x0, #12]
			if ((fail && FAIL_FAST) || test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40b7fc:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b800:	b94f4400 	ldr	w0, [x0, #3908]
  40b804:	7100081f 	cmp	w0, #0x2
  40b808:	54ffe801 	b.ne	40b508 <z_ztest_run_test_suite_ptr+0xc0>  // b.any
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  40b80c:	35ffe956 	cbnz	w22, 40b534 <z_ztest_run_test_suite_ptr+0xec>
  40b810:	f9400281 	ldr	x1, [x20]
  40b814:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40b818:	52800016 	mov	w22, #0x0                   	// #0
  40b81c:	91238000 	add	x0, x0, #0x8e0
  40b820:	97ffead9 	bl	406384 <printk>
	phase = TEST_PHASE_TEARDOWN;
  40b824:	f947ceb5 	ldr	x21, [x21, #3992]
  40b828:	52800080 	mov	w0, #0x4                   	// #4
	if (suite->teardown != NULL) {
  40b82c:	f9401281 	ldr	x1, [x20, #32]
	phase = TEST_PHASE_TEARDOWN;
  40b830:	b90002a0 	str	w0, [x21]
	if (suite->teardown != NULL) {
  40b834:	b4ffe241 	cbz	x1, 40b47c <z_ztest_run_test_suite_ptr+0x34>
		suite->teardown(data);
  40b838:	aa1703e0 	mov	x0, x23
  40b83c:	d63f0020 	blr	x1
  40b840:	17ffff0f 	b	40b47c <z_ztest_run_test_suite_ptr+0x34>
				if (tc_result == TC_PASS) {
  40b844:	34fffd7a 	cbz	w26, 40b7f0 <z_ztest_run_test_suite_ptr+0x3a8>
					test->stats->fail_count++;
  40b848:	b9400801 	ldr	w1, [x0, #8]
					fail++;
  40b84c:	110006d6 	add	w22, w22, #0x1
					test->stats->fail_count++;
  40b850:	11000421 	add	w1, w1, #0x1
  40b854:	b9000801 	str	w1, [x0, #8]
					fail++;
  40b858:	17ffffe9 	b	40b7fc <z_ztest_run_test_suite_ptr+0x3b4>

000000000040b85c <z_impl_ztest_run_test_suites>:

	return count;
}

int z_impl_ztest_run_test_suites(const void *state)
{
  40b85c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b860:	910003fd 	mov	x29, sp
  40b864:	f90023f9 	str	x25, [sp, #64]
	int count = 0;

	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40b868:	d0000119 	adrp	x25, 42d000 <counter_value>
{
  40b86c:	a90363f7 	stp	x23, x24, [sp, #48]
  40b870:	aa0003f7 	mov	x23, x0
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40b874:	b94f4720 	ldr	w0, [x25, #3908]
{
  40b878:	a90153f3 	stp	x19, x20, [sp, #16]
  40b87c:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40b880:	7100081f 	cmp	w0, #0x2
  40b884:	540007a0 	b.eq	40b978 <z_impl_ztest_run_test_suites+0x11c>  // b.none
		    (test_status == ZTEST_STATUS_HAS_FAILURE && FAIL_FAST)) {
			break;
		}
	}
#else
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40b888:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40b88c:	90000116 	adrp	x22, 42b000 <__FRAME_END__+0x1007c>
		if (ztest_api.should_suite_run(state, ptr)) {
  40b890:	90000118 	adrp	x24, 42b000 <__FRAME_END__+0x1007c>
	int count = 0;
  40b894:	52800015 	mov	w21, #0x0                   	// #0
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40b898:	f9471e73 	ldr	x19, [x19, #3640]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40b89c:	f9473ad6 	ldr	x22, [x22, #3696]
		if (ztest_api.should_suite_run(state, ptr)) {
  40b8a0:	f9479718 	ldr	x24, [x24, #3880]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40b8a4:	eb16027f 	cmp	x19, x22
  40b8a8:	54000103 	b.cc	40b8c8 <z_impl_ztest_run_test_suites+0x6c>  // b.lo, b.ul, b.last
		}
	}
#endif

	return count;
}
  40b8ac:	2a1503e0 	mov	w0, w21
  40b8b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b8b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b8b8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b8bc:	f94023f9 	ldr	x25, [sp, #64]
  40b8c0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40b8c4:	d65f03c0 	ret
		if (ztest_api.should_suite_run(state, ptr)) {
  40b8c8:	f9400702 	ldr	x2, [x24, #8]
  40b8cc:	aa1303e1 	mov	x1, x19
  40b8d0:	aa1703e0 	mov	x0, x23
	struct ztest_suite_stats *stats = ptr->stats;
  40b8d4:	f9401a74 	ldr	x20, [x19, #48]
		if (ztest_api.should_suite_run(state, ptr)) {
  40b8d8:	d63f0040 	blr	x2
  40b8dc:	72001c1f 	tst	w0, #0xff
  40b8e0:	54000420 	b.eq	40b964 <z_impl_ztest_run_test_suites+0x108>  // b.none
	struct ztest_unit_test *test = NULL;
  40b8e4:	d2800001 	mov	x1, #0x0                   	// #0
  40b8e8:	1400000b 	b	40b914 <z_impl_ztest_run_test_suites+0xb8>
		test->stats->run_count = 0;
  40b8ec:	f9401020 	ldr	x0, [x1, #32]
  40b8f0:	b900001f 	str	wzr, [x0]
		test->stats->skip_count = 0;
  40b8f4:	f9401020 	ldr	x0, [x1, #32]
  40b8f8:	b900041f 	str	wzr, [x0, #4]
		test->stats->fail_count = 0;
  40b8fc:	f9401020 	ldr	x0, [x1, #32]
  40b900:	b900081f 	str	wzr, [x0, #8]
		test->stats->pass_count = 0;
  40b904:	f9401020 	ldr	x0, [x1, #32]
  40b908:	b9000c1f 	str	wzr, [x0, #12]
		test->stats->duration_worst_ms = 0;
  40b90c:	f9401020 	ldr	x0, [x1, #32]
  40b910:	b900101f 	str	wzr, [x0, #16]
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40b914:	f9400260 	ldr	x0, [x19]
  40b918:	97fffeb2 	bl	40b3e0 <z_ztest_get_next_test>
  40b91c:	aa0003e1 	mov	x1, x0
  40b920:	b5fffe60 	cbnz	x0, 40b8ec <z_impl_ztest_run_test_suites+0x90>
			int fail = z_ztest_run_test_suite_ptr(ptr);
  40b924:	aa1303e0 	mov	x0, x19
  40b928:	97fffec8 	bl	40b448 <z_ztest_run_test_suite_ptr>
			stats->fail_count += (fail != 0) ? 1 : 0;
  40b92c:	7100001f 	cmp	w0, #0x0
  40b930:	b9400a80 	ldr	w0, [x20, #8]
			stats->run_count++;
  40b934:	b9400281 	ldr	w1, [x20]
			stats->fail_count += (fail != 0) ? 1 : 0;
  40b938:	1a800400 	cinc	w0, w0, ne  // ne = any
  40b93c:	b9000a80 	str	w0, [x20, #8]
			stats->run_count++;
  40b940:	11000421 	add	w1, w1, #0x1
			count++;
  40b944:	52800020 	mov	w0, #0x1                   	// #1
			stats->run_count++;
  40b948:	b9000281 	str	w1, [x20]
		count += __ztest_run_test_suite(ptr, state);
  40b94c:	0b0002b5 	add	w21, w21, w0
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
  40b950:	b94f4720 	ldr	w0, [x25, #3908]
  40b954:	7100081f 	cmp	w0, #0x2
  40b958:	54fffaa0 	b.eq	40b8ac <z_impl_ztest_run_test_suites+0x50>  // b.none
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40b95c:	9100e273 	add	x19, x19, #0x38
  40b960:	17ffffd1 	b	40b8a4 <z_impl_ztest_run_test_suites+0x48>
			stats->skip_count++;
  40b964:	b9400680 	ldr	w0, [x20, #4]
  40b968:	11000400 	add	w0, w0, #0x1
  40b96c:	b9000680 	str	w0, [x20, #4]
	int count = 0;
  40b970:	52800000 	mov	w0, #0x0                   	// #0
  40b974:	17fffff6 	b	40b94c <z_impl_ztest_run_test_suites+0xf0>
		return count;
  40b978:	52800015 	mov	w21, #0x0                   	// #0
  40b97c:	17ffffcc 	b	40b8ac <z_impl_ztest_run_test_suites+0x50>

000000000040b980 <ztest_verify_all_test_suites_ran>:

void ztest_verify_all_test_suites_ran(void)
{
  40b980:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b984:	910003fd 	mov	x29, sp
  40b988:	a90153f3 	stp	x19, x20, [sp, #16]
	bool all_tests_run = true;
	struct ztest_suite_node *suite;
	struct ztest_unit_test *test;

	if (IS_ENABLED(CONFIG_ZTEST_VERIFY_RUN_ALL)) {
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40b98c:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  40b990:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  40b994:	f9471e73 	ldr	x19, [x19, #3640]
{
  40b998:	a9025bf5 	stp	x21, x22, [sp, #32]
		     ++suite) {
			if (suite->stats->run_count < 1) {
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40b99c:	d0000056 	adrp	x22, 415000 <random_data+0xd8c>
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40b9a0:	f9473a94 	ldr	x20, [x20, #3696]
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40b9a4:	91243ad6 	add	x22, x22, #0x90e
	bool all_tests_run = true;
  40b9a8:	52800035 	mov	w21, #0x1                   	// #1
{
  40b9ac:	a90363f7 	stp	x23, x24, [sp, #48]
  40b9b0:	f90023f9 	str	x25, [sp, #64]
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40b9b4:	eb14027f 	cmp	x19, x20
  40b9b8:	54000383 	b.cc	40ba28 <ztest_verify_all_test_suites_ran+0xa8>  // b.lo, b.ul, b.last
				all_tests_run = false;
			}
		}

		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40b9bc:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40b9c0:	90000113 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
			suite = ztest_find_test_suite(test->test_suite_name);
			if (suite == NULL) {
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40b9c4:	d0000056 	adrp	x22, 415000 <random_data+0xd8c>
  40b9c8:	aa0003f8 	mov	x24, x0
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40b9cc:	f946ea74 	ldr	x20, [x19, #3536]
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40b9d0:	9124ced6 	add	x22, x22, #0x933
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40b9d4:	f9473c19 	ldr	x25, [x0, #3704]
  40b9d8:	eb19029f 	cmp	x20, x25
  40b9dc:	54000383 	b.cc	40ba4c <ztest_verify_all_test_suites_ran+0xcc>  // b.lo, b.ul, b.last
				      test->name, test->test_suite_name);
				all_tests_run = false;
			}
		}

		if (!all_tests_run) {
  40b9e0:	35000095 	cbnz	w21, 40b9f0 <ztest_verify_all_test_suites_ran+0x70>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  40b9e4:	d0000100 	adrp	x0, 42d000 <counter_value>
  40b9e8:	52800021 	mov	w1, #0x1                   	// #1
  40b9ec:	b90f4401 	str	w1, [x0, #3908]
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40b9f0:	f946ea73 	ldr	x19, [x19, #3536]
	}

	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
		    test->stats->run_count) {
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40b9f4:	d0000055 	adrp	x21, 415000 <random_data+0xd8c>
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40b9f8:	f9473f18 	ldr	x24, [x24, #3704]
			test_status = 1;
  40b9fc:	d0000116 	adrp	x22, 42d000 <counter_value>
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40ba00:	9125d6b5 	add	x21, x21, #0x975
			test_status = 1;
  40ba04:	913d12d6 	add	x22, x22, #0xf44
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40ba08:	eb18027f 	cmp	x19, x24
  40ba0c:	54000363 	b.cc	40ba78 <ztest_verify_all_test_suites_ran+0xf8>  // b.lo, b.ul, b.last
		}
	}
}
  40ba10:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ba14:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ba18:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ba1c:	f94023f9 	ldr	x25, [sp, #64]
  40ba20:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40ba24:	d65f03c0 	ret
			if (suite->stats->run_count < 1) {
  40ba28:	f9401a60 	ldr	x0, [x19, #48]
  40ba2c:	b9400000 	ldr	w0, [x0]
  40ba30:	350000a0 	cbnz	w0, 40ba44 <ztest_verify_all_test_suites_ran+0xc4>
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40ba34:	f9400261 	ldr	x1, [x19]
  40ba38:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  40ba3c:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40ba40:	97ffea51 	bl	406384 <printk>
		     ++suite) {
  40ba44:	9100e273 	add	x19, x19, #0x38
  40ba48:	17ffffdb 	b	40b9b4 <ztest_verify_all_test_suites_ran+0x34>
			suite = ztest_find_test_suite(test->test_suite_name);
  40ba4c:	f9400297 	ldr	x23, [x20]
  40ba50:	aa1703e0 	mov	x0, x23
  40ba54:	97fffdde 	bl	40b1cc <ztest_find_test_suite>
			if (suite == NULL) {
  40ba58:	b50000c0 	cbnz	x0, 40ba70 <ztest_verify_all_test_suites_ran+0xf0>
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40ba5c:	f9400681 	ldr	x1, [x20, #8]
  40ba60:	aa1703e2 	mov	x2, x23
  40ba64:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  40ba68:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40ba6c:	97ffea46 	bl	406384 <printk>
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40ba70:	9100a294 	add	x20, x20, #0x28
  40ba74:	17ffffd9 	b	40b9d8 <ztest_verify_all_test_suites_ran+0x58>
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
  40ba78:	f9401262 	ldr	x2, [x19, #32]
  40ba7c:	29410041 	ldp	w1, w0, [x2, #8]
  40ba80:	0b000021 	add	w1, w1, w0
  40ba84:	b9400440 	ldr	w0, [x2, #4]
  40ba88:	0b000021 	add	w1, w1, w0
  40ba8c:	b9400040 	ldr	w0, [x2]
  40ba90:	6b00003f 	cmp	w1, w0
  40ba94:	540000c0 	b.eq	40baac <ztest_verify_all_test_suites_ran+0x12c>  // b.none
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40ba98:	a9400a61 	ldp	x1, x2, [x19]
  40ba9c:	aa1503e0 	mov	x0, x21
  40baa0:	97ffea39 	bl	406384 <printk>
			test_status = 1;
  40baa4:	52800020 	mov	w0, #0x1                   	// #1
  40baa8:	b90002c0 	str	w0, [x22]
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40baac:	9100a273 	add	x19, x19, #0x28
  40bab0:	17ffffd6 	b	40ba08 <ztest_verify_all_test_suites_ran+0x88>

000000000040bab4 <ztest_run_all>:

void ztest_run_all(const void *state) { ztest_api.run_all(state); }
  40bab4:	90000101 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40bab8:	f9479421 	ldr	x1, [x1, #3880]
  40babc:	f9400021 	ldr	x1, [x1]
  40bac0:	aa0103f0 	mov	x16, x1
  40bac4:	d61f0200 	br	x16

000000000040bac8 <test_main>:

void __weak test_main(void)
{
  40bac8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ztest_run_all(NULL);
  40bacc:	d2800000 	mov	x0, #0x0                   	// #0
{
  40bad0:	910003fd 	mov	x29, sp
	ztest_run_all(NULL);
  40bad4:	97fffff8 	bl	40bab4 <ztest_run_all>

	ztest_verify_all_test_suites_ran();
}
  40bad8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ztest_verify_all_test_suites_ran();
  40badc:	17ffffa9 	b	40b980 <ztest_verify_all_test_suites_ran>

000000000040bae0 <_posix_zephyr_main>:

	return test_status;
}
#else
int main(void)
{
  40bae0:	d10203ff 	sub	sp, sp, #0x80
  40bae4:	a9027bfd 	stp	x29, x30, [sp, #32]
  40bae8:	910083fd 	add	x29, sp, #0x20
  40baec:	a90353f3 	stp	x19, x20, [sp, #48]
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40baf0:	90000114 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
{
  40baf4:	a9045bf5 	stp	x21, x22, [sp, #64]
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40baf8:	d0000056 	adrp	x22, 415000 <random_data+0xd8c>
  40bafc:	91285ed6 	add	x22, x22, #0xa17
{
  40bb00:	a90563f7 	stp	x23, x24, [sp, #80]
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40bb04:	52955577 	mov	w23, #0xaaab                	// #43691
  40bb08:	72b55557 	movk	w23, #0xaaaa, lsl #16
{
  40bb0c:	a9066bf9 	stp	x25, x26, [sp, #96]
  40bb10:	a90773fb 	stp	x27, x28, [sp, #112]
	k_mem_domain_add_partition(&k_mem_domain_default, &z_malloc_partition);
#endif
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
  40bb14:	97ffffed 	bl	40bac8 <test_main>
	flush_log();
  40bb18:	97fffdc4 	bl	40b228 <flush_log>
	TC_SUMMARY_PRINT("\n------ TESTSUITE SUMMARY START ------\n\n");
  40bb1c:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40bb20:	91262800 	add	x0, x0, #0x98a
  40bb24:	97ffea18 	bl	406384 <printk>
	flush_log();
  40bb28:	97fffdc0 	bl	40b228 <flush_log>
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40bb2c:	f9471e94 	ldr	x20, [x20, #3640]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bb30:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40bb34:	f9473800 	ldr	x0, [x0, #3696]
  40bb38:	eb00029f 	cmp	x20, x0
  40bb3c:	54000cc3 	b.cc	40bcd4 <_posix_zephyr_main+0x1f4>  // b.lo, b.ul, b.last
	TC_SUMMARY_PRINT("------ TESTSUITE SUMMARY END ------\n\n");
  40bb40:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40bb44:	91290c00 	add	x0, x0, #0xa43
  40bb48:	97ffea0f 	bl	406384 <printk>
	flush_log();
  40bb4c:	d0000054 	adrp	x20, 415000 <random_data+0xd8c>
  40bb50:	d0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40bb54:	97fffdb5 	bl	40b228 <flush_log>
	if (test_status) {
  40bb58:	d0000100 	adrp	x0, 42d000 <counter_value>
  40bb5c:	b94f4401 	ldr	w1, [x0, #3908]
  40bb60:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
		TC_END_REPORT(TC_FAIL);
  40bb64:	9121c800 	add	x0, x0, #0x872
	if (test_status) {
  40bb68:	34000fc1 	cbz	w1, 40bd60 <_posix_zephyr_main+0x280>
		TC_END_REPORT(TC_FAIL);
  40bb6c:	97ffea06 	bl	406384 <printk>
  40bb70:	9129a680 	add	x0, x20, #0xa69
  40bb74:	97ffea04 	bl	406384 <printk>
  40bb78:	912a6660 	add	x0, x19, #0xa99
  40bb7c:	d0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40bb80:	912a4821 	add	x1, x1, #0xa92
  40bb84:	97ffea00 	bl	406384 <printk>
	z_impl_log_panic();
  40bb88:	97fff0ad 	bl	407e3c <z_impl_log_panic>
  40bb8c:	52800020 	mov	w0, #0x1                   	// #1
		TC_END_REPORT(TC_PASS);
  40bb90:	97fff980 	bl	40a190 <posix_exit>
	end_report();
	flush_log();
  40bb94:	97fffda5 	bl	40b228 <flush_log>
  40bb98:	97fff0a9 	bl	407e3c <z_impl_log_panic>
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
	return 0;
}
  40bb9c:	52800000 	mov	w0, #0x0                   	// #0
  40bba0:	a9427bfd 	ldp	x29, x30, [sp, #32]
  40bba4:	a94353f3 	ldp	x19, x20, [sp, #48]
  40bba8:	a9445bf5 	ldp	x21, x22, [sp, #64]
  40bbac:	a94563f7 	ldp	x23, x24, [sp, #80]
  40bbb0:	a9466bf9 	ldp	x25, x26, [sp, #96]
  40bbb4:	a94773fb 	ldp	x27, x28, [sp, #112]
  40bbb8:	910203ff 	add	sp, sp, #0x80
  40bbbc:	d65f03c0 	ret
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40bbc0:	f9401260 	ldr	x0, [x19, #32]
		distinct_total++;
  40bbc4:	1100075a 	add	w26, w26, #0x1
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40bbc8:	b9401001 	ldr	w1, [x0, #16]
		if (test->stats->skip_count == test->stats->run_count) {
  40bbcc:	b9400402 	ldr	w2, [x0, #4]
		suite_duration_worst_ms += test->stats->duration_worst_ms;
  40bbd0:	0b0102b5 	add	w21, w21, w1
		if (test->stats->skip_count == test->stats->run_count) {
  40bbd4:	b9400001 	ldr	w1, [x0]
  40bbd8:	6b01005f 	cmp	w2, w1
  40bbdc:	540006e1 	b.ne	40bcb8 <_posix_zephyr_main+0x1d8>  // b.any
			distinct_skip++;
  40bbe0:	11000718 	add	w24, w24, #0x1
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40bbe4:	f9400280 	ldr	x0, [x20]
  40bbe8:	aa1303e1 	mov	x1, x19
  40bbec:	97fffdfd 	bl	40b3e0 <z_ztest_get_next_test>
  40bbf0:	aa0003f3 	mov	x19, x0
  40bbf4:	b5fffe60 	cbnz	x0, 40bbc0 <_posix_zephyr_main+0xe0>
	if (distinct_skip == distinct_total) {
  40bbf8:	6b18035f 	cmp	w26, w24
  40bbfc:	540007a0 	b.eq	40bcf0 <_posix_zephyr_main+0x210>  // b.none
		expanded_pass = distinct_pass * 100000;
  40bc00:	5290d401 	mov	w1, #0x86a0                	// #34464
		effective_total = distinct_total - distinct_skip;
  40bc04:	4b180342 	sub	w2, w26, w24
		expanded_pass = distinct_pass * 100000;
  40bc08:	72a00021 	movk	w1, #0x1, lsl #16
		passrate_major = expanded_passrate / 1000;
  40bc0c:	52807d08 	mov	w8, #0x3e8                 	// #1000
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bc10:	52800143 	mov	w3, #0xa                   	// #10
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
  40bc14:	7100039f 	cmp	w28, #0x0
		expanded_pass = distinct_pass * 100000;
  40bc18:	1b017f61 	mul	w1, w27, w1
		suite_result = (distinct_fail > 0) ? TC_FAIL : TC_PASS;
  40bc1c:	1a9fd7e0 	cset	w0, gt
		expanded_passrate = expanded_pass / effective_total;
  40bc20:	1ac20c21 	sdiv	w1, w1, w2
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bc24:	12807ce2 	mov	w2, #0xfffffc18            	// #-1000
		passrate_major = expanded_passrate / 1000;
  40bc28:	1ac80c28 	sdiv	w8, w1, w8
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bc2c:	1b020501 	madd	w1, w8, w2, w1
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
  40bc30:	12800122 	mov	w2, #0xfffffff6            	// #-10
		passrate_minor = (expanded_passrate - passrate_major * 1000) / 10;
  40bc34:	1ac30c23 	sdiv	w3, w1, w3
		passrate_tail = expanded_passrate - passrate_major * 1000 - passrate_minor * 10;
  40bc38:	1b020461 	madd	w1, w3, w2, w1
			passrate_minor++;
  40bc3c:	7100103f 	cmp	w1, #0x4
  40bc40:	1a83d463 	cinc	w3, w3, gt
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
  40bc44:	52807d19 	mov	w25, #0x3e8                 	// #1000
  40bc48:	97fffd33 	bl	40b114 <TC_RESULT_TO_STR>
  40bc4c:	b90003fa 	str	w26, [sp]
  40bc50:	aa0003e1 	mov	x1, x0
  40bc54:	1ad90aa2 	udiv	w2, w21, w25
  40bc58:	2a1803e7 	mov	w7, w24
  40bc5c:	2a1c03e6 	mov	w6, w28
  40bc60:	2a1b03e5 	mov	w5, w27
  40bc64:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40bc68:	9126cc00 	add	x0, x0, #0x9b3
  40bc6c:	1b19d455 	msub	w21, w2, w25, w21
  40bc70:	b9000be2 	str	w2, [sp, #8]
  40bc74:	b90013f5 	str	w21, [sp, #16]
  40bc78:	2a0803e2 	mov	w2, w8
	int flush_frequency = 0;
  40bc7c:	52800015 	mov	w21, #0x0                   	// #0
	TC_SUMMARY_PRINT("SUITE %s - %3d.%02d%% [%s]: pass = %d, fail = %d, "
  40bc80:	f9400284 	ldr	x4, [x20]
  40bc84:	97ffe9c0 	bl	406384 <printk>
	flush_log();
  40bc88:	97fffd68 	bl	40b228 <flush_log>
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40bc8c:	f9400280 	ldr	x0, [x20]
  40bc90:	aa1303e1 	mov	x1, x19
  40bc94:	97fffdd3 	bl	40b3e0 <z_ztest_get_next_test>
  40bc98:	aa0003f3 	mov	x19, x0
  40bc9c:	b5000320 	cbnz	x0, 40bd00 <_posix_zephyr_main+0x220>
	TC_SUMMARY_PRINT("\n");
  40bca0:	d0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40bca4:	91320800 	add	x0, x0, #0xc82
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bca8:	9100e294 	add	x20, x20, #0x38
	TC_SUMMARY_PRINT("\n");
  40bcac:	97ffe9b6 	bl	406384 <printk>
	flush_log();
  40bcb0:	97fffd5e 	bl	40b228 <flush_log>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40bcb4:	17ffff9f 	b	40bb30 <_posix_zephyr_main+0x50>
		} else if (test->stats->pass_count == test->stats->run_count) {
  40bcb8:	b9400c00 	ldr	w0, [x0, #12]
  40bcbc:	6b00003f 	cmp	w1, w0
  40bcc0:	54000061 	b.ne	40bccc <_posix_zephyr_main+0x1ec>  // b.any
			distinct_pass++;
  40bcc4:	1100077b 	add	w27, w27, #0x1
  40bcc8:	17ffffc7 	b	40bbe4 <_posix_zephyr_main+0x104>
			distinct_fail++;
  40bccc:	1100079c 	add	w28, w28, #0x1
  40bcd0:	17ffffc5 	b	40bbe4 <_posix_zephyr_main+0x104>
	unsigned int suite_duration_worst_ms = 0;
  40bcd4:	52800015 	mov	w21, #0x0                   	// #0
	struct ztest_unit_test *test = NULL;
  40bcd8:	d2800013 	mov	x19, #0x0                   	// #0
	int distinct_pass = 0, distinct_fail = 0, distinct_skip = 0, distinct_total = 0;
  40bcdc:	5280001a 	mov	w26, #0x0                   	// #0
  40bce0:	52800018 	mov	w24, #0x0                   	// #0
  40bce4:	5280001c 	mov	w28, #0x0                   	// #0
  40bce8:	5280001b 	mov	w27, #0x0                   	// #0
  40bcec:	17ffffbe 	b	40bbe4 <_posix_zephyr_main+0x104>
		suite_result = TC_SKIP;
  40bcf0:	52800040 	mov	w0, #0x2                   	// #2
		passrate_major = passrate_minor = 0;
  40bcf4:	52800003 	mov	w3, #0x0                   	// #0
  40bcf8:	52800008 	mov	w8, #0x0                   	// #0
  40bcfc:	17ffffd2 	b	40bc44 <_posix_zephyr_main+0x164>
		if (test->stats->skip_count == test->stats->run_count) {
  40bd00:	f9401263 	ldr	x3, [x19, #32]
  40bd04:	29400460 	ldp	w0, w1, [x3]
  40bd08:	6b00003f 	cmp	w1, w0
  40bd0c:	54000260 	b.eq	40bd58 <_posix_zephyr_main+0x278>  // b.none
		} else if (test->stats->pass_count == test->stats->run_count) {
  40bd10:	b9400c61 	ldr	w1, [x3, #12]
  40bd14:	6b00003f 	cmp	w1, w0
  40bd18:	1a9f07e0 	cset	w0, ne  // ne = any
		TC_SUMMARY_PRINT(" - %s - [%s.%s] duration = %u.%03u seconds\n",
  40bd1c:	97fffcfe 	bl	40b114 <TC_RESULT_TO_STR>
  40bd20:	b9401065 	ldr	w5, [x3, #16]
  40bd24:	a9400e62 	ldp	x2, x3, [x19]
  40bd28:	aa0003e1 	mov	x1, x0
  40bd2c:	aa1603e0 	mov	x0, x22
  40bd30:	1ad908a4 	udiv	w4, w5, w25
  40bd34:	1b199485 	msub	w5, w4, w25, w5
  40bd38:	97ffe993 	bl	406384 <printk>
  40bd3c:	1b177ea1 	mul	w1, w21, w23
		if (flush_frequency % 3 == 0) {
  40bd40:	3200f3e0 	mov	w0, #0x55555555            	// #1431655765
  40bd44:	6b00003f 	cmp	w1, w0
  40bd48:	54000048 	b.hi	40bd50 <_posix_zephyr_main+0x270>  // b.pmore
			flush_log();
  40bd4c:	97fffd37 	bl	40b228 <flush_log>
		flush_frequency++;
  40bd50:	110006b5 	add	w21, w21, #0x1
  40bd54:	17ffffce 	b	40bc8c <_posix_zephyr_main+0x1ac>
			tc_result = TC_SKIP;
  40bd58:	52800040 	mov	w0, #0x2                   	// #2
  40bd5c:	17fffff0 	b	40bd1c <_posix_zephyr_main+0x23c>
		TC_END_REPORT(TC_PASS);
  40bd60:	97ffe989 	bl	406384 <printk>
  40bd64:	9129a680 	add	x0, x20, #0xa69
  40bd68:	97ffe987 	bl	406384 <printk>
  40bd6c:	912a6660 	add	x0, x19, #0xa99
  40bd70:	d0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40bd74:	912abc21 	add	x1, x1, #0xaaf
  40bd78:	97ffe983 	bl	406384 <printk>
  40bd7c:	97fff030 	bl	407e3c <z_impl_log_panic>
  40bd80:	52800000 	mov	w0, #0x0                   	// #0
  40bd84:	17ffff83 	b	40bb90 <_posix_zephyr_main+0xb0>

000000000040bd88 <add_test_filter_option>:
		  "\'suiteA::test1,suiteA::test2,suiteB::*\'. An * can be used "
		  "as a wildcard to run all tests within a suite." },
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(test_filter_s);
  40bd88:	b0000100 	adrp	x0, 42c000 <__dso_handle>
  40bd8c:	910d0000 	add	x0, x0, #0x340
  40bd90:	17fffc23 	b	40ae1c <native_add_command_line_opts>

000000000040bd94 <z_ztest_testargs_contains>:
 * @param test_name
 * @return true
 * @return false
 */
static bool z_ztest_testargs_contains(const char *suite_name, const char *test_name)
{
  40bd94:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40bd98:	910003fd 	mov	x29, sp
  40bd9c:	a90363f7 	stp	x23, x24, [sp, #48]
  40bda0:	aa0003f7 	mov	x23, x0
  40bda4:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40bda8:	a90153f3 	stp	x19, x20, [sp, #16]
  40bdac:	aa0103f4 	mov	x20, x1
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
		test_arg = strtok_r(NULL, ":", &last_arg);

		found = !strcmp(suite_arg, suite_name);
		if (test_name) {
			found &= !strcmp(test_arg, "*") ||
  40bdb0:	d0000058 	adrp	x24, 415000 <random_data+0xd8c>
{
  40bdb4:	f9476800 	ldr	x0, [x0, #3792]
  40bdb8:	a9025bf5 	stp	x21, x22, [sp, #32]
			found &= !strcmp(test_arg, "*") ||
  40bdbc:	912af318 	add	x24, x24, #0xabc
{
  40bdc0:	a9046bf9 	stp	x25, x26, [sp, #64]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40bdc4:	d0000055 	adrp	x21, 415000 <random_data+0xd8c>
  40bdc8:	9118aeb5 	add	x21, x21, #0x62b
{
  40bdcc:	a90573fb 	stp	x27, x28, [sp, #80]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40bdd0:	9101c3fb 	add	x27, sp, #0x70
	bool found = false;
  40bdd4:	52800013 	mov	w19, #0x0                   	// #0
{
  40bdd8:	f9400001 	ldr	x1, [x0]
  40bddc:	f9003fe1 	str	x1, [sp, #120]
  40bde0:	d2800001 	mov	x1, #0x0                   	// #0
	char *test_args_local = strdup(test_args);
  40bde4:	d0000100 	adrp	x0, 42d000 <counter_value>
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40bde8:	9101a3f9 	add	x25, sp, #0x68
  40bdec:	d000005a 	adrp	x26, 415000 <random_data+0xd8c>
	char *test_args_local = strdup(test_args);
  40bdf0:	f9407800 	ldr	x0, [x0, #240]
  40bdf4:	97ffd547 	bl	401310 <strdup@plt>
  40bdf8:	aa0003f6 	mov	x22, x0
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40bdfc:	aa1903e2 	mov	x2, x25
  40be00:	912aeb41 	add	x1, x26, #0xaba
  40be04:	97ffd51b 	bl	401270 <strtok_r@plt>
	while (suite_test_pair && !found) {
  40be08:	f100001f 	cmp	x0, #0x0
  40be0c:	52000261 	eor	w1, w19, #0x1
  40be10:	1a9f07e2 	cset	w2, ne  // ne = any
  40be14:	6a01005f 	tst	w2, w1
  40be18:	54000161 	b.ne	40be44 <z_ztest_testargs_contains+0xb0>  // b.any
		}

		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
	}

	free(test_args_local);
  40be1c:	aa1603e0 	mov	x0, x22
  40be20:	97ffd570 	bl	4013e0 <free@plt>
	return found;
}
  40be24:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40be28:	f9476800 	ldr	x0, [x0, #3792]
  40be2c:	f9403fe2 	ldr	x2, [sp, #120]
  40be30:	f9400001 	ldr	x1, [x0]
  40be34:	eb010042 	subs	x2, x2, x1
  40be38:	d2800001 	mov	x1, #0x0                   	// #0
  40be3c:	54000440 	b.eq	40bec4 <z_ztest_testargs_contains+0x130>  // b.none
  40be40:	97ffd538 	bl	401320 <__stack_chk_fail@plt>
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40be44:	aa1b03e2 	mov	x2, x27
  40be48:	aa1503e1 	mov	x1, x21
  40be4c:	97ffd509 	bl	401270 <strtok_r@plt>
  40be50:	aa0003f3 	mov	x19, x0
		test_arg = strtok_r(NULL, ":", &last_arg);
  40be54:	aa1b03e2 	mov	x2, x27
  40be58:	aa1503e1 	mov	x1, x21
  40be5c:	d2800000 	mov	x0, #0x0                   	// #0
  40be60:	97ffd504 	bl	401270 <strtok_r@plt>
		found = !strcmp(suite_arg, suite_name);
  40be64:	aa1703e1 	mov	x1, x23
		test_arg = strtok_r(NULL, ":", &last_arg);
  40be68:	aa0003fc 	mov	x28, x0
		found = !strcmp(suite_arg, suite_name);
  40be6c:	aa1303e0 	mov	x0, x19
  40be70:	97ffd54c 	bl	4013a0 <strcmp@plt>
  40be74:	7100001f 	cmp	w0, #0x0
  40be78:	1a9f17f3 	cset	w19, eq  // eq = none
		if (test_name) {
  40be7c:	b4000174 	cbz	x20, 40bea8 <z_ztest_testargs_contains+0x114>
			found &= !strcmp(test_arg, "*") ||
  40be80:	aa1803e1 	mov	x1, x24
  40be84:	aa1c03e0 	mov	x0, x28
  40be88:	97ffd546 	bl	4013a0 <strcmp@plt>
  40be8c:	34000180 	cbz	w0, 40bebc <z_ztest_testargs_contains+0x128>
				 !strcmp(test_arg, test_name);
  40be90:	aa1403e1 	mov	x1, x20
  40be94:	aa1c03e0 	mov	x0, x28
  40be98:	97ffd542 	bl	4013a0 <strcmp@plt>
			found &= !strcmp(test_arg, "*") ||
  40be9c:	7100001f 	cmp	w0, #0x0
  40bea0:	1a9f17e0 	cset	w0, eq  // eq = none
  40bea4:	0a000273 	and	w19, w19, w0
		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
  40bea8:	aa1903e2 	mov	x2, x25
  40beac:	912aeb41 	add	x1, x26, #0xaba
  40beb0:	d2800000 	mov	x0, #0x0                   	// #0
  40beb4:	97ffd4ef 	bl	401270 <strtok_r@plt>
  40beb8:	17ffffd4 	b	40be08 <z_ztest_testargs_contains+0x74>
			found &= !strcmp(test_arg, "*") ||
  40bebc:	52800020 	mov	w0, #0x1                   	// #1
  40bec0:	17fffff9 	b	40bea4 <z_ztest_testargs_contains+0x110>
}
  40bec4:	2a1303e0 	mov	w0, w19
  40bec8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40becc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40bed0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40bed4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40bed8:	a94573fb 	ldp	x27, x28, [sp, #80]
  40bedc:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40bee0:	d65f03c0 	ret

000000000040bee4 <z_ztest_should_test_run>:
 */
bool z_ztest_should_test_run(const char *suite, const char *test)
{
	bool run_test = false;

	run_test = (test_args == NULL ||
  40bee4:	d0000102 	adrp	x2, 42d000 <counter_value>
  40bee8:	f9407842 	ldr	x2, [x2, #240]
  40beec:	b4000102 	cbz	x2, 40bf0c <z_ztest_should_test_run+0x28>
{
  40bef0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40bef4:	910003fd 	mov	x29, sp
		    z_ztest_testargs_contains(suite, test));
  40bef8:	97ffffa7 	bl	40bd94 <z_ztest_testargs_contains>
  40befc:	12001c00 	and	w0, w0, #0xff

	return run_test;
}
  40bf00:	12000000 	and	w0, w0, #0x1
  40bf04:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40bf08:	d65f03c0 	ret
	run_test = (test_args == NULL ||
  40bf0c:	52800020 	mov	w0, #0x1                   	// #1
}
  40bf10:	12000000 	and	w0, w0, #0x1
  40bf14:	d65f03c0 	ret

000000000040bf18 <z_ztest_should_suite_run>:
 * @param suite Pointer to ztest_suite_node
 * @return true
 * @return false
 */
bool z_ztest_should_suite_run(const void *state, struct ztest_suite_node *suite)
{
  40bf18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40bf1c:	910003fd 	mov	x29, sp
  40bf20:	a90153f3 	stp	x19, x20, [sp, #16]
  40bf24:	aa0003f4 	mov	x20, x0
	bool run_suite = true;

	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40bf28:	d0000100 	adrp	x0, 42d000 <counter_value>
{
  40bf2c:	aa0103f3 	mov	x19, x1
	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40bf30:	f9407800 	ldr	x0, [x0, #240]
  40bf34:	b40001a0 	cbz	x0, 40bf68 <z_ztest_should_suite_run+0x50>
  40bf38:	f9400260 	ldr	x0, [x19]
  40bf3c:	d2800001 	mov	x1, #0x0                   	// #0
  40bf40:	97ffff95 	bl	40bd94 <z_ztest_testargs_contains>
  40bf44:	72001c00 	ands	w0, w0, #0xff
  40bf48:	54000101 	b.ne	40bf68 <z_ztest_should_suite_run+0x50>  // b.any
  40bf4c:	f9401a62 	ldr	x2, [x19, #48]
		run_suite = false;
		suite->stats->run_count++;
  40bf50:	b9400041 	ldr	w1, [x2]
  40bf54:	11000421 	add	w1, w1, #0x1
  40bf58:	b9000041 	str	w1, [x2]
	} else if (suite->predicate != NULL) {
		run_suite = suite->predicate(state);
	}

	return run_suite;
}
  40bf5c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bf60:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40bf64:	d65f03c0 	ret
	} else if (suite->predicate != NULL) {
  40bf68:	f9401661 	ldr	x1, [x19, #40]
  40bf6c:	b40000c1 	cbz	x1, 40bf84 <z_ztest_should_suite_run+0x6c>
		run_suite = suite->predicate(state);
  40bf70:	aa1403e0 	mov	x0, x20
  40bf74:	aa0103f0 	mov	x16, x1
}
  40bf78:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bf7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		run_suite = suite->predicate(state);
  40bf80:	d61f0200 	br	x16
	bool run_suite = true;
  40bf84:	52800020 	mov	w0, #0x1                   	// #1
  40bf88:	17fffff5 	b	40bf5c <z_ztest_should_suite_run+0x44>

000000000040bf8c <ztest_relative_filename>:
{
  40bf8c:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  40bf90:	910003fd 	mov	x29, sp
  40bf94:	a90153f3 	stp	x19, x20, [sp, #16]
  40bf98:	aa0003f3 	mov	x19, x0
  40bf9c:	90000100 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40bfa0:	a9025bf5 	stp	x21, x22, [sp, #32]
  40bfa4:	f9476800 	ldr	x0, [x0, #3792]
  40bfa8:	f9400001 	ldr	x1, [x0]
  40bfac:	f9007fe1 	str	x1, [sp, #248]
  40bfb0:	d2800001 	mov	x1, #0x0                   	// #0
		       "destination buffer");

__fortify_function __wur char *
__NTH (getcwd (char *__buf, size_t __size))
{
  return __glibc_fortify (getcwd, __size, sizeof (char),
  40bfb4:	9100c3e0 	add	x0, sp, #0x30
  40bfb8:	d2801901 	mov	x1, #0xc8                  	// #200
  40bfbc:	97ffd471 	bl	401180 <getcwd@plt>
	if (cwd && strlen(file) > strlen(cwd) && !strncmp(file, cwd, strlen(cwd))) {
  40bfc0:	b4000220 	cbz	x0, 40c004 <ztest_relative_filename+0x78>
  40bfc4:	aa0003f5 	mov	x21, x0
  40bfc8:	aa1303e0 	mov	x0, x19
  40bfcc:	97ffd475 	bl	4011a0 <strlen@plt>
  40bfd0:	aa0003f6 	mov	x22, x0
  40bfd4:	aa1503e0 	mov	x0, x21
  40bfd8:	97ffd472 	bl	4011a0 <strlen@plt>
  40bfdc:	aa0003f4 	mov	x20, x0
  40bfe0:	eb0002df 	cmp	x22, x0
  40bfe4:	54000109 	b.ls	40c004 <ztest_relative_filename+0x78>  // b.plast
  40bfe8:	aa0003e2 	mov	x2, x0
  40bfec:	aa1503e1 	mov	x1, x21
  40bff0:	aa1303e0 	mov	x0, x19
  40bff4:	97ffd4a7 	bl	401290 <strncmp@plt>
  40bff8:	35000060 	cbnz	w0, 40c004 <ztest_relative_filename+0x78>
		return file + strlen(cwd) + 1; /* move past the trailing '/' */
  40bffc:	91000694 	add	x20, x20, #0x1
  40c000:	8b140273 	add	x19, x19, x20
}
  40c004:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40c008:	f9476800 	ldr	x0, [x0, #3792]
  40c00c:	f9407fe2 	ldr	x2, [sp, #248]
  40c010:	f9400001 	ldr	x1, [x0]
  40c014:	eb010042 	subs	x2, x2, x1
  40c018:	d2800001 	mov	x1, #0x0                   	// #0
  40c01c:	54000040 	b.eq	40c024 <ztest_relative_filename+0x98>  // b.none
  40c020:	97ffd4c0 	bl	401320 <__stack_chk_fail@plt>
  40c024:	aa1303e0 	mov	x0, x19
  40c028:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c02c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c030:	a8d07bfd 	ldp	x29, x30, [sp], #256
  40c034:	d65f03c0 	ret

000000000040c038 <z_ztest_get_list_test>:
}
  40c038:	d0000100 	adrp	x0, 42e000 <des_frames+0x27>
  40c03c:	394c2000 	ldrb	w0, [x0, #776]
  40c040:	d65f03c0 	ret

000000000040c044 <z_ztest_list_tests>:
{
  40c044:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40c048:	910003fd 	mov	x29, sp
  40c04c:	a90363f7 	stp	x23, x24, [sp, #48]
	if (list_once) {
  40c050:	90000118 	adrp	x24, 42c000 <__dso_handle>
  40c054:	39504700 	ldrb	w0, [x24, #1041]
{
  40c058:	a90153f3 	stp	x19, x20, [sp, #16]
  40c05c:	a9025bf5 	stp	x21, x22, [sp, #32]
	int test_count = 0;
  40c060:	52800015 	mov	w21, #0x0                   	// #0
	if (list_once) {
  40c064:	350002e0 	cbnz	w0, 40c0c0 <z_ztest_list_tests+0x7c>
}
  40c068:	2a1503e0 	mov	w0, w21
  40c06c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c070:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c074:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c078:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40c07c:	d65f03c0 	ret
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c080:	a9400a61 	ldp	x1, x2, [x19]
  40c084:	aa1703e0 	mov	x0, x23
				test_count++;
  40c088:	110006b5 	add	w21, w21, #0x1
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c08c:	97ffe8be 	bl	406384 <printk>
			while ((test = z_ztest_get_next_test(ptr->name, test)) != NULL) {
  40c090:	f9400280 	ldr	x0, [x20]
  40c094:	aa1303e1 	mov	x1, x19
  40c098:	97fffcd2 	bl	40b3e0 <z_ztest_get_next_test>
  40c09c:	aa0003f3 	mov	x19, x0
  40c0a0:	b5ffff00 	cbnz	x0, 40c080 <z_ztest_list_tests+0x3c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c0a4:	9100e294 	add	x20, x20, #0x38
  40c0a8:	eb16029f 	cmp	x20, x22
  40c0ac:	54000063 	b.cc	40c0b8 <z_ztest_list_tests+0x74>  // b.lo, b.ul, b.last
		list_once = false;
  40c0b0:	3910471f 	strb	wzr, [x24, #1041]
	return test_count;
  40c0b4:	17ffffed 	b	40c068 <z_ztest_list_tests+0x24>
			test = NULL;
  40c0b8:	d2800013 	mov	x19, #0x0                   	// #0
  40c0bc:	17fffff5 	b	40c090 <z_ztest_list_tests+0x4c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c0c0:	f00000f4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  40c0c4:	f00000f6 	adrp	x22, 42b000 <__FRAME_END__+0x1007c>
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40c0c8:	b0000057 	adrp	x23, 415000 <random_data+0xd8c>
  40c0cc:	912afaf7 	add	x23, x23, #0xabe
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40c0d0:	f9471e94 	ldr	x20, [x20, #3640]
  40c0d4:	f9473ad6 	ldr	x22, [x22, #3696]
  40c0d8:	17fffff4 	b	40c0a8 <z_ztest_list_tests+0x64>

000000000040c0dc <z_ztest_run_all>:
{
  40c0dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c0e0:	910003fd 	mov	x29, sp
  40c0e4:	f9000bf3 	str	x19, [sp, #16]
  40c0e8:	aa0003f3 	mov	x19, x0
	if (z_ztest_get_list_test()) {
  40c0ec:	97ffffd3 	bl	40c038 <z_ztest_get_list_test>
  40c0f0:	72001c1f 	tst	w0, #0xff
  40c0f4:	54000080 	b.eq	40c104 <z_ztest_run_all+0x28>  // b.none
}
  40c0f8:	f9400bf3 	ldr	x19, [sp, #16]
  40c0fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_ztest_list_tests();
  40c100:	17ffffd1 	b	40c044 <z_ztest_list_tests>
		union { uintptr_t x; const void * val; } parm0 = { .val = state };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_ZTEST_RUN_TEST_SUITES);
	}
#endif
	compiler_barrier();
	return z_impl_ztest_run_test_suites(state);
  40c104:	aa1303e0 	mov	x0, x19
}
  40c108:	f9400bf3 	ldr	x19, [sp, #16]
  40c10c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c110:	17fffdd3 	b	40b85c <z_impl_ztest_run_test_suites>

000000000040c114 <generic_data_ref>:

	net_buf_simple_reset(&buf->b);
}

static uint8_t *generic_data_ref(struct net_buf *buf, uint8_t *data)
{
  40c114:	aa0103e0 	mov	x0, x1
	uint8_t *ref_count;

	ref_count = data - sizeof(void *);
	(*ref_count)++;
  40c118:	385f8021 	ldurb	w1, [x1, #-8]
  40c11c:	11000421 	add	w1, w1, #0x1
  40c120:	381f8001 	sturb	w1, [x0, #-8]

	return data;
}
  40c124:	d65f03c0 	ret

000000000040c128 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
  40c128:	d65f03c0 	ret

000000000040c12c <net_buf_pool_get>:
}
  40c12c:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40c130:	52800c02 	mov	w2, #0x60                  	// #96
  40c134:	f9479821 	ldr	x1, [x1, #3888]
  40c138:	9b220400 	smaddl	x0, w0, w2, x1
  40c13c:	d65f03c0 	ret

000000000040c140 <mem_pool_data_unref>:
{
  40c140:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c144:	910003fd 	mov	x29, sp
  40c148:	f9000bf3 	str	x19, [sp, #16]
  40c14c:	aa0103f3 	mov	x19, x1
	struct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);
  40c150:	39404800 	ldrb	w0, [x0, #18]
  40c154:	97fffff6 	bl	40c12c <net_buf_pool_get>
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c158:	f9402800 	ldr	x0, [x0, #80]
	if (--(*ref_count)) {
  40c15c:	385f8262 	ldurb	w2, [x19, #-8]
  40c160:	51000442 	sub	w2, w2, #0x1
  40c164:	12001c42 	and	w2, w2, #0xff
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c168:	f9400400 	ldr	x0, [x0, #8]
	if (--(*ref_count)) {
  40c16c:	381f8262 	sturb	w2, [x19, #-8]
  40c170:	350000a2 	cbnz	w2, 40c184 <mem_pool_data_unref+0x44>
	k_heap_free(pool, ref_count);
  40c174:	d1002261 	sub	x1, x19, #0x8
}
  40c178:	f9400bf3 	ldr	x19, [sp, #16]
  40c17c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_heap_free(pool, ref_count);
  40c180:	140006bb 	b	40dc6c <k_heap_free>
}
  40c184:	f9400bf3 	ldr	x19, [sp, #16]
  40c188:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c18c:	d65f03c0 	ret

000000000040c190 <mem_pool_data_alloc>:
{
  40c190:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c194:	910003fd 	mov	x29, sp
  40c198:	a90153f3 	stp	x19, x20, [sp, #16]
  40c19c:	aa0103f4 	mov	x20, x1
  40c1a0:	aa0203f3 	mov	x19, x2
	struct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);
  40c1a4:	39404800 	ldrb	w0, [x0, #18]
  40c1a8:	97ffffe1 	bl	40c12c <net_buf_pool_get>
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40c1ac:	f9402800 	ldr	x0, [x0, #80]
	void *b = k_heap_alloc(pool, sizeof(void *) + *size, timeout);
  40c1b0:	aa1303e2 	mov	x2, x19
  40c1b4:	f9400281 	ldr	x1, [x20]
  40c1b8:	f9400400 	ldr	x0, [x0, #8]
  40c1bc:	91002021 	add	x1, x1, #0x8
  40c1c0:	940006a7 	bl	40dc5c <k_heap_alloc>
	if (b == NULL) {
  40c1c4:	b4000060 	cbz	x0, 40c1d0 <mem_pool_data_alloc+0x40>
	*ref_count = 1U;
  40c1c8:	52800021 	mov	w1, #0x1                   	// #1
  40c1cc:	38008401 	strb	w1, [x0], #8
}
  40c1d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c1d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c1d8:	d65f03c0 	ret

000000000040c1dc <data_alloc>:
};

#endif /* CONFIG_HEAP_MEM_POOL_SIZE > 0 */

static uint8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)
{
  40c1dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c1e0:	910003fd 	mov	x29, sp
  40c1e4:	a90153f3 	stp	x19, x20, [sp, #16]
  40c1e8:	aa0003f3 	mov	x19, x0
  40c1ec:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c1f0:	39404800 	ldrb	w0, [x0, #18]
{
  40c1f4:	f90013f5 	str	x21, [sp, #32]
  40c1f8:	aa0203f5 	mov	x21, x2
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c1fc:	97ffffcc 	bl	40c12c <net_buf_pool_get>

	return pool->alloc->cb->alloc(buf, size, timeout);
  40c200:	f9402800 	ldr	x0, [x0, #80]
  40c204:	aa1503e2 	mov	x2, x21
  40c208:	aa1403e1 	mov	x1, x20
}
  40c20c:	f94013f5 	ldr	x21, [sp, #32]
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c210:	f9400000 	ldr	x0, [x0]
  40c214:	f9400003 	ldr	x3, [x0]
  40c218:	aa1303e0 	mov	x0, x19
}
  40c21c:	a94153f3 	ldp	x19, x20, [sp, #16]
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c220:	aa0303f0 	mov	x16, x3
}
  40c224:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return pool->alloc->cb->alloc(buf, size, timeout);
  40c228:	d61f0200 	br	x16

000000000040c22c <net_buf_destroy>:
{
  40c22c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c230:	910003fd 	mov	x29, sp
  40c234:	f9000bf3 	str	x19, [sp, #16]
  40c238:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c23c:	39404800 	ldrb	w0, [x0, #18]
  40c240:	97ffffbb 	bl	40c12c <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40c244:	aa1303e1 	mov	x1, x19
}
  40c248:	f9400bf3 	ldr	x19, [sp, #16]
  40c24c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_lifo_put(&pool->free, buf);
  40c250:	14000c7e 	b	40f448 <k_queue_prepend>

000000000040c254 <net_buf_id>:
{
  40c254:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c258:	910003fd 	mov	x29, sp
  40c25c:	f9000bf3 	str	x19, [sp, #16]
  40c260:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c264:	39404800 	ldrb	w0, [x0, #18]
  40c268:	97ffffb1 	bl	40c12c <net_buf_pool_get>
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40c26c:	f9402c01 	ldr	x1, [x0, #88]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c270:	39411000 	ldrb	w0, [x0, #68]
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40c274:	cb010273 	sub	x19, x19, x1
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c278:	9100dc00 	add	x0, x0, #0x37
  40c27c:	927df000 	and	x0, x0, #0xfffffffffffffff8
}
  40c280:	9ac00a60 	udiv	x0, x19, x0
  40c284:	f9400bf3 	ldr	x19, [sp, #16]
  40c288:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c28c:	d65f03c0 	ret

000000000040c290 <fixed_data_alloc>:
{
  40c290:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c294:	910003fd 	mov	x29, sp
  40c298:	a90153f3 	stp	x19, x20, [sp, #16]
  40c29c:	aa0003f3 	mov	x19, x0
  40c2a0:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c2a4:	39404800 	ldrb	w0, [x0, #18]
{
  40c2a8:	f90013f5 	str	x21, [sp, #32]
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c2ac:	97ffffa0 	bl	40c12c <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40c2b0:	f9402800 	ldr	x0, [x0, #80]
  40c2b4:	f9400401 	ldr	x1, [x0, #8]
	*size = MIN(fixed->data_size, *size);
  40c2b8:	f9400280 	ldr	x0, [x20]
  40c2bc:	f9400022 	ldr	x2, [x1]
  40c2c0:	eb02001f 	cmp	x0, x2
  40c2c4:	9a829000 	csel	x0, x0, x2, ls  // ls = plast
  40c2c8:	f9000280 	str	x0, [x20]
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
  40c2cc:	aa1303e0 	mov	x0, x19
  40c2d0:	a9405035 	ldp	x21, x20, [x1]
  40c2d4:	97ffffe0 	bl	40c254 <net_buf_id>
  40c2d8:	93407c00 	sxtw	x0, w0
}
  40c2dc:	9b155000 	madd	x0, x0, x21, x20
  40c2e0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c2e4:	f94013f5 	ldr	x21, [sp, #32]
  40c2e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40c2ec:	d65f03c0 	ret

000000000040c2f0 <net_buf_reset>:
{
  40c2f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c2f4:	910003fd 	mov	x29, sp
  40c2f8:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(buf->flags == 0U);
  40c2fc:	39404401 	ldrb	w1, [x0, #17]
  40c300:	34000241 	cbz	w1, 40c348 <net_buf_reset+0x58>
  40c304:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c308:	912e5a73 	add	x19, x19, #0xb96
  40c30c:	aa1303e2 	mov	x2, x19
  40c310:	52800b43 	mov	w3, #0x5a                  	// #90
  40c314:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c318:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c31c:	912ee821 	add	x1, x1, #0xbba
  40c320:	911a8800 	add	x0, x0, #0x6a2
  40c324:	97ffedd5 	bl	407a78 <assert_print>
  40c328:	aa1303e0 	mov	x0, x19
  40c32c:	52800b41 	mov	w1, #0x5a                  	// #90
  40c330:	97ffedfc 	bl	407b20 <assert_post_action>
  40c334:	52800b42 	mov	w2, #0x5a                  	// #90
	__ASSERT_NO_MSG(buf->frags == NULL);
  40c338:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c33c:	aa1303e1 	mov	x1, x19
  40c340:	911b8000 	add	x0, x0, #0x6e0
  40c344:	97fff7e9 	bl	40a2e8 <posix_print_error_and_exit>
  40c348:	f9400401 	ldr	x1, [x0, #8]
  40c34c:	b40001e1 	cbz	x1, 40c388 <net_buf_reset+0x98>
  40c350:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c354:	912e5a73 	add	x19, x19, #0xb96
  40c358:	aa1303e2 	mov	x2, x19
  40c35c:	52800b63 	mov	w3, #0x5b                  	// #91
  40c360:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c364:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c368:	912f2c21 	add	x1, x1, #0xbcb
  40c36c:	911a8800 	add	x0, x0, #0x6a2
  40c370:	97ffedc2 	bl	407a78 <assert_print>
  40c374:	aa1303e0 	mov	x0, x19
  40c378:	52800b61 	mov	w1, #0x5b                  	// #91
  40c37c:	97ffede9 	bl	407b20 <assert_post_action>
  40c380:	52800b62 	mov	w2, #0x5b                  	// #91
  40c384:	17ffffed 	b	40c338 <net_buf_reset+0x48>
	buf->data = buf->__buf;
  40c388:	f9401401 	ldr	x1, [x0, #40]
  40c38c:	f9000c01 	str	x1, [x0, #24]
	buf->len  = 0U;
  40c390:	7900401f 	strh	wzr, [x0, #32]
}
  40c394:	f9400bf3 	ldr	x19, [sp, #16]
  40c398:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c39c:	d65f03c0 	ret

000000000040c3a0 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
  40c3a0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40c3a4:	910003fd 	mov	x29, sp
  40c3a8:	a90153f3 	stp	x19, x20, [sp, #16]
  40c3ac:	aa0003f4 	mov	x20, x0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
  40c3b0:	aa0203e0 	mov	x0, x2
{
  40c3b4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c3b8:	aa0203f5 	mov	x21, x2
  40c3bc:	a90363f7 	stp	x23, x24, [sp, #48]
  40c3c0:	f90023f9 	str	x25, [sp, #64]
  40c3c4:	f9002fe1 	str	x1, [sp, #88]
	uint64_t end = sys_clock_timeout_end_calc(timeout);
  40c3c8:	94001ae0 	bl	412f48 <sys_clock_timeout_end_calc>
	struct net_buf *buf;
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(pool);
  40c3cc:	b5000254 	cbnz	x20, 40c414 <net_buf_alloc_len+0x74>
  40c3d0:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c3d4:	912e5a73 	add	x19, x19, #0xb96
  40c3d8:	aa1303e2 	mov	x2, x19
  40c3dc:	52801f03 	mov	w3, #0xf8                  	// #248
  40c3e0:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c3e4:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c3e8:	912f9421 	add	x1, x1, #0xbe5
  40c3ec:	911a8800 	add	x0, x0, #0x6a2
  40c3f0:	97ffeda2 	bl	407a78 <assert_print>
  40c3f4:	aa1303e0 	mov	x0, x19
  40c3f8:	52801f01 	mov	w1, #0xf8                  	// #248
  40c3fc:	97ffedc9 	bl	407b20 <assert_post_action>
  40c400:	52801f02 	mov	w2, #0xf8                  	// #248
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40c404:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c408:	aa1303e1 	mov	x1, x19
  40c40c:	911b8000 	add	x0, x0, #0x6e0
  40c410:	97fff7b6 	bl	40a2e8 <posix_print_error_and_exit>
  40c414:	aa0003f7 	mov	x23, x0
	NET_BUF_DBG("%s():%d: pool %p size %zu", func, line, pool, size);

	/* We need to prevent race conditions
	 * when accessing pool->uninit_count.
	 */
	key = k_spin_lock(&pool->lock);
  40c418:	9100e296 	add	x22, x20, #0x38
	return posix_irq_lock();
  40c41c:	97fff69d 	bl	409e90 <posix_irq_lock>
  40c420:	2a0003f8 	mov	w24, w0
  40c424:	aa1603e0 	mov	x0, x22
  40c428:	94000858 	bl	40e588 <z_spin_lock_valid>
  40c42c:	72001c1f 	tst	w0, #0xff
  40c430:	54000261 	b.ne	40c47c <net_buf_alloc_len+0xdc>  // b.any
  40c434:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c438:	912faa73 	add	x19, x19, #0xbea
  40c43c:	aa1303e2 	mov	x2, x19
  40c440:	52801283 	mov	w3, #0x94                  	// #148
  40c444:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c448:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c44c:	91305c21 	add	x1, x1, #0xc17
  40c450:	911a8800 	add	x0, x0, #0x6a2
  40c454:	97ffed89 	bl	407a78 <assert_print>
  40c458:	aa1603e1 	mov	x1, x22
  40c45c:	b0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40c460:	9130b000 	add	x0, x0, #0xc2c
  40c464:	97ffed85 	bl	407a78 <assert_print>
  40c468:	aa1303e0 	mov	x0, x19
  40c46c:	52801281 	mov	w1, #0x94                  	// #148
  40c470:	97ffedac 	bl	407b20 <assert_post_action>
  40c474:	52801282 	mov	w2, #0x94                  	// #148
  40c478:	17ffffe3 	b	40c404 <net_buf_alloc_len+0x64>
		arch_spin_relax();
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
  40c47c:	aa1603e0 	mov	x0, x22
  40c480:	9400085a 	bl	40e5e8 <z_spin_lock_set_owner>

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
  40c484:	79408680 	ldrh	w0, [x20, #66]
  40c488:	340009e0 	cbz	w0, 40c5c4 <net_buf_alloc_len+0x224>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
  40c48c:	79408281 	ldrh	w1, [x20, #64]
  40c490:	6b00003f 	cmp	w1, w0
  40c494:	54000609 	b.ls	40c554 <net_buf_alloc_len+0x1b4>  // b.plast
	return z_impl_k_queue_get(queue, timeout);
  40c498:	d2800001 	mov	x1, #0x0                   	// #0
  40c49c:	aa1403e0 	mov	x0, x20
  40c4a0:	94000bef 	bl	40f45c <z_impl_k_queue_get>
  40c4a4:	aa0003f3 	mov	x19, x0
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
  40c4a8:	b4000560 	cbz	x0, 40c554 <net_buf_alloc_len+0x1b4>
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40c4ac:	aa1603e0 	mov	x0, x22
  40c4b0:	94000841 	bl	40e5b4 <z_spin_unlock_valid>
  40c4b4:	72001c1f 	tst	w0, #0xff
  40c4b8:	54000261 	b.ne	40c504 <net_buf_alloc_len+0x164>  // b.any
  40c4bc:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c4c0:	912faa73 	add	x19, x19, #0xbea
  40c4c4:	aa1303e2 	mov	x2, x19
  40c4c8:	52801863 	mov	w3, #0xc3                  	// #195
  40c4cc:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c4d0:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c4d4:	91311021 	add	x1, x1, #0xc44
  40c4d8:	911a8800 	add	x0, x0, #0x6a2
  40c4dc:	97ffed67 	bl	407a78 <assert_print>
  40c4e0:	aa1603e1 	mov	x1, x22
  40c4e4:	b0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40c4e8:	91316c00 	add	x0, x0, #0xc5b
  40c4ec:	97ffed63 	bl	407a78 <assert_print>
  40c4f0:	aa1303e0 	mov	x0, x19
  40c4f4:	52801861 	mov	w1, #0xc3                  	// #195
  40c4f8:	97ffed8a 	bl	407b20 <assert_post_action>
  40c4fc:	52801862 	mov	w2, #0xc3                  	// #195
  40c500:	17ffffc1 	b	40c404 <net_buf_alloc_len+0x64>
	posix_irq_unlock(key);
  40c504:	2a1803e0 	mov	w0, w24
  40c508:	97fff664 	bl	409e98 <posix_irq_unlock>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
  40c50c:	f9402ff4 	ldr	x20, [sp, #88]
  40c510:	b4000a74 	cbz	x20, 40c65c <net_buf_alloc_len+0x2bc>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  40c514:	b40000d5 	cbz	x21, 40c52c <net_buf_alloc_len+0x18c>
  40c518:	b10006bf 	cmn	x21, #0x1
  40c51c:	54000080 	b.eq	40c52c <net_buf_alloc_len+0x18c>  // b.none
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
  40c520:	94001a40 	bl	412e20 <sys_clock_tick_get>

			if (remaining <= 0) {
  40c524:	eb0002f5 	subs	x21, x23, x0
  40c528:	9a9f52b5 	csel	x21, x21, xzr, pl  // pl = nfrst
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
  40c52c:	aa1503e2 	mov	x2, x21
  40c530:	910163e1 	add	x1, sp, #0x58
  40c534:	aa1303e0 	mov	x0, x19
  40c538:	97ffff29 	bl	40c1dc <data_alloc>
  40c53c:	f9001660 	str	x0, [x19, #40]
		if (!buf->__buf) {
  40c540:	b5000660 	cbnz	x0, 40c60c <net_buf_alloc_len+0x26c>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
  40c544:	aa1303e0 	mov	x0, x19
			return NULL;
  40c548:	d2800013 	mov	x19, #0x0                   	// #0
			net_buf_destroy(buf);
  40c54c:	97ffff38 	bl	40c22c <net_buf_destroy>
			return NULL;
  40c550:	14000028 	b	40c5f0 <net_buf_alloc_len+0x250>
		uninit_count = pool->uninit_count--;
  40c554:	79408699 	ldrh	w25, [x20, #66]
  40c558:	51000720 	sub	w0, w25, #0x1
  40c55c:	79008680 	strh	w0, [x20, #66]
  40c560:	aa1603e0 	mov	x0, x22
  40c564:	94000814 	bl	40e5b4 <z_spin_unlock_valid>
  40c568:	72001c1f 	tst	w0, #0xff
  40c56c:	54fffa80 	b.eq	40c4bc <net_buf_alloc_len+0x11c>  // b.none
  40c570:	2a1803e0 	mov	w0, w24
  40c574:	97fff649 	bl	409e98 <posix_irq_unlock>
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c578:	79408280 	ldrh	w0, [x20, #64]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c57c:	39411293 	ldrb	w19, [x20, #68]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c580:	4b190000 	sub	w0, w0, w25
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c584:	9100de73 	add	x19, x19, #0x37
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
  40c588:	f9402e81 	ldr	x1, [x20, #88]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40c58c:	93407c00 	sxtw	x0, w0
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40c590:	927df273 	and	x19, x19, #0xfffffffffffffff8
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
  40c594:	9b000673 	madd	x19, x19, x0, x1
	return pool - TYPE_SECTION_START(net_buf_pool);
  40c598:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40c59c:	b201f3e1 	mov	x1, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
  40c5a0:	f9479800 	ldr	x0, [x0, #3888]
  40c5a4:	f2955561 	movk	x1, #0xaaab
  40c5a8:	cb000280 	sub	x0, x20, x0
  40c5ac:	9345fc00 	asr	x0, x0, #5
  40c5b0:	9b017c00 	mul	x0, x0, x1
	buf->pool_id = pool_id(pool);
  40c5b4:	39004a60 	strb	w0, [x19, #18]
	buf->user_data_size = pool->user_data_size;
  40c5b8:	39411280 	ldrb	w0, [x20, #68]
  40c5bc:	39004e60 	strb	w0, [x19, #19]
		goto success;
  40c5c0:	17ffffd3 	b	40c50c <net_buf_alloc_len+0x16c>
  40c5c4:	aa1603e0 	mov	x0, x22
  40c5c8:	940007fb 	bl	40e5b4 <z_spin_unlock_valid>
  40c5cc:	72001c1f 	tst	w0, #0xff
  40c5d0:	54fff760 	b.eq	40c4bc <net_buf_alloc_len+0x11c>  // b.none
  40c5d4:	2a1803e0 	mov	w0, w24
  40c5d8:	97fff630 	bl	409e98 <posix_irq_unlock>
  40c5dc:	aa1503e1 	mov	x1, x21
  40c5e0:	aa1403e0 	mov	x0, x20
  40c5e4:	94000b9e 	bl	40f45c <z_impl_k_queue_get>
  40c5e8:	aa0003f3 	mov	x19, x0
	if (!buf) {
  40c5ec:	b5fff900 	cbnz	x0, 40c50c <net_buf_alloc_len+0x16c>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
  40c5f0:	aa1303e0 	mov	x0, x19
  40c5f4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c5f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c5fc:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c600:	f94023f9 	ldr	x25, [sp, #64]
  40c604:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40c608:	d65f03c0 	ret
		NET_BUF_ASSERT(req_size <= size);
  40c60c:	f9402fe0 	ldr	x0, [sp, #88]
  40c610:	eb00029f 	cmp	x20, x0
  40c614:	54000269 	b.ls	40c660 <net_buf_alloc_len+0x2c0>  // b.plast
  40c618:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c61c:	912e5a73 	add	x19, x19, #0xb96
  40c620:	aa1303e2 	mov	x2, x19
  40c624:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c628:	9131c021 	add	x1, x1, #0xc70
  40c62c:	52802b23 	mov	w3, #0x159                 	// #345
  40c630:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c634:	911a8800 	add	x0, x0, #0x6a2
  40c638:	97ffed10 	bl	407a78 <assert_print>
  40c63c:	b0000040 	adrp	x0, 415000 <random_data+0xd8c>
  40c640:	91320400 	add	x0, x0, #0xc81
  40c644:	97ffed0d 	bl	407a78 <assert_print>
  40c648:	aa1303e0 	mov	x0, x19
  40c64c:	52802b21 	mov	w1, #0x159                 	// #345
  40c650:	97ffed34 	bl	407b20 <assert_post_action>
  40c654:	52802b22 	mov	w2, #0x159                 	// #345
  40c658:	17ffff6b 	b	40c404 <net_buf_alloc_len+0x64>
		buf->__buf = NULL;
  40c65c:	f900167f 	str	xzr, [x19, #40]
	buf->ref   = 1U;
  40c660:	52800020 	mov	w0, #0x1                   	// #1
  40c664:	79002260 	strh	w0, [x19, #16]
	buf->size  = size;
  40c668:	f9402fe0 	ldr	x0, [sp, #88]
	buf->frags = NULL;
  40c66c:	f900067f 	str	xzr, [x19, #8]
	buf->size  = size;
  40c670:	79004660 	strh	w0, [x19, #34]
	net_buf_reset(buf);
  40c674:	aa1303e0 	mov	x0, x19
  40c678:	97ffff1e 	bl	40c2f0 <net_buf_reset>
	return buf;
  40c67c:	17ffffdd 	b	40c5f0 <net_buf_alloc_len+0x250>

000000000040c680 <net_buf_alloc_fixed>:
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40c680:	f9402802 	ldr	x2, [x0, #80]

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
  40c684:	f9400443 	ldr	x3, [x2, #8]
  40c688:	aa0103e2 	mov	x2, x1
  40c68c:	f9400061 	ldr	x1, [x3]
  40c690:	17ffff44 	b	40c3a0 <net_buf_alloc_len>

000000000040c694 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
  40c694:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c698:	910003fd 	mov	x29, sp
  40c69c:	a90153f3 	stp	x19, x20, [sp, #16]
  40c6a0:	f90013f5 	str	x21, [sp, #32]
	__ASSERT_NO_MSG(buf);
  40c6a4:	b5000240 	cbnz	x0, 40c6ec <net_buf_unref+0x58>
  40c6a8:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c6ac:	912e5a73 	add	x19, x19, #0xb96
  40c6b0:	aa1303e2 	mov	x2, x19
  40c6b4:	52803ba3 	mov	w3, #0x1dd                 	// #477
  40c6b8:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c6bc:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c6c0:	91322021 	add	x1, x1, #0xc88
  40c6c4:	911a8800 	add	x0, x0, #0x6a2
  40c6c8:	97ffecec 	bl	407a78 <assert_print>
  40c6cc:	aa1303e0 	mov	x0, x19
  40c6d0:	52803ba1 	mov	w1, #0x1dd                 	// #477
  40c6d4:	97ffed13 	bl	407b20 <assert_post_action>
  40c6d8:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c6dc:	aa1303e1 	mov	x1, x19
  40c6e0:	911b8000 	add	x0, x0, #0x6e0
  40c6e4:	52803ba2 	mov	w2, #0x1dd                 	// #477
  40c6e8:	97fff700 	bl	40a2e8 <posix_print_error_and_exit>
  40c6ec:	aa0003f4 	mov	x20, x0
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
  40c6f0:	39404280 	ldrb	w0, [x20, #16]
  40c6f4:	aa1403f3 	mov	x19, x20
		struct net_buf *frags = buf->frags;
  40c6f8:	f9400694 	ldr	x20, [x20, #8]
		if (--buf->ref > 0) {
  40c6fc:	51000400 	sub	w0, w0, #0x1
  40c700:	12001c00 	and	w0, w0, #0xff
  40c704:	39004260 	strb	w0, [x19, #16]
  40c708:	350002e0 	cbnz	w0, 40c764 <net_buf_unref+0xd0>
			return;
		}

		if (buf->__buf) {
  40c70c:	f9401675 	ldr	x21, [x19, #40]
  40c710:	b4000195 	cbz	x21, 40c740 <net_buf_unref+0xac>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40c714:	39404a60 	ldrb	w0, [x19, #18]
  40c718:	97fffe85 	bl	40c12c <net_buf_pool_get>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
  40c71c:	39404661 	ldrb	w1, [x19, #17]
  40c720:	370000e1 	tbnz	w1, #0, 40c73c <net_buf_unref+0xa8>
	pool->alloc->cb->unref(buf, data);
  40c724:	f9402800 	ldr	x0, [x0, #80]
  40c728:	aa1503e1 	mov	x1, x21
  40c72c:	f9400000 	ldr	x0, [x0]
  40c730:	f9400802 	ldr	x2, [x0, #16]
  40c734:	aa1303e0 	mov	x0, x19
  40c738:	d63f0040 	blr	x2
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
  40c73c:	f900167f 	str	xzr, [x19, #40]
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
  40c740:	39404a60 	ldrb	w0, [x19, #18]
		buf->frags = NULL;
  40c744:	f900067f 	str	xzr, [x19, #8]
		buf->data = NULL;
  40c748:	f9000e7f 	str	xzr, [x19, #24]
		pool = net_buf_pool_get(buf->pool_id);
  40c74c:	97fffe78 	bl	40c12c <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
  40c750:	f9402401 	ldr	x1, [x0, #72]
			pool->destroy(buf);
  40c754:	aa1303e0 	mov	x0, x19
		if (pool->destroy) {
  40c758:	b40000e1 	cbz	x1, 40c774 <net_buf_unref+0xe0>
			pool->destroy(buf);
  40c75c:	d63f0020 	blr	x1
	while (buf) {
  40c760:	b5fffc94 	cbnz	x20, 40c6f0 <net_buf_unref+0x5c>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
  40c764:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c768:	f94013f5 	ldr	x21, [sp, #32]
  40c76c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40c770:	d65f03c0 	ret
			net_buf_destroy(buf);
  40c774:	97fffeae 	bl	40c22c <net_buf_destroy>
  40c778:	17fffffa 	b	40c760 <net_buf_unref+0xcc>

000000000040c77c <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
  40c77c:	f9400001 	ldr	x1, [x0]
  40c780:	f9400800 	ldr	x0, [x0, #16]
}
  40c784:	cb000020 	sub	x0, x1, x0
  40c788:	d65f03c0 	ret

000000000040c78c <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
  40c78c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c790:	910003fd 	mov	x29, sp
  40c794:	a90153f3 	stp	x19, x20, [sp, #16]
  40c798:	aa0003f3 	mov	x19, x0
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
  40c79c:	79401414 	ldrh	w20, [x0, #10]
  40c7a0:	97fffff7 	bl	40c77c <net_buf_simple_headroom>
  40c7a4:	79401261 	ldrh	w1, [x19, #8]
  40c7a8:	cb010294 	sub	x20, x20, x1
}
  40c7ac:	cb000280 	sub	x0, x20, x0
  40c7b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c7b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c7b8:	d65f03c0 	ret

000000000040c7bc <net_buf_simple_add>:
{
  40c7bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c7c0:	910003fd 	mov	x29, sp
  40c7c4:	a90153f3 	stp	x19, x20, [sp, #16]
  40c7c8:	aa0103f4 	mov	x20, x1
  40c7cc:	aa0003f3 	mov	x19, x0
  40c7d0:	f90013f5 	str	x21, [sp, #32]
	return buf->data + buf->len;
  40c7d4:	79401001 	ldrh	w1, [x0, #8]
  40c7d8:	f9400015 	ldr	x21, [x0]
  40c7dc:	8b0102b5 	add	x21, x21, x1
	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
  40c7e0:	97ffffeb 	bl	40c78c <net_buf_simple_tailroom>
  40c7e4:	eb14001f 	cmp	x0, x20
  40c7e8:	54000242 	b.cs	40c830 <net_buf_simple_add+0x74>  // b.hs, b.nlast
  40c7ec:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c7f0:	91323273 	add	x19, x19, #0xc8c
  40c7f4:	aa1303e2 	mov	x2, x19
  40c7f8:	528007c3 	mov	w3, #0x3e                  	// #62
  40c7fc:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c800:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c804:	91331821 	add	x1, x1, #0xcc6
  40c808:	911a8800 	add	x0, x0, #0x6a2
  40c80c:	97ffec9b 	bl	407a78 <assert_print>
  40c810:	aa1303e0 	mov	x0, x19
  40c814:	528007c1 	mov	w1, #0x3e                  	// #62
  40c818:	97ffecc2 	bl	407b20 <assert_post_action>
  40c81c:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c820:	aa1303e1 	mov	x1, x19
  40c824:	911b8000 	add	x0, x0, #0x6e0
  40c828:	528007c2 	mov	w2, #0x3e                  	// #62
  40c82c:	97fff6af 	bl	40a2e8 <posix_print_error_and_exit>
	buf->len += len;
  40c830:	79401260 	ldrh	w0, [x19, #8]
  40c834:	0b140000 	add	w0, w0, w20
  40c838:	79001260 	strh	w0, [x19, #8]
}
  40c83c:	aa1503e0 	mov	x0, x21
  40c840:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c844:	f94013f5 	ldr	x21, [sp, #32]
  40c848:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40c84c:	d65f03c0 	ret

000000000040c850 <net_buf_simple_add_mem>:
{
  40c850:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c854:	910003fd 	mov	x29, sp
  40c858:	a90153f3 	stp	x19, x20, [sp, #16]
  40c85c:	aa0103f4 	mov	x20, x1
  40c860:	aa0203f3 	mov	x19, x2
	return memcpy(net_buf_simple_add(buf, len), mem, len);
  40c864:	aa0203e1 	mov	x1, x2
  40c868:	97ffffd5 	bl	40c7bc <net_buf_simple_add>
  40c86c:	aa1303e2 	mov	x2, x19
  40c870:	aa1403e1 	mov	x1, x20
}
  40c874:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c878:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c87c:	17ffd23d 	b	401170 <memcpy@plt>

000000000040c880 <can_tx_default_cb>:
	struct k_sem done;
	int status;
};

static void can_tx_default_cb(const struct device *dev, int error, void *user_data)
{
  40c880:	aa0203e0 	mov	x0, x2
	struct can_tx_default_cb_ctx *ctx = user_data;

	ctx->status = error;
  40c884:	b9002841 	str	w1, [x2, #40]
	z_impl_k_sem_give(sem);
  40c888:	14000b5c 	b	40f5f8 <z_impl_k_sem_give>

000000000040c88c <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40c88c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40c890:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40c894:	910003fd 	mov	x29, sp
  40c898:	f9476800 	ldr	x0, [x0, #3792]
  40c89c:	3d8023e0 	str	q0, [sp, #128]
  40c8a0:	3d8027e1 	str	q1, [sp, #144]
  40c8a4:	3d802be2 	str	q2, [sp, #160]
  40c8a8:	3d802fe3 	str	q3, [sp, #176]
  40c8ac:	3d8033e4 	str	q4, [sp, #192]
  40c8b0:	3d8037e5 	str	q5, [sp, #208]
  40c8b4:	3d803be6 	str	q6, [sp, #224]
  40c8b8:	3d803fe7 	str	q7, [sp, #240]
  40c8bc:	f90087e7 	str	x7, [sp, #264]
  40c8c0:	f9400002 	ldr	x2, [x0]
  40c8c4:	f9003fe2 	str	x2, [sp, #120]
  40c8c8:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40c8cc:	910443e0 	add	x0, sp, #0x110
  40c8d0:	a90383e0 	stp	x0, x0, [sp, #56]
  40c8d4:	910403e0 	add	x0, sp, #0x100
  40c8d8:	9100e3e2 	add	x2, sp, #0x38
  40c8dc:	f90027e0 	str	x0, [sp, #72]
  40c8e0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40c8e4:	b90053e0 	str	w0, [sp, #80]
  40c8e8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40c8ec:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40c8f0:	910163e0 	add	x0, sp, #0x58
  40c8f4:	ad400440 	ldp	q0, q1, [x2]
  40c8f8:	ad000400 	stp	q0, q1, [x0]
  40c8fc:	ad400400 	ldp	q0, q1, [x0]
  40c900:	910043e7 	add	x7, sp, #0x10
  40c904:	52800022 	mov	w2, #0x1                   	// #1
  40c908:	52800000 	mov	w0, #0x0                   	// #0
  40c90c:	b0000046 	adrp	x6, 415000 <random_data+0xd8c>
  40c910:	52800005 	mov	w5, #0x0                   	// #0
  40c914:	9133e4c6 	add	x6, x6, #0xcf9
  40c918:	d2800004 	mov	x4, #0x0                   	// #0
  40c91c:	d2800003 	mov	x3, #0x0                   	// #0
  40c920:	ad0004e0 	stp	q0, q1, [x7]
  40c924:	97ffee35 	bl	4081f8 <z_impl_z_log_msg_runtime_vcreate>
}
  40c928:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40c92c:	f9476800 	ldr	x0, [x0, #3792]
  40c930:	f9403fe2 	ldr	x2, [sp, #120]
  40c934:	f9400001 	ldr	x1, [x0]
  40c938:	eb010042 	subs	x2, x2, x1
  40c93c:	d2800001 	mov	x1, #0x0                   	// #0
  40c940:	54000040 	b.eq	40c948 <z_log_msg_runtime_create.constprop.0+0xbc>  // b.none
  40c944:	97ffd277 	bl	401320 <__stack_chk_fail@plt>
  40c948:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40c94c:	d65f03c0 	ret

000000000040c950 <can_msgq_put>:

	return api->send(dev, frame, timeout, callback, user_data);
}

static void can_msgq_put(const struct device *dev, struct can_frame *frame, void *user_data)
{
  40c950:	d100c3ff 	sub	sp, sp, #0x30
  40c954:	a9017bfd 	stp	x29, x30, [sp, #16]
  40c958:	910043fd 	add	x29, sp, #0x10
  40c95c:	a90253f3 	stp	x19, x20, [sp, #32]
	struct k_msgq *msgq = (struct k_msgq *)user_data;
	int ret;

	ARG_UNUSED(dev);

	__ASSERT_NO_MSG(msgq);
  40c960:	b5000242 	cbnz	x2, 40c9a8 <can_msgq_put+0x58>
  40c964:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40c968:	91347273 	add	x19, x19, #0xd1c
  40c96c:	aa1303e2 	mov	x2, x19
  40c970:	52800823 	mov	w3, #0x41                  	// #65
  40c974:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40c978:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c97c:	91352021 	add	x1, x1, #0xd48
  40c980:	911a8800 	add	x0, x0, #0x6a2
  40c984:	97ffec3d 	bl	407a78 <assert_print>
  40c988:	aa1303e0 	mov	x0, x19
  40c98c:	52800821 	mov	w1, #0x41                  	// #65
  40c990:	97ffec64 	bl	407b20 <assert_post_action>
  40c994:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40c998:	aa1303e1 	mov	x1, x19
  40c99c:	911b8000 	add	x0, x0, #0x6e0
  40c9a0:	52800822 	mov	w2, #0x41                  	// #65
  40c9a4:	97fff651 	bl	40a2e8 <posix_print_error_and_exit>
  40c9a8:	aa0103f4 	mov	x20, x1
  40c9ac:	aa0203f3 	mov	x19, x2
	return z_impl_k_msgq_put(msgq, data, timeout);
  40c9b0:	d2800002 	mov	x2, #0x0                   	// #0
  40c9b4:	aa1303e0 	mov	x0, x19
  40c9b8:	94000751 	bl	40e6fc <z_impl_k_msgq_put>

	ret = k_msgq_put(msgq, frame, K_NO_WAIT);
	if (ret) {
  40c9bc:	340001e0 	cbz	w0, 40c9f8 <can_msgq_put+0xa8>
		LOG_ERR("Msgq %p overflowed. Frame ID: 0x%x", msgq, frame->id);
  40c9c0:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40c9c4:	b9400280 	ldr	w0, [x20]
  40c9c8:	b0000046 	adrp	x6, 415000 <random_data+0xd8c>
  40c9cc:	aa1303e7 	mov	x7, x19
  40c9d0:	f9473421 	ldr	x1, [x1, #3688]
  40c9d4:	d3407000 	ubfx	x0, x0, #0, #29
  40c9d8:	b90003e0 	str	w0, [sp]
  40c9dc:	9133e4c6 	add	x6, x6, #0xcf9
  40c9e0:	52800005 	mov	w5, #0x0                   	// #0
  40c9e4:	d2800004 	mov	x4, #0x0                   	// #0
  40c9e8:	d2800003 	mov	x3, #0x0                   	// #0
  40c9ec:	52800022 	mov	w2, #0x1                   	// #1
  40c9f0:	52800000 	mov	w0, #0x0                   	// #0
  40c9f4:	97ffffa6 	bl	40c88c <z_log_msg_runtime_create.constprop.0>
	}
}
  40c9f8:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40c9fc:	a94253f3 	ldp	x19, x20, [sp, #32]
  40ca00:	9100c3ff 	add	sp, sp, #0x30
  40ca04:	d65f03c0 	ret

000000000040ca08 <z_impl_can_send>:
{
  40ca08:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40ca0c:	f00000e5 	adrp	x5, 42b000 <__FRAME_END__+0x1007c>
  40ca10:	910003fd 	mov	x29, sp
  40ca14:	f94768a5 	ldr	x5, [x5, #3792]
  40ca18:	a90153f3 	stp	x19, x20, [sp, #16]
  40ca1c:	f00000f3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  40ca20:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ca24:	a90363f7 	stp	x23, x24, [sp, #48]
  40ca28:	f94000a6 	ldr	x6, [x5]
  40ca2c:	f9003fe6 	str	x6, [sp, #120]
  40ca30:	d2800006 	mov	x6, #0x0                   	// #0
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  40ca34:	f9400818 	ldr	x24, [x0, #16]
	if (callback == NULL) {
  40ca38:	b5000423 	cbnz	x3, 40cabc <z_impl_can_send+0xb4>
  40ca3c:	aa0003f4 	mov	x20, x0
  40ca40:	aa0103f6 	mov	x22, x1
  40ca44:	aa0203f7 	mov	x23, x2
	return z_impl_k_sem_init(sem, initial_count, limit);
  40ca48:	910123f5 	add	x21, sp, #0x48
  40ca4c:	52800022 	mov	w2, #0x1                   	// #1
  40ca50:	52800001 	mov	w1, #0x0                   	// #0
  40ca54:	aa1503e0 	mov	x0, x21
  40ca58:	94000add 	bl	40f5cc <z_impl_k_sem_init>
		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
  40ca5c:	f9401705 	ldr	x5, [x24, #40]
  40ca60:	90000003 	adrp	x3, 40c000 <ztest_relative_filename+0x74>
  40ca64:	aa1503e4 	mov	x4, x21
  40ca68:	91220063 	add	x3, x3, #0x880
  40ca6c:	aa1703e2 	mov	x2, x23
  40ca70:	aa1603e1 	mov	x1, x22
  40ca74:	aa1403e0 	mov	x0, x20
  40ca78:	d63f00a0 	blr	x5
		if (err != 0) {
  40ca7c:	350000a0 	cbnz	w0, 40ca90 <z_impl_can_send+0x88>
	return z_impl_k_sem_take(sem, timeout);
  40ca80:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40ca84:	aa1503e0 	mov	x0, x21
  40ca88:	94000b13 	bl	40f6d4 <z_impl_k_sem_take>
		return ctx.status;
  40ca8c:	b94073e0 	ldr	w0, [sp, #112]
}
  40ca90:	f9476a73 	ldr	x19, [x19, #3792]
  40ca94:	f9403fe1 	ldr	x1, [sp, #120]
  40ca98:	f9400262 	ldr	x2, [x19]
  40ca9c:	eb020021 	subs	x1, x1, x2
  40caa0:	d2800002 	mov	x2, #0x0                   	// #0
  40caa4:	54000181 	b.ne	40cad4 <z_impl_can_send+0xcc>  // b.any
  40caa8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40caac:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40cab0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40cab4:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40cab8:	d65f03c0 	ret
	return api->send(dev, frame, timeout, callback, user_data);
  40cabc:	f9476a73 	ldr	x19, [x19, #3792]
  40cac0:	f9403fe5 	ldr	x5, [sp, #120]
  40cac4:	f9400266 	ldr	x6, [x19]
  40cac8:	eb0600a5 	subs	x5, x5, x6
  40cacc:	d2800006 	mov	x6, #0x0                   	// #0
  40cad0:	54000040 	b.eq	40cad8 <z_impl_can_send+0xd0>  // b.none
}
  40cad4:	97ffd213 	bl	401320 <__stack_chk_fail@plt>
  40cad8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cadc:	a9425bf5 	ldp	x21, x22, [sp, #32]
	return api->send(dev, frame, timeout, callback, user_data);
  40cae0:	f9401705 	ldr	x5, [x24, #40]
}
  40cae4:	a94363f7 	ldp	x23, x24, [sp, #48]
	return api->send(dev, frame, timeout, callback, user_data);
  40cae8:	aa0503f0 	mov	x16, x5
}
  40caec:	a8c87bfd 	ldp	x29, x30, [sp], #128
	return api->send(dev, frame, timeout, callback, user_data);
  40caf0:	d61f0200 	br	x16

000000000040caf4 <z_impl_can_add_rx_filter_msgq>:
int z_impl_can_add_rx_filter_msgq(const struct device *dev, struct k_msgq *msgq,
				  const struct can_filter *filter)
{
	const struct can_driver_api *api = dev->api;

	return api->add_rx_filter(dev, can_msgq_put, msgq, filter);
  40caf4:	f9400803 	ldr	x3, [x0, #16]
  40caf8:	f9401864 	ldr	x4, [x3, #48]
  40cafc:	aa0203e3 	mov	x3, x2
  40cb00:	aa0103e2 	mov	x2, x1
  40cb04:	90000001 	adrp	x1, 40c000 <ztest_relative_filename+0x74>
  40cb08:	aa0403f0 	mov	x16, x4
  40cb0c:	91254021 	add	x1, x1, #0x950
  40cb10:	d61f0200 	br	x16

000000000040cb14 <can_loopback_get_capabilities>:
	ARG_UNUSED(dev);

	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK;

#if CONFIG_CAN_FD_MODE
	*cap |= CAN_MODE_FD;
  40cb14:	528000a0 	mov	w0, #0x5                   	// #5
  40cb18:	b9000020 	str	w0, [x1]
#endif /* CONFIG_CAN_FD_MODE */

	return 0;
}
  40cb1c:	52800000 	mov	w0, #0x0                   	// #0
  40cb20:	d65f03c0 	ret

000000000040cb24 <can_loopback_start>:

static int can_loopback_start(const struct device *dev)
{
	struct can_loopback_data *data = dev->data;
  40cb24:	f9401000 	ldr	x0, [x0, #32]

	if (data->started) {
  40cb28:	39632001 	ldrb	w1, [x0, #2248]
  40cb2c:	350000a1 	cbnz	w1, 40cb40 <can_loopback_start+0x1c>
		return -EALREADY;
	}

	data->started = true;
  40cb30:	52800021 	mov	w1, #0x1                   	// #1
  40cb34:	39232001 	strb	w1, [x0, #2248]

	return 0;
  40cb38:	52800000 	mov	w0, #0x0                   	// #0
}
  40cb3c:	d65f03c0 	ret
		return -EALREADY;
  40cb40:	12800e20 	mov	w0, #0xffffff8e            	// #-114
  40cb44:	17fffffe 	b	40cb3c <can_loopback_start+0x18>

000000000040cb48 <can_loopback_set_timing>:
{
	struct can_loopback_data *data = dev->data;

	ARG_UNUSED(timing);

	if (data->started) {
  40cb48:	f9401000 	ldr	x0, [x0, #32]
  40cb4c:	39632000 	ldrb	w0, [x0, #2248]
		return -EBUSY;
  40cb50:	7100001f 	cmp	w0, #0x0
	}

	return 0;
}
  40cb54:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40cb58:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40cb5c:	d65f03c0 	ret

000000000040cb60 <can_loopback_get_state>:
static int can_loopback_get_state(const struct device *dev, enum can_state *state,
				  struct can_bus_err_cnt *err_cnt)
{
	struct can_loopback_data *data = dev->data;

	if (state != NULL) {
  40cb60:	b40000e1 	cbz	x1, 40cb7c <can_loopback_get_state+0x1c>
		if (data->started) {
  40cb64:	f9401000 	ldr	x0, [x0, #32]
  40cb68:	39632000 	ldrb	w0, [x0, #2248]
			*state = CAN_STATE_ERROR_ACTIVE;
  40cb6c:	7100001f 	cmp	w0, #0x0
  40cb70:	52800080 	mov	w0, #0x4                   	// #4
  40cb74:	1a8013e0 	csel	w0, wzr, w0, ne  // ne = any
  40cb78:	b9000020 	str	w0, [x1]
		} else {
			*state = CAN_STATE_STOPPED;
		}
	}

	if (err_cnt) {
  40cb7c:	b4000042 	cbz	x2, 40cb84 <can_loopback_get_state+0x24>
		err_cnt->tx_err_cnt = 0;
  40cb80:	7900005f 	strh	wzr, [x2]
		err_cnt->rx_err_cnt = 0;
	}

	return 0;
}
  40cb84:	52800000 	mov	w0, #0x0                   	// #0
  40cb88:	d65f03c0 	ret

000000000040cb8c <can_loopback_set_state_change_callback>:
						   void *user_data)
{
	ARG_UNUSED(dev);
	ARG_UNUSED(cb);
	ARG_UNUSED(user_data);
}
  40cb8c:	d65f03c0 	ret

000000000040cb90 <can_loopback_get_core_clock>:

static int can_loopback_get_core_clock(const struct device *dev, uint32_t *rate)
{
	/* Return 16MHz as an realistic value for the testcases */
	*rate = 16000000;
  40cb90:	52848000 	mov	w0, #0x2400                	// #9216
  40cb94:	72a01e80 	movk	w0, #0xf4, lsl #16
  40cb98:	b9000020 	str	w0, [x1]
	return 0;
}
  40cb9c:	52800000 	mov	w0, #0x0                   	// #0
  40cba0:	d65f03c0 	ret

000000000040cba4 <can_loopback_get_max_filters>:
static int can_loopback_get_max_filters(const struct device *dev, bool ide)
{
	ARG_UNUSED(ide);

	return CONFIG_CAN_MAX_FILTER;
}
  40cba4:	52800200 	mov	w0, #0x10                  	// #16
  40cba8:	d65f03c0 	ret

000000000040cbac <can_loopback_stop>:
	struct can_loopback_data *data = dev->data;
  40cbac:	f9401000 	ldr	x0, [x0, #32]
	if (!data->started) {
  40cbb0:	39632001 	ldrb	w1, [x0, #2248]
  40cbb4:	34000121 	cbz	w1, 40cbd8 <can_loopback_stop+0x2c>
{
  40cbb8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40cbbc:	910003fd 	mov	x29, sp
	data->started = false;
  40cbc0:	3923201f 	strb	wzr, [x0, #2248]
	z_impl_k_msgq_purge(msgq);
  40cbc4:	91088000 	add	x0, x0, #0x220
  40cbc8:	94000820 	bl	40ec48 <z_impl_k_msgq_purge>
	return 0;
  40cbcc:	52800000 	mov	w0, #0x0                   	// #0
}
  40cbd0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40cbd4:	d65f03c0 	ret
		return -EALREADY;
  40cbd8:	12800e20 	mov	w0, #0xffffff8e            	// #-114
}
  40cbdc:	d65f03c0 	ret

000000000040cbe0 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40cbe0:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40cbe4:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40cbe8:	12001c42 	and	w2, w2, #0xff
  40cbec:	910003fd 	mov	x29, sp
  40cbf0:	f9476800 	ldr	x0, [x0, #3792]
  40cbf4:	3d8023e0 	str	q0, [sp, #128]
  40cbf8:	3d8027e1 	str	q1, [sp, #144]
  40cbfc:	3d802be2 	str	q2, [sp, #160]
  40cc00:	3d802fe3 	str	q3, [sp, #176]
  40cc04:	3d8033e4 	str	q4, [sp, #192]
  40cc08:	3d8037e5 	str	q5, [sp, #208]
  40cc0c:	3d803be6 	str	q6, [sp, #224]
  40cc10:	3d803fe7 	str	q7, [sp, #240]
  40cc14:	f90087e7 	str	x7, [sp, #264]
  40cc18:	f9400003 	ldr	x3, [x0]
  40cc1c:	f9003fe3 	str	x3, [sp, #120]
  40cc20:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(ap, fmt);
  40cc24:	910443e0 	add	x0, sp, #0x110
  40cc28:	a90383e0 	stp	x0, x0, [sp, #56]
  40cc2c:	910403e0 	add	x0, sp, #0x100
  40cc30:	9100e3e3 	add	x3, sp, #0x38
  40cc34:	f90027e0 	str	x0, [sp, #72]
  40cc38:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40cc3c:	b90053e0 	str	w0, [sp, #80]
  40cc40:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40cc44:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40cc48:	910163e0 	add	x0, sp, #0x58
  40cc4c:	ad400460 	ldp	q0, q1, [x3]
  40cc50:	ad000400 	stp	q0, q1, [x0]
  40cc54:	ad400400 	ldp	q0, q1, [x0]
  40cc58:	910043e7 	add	x7, sp, #0x10
  40cc5c:	52800000 	mov	w0, #0x0                   	// #0
  40cc60:	52800005 	mov	w5, #0x0                   	// #0
  40cc64:	d2800004 	mov	x4, #0x0                   	// #0
  40cc68:	d2800003 	mov	x3, #0x0                   	// #0
  40cc6c:	ad0004e0 	stp	q0, q1, [x7]
  40cc70:	97ffed62 	bl	4081f8 <z_impl_z_log_msg_runtime_vcreate>
}
  40cc74:	f00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40cc78:	f9476800 	ldr	x0, [x0, #3792]
  40cc7c:	f9403fe2 	ldr	x2, [sp, #120]
  40cc80:	f9400001 	ldr	x1, [x0]
  40cc84:	eb010042 	subs	x2, x2, x1
  40cc88:	d2800001 	mov	x1, #0x0                   	// #0
  40cc8c:	54000040 	b.eq	40cc94 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40cc90:	97ffd1a4 	bl	401320 <__stack_chk_fail@plt>
  40cc94:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40cc98:	d65f03c0 	ret

000000000040cc9c <can_loopback_send>:
{
  40cc9c:	d10243ff 	sub	sp, sp, #0x90
  40cca0:	aa0103e5 	mov	x5, x1
  40cca4:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40cca8:	a9017bfd 	stp	x29, x30, [sp, #16]
  40ccac:	910043fd 	add	x29, sp, #0x10
  40ccb0:	f9476821 	ldr	x1, [x1, #3792]
  40ccb4:	f90013f3 	str	x19, [sp, #32]
  40ccb8:	f9400026 	ldr	x6, [x1]
  40ccbc:	f90047e6 	str	x6, [sp, #136]
  40ccc0:	d2800006 	mov	x6, #0x0                   	// #0
	struct can_loopback_data *data = dev->data;
  40ccc4:	f9401000 	ldr	x0, [x0, #32]
	__ASSERT_NO_MSG(callback != NULL);
  40ccc8:	b5000243 	cbnz	x3, 40cd10 <can_loopback_send+0x74>
  40cccc:	b0000053 	adrp	x19, 415000 <random_data+0xd8c>
  40ccd0:	91356273 	add	x19, x19, #0xd58
  40ccd4:	aa1303e2 	mov	x2, x19
  40ccd8:	52800d83 	mov	w3, #0x6c                  	// #108
  40ccdc:	b0000041 	adrp	x1, 415000 <random_data+0xd8c>
  40cce0:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40cce4:	91361821 	add	x1, x1, #0xd86
  40cce8:	911a8800 	add	x0, x0, #0x6a2
  40ccec:	97ffeb63 	bl	407a78 <assert_print>
  40ccf0:	aa1303e0 	mov	x0, x19
  40ccf4:	52800d81 	mov	w1, #0x6c                  	// #108
  40ccf8:	97ffeb8a 	bl	407b20 <assert_post_action>
  40ccfc:	90000040 	adrp	x0, 414000 <__func__.1+0xd>
  40cd00:	aa1303e1 	mov	x1, x19
  40cd04:	911b8000 	add	x0, x0, #0x6e0
  40cd08:	52800d82 	mov	w2, #0x6c                  	// #108
  40cd0c:	97fff577 	bl	40a2e8 <posix_print_error_and_exit>
	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR |
  40cd10:	394014a1 	ldrb	w1, [x5, #5]
  40cd14:	394014a7 	ldrb	w7, [x5, #5]
  40cd18:	f27c0c3f 	tst	x1, #0xf0
  40cd1c:	540001a0 	b.eq	40cd50 <can_loopback_send+0xb4>  // b.none
		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
  40cd20:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40cd24:	b0000046 	adrp	x6, 415000 <random_data+0xd8c>
  40cd28:	52800005 	mov	w5, #0x0                   	// #0
  40cd2c:	913678c6 	add	x6, x6, #0xd9e
  40cd30:	f9474c21 	ldr	x1, [x1, #3736]
  40cd34:	d2800004 	mov	x4, #0x0                   	// #0
  40cd38:	d2800003 	mov	x3, #0x0                   	// #0
  40cd3c:	52800022 	mov	w2, #0x1                   	// #1
  40cd40:	52800000 	mov	w0, #0x0                   	// #0
  40cd44:	97ffffa7 	bl	40cbe0 <z_log_msg_runtime_create.constprop.0>
			return -ENOTSUP;
  40cd48:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
  40cd4c:	14000014 	b	40cd9c <can_loopback_send+0x100>
	if ((frame->flags & CAN_FRAME_FDF) != 0) {
  40cd50:	36100367 	tbz	w7, #2, 40cdbc <can_loopback_send+0x120>
		if (!data->fd) {
  40cd54:	39632801 	ldrb	w1, [x0, #2250]
  40cd58:	34ffff81 	cbz	w1, 40cd48 <can_loopback_send+0xac>
		max_dlc = CANFD_MAX_DLC;
  40cd5c:	528001e1 	mov	w1, #0xf                   	// #15
	if (frame->dlc > max_dlc) {
  40cd60:	394010a7 	ldrb	w7, [x5, #4]
  40cd64:	6b0100ff 	cmp	w7, w1
  40cd68:	540002e9 	b.ls	40cdc4 <can_loopback_send+0x128>  // b.plast
		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, max_dlc);
  40cd6c:	b90003e1 	str	w1, [sp]
  40cd70:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40cd74:	52800000 	mov	w0, #0x0                   	// #0
  40cd78:	b0000046 	adrp	x6, 415000 <random_data+0xd8c>
  40cd7c:	f9474c21 	ldr	x1, [x1, #3736]
  40cd80:	913704c6 	add	x6, x6, #0xdc1
  40cd84:	52800005 	mov	w5, #0x0                   	// #0
  40cd88:	d2800004 	mov	x4, #0x0                   	// #0
  40cd8c:	d2800003 	mov	x3, #0x0                   	// #0
  40cd90:	52800022 	mov	w2, #0x1                   	// #1
  40cd94:	97ffff93 	bl	40cbe0 <z_log_msg_runtime_create.constprop.0>
		return -EINVAL;
  40cd98:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  40cd9c:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40cda0:	f9476821 	ldr	x1, [x1, #3792]
  40cda4:	f94047e3 	ldr	x3, [sp, #136]
  40cda8:	f9400022 	ldr	x2, [x1]
  40cdac:	eb020063 	subs	x3, x3, x2
  40cdb0:	d2800002 	mov	x2, #0x0                   	// #0
  40cdb4:	540002c0 	b.eq	40ce0c <can_loopback_send+0x170>  // b.none
  40cdb8:	97ffd15a 	bl	401320 <__stack_chk_fail@plt>
	uint8_t max_dlc = CAN_MAX_DLC;
  40cdbc:	52800101 	mov	w1, #0x8                   	// #8
  40cdc0:	17ffffe8 	b	40cd60 <can_loopback_send+0xc4>
	if (!data->started) {
  40cdc4:	39632001 	ldrb	w1, [x0, #2248]
  40cdc8:	340001e1 	cbz	w1, 40ce04 <can_loopback_send+0x168>
	loopback_frame.frame = *frame;
  40cdcc:	ad4004a0 	ldp	q0, q1, [x5]
  40cdd0:	9100c3e1 	add	x1, sp, #0x30
	loopback_frame.cb_arg = user_data;
  40cdd4:	a90793e3 	stp	x3, x4, [sp, #120]
	loopback_frame.frame = *frame;
  40cdd8:	ad000420 	stp	q0, q1, [x1]
  40cddc:	ad4104a0 	ldp	q0, q1, [x5, #32]
  40cde0:	f94020a5 	ldr	x5, [x5, #64]
  40cde4:	f9002025 	str	x5, [x1, #64]
  40cde8:	ad010420 	stp	q0, q1, [x1, #32]
	return z_impl_k_msgq_put(msgq, data, timeout);
  40cdec:	91088000 	add	x0, x0, #0x220
  40cdf0:	94000643 	bl	40e6fc <z_impl_k_msgq_put>
		return -EAGAIN;
  40cdf4:	7100001f 	cmp	w0, #0x0
  40cdf8:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40cdfc:	1a80a3e0 	csel	w0, wzr, w0, ge  // ge = tcont
  40ce00:	17ffffe7 	b	40cd9c <can_loopback_send+0x100>
		return -ENETDOWN;
  40ce04:	12800c60 	mov	w0, #0xffffff9c            	// #-100
  40ce08:	17ffffe5 	b	40cd9c <can_loopback_send+0x100>
}
  40ce0c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40ce10:	f94013f3 	ldr	x19, [sp, #32]
  40ce14:	910243ff 	add	sp, sp, #0x90
  40ce18:	d65f03c0 	ret

000000000040ce1c <can_loopback_set_mode>:
	struct can_loopback_data *data = dev->data;
  40ce1c:	f9401000 	ldr	x0, [x0, #32]
{
  40ce20:	2a0103e7 	mov	w7, w1
	if (data->started) {
  40ce24:	39632001 	ldrb	w1, [x0, #2248]
  40ce28:	35000321 	cbnz	w1, 40ce8c <can_loopback_set_mode+0x70>
	if ((mode & ~(CAN_MODE_LOOPBACK | CAN_MODE_FD)) != 0) {
  40ce2c:	927f78e1 	and	x1, x7, #0xfffffffe
  40ce30:	927df821 	and	x1, x1, #0xfffffffffffffffb
  40ce34:	b4000201 	cbz	x1, 40ce74 <can_loopback_set_mode+0x58>
{
  40ce38:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40ce3c:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40ce40:	52800005 	mov	w5, #0x0                   	// #0
{
  40ce44:	910003fd 	mov	x29, sp
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40ce48:	f9474c21 	ldr	x1, [x1, #3736]
  40ce4c:	d2800004 	mov	x4, #0x0                   	// #0
  40ce50:	d2800003 	mov	x3, #0x0                   	// #0
  40ce54:	52800022 	mov	w2, #0x1                   	// #1
  40ce58:	52800000 	mov	w0, #0x0                   	// #0
  40ce5c:	b0000046 	adrp	x6, 415000 <random_data+0xd8c>
  40ce60:	913780c6 	add	x6, x6, #0xde0
  40ce64:	97ffff5f 	bl	40cbe0 <z_log_msg_runtime_create.constprop.0>
  40ce68:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40ce6c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40ce70:	d65f03c0 	ret
	data->fd = (mode & CAN_MODE_FD) != 0;
  40ce74:	d34208e1 	ubfx	x1, x7, #2, #1
	data->loopback = (mode & CAN_MODE_LOOPBACK) != 0;
  40ce78:	120000e7 	and	w7, w7, #0x1
  40ce7c:	39232407 	strb	w7, [x0, #2249]
	data->fd = (mode & CAN_MODE_FD) != 0;
  40ce80:	39232801 	strb	w1, [x0, #2250]
	return 0;
  40ce84:	52800000 	mov	w0, #0x0                   	// #0
  40ce88:	d65f03c0 	ret
		return -EBUSY;
  40ce8c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
  40ce90:	d65f03c0 	ret

000000000040ce94 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
  40ce94:	14000858 	b	40eff4 <z_impl_k_mutex_unlock>

000000000040ce98 <can_loopback_remove_rx_filter>:
{
  40ce98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ce9c:	910003fd 	mov	x29, sp
  40cea0:	a90153f3 	stp	x19, x20, [sp, #16]
  40cea4:	2a0103f3 	mov	w19, w1
  40cea8:	f90013f5 	str	x21, [sp, #32]
	struct can_loopback_data *data = dev->data;
  40ceac:	f9401015 	ldr	x21, [x0, #32]
	if (filter_id >= ARRAY_SIZE(data->filters)) {
  40ceb0:	71003c3f 	cmp	w1, #0xf
  40ceb4:	540001e9 	b.ls	40cef0 <can_loopback_remove_rx_filter+0x58>  // b.plast
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40ceb8:	2a0103e7 	mov	w7, w1
  40cebc:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
}
  40cec0:	a94153f3 	ldp	x19, x20, [sp, #16]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40cec4:	b0000046 	adrp	x6, 415000 <random_data+0xd8c>
}
  40cec8:	f94013f5 	ldr	x21, [sp, #32]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40cecc:	9137e4c6 	add	x6, x6, #0xdf9
}
  40ced0:	a8c37bfd 	ldp	x29, x30, [sp], #48
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40ced4:	52800005 	mov	w5, #0x0                   	// #0
  40ced8:	f9474c21 	ldr	x1, [x1, #3736]
  40cedc:	d2800004 	mov	x4, #0x0                   	// #0
  40cee0:	d2800003 	mov	x3, #0x0                   	// #0
  40cee4:	52800022 	mov	w2, #0x1                   	// #1
  40cee8:	52800000 	mov	w0, #0x0                   	// #0
  40ceec:	17ffff3d 	b	40cbe0 <z_log_msg_runtime_create.constprop.0>
	k_mutex_lock(&data->mtx, K_FOREVER);
  40cef0:	910802b4 	add	x20, x21, #0x200
	data->filters[filter_id].rx_cb = NULL;
  40cef4:	937b7e73 	sbfiz	x19, x19, #5, #32
	return z_impl_k_mutex_lock(mutex, timeout);
  40cef8:	aa1403e0 	mov	x0, x20
  40cefc:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40cf00:	94000791 	bl	40ed44 <z_impl_k_mutex_lock>
	k_mutex_unlock(&data->mtx);
  40cf04:	aa1403e0 	mov	x0, x20
	data->filters[filter_id].rx_cb = NULL;
  40cf08:	f8336abf 	str	xzr, [x21, x19]
}
  40cf0c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cf10:	f94013f5 	ldr	x21, [sp, #32]
  40cf14:	a8c37bfd 	ldp	x29, x30, [sp], #48
	k_mutex_unlock(&data->mtx);
  40cf18:	17ffffdf 	b	40ce94 <k_mutex_unlock.isra.0>

000000000040cf1c <can_loopback_init>:
	},
#endif /* CONFIG_CAN_FD_MODE */
};

static int can_loopback_init(const struct device *dev)
{
  40cf1c:	d10103ff 	sub	sp, sp, #0x40
  40cf20:	a9017bfd 	stp	x29, x30, [sp, #16]
  40cf24:	910043fd 	add	x29, sp, #0x10
  40cf28:	a90253f3 	stp	x19, x20, [sp, #32]
  40cf2c:	aa0003f4 	mov	x20, x0
	struct can_loopback_data *data = dev->data;
  40cf30:	f9401013 	ldr	x19, [x0, #32]
{
  40cf34:	f9001bf5 	str	x21, [sp, #48]
	k_tid_t tx_tid;

	k_mutex_init(&data->mtx);
  40cf38:	91080275 	add	x21, x19, #0x200
	return z_impl_k_mutex_init(mutex);
  40cf3c:	aa1503e0 	mov	x0, x21
  40cf40:	9400077c 	bl	40ed30 <z_impl_k_mutex_init>

	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40cf44:	aa1303e0 	mov	x0, x19
		data->filters[i].rx_cb = NULL;
  40cf48:	f802041f 	str	xzr, [x0], #32
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40cf4c:	eb15001f 	cmp	x0, x21
  40cf50:	54ffffc1 	b.ne	40cf48 <can_loopback_init+0x2c>  // b.any
	}

	k_msgq_init(&data->tx_msgq, data->msgq_buffer, sizeof(struct can_loopback_frame),
  40cf54:	910a2261 	add	x1, x19, #0x288
  40cf58:	91088260 	add	x0, x19, #0x220
  40cf5c:	52800203 	mov	w3, #0x10                  	// #16
  40cf60:	d2800b02 	mov	x2, #0x58                  	// #88
  40cf64:	940005c4 	bl	40e674 <k_msgq_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40cf68:	b90003ff 	str	wzr, [sp]
  40cf6c:	91234261 	add	x1, x19, #0x8d0
  40cf70:	f90007ff 	str	xzr, [sp, #8]
  40cf74:	aa1403e4 	mov	x4, x20
  40cf78:	91202260 	add	x0, x19, #0x808
  40cf7c:	52800047 	mov	w7, #0x2                   	// #2
  40cf80:	d2800006 	mov	x6, #0x0                   	// #0
  40cf84:	d2800005 	mov	x5, #0x0                   	// #0
  40cf88:	b0000003 	adrp	x3, 40d000 <can_loopback_init+0xe4>
  40cf8c:	d2802002 	mov	x2, #0x100                 	// #256
  40cf90:	91008063 	add	x3, x3, #0x20
  40cf94:	940004eb 	bl	40e340 <z_impl_k_thread_create>
	tx_tid = k_thread_create(&data->tx_thread_data, data->tx_thread_stack,
				 K_KERNEL_STACK_SIZEOF(data->tx_thread_stack),
				 tx_thread, (void *)dev, NULL, NULL,
				 CONFIG_CAN_LOOPBACK_TX_THREAD_PRIORITY,
				 0, K_NO_WAIT);
	if (!tx_tid) {
  40cf98:	f00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40cf9c:	b50001e0 	cbnz	x0, 40cfd8 <can_loopback_init+0xbc>
		LOG_ERR("ERROR spawning tx thread");
  40cfa0:	f9474c21 	ldr	x1, [x1, #3736]
  40cfa4:	b0000046 	adrp	x6, 415000 <random_data+0xd8c>
  40cfa8:	52800005 	mov	w5, #0x0                   	// #0
  40cfac:	913850c6 	add	x6, x6, #0xe14
  40cfb0:	d2800004 	mov	x4, #0x0                   	// #0
  40cfb4:	d2800003 	mov	x3, #0x0                   	// #0
  40cfb8:	52800022 	mov	w2, #0x1                   	// #1
  40cfbc:	97ffff09 	bl	40cbe0 <z_log_msg_runtime_create.constprop.0>
		return -1;
  40cfc0:	12800000 	mov	w0, #0xffffffff            	// #-1
	}

	LOG_INF("Init of %s done", dev->name);

	return 0;
}
  40cfc4:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40cfc8:	a94253f3 	ldp	x19, x20, [sp, #32]
  40cfcc:	f9401bf5 	ldr	x21, [sp, #48]
  40cfd0:	910103ff 	add	sp, sp, #0x40
  40cfd4:	d65f03c0 	ret
	LOG_INF("Init of %s done", dev->name);
  40cfd8:	f9474c21 	ldr	x1, [x1, #3736]
  40cfdc:	52800000 	mov	w0, #0x0                   	// #0
  40cfe0:	f9400287 	ldr	x7, [x20]
  40cfe4:	b0000046 	adrp	x6, 415000 <random_data+0xd8c>
  40cfe8:	52800005 	mov	w5, #0x0                   	// #0
  40cfec:	9138b4c6 	add	x6, x6, #0xe2d
  40cff0:	d2800004 	mov	x4, #0x0                   	// #0
  40cff4:	d2800003 	mov	x3, #0x0                   	// #0
  40cff8:	52800062 	mov	w2, #0x3                   	// #3
  40cffc:	97fffef9 	bl	40cbe0 <z_log_msg_runtime_create.constprop.0>
	return 0;
  40d000:	52800000 	mov	w0, #0x0                   	// #0
  40d004:	17fffff0 	b	40cfc4 <can_loopback_init+0xa8>

000000000040d008 <can_loopback_set_timing_data>:
  40d008:	f9401000 	ldr	x0, [x0, #32]
  40d00c:	39632000 	ldrb	w0, [x0, #2248]
  40d010:	7100001f 	cmp	w0, #0x0
  40d014:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40d018:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40d01c:	d65f03c0 	ret

000000000040d020 <tx_thread>:
{
  40d020:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  40d024:	910003fd 	mov	x29, sp
  40d028:	a90363f7 	stp	x23, x24, [sp, #48]
  40d02c:	aa0003f7 	mov	x23, x0
  40d030:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40d034:	a90153f3 	stp	x19, x20, [sp, #16]
	return z_impl_k_msgq_get(msgq, data, timeout);
  40d038:	910283f3 	add	x19, sp, #0xa0
	struct can_frame frame_tmp = *frame;
  40d03c:	910163f4 	add	x20, sp, #0x58
{
  40d040:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d044:	a9046bf9 	stp	x25, x26, [sp, #64]
  40d048:	f9476800 	ldr	x0, [x0, #3792]
	struct can_loopback_data *data = dev->data;
  40d04c:	f94012f6 	ldr	x22, [x23, #32]
{
  40d050:	f9400001 	ldr	x1, [x0]
  40d054:	f9007fe1 	str	x1, [sp, #248]
  40d058:	d2800001 	mov	x1, #0x0                   	// #0
		ret = k_msgq_get(&data->tx_msgq, &frame, K_FOREVER);
  40d05c:	910882d9 	add	x25, x22, #0x220
  40d060:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  40d064:	aa1303e1 	mov	x1, x19
  40d068:	aa1903e0 	mov	x0, x25
  40d06c:	9400064a 	bl	40e994 <z_impl_k_msgq_get>
		if (ret < 0) {
  40d070:	37ffff80 	tbnz	w0, #31, 40d060 <tx_thread+0x40>
		frame.cb(dev, 0, frame.cb_arg);
  40d074:	a94e8be3 	ldp	x3, x2, [sp, #232]
  40d078:	aa1703e0 	mov	x0, x23
  40d07c:	52800001 	mov	w1, #0x0                   	// #0
  40d080:	d63f0060 	blr	x3
		if (!data->loopback) {
  40d084:	396326c0 	ldrb	w0, [x22, #2249]
  40d088:	34fffec0 	cbz	w0, 40d060 <tx_thread+0x40>
		k_mutex_lock(&data->mtx, K_FOREVER);
  40d08c:	910802da 	add	x26, x22, #0x200
	return z_impl_k_mutex_lock(mutex, timeout);
  40d090:	aa1603f5 	mov	x21, x22
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d094:	52800018 	mov	w24, #0x0                   	// #0
  40d098:	aa1a03e0 	mov	x0, x26
  40d09c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40d0a0:	94000729 	bl	40ed44 <z_impl_k_mutex_lock>
			if (filter->rx_cb != NULL &&
  40d0a4:	f94002a0 	ldr	x0, [x21]
  40d0a8:	b40000c0 	cbz	x0, 40d0c0 <tx_thread+0xa0>
 * @return true if the CAN frame matches the CAN filter, false otherwise
 */
static inline bool can_frame_matches_filter(const struct can_frame *frame,
					    const struct can_filter *filter)
{
	if ((frame->flags & CAN_FRAME_IDE) != 0 && (filter->flags & CAN_FILTER_IDE) == 0) {
  40d0ac:	394297e0 	ldrb	w0, [sp, #165]
  40d0b0:	394062a1 	ldrb	w1, [x21, #24]
  40d0b4:	12000022 	and	w2, w1, #0x1
  40d0b8:	36000120 	tbz	w0, #0, 40d0dc <tx_thread+0xbc>
  40d0bc:	35000122 	cbnz	w2, 40d0e0 <tx_thread+0xc0>
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d0c0:	11000718 	add	w24, w24, #0x1
  40d0c4:	910082b5 	add	x21, x21, #0x20
  40d0c8:	7100431f 	cmp	w24, #0x10
  40d0cc:	54fffec1 	b.ne	40d0a4 <tx_thread+0x84>  // b.any
		k_mutex_unlock(&data->mtx);
  40d0d0:	aa1a03e0 	mov	x0, x26
  40d0d4:	97ffff70 	bl	40ce94 <k_mutex_unlock.isra.0>
  40d0d8:	17ffffe2 	b	40d060 <tx_thread+0x40>
		/* Extended (29-bit) ID frame, standard (11-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_IDE) == 0 && (filter->flags & CAN_FILTER_IDE) != 0) {
  40d0dc:	35ffff22 	cbnz	w2, 40d0c0 <tx_thread+0xa0>
		/* Standard (11-bit) ID frame, extended (29-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_RTR) == 0 && (filter->flags & CAN_FILTER_DATA) == 0) {
  40d0e0:	37080300 	tbnz	w0, #1, 40d140 <tx_thread+0x120>
  40d0e4:	3617fee1 	tbz	w1, #2, 40d0c0 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
		/* Remote transmission request (RTR) frame, non-RTR filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_FDF) != 0 && (filter->flags & CAN_FILTER_FDF) == 0) {
  40d0e8:	121d0021 	and	w1, w1, #0x8
  40d0ec:	361002e0 	tbz	w0, #2, 40d148 <tx_thread+0x128>
  40d0f0:	34fffe81 	cbz	w1, 40d0c0 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
		/* Classic frame, CAN-FD format filter */
		return false;
	}

	if ((frame->id ^ filter->id) & filter->mask) {
  40d0f4:	937b7f00 	sbfiz	x0, x24, #5, #32
  40d0f8:	8b0002c0 	add	x0, x22, x0
  40d0fc:	f94053e1 	ldr	x1, [sp, #160]
  40d100:	f9400800 	ldr	x0, [x0, #16]
  40d104:	4a010001 	eor	w1, w0, w1
  40d108:	d360f000 	ubfx	x0, x0, #32, #29
  40d10c:	6a00003f 	tst	w1, w0
  40d110:	54fffd81 	b.ne	40d0c0 <tx_thread+0xa0>  // b.any
	struct can_frame frame_tmp = *frame;
  40d114:	ad400660 	ldp	q0, q1, [x19]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40d118:	aa1403e1 	mov	x1, x20
	struct can_frame frame_tmp = *frame;
  40d11c:	f9402260 	ldr	x0, [x19, #64]
  40d120:	f9002280 	str	x0, [x20, #64]
  40d124:	ad000680 	stp	q0, q1, [x20]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40d128:	aa1703e0 	mov	x0, x23
	struct can_frame frame_tmp = *frame;
  40d12c:	ad410660 	ldp	q0, q1, [x19, #32]
  40d130:	ad010680 	stp	q0, q1, [x20, #32]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40d134:	a9400aa3 	ldp	x3, x2, [x21]
  40d138:	d63f0060 	blr	x3
}
  40d13c:	17ffffe1 	b	40d0c0 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
  40d140:	370ffd41 	tbnz	w1, #1, 40d0e8 <tx_thread+0xc8>
  40d144:	17ffffdf 	b	40d0c0 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
  40d148:	34fffd61 	cbz	w1, 40d0f4 <tx_thread+0xd4>
  40d14c:	17ffffdd 	b	40d0c0 <tx_thread+0xa0>

000000000040d150 <can_loopback_add_rx_filter>:
{
  40d150:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40d154:	910003fd 	mov	x29, sp
  40d158:	a90153f3 	stp	x19, x20, [sp, #16]
  40d15c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d160:	a90363f7 	stp	x23, x24, [sp, #48]
  40d164:	f90023f9 	str	x25, [sp, #64]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA |
  40d168:	39402073 	ldrb	w19, [x3, #8]
  40d16c:	39402067 	ldrb	w7, [x3, #8]
  40d170:	f27cee73 	ands	x19, x19, #0xfffffffffffffff0
	struct can_loopback_data *data = dev->data;
  40d174:	f9401016 	ldr	x22, [x0, #32]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA |
  40d178:	54000260 	b.eq	40d1c4 <can_loopback_add_rx_filter+0x74>  // b.none
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40d17c:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
		return -ENOTSUP;
  40d180:	12800bd5 	mov	w21, #0xffffffa1            	// #-95
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40d184:	90000046 	adrp	x6, 415000 <random_data+0xd8c>
  40d188:	52800005 	mov	w5, #0x0                   	// #0
  40d18c:	f9474c21 	ldr	x1, [x1, #3736]
  40d190:	9138f4c6 	add	x6, x6, #0xe3d
  40d194:	d2800004 	mov	x4, #0x0                   	// #0
  40d198:	d2800003 	mov	x3, #0x0                   	// #0
  40d19c:	52800022 	mov	w2, #0x1                   	// #1
  40d1a0:	52800000 	mov	w0, #0x0                   	// #0
  40d1a4:	97fffe8f 	bl	40cbe0 <z_log_msg_runtime_create.constprop.0>
}
  40d1a8:	2a1503e0 	mov	w0, w21
  40d1ac:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d1b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d1b4:	a94363f7 	ldp	x23, x24, [sp, #48]
  40d1b8:	f94023f9 	ldr	x25, [sp, #64]
  40d1bc:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40d1c0:	d65f03c0 	ret
  40d1c4:	aa0103f9 	mov	x25, x1
  40d1c8:	aa0203f8 	mov	x24, x2
  40d1cc:	aa0303f4 	mov	x20, x3
	k_mutex_lock(&data->mtx, K_FOREVER);
  40d1d0:	910802d7 	add	x23, x22, #0x200
  40d1d4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40d1d8:	aa1703e0 	mov	x0, x23
  40d1dc:	940006da 	bl	40ed44 <z_impl_k_mutex_lock>
		if (filters[i].rx_cb == NULL) {
  40d1e0:	d37bea60 	lsl	x0, x19, #5
  40d1e4:	2a1303f5 	mov	w21, w19
  40d1e8:	f8606ac0 	ldr	x0, [x22, x0]
  40d1ec:	b4000240 	cbz	x0, 40d234 <can_loopback_add_rx_filter+0xe4>
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40d1f0:	91000673 	add	x19, x19, #0x1
  40d1f4:	f100427f 	cmp	x19, #0x10
  40d1f8:	54ffff41 	b.ne	40d1e0 <can_loopback_add_rx_filter+0x90>  // b.any
		LOG_ERR("No free filter left");
  40d1fc:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40d200:	90000046 	adrp	x6, 415000 <random_data+0xd8c>
  40d204:	913984c6 	add	x6, x6, #0xe61
  40d208:	52800005 	mov	w5, #0x0                   	// #0
  40d20c:	f9474c21 	ldr	x1, [x1, #3736]
  40d210:	d2800004 	mov	x4, #0x0                   	// #0
  40d214:	d2800003 	mov	x3, #0x0                   	// #0
  40d218:	52800022 	mov	w2, #0x1                   	// #1
  40d21c:	52800000 	mov	w0, #0x0                   	// #0
	return -ENOSPC;
  40d220:	12800375 	mov	w21, #0xffffffe4            	// #-28
		LOG_ERR("No free filter left");
  40d224:	97fffe6f 	bl	40cbe0 <z_log_msg_runtime_create.constprop.0>
		k_mutex_unlock(&data->mtx);
  40d228:	aa1703e0 	mov	x0, x23
  40d22c:	97ffff1a 	bl	40ce94 <k_mutex_unlock.isra.0>
		return filter_id;
  40d230:	17ffffde 	b	40d1a8 <can_loopback_add_rx_filter+0x58>
	loopback_filter->rx_cb = cb;
  40d234:	937b7e61 	sbfiz	x1, x19, #5, #32
  40d238:	8b0102c0 	add	x0, x22, x1
  40d23c:	f8216ad9 	str	x25, [x22, x1]
	loopback_filter->cb_arg = cb_arg;
  40d240:	f9000418 	str	x24, [x0, #8]
	loopback_filter->filter = *filter;
  40d244:	f9400281 	ldr	x1, [x20]
  40d248:	f9000801 	str	x1, [x0, #16]
  40d24c:	b9400a81 	ldr	w1, [x20, #8]
  40d250:	b9001801 	str	w1, [x0, #24]
	k_mutex_unlock(&data->mtx);
  40d254:	aa1703e0 	mov	x0, x23
  40d258:	97ffff0f 	bl	40ce94 <k_mutex_unlock.isra.0>
	return filter_id;
  40d25c:	17ffffd3 	b	40d1a8 <can_loopback_add_rx_filter+0x58>

000000000040d260 <posix_arch_console_init>:
		stdout_buff[0] = 0;
	}
}

static int posix_arch_console_init(void)
{
  40d260:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#ifdef CONFIG_PRINTK
	extern void __printk_hook_install(int (*fn)(int));
	__printk_hook_install(print_char);
  40d264:	90000000 	adrp	x0, 40d000 <can_loopback_init+0xe4>
  40d268:	910a0000 	add	x0, x0, #0x280
{
  40d26c:	910003fd 	mov	x29, sp
	__printk_hook_install(print_char);
  40d270:	97ffe438 	bl	406350 <__printk_hook_install>
#ifdef CONFIG_STDOUT_CONSOLE
	extern void __stdout_hook_install(int (*fn)(int));
	__stdout_hook_install(print_char);
#endif
	return 0;
}
  40d274:	52800000 	mov	w0, #0x0                   	// #0
  40d278:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d27c:	d65f03c0 	ret

000000000040d280 <print_char>:
{
  40d280:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if ((c != '\n') && (c != '\r')) {
  40d284:	7100281f 	cmp	w0, #0xa
  40d288:	7a4d1804 	ccmp	w0, #0xd, #0x4, ne  // ne = any
{
  40d28c:	910003fd 	mov	x29, sp
  40d290:	a90153f3 	stp	x19, x20, [sp, #16]
  40d294:	2a0003f3 	mov	w19, w0
  40d298:	90000114 	adrp	x20, 42d000 <counter_value>
  40d29c:	f90013f5 	str	x21, [sp, #32]
	if ((c != '\n') && (c != '\r')) {
  40d2a0:	54000320 	b.eq	40d304 <print_char+0x84>  // b.none
		stdout_buff[n_pend++] = c;
  40d2a4:	b94f4a82 	ldr	w2, [x20, #3912]
  40d2a8:	b0000100 	adrp	x0, 42e000 <des_frames+0x27>
  40d2ac:	910c2400 	add	x0, x0, #0x309
  40d2b0:	11000441 	add	w1, w2, #0x1
  40d2b4:	b90f4a81 	str	w1, [x20, #3912]
  40d2b8:	3822c813 	strb	w19, [x0, w2, sxtw]
		stdout_buff[n_pend] = 0;
  40d2bc:	3821c81f 	strb	wzr, [x0, w1, sxtw]
	int printnow = 0;
  40d2c0:	52800000 	mov	w0, #0x0                   	// #0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  40d2c4:	b94f4a81 	ldr	w1, [x20, #3912]
  40d2c8:	7103f83f 	cmp	w1, #0xfe
  40d2cc:	5400004c 	b.gt	40d2d4 <print_char+0x54>
	if (printnow) {
  40d2d0:	34000100 	cbz	w0, 40d2f0 <print_char+0x70>
		posix_print_trace("%s\n", stdout_buff);
  40d2d4:	b0000115 	adrp	x21, 42e000 <des_frames+0x27>
  40d2d8:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40d2dc:	910c26a1 	add	x1, x21, #0x309
  40d2e0:	9122fc00 	add	x0, x0, #0x8bf
  40d2e4:	97fff467 	bl	40a480 <posix_print_trace>
		n_pend = 0;
  40d2e8:	b90f4a9f 	str	wzr, [x20, #3912]
		stdout_buff[0] = 0;
  40d2ec:	390c26bf 	strb	wzr, [x21, #777]
}
  40d2f0:	2a1303e0 	mov	w0, w19
  40d2f4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d2f8:	f94013f5 	ldr	x21, [sp, #32]
  40d2fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40d300:	d65f03c0 	ret
		printnow = 1;
  40d304:	52800020 	mov	w0, #0x1                   	// #1
  40d308:	17ffffef 	b	40d2c4 <print_char+0x44>

000000000040d30c <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
  40d30c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d310:	910003fd 	mov	x29, sp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
  40d314:	97fff131 	bl	4097d8 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40d318:	90000102 	adrp	x2, 42d000 <counter_value>
  40d31c:	90000101 	adrp	x1, 42d000 <counter_value>

	last_tick_time += elapsed_ticks*tick_period;
	sys_clock_announce(elapsed_ticks);
}
  40d320:	a8c17bfd 	ldp	x29, x30, [sp], #16
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40d324:	f9456443 	ldr	x3, [x2, #2760]
  40d328:	f9456824 	ldr	x4, [x1, #2768]
  40d32c:	cb030000 	sub	x0, x0, x3
  40d330:	9ac40800 	udiv	x0, x0, x4
	last_tick_time += elapsed_ticks*tick_period;
  40d334:	93407c01 	sxtw	x1, w0
  40d338:	9b040c21 	madd	x1, x1, x4, x3
  40d33c:	f9056441 	str	x1, [x2, #2760]
	sys_clock_announce(elapsed_ticks);
  40d340:	1400163b 	b	412c2c <sys_clock_announce>

000000000040d344 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(void)
{
  40d344:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40d348:	d284e200 	mov	x0, #0x2710                	// #10000
{
  40d34c:	910003fd 	mov	x29, sp
  40d350:	f9000bf3 	str	x19, [sp, #16]
	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40d354:	90000113 	adrp	x19, 42d000 <counter_value>
  40d358:	f9056a60 	str	x0, [x19, #2768]

	last_tick_time = hwm_get_time();
  40d35c:	97fff11f 	bl	4097d8 <hwm_get_time>
  40d360:	90000101 	adrp	x1, 42d000 <counter_value>
  40d364:	f9056420 	str	x0, [x1, #2760]
	hwtimer_enable(tick_period);
  40d368:	f9456a60 	ldr	x0, [x19, #2768]
  40d36c:	97fff1af 	bl	409a28 <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
  40d370:	d2800003 	mov	x3, #0x0                   	// #0
  40d374:	52800001 	mov	w1, #0x0                   	// #0
  40d378:	52800000 	mov	w0, #0x0                   	// #0
  40d37c:	90000002 	adrp	x2, 40d000 <can_loopback_init+0xe4>
  40d380:	910c3042 	add	x2, x2, #0x30c
  40d384:	97fff2c9 	bl	409ea8 <posix_isr_declare>
  40d388:	52800002 	mov	w2, #0x0                   	// #0
  40d38c:	52800021 	mov	w1, #0x1                   	// #1
  40d390:	52800000 	mov	w0, #0x0                   	// #0
  40d394:	97fff2cf 	bl	409ed0 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
  40d398:	52800000 	mov	w0, #0x0                   	// #0
  40d39c:	97ffee3b 	bl	408c88 <arch_irq_enable>

	return 0;
}
  40d3a0:	52800000 	mov	w0, #0x0                   	// #0
  40d3a4:	f9400bf3 	ldr	x19, [sp, #16]
  40d3a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40d3ac:	d65f03c0 	ret

000000000040d3b0 <sys_clock_cycle_get_32>:
{
  40d3b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d3b4:	910003fd 	mov	x29, sp
	return hwm_get_time();
  40d3b8:	97fff108 	bl	4097d8 <hwm_get_time>
}
  40d3bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d3c0:	d65f03c0 	ret

000000000040d3c4 <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
  40d3c4:	3100041f 	cmn	w0, #0x1
  40d3c8:	540000c0 	b.eq	40d3e0 <sys_clock_set_timeout+0x1c>  // b.none
		silent_ticks = ticks - 1;
  40d3cc:	51000401 	sub	w1, w0, #0x1
  40d3d0:	7100001f 	cmp	w0, #0x0
  40d3d4:	93407c21 	sxtw	x1, w1
  40d3d8:	9a9fc020 	csel	x0, x1, xzr, gt
	hwtimer_set_silent_ticks(silent_ticks);
  40d3dc:	17fff207 	b	409bf8 <hwtimer_set_silent_ticks>
		silent_ticks = INT64_MAX;
  40d3e0:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  40d3e4:	17fffffe 	b	40d3dc <sys_clock_set_timeout+0x18>

000000000040d3e8 <sys_clock_elapsed>:
{
  40d3e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d3ec:	910003fd 	mov	x29, sp
	return (hwm_get_time() - last_tick_time)/tick_period;
  40d3f0:	97fff0fa 	bl	4097d8 <hwm_get_time>
  40d3f4:	90000101 	adrp	x1, 42d000 <counter_value>
}
  40d3f8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return (hwm_get_time() - last_tick_time)/tick_period;
  40d3fc:	f9456421 	ldr	x1, [x1, #2760]
  40d400:	cb010000 	sub	x0, x0, x1
  40d404:	90000101 	adrp	x1, 42d000 <counter_value>
  40d408:	f9456821 	ldr	x1, [x1, #2768]
}
  40d40c:	9ac10800 	udiv	x0, x0, x1
  40d410:	d65f03c0 	ret

000000000040d414 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	STRUCT_SECTION_FOREACH(device, dev) {
  40d414:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40d418:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40d41c:	f9476000 	ldr	x0, [x0, #3776]
  40d420:	f9478421 	ldr	x1, [x1, #3848]
  40d424:	eb01001f 	cmp	x0, x1
  40d428:	54000349 	b.ls	40d490 <z_device_state_init+0x7c>  // b.plast
{
  40d42c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	STRUCT_SECTION_FOREACH(device, dev) {
  40d430:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40d434:	913acc21 	add	x1, x1, #0xeb3
{
  40d438:	910003fd 	mov	x29, sp
  40d43c:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(device, dev) {
  40d440:	90000053 	adrp	x19, 415000 <random_data+0xd8c>
  40d444:	913a4273 	add	x19, x19, #0xe90
  40d448:	528002e3 	mov	w3, #0x17                  	// #23
  40d44c:	aa1303e2 	mov	x2, x19
  40d450:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40d454:	911a8800 	add	x0, x0, #0x6a2
  40d458:	97ffe988 	bl	407a78 <assert_print>
  40d45c:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40d460:	91278c00 	add	x0, x0, #0x9e3
  40d464:	97ffe985 	bl	407a78 <assert_print>
  40d468:	aa1303e0 	mov	x0, x19
  40d46c:	528002e1 	mov	w1, #0x17                  	// #23
  40d470:	97ffe9ac 	bl	407b20 <assert_post_action>
  40d474:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40d478:	aa1303e1 	mov	x1, x19
  40d47c:	911b8000 	add	x0, x0, #0x6e0
  40d480:	528002e2 	mov	w2, #0x17                  	// #23
  40d484:	97fff399 	bl	40a2e8 <posix_print_error_and_exit>
  40d488:	9100c000 	add	x0, x0, #0x30
  40d48c:	17ffffe6 	b	40d424 <z_device_state_init+0x10>
  40d490:	54ffffc3 	b.cc	40d488 <z_device_state_init+0x74>  // b.lo, b.ul, b.last
  40d494:	d65f03c0 	ret

000000000040d498 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
  40d498:	b4000100 	cbz	x0, 40d4b8 <z_device_is_ready+0x20>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
  40d49c:	f9400c00 	ldr	x0, [x0, #24]
  40d4a0:	39400401 	ldrb	w1, [x0, #1]
  40d4a4:	360000a1 	tbz	w1, #0, 40d4b8 <z_device_is_ready+0x20>
  40d4a8:	39400000 	ldrb	w0, [x0]
  40d4ac:	7100001f 	cmp	w0, #0x0
  40d4b0:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40d4b4:	d65f03c0 	ret
		return false;
  40d4b8:	52800000 	mov	w0, #0x0                   	// #0
  40d4bc:	17fffffe 	b	40d4b4 <z_device_is_ready+0x1c>

000000000040d4c0 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40d4c0:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40d4c4:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40d4c8:	910003fd 	mov	x29, sp
  40d4cc:	f9476800 	ldr	x0, [x0, #3792]
  40d4d0:	3d8023e0 	str	q0, [sp, #128]
  40d4d4:	3d8027e1 	str	q1, [sp, #144]
  40d4d8:	3d802be2 	str	q2, [sp, #160]
  40d4dc:	3d802fe3 	str	q3, [sp, #176]
  40d4e0:	3d8033e4 	str	q4, [sp, #192]
  40d4e4:	3d8037e5 	str	q5, [sp, #208]
  40d4e8:	3d803be6 	str	q6, [sp, #224]
  40d4ec:	3d803fe7 	str	q7, [sp, #240]
  40d4f0:	f90087e7 	str	x7, [sp, #264]
  40d4f4:	f9400002 	ldr	x2, [x0]
  40d4f8:	f9003fe2 	str	x2, [sp, #120]
  40d4fc:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40d500:	910443e0 	add	x0, sp, #0x110
  40d504:	a90383e0 	stp	x0, x0, [sp, #56]
  40d508:	910403e0 	add	x0, sp, #0x100
  40d50c:	9100e3e2 	add	x2, sp, #0x38
  40d510:	f90027e0 	str	x0, [sp, #72]
  40d514:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40d518:	b90053e0 	str	w0, [sp, #80]
  40d51c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40d520:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40d524:	910163e0 	add	x0, sp, #0x58
  40d528:	ad400440 	ldp	q0, q1, [x2]
  40d52c:	ad000400 	stp	q0, q1, [x0]
  40d530:	ad400400 	ldp	q0, q1, [x0]
  40d534:	910043e7 	add	x7, sp, #0x10
  40d538:	52800022 	mov	w2, #0x1                   	// #1
  40d53c:	52800000 	mov	w0, #0x0                   	// #0
  40d540:	52800005 	mov	w5, #0x0                   	// #0
  40d544:	d2800004 	mov	x4, #0x0                   	// #0
  40d548:	d2800003 	mov	x3, #0x0                   	// #0
  40d54c:	ad0004e0 	stp	q0, q1, [x7]
  40d550:	97ffeb2a 	bl	4081f8 <z_impl_z_log_msg_runtime_vcreate>
}
  40d554:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40d558:	f9476800 	ldr	x0, [x0, #3792]
  40d55c:	f9403fe2 	ldr	x2, [sp, #120]
  40d560:	f9400001 	ldr	x1, [x0]
  40d564:	eb010042 	subs	x2, x2, x1
  40d568:	d2800001 	mov	x1, #0x0                   	// #0
  40d56c:	54000040 	b.eq	40d574 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40d570:	97ffcf6c 	bl	401320 <__stack_chk_fail@plt>
  40d574:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40d578:	d65f03c0 	ret

000000000040d57c <coredump>:
#else

void coredump(unsigned int reason, const z_arch_esf_t *esf,
	      struct k_thread *thread)
{
}
  40d57c:	d65f03c0 	ret

000000000040d580 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  40d580:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40d584:	910003fd 	mov	x29, sp
  40d588:	f9000bf3 	str	x19, [sp, #16]
  40d58c:	2a0003f3 	mov	w19, w0
  40d590:	97ffea2b 	bl	407e3c <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
  40d594:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40d598:	90000046 	adrp	x6, 415000 <random_data+0xd8c>
  40d59c:	913b2cc6 	add	x6, x6, #0xecb
  40d5a0:	52800005 	mov	w5, #0x0                   	// #0
  40d5a4:	f9470421 	ldr	x1, [x1, #3592]
  40d5a8:	d2800004 	mov	x4, #0x0                   	// #0
  40d5ac:	d2800003 	mov	x3, #0x0                   	// #0
  40d5b0:	52800022 	mov	w2, #0x1                   	// #1
  40d5b4:	52800000 	mov	w0, #0x0                   	// #0
  40d5b8:	97ffffc2 	bl	40d4c0 <z_log_msg_runtime_create.constprop.0>
	arch_system_halt(reason);
  40d5bc:	2a1303e0 	mov	w0, w19
  40d5c0:	97ffeda7 	bl	408c5c <arch_system_halt>

000000000040d5c4 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  40d5c4:	d10143ff 	sub	sp, sp, #0x50
  40d5c8:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d5cc:	910043fd 	add	x29, sp, #0x10
  40d5d0:	a90253f3 	stp	x19, x20, [sp, #32]
  40d5d4:	2a0003f3 	mov	w19, w0
  40d5d8:	aa0103f4 	mov	x20, x1
  40d5dc:	a9035bf5 	stp	x21, x22, [sp, #48]
  40d5e0:	f90023f7 	str	x23, [sp, #64]
	return posix_irq_lock();
  40d5e4:	97fff22b 	bl	409e90 <posix_irq_lock>
  40d5e8:	2a0003f5 	mov	w21, w0
	return z_impl_z_current_get();
  40d5ec:	940012da 	bl	412154 <z_impl_z_current_get>
  40d5f0:	aa0003f6 	mov	x22, x0
	switch (reason) {
  40d5f4:	7100127f 	cmp	w19, #0x4
  40d5f8:	54000848 	b.hi	40d700 <z_fatal_error+0x13c>  // b.pmore
  40d5fc:	d0000020 	adrp	x0, 413000 <z_timer_expiration_handler+0x68>
  40d600:	91178000 	add	x0, x0, #0x5e0
  40d604:	38734800 	ldrb	w0, [x0, w19, uxtw]
  40d608:	10000061 	adr	x1, 40d614 <z_fatal_error+0x50>
  40d60c:	8b208820 	add	x0, x1, w0, sxtb #2
  40d610:	d61f0000 	br	x0
		return "Unhandled interrupt";
  40d614:	90000043 	adrp	x3, 415000 <random_data+0xd8c>
  40d618:	913ba063 	add	x3, x3, #0xee8
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  40d61c:	d00000f7 	adrp	x23, 42b000 <__FRAME_END__+0x1007c>
  40d620:	f90003e3 	str	x3, [sp]
  40d624:	b9000bff 	str	wzr, [sp, #8]
  40d628:	90000046 	adrp	x6, 415000 <random_data+0xd8c>
  40d62c:	f94706e1 	ldr	x1, [x23, #3592]
  40d630:	2a1303e7 	mov	w7, w19
  40d634:	913ce8c6 	add	x6, x6, #0xf3a
  40d638:	52800005 	mov	w5, #0x0                   	// #0
  40d63c:	d2800004 	mov	x4, #0x0                   	// #0
  40d640:	52800022 	mov	w2, #0x1                   	// #1
  40d644:	52800000 	mov	w0, #0x0                   	// #0
  40d648:	d2800003 	mov	x3, #0x0                   	// #0
  40d64c:	97ffff9d 	bl	40d4c0 <z_log_msg_runtime_create.constprop.0>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
  40d650:	b40000d6 	cbz	x22, 40d668 <z_fatal_error+0xa4>
  40d654:	aa1603e0 	mov	x0, x22
  40d658:	940002d6 	bl	40e1b0 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
  40d65c:	b4000060 	cbz	x0, 40d668 <z_fatal_error+0xa4>
  40d660:	39400001 	ldrb	w1, [x0]
  40d664:	35000061 	cbnz	w1, 40d670 <z_fatal_error+0xac>
		thread_name = "unknown";
  40d668:	90000043 	adrp	x3, 415000 <random_data+0xd8c>
  40d66c:	913cc860 	add	x0, x3, #0xf32
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  40d670:	f94706e1 	ldr	x1, [x23, #3592]
  40d674:	aa1603e7 	mov	x7, x22
  40d678:	90000046 	adrp	x6, 415000 <random_data+0xd8c>
  40d67c:	913d88c6 	add	x6, x6, #0xf62
  40d680:	f90003e0 	str	x0, [sp]
  40d684:	52800005 	mov	w5, #0x0                   	// #0
  40d688:	d2800004 	mov	x4, #0x0                   	// #0
  40d68c:	d2800003 	mov	x3, #0x0                   	// #0
  40d690:	52800022 	mov	w2, #0x1                   	// #1
  40d694:	52800000 	mov	w0, #0x0                   	// #0
  40d698:	97ffff8a 	bl	40d4c0 <z_log_msg_runtime_create.constprop.0>
		thread_name_get(thread));

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
  40d69c:	aa1603e2 	mov	x2, x22
  40d6a0:	aa1403e1 	mov	x1, x20
  40d6a4:	2a1303e0 	mov	w0, w19
  40d6a8:	97ffffb5 	bl	40d57c <coredump>
#endif

	k_sys_fatal_error_handler(reason, esf);
  40d6ac:	aa1403e1 	mov	x1, x20
  40d6b0:	2a1303e0 	mov	w0, w19
  40d6b4:	97ffffb3 	bl	40d580 <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
  40d6b8:	2a1503e0 	mov	w0, w21
  40d6bc:	97fff1f7 	bl	409e98 <posix_irq_unlock>
	z_impl_k_thread_abort(thread);
  40d6c0:	aa1603e0 	mov	x0, x22
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
  40d6c4:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40d6c8:	a94253f3 	ldp	x19, x20, [sp, #32]
  40d6cc:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40d6d0:	f94023f7 	ldr	x23, [sp, #64]
  40d6d4:	910143ff 	add	sp, sp, #0x50
  40d6d8:	17ffee9b 	b	409144 <z_impl_k_thread_abort>
		return "Stack overflow";
  40d6dc:	90000043 	adrp	x3, 415000 <random_data+0xd8c>
  40d6e0:	913bf063 	add	x3, x3, #0xefc
  40d6e4:	17ffffce 	b	40d61c <z_fatal_error+0x58>
		return "Kernel oops";
  40d6e8:	90000043 	adrp	x3, 415000 <random_data+0xd8c>
  40d6ec:	913c2c63 	add	x3, x3, #0xf0b
  40d6f0:	17ffffcb 	b	40d61c <z_fatal_error+0x58>
		return "Kernel panic";
  40d6f4:	90000043 	adrp	x3, 415000 <random_data+0xd8c>
  40d6f8:	913c5c63 	add	x3, x3, #0xf17
  40d6fc:	17ffffc8 	b	40d61c <z_fatal_error+0x58>
		return "Unknown error";
  40d700:	90000043 	adrp	x3, 415000 <random_data+0xd8c>
  40d704:	913c9063 	add	x3, x3, #0xf24
  40d708:	17ffffc5 	b	40d61c <z_fatal_error+0x58>
	switch (reason) {
  40d70c:	90000043 	adrp	x3, 415000 <random_data+0xd8c>
  40d710:	913b6863 	add	x3, x3, #0xeda
  40d714:	17ffffc2 	b	40d61c <z_fatal_error+0x58>

000000000040d718 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
  40d718:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d71c:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40d720:	91274021 	add	x1, x1, #0x9d0
{
  40d724:	910003fd 	mov	x29, sp
  40d728:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d72c:	f8605833 	ldr	x19, [x1, w0, uxtw #3]
  40d730:	11000400 	add	w0, w0, #0x1
{
  40d734:	a9025bf5 	stp	x21, x22, [sp, #32]
						rc = -rc;
					}
					if (rc > UINT8_MAX) {
						rc = UINT8_MAX;
					}
					dev->state->init_res = rc;
  40d738:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d73c:	f8607835 	ldr	x21, [x1, x0, lsl #3]
  40d740:	eb1302bf 	cmp	x21, x19
  40d744:	540000a8 	b.hi	40d758 <z_sys_init_run_level+0x40>  // b.pmore
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
  40d748:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d74c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d750:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40d754:	d65f03c0 	ret
		const struct device *dev = entry->dev;
  40d758:	a9405261 	ldp	x1, x20, [x19]
		if (dev != NULL) {
  40d75c:	b4000234 	cbz	x20, 40d7a0 <z_sys_init_run_level+0x88>
			if (entry->init_fn.dev != NULL) {
  40d760:	b4000141 	cbz	x1, 40d788 <z_sys_init_run_level+0x70>
				rc = entry->init_fn.dev(dev);
  40d764:	aa1403e0 	mov	x0, x20
  40d768:	d63f0020 	blr	x1
				if (rc != 0) {
  40d76c:	7100001f 	cmp	w0, #0x0
  40d770:	340000c0 	cbz	w0, 40d788 <z_sys_init_run_level+0x70>
					dev->state->init_res = rc;
  40d774:	f9400e81 	ldr	x1, [x20, #24]
  40d778:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
  40d77c:	7103fc1f 	cmp	w0, #0xff
  40d780:	1a96d000 	csel	w0, w0, w22, le
  40d784:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
  40d788:	f9400e81 	ldr	x1, [x20, #24]
  40d78c:	39400420 	ldrb	w0, [x1, #1]
  40d790:	32000000 	orr	w0, w0, #0x1
  40d794:	39000420 	strb	w0, [x1, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40d798:	91004273 	add	x19, x19, #0x10
  40d79c:	17ffffe9 	b	40d740 <z_sys_init_run_level+0x28>
			(void)entry->init_fn.sys();
  40d7a0:	d63f0020 	blr	x1
  40d7a4:	17fffffd 	b	40d798 <z_sys_init_run_level+0x80>

000000000040d7a8 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
  40d7a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
  40d7ac:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40d7b0:	52800021 	mov	w1, #0x1                   	// #1
{
  40d7b4:	910003fd 	mov	x29, sp
	z_sys_post_kernel = true;
  40d7b8:	f946f000 	ldr	x0, [x0, #3552]
  40d7bc:	39000001 	strb	w1, [x0]

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
  40d7c0:	52800060 	mov	w0, #0x3                   	// #3
  40d7c4:	97ffffd5 	bl	40d718 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
  40d7c8:	94001733 	bl	413494 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
  40d7cc:	52800080 	mov	w0, #0x4                   	// #4
  40d7d0:	97ffffd2 	bl	40d718 <z_sys_init_run_level>

	z_init_static_threads();
  40d7d4:	9400030d 	bl	40e408 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
  40d7d8:	97fff8c2 	bl	40bae0 <_posix_zephyr_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  40d7dc:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40d7e0:	f947e800 	ldr	x0, [x0, #4048]
  40d7e4:	39406001 	ldrb	w1, [x0, #24]
  40d7e8:	121f7821 	and	w1, w1, #0xfffffffe
  40d7ec:	39006001 	strb	w1, [x0, #24]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  40d7f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d7f4:	d65f03c0 	ret

000000000040d7f8 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
  40d7f8:	d10143ff 	sub	sp, sp, #0x50
	z_setup_new_thread(thread, stack,
  40d7fc:	52800504 	mov	w4, #0x28                  	// #40
  40d800:	d00000e3 	adrp	x3, 42b000 <__FRAME_END__+0x1007c>
  40d804:	528001e7 	mov	w7, #0xf                   	// #15
  40d808:	d2800006 	mov	x6, #0x0                   	// #0
  40d80c:	d2800005 	mov	x5, #0x0                   	// #0
{
  40d810:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d814:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(thread, stack,
  40d818:	d2802002 	mov	x2, #0x100                 	// #256
  40d81c:	f9475063 	ldr	x3, [x3, #3744]
{
  40d820:	a9035bf5 	stp	x21, x22, [sp, #48]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  40d824:	d00000f6 	adrp	x22, 42b000 <__FRAME_END__+0x1007c>
{
  40d828:	f90023f7 	str	x23, [sp, #64]
	struct k_thread *thread = &z_idle_threads[i];
  40d82c:	d00000f7 	adrp	x23, 42b000 <__FRAME_END__+0x1007c>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  40d830:	f9472ed6 	ldr	x22, [x22, #3672]
{
  40d834:	a90253f3 	stp	x19, x20, [sp, #32]
  40d838:	93407c13 	sxtw	x19, w0
	struct k_thread *thread = &z_idle_threads[i];
  40d83c:	f946fef7 	ldr	x23, [x23, #3576]
  40d840:	52801815 	mov	w21, #0xc0                  	// #192
	z_setup_new_thread(thread, stack,
  40d844:	9b245a64 	smaddl	x4, w19, w4, x22
  40d848:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40d84c:	913de800 	add	x0, x0, #0xf7a
  40d850:	f90007e0 	str	x0, [sp, #8]
	struct k_thread *thread = &z_idle_threads[i];
  40d854:	9b355e75 	smaddl	x21, w19, w21, x23
	z_setup_new_thread(thread, stack,
  40d858:	52800020 	mov	w0, #0x1                   	// #1
  40d85c:	b90003e0 	str	w0, [sp]
	k_thread_stack_t *stack = z_idle_stacks[i];
  40d860:	93787e61 	sbfiz	x1, x19, #8, #32
	z_setup_new_thread(thread, stack,
  40d864:	f0000100 	adrp	x0, 430000 <kheap_net_buf_mem_pool_isotp_tx_pool+0xe8>
  40d868:	91186000 	add	x0, x0, #0x618
  40d86c:	8b010001 	add	x1, x0, x1
  40d870:	aa1503e0 	mov	x0, x21
  40d874:	94000259 	bl	40e1d8 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  40d878:	d2801800 	mov	x0, #0xc0                  	// #192
  40d87c:	9b005e60 	madd	x0, x19, x0, x23
  40d880:	39406401 	ldrb	w1, [x0, #25]
  40d884:	121d7821 	and	w1, w1, #0xfffffffb
  40d888:	39006401 	strb	w1, [x0, #25]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40d88c:	d2800501 	mov	x1, #0x28                  	// #40
	_kernel.cpus[id].id = id;
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40d890:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40d894:	9b015a61 	madd	x1, x19, x1, x22
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40d898:	f946f800 	ldr	x0, [x0, #3568]
	_kernel.cpus[id].id = id;
  40d89c:	39008033 	strb	w19, [x1, #32]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40d8a0:	91000673 	add	x19, x19, #0x1
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40d8a4:	f9000c35 	str	x21, [x1, #24]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40d8a8:	8b132c13 	add	x19, x0, x19, lsl #11
	_kernel.cpus[id].irq_stack =
  40d8ac:	f9000433 	str	x19, [x1, #8]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  40d8b0:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40d8b4:	d2800020 	mov	x0, #0x1                   	// #1
  40d8b8:	f9477021 	ldr	x1, [x1, #3808]
  40d8bc:	97ffcf55 	bl	401610 <__aarch64_ldadd8_acq_rel>
	/*
	 * Increment number of CPUs active. The pm subsystem
	 * will keep track of this from here.
	 */
	atomic_inc(&_cpus_active);
}
  40d8c0:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40d8c4:	a94253f3 	ldp	x19, x20, [sp, #32]
  40d8c8:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40d8cc:	f94023f7 	ldr	x23, [sp, #64]
  40d8d0:	910143ff 	add	sp, sp, #0x50
  40d8d4:	d65f03c0 	ret

000000000040d8d8 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
  40d8d8:	d10403ff 	sub	sp, sp, #0x100
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  40d8dc:	52800000 	mov	w0, #0x0                   	// #0
{
  40d8e0:	a9017bfd 	stp	x29, x30, [sp, #16]
  40d8e4:	910043fd 	add	x29, sp, #0x10
  40d8e8:	a90253f3 	stp	x19, x20, [sp, #32]

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
  40d8ec:	d00000f4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
	_kernel.ready_q.cache = &z_main_thread;
  40d8f0:	d00000f3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
{
  40d8f4:	f9001bf5 	str	x21, [sp, #48]
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  40d8f8:	97ffff88 	bl	40d718 <z_sys_init_run_level>

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
  40d8fc:	97ffe945 	bl	407e10 <log_core_init>
	dummy_thread->resource_pool = NULL;
  40d900:	f9007bff 	str	xzr, [sp, #240]
	_current_cpu->current = dummy_thread;
  40d904:	f9472e94 	ldr	x20, [x20, #3672]
	dummy_thread->base.user_options = K_ESSENTIAL;
  40d908:	52802020 	mov	w0, #0x101                 	// #257
  40d90c:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
  40d910:	910103e0 	add	x0, sp, #0x40
  40d914:	f9000a80 	str	x0, [x20, #16]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
  40d918:	97fffebf 	bl	40d414 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
  40d91c:	52800020 	mov	w0, #0x1                   	// #1
  40d920:	97ffff7e 	bl	40d718 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
  40d924:	52800040 	mov	w0, #0x2                   	// #2
  40d928:	97ffff7c 	bl	40d718 <z_sys_init_run_level>
	z_sched_init();
  40d92c:	940010c7 	bl	411c48 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40d930:	d00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40d934:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
	_kernel.ready_q.cache = &z_main_thread;
  40d938:	f947ea73 	ldr	x19, [x19, #4048]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40d93c:	913dfc00 	add	x0, x0, #0xf7f
  40d940:	f9477821 	ldr	x1, [x1, #3824]
	_kernel.ready_q.cache = &z_main_thread;
  40d944:	f9001693 	str	x19, [x20, #40]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40d948:	f90007e0 	str	x0, [sp, #8]
  40d94c:	52800020 	mov	w0, #0x1                   	// #1
  40d950:	b90003e0 	str	w0, [sp]
  40d954:	90000014 	adrp	x20, 40d000 <can_loopback_init+0xe4>
  40d958:	911ea294 	add	x20, x20, #0x7a8
  40d95c:	52800007 	mov	w7, #0x0                   	// #0
  40d960:	aa1403e3 	mov	x3, x20
  40d964:	d2800006 	mov	x6, #0x0                   	// #0
  40d968:	d2800005 	mov	x5, #0x0                   	// #0
  40d96c:	d2800004 	mov	x4, #0x0                   	// #0
  40d970:	d2804002 	mov	x2, #0x200                 	// #512
  40d974:	aa1303e0 	mov	x0, x19
  40d978:	94000218 	bl	40e1d8 <z_setup_new_thread>
  40d97c:	aa0003f5 	mov	x21, x0
  40d980:	39406660 	ldrb	w0, [x19, #25]
  40d984:	121d7800 	and	w0, w0, #0xfffffffb
  40d988:	39006660 	strb	w0, [x19, #25]
	z_ready_thread(&z_main_thread);
  40d98c:	aa1303e0 	mov	x0, x19
  40d990:	94000cfe 	bl	410d88 <z_ready_thread>
	z_init_cpu(0);
  40d994:	52800000 	mov	w0, #0x0                   	// #0
  40d998:	97ffff98 	bl	40d7f8 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  40d99c:	aa1403e2 	mov	x2, x20
  40d9a0:	aa1503e1 	mov	x1, x21
  40d9a4:	aa1303e0 	mov	x0, x19
  40d9a8:	97ffee28 	bl	409248 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  40d9ac:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40d9b0:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40d9b4:	913e1021 	add	x1, x1, #0xf84
  40d9b8:	911b8000 	add	x0, x0, #0x6e0
  40d9bc:	52803a82 	mov	w2, #0x1d4                 	// #468
  40d9c0:	97fff24a 	bl	40a2e8 <posix_print_error_and_exit>

000000000040d9c4 <k_heap_init>:
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
  40d9c4:	91006004 	add	x4, x0, #0x18
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
  40d9c8:	a9019004 	stp	x4, x4, [x0, #24]
#include <zephyr/sys/iterable_sections.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
  40d9cc:	17ffe459 	b	406b30 <sys_heap_init>

000000000040d9d0 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
  40d9d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40d9d4:	910003fd 	mov	x29, sp
  40d9d8:	a90153f3 	stp	x19, x20, [sp, #16]
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40d9dc:	d00000f3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  40d9e0:	d00000f4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  40d9e4:	f9474673 	ldr	x19, [x19, #3720]
  40d9e8:	f9473294 	ldr	x20, [x20, #3680]
  40d9ec:	eb14027f 	cmp	x19, x20
  40d9f0:	54000349 	b.ls	40da58 <statics_init+0x88>  // b.plast
  40d9f4:	90000053 	adrp	x19, 415000 <random_data+0xd8c>
  40d9f8:	913ea273 	add	x19, x19, #0xfa8
  40d9fc:	aa1303e2 	mov	x2, x19
  40da00:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40da04:	913f2821 	add	x1, x1, #0xfca
  40da08:	52800303 	mov	w3, #0x18                  	// #24
  40da0c:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40da10:	911a8800 	add	x0, x0, #0x6a2
  40da14:	97ffe819 	bl	407a78 <assert_print>
  40da18:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40da1c:	91278c00 	add	x0, x0, #0x9e3
  40da20:	97ffe816 	bl	407a78 <assert_print>
  40da24:	aa1303e0 	mov	x0, x19
  40da28:	52800301 	mov	w1, #0x18                  	// #24
  40da2c:	97ffe83d 	bl	407b20 <assert_post_action>
  40da30:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40da34:	aa1303e1 	mov	x1, x19
  40da38:	911b8000 	add	x0, x0, #0x6e0
  40da3c:	52800302 	mov	w2, #0x18                  	// #24
  40da40:	97fff22a 	bl	40a2e8 <posix_print_error_and_exit>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  40da44:	a9408a61 	ldp	x1, x2, [x19, #8]
  40da48:	aa1303e0 	mov	x0, x19
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40da4c:	9100c273 	add	x19, x19, #0x30
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  40da50:	97ffffdd 	bl	40d9c4 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40da54:	17ffffe6 	b	40d9ec <statics_init+0x1c>
  40da58:	54ffff63 	b.cc	40da44 <statics_init+0x74>  // b.lo, b.ul, b.last
		}
	}
	return 0;
}
  40da5c:	52800000 	mov	w0, #0x0                   	// #0
  40da60:	a94153f3 	ldp	x19, x20, [sp, #16]
  40da64:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40da68:	d65f03c0 	ret

000000000040da6c <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
  40da6c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40da70:	910003fd 	mov	x29, sp
  40da74:	a90153f3 	stp	x19, x20, [sp, #16]
  40da78:	a9025bf5 	stp	x21, x22, [sp, #32]
  40da7c:	aa0303f6 	mov	x22, x3
  40da80:	aa0003f5 	mov	x21, x0
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  40da84:	aa0303e0 	mov	x0, x3
{
  40da88:	a90363f7 	stp	x23, x24, [sp, #48]
  40da8c:	aa0103f7 	mov	x23, x1
  40da90:	aa0203f8 	mov	x24, x2
  40da94:	a9046bf9 	stp	x25, x26, [sp, #64]
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  40da98:	9400152c 	bl	412f48 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  40da9c:	b10006df 	cmn	x22, #0x1
  40daa0:	92f00001 	mov	x1, #0x7fffffffffffffff    	// #9223372036854775807

	k_spinlock_key_t key = k_spin_lock(&h->lock);
  40daa4:	9100a2b3 	add	x19, x21, #0x28
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  40daa8:	9a811019 	csel	x25, x0, x1, ne  // ne = any
	return posix_irq_lock();
  40daac:	97fff0f9 	bl	409e90 <posix_irq_lock>
  40dab0:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40dab4:	aa1303e0 	mov	x0, x19
  40dab8:	940002b4 	bl	40e588 <z_spin_lock_valid>
  40dabc:	72001c1f 	tst	w0, #0xff
  40dac0:	54000281 	b.ne	40db10 <k_heap_aligned_alloc+0xa4>  // b.any
  40dac4:	90000054 	adrp	x20, 415000 <random_data+0xd8c>
  40dac8:	912faa94 	add	x20, x20, #0xbea
  40dacc:	aa1403e2 	mov	x2, x20
  40dad0:	52801283 	mov	w3, #0x94                  	// #148
  40dad4:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40dad8:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40dadc:	91305c21 	add	x1, x1, #0xc17
  40dae0:	911a8800 	add	x0, x0, #0x6a2
  40dae4:	97ffe7e5 	bl	407a78 <assert_print>
  40dae8:	aa1303e1 	mov	x1, x19
  40daec:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40daf0:	9130b000 	add	x0, x0, #0xc2c
  40daf4:	97ffe7e1 	bl	407a78 <assert_print>
  40daf8:	aa1403e0 	mov	x0, x20
  40dafc:	52801281 	mov	w1, #0x94                  	// #148
  40db00:	97ffe808 	bl	407b20 <assert_post_action>
  40db04:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40db08:	aa1403e1 	mov	x1, x20
  40db0c:	14000019 	b	40db70 <k_heap_aligned_alloc+0x104>
	z_spin_lock_set_owner(l);
  40db10:	aa1303e0 	mov	x0, x19
  40db14:	940002b5 	bl	40e5e8 <z_spin_lock_set_owner>
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
  40db18:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40db1c:	f9472c00 	ldr	x0, [x0, #3672]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40db20:	b9400000 	ldr	w0, [x0]
  40db24:	34000860 	cbz	w0, 40dc30 <k_heap_aligned_alloc+0x1c4>
  40db28:	b4000856 	cbz	x22, 40dc30 <k_heap_aligned_alloc+0x1c4>
  40db2c:	90000053 	adrp	x19, 415000 <random_data+0xd8c>
  40db30:	913ea273 	add	x19, x19, #0xfa8
  40db34:	aa1303e2 	mov	x2, x19
  40db38:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40db3c:	913f8021 	add	x1, x1, #0xfe0
  40db40:	52800983 	mov	w3, #0x4c                  	// #76
  40db44:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40db48:	911a8800 	add	x0, x0, #0x6a2
  40db4c:	97ffe7cb 	bl	407a78 <assert_print>
  40db50:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40db54:	91320400 	add	x0, x0, #0xc81
  40db58:	97ffe7c8 	bl	407a78 <assert_print>
  40db5c:	52800981 	mov	w1, #0x4c                  	// #76
  40db60:	aa1303e0 	mov	x0, x19
  40db64:	97ffe7ef 	bl	407b20 <assert_post_action>
  40db68:	aa1303e1 	mov	x1, x19
  40db6c:	52800982 	mov	w2, #0x4c                  	// #76
  40db70:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40db74:	911b8000 	add	x0, x0, #0x6e0
  40db78:	97fff1dc 	bl	40a2e8 <posix_print_error_and_exit>
	while (ret == NULL) {
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);

		now = sys_clock_tick_get();
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
		    (ret != NULL) || ((end - now) <= 0)) {
  40db7c:	cb030323 	sub	x3, x25, x3
  40db80:	f100007f 	cmp	x3, #0x0
  40db84:	540002ad 	b.le	40dbd8 <k_heap_aligned_alloc+0x16c>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  40db88:	2a1403e1 	mov	w1, w20
  40db8c:	aa1a03e2 	mov	x2, x26
  40db90:	aa1303e0 	mov	x0, x19
  40db94:	94000dc6 	bl	4112ac <z_pend_curr>
  40db98:	97fff0be 	bl	409e90 <posix_irq_lock>
  40db9c:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40dba0:	aa1303e0 	mov	x0, x19
  40dba4:	94000279 	bl	40e588 <z_spin_lock_valid>
  40dba8:	72001c1f 	tst	w0, #0xff
  40dbac:	54fff8c0 	b.eq	40dac4 <k_heap_aligned_alloc+0x58>  // b.none
	z_spin_lock_set_owner(l);
  40dbb0:	aa1303e0 	mov	x0, x19
  40dbb4:	9400028d 	bl	40e5e8 <z_spin_lock_set_owner>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
  40dbb8:	aa1803e2 	mov	x2, x24
  40dbbc:	aa1703e1 	mov	x1, x23
  40dbc0:	aa1503e0 	mov	x0, x21
  40dbc4:	97ffe372 	bl	40698c <sys_heap_aligned_alloc>
  40dbc8:	aa0003f6 	mov	x22, x0
		now = sys_clock_tick_get();
  40dbcc:	94001495 	bl	412e20 <sys_clock_tick_get>
  40dbd0:	aa0003e3 	mov	x3, x0
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
  40dbd4:	b4fffd56 	cbz	x22, 40db7c <k_heap_aligned_alloc+0x110>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dbd8:	aa1303e0 	mov	x0, x19
  40dbdc:	94000276 	bl	40e5b4 <z_spin_unlock_valid>
  40dbe0:	72001c1f 	tst	w0, #0xff
  40dbe4:	540002a1 	b.ne	40dc38 <k_heap_aligned_alloc+0x1cc>  // b.any
  40dbe8:	90000054 	adrp	x20, 415000 <random_data+0xd8c>
  40dbec:	912faa94 	add	x20, x20, #0xbea
  40dbf0:	aa1403e2 	mov	x2, x20
  40dbf4:	52801863 	mov	w3, #0xc3                  	// #195
  40dbf8:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40dbfc:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40dc00:	91311021 	add	x1, x1, #0xc44
  40dc04:	911a8800 	add	x0, x0, #0x6a2
  40dc08:	97ffe79c 	bl	407a78 <assert_print>
  40dc0c:	aa1303e1 	mov	x1, x19
  40dc10:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40dc14:	91316c00 	add	x0, x0, #0xc5b
  40dc18:	97ffe798 	bl	407a78 <assert_print>
  40dc1c:	aa1403e0 	mov	x0, x20
  40dc20:	52801861 	mov	w1, #0xc3                  	// #195
  40dc24:	97ffe7bf 	bl	407b20 <assert_post_action>
  40dc28:	52801862 	mov	w2, #0xc3                  	// #195
  40dc2c:	17ffffb7 	b	40db08 <k_heap_aligned_alloc+0x9c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  40dc30:	910062ba 	add	x26, x21, #0x18
  40dc34:	17ffffe1 	b	40dbb8 <k_heap_aligned_alloc+0x14c>
	posix_irq_unlock(key);
  40dc38:	2a1403e0 	mov	w0, w20
  40dc3c:	97fff097 	bl	409e98 <posix_irq_unlock>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
  40dc40:	aa1603e0 	mov	x0, x22
  40dc44:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dc48:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dc4c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40dc50:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40dc54:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40dc58:	d65f03c0 	ret

000000000040dc5c <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
  40dc5c:	aa0203e3 	mov	x3, x2
  40dc60:	aa0103e2 	mov	x2, x1
  40dc64:	d2800101 	mov	x1, #0x8                   	// #8
  40dc68:	17ffff81 	b	40da6c <k_heap_aligned_alloc>

000000000040dc6c <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
  40dc6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40dc70:	910003fd 	mov	x29, sp
  40dc74:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  40dc78:	9100a013 	add	x19, x0, #0x28
{
  40dc7c:	aa0003f4 	mov	x20, x0
  40dc80:	a9025bf5 	stp	x21, x22, [sp, #32]
  40dc84:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  40dc88:	97fff082 	bl	409e90 <posix_irq_lock>
  40dc8c:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40dc90:	aa1303e0 	mov	x0, x19
  40dc94:	9400023d 	bl	40e588 <z_spin_lock_valid>
  40dc98:	72001c1f 	tst	w0, #0xff
  40dc9c:	540002c1 	b.ne	40dcf4 <k_heap_free+0x88>  // b.any
  40dca0:	90000054 	adrp	x20, 415000 <random_data+0xd8c>
  40dca4:	912faa94 	add	x20, x20, #0xbea
  40dca8:	aa1403e2 	mov	x2, x20
  40dcac:	52801283 	mov	w3, #0x94                  	// #148
  40dcb0:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40dcb4:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40dcb8:	91305c21 	add	x1, x1, #0xc17
  40dcbc:	911a8800 	add	x0, x0, #0x6a2
  40dcc0:	97ffe76e 	bl	407a78 <assert_print>
  40dcc4:	aa1303e1 	mov	x1, x19
  40dcc8:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40dccc:	9130b000 	add	x0, x0, #0xc2c
  40dcd0:	97ffe76a 	bl	407a78 <assert_print>
  40dcd4:	aa1403e0 	mov	x0, x20
  40dcd8:	52801281 	mov	w1, #0x94                  	// #148
  40dcdc:	97ffe791 	bl	407b20 <assert_post_action>
  40dce0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dce4:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40dce8:	aa1403e1 	mov	x1, x20
  40dcec:	911b8000 	add	x0, x0, #0x6e0
  40dcf0:	97fff17e 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40dcf4:	aa1303e0 	mov	x0, x19
  40dcf8:	9400023c 	bl	40e5e8 <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
  40dcfc:	aa1603e1 	mov	x1, x22
  40dd00:	aa1403e0 	mov	x0, x20
  40dd04:	97ffe2b1 	bl	4067c8 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
  40dd08:	91006280 	add	x0, x20, #0x18
  40dd0c:	94000fba 	bl	411bf4 <z_unpend_all>
  40dd10:	340000e0 	cbz	w0, 40dd2c <k_heap_free+0xc0>
		z_reschedule(&h->lock, key);
  40dd14:	2a1503e1 	mov	w1, w21
  40dd18:	aa1303e0 	mov	x0, x19
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
  40dd1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dd20:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dd24:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&h->lock, key);
  40dd28:	140009bd 	b	41041c <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40dd2c:	aa1303e0 	mov	x0, x19
  40dd30:	94000221 	bl	40e5b4 <z_spin_unlock_valid>
  40dd34:	72001c1f 	tst	w0, #0xff
  40dd38:	54000261 	b.ne	40dd84 <k_heap_free+0x118>  // b.any
  40dd3c:	90000054 	adrp	x20, 415000 <random_data+0xd8c>
  40dd40:	912faa94 	add	x20, x20, #0xbea
  40dd44:	aa1403e2 	mov	x2, x20
  40dd48:	52801863 	mov	w3, #0xc3                  	// #195
  40dd4c:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40dd50:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40dd54:	91311021 	add	x1, x1, #0xc44
  40dd58:	911a8800 	add	x0, x0, #0x6a2
  40dd5c:	97ffe747 	bl	407a78 <assert_print>
  40dd60:	aa1303e1 	mov	x1, x19
  40dd64:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40dd68:	91316c00 	add	x0, x0, #0xc5b
  40dd6c:	97ffe743 	bl	407a78 <assert_print>
  40dd70:	aa1403e0 	mov	x0, x20
  40dd74:	52801861 	mov	w1, #0xc3                  	// #195
  40dd78:	97ffe76a 	bl	407b20 <assert_post_action>
  40dd7c:	52801862 	mov	w2, #0xc3                  	// #195
  40dd80:	17ffffd9 	b	40dce4 <k_heap_free+0x78>
	posix_irq_unlock(key);
  40dd84:	2a1503e0 	mov	w0, w21
}
  40dd88:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dd8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dd90:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40dd94:	17fff041 	b	409e98 <posix_irq_unlock>

000000000040dd98 <create_free_list>:
{
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  40dd98:	a9420402 	ldp	x2, x1, [x0, #32]
  40dd9c:	aa020022 	orr	x2, x1, x2
  40dda0:	f240085f 	tst	x2, #0x7
  40dda4:	540001e1 	b.ne	40dde0 <create_free_list+0x48>  // b.any
	}

	slab->free_list = NULL;
	p = slab->buffer;

	for (j = 0U; j < slab->num_blocks; j++) {
  40dda8:	52800002 	mov	w2, #0x0                   	// #0
	slab->free_list = NULL;
  40ddac:	f900181f 	str	xzr, [x0, #48]
	for (j = 0U; j < slab->num_blocks; j++) {
  40ddb0:	b9401803 	ldr	w3, [x0, #24]
  40ddb4:	6b02007f 	cmp	w3, w2
  40ddb8:	54000068 	b.hi	40ddc4 <create_free_list+0x2c>  // b.pmore
		*(char **)p = slab->free_list;
		slab->free_list = p;
		p += slab->block_size;
	}
	return 0;
  40ddbc:	52800000 	mov	w0, #0x0                   	// #0
}
  40ddc0:	d65f03c0 	ret
		*(char **)p = slab->free_list;
  40ddc4:	f9401803 	ldr	x3, [x0, #48]
  40ddc8:	f9000023 	str	x3, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
  40ddcc:	11000442 	add	w2, w2, #0x1
		slab->free_list = p;
  40ddd0:	f9001801 	str	x1, [x0, #48]
		p += slab->block_size;
  40ddd4:	f9401003 	ldr	x3, [x0, #32]
  40ddd8:	8b030021 	add	x1, x1, x3
	for (j = 0U; j < slab->num_blocks; j++) {
  40dddc:	17fffff5 	b	40ddb0 <create_free_list+0x18>
		return -EINVAL;
  40dde0:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40dde4:	17fffff7 	b	40ddc0 <create_free_list+0x28>

000000000040dde8 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
  40dde8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int rc = 0;

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40ddec:	d00000e4 	adrp	x4, 42b000 <__FRAME_END__+0x1007c>
  40ddf0:	d00000e5 	adrp	x5, 42b000 <__FRAME_END__+0x1007c>
{
  40ddf4:	910003fd 	mov	x29, sp
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40ddf8:	f947e484 	ldr	x4, [x4, #4040]
	int rc = 0;
  40ddfc:	52800000 	mov	w0, #0x0                   	// #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40de00:	f946f4a5 	ldr	x5, [x5, #3560]
{
  40de04:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40de08:	eb05009f 	cmp	x4, x5
  40de0c:	54000349 	b.ls	40de74 <init_mem_slab_module+0x8c>  // b.plast
  40de10:	b0000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40de14:	91009a73 	add	x19, x19, #0x26
  40de18:	aa1303e2 	mov	x2, x19
  40de1c:	b0000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40de20:	91012c21 	add	x1, x1, #0x4b
  40de24:	528007a3 	mov	w3, #0x3d                  	// #61
  40de28:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40de2c:	911a8800 	add	x0, x0, #0x6a2
  40de30:	97ffe712 	bl	407a78 <assert_print>
  40de34:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40de38:	91278c00 	add	x0, x0, #0x9e3
  40de3c:	97ffe70f 	bl	407a78 <assert_print>
  40de40:	aa1303e0 	mov	x0, x19
  40de44:	528007a1 	mov	w1, #0x3d                  	// #61
  40de48:	97ffe736 	bl	407b20 <assert_post_action>
  40de4c:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40de50:	aa1303e1 	mov	x1, x19
  40de54:	911b8000 	add	x0, x0, #0x6e0
  40de58:	528007a2 	mov	w2, #0x3d                  	// #61
  40de5c:	97fff123 	bl	40a2e8 <posix_print_error_and_exit>
		rc = create_free_list(slab);
  40de60:	aa0403e0 	mov	x0, x4
  40de64:	97ffffcd 	bl	40dd98 <create_free_list>
		if (rc < 0) {
  40de68:	37f80080 	tbnz	w0, #31, 40de78 <init_mem_slab_module+0x90>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40de6c:	91010084 	add	x4, x4, #0x40
  40de70:	17ffffe6 	b	40de08 <init_mem_slab_module+0x20>
  40de74:	54ffff63 	b.cc	40de60 <init_mem_slab_module+0x78>  // b.lo, b.ul, b.last
		z_object_init(slab);
	}

out:
	return rc;
}
  40de78:	f9400bf3 	ldr	x19, [sp, #16]
  40de7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40de80:	d65f03c0 	ret

000000000040de84 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
  40de84:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40de88:	910003fd 	mov	x29, sp
  40de8c:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  40de90:	91004014 	add	x20, x0, #0x10
{
  40de94:	aa0003f3 	mov	x19, x0
  40de98:	a9025bf5 	stp	x21, x22, [sp, #32]
  40de9c:	aa0103f5 	mov	x21, x1
  40dea0:	f9001bf7 	str	x23, [sp, #48]
  40dea4:	aa0203f7 	mov	x23, x2
	return posix_irq_lock();
  40dea8:	97ffeffa 	bl	409e90 <posix_irq_lock>
  40deac:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40deb0:	aa1403e0 	mov	x0, x20
  40deb4:	940001b5 	bl	40e588 <z_spin_lock_valid>
  40deb8:	72001c1f 	tst	w0, #0xff
  40debc:	540002c1 	b.ne	40df14 <k_mem_slab_alloc+0x90>  // b.any
  40dec0:	90000053 	adrp	x19, 415000 <random_data+0xd8c>
  40dec4:	912faa73 	add	x19, x19, #0xbea
  40dec8:	aa1303e2 	mov	x2, x19
  40decc:	52801283 	mov	w3, #0x94                  	// #148
  40ded0:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40ded4:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ded8:	91305c21 	add	x1, x1, #0xc17
  40dedc:	911a8800 	add	x0, x0, #0x6a2
  40dee0:	97ffe6e6 	bl	407a78 <assert_print>
  40dee4:	aa1403e1 	mov	x1, x20
  40dee8:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40deec:	9130b000 	add	x0, x0, #0xc2c
  40def0:	97ffe6e2 	bl	407a78 <assert_print>
  40def4:	aa1303e0 	mov	x0, x19
  40def8:	52801281 	mov	w1, #0x94                  	// #148
  40defc:	97ffe709 	bl	407b20 <assert_post_action>
  40df00:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40df04:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40df08:	aa1303e1 	mov	x1, x19
  40df0c:	911b8000 	add	x0, x0, #0x6e0
  40df10:	97fff0f6 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40df14:	aa1403e0 	mov	x0, x20
  40df18:	940001b4 	bl	40e5e8 <z_spin_lock_set_owner>
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
  40df1c:	f9401a60 	ldr	x0, [x19, #48]
  40df20:	b40003c0 	cbz	x0, 40df98 <k_mem_slab_alloc+0x114>
		/* take a free block */
		*mem = slab->free_list;
  40df24:	f90002a0 	str	x0, [x21]
		slab->free_list = *(char **)(slab->free_list);
  40df28:	f9400000 	ldr	x0, [x0]
  40df2c:	f9001a60 	str	x0, [x19, #48]
		slab->num_used++;
  40df30:	b9403a60 	ldr	w0, [x19, #56]
  40df34:	11000400 	add	w0, w0, #0x1
  40df38:	b9003a60 	str	w0, [x19, #56]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
  40df3c:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40df40:	aa1403e0 	mov	x0, x20
  40df44:	9400019c 	bl	40e5b4 <z_spin_unlock_valid>
  40df48:	72001c1f 	tst	w0, #0xff
  40df4c:	54000521 	b.ne	40dff0 <k_mem_slab_alloc+0x16c>  // b.any
  40df50:	90000053 	adrp	x19, 415000 <random_data+0xd8c>
  40df54:	912faa73 	add	x19, x19, #0xbea
  40df58:	aa1303e2 	mov	x2, x19
  40df5c:	52801863 	mov	w3, #0xc3                  	// #195
  40df60:	90000041 	adrp	x1, 415000 <random_data+0xd8c>
  40df64:	f0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40df68:	91311021 	add	x1, x1, #0xc44
  40df6c:	911a8800 	add	x0, x0, #0x6a2
  40df70:	97ffe6c2 	bl	407a78 <assert_print>
  40df74:	aa1403e1 	mov	x1, x20
  40df78:	90000040 	adrp	x0, 415000 <random_data+0xd8c>
  40df7c:	91316c00 	add	x0, x0, #0xc5b
  40df80:	97ffe6be 	bl	407a78 <assert_print>
  40df84:	aa1303e0 	mov	x0, x19
  40df88:	52801861 	mov	w1, #0xc3                  	// #195
  40df8c:	97ffe6e5 	bl	407b20 <assert_post_action>
  40df90:	52801862 	mov	w2, #0xc3                  	// #195
  40df94:	17ffffdc 	b	40df04 <k_mem_slab_alloc+0x80>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
  40df98:	b5000097 	cbnz	x23, 40dfa8 <k_mem_slab_alloc+0x124>
		   !IS_ENABLED(CONFIG_MULTITHREADING)) {
		/* don't wait for a free block to become available */
		*mem = NULL;
		result = -ENOMEM;
  40df9c:	12800173 	mov	w19, #0xfffffff4            	// #-12
		*mem = NULL;
  40dfa0:	f90002bf 	str	xzr, [x21]
		result = -ENOMEM;
  40dfa4:	17ffffe7 	b	40df40 <k_mem_slab_alloc+0xbc>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);

		/* wait for a free block or timeout */
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
  40dfa8:	aa1303e2 	mov	x2, x19
  40dfac:	aa1703e3 	mov	x3, x23
  40dfb0:	2a1603e1 	mov	w1, w22
  40dfb4:	aa1403e0 	mov	x0, x20
  40dfb8:	94000cbd 	bl	4112ac <z_pend_curr>
  40dfbc:	2a0003f3 	mov	w19, w0
		if (result == 0) {
  40dfc0:	350000c0 	cbnz	w0, 40dfd8 <k_mem_slab_alloc+0x154>
			*mem = _current->base.swap_data;
  40dfc4:	d00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40dfc8:	f9472c00 	ldr	x0, [x0, #3672]
  40dfcc:	f9400800 	ldr	x0, [x0, #16]
  40dfd0:	f9401000 	ldr	x0, [x0, #32]
  40dfd4:	f90002a0 	str	x0, [x21]
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
  40dfd8:	2a1303e0 	mov	w0, w19
  40dfdc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dfe0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dfe4:	f9401bf7 	ldr	x23, [sp, #48]
  40dfe8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40dfec:	d65f03c0 	ret
	posix_irq_unlock(key);
  40dff0:	2a1603e0 	mov	w0, w22
  40dff4:	97ffefa9 	bl	409e98 <posix_irq_unlock>
	return result;
  40dff8:	17fffff8 	b	40dfd8 <k_mem_slab_alloc+0x154>

000000000040dffc <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
  40dffc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40e000:	910003fd 	mov	x29, sp
  40e004:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  40e008:	91004014 	add	x20, x0, #0x10
{
  40e00c:	aa0003f3 	mov	x19, x0
  40e010:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e014:	aa0103f5 	mov	x21, x1
	return posix_irq_lock();
  40e018:	97ffef9e 	bl	409e90 <posix_irq_lock>
  40e01c:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40e020:	aa1403e0 	mov	x0, x20
  40e024:	94000159 	bl	40e588 <z_spin_lock_valid>
  40e028:	72001c1f 	tst	w0, #0xff
  40e02c:	540002c1 	b.ne	40e084 <k_mem_slab_free+0x88>  // b.any
  40e030:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40e034:	912faa73 	add	x19, x19, #0xbea
  40e038:	aa1303e2 	mov	x2, x19
  40e03c:	52801283 	mov	w3, #0x94                  	// #148
  40e040:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40e044:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e048:	91305c21 	add	x1, x1, #0xc17
  40e04c:	911a8800 	add	x0, x0, #0x6a2
  40e050:	97ffe68a 	bl	407a78 <assert_print>
  40e054:	aa1403e1 	mov	x1, x20
  40e058:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40e05c:	9130b000 	add	x0, x0, #0xc2c
  40e060:	97ffe686 	bl	407a78 <assert_print>
  40e064:	aa1303e0 	mov	x0, x19
  40e068:	52801281 	mov	w1, #0x94                  	// #148
  40e06c:	97ffe6ad 	bl	407b20 <assert_post_action>
  40e070:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e074:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e078:	aa1303e1 	mov	x1, x19
  40e07c:	911b8000 	add	x0, x0, #0x6e0
  40e080:	97fff09a 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40e084:	aa1403e0 	mov	x0, x20
  40e088:	94000158 	bl	40e5e8 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
  40e08c:	f9401a60 	ldr	x0, [x19, #48]
  40e090:	b50001c0 	cbnz	x0, 40e0c8 <k_mem_slab_free+0xcc>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
  40e094:	aa1303e0 	mov	x0, x19
  40e098:	94000e8d 	bl	411acc <z_unpend_first_thread>

		if (pending_thread != NULL) {
  40e09c:	b4000160 	cbz	x0, 40e0c8 <k_mem_slab_free+0xcc>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
  40e0a0:	f94002a1 	ldr	x1, [x21]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
  40e0a4:	f9001001 	str	x1, [x0, #32]
	thread->callee_saved.retval = value;
  40e0a8:	b9004c1f 	str	wzr, [x0, #76]
			z_ready_thread(pending_thread);
  40e0ac:	94000b37 	bl	410d88 <z_ready_thread>
			z_reschedule(&slab->lock, key);
  40e0b0:	2a1603e1 	mov	w1, w22
  40e0b4:	aa1403e0 	mov	x0, x20
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
  40e0b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e0bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e0c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
			z_reschedule(&slab->lock, key);
  40e0c4:	140008d6 	b	41041c <z_reschedule>
	**(char ***) mem = slab->free_list;
  40e0c8:	f94002a0 	ldr	x0, [x21]
  40e0cc:	f9401a61 	ldr	x1, [x19, #48]
  40e0d0:	f9000001 	str	x1, [x0]
	slab->free_list = *(char **) mem;
  40e0d4:	f94002a0 	ldr	x0, [x21]
  40e0d8:	f9001a60 	str	x0, [x19, #48]
	slab->num_used--;
  40e0dc:	b9403a60 	ldr	w0, [x19, #56]
  40e0e0:	51000400 	sub	w0, w0, #0x1
  40e0e4:	b9003a60 	str	w0, [x19, #56]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e0e8:	aa1403e0 	mov	x0, x20
  40e0ec:	94000132 	bl	40e5b4 <z_spin_unlock_valid>
  40e0f0:	72001c1f 	tst	w0, #0xff
  40e0f4:	54000261 	b.ne	40e140 <k_mem_slab_free+0x144>  // b.any
  40e0f8:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40e0fc:	912faa73 	add	x19, x19, #0xbea
  40e100:	aa1303e2 	mov	x2, x19
  40e104:	52801863 	mov	w3, #0xc3                  	// #195
  40e108:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40e10c:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e110:	91311021 	add	x1, x1, #0xc44
  40e114:	911a8800 	add	x0, x0, #0x6a2
  40e118:	97ffe658 	bl	407a78 <assert_print>
  40e11c:	aa1403e1 	mov	x1, x20
  40e120:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40e124:	91316c00 	add	x0, x0, #0xc5b
  40e128:	97ffe654 	bl	407a78 <assert_print>
  40e12c:	aa1303e0 	mov	x0, x19
  40e130:	52801861 	mov	w1, #0xc3                  	// #195
  40e134:	97ffe67b 	bl	407b20 <assert_post_action>
  40e138:	52801862 	mov	w2, #0xc3                  	// #195
  40e13c:	17ffffce 	b	40e074 <k_mem_slab_free+0x78>
	posix_irq_unlock(key);
  40e140:	2a1603e0 	mov	w0, w22
}
  40e144:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e148:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e14c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40e150:	17ffef52 	b	409e98 <posix_irq_unlock>

000000000040e154 <k_is_in_isr>:
	return _kernel.cpus[0].nested != 0U;
  40e154:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40e158:	f9472c00 	ldr	x0, [x0, #3672]
  40e15c:	b9400000 	ldr	w0, [x0]
  40e160:	7100001f 	cmp	w0, #0x0
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
  40e164:	1a9f07e0 	cset	w0, ne  // ne = any
  40e168:	d65f03c0 	ret

000000000040e16c <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
  40e16c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e170:	910003fd 	mov	x29, sp
  40e174:	f9000bf3 	str	x19, [sp, #16]
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
  40e178:	b5000180 	cbnz	x0, 40e1a8 <z_impl_k_thread_name_set+0x3c>
		thread = _current;
  40e17c:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40e180:	f9472c00 	ldr	x0, [x0, #3672]
  40e184:	f9400813 	ldr	x19, [x0, #16]

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len,
  40e188:	91022660 	add	x0, x19, #0x89
  40e18c:	d28003e2 	mov	x2, #0x1f                  	// #31
  40e190:	97ffccb0 	bl	401450 <strncpy@plt>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  40e194:	3902a27f 	strb	wzr, [x19, #168]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
  40e198:	52800000 	mov	w0, #0x0                   	// #0
  40e19c:	f9400bf3 	ldr	x19, [sp, #16]
  40e1a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e1a4:	d65f03c0 	ret
  40e1a8:	aa0003f3 	mov	x19, x0
  40e1ac:	17fffff7 	b	40e188 <z_impl_k_thread_name_set+0x1c>

000000000040e1b0 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
  40e1b0:	91022400 	add	x0, x0, #0x89
  40e1b4:	d65f03c0 	ret

000000000040e1b8 <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
  40e1b8:	14000b35 	b	410e8c <z_sched_start>

000000000040e1bc <z_init_thread_base>:

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
  40e1bc:	f900081f 	str	xzr, [x0, #16]
	thread_base->user_options = (uint8_t)options;
  40e1c0:	39006003 	strb	w3, [x0, #24]
	thread_base->thread_state = (uint8_t)initial_state;
  40e1c4:	39006402 	strb	w2, [x0, #25]

	thread_base->prio = priority;
  40e1c8:	39006801 	strb	w1, [x0, #26]

	thread_base->sched_locked = 0U;
  40e1cc:	39006c1f 	strb	wzr, [x0, #27]
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
  40e1d0:	a902fc1f 	stp	xzr, xzr, [x0, #40]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
  40e1d4:	d65f03c0 	ret

000000000040e1d8 <z_setup_new_thread>:
{
  40e1d8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40e1dc:	910003fd 	mov	x29, sp
  40e1e0:	a90153f3 	stp	x19, x20, [sp, #16]
  40e1e4:	aa0003f3 	mov	x19, x0
  40e1e8:	aa0203f4 	mov	x20, x2
  40e1ec:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e1f0:	aa0103f6 	mov	x22, x1
  40e1f4:	2a0703f5 	mov	w21, w7
  40e1f8:	a90363f7 	stp	x23, x24, [sp, #48]
  40e1fc:	aa0303f7 	mov	x23, x3
  40e200:	aa0403f8 	mov	x24, x4
  40e204:	a9046bf9 	stp	x25, x26, [sp, #64]
  40e208:	aa0503fa 	mov	x26, x5
  40e20c:	f9002bfb 	str	x27, [sp, #80]
  40e210:	aa0603fb 	mov	x27, x6
  40e214:	f94037f9 	ldr	x25, [sp, #104]
	Z_ASSERT_VALID_PRIO(prio, entry);
  40e218:	71003cff 	cmp	w7, #0xf
  40e21c:	540005a1 	b.ne	40e2d0 <z_setup_new_thread+0xf8>  // b.any
  40e220:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40e224:	f9475000 	ldr	x0, [x0, #3744]
  40e228:	eb00007f 	cmp	x3, x0
  40e22c:	54000581 	b.ne	40e2dc <z_setup_new_thread+0x104>  // b.any
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e230:	b94063e3 	ldr	w3, [sp, #96]
  40e234:	91018260 	add	x0, x19, #0x60
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  40e238:	91001e94 	add	x20, x20, #0x7
	list->tail = (sys_dnode_t *)list;
  40e23c:	a9060260 	stp	x0, x0, [x19, #96]
  40e240:	927df294 	and	x20, x20, #0xfffffffffffffff8
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e244:	2a1503e1 	mov	w1, w21
  40e248:	aa1303e0 	mov	x0, x19
  40e24c:	52800082 	mov	w2, #0x4                   	// #4
	stack_ptr = (char *)stack + stack_obj_size;
  40e250:	8b1402d4 	add	x20, x22, x20
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40e254:	97ffffda 	bl	40e1bc <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  40e258:	aa1b03e6 	mov	x6, x27
  40e25c:	aa1a03e5 	mov	x5, x26
  40e260:	aa1803e4 	mov	x4, x24
  40e264:	aa1703e3 	mov	x3, x23
  40e268:	aa1403e2 	mov	x2, x20
  40e26c:	aa1603e1 	mov	x1, x22
  40e270:	aa1303e0 	mov	x0, x19
  40e274:	97ffebfc 	bl	409264 <arch_new_thread>
	new_thread->init_data = NULL;
  40e278:	f9002e7f 	str	xzr, [x19, #88]
	new_thread->no_wake_on_timeout = false;
  40e27c:	3902227f 	strb	wzr, [x19, #136]
	if (name != NULL) {
  40e280:	b40005d9 	cbz	x25, 40e338 <z_setup_new_thread+0x160>
  40e284:	aa1903e1 	mov	x1, x25
  40e288:	91022660 	add	x0, x19, #0x89
  40e28c:	d28003e2 	mov	x2, #0x1f                  	// #31
  40e290:	97ffcc70 	bl	401450 <strncpy@plt>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  40e294:	3902a27f 	strb	wzr, [x19, #168]
	if (!_current) {
  40e298:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40e29c:	f9472c00 	ldr	x0, [x0, #3672]
  40e2a0:	f9400800 	ldr	x0, [x0, #16]
  40e2a4:	b4000040 	cbz	x0, 40e2ac <z_setup_new_thread+0xd4>
	new_thread->resource_pool = _current->resource_pool;
  40e2a8:	f9405800 	ldr	x0, [x0, #176]
	return stack_ptr;
  40e2ac:	f9005a60 	str	x0, [x19, #176]
}
  40e2b0:	aa1403e0 	mov	x0, x20
  40e2b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e2b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e2bc:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e2c0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40e2c4:	f9402bfb 	ldr	x27, [sp, #80]
  40e2c8:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40e2cc:	d65f03c0 	ret
	Z_ASSERT_VALID_PRIO(prio, entry);
  40e2d0:	110040e0 	add	w0, w7, #0x10
  40e2d4:	7100781f 	cmp	w0, #0x1e
  40e2d8:	54fffac9 	b.ls	40e230 <z_setup_new_thread+0x58>  // b.plast
  40e2dc:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40e2e0:	9101a273 	add	x19, x19, #0x68
  40e2e4:	aa1303e2 	mov	x2, x19
  40e2e8:	52804343 	mov	w3, #0x21a                 	// #538
  40e2ec:	90000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40e2f0:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e2f4:	91022c21 	add	x1, x1, #0x8b
  40e2f8:	911a8800 	add	x0, x0, #0x6a2
  40e2fc:	97ffe5df 	bl	407a78 <assert_print>
  40e300:	528001c2 	mov	w2, #0xe                   	// #14
  40e304:	128001e3 	mov	w3, #0xfffffff0            	// #-16
  40e308:	2a1503e1 	mov	w1, w21
  40e30c:	90000040 	adrp	x0, 416000 <__func__.0+0xc27>
  40e310:	91042c00 	add	x0, x0, #0x10b
  40e314:	97ffe5d9 	bl	407a78 <assert_print>
  40e318:	aa1303e0 	mov	x0, x19
  40e31c:	52804341 	mov	w1, #0x21a                 	// #538
  40e320:	97ffe600 	bl	407b20 <assert_post_action>
  40e324:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e328:	aa1303e1 	mov	x1, x19
  40e32c:	911b8000 	add	x0, x0, #0x6e0
  40e330:	52804342 	mov	w2, #0x21a                 	// #538
  40e334:	97ffefed 	bl	40a2e8 <posix_print_error_and_exit>
		new_thread->name[0] = '\0';
  40e338:	3902267f 	strb	wzr, [x19, #137]
  40e33c:	17ffffd7 	b	40e298 <z_setup_new_thread+0xc0>

000000000040e340 <z_impl_k_thread_create>:
{
  40e340:	d100c3ff 	sub	sp, sp, #0x30
  40e344:	b00000e8 	adrp	x8, 42b000 <__FRAME_END__+0x1007c>
  40e348:	a9017bfd 	stp	x29, x30, [sp, #16]
  40e34c:	910043fd 	add	x29, sp, #0x10
  40e350:	f9472d08 	ldr	x8, [x8, #3672]
  40e354:	a90253f3 	stp	x19, x20, [sp, #32]
  40e358:	f9401ff4 	ldr	x20, [sp, #56]
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
  40e35c:	b9400108 	ldr	w8, [x8]
  40e360:	340002a8 	cbz	w8, 40e3b4 <z_impl_k_thread_create+0x74>
  40e364:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40e368:	9101a273 	add	x19, x19, #0x68
  40e36c:	aa1303e2 	mov	x2, x19
  40e370:	90000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40e374:	9104f021 	add	x1, x1, #0x13c
  40e378:	52805183 	mov	w3, #0x28c                 	// #652
  40e37c:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e380:	911a8800 	add	x0, x0, #0x6a2
  40e384:	97ffe5bd 	bl	407a78 <assert_print>
  40e388:	90000040 	adrp	x0, 416000 <__func__.0+0xc27>
  40e38c:	91053800 	add	x0, x0, #0x14e
  40e390:	97ffe5ba 	bl	407a78 <assert_print>
  40e394:	aa1303e0 	mov	x0, x19
  40e398:	52805181 	mov	w1, #0x28c                 	// #652
  40e39c:	97ffe5e1 	bl	407b20 <assert_post_action>
  40e3a0:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e3a4:	aa1303e1 	mov	x1, x19
  40e3a8:	911b8000 	add	x0, x0, #0x6e0
  40e3ac:	52805182 	mov	w2, #0x28c                 	// #652
  40e3b0:	97ffefce 	bl	40a2e8 <posix_print_error_and_exit>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  40e3b4:	b94033e8 	ldr	w8, [sp, #48]
  40e3b8:	aa0003f3 	mov	x19, x0
  40e3bc:	b90003e8 	str	w8, [sp]
  40e3c0:	f90007ff 	str	xzr, [sp, #8]
  40e3c4:	97ffff85 	bl	40e1d8 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  40e3c8:	b100069f 	cmn	x20, #0x1
  40e3cc:	54000080 	b.eq	40e3dc <z_impl_k_thread_create+0x9c>  // b.none
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  40e3d0:	b5000114 	cbnz	x20, 40e3f0 <z_impl_k_thread_create+0xb0>
	z_impl_k_thread_start(thread);
  40e3d4:	aa1303e0 	mov	x0, x19
  40e3d8:	97ffff78 	bl	40e1b8 <z_impl_k_thread_start>
}
  40e3dc:	aa1303e0 	mov	x0, x19
  40e3e0:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40e3e4:	a94253f3 	ldp	x19, x20, [sp, #32]
  40e3e8:	9100c3ff 	add	sp, sp, #0x30
  40e3ec:	d65f03c0 	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  40e3f0:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40e3f4:	aa1403e2 	mov	x2, x20
  40e3f8:	9100a260 	add	x0, x19, #0x28
  40e3fc:	f9472421 	ldr	x1, [x1, #3656]
  40e400:	94001130 	bl	4128c0 <z_add_timeout>
  40e404:	17fffff6 	b	40e3dc <z_impl_k_thread_create+0x9c>

000000000040e408 <z_init_static_threads>:
{
  40e408:	d10103ff 	sub	sp, sp, #0x40
	_FOREACH_STATIC_THREAD(thread_data) {
  40e40c:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
{
  40e410:	a9017bfd 	stp	x29, x30, [sp, #16]
  40e414:	910043fd 	add	x29, sp, #0x10
  40e418:	a90253f3 	stp	x19, x20, [sp, #32]
  40e41c:	aa0003f4 	mov	x20, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  40e420:	f9479c13 	ldr	x19, [x0, #3896]
  40e424:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
{
  40e428:	a9035bf5 	stp	x21, x22, [sp, #48]
  40e42c:	aa0003f5 	mov	x21, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  40e430:	f9471416 	ldr	x22, [x0, #3624]
  40e434:	eb16027f 	cmp	x19, x22
  40e438:	54000469 	b.ls	40e4c4 <z_init_static_threads+0xbc>  // b.plast
  40e43c:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40e440:	9101a273 	add	x19, x19, #0x68
  40e444:	aa1303e2 	mov	x2, x19
  40e448:	90000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40e44c:	9105cc21 	add	x1, x1, #0x173
  40e450:	52805e63 	mov	w3, #0x2f3                 	// #755
  40e454:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e458:	911a8800 	add	x0, x0, #0x6a2
  40e45c:	97ffe587 	bl	407a78 <assert_print>
  40e460:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e464:	91278c00 	add	x0, x0, #0x9e3
  40e468:	97ffe584 	bl	407a78 <assert_print>
  40e46c:	aa1303e0 	mov	x0, x19
  40e470:	52805e61 	mov	w1, #0x2f3                 	// #755
  40e474:	97ffe5ab 	bl	407b20 <assert_post_action>
  40e478:	52805e62 	mov	w2, #0x2f3                 	// #755
	_FOREACH_STATIC_THREAD(thread_data) {
  40e47c:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e480:	aa1303e1 	mov	x1, x19
  40e484:	911b8000 	add	x0, x0, #0x6e0
  40e488:	97ffef98 	bl	40a2e8 <posix_print_error_and_exit>
		z_setup_new_thread(
  40e48c:	f9402660 	ldr	x0, [x19, #72]
  40e490:	b9401262 	ldr	w2, [x19, #16]
  40e494:	f90007e0 	str	x0, [sp, #8]
  40e498:	b9403e60 	ldr	w0, [x19, #60]
  40e49c:	b90003e0 	str	w0, [sp]
  40e4a0:	a9400660 	ldp	x0, x1, [x19]
  40e4a4:	a9419263 	ldp	x3, x4, [x19, #24]
  40e4a8:	a9429a65 	ldp	x5, x6, [x19, #40]
  40e4ac:	b9403a67 	ldr	w7, [x19, #56]
  40e4b0:	97ffff4a 	bl	40e1d8 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  40e4b4:	f9400260 	ldr	x0, [x19]
  40e4b8:	f9002c13 	str	x19, [x0, #88]
	_FOREACH_STATIC_THREAD(thread_data) {
  40e4bc:	91014273 	add	x19, x19, #0x50
  40e4c0:	17ffffdd 	b	40e434 <z_init_static_threads+0x2c>
  40e4c4:	54fffe43 	b.cc	40e48c <z_init_static_threads+0x84>  // b.lo, b.ul, b.last
	k_sched_lock();
  40e4c8:	94000826 	bl	410560 <k_sched_lock>
  40e4cc:	d2800156 	mov	x22, #0xa                   	// #10
	_FOREACH_STATIC_THREAD(thread_data) {
  40e4d0:	f9479e93 	ldr	x19, [x20, #3896]
  40e4d4:	f94716b4 	ldr	x20, [x21, #3624]
  40e4d8:	b00000f5 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
  40e4dc:	f94726b5 	ldr	x21, [x21, #3656]
  40e4e0:	eb14027f 	cmp	x19, x20
  40e4e4:	54000469 	b.ls	40e570 <z_init_static_threads+0x168>  // b.plast
  40e4e8:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40e4ec:	9101a273 	add	x19, x19, #0x68
  40e4f0:	aa1303e2 	mov	x2, x19
  40e4f4:	90000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40e4f8:	9105cc21 	add	x1, x1, #0x173
  40e4fc:	52806243 	mov	w3, #0x312                 	// #786
  40e500:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e504:	911a8800 	add	x0, x0, #0x6a2
  40e508:	97ffe55c 	bl	407a78 <assert_print>
  40e50c:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e510:	91278c00 	add	x0, x0, #0x9e3
  40e514:	97ffe559 	bl	407a78 <assert_print>
  40e518:	aa1303e0 	mov	x0, x19
  40e51c:	52806241 	mov	w1, #0x312                 	// #786
  40e520:	97ffe580 	bl	407b20 <assert_post_action>
  40e524:	52806242 	mov	w2, #0x312                 	// #786
  40e528:	17ffffd5 	b	40e47c <z_init_static_threads+0x74>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
  40e52c:	b9404262 	ldr	w2, [x19, #64]
  40e530:	3100045f 	cmn	w2, #0x1
  40e534:	54000100 	b.eq	40e554 <z_init_static_threads+0x14c>  // b.none
					    K_MSEC(thread_data->init_delay));
  40e538:	7100005f 	cmp	w2, #0x0
  40e53c:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
  40e540:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
  40e544:	93407c43 	sxtw	x3, w2
		t += off;
  40e548:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  40e54c:	b5000083 	cbnz	x3, 40e55c <z_init_static_threads+0x154>
  40e550:	97ffff1a 	bl	40e1b8 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
  40e554:	91014273 	add	x19, x19, #0x50
  40e558:	17ffffe2 	b	40e4e0 <z_init_static_threads+0xd8>
  40e55c:	9ad60842 	udiv	x2, x2, x22
  40e560:	aa1503e1 	mov	x1, x21
  40e564:	9100a000 	add	x0, x0, #0x28
  40e568:	940010d6 	bl	4128c0 <z_add_timeout>
  40e56c:	17fffffa 	b	40e554 <z_init_static_threads+0x14c>
  40e570:	54fffde3 	b.cc	40e52c <z_init_static_threads+0x124>  // b.lo, b.ul, b.last
}
  40e574:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40e578:	a94253f3 	ldp	x19, x20, [sp, #32]
  40e57c:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40e580:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
  40e584:	14000c9f 	b	411800 <k_sched_unlock>

000000000040e588 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
  40e588:	f9400000 	ldr	x0, [x0]

	if (thread_cpu != 0U) {
  40e58c:	b4000100 	cbz	x0, 40e5ac <z_spin_lock_valid+0x24>
		if ((thread_cpu & 3U) == _current_cpu->id) {
  40e590:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40e594:	92400400 	and	x0, x0, #0x3
  40e598:	f9472c21 	ldr	x1, [x1, #3672]
  40e59c:	39408021 	ldrb	w1, [x1, #32]
  40e5a0:	eb01001f 	cmp	x0, x1
  40e5a4:	1a9f07e0 	cset	w0, ne  // ne = any
			return false;
		}
	}
	return true;
}
  40e5a8:	d65f03c0 	ret
	return true;
  40e5ac:	52800020 	mov	w0, #0x1                   	// #1
  40e5b0:	17fffffe 	b	40e5a8 <z_spin_lock_valid+0x20>

000000000040e5b4 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
  40e5b4:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40e5b8:	f9472c21 	ldr	x1, [x1, #3672]
  40e5bc:	39408022 	ldrb	w2, [x1, #32]
  40e5c0:	f9400821 	ldr	x1, [x1, #16]
  40e5c4:	aa020021 	orr	x1, x1, x2
  40e5c8:	f9400002 	ldr	x2, [x0]
  40e5cc:	eb01005f 	cmp	x2, x1
  40e5d0:	54000081 	b.ne	40e5e0 <z_spin_unlock_valid+0x2c>  // b.any
		return false;
	}
	l->thread_cpu = 0;
  40e5d4:	f900001f 	str	xzr, [x0]
	return true;
  40e5d8:	52800020 	mov	w0, #0x1                   	// #1
}
  40e5dc:	d65f03c0 	ret
		return false;
  40e5e0:	52800000 	mov	w0, #0x0                   	// #0
  40e5e4:	17fffffe 	b	40e5dc <z_spin_unlock_valid+0x28>

000000000040e5e8 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
  40e5e8:	b00000e1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  40e5ec:	f9472c21 	ldr	x1, [x1, #3672]
  40e5f0:	39408022 	ldrb	w2, [x1, #32]
  40e5f4:	f9400821 	ldr	x1, [x1, #16]
  40e5f8:	aa020021 	orr	x1, x1, x2
  40e5fc:	f9000001 	str	x1, [x0]
}
  40e600:	d65f03c0 	ret

000000000040e604 <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
  40e604:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e608:	b00000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
{
  40e60c:	910003fd 	mov	x29, sp
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e610:	f9472c00 	ldr	x0, [x0, #3672]
{
  40e614:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40e618:	f9400800 	ldr	x0, [x0, #16]
  40e61c:	39c06800 	ldrsb	w0, [x0, #26]
  40e620:	36f80240 	tbz	w0, #31, 40e668 <idle+0x64>
  40e624:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40e628:	91068273 	add	x19, x19, #0x1a0
  40e62c:	aa1303e2 	mov	x2, x19
  40e630:	52800523 	mov	w3, #0x29                  	// #41
  40e634:	90000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40e638:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e63c:	91070421 	add	x1, x1, #0x1c1
  40e640:	911a8800 	add	x0, x0, #0x6a2
  40e644:	97ffe50d 	bl	407a78 <assert_print>
  40e648:	aa1303e0 	mov	x0, x19
  40e64c:	52800521 	mov	w1, #0x29                  	// #41
  40e650:	97ffe534 	bl	407b20 <assert_post_action>
  40e654:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e658:	aa1303e1 	mov	x1, x19
  40e65c:	911b8000 	add	x0, x0, #0x6e0
  40e660:	52800522 	mov	w2, #0x29                  	// #41
  40e664:	97ffef21 	bl	40a2e8 <posix_print_error_and_exit>
	return posix_irq_lock();
  40e668:	97ffee0a 	bl	409e90 <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
  40e66c:	97ffe976 	bl	408c44 <arch_cpu_idle>
  40e670:	17fffffe 	b	40e668 <idle+0x64>

000000000040e674 <k_msgq_init>:

void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
		 uint32_t max_msgs)
{
	msgq->msg_size = msg_size;
	msgq->max_msgs = max_msgs;
  40e674:	b9002003 	str	w3, [x0, #32]
	msgq->buffer_start = buffer;
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e678:	2a0303e3 	mov	w3, w3
	msgq->msg_size = msg_size;
  40e67c:	a901081f 	stp	xzr, x2, [x0, #16]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e680:	9b020462 	madd	x2, x3, x2, x1
  40e684:	a9000000 	stp	x0, x0, [x0]
	msgq->buffer_start = buffer;
  40e688:	f9001401 	str	x1, [x0, #40]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40e68c:	f9001802 	str	x2, [x0, #48]
	msgq->read_ptr = buffer;
	msgq->write_ptr = buffer;
  40e690:	a9038401 	stp	x1, x1, [x0, #56]
	msgq->used_msgs = 0;
	msgq->flags = 0;
	z_waitq_init(&msgq->wait_q);
	msgq->lock = (struct k_spinlock) {};
#ifdef CONFIG_POLL
	sys_dlist_init(&msgq->poll_events);
  40e694:	91014001 	add	x1, x0, #0x50
	msgq->used_msgs = 0;
  40e698:	b900481f 	str	wzr, [x0, #72]
  40e69c:	a9050401 	stp	x1, x1, [x0, #80]
	msgq->flags = 0;
  40e6a0:	3901801f 	strb	wzr, [x0, #96]
#endif	/* CONFIG_POLL */

	SYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);

	z_object_init(msgq);
}
  40e6a4:	d65f03c0 	ret

000000000040e6a8 <k_msgq_cleanup>:
}
#include <syscalls/k_msgq_alloc_init_mrsh.c>
#endif

int k_msgq_cleanup(struct k_msgq *msgq)
{
  40e6a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e6ac:	910003fd 	mov	x29, sp
  40e6b0:	f9000bf3 	str	x19, [sp, #16]
  40e6b4:	aa0003f3 	mov	x19, x0
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  40e6b8:	f9400000 	ldr	x0, [x0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40e6bc:	eb00027f 	cmp	x19, x0
  40e6c0:	54000040 	b.eq	40e6c8 <k_msgq_cleanup+0x20>  // b.none
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, cleanup, msgq);

	CHECKIF(z_waitq_head(&msgq->wait_q) != NULL) {
  40e6c4:	b5000140 	cbnz	x0, 40e6ec <k_msgq_cleanup+0x44>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, -EBUSY);

		return -EBUSY;
	}

	if ((msgq->flags & K_MSGQ_FLAG_ALLOC) != 0U) {
  40e6c8:	39418260 	ldrb	w0, [x19, #96]
  40e6cc:	360000c0 	tbz	w0, #0, 40e6e4 <k_msgq_cleanup+0x3c>
		k_free(msgq->buffer_start);
  40e6d0:	f9401660 	ldr	x0, [x19, #40]
  40e6d4:	94001334 	bl	4133a4 <k_free>
		msgq->flags &= ~K_MSGQ_FLAG_ALLOC;
  40e6d8:	39418260 	ldrb	w0, [x19, #96]
  40e6dc:	121f7800 	and	w0, w0, #0xfffffffe
  40e6e0:	39018260 	strb	w0, [x19, #96]
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, cleanup, msgq, 0);

	return 0;
  40e6e4:	52800000 	mov	w0, #0x0                   	// #0
  40e6e8:	14000002 	b	40e6f0 <k_msgq_cleanup+0x48>
		return -EBUSY;
  40e6ec:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
  40e6f0:	f9400bf3 	ldr	x19, [sp, #16]
  40e6f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e6f8:	d65f03c0 	ret

000000000040e6fc <z_impl_k_msgq_put>:


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
  40e6fc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40e700:	910003fd 	mov	x29, sp
  40e704:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e708:	aa0203f5 	mov	x21, x2
  40e70c:	b00000e2 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
  40e710:	a90153f3 	stp	x19, x20, [sp, #16]
  40e714:	aa0003f3 	mov	x19, x0
  40e718:	f9472c40 	ldr	x0, [x2, #3672]
  40e71c:	a90363f7 	stp	x23, x24, [sp, #48]
  40e720:	aa0103f7 	mov	x23, x1
  40e724:	aa0203f8 	mov	x24, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40e728:	b9400000 	ldr	w0, [x0]
  40e72c:	340002c0 	cbz	w0, 40e784 <z_impl_k_msgq_put+0x88>
  40e730:	b40002b5 	cbz	x21, 40e784 <z_impl_k_msgq_put+0x88>
  40e734:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40e738:	9107a673 	add	x19, x19, #0x1e9
  40e73c:	aa1303e2 	mov	x2, x19
  40e740:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40e744:	913f8021 	add	x1, x1, #0xfe0
  40e748:	52800ec3 	mov	w3, #0x76                  	// #118
  40e74c:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e750:	911a8800 	add	x0, x0, #0x6a2
  40e754:	97ffe4c9 	bl	407a78 <assert_print>
  40e758:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40e75c:	91320400 	add	x0, x0, #0xc81
  40e760:	97ffe4c6 	bl	407a78 <assert_print>
  40e764:	aa1303e0 	mov	x0, x19
  40e768:	52800ec1 	mov	w1, #0x76                  	// #118
  40e76c:	97ffe4ed 	bl	407b20 <assert_post_action>
  40e770:	52800ec2 	mov	w2, #0x76                  	// #118
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40e774:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e778:	aa1303e1 	mov	x1, x19
  40e77c:	911b8000 	add	x0, x0, #0x6e0
  40e780:	97ffeeda 	bl	40a2e8 <posix_print_error_and_exit>
  40e784:	97ffedc3 	bl	409e90 <posix_irq_lock>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
  40e788:	91004274 	add	x20, x19, #0x10
  40e78c:	2a0003f6 	mov	w22, w0
  40e790:	aa1403e0 	mov	x0, x20
  40e794:	97ffff7d 	bl	40e588 <z_spin_lock_valid>
  40e798:	72001c1f 	tst	w0, #0xff
  40e79c:	54000261 	b.ne	40e7e8 <z_impl_k_msgq_put+0xec>  // b.any
  40e7a0:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40e7a4:	912faa73 	add	x19, x19, #0xbea
  40e7a8:	aa1303e2 	mov	x2, x19
  40e7ac:	52801283 	mov	w3, #0x94                  	// #148
  40e7b0:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40e7b4:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e7b8:	91305c21 	add	x1, x1, #0xc17
  40e7bc:	911a8800 	add	x0, x0, #0x6a2
  40e7c0:	97ffe4ae 	bl	407a78 <assert_print>
  40e7c4:	aa1403e1 	mov	x1, x20
  40e7c8:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40e7cc:	9130b000 	add	x0, x0, #0xc2c
  40e7d0:	97ffe4aa 	bl	407a78 <assert_print>
  40e7d4:	aa1303e0 	mov	x0, x19
  40e7d8:	52801281 	mov	w1, #0x94                  	// #148
  40e7dc:	97ffe4d1 	bl	407b20 <assert_post_action>
  40e7e0:	52801282 	mov	w2, #0x94                  	// #148
  40e7e4:	17ffffe4 	b	40e774 <z_impl_k_msgq_put+0x78>
	z_spin_lock_set_owner(l);
  40e7e8:	aa1403e0 	mov	x0, x20
  40e7ec:	97ffff7f 	bl	40e5e8 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
  40e7f0:	b9402260 	ldr	w0, [x19, #32]
  40e7f4:	b9404a61 	ldr	w1, [x19, #72]
  40e7f8:	6b00003f 	cmp	w1, w0
  40e7fc:	54000a82 	b.cs	40e94c <z_impl_k_msgq_put+0x250>  // b.hs, b.nlast
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  40e800:	aa1303e0 	mov	x0, x19
  40e804:	94000cb2 	bl	411acc <z_unpend_first_thread>
  40e808:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  40e80c:	b4000240 	cbz	x0, 40e854 <z_impl_k_msgq_put+0x158>
  return __builtin___memcpy_chk (__dest, __src, __len,
  40e810:	f9400e62 	ldr	x2, [x19, #24]
  40e814:	aa1703e1 	mov	x1, x23
  40e818:	f9401000 	ldr	x0, [x0, #32]
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
  40e81c:	52800013 	mov	w19, #0x0                   	// #0
  40e820:	97ffca54 	bl	401170 <memcpy@plt>
	thread->callee_saved.retval = value;
  40e824:	b9004ebf 	str	wzr, [x21, #76]
			z_ready_thread(pending_thread);
  40e828:	aa1503e0 	mov	x0, x21
  40e82c:	94000957 	bl	410d88 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  40e830:	2a1603e1 	mov	w1, w22
  40e834:	aa1403e0 	mov	x0, x20
  40e838:	940006f9 	bl	41041c <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  40e83c:	2a1303e0 	mov	w0, w19
  40e840:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e844:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e848:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e84c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40e850:	d65f03c0 	ret
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  40e854:	f9401661 	ldr	x1, [x19, #40]
  40e858:	f9402260 	ldr	x0, [x19, #64]
  40e85c:	eb01001f 	cmp	x0, x1
  40e860:	54000083 	b.cc	40e870 <z_impl_k_msgq_put+0x174>  // b.lo, b.ul, b.last
  40e864:	f9401a61 	ldr	x1, [x19, #48]
  40e868:	eb01001f 	cmp	x0, x1
  40e86c:	540001e3 	b.cc	40e8a8 <z_impl_k_msgq_put+0x1ac>  // b.lo, b.ul, b.last
  40e870:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40e874:	9107a673 	add	x19, x19, #0x1e9
  40e878:	aa1303e2 	mov	x2, x19
  40e87c:	52801203 	mov	w3, #0x90                  	// #144
  40e880:	90000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40e884:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e888:	91082c21 	add	x1, x1, #0x20b
  40e88c:	911a8800 	add	x0, x0, #0x6a2
  40e890:	97ffe47a 	bl	407a78 <assert_print>
  40e894:	aa1303e0 	mov	x0, x19
  40e898:	52801201 	mov	w1, #0x90                  	// #144
  40e89c:	97ffe4a1 	bl	407b20 <assert_post_action>
  40e8a0:	52801202 	mov	w2, #0x90                  	// #144
  40e8a4:	17ffffb4 	b	40e774 <z_impl_k_msgq_put+0x78>
  40e8a8:	f9400e62 	ldr	x2, [x19, #24]
  40e8ac:	aa1703e1 	mov	x1, x23
  40e8b0:	97ffca30 	bl	401170 <memcpy@plt>
			msgq->write_ptr += msgq->msg_size;
  40e8b4:	f9400e60 	ldr	x0, [x19, #24]
  40e8b8:	f9402262 	ldr	x2, [x19, #64]
  40e8bc:	8b000042 	add	x2, x2, x0
  40e8c0:	f9002262 	str	x2, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  40e8c4:	f9401a60 	ldr	x0, [x19, #48]
  40e8c8:	eb00005f 	cmp	x2, x0
  40e8cc:	54000061 	b.ne	40e8d8 <z_impl_k_msgq_put+0x1dc>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  40e8d0:	f9401660 	ldr	x0, [x19, #40]
  40e8d4:	f9002260 	str	x0, [x19, #64]
			msgq->used_msgs++;
  40e8d8:	b9404a60 	ldr	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40e8dc:	52800201 	mov	w1, #0x10                  	// #16
			msgq->used_msgs++;
  40e8e0:	11000400 	add	w0, w0, #0x1
  40e8e4:	b9004a60 	str	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40e8e8:	91014260 	add	x0, x19, #0x50
		result = 0;
  40e8ec:	52800013 	mov	w19, #0x0                   	// #0
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40e8f0:	940012a3 	bl	41337c <z_handle_obj_poll_events>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40e8f4:	aa1403e0 	mov	x0, x20
  40e8f8:	97ffff2f 	bl	40e5b4 <z_spin_unlock_valid>
  40e8fc:	72001c1f 	tst	w0, #0xff
  40e900:	54000441 	b.ne	40e988 <z_impl_k_msgq_put+0x28c>  // b.any
  40e904:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40e908:	912faa73 	add	x19, x19, #0xbea
  40e90c:	aa1303e2 	mov	x2, x19
  40e910:	52801863 	mov	w3, #0xc3                  	// #195
  40e914:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40e918:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e91c:	91311021 	add	x1, x1, #0xc44
  40e920:	911a8800 	add	x0, x0, #0x6a2
  40e924:	97ffe455 	bl	407a78 <assert_print>
  40e928:	aa1403e1 	mov	x1, x20
  40e92c:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40e930:	91316c00 	add	x0, x0, #0xc5b
  40e934:	97ffe451 	bl	407a78 <assert_print>
  40e938:	aa1303e0 	mov	x0, x19
  40e93c:	52801861 	mov	w1, #0xc3                  	// #195
  40e940:	97ffe478 	bl	407b20 <assert_post_action>
  40e944:	52801862 	mov	w2, #0xc3                  	// #195
  40e948:	17ffff8b 	b	40e774 <z_impl_k_msgq_put+0x78>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40e94c:	b40001b5 	cbz	x21, 40e980 <z_impl_k_msgq_put+0x284>
		_current->base.swap_data = (void *) data;
  40e950:	f9472f02 	ldr	x2, [x24, #3672]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40e954:	aa1503e3 	mov	x3, x21
  40e958:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = (void *) data;
  40e95c:	f9400840 	ldr	x0, [x2, #16]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40e960:	aa1303e2 	mov	x2, x19
		_current->base.swap_data = (void *) data;
  40e964:	f9001017 	str	x23, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40e968:	aa1403e0 	mov	x0, x20
}
  40e96c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e970:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e974:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e978:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40e97c:	14000a4c 	b	4112ac <z_pend_curr>
		result = -ENOMSG;
  40e980:	12800533 	mov	w19, #0xffffffd6            	// #-42
  40e984:	17ffffdc 	b	40e8f4 <z_impl_k_msgq_put+0x1f8>
	posix_irq_unlock(key);
  40e988:	2a1603e0 	mov	w0, w22
  40e98c:	97ffed43 	bl	409e98 <posix_irq_unlock>
	return result;
  40e990:	17ffffab 	b	40e83c <z_impl_k_msgq_put+0x140>

000000000040e994 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
  40e994:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	return _kernel.cpus[0].nested != 0U;
  40e998:	b00000e4 	adrp	x4, 42b000 <__FRAME_END__+0x1007c>
  40e99c:	910003fd 	mov	x29, sp
  40e9a0:	a90153f3 	stp	x19, x20, [sp, #16]
  40e9a4:	aa0003f3 	mov	x19, x0
  40e9a8:	f9472c80 	ldr	x0, [x4, #3672]
  40e9ac:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e9b0:	aa0403f5 	mov	x21, x4
  40e9b4:	a90363f7 	stp	x23, x24, [sp, #48]
  40e9b8:	aa0103f8 	mov	x24, x1
  40e9bc:	aa0203f7 	mov	x23, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40e9c0:	b9400000 	ldr	w0, [x0]
  40e9c4:	340002c0 	cbz	w0, 40ea1c <z_impl_k_msgq_get+0x88>
  40e9c8:	b40002a2 	cbz	x2, 40ea1c <z_impl_k_msgq_get+0x88>
  40e9cc:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40e9d0:	9107a673 	add	x19, x19, #0x1e9
  40e9d4:	aa1303e2 	mov	x2, x19
  40e9d8:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40e9dc:	913f8021 	add	x1, x1, #0xfe0
  40e9e0:	52801a43 	mov	w3, #0xd2                  	// #210
  40e9e4:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40e9e8:	911a8800 	add	x0, x0, #0x6a2
  40e9ec:	97ffe423 	bl	407a78 <assert_print>
  40e9f0:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40e9f4:	91320400 	add	x0, x0, #0xc81
  40e9f8:	97ffe420 	bl	407a78 <assert_print>
  40e9fc:	aa1303e0 	mov	x0, x19
  40ea00:	52801a41 	mov	w1, #0xd2                  	// #210
  40ea04:	97ffe447 	bl	407b20 <assert_post_action>
  40ea08:	52801a42 	mov	w2, #0xd2                  	// #210
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ea0c:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ea10:	aa1303e1 	mov	x1, x19
  40ea14:	911b8000 	add	x0, x0, #0x6e0
  40ea18:	97ffee34 	bl	40a2e8 <posix_print_error_and_exit>
	return posix_irq_lock();
  40ea1c:	97ffed1d 	bl	409e90 <posix_irq_lock>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
  40ea20:	91004274 	add	x20, x19, #0x10
  40ea24:	2a0003f6 	mov	w22, w0
  40ea28:	aa1403e0 	mov	x0, x20
  40ea2c:	97fffed7 	bl	40e588 <z_spin_lock_valid>
  40ea30:	72001c1f 	tst	w0, #0xff
  40ea34:	54000261 	b.ne	40ea80 <z_impl_k_msgq_get+0xec>  // b.any
  40ea38:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40ea3c:	912faa73 	add	x19, x19, #0xbea
  40ea40:	aa1303e2 	mov	x2, x19
  40ea44:	52801283 	mov	w3, #0x94                  	// #148
  40ea48:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40ea4c:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ea50:	91305c21 	add	x1, x1, #0xc17
  40ea54:	911a8800 	add	x0, x0, #0x6a2
  40ea58:	97ffe408 	bl	407a78 <assert_print>
  40ea5c:	aa1403e1 	mov	x1, x20
  40ea60:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40ea64:	9130b000 	add	x0, x0, #0xc2c
  40ea68:	97ffe404 	bl	407a78 <assert_print>
  40ea6c:	aa1303e0 	mov	x0, x19
  40ea70:	52801281 	mov	w1, #0x94                  	// #148
  40ea74:	97ffe42b 	bl	407b20 <assert_post_action>
  40ea78:	52801282 	mov	w2, #0x94                  	// #148
  40ea7c:	17ffffe4 	b	40ea0c <z_impl_k_msgq_get+0x78>
	z_spin_lock_set_owner(l);
  40ea80:	aa1403e0 	mov	x0, x20
  40ea84:	97fffed9 	bl	40e5e8 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
  40ea88:	b9404a60 	ldr	w0, [x19, #72]
  40ea8c:	340008c0 	cbz	w0, 40eba4 <z_impl_k_msgq_get+0x210>
  40ea90:	f9400e62 	ldr	x2, [x19, #24]
  40ea94:	aa1803e0 	mov	x0, x24
  40ea98:	f9401e61 	ldr	x1, [x19, #56]
  40ea9c:	97ffc9b5 	bl	401170 <memcpy@plt>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
  40eaa0:	f9400e61 	ldr	x1, [x19, #24]
  40eaa4:	f9401e60 	ldr	x0, [x19, #56]
  40eaa8:	8b010000 	add	x0, x0, x1
  40eaac:	f9001e60 	str	x0, [x19, #56]
		if (msgq->read_ptr == msgq->buffer_end) {
  40eab0:	f9401a61 	ldr	x1, [x19, #48]
  40eab4:	eb01001f 	cmp	x0, x1
  40eab8:	54000061 	b.ne	40eac4 <z_impl_k_msgq_get+0x130>  // b.any
			msgq->read_ptr = msgq->buffer_start;
  40eabc:	f9401660 	ldr	x0, [x19, #40]
  40eac0:	f9001e60 	str	x0, [x19, #56]
		}
		msgq->used_msgs--;
  40eac4:	b9404a60 	ldr	w0, [x19, #72]
  40eac8:	51000400 	sub	w0, w0, #0x1
  40eacc:	b9004a60 	str	w0, [x19, #72]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  40ead0:	aa1303e0 	mov	x0, x19
  40ead4:	94000bfe 	bl	411acc <z_unpend_first_thread>
  40ead8:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  40eadc:	b40007e0 	cbz	x0, 40ebd8 <z_impl_k_msgq_get+0x244>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  40eae0:	f9401661 	ldr	x1, [x19, #40]
  40eae4:	f9402260 	ldr	x0, [x19, #64]
  40eae8:	eb01001f 	cmp	x0, x1
  40eaec:	54000083 	b.cc	40eafc <z_impl_k_msgq_get+0x168>  // b.lo, b.ul, b.last
  40eaf0:	f9401a61 	ldr	x1, [x19, #48]
  40eaf4:	eb01001f 	cmp	x0, x1
  40eaf8:	540001e3 	b.cc	40eb34 <z_impl_k_msgq_get+0x1a0>  // b.lo, b.ul, b.last
  40eafc:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40eb00:	9107a673 	add	x19, x19, #0x1e9
  40eb04:	aa1303e2 	mov	x2, x19
  40eb08:	52801d63 	mov	w3, #0xeb                  	// #235
  40eb0c:	90000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40eb10:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40eb14:	91082c21 	add	x1, x1, #0x20b
  40eb18:	911a8800 	add	x0, x0, #0x6a2
  40eb1c:	97ffe3d7 	bl	407a78 <assert_print>
  40eb20:	aa1303e0 	mov	x0, x19
  40eb24:	52801d61 	mov	w1, #0xeb                  	// #235
  40eb28:	97ffe3fe 	bl	407b20 <assert_post_action>
  40eb2c:	52801d62 	mov	w2, #0xeb                  	// #235
  40eb30:	17ffffb7 	b	40ea0c <z_impl_k_msgq_get+0x78>
  40eb34:	f9400e62 	ldr	x2, [x19, #24]
  40eb38:	f94012a1 	ldr	x1, [x21, #32]
  40eb3c:	97ffc98d 	bl	401170 <memcpy@plt>
					msgq->write_ptr < msgq->buffer_end);
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
  40eb40:	f9400e61 	ldr	x1, [x19, #24]
  40eb44:	f9402260 	ldr	x0, [x19, #64]
  40eb48:	8b010000 	add	x0, x0, x1
  40eb4c:	f9002260 	str	x0, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  40eb50:	f9401a61 	ldr	x1, [x19, #48]
  40eb54:	eb01001f 	cmp	x0, x1
  40eb58:	54000061 	b.ne	40eb64 <z_impl_k_msgq_get+0x1d0>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  40eb5c:	f9401660 	ldr	x0, [x19, #40]
  40eb60:	f9002260 	str	x0, [x19, #64]
			}
			msgq->used_msgs++;
  40eb64:	b9404a60 	ldr	w0, [x19, #72]
  40eb68:	11000400 	add	w0, w0, #0x1
  40eb6c:	b9004a60 	str	w0, [x19, #72]
	thread->callee_saved.retval = value;
  40eb70:	b9004ebf 	str	wzr, [x21, #76]

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
  40eb74:	aa1503e0 	mov	x0, x21
			z_reschedule(&msgq->lock, key);

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
  40eb78:	52800013 	mov	w19, #0x0                   	// #0
			z_ready_thread(pending_thread);
  40eb7c:	94000883 	bl	410d88 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  40eb80:	2a1603e1 	mov	w1, w22
  40eb84:	aa1403e0 	mov	x0, x20
  40eb88:	94000625 	bl	41041c <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  40eb8c:	2a1303e0 	mov	w0, w19
  40eb90:	a94153f3 	ldp	x19, x20, [sp, #16]
  40eb94:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40eb98:	a94363f7 	ldp	x23, x24, [sp, #48]
  40eb9c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40eba0:	d65f03c0 	ret
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40eba4:	b4000497 	cbz	x23, 40ec34 <z_impl_k_msgq_get+0x2a0>
		_current->base.swap_data = data;
  40eba8:	f9472ea4 	ldr	x4, [x21, #3672]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ebac:	aa1703e3 	mov	x3, x23
  40ebb0:	aa1303e2 	mov	x2, x19
  40ebb4:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = data;
  40ebb8:	f9400880 	ldr	x0, [x4, #16]
  40ebbc:	f9001018 	str	x24, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ebc0:	aa1403e0 	mov	x0, x20
}
  40ebc4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ebc8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ebcc:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ebd0:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40ebd4:	140009b6 	b	4112ac <z_pend_curr>
		result = 0;
  40ebd8:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40ebdc:	aa1403e0 	mov	x0, x20
  40ebe0:	97fffe75 	bl	40e5b4 <z_spin_unlock_valid>
  40ebe4:	72001c1f 	tst	w0, #0xff
  40ebe8:	540002a1 	b.ne	40ec3c <z_impl_k_msgq_get+0x2a8>  // b.any
  40ebec:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40ebf0:	912faa73 	add	x19, x19, #0xbea
  40ebf4:	aa1303e2 	mov	x2, x19
  40ebf8:	52801863 	mov	w3, #0xc3                  	// #195
  40ebfc:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40ec00:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ec04:	91311021 	add	x1, x1, #0xc44
  40ec08:	911a8800 	add	x0, x0, #0x6a2
  40ec0c:	97ffe39b 	bl	407a78 <assert_print>
  40ec10:	aa1403e1 	mov	x1, x20
  40ec14:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40ec18:	91316c00 	add	x0, x0, #0xc5b
  40ec1c:	97ffe397 	bl	407a78 <assert_print>
  40ec20:	aa1303e0 	mov	x0, x19
  40ec24:	52801861 	mov	w1, #0xc3                  	// #195
  40ec28:	97ffe3be 	bl	407b20 <assert_post_action>
  40ec2c:	52801862 	mov	w2, #0xc3                  	// #195
  40ec30:	17ffff77 	b	40ea0c <z_impl_k_msgq_get+0x78>
		result = -ENOMSG;
  40ec34:	12800533 	mov	w19, #0xffffffd6            	// #-42
  40ec38:	17ffffe9 	b	40ebdc <z_impl_k_msgq_get+0x248>
	posix_irq_unlock(key);
  40ec3c:	2a1603e0 	mov	w0, w22
  40ec40:	97ffec96 	bl	409e98 <posix_irq_unlock>
	return result;
  40ec44:	17ffffd2 	b	40eb8c <z_impl_k_msgq_get+0x1f8>

000000000040ec48 <z_impl_k_msgq_purge>:
}
#include <syscalls/k_msgq_peek_at_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
  40ec48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ec4c:	910003fd 	mov	x29, sp
  40ec50:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
  40ec54:	91004014 	add	x20, x0, #0x10
{
  40ec58:	aa0003f3 	mov	x19, x0
  40ec5c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40ec60:	97ffec8c 	bl	409e90 <posix_irq_lock>
  40ec64:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ec68:	aa1403e0 	mov	x0, x20
  40ec6c:	97fffe47 	bl	40e588 <z_spin_lock_valid>
  40ec70:	72001c1f 	tst	w0, #0xff
  40ec74:	540002c1 	b.ne	40eccc <z_impl_k_msgq_purge+0x84>  // b.any
  40ec78:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40ec7c:	912faa73 	add	x19, x19, #0xbea
  40ec80:	aa1303e2 	mov	x2, x19
  40ec84:	52801283 	mov	w3, #0x94                  	// #148
  40ec88:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40ec8c:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ec90:	91305c21 	add	x1, x1, #0xc17
  40ec94:	911a8800 	add	x0, x0, #0x6a2
  40ec98:	97ffe378 	bl	407a78 <assert_print>
  40ec9c:	aa1403e1 	mov	x1, x20
  40eca0:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40eca4:	9130b000 	add	x0, x0, #0xc2c
  40eca8:	97ffe374 	bl	407a78 <assert_print>
  40ecac:	aa1303e0 	mov	x0, x19
  40ecb0:	52801281 	mov	w1, #0x94                  	// #148
  40ecb4:	97ffe39b 	bl	407b20 <assert_post_action>
  40ecb8:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ecbc:	aa1303e1 	mov	x1, x19
  40ecc0:	911b8000 	add	x0, x0, #0x6e0
  40ecc4:	52801282 	mov	w2, #0x94                  	// #148
  40ecc8:	97ffed88 	bl	40a2e8 <posix_print_error_and_exit>
  40eccc:	12800536 	mov	w22, #0xffffffd6            	// #-42
	z_spin_lock_set_owner(l);
  40ecd0:	aa1403e0 	mov	x0, x20
  40ecd4:	97fffe45 	bl	40e5e8 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
  40ecd8:	aa1303e0 	mov	x0, x19
  40ecdc:	94000b7c 	bl	411acc <z_unpend_first_thread>
  40ece0:	aa0003e2 	mov	x2, x0
  40ece4:	b5000140 	cbnz	x0, 40ed0c <z_impl_k_msgq_purge+0xc4>
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
	}

	msgq->used_msgs = 0;
	msgq->read_ptr = msgq->write_ptr;
  40ece8:	f9402260 	ldr	x0, [x19, #64]
  40ecec:	f9001e60 	str	x0, [x19, #56]
	msgq->used_msgs = 0;
  40ecf0:	b9004a7f 	str	wzr, [x19, #72]

	z_reschedule(&msgq->lock, key);
  40ecf4:	2a1503e1 	mov	w1, w21
  40ecf8:	aa1403e0 	mov	x0, x20
}
  40ecfc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ed00:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ed04:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&msgq->lock, key);
  40ed08:	140005c5 	b	41041c <z_reschedule>
  40ed0c:	b9004c56 	str	w22, [x2, #76]
		z_ready_thread(pending_thread);
  40ed10:	9400081e 	bl	410d88 <z_ready_thread>
  40ed14:	17fffff1 	b	40ecd8 <z_impl_k_msgq_purge+0x90>

000000000040ed18 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
  40ed18:	39c06802 	ldrsb	w2, [x0, #26]
  40ed1c:	6b01005f 	cmp	w2, w1
  40ed20:	54000040 	b.eq	40ed28 <adjust_owner_prio.isra.0+0x10>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
  40ed24:	140009d2 	b	41146c <z_set_prio>
	}
	return false;
}
  40ed28:	52800000 	mov	w0, #0x0                   	// #0
  40ed2c:	d65f03c0 	ret

000000000040ed30 <z_impl_k_mutex_init>:
	list->tail = (sys_dnode_t *)list;
  40ed30:	a9000000 	stp	x0, x0, [x0]
	mutex->owner = NULL;
  40ed34:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
  40ed38:	b900181f 	str	wzr, [x0, #24]
}
  40ed3c:	52800000 	mov	w0, #0x0                   	// #0
  40ed40:	d65f03c0 	ret

000000000040ed44 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
  40ed44:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ed48:	910003fd 	mov	x29, sp
  40ed4c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return _kernel.cpus[0].nested != 0U;
  40ed50:	b00000f5 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
  40ed54:	f90023f9 	str	x25, [sp, #64]
  40ed58:	f9472eb9 	ldr	x25, [x21, #3672]
  40ed5c:	a90153f3 	stp	x19, x20, [sp, #16]
  40ed60:	aa0003f3 	mov	x19, x0
  40ed64:	a90363f7 	stp	x23, x24, [sp, #48]
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  40ed68:	b9400320 	ldr	w0, [x25]
  40ed6c:	340002a0 	cbz	w0, 40edc0 <z_impl_k_mutex_lock+0x7c>
  40ed70:	90000053 	adrp	x19, 416000 <__func__.0+0xc27>
  40ed74:	91095e73 	add	x19, x19, #0x257
  40ed78:	aa1303e2 	mov	x2, x19
  40ed7c:	90000041 	adrp	x1, 416000 <__func__.0+0xc27>
  40ed80:	9104f021 	add	x1, x1, #0x13c
  40ed84:	52800ca3 	mov	w3, #0x65                  	// #101
  40ed88:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ed8c:	911a8800 	add	x0, x0, #0x6a2
  40ed90:	97ffe33a 	bl	407a78 <assert_print>
  40ed94:	90000040 	adrp	x0, 416000 <__func__.0+0xc27>
  40ed98:	9109e400 	add	x0, x0, #0x279
  40ed9c:	97ffe337 	bl	407a78 <assert_print>
  40eda0:	aa1303e0 	mov	x0, x19
  40eda4:	52800ca1 	mov	w1, #0x65                  	// #101
  40eda8:	97ffe35e 	bl	407b20 <assert_post_action>
  40edac:	52800ca2 	mov	w2, #0x65                  	// #101
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40edb0:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40edb4:	aa1303e1 	mov	x1, x19
  40edb8:	911b8000 	add	x0, x0, #0x6e0
  40edbc:	97ffed4b 	bl	40a2e8 <posix_print_error_and_exit>
  40edc0:	aa0103f8 	mov	x24, x1
  40edc4:	f00000f4 	adrp	x20, 42d000 <counter_value>
  40edc8:	97ffec32 	bl	409e90 <posix_irq_lock>
  40edcc:	91328297 	add	x23, x20, #0xca0
  40edd0:	2a0003f6 	mov	w22, w0
  40edd4:	aa1703e0 	mov	x0, x23
  40edd8:	97fffdec 	bl	40e588 <z_spin_lock_valid>
  40eddc:	72001c1f 	tst	w0, #0xff
  40ede0:	54000261 	b.ne	40ee2c <z_impl_k_mutex_lock+0xe8>  // b.any
  40ede4:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40ede8:	912faa73 	add	x19, x19, #0xbea
  40edec:	aa1303e2 	mov	x2, x19
  40edf0:	52801283 	mov	w3, #0x94                  	// #148
  40edf4:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40edf8:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40edfc:	91305c21 	add	x1, x1, #0xc17
  40ee00:	911a8800 	add	x0, x0, #0x6a2
  40ee04:	97ffe31d 	bl	407a78 <assert_print>
  40ee08:	91328281 	add	x1, x20, #0xca0
  40ee0c:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40ee10:	9130b000 	add	x0, x0, #0xc2c
  40ee14:	97ffe319 	bl	407a78 <assert_print>
  40ee18:	aa1303e0 	mov	x0, x19
  40ee1c:	52801281 	mov	w1, #0x94                  	// #148
  40ee20:	97ffe340 	bl	407b20 <assert_post_action>
  40ee24:	52801282 	mov	w2, #0x94                  	// #148
  40ee28:	17ffffe2 	b	40edb0 <z_impl_k_mutex_lock+0x6c>
	z_spin_lock_set_owner(l);
  40ee2c:	aa1703e0 	mov	x0, x23
  40ee30:	97fffdee 	bl	40e5e8 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  40ee34:	b9401a61 	ldr	w1, [x19, #24]
  40ee38:	340001c1 	cbz	w1, 40ee70 <z_impl_k_mutex_lock+0x12c>
  40ee3c:	f9400a60 	ldr	x0, [x19, #16]
  40ee40:	f9400b22 	ldr	x2, [x25, #16]
  40ee44:	eb02001f 	cmp	x0, x2
  40ee48:	540004e0 	b.eq	40eee4 <z_impl_k_mutex_lock+0x1a0>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
  40ee4c:	b5000638 	cbnz	x24, 40ef10 <z_impl_k_mutex_lock+0x1cc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40ee50:	aa1703e0 	mov	x0, x23
  40ee54:	97fffdd8 	bl	40e5b4 <z_spin_unlock_valid>
  40ee58:	72001c1f 	tst	w0, #0xff
  40ee5c:	54000200 	b.eq	40ee9c <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  40ee60:	2a1603e0 	mov	w0, w22
  40ee64:	97ffec0d 	bl	409e98 <posix_irq_unlock>
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
  40ee68:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40ee6c:	14000023 	b	40eef8 <z_impl_k_mutex_lock+0x1b4>
					_current->base.prio :
  40ee70:	f9400b20 	ldr	x0, [x25, #16]
  40ee74:	39c06800 	ldrsb	w0, [x0, #26]
		mutex->owner = _current;
  40ee78:	f9472eb5 	ldr	x21, [x21, #3672]
		mutex->lock_count++;
  40ee7c:	11000421 	add	w1, w1, #0x1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  40ee80:	29030261 	stp	w1, w0, [x19, #24]
		mutex->owner = _current;
  40ee84:	f9400aa0 	ldr	x0, [x21, #16]
  40ee88:	f9000a60 	str	x0, [x19, #16]
  40ee8c:	91328280 	add	x0, x20, #0xca0
  40ee90:	97fffdc9 	bl	40e5b4 <z_spin_unlock_valid>
  40ee94:	72001c1f 	tst	w0, #0xff
  40ee98:	540002a1 	b.ne	40eeec <z_impl_k_mutex_lock+0x1a8>  // b.any
  40ee9c:	f0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40eea0:	912faa73 	add	x19, x19, #0xbea
  40eea4:	aa1303e2 	mov	x2, x19
  40eea8:	52801863 	mov	w3, #0xc3                  	// #195
  40eeac:	f0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40eeb0:	d0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40eeb4:	91311021 	add	x1, x1, #0xc44
  40eeb8:	911a8800 	add	x0, x0, #0x6a2
  40eebc:	97ffe2ef 	bl	407a78 <assert_print>
  40eec0:	91328281 	add	x1, x20, #0xca0
  40eec4:	f0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40eec8:	91316c00 	add	x0, x0, #0xc5b
  40eecc:	97ffe2eb 	bl	407a78 <assert_print>
  40eed0:	aa1303e0 	mov	x0, x19
  40eed4:	52801861 	mov	w1, #0xc3                  	// #195
  40eed8:	97ffe312 	bl	407b20 <assert_post_action>
  40eedc:	52801862 	mov	w2, #0xc3                  	// #195
  40eee0:	17ffffb4 	b	40edb0 <z_impl_k_mutex_lock+0x6c>
					_current->base.prio :
  40eee4:	b9401e60 	ldr	w0, [x19, #28]
  40eee8:	17ffffe4 	b	40ee78 <z_impl_k_mutex_lock+0x134>
  40eeec:	2a1603e0 	mov	w0, w22
  40eef0:	97ffebea 	bl	409e98 <posix_irq_unlock>
		return 0;
  40eef4:	52800000 	mov	w0, #0x0                   	// #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
  40eef8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40eefc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ef00:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ef04:	f94023f9 	ldr	x25, [sp, #64]
  40ef08:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40ef0c:	d65f03c0 	ret
	new_prio = new_prio_for_inheritance(_current->base.prio,
  40ef10:	39c06842 	ldrsb	w2, [x2, #26]
  40ef14:	39c06803 	ldrsb	w3, [x0, #26]
  40ef18:	6b03005f 	cmp	w2, w3
  40ef1c:	1a83d041 	csel	w1, w2, w3, le
  40ef20:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  40ef24:	3101fc3f 	cmn	w1, #0x7f
  40ef28:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  40ef2c:	6b01007f 	cmp	w3, w1
  40ef30:	5400050d 	b.le	40efd0 <z_impl_k_mutex_lock+0x28c>
		resched = adjust_owner_prio(mutex, new_prio);
  40ef34:	97ffff79 	bl	40ed18 <adjust_owner_prio.isra.0>
  40ef38:	12001c17 	and	w23, w0, #0xff
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  40ef3c:	91328299 	add	x25, x20, #0xca0
  40ef40:	aa1803e3 	mov	x3, x24
  40ef44:	aa1303e2 	mov	x2, x19
  40ef48:	2a1603e1 	mov	w1, w22
  40ef4c:	aa1903e0 	mov	x0, x25
  40ef50:	940008d7 	bl	4112ac <z_pend_curr>
	if (got_mutex == 0) {
  40ef54:	34fffd20 	cbz	w0, 40eef8 <z_impl_k_mutex_lock+0x1b4>
	return posix_irq_lock();
  40ef58:	97ffebce 	bl	409e90 <posix_irq_lock>
  40ef5c:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ef60:	aa1903e0 	mov	x0, x25
  40ef64:	97fffd89 	bl	40e588 <z_spin_lock_valid>
  40ef68:	72001c1f 	tst	w0, #0xff
  40ef6c:	54fff3c0 	b.eq	40ede4 <z_impl_k_mutex_lock+0xa0>  // b.none
	z_spin_lock_set_owner(l);
  40ef70:	aa1903e0 	mov	x0, x25
  40ef74:	97fffd9d 	bl	40e5e8 <z_spin_lock_set_owner>
	if (likely(mutex->owner != NULL)) {
  40ef78:	f9400a60 	ldr	x0, [x19, #16]
  40ef7c:	b40001e0 	cbz	x0, 40efb8 <z_impl_k_mutex_lock+0x274>
	return list->head == list;
  40ef80:	f9400262 	ldr	x2, [x19]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  40ef84:	b9401e61 	ldr	w1, [x19, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40ef88:	eb02027f 	cmp	x19, x2
  40ef8c:	54000100 	b.eq	40efac <z_impl_k_mutex_lock+0x268>  // b.none
  40ef90:	b40000e2 	cbz	x2, 40efac <z_impl_k_mutex_lock+0x268>
  40ef94:	39c06842 	ldrsb	w2, [x2, #26]
  40ef98:	6b02003f 	cmp	w1, w2
  40ef9c:	1a82d021 	csel	w1, w1, w2, le
  40efa0:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  40efa4:	3101fc3f 	cmn	w1, #0x7f
  40efa8:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
		resched = adjust_owner_prio(mutex, new_prio) || resched;
  40efac:	97ffff5b 	bl	40ed18 <adjust_owner_prio.isra.0>
  40efb0:	72001c1f 	tst	w0, #0xff
  40efb4:	54000041 	b.ne	40efbc <z_impl_k_mutex_lock+0x278>  // b.any
	if (resched) {
  40efb8:	34000117 	cbz	w23, 40efd8 <z_impl_k_mutex_lock+0x294>
		z_reschedule(&lock, key);
  40efbc:	2a1503e1 	mov	w1, w21
  40efc0:	91328280 	add	x0, x20, #0xca0
  40efc4:	94000516 	bl	41041c <z_reschedule>
	return -EAGAIN;
  40efc8:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40efcc:	17ffffcb 	b	40eef8 <z_impl_k_mutex_lock+0x1b4>
	bool resched = false;
  40efd0:	52800017 	mov	w23, #0x0                   	// #0
  40efd4:	17ffffda 	b	40ef3c <z_impl_k_mutex_lock+0x1f8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40efd8:	91328280 	add	x0, x20, #0xca0
  40efdc:	97fffd76 	bl	40e5b4 <z_spin_unlock_valid>
  40efe0:	72001c1f 	tst	w0, #0xff
  40efe4:	54fff5c0 	b.eq	40ee9c <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  40efe8:	2a1503e0 	mov	w0, w21
  40efec:	97ffebab 	bl	409e98 <posix_irq_unlock>
  40eff0:	17fffff6 	b	40efc8 <z_impl_k_mutex_lock+0x284>

000000000040eff4 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  40eff4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40eff8:	910003fd 	mov	x29, sp
  40effc:	a90153f3 	stp	x19, x20, [sp, #16]
  40f000:	aa0003f3 	mov	x19, x0
  40f004:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40f008:	f90013f5 	str	x21, [sp, #32]
  40f00c:	f9472c00 	ldr	x0, [x0, #3672]
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  40f010:	b9400001 	ldr	w1, [x0]
  40f014:	340002a1 	cbz	w1, 40f068 <z_impl_k_mutex_unlock+0x74>
  40f018:	f0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  40f01c:	91095e73 	add	x19, x19, #0x257
  40f020:	aa1303e2 	mov	x2, x19
  40f024:	f0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  40f028:	9104f021 	add	x1, x1, #0x13c
  40f02c:	528019a3 	mov	w3, #0xcd                  	// #205
  40f030:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f034:	911a8800 	add	x0, x0, #0x6a2
  40f038:	97ffe290 	bl	407a78 <assert_print>
  40f03c:	f0000020 	adrp	x0, 416000 <__func__.0+0xc27>
  40f040:	9109e400 	add	x0, x0, #0x279
  40f044:	97ffe28d 	bl	407a78 <assert_print>
  40f048:	aa1303e0 	mov	x0, x19
  40f04c:	528019a1 	mov	w1, #0xcd                  	// #205
  40f050:	97ffe2b4 	bl	407b20 <assert_post_action>
  40f054:	528019a2 	mov	w2, #0xcd                  	// #205
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  40f058:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f05c:	aa1303e1 	mov	x1, x19
  40f060:	911b8000 	add	x0, x0, #0x6e0
  40f064:	97ffeca1 	bl	40a2e8 <posix_print_error_and_exit>
	CHECKIF(mutex->owner == NULL) {
  40f068:	f9400a61 	ldr	x1, [x19, #16]
  40f06c:	b4000c41 	cbz	x1, 40f1f4 <z_impl_k_mutex_unlock+0x200>
	CHECKIF(mutex->owner != _current) {
  40f070:	f9400800 	ldr	x0, [x0, #16]
  40f074:	eb00003f 	cmp	x1, x0
  40f078:	54000c21 	b.ne	40f1fc <z_impl_k_mutex_unlock+0x208>  // b.any
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  40f07c:	b9401a60 	ldr	w0, [x19, #24]
  40f080:	350001e0 	cbnz	w0, 40f0bc <z_impl_k_mutex_unlock+0xc8>
  40f084:	f0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  40f088:	91095e73 	add	x19, x19, #0x257
  40f08c:	aa1303e2 	mov	x2, x19
  40f090:	52801ca3 	mov	w3, #0xe5                  	// #229
  40f094:	f0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  40f098:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f09c:	910a7821 	add	x1, x1, #0x29e
  40f0a0:	911a8800 	add	x0, x0, #0x6a2
  40f0a4:	97ffe275 	bl	407a78 <assert_print>
  40f0a8:	aa1303e0 	mov	x0, x19
  40f0ac:	52801ca1 	mov	w1, #0xe5                  	// #229
  40f0b0:	97ffe29c 	bl	407b20 <assert_post_action>
  40f0b4:	52801ca2 	mov	w2, #0xe5                  	// #229
  40f0b8:	17ffffe8 	b	40f058 <z_impl_k_mutex_unlock+0x64>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
  40f0bc:	7100041f 	cmp	w0, #0x1
  40f0c0:	54000100 	b.eq	40f0e0 <z_impl_k_mutex_unlock+0xec>  // b.none
		mutex->lock_count--;
  40f0c4:	51000400 	sub	w0, w0, #0x1
  40f0c8:	b9001a60 	str	w0, [x19, #24]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
  40f0cc:	52800000 	mov	w0, #0x0                   	// #0
}
  40f0d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f0d4:	f94013f5 	ldr	x21, [sp, #32]
  40f0d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40f0dc:	d65f03c0 	ret
	return posix_irq_lock();
  40f0e0:	97ffeb6c 	bl	409e90 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f0e4:	d00000f4 	adrp	x20, 42d000 <counter_value>
  40f0e8:	91328294 	add	x20, x20, #0xca0
  40f0ec:	2a0003f5 	mov	w21, w0
  40f0f0:	aa1403e0 	mov	x0, x20
  40f0f4:	97fffd25 	bl	40e588 <z_spin_lock_valid>
  40f0f8:	72001c1f 	tst	w0, #0xff
  40f0fc:	54000261 	b.ne	40f148 <z_impl_k_mutex_unlock+0x154>  // b.any
  40f100:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f104:	912faa73 	add	x19, x19, #0xbea
  40f108:	aa1303e2 	mov	x2, x19
  40f10c:	52801283 	mov	w3, #0x94                  	// #148
  40f110:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f114:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f118:	91305c21 	add	x1, x1, #0xc17
  40f11c:	911a8800 	add	x0, x0, #0x6a2
  40f120:	97ffe256 	bl	407a78 <assert_print>
  40f124:	aa1403e1 	mov	x1, x20
  40f128:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f12c:	9130b000 	add	x0, x0, #0xc2c
  40f130:	97ffe252 	bl	407a78 <assert_print>
  40f134:	aa1303e0 	mov	x0, x19
  40f138:	52801281 	mov	w1, #0x94                  	// #148
  40f13c:	97ffe279 	bl	407b20 <assert_post_action>
  40f140:	52801282 	mov	w2, #0x94                  	// #148
  40f144:	17ffffc5 	b	40f058 <z_impl_k_mutex_unlock+0x64>
	z_spin_lock_set_owner(l);
  40f148:	aa1403e0 	mov	x0, x20
  40f14c:	97fffd27 	bl	40e5e8 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  40f150:	b9401e61 	ldr	w1, [x19, #28]
  40f154:	f9400a60 	ldr	x0, [x19, #16]
  40f158:	97fffef0 	bl	40ed18 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  40f15c:	aa1303e0 	mov	x0, x19
  40f160:	94000a5b 	bl	411acc <z_unpend_first_thread>
	mutex->owner = new_owner;
  40f164:	f9000a60 	str	x0, [x19, #16]
	if (new_owner != NULL) {
  40f168:	b4000120 	cbz	x0, 40f18c <z_impl_k_mutex_unlock+0x198>
		mutex->owner_orig_prio = new_owner->base.prio;
  40f16c:	39c06801 	ldrsb	w1, [x0, #26]
  40f170:	b9001e61 	str	w1, [x19, #28]
	thread->callee_saved.retval = value;
  40f174:	b9004c1f 	str	wzr, [x0, #76]
		z_ready_thread(new_owner);
  40f178:	94000704 	bl	410d88 <z_ready_thread>
		z_reschedule(&lock, key);
  40f17c:	2a1503e1 	mov	w1, w21
  40f180:	aa1403e0 	mov	x0, x20
  40f184:	940004a6 	bl	41041c <z_reschedule>
  40f188:	17ffffd1 	b	40f0cc <z_impl_k_mutex_unlock+0xd8>
		mutex->lock_count = 0U;
  40f18c:	b9001a7f 	str	wzr, [x19, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f190:	aa1403e0 	mov	x0, x20
  40f194:	97fffd08 	bl	40e5b4 <z_spin_unlock_valid>
  40f198:	72001c1f 	tst	w0, #0xff
  40f19c:	54000261 	b.ne	40f1e8 <z_impl_k_mutex_unlock+0x1f4>  // b.any
  40f1a0:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f1a4:	912faa73 	add	x19, x19, #0xbea
  40f1a8:	aa1303e2 	mov	x2, x19
  40f1ac:	52801863 	mov	w3, #0xc3                  	// #195
  40f1b0:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f1b4:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f1b8:	91311021 	add	x1, x1, #0xc44
  40f1bc:	911a8800 	add	x0, x0, #0x6a2
  40f1c0:	97ffe22e 	bl	407a78 <assert_print>
  40f1c4:	aa1403e1 	mov	x1, x20
  40f1c8:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f1cc:	91316c00 	add	x0, x0, #0xc5b
  40f1d0:	97ffe22a 	bl	407a78 <assert_print>
  40f1d4:	aa1303e0 	mov	x0, x19
  40f1d8:	52801861 	mov	w1, #0xc3                  	// #195
  40f1dc:	97ffe251 	bl	407b20 <assert_post_action>
  40f1e0:	52801862 	mov	w2, #0xc3                  	// #195
  40f1e4:	17ffff9d 	b	40f058 <z_impl_k_mutex_unlock+0x64>
	posix_irq_unlock(key);
  40f1e8:	2a1503e0 	mov	w0, w21
  40f1ec:	97ffeb2b 	bl	409e98 <posix_irq_unlock>
  40f1f0:	17ffffb7 	b	40f0cc <z_impl_k_mutex_unlock+0xd8>
		return -EINVAL;
  40f1f4:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40f1f8:	17ffffb6 	b	40f0d0 <z_impl_k_mutex_unlock+0xdc>
		return -EPERM;
  40f1fc:	12800000 	mov	w0, #0xffffffff            	// #-1
  40f200:	17ffffb4 	b	40f0d0 <z_impl_k_mutex_unlock+0xdc>

000000000040f204 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
  40f204:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40f208:	910003fd 	mov	x29, sp
  40f20c:	a90153f3 	stp	x19, x20, [sp, #16]
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  40f210:	91004014 	add	x20, x0, #0x10
{
  40f214:	aa0003f3 	mov	x19, x0
  40f218:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f21c:	aa0103f5 	mov	x21, x1
  40f220:	a90363f7 	stp	x23, x24, [sp, #48]
  40f224:	aa0203f7 	mov	x23, x2
  40f228:	12001c78 	and	w24, w3, #0xff
  40f22c:	f90023f9 	str	x25, [sp, #64]
  40f230:	12001c99 	and	w25, w4, #0xff
	return posix_irq_lock();
  40f234:	97ffeb17 	bl	409e90 <posix_irq_lock>
  40f238:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f23c:	aa1403e0 	mov	x0, x20
  40f240:	97fffcd2 	bl	40e588 <z_spin_lock_valid>
  40f244:	72001c1f 	tst	w0, #0xff
  40f248:	540002c1 	b.ne	40f2a0 <queue_insert+0x9c>  // b.any
  40f24c:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f250:	912faa73 	add	x19, x19, #0xbea
  40f254:	aa1303e2 	mov	x2, x19
  40f258:	52801283 	mov	w3, #0x94                  	// #148
  40f25c:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f260:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f264:	91305c21 	add	x1, x1, #0xc17
  40f268:	911a8800 	add	x0, x0, #0x6a2
  40f26c:	97ffe203 	bl	407a78 <assert_print>
  40f270:	aa1403e1 	mov	x1, x20
  40f274:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f278:	9130b000 	add	x0, x0, #0xc2c
  40f27c:	97ffe1ff 	bl	407a78 <assert_print>
  40f280:	aa1303e0 	mov	x0, x19
  40f284:	52801281 	mov	w1, #0x94                  	// #148
  40f288:	97ffe226 	bl	407b20 <assert_post_action>
  40f28c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f290:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f294:	aa1303e1 	mov	x1, x19
  40f298:	911b8000 	add	x0, x0, #0x6e0
  40f29c:	97ffec13 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f2a0:	aa1403e0 	mov	x0, x20
  40f2a4:	97fffcd1 	bl	40e5e8 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
  40f2a8:	34000059 	cbz	w25, 40f2b0 <queue_insert+0xac>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
  40f2ac:	f9400675 	ldr	x21, [x19, #8]
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  40f2b0:	91006260 	add	x0, x19, #0x18
  40f2b4:	94000a06 	bl	411acc <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
  40f2b8:	b4000120 	cbz	x0, 40f2dc <queue_insert+0xd8>
  40f2bc:	f9001017 	str	x23, [x0, #32]
  40f2c0:	b9004c1f 	str	wzr, [x0, #76]
	z_ready_thread(thread);
  40f2c4:	940006b1 	bl	410d88 <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
  40f2c8:	aa1403e0 	mov	x0, x20
  40f2cc:	2a1603e1 	mov	w1, w22
  40f2d0:	94000453 	bl	41041c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
  40f2d4:	52800000 	mov	w0, #0x0                   	// #0
  40f2d8:	1400001f 	b	40f354 <queue_insert+0x150>
	if (alloc) {
  40f2dc:	34000638 	cbz	w24, 40f3a0 <queue_insert+0x19c>
	return z_thread_aligned_alloc(0, size);
  40f2e0:	d2800201 	mov	x1, #0x10                  	// #16
  40f2e4:	94001035 	bl	4133b8 <z_thread_aligned_alloc>
  40f2e8:	aa0003e3 	mov	x3, x0
		if (anode == NULL) {
  40f2ec:	b5000400 	cbnz	x0, 40f36c <queue_insert+0x168>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f2f0:	aa1403e0 	mov	x0, x20
  40f2f4:	97fffcb0 	bl	40e5b4 <z_spin_unlock_valid>
  40f2f8:	72001c1f 	tst	w0, #0xff
  40f2fc:	54000261 	b.ne	40f348 <queue_insert+0x144>  // b.any
  40f300:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f304:	912faa73 	add	x19, x19, #0xbea
  40f308:	aa1303e2 	mov	x2, x19
  40f30c:	52801863 	mov	w3, #0xc3                  	// #195
  40f310:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f314:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f318:	91311021 	add	x1, x1, #0xc44
  40f31c:	911a8800 	add	x0, x0, #0x6a2
  40f320:	97ffe1d6 	bl	407a78 <assert_print>
  40f324:	aa1403e1 	mov	x1, x20
  40f328:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f32c:	91316c00 	add	x0, x0, #0xc5b
  40f330:	97ffe1d2 	bl	407a78 <assert_print>
  40f334:	aa1303e0 	mov	x0, x19
  40f338:	52801861 	mov	w1, #0xc3                  	// #195
  40f33c:	97ffe1f9 	bl	407b20 <assert_post_action>
  40f340:	52801862 	mov	w2, #0xc3                  	// #195
  40f344:	17ffffd3 	b	40f290 <queue_insert+0x8c>
	posix_irq_unlock(key);
  40f348:	2a1603e0 	mov	w0, w22
  40f34c:	97ffead3 	bl	409e98 <posix_irq_unlock>
			return -ENOMEM;
  40f350:	12800160 	mov	w0, #0xfffffff4            	// #-12
}
  40f354:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f358:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f35c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f360:	f94023f9 	ldr	x25, [sp, #64]
  40f364:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40f368:	d65f03c0 	ret
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
  40f36c:	d2800020 	mov	x0, #0x1                   	// #1
		anode->data = data;
  40f370:	a9005c60 	stp	x0, x23, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f374:	f9400060 	ldr	x0, [x3]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f378:	92400400 	and	x0, x0, #0x3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
  40f37c:	b5000195 	cbnz	x21, 40f3ac <queue_insert+0x1a8>
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f380:	f9400261 	ldr	x1, [x19]
  40f384:	aa000020 	orr	x0, x1, x0
  40f388:	f9000060 	str	x0, [x3]
	list->head = node;
  40f38c:	f9000263 	str	x3, [x19]
Z_GENLIST_PREPEND(sflist, sfnode)
  40f390:	f9400660 	ldr	x0, [x19, #8]
  40f394:	b50001a0 	cbnz	x0, 40f3c8 <queue_insert+0x1c4>
	list->tail = node;
  40f398:	f9000663 	str	x3, [x19, #8]
}
  40f39c:	1400000b 	b	40f3c8 <queue_insert+0x1c4>
}
  40f3a0:	aa1703e3 	mov	x3, x23
	node->next_and_flags = flags;
  40f3a4:	f90002ff 	str	xzr, [x23]
}
  40f3a8:	17fffff3 	b	40f374 <queue_insert+0x170>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f3ac:	f94002a2 	ldr	x2, [x21]
Z_GENLIST_INSERT(sflist, sfnode)
  40f3b0:	f27ef442 	ands	x2, x2, #0xfffffffffffffffc
  40f3b4:	540001c1 	b.ne	40f3ec <queue_insert+0x1e8>  // b.any
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f3b8:	f9000060 	str	x0, [x3]
	return list->tail;
  40f3bc:	f9400661 	ldr	x1, [x19, #8]
Z_GENLIST_APPEND(sflist, sfnode)
  40f3c0:	b50000c1 	cbnz	x1, 40f3d8 <queue_insert+0x1d4>
	list->tail = node;
  40f3c4:	a9000e63 	stp	x3, x3, [x19]
	z_handle_obj_poll_events(&queue->poll_events, state);
  40f3c8:	9100a260 	add	x0, x19, #0x28
  40f3cc:	52800081 	mov	w1, #0x4                   	// #4
  40f3d0:	94000feb 	bl	41337c <z_handle_obj_poll_events>
  40f3d4:	17ffffbd 	b	40f2c8 <queue_insert+0xc4>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f3d8:	f9400020 	ldr	x0, [x1]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f3dc:	92400400 	and	x0, x0, #0x3
  40f3e0:	aa000060 	orr	x0, x3, x0
  40f3e4:	f9000020 	str	x0, [x1]
  40f3e8:	17ffffec 	b	40f398 <queue_insert+0x194>
  40f3ec:	aa000042 	orr	x2, x2, x0
  40f3f0:	f9000062 	str	x2, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f3f4:	f94002a0 	ldr	x0, [x21]
	parent->next_and_flags = cur_flags | (unative_t)child;
  40f3f8:	92400400 	and	x0, x0, #0x3
  40f3fc:	aa000063 	orr	x3, x3, x0
  40f400:	f90002a3 	str	x3, [x21]
}
  40f404:	17fffff1 	b	40f3c8 <queue_insert+0x1c4>

000000000040f408 <z_queue_node_peek>:
{
  40f408:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40f40c:	910003fd 	mov	x29, sp
  40f410:	f9000bf3 	str	x19, [sp, #16]
  40f414:	aa0003f3 	mov	x19, x0
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
  40f418:	b4000100 	cbz	x0, 40f438 <z_queue_node_peek+0x30>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  40f41c:	f9400003 	ldr	x3, [x0]
  40f420:	f240047f 	tst	x3, #0x3
  40f424:	540000a0 	b.eq	40f438 <z_queue_node_peek+0x30>  // b.none
  40f428:	12001c21 	and	w1, w1, #0xff
		ret = anode->data;
  40f42c:	f9400413 	ldr	x19, [x0, #8]
		if (needs_free) {
  40f430:	34000041 	cbz	w1, 40f438 <z_queue_node_peek+0x30>
			k_free(anode);
  40f434:	94000fdc 	bl	4133a4 <k_free>
}
  40f438:	aa1303e0 	mov	x0, x19
  40f43c:	f9400bf3 	ldr	x19, [sp, #16]
  40f440:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f444:	d65f03c0 	ret

000000000040f448 <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
  40f448:	aa0103e2 	mov	x2, x1
  40f44c:	52800004 	mov	w4, #0x0                   	// #0
  40f450:	52800003 	mov	w3, #0x0                   	// #0
  40f454:	d2800001 	mov	x1, #0x0                   	// #0
  40f458:	17ffff6b 	b	40f204 <queue_insert>

000000000040f45c <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
  40f45c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40f460:	910003fd 	mov	x29, sp
  40f464:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  40f468:	91004014 	add	x20, x0, #0x10
{
  40f46c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f470:	aa0003f5 	mov	x21, x0
  40f474:	f9001bf7 	str	x23, [sp, #48]
  40f478:	aa0103f7 	mov	x23, x1
	return posix_irq_lock();
  40f47c:	97ffea85 	bl	409e90 <posix_irq_lock>
  40f480:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f484:	aa1403e0 	mov	x0, x20
  40f488:	97fffc40 	bl	40e588 <z_spin_lock_valid>
  40f48c:	72001c1f 	tst	w0, #0xff
  40f490:	540002c1 	b.ne	40f4e8 <z_impl_k_queue_get+0x8c>  // b.any
  40f494:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f498:	912faa73 	add	x19, x19, #0xbea
  40f49c:	aa1303e2 	mov	x2, x19
  40f4a0:	52801283 	mov	w3, #0x94                  	// #148
  40f4a4:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f4a8:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f4ac:	91305c21 	add	x1, x1, #0xc17
  40f4b0:	911a8800 	add	x0, x0, #0x6a2
  40f4b4:	97ffe171 	bl	407a78 <assert_print>
  40f4b8:	aa1403e1 	mov	x1, x20
  40f4bc:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f4c0:	9130b000 	add	x0, x0, #0xc2c
  40f4c4:	97ffe16d 	bl	407a78 <assert_print>
  40f4c8:	aa1303e0 	mov	x0, x19
  40f4cc:	52801281 	mov	w1, #0x94                  	// #148
  40f4d0:	97ffe194 	bl	407b20 <assert_post_action>
  40f4d4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f4d8:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f4dc:	aa1303e1 	mov	x1, x19
  40f4e0:	911b8000 	add	x0, x0, #0x6e0
  40f4e4:	97ffeb81 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f4e8:	aa1403e0 	mov	x0, x20
  40f4ec:	97fffc3f 	bl	40e5e8 <z_spin_lock_set_owner>
	return list->head;
  40f4f0:	f94002b3 	ldr	x19, [x21]
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
  40f4f4:	b4000453 	cbz	x19, 40f57c <z_impl_k_queue_get+0x120>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f4f8:	f9400260 	ldr	x0, [x19]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  40f4fc:	f94006a1 	ldr	x1, [x21, #8]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  40f500:	927ef400 	and	x0, x0, #0xfffffffffffffffc
	list->head = node;
  40f504:	f90002a0 	str	x0, [x21]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  40f508:	eb01027f 	cmp	x19, x1
  40f50c:	54000041 	b.ne	40f514 <z_impl_k_queue_get+0xb8>  // b.any
	list->tail = node;
  40f510:	f90006a0 	str	x0, [x21, #8]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
  40f514:	aa1303e0 	mov	x0, x19
  40f518:	52800021 	mov	w1, #0x1                   	// #1
  40f51c:	97ffffbb 	bl	40f408 <z_queue_node_peek>
  40f520:	aa0003f3 	mov	x19, x0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f524:	aa1403e0 	mov	x0, x20
  40f528:	97fffc23 	bl	40e5b4 <z_spin_unlock_valid>
  40f52c:	72001c1f 	tst	w0, #0xff
  40f530:	540003e1 	b.ne	40f5ac <z_impl_k_queue_get+0x150>  // b.any
  40f534:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f538:	912faa73 	add	x19, x19, #0xbea
  40f53c:	aa1303e2 	mov	x2, x19
  40f540:	52801863 	mov	w3, #0xc3                  	// #195
  40f544:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f548:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f54c:	91311021 	add	x1, x1, #0xc44
  40f550:	911a8800 	add	x0, x0, #0x6a2
  40f554:	97ffe149 	bl	407a78 <assert_print>
  40f558:	aa1403e1 	mov	x1, x20
  40f55c:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f560:	91316c00 	add	x0, x0, #0xc5b
  40f564:	97ffe145 	bl	407a78 <assert_print>
  40f568:	aa1303e0 	mov	x0, x19
  40f56c:	52801861 	mov	w1, #0xc3                  	// #195
  40f570:	97ffe16c 	bl	407b20 <assert_post_action>
  40f574:	52801862 	mov	w2, #0xc3                  	// #195
  40f578:	17ffffd8 	b	40f4d8 <z_impl_k_queue_get+0x7c>
		return data;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40f57c:	b4fffd57 	cbz	x23, 40f524 <z_impl_k_queue_get+0xc8>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
  40f580:	aa1703e3 	mov	x3, x23
  40f584:	910062a2 	add	x2, x21, #0x18
  40f588:	2a1603e1 	mov	w1, w22
  40f58c:	aa1403e0 	mov	x0, x20
  40f590:	94000747 	bl	4112ac <z_pend_curr>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
  40f594:	35000100 	cbnz	w0, 40f5b4 <z_impl_k_queue_get+0x158>
  40f598:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40f59c:	f9472c00 	ldr	x0, [x0, #3672]
  40f5a0:	f9400800 	ldr	x0, [x0, #16]
  40f5a4:	f9401013 	ldr	x19, [x0, #32]
  40f5a8:	14000003 	b	40f5b4 <z_impl_k_queue_get+0x158>
	posix_irq_unlock(key);
  40f5ac:	2a1603e0 	mov	w0, w22
  40f5b0:	97ffea3a 	bl	409e98 <posix_irq_unlock>
}
  40f5b4:	aa1303e0 	mov	x0, x19
  40f5b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f5bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f5c0:	f9401bf7 	ldr	x23, [sp, #48]
  40f5c4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40f5c8:	d65f03c0 	ret

000000000040f5cc <z_impl_k_sem_init>:
		      unsigned int limit)
{
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
  40f5cc:	7100005f 	cmp	w2, #0x0
  40f5d0:	7a411040 	ccmp	w2, w1, #0x0, ne  // ne = any
  40f5d4:	540000e3 	b.cc	40f5f0 <z_impl_k_sem_init+0x24>  // b.lo, b.ul, b.last
	list->tail = (sys_dnode_t *)list;
  40f5d8:	a9000000 	stp	x0, x0, [x0]

		return -EINVAL;
	}

	sem->count = initial_count;
	sem->limit = limit;
  40f5dc:	29020801 	stp	w1, w2, [x0, #16]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
  40f5e0:	91006001 	add	x1, x0, #0x18
  40f5e4:	a9018401 	stp	x1, x1, [x0, #24]
#endif
	z_object_init(sem);

	return 0;
  40f5e8:	52800000 	mov	w0, #0x0                   	// #0
}
  40f5ec:	d65f03c0 	ret
		return -EINVAL;
  40f5f0:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40f5f4:	17fffffe 	b	40f5ec <z_impl_k_sem_init+0x20>

000000000040f5f8 <z_impl_k_sem_give>:
	return false;
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  40f5f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40f5fc:	910003fd 	mov	x29, sp
  40f600:	a90153f3 	stp	x19, x20, [sp, #16]
  40f604:	aa0003f3 	mov	x19, x0
  40f608:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40f60c:	97ffea21 	bl	409e90 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f610:	d00000f6 	adrp	x22, 42d000 <counter_value>
  40f614:	9132a2d5 	add	x21, x22, #0xca8
  40f618:	2a0003f4 	mov	w20, w0
  40f61c:	aa1503e0 	mov	x0, x21
  40f620:	97fffbda 	bl	40e588 <z_spin_lock_valid>
  40f624:	72001c1f 	tst	w0, #0xff
  40f628:	540002c1 	b.ne	40f680 <z_impl_k_sem_give+0x88>  // b.any
  40f62c:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f630:	912faa73 	add	x19, x19, #0xbea
  40f634:	aa1303e2 	mov	x2, x19
  40f638:	52801283 	mov	w3, #0x94                  	// #148
  40f63c:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f640:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f644:	91305c21 	add	x1, x1, #0xc17
  40f648:	911a8800 	add	x0, x0, #0x6a2
  40f64c:	97ffe10b 	bl	407a78 <assert_print>
  40f650:	aa1503e1 	mov	x1, x21
  40f654:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f658:	9130b000 	add	x0, x0, #0xc2c
  40f65c:	97ffe107 	bl	407a78 <assert_print>
  40f660:	aa1303e0 	mov	x0, x19
  40f664:	52801281 	mov	w1, #0x94                  	// #148
  40f668:	97ffe12e 	bl	407b20 <assert_post_action>
  40f66c:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f670:	aa1303e1 	mov	x1, x19
  40f674:	911b8000 	add	x0, x0, #0x6e0
  40f678:	52801282 	mov	w2, #0x94                  	// #148
  40f67c:	97ffeb1b 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f680:	aa1503e0 	mov	x0, x21
  40f684:	97fffbd9 	bl	40e5e8 <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool resched = true;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
  40f688:	aa1303e0 	mov	x0, x19
  40f68c:	94000910 	bl	411acc <z_unpend_first_thread>

	if (thread != NULL) {
  40f690:	b4000120 	cbz	x0, 40f6b4 <z_impl_k_sem_give+0xbc>
  40f694:	b9004c1f 	str	wzr, [x0, #76]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
  40f698:	940005bc 	bl	410d88 <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		resched = handle_poll_events(sem);
	}

	if (resched) {
		z_reschedule(&lock, key);
  40f69c:	2a1403e1 	mov	w1, w20
  40f6a0:	9132a2c0 	add	x0, x22, #0xca8
	} else {
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
  40f6a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f6a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f6ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&lock, key);
  40f6b0:	1400035b 	b	41041c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f6b4:	29420262 	ldp	w2, w0, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f6b8:	52800041 	mov	w1, #0x2                   	// #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f6bc:	6b02001f 	cmp	w0, w2
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f6c0:	91006260 	add	x0, x19, #0x18
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  40f6c4:	1a820442 	cinc	w2, w2, ne  // ne = any
  40f6c8:	b9001262 	str	w2, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f6cc:	94000f2c 	bl	41337c <z_handle_obj_poll_events>
	return true;
  40f6d0:	17fffff3 	b	40f69c <z_impl_k_sem_give+0xa4>

000000000040f6d4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
  40f6d4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40f6d8:	910003fd 	mov	x29, sp
  40f6dc:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f6e0:	aa0003f5 	mov	x21, x0
	return _kernel.cpus[0].nested != 0U;
  40f6e4:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40f6e8:	a90153f3 	stp	x19, x20, [sp, #16]
  40f6ec:	aa0103f6 	mov	x22, x1
  40f6f0:	f9472c00 	ldr	x0, [x0, #3672]
  40f6f4:	f9001bf7 	str	x23, [sp, #48]
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
  40f6f8:	b9400000 	ldr	w0, [x0]
  40f6fc:	34000280 	cbz	w0, 40f74c <z_impl_k_sem_take+0x78>
  40f700:	b4000261 	cbz	x1, 40f74c <z_impl_k_sem_take+0x78>
  40f704:	f0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  40f708:	910ad673 	add	x19, x19, #0x2b5
  40f70c:	aa1303e2 	mov	x2, x19
  40f710:	f0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  40f714:	910b5421 	add	x1, x1, #0x2d5
  40f718:	52801003 	mov	w3, #0x80                  	// #128
  40f71c:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f720:	911a8800 	add	x0, x0, #0x6a2
  40f724:	97ffe0d5 	bl	407a78 <assert_print>
  40f728:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f72c:	91320400 	add	x0, x0, #0xc81
  40f730:	97ffe0d2 	bl	407a78 <assert_print>
  40f734:	aa1303e0 	mov	x0, x19
  40f738:	52801001 	mov	w1, #0x80                  	// #128
  40f73c:	97ffe0f9 	bl	407b20 <assert_post_action>
  40f740:	52801002 	mov	w2, #0x80                  	// #128
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f744:	aa1303e1 	mov	x1, x19
  40f748:	1400001b 	b	40f7b4 <z_impl_k_sem_take+0xe0>
  40f74c:	97ffe9d1 	bl	409e90 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f750:	d00000f7 	adrp	x23, 42d000 <counter_value>
  40f754:	9132a2f3 	add	x19, x23, #0xca8
  40f758:	2a0003f4 	mov	w20, w0
  40f75c:	aa1303e0 	mov	x0, x19
  40f760:	97fffb8a 	bl	40e588 <z_spin_lock_valid>
  40f764:	72001c1f 	tst	w0, #0xff
  40f768:	540002c1 	b.ne	40f7c0 <z_impl_k_sem_take+0xec>  // b.any
  40f76c:	d0000034 	adrp	x20, 415000 <random_data+0xd8c>
  40f770:	912faa94 	add	x20, x20, #0xbea
  40f774:	aa1403e2 	mov	x2, x20
  40f778:	52801283 	mov	w3, #0x94                  	// #148
  40f77c:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f780:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f784:	91305c21 	add	x1, x1, #0xc17
  40f788:	911a8800 	add	x0, x0, #0x6a2
  40f78c:	97ffe0bb 	bl	407a78 <assert_print>
  40f790:	aa1303e1 	mov	x1, x19
  40f794:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f798:	9130b000 	add	x0, x0, #0xc2c
  40f79c:	97ffe0b7 	bl	407a78 <assert_print>
  40f7a0:	52801281 	mov	w1, #0x94                  	// #148
  40f7a4:	aa1403e0 	mov	x0, x20
  40f7a8:	97ffe0de 	bl	407b20 <assert_post_action>
  40f7ac:	aa1403e1 	mov	x1, x20
  40f7b0:	52801282 	mov	w2, #0x94                  	// #148
  40f7b4:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f7b8:	911b8000 	add	x0, x0, #0x6e0
  40f7bc:	97ffeacb 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f7c0:	aa1303e0 	mov	x0, x19
  40f7c4:	97fffb89 	bl	40e5e8 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
  40f7c8:	b94012a0 	ldr	w0, [x21, #16]
  40f7cc:	34000420 	cbz	w0, 40f850 <z_impl_k_sem_take+0x17c>
		sem->count--;
  40f7d0:	51000400 	sub	w0, w0, #0x1
  40f7d4:	b90012a0 	str	w0, [x21, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f7d8:	aa1303e0 	mov	x0, x19
  40f7dc:	97fffb76 	bl	40e5b4 <z_spin_unlock_valid>
  40f7e0:	72001c1f 	tst	w0, #0xff
  40f7e4:	54000261 	b.ne	40f830 <z_impl_k_sem_take+0x15c>  // b.any
  40f7e8:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f7ec:	912faa73 	add	x19, x19, #0xbea
  40f7f0:	aa1303e2 	mov	x2, x19
  40f7f4:	52801863 	mov	w3, #0xc3                  	// #195
  40f7f8:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f7fc:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f800:	91311021 	add	x1, x1, #0xc44
  40f804:	911a8800 	add	x0, x0, #0x6a2
  40f808:	97ffe09c 	bl	407a78 <assert_print>
  40f80c:	9132a2e1 	add	x1, x23, #0xca8
  40f810:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f814:	91316c00 	add	x0, x0, #0xc5b
  40f818:	97ffe098 	bl	407a78 <assert_print>
  40f81c:	aa1303e0 	mov	x0, x19
  40f820:	52801861 	mov	w1, #0xc3                  	// #195
  40f824:	97ffe0bf 	bl	407b20 <assert_post_action>
  40f828:	52801862 	mov	w2, #0xc3                  	// #195
  40f82c:	17ffffc6 	b	40f744 <z_impl_k_sem_take+0x70>
	posix_irq_unlock(key);
  40f830:	2a1403e0 	mov	w0, w20
  40f834:	97ffe999 	bl	409e98 <posix_irq_unlock>
		k_spin_unlock(&lock, key);
		ret = 0;
  40f838:	52800000 	mov	w0, #0x0                   	// #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
  40f83c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f840:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f844:	f9401bf7 	ldr	x23, [sp, #48]
  40f848:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40f84c:	d65f03c0 	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40f850:	b5000136 	cbnz	x22, 40f874 <z_impl_k_sem_take+0x1a0>
  40f854:	aa1303e0 	mov	x0, x19
  40f858:	97fffb57 	bl	40e5b4 <z_spin_unlock_valid>
  40f85c:	72001c1f 	tst	w0, #0xff
  40f860:	54fffc40 	b.eq	40f7e8 <z_impl_k_sem_take+0x114>  // b.none
  40f864:	2a1403e0 	mov	w0, w20
  40f868:	97ffe98c 	bl	409e98 <posix_irq_unlock>
		ret = -EBUSY;
  40f86c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40f870:	17fffff3 	b	40f83c <z_impl_k_sem_take+0x168>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  40f874:	aa1603e3 	mov	x3, x22
  40f878:	aa1503e2 	mov	x2, x21
  40f87c:	2a1403e1 	mov	w1, w20
  40f880:	aa1303e0 	mov	x0, x19
}
  40f884:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f888:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f88c:	f9401bf7 	ldr	x23, [sp, #48]
  40f890:	a8c47bfd 	ldp	x29, x30, [sp], #64
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  40f894:	14000686 	b	4112ac <z_pend_curr>

000000000040f898 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
  40f898:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40f89c:	910003fd 	mov	x29, sp
  40f8a0:	a90153f3 	stp	x19, x20, [sp, #16]
  40f8a4:	aa0003f3 	mov	x19, x0
  40f8a8:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40f8ac:	97ffe979 	bl	409e90 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f8b0:	d00000f6 	adrp	x22, 42d000 <counter_value>
  40f8b4:	9132a2d5 	add	x21, x22, #0xca8
  40f8b8:	2a0003f4 	mov	w20, w0
  40f8bc:	aa1503e0 	mov	x0, x21
  40f8c0:	97fffb32 	bl	40e588 <z_spin_lock_valid>
  40f8c4:	72001c1f 	tst	w0, #0xff
  40f8c8:	540002c1 	b.ne	40f920 <z_impl_k_sem_reset+0x88>  // b.any
  40f8cc:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f8d0:	912faa73 	add	x19, x19, #0xbea
  40f8d4:	aa1303e2 	mov	x2, x19
  40f8d8:	52801283 	mov	w3, #0x94                  	// #148
  40f8dc:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40f8e0:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f8e4:	91305c21 	add	x1, x1, #0xc17
  40f8e8:	911a8800 	add	x0, x0, #0x6a2
  40f8ec:	97ffe063 	bl	407a78 <assert_print>
  40f8f0:	aa1503e1 	mov	x1, x21
  40f8f4:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40f8f8:	9130b000 	add	x0, x0, #0xc2c
  40f8fc:	97ffe05f 	bl	407a78 <assert_print>
  40f900:	aa1303e0 	mov	x0, x19
  40f904:	52801281 	mov	w1, #0x94                  	// #148
  40f908:	97ffe086 	bl	407b20 <assert_post_action>
  40f90c:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40f910:	aa1303e1 	mov	x1, x19
  40f914:	911b8000 	add	x0, x0, #0x6e0
  40f918:	52801282 	mov	w2, #0x94                  	// #148
  40f91c:	97ffea73 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f920:	aa1503e0 	mov	x0, x21
	thread->callee_saved.retval = value;
  40f924:	12800155 	mov	w21, #0xfffffff5            	// #-11
  40f928:	97fffb30 	bl	40e5e8 <z_spin_lock_set_owner>
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
  40f92c:	aa1303e0 	mov	x0, x19
  40f930:	94000867 	bl	411acc <z_unpend_first_thread>
		if (thread == NULL) {
  40f934:	b4000080 	cbz	x0, 40f944 <z_impl_k_sem_reset+0xac>
  40f938:	b9004c15 	str	w21, [x0, #76]
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
  40f93c:	94000513 	bl	410d88 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
  40f940:	17fffffb 	b	40f92c <z_impl_k_sem_reset+0x94>
	}
	sem->count = 0;
  40f944:	b900127f 	str	wzr, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  40f948:	91006260 	add	x0, x19, #0x18
  40f94c:	52800041 	mov	w1, #0x2                   	// #2
  40f950:	94000e8b 	bl	41337c <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
  40f954:	2a1403e1 	mov	w1, w20
  40f958:	9132a2c0 	add	x0, x22, #0xca8
}
  40f95c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f960:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f964:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&lock, key);
  40f968:	140002ad 	b	41041c <z_reschedule>

000000000040f96c <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
  40f96c:	b9400002 	ldr	w2, [x0]
	*flagp &= ~BIT(bit);
  40f970:	d2800023 	mov	x3, #0x1                   	// #1
  40f974:	9ac12063 	lsl	x3, x3, x1
  40f978:	0a230043 	bic	w3, w2, w3
  40f97c:	b9000003 	str	w3, [x0]
	return (*flagp & BIT(bit)) != 0U;
  40f980:	2a0203e0 	mov	w0, w2
  40f984:	9ac12400 	lsr	x0, x0, x1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
  40f988:	12000000 	and	w0, w0, #0x1
  40f98c:	d65f03c0 	ret

000000000040f990 <notify_queue_locked.isra.0>:
 */
static inline bool notify_queue_locked(struct k_work_q *queue)
{
	bool rv = false;

	if (queue != NULL) {
  40f990:	b40000a0 	cbz	x0, 40f9a4 <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
  40f994:	91034000 	add	x0, x0, #0xd0
  40f998:	d2800002 	mov	x2, #0x0                   	// #0
  40f99c:	52800001 	mov	w1, #0x0                   	// #0
  40f9a0:	14000b38 	b	412680 <z_sched_wake>
	}

	return rv;
}
  40f9a4:	d65f03c0 	ret

000000000040f9a8 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
  40f9a8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40f9ac:	910003fd 	mov	x29, sp
  40f9b0:	a90153f3 	stp	x19, x20, [sp, #16]
  40f9b4:	aa0003f3 	mov	x19, x0
  40f9b8:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f9bc:	d00000f5 	adrp	x21, 42d000 <counter_value>
  40f9c0:	a90363f7 	stp	x23, x24, [sp, #48]
	return list->head;
  40f9c4:	d00000f8 	adrp	x24, 42d000 <counter_value>
	return list->tail;
  40f9c8:	9132e316 	add	x22, x24, #0xcb8
  40f9cc:	a9046bf9 	stp	x25, x26, [sp, #64]
  40f9d0:	97ffe930 	bl	409e90 <posix_irq_lock>
  40f9d4:	9132c2b4 	add	x20, x21, #0xcb0
  40f9d8:	2a0003f7 	mov	w23, w0
  40f9dc:	aa1403e0 	mov	x0, x20
  40f9e0:	97fffaea 	bl	40e588 <z_spin_lock_valid>
  40f9e4:	72001c1f 	tst	w0, #0xff
  40f9e8:	540002c1 	b.ne	40fa40 <work_queue_main+0x98>  // b.any
  40f9ec:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40f9f0:	912faa73 	add	x19, x19, #0xbea
  40f9f4:	aa1303e2 	mov	x2, x19
  40f9f8:	52801283 	mov	w3, #0x94                  	// #148
  40f9fc:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40fa00:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fa04:	91305c21 	add	x1, x1, #0xc17
  40fa08:	911a8800 	add	x0, x0, #0x6a2
  40fa0c:	97ffe01b 	bl	407a78 <assert_print>
  40fa10:	9132c2a1 	add	x1, x21, #0xcb0
  40fa14:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40fa18:	9130b000 	add	x0, x0, #0xc2c
  40fa1c:	97ffe017 	bl	407a78 <assert_print>
  40fa20:	aa1303e0 	mov	x0, x19
  40fa24:	52801281 	mov	w1, #0x94                  	// #148
  40fa28:	97ffe03e 	bl	407b20 <assert_post_action>
  40fa2c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fa30:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fa34:	aa1303e1 	mov	x1, x19
  40fa38:	911b8000 	add	x0, x0, #0x6e0
  40fa3c:	97ffea2b 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40fa40:	aa1403e0 	mov	x0, x20
  40fa44:	97fffae9 	bl	40e5e8 <z_spin_lock_set_owner>
	return list->head;
  40fa48:	f9406274 	ldr	x20, [x19, #192]
Z_GENLIST_GET(slist, snode)
  40fa4c:	b50001b4 	cbnz	x20, 40fa80 <work_queue_main+0xd8>
			 * which should never happen, even line 'if (work != NULL)'
			 * ensures that.
			 * This means that if node is not NULL, then work will not be NULL.
			 */
			handler = work->handler;
		} else if (flag_test_and_clear(&queue->flags,
  40fa50:	9103c260 	add	x0, x19, #0xf0
  40fa54:	52800041 	mov	w1, #0x2                   	// #2
  40fa58:	97ffffc5 	bl	40f96c <flag_test_and_clear>
  40fa5c:	72001c1f 	tst	w0, #0xff
  40fa60:	54000581 	b.ne	40fb10 <work_queue_main+0x168>  // b.any
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
  40fa64:	91034262 	add	x2, x19, #0xd0
  40fa68:	2a1703e1 	mov	w1, w23
  40fa6c:	9132c2a0 	add	x0, x21, #0xcb0
  40fa70:	d2800004 	mov	x4, #0x0                   	// #0
  40fa74:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40fa78:	94000b58 	bl	4127d8 <z_sched_wait>
					   K_FOREVER, NULL);
			continue;
  40fa7c:	17ffffd5 	b	40f9d0 <work_queue_main+0x28>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  40fa80:	f9406661 	ldr	x1, [x19, #200]
	return node->next;
  40fa84:	f9400280 	ldr	x0, [x20]
	list->head = node;
  40fa88:	f9006260 	str	x0, [x19, #192]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  40fa8c:	eb01029f 	cmp	x20, x1
  40fa90:	54000041 	b.ne	40fa98 <work_queue_main+0xf0>  // b.any
	list->tail = node;
  40fa94:	f9006660 	str	x0, [x19, #200]
	*flagp |= BIT(bit);
  40fa98:	b940f260 	ldr	w0, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fa9c:	9132c2b9 	add	x25, x21, #0xcb0
  40faa0:	321f0000 	orr	w0, w0, #0x2
  40faa4:	b900f260 	str	w0, [x19, #240]
  40faa8:	aa1903e0 	mov	x0, x25
	*flagp &= ~BIT(bit);
  40faac:	b9401a82 	ldr	w2, [x20, #24]
			handler = work->handler;
  40fab0:	f940069a 	ldr	x26, [x20, #8]
	*flagp &= ~BIT(bit);
  40fab4:	121d7842 	and	w2, w2, #0xfffffffb
  40fab8:	32000042 	orr	w2, w2, #0x1
  40fabc:	b9001a82 	str	w2, [x20, #24]
  40fac0:	97fffabd 	bl	40e5b4 <z_spin_unlock_valid>
  40fac4:	72001c1f 	tst	w0, #0xff
  40fac8:	54000600 	b.eq	40fb88 <work_queue_main+0x1e0>  // b.none
	posix_irq_unlock(key);
  40facc:	2a1703e0 	mov	w0, w23
  40fad0:	97ffe8f2 	bl	409e98 <posix_irq_unlock>
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
  40fad4:	b50002fa 	cbnz	x26, 40fb30 <work_queue_main+0x188>
  40fad8:	f0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  40fadc:	910c8e73 	add	x19, x19, #0x323
  40fae0:	aa1303e2 	mov	x2, x19
  40fae4:	52805363 	mov	w3, #0x29b                 	// #667
  40fae8:	f0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  40faec:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40faf0:	910d1021 	add	x1, x1, #0x344
  40faf4:	911a8800 	add	x0, x0, #0x6a2
  40faf8:	97ffdfe0 	bl	407a78 <assert_print>
  40fafc:	aa1303e0 	mov	x0, x19
  40fb00:	52805361 	mov	w1, #0x29b                 	// #667
  40fb04:	97ffe007 	bl	407b20 <assert_post_action>
  40fb08:	52805362 	mov	w2, #0x29b                 	// #667
  40fb0c:	17ffffc9 	b	40fa30 <work_queue_main+0x88>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
  40fb10:	91038274 	add	x20, x19, #0xe0
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
  40fb14:	aa1403e0 	mov	x0, x20
  40fb18:	d2800002 	mov	x2, #0x0                   	// #0
  40fb1c:	52800021 	mov	w1, #0x1                   	// #1
  40fb20:	94000ad8 	bl	412680 <z_sched_wake>
  40fb24:	72001c1f 	tst	w0, #0xff
  40fb28:	54ffff61 	b.ne	40fb14 <work_queue_main+0x16c>  // b.any
  40fb2c:	17ffffce 	b	40fa64 <work_queue_main+0xbc>
		handler(work);
  40fb30:	aa1403e0 	mov	x0, x20
  40fb34:	d63f0340 	blr	x26
	return posix_irq_lock();
  40fb38:	97ffe8d6 	bl	409e90 <posix_irq_lock>
  40fb3c:	2a0003f7 	mov	w23, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fb40:	aa1903e0 	mov	x0, x25
  40fb44:	97fffa91 	bl	40e588 <z_spin_lock_valid>
  40fb48:	72001c1f 	tst	w0, #0xff
  40fb4c:	54fff500 	b.eq	40f9ec <work_queue_main+0x44>  // b.none
	z_spin_lock_set_owner(l);
  40fb50:	aa1903e0 	mov	x0, x25
  40fb54:	97fffaa5 	bl	40e5e8 <z_spin_lock_set_owner>
	*flagp &= ~BIT(bit);
  40fb58:	b9401a80 	ldr	w0, [x20, #24]
  40fb5c:	121f7801 	and	w1, w0, #0xfffffffe
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  40fb60:	37080380 	tbnz	w0, #1, 40fbd0 <work_queue_main+0x228>
	*flagp &= ~BIT(bit);
  40fb64:	b9001a81 	str	w1, [x20, #24]
  40fb68:	b940f261 	ldr	w1, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fb6c:	9132c2a0 	add	x0, x21, #0xcb0
  40fb70:	121e7821 	and	w1, w1, #0xfffffffd
  40fb74:	b900f261 	str	w1, [x19, #240]
	return (*flagp & BIT(bit)) != 0U;
  40fb78:	d3482034 	ubfx	x20, x1, #8, #1
  40fb7c:	97fffa8e 	bl	40e5b4 <z_spin_unlock_valid>
  40fb80:	72001c1f 	tst	w0, #0xff
  40fb84:	54000641 	b.ne	40fc4c <work_queue_main+0x2a4>  // b.any
  40fb88:	d0000033 	adrp	x19, 415000 <random_data+0xd8c>
  40fb8c:	912faa73 	add	x19, x19, #0xbea
  40fb90:	aa1303e2 	mov	x2, x19
  40fb94:	52801863 	mov	w3, #0xc3                  	// #195
  40fb98:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40fb9c:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fba0:	91311021 	add	x1, x1, #0xc44
  40fba4:	911a8800 	add	x0, x0, #0x6a2
  40fba8:	97ffdfb4 	bl	407a78 <assert_print>
  40fbac:	9132c2a1 	add	x1, x21, #0xcb0
  40fbb0:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40fbb4:	91316c00 	add	x0, x0, #0xc5b
  40fbb8:	97ffdfb0 	bl	407a78 <assert_print>
  40fbbc:	aa1303e0 	mov	x0, x19
  40fbc0:	52801861 	mov	w1, #0xc3                  	// #195
  40fbc4:	97ffdfd7 	bl	407b20 <assert_post_action>
  40fbc8:	52801862 	mov	w2, #0xc3                  	// #195
  40fbcc:	17ffff99 	b	40fa30 <work_queue_main+0x88>
	*flagp &= ~BIT(bit);
  40fbd0:	121e7400 	and	w0, w0, #0xfffffffc
  40fbd4:	b9001a80 	str	w0, [x20, #24]
	return list->head;
  40fbd8:	f9465f00 	ldr	x0, [x24, #3256]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  40fbdc:	b4fffc60 	cbz	x0, 40fb68 <work_queue_main+0x1c0>
	return node->next;
  40fbe0:	f940001a 	ldr	x26, [x0]
  40fbe4:	d2800019 	mov	x25, #0x0                   	// #0
		if (wc->work == work) {
  40fbe8:	f9400402 	ldr	x2, [x0, #8]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
  40fbec:	aa0003e1 	mov	x1, x0
		if (wc->work == work) {
  40fbf0:	eb02029f 	cmp	x20, x2
  40fbf4:	54000161 	b.ne	40fc20 <work_queue_main+0x278>  // b.any
  40fbf8:	f9400001 	ldr	x1, [x0]
Z_GENLIST_REMOVE(slist, snode)
  40fbfc:	b50001d9 	cbnz	x25, 40fc34 <work_queue_main+0x28c>
  40fc00:	f94006c2 	ldr	x2, [x22, #8]
	list->head = node;
  40fc04:	f90002c1 	str	x1, [x22]
Z_GENLIST_REMOVE(slist, snode)
  40fc08:	eb00005f 	cmp	x2, x0
  40fc0c:	54000041 	b.ne	40fc14 <work_queue_main+0x26c>  // b.any
	list->tail = node;
  40fc10:	f90006c1 	str	x1, [x22, #8]
	parent->next = child;
  40fc14:	f801041f 	str	xzr, [x0], #16
	z_impl_k_sem_give(sem);
  40fc18:	97fffe78 	bl	40f5f8 <z_impl_k_sem_give>
}
  40fc1c:	aa1903e1 	mov	x1, x25
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  40fc20:	b4fffa5a 	cbz	x26, 40fb68 <work_queue_main+0x1c0>
	return node->next;
  40fc24:	aa1a03e0 	mov	x0, x26
  40fc28:	aa0103f9 	mov	x25, x1
  40fc2c:	f940035a 	ldr	x26, [x26]
  40fc30:	17ffffee 	b	40fbe8 <work_queue_main+0x240>
	parent->next = child;
  40fc34:	f9000321 	str	x1, [x25]
Z_GENLIST_REMOVE(slist, snode)
  40fc38:	f94006c1 	ldr	x1, [x22, #8]
  40fc3c:	eb00003f 	cmp	x1, x0
  40fc40:	54fffea1 	b.ne	40fc14 <work_queue_main+0x26c>  // b.any
	list->tail = node;
  40fc44:	f90006d9 	str	x25, [x22, #8]
}
  40fc48:	17fffff3 	b	40fc14 <work_queue_main+0x26c>
	posix_irq_unlock(key);
  40fc4c:	2a1703e0 	mov	w0, w23
  40fc50:	97ffe892 	bl	409e98 <posix_irq_unlock>
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
  40fc54:	35ffebf4 	cbnz	w20, 40f9d0 <work_queue_main+0x28>
	z_impl_k_yield();
  40fc58:	94000800 	bl	411c58 <z_impl_k_yield>
}
  40fc5c:	17ffff5d 	b	40f9d0 <work_queue_main+0x28>

000000000040fc60 <submit_to_queue_locked>:
{
  40fc60:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40fc64:	910003fd 	mov	x29, sp
  40fc68:	a90153f3 	stp	x19, x20, [sp, #16]
  40fc6c:	aa0003f3 	mov	x19, x0
  40fc70:	aa0103f4 	mov	x20, x1
  40fc74:	a9025bf5 	stp	x21, x22, [sp, #32]
	return (*flagp & BIT(bit)) != 0U;
  40fc78:	b9401800 	ldr	w0, [x0, #24]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  40fc7c:	721f001f 	tst	w0, #0x2
  40fc80:	54000941 	b.ne	40fda8 <submit_to_queue_locked+0x148>  // b.any
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
  40fc84:	721e001f 	tst	w0, #0x4
  40fc88:	54000961 	b.ne	40fdb4 <submit_to_queue_locked+0x154>  // b.any
		if (*queuep == NULL) {
  40fc8c:	f9400020 	ldr	x0, [x1]
  40fc90:	b5000060 	cbnz	x0, 40fc9c <submit_to_queue_locked+0x3c>
			*queuep = work->queue;
  40fc94:	f9400a60 	ldr	x0, [x19, #16]
  40fc98:	f9000020 	str	x0, [x1]
	return (*flagp & BIT(bit)) != 0U;
  40fc9c:	b9401a60 	ldr	w0, [x19, #24]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
  40fca0:	36000760 	tbz	w0, #0, 40fd8c <submit_to_queue_locked+0x12c>
			__ASSERT_NO_MSG(work->queue != NULL);
  40fca4:	f9400a60 	ldr	x0, [x19, #16]
  40fca8:	b5000240 	cbnz	x0, 40fcf0 <submit_to_queue_locked+0x90>
  40fcac:	f0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  40fcb0:	910c8e73 	add	x19, x19, #0x323
  40fcb4:	aa1303e2 	mov	x2, x19
  40fcb8:	528029c3 	mov	w3, #0x14e                 	// #334
  40fcbc:	f0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  40fcc0:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fcc4:	910d6c21 	add	x1, x1, #0x35b
  40fcc8:	911a8800 	add	x0, x0, #0x6a2
  40fccc:	97ffdf6b 	bl	407a78 <assert_print>
  40fcd0:	aa1303e0 	mov	x0, x19
  40fcd4:	528029c1 	mov	w1, #0x14e                 	// #334
  40fcd8:	97ffdf92 	bl	407b20 <assert_post_action>
  40fcdc:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fce0:	aa1303e1 	mov	x1, x19
  40fce4:	911b8000 	add	x0, x0, #0x6e0
  40fce8:	528029c2 	mov	w2, #0x14e                 	// #334
  40fcec:	97ffe97f 	bl	40a2e8 <posix_print_error_and_exit>
			ret = 2;
  40fcf0:	52800056 	mov	w22, #0x2                   	// #2
			*queuep = work->queue;
  40fcf4:	f9000280 	str	x0, [x20]
		int rc = queue_submit_locked(*queuep, work);
  40fcf8:	f9400295 	ldr	x21, [x20]
	if (queue == NULL) {
  40fcfc:	b4000615 	cbz	x21, 40fdbc <submit_to_queue_locked+0x15c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40fd00:	900000e0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  40fd04:	f9472c00 	ldr	x0, [x0, #3672]
  40fd08:	f9400800 	ldr	x0, [x0, #16]
  40fd0c:	eb15001f 	cmp	x0, x21
  40fd10:	54000421 	b.ne	40fd94 <submit_to_queue_locked+0x134>  // b.any
  40fd14:	97fff910 	bl	40e154 <k_is_in_isr>
  40fd18:	12001c00 	and	w0, w0, #0xff
  40fd1c:	52000000 	eor	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  40fd20:	b940f2a2 	ldr	w2, [x21, #240]
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40fd24:	12000000 	and	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  40fd28:	d3420841 	ubfx	x1, x2, #2, #1
  40fd2c:	d3430c43 	ubfx	x3, x2, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
  40fd30:	360004a2 	tbz	w2, #0, 40fdc4 <submit_to_queue_locked+0x164>
	} else if (draining && !chained) {
  40fd34:	52000000 	eor	w0, w0, #0x1
  40fd38:	6a00003f 	tst	w1, w0
  40fd3c:	54000361 	b.ne	40fda8 <submit_to_queue_locked+0x148>  // b.any
	} else if (plugged && !draining) {
  40fd40:	52000021 	eor	w1, w1, #0x1
  40fd44:	6a01007f 	tst	w3, w1
  40fd48:	54000301 	b.ne	40fda8 <submit_to_queue_locked+0x148>  // b.any
	parent->next = child;
  40fd4c:	f900027f 	str	xzr, [x19]
	return list->tail;
  40fd50:	f94066a0 	ldr	x0, [x21, #200]
Z_GENLIST_APPEND(slist, snode)
  40fd54:	b5000240 	cbnz	x0, 40fd9c <submit_to_queue_locked+0x13c>
	list->tail = node;
  40fd58:	a90c4eb3 	stp	x19, x19, [x21, #192]
		(void)notify_queue_locked(queue);
  40fd5c:	aa1503e0 	mov	x0, x21
  40fd60:	97ffff0c 	bl	40f990 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
  40fd64:	b9401a60 	ldr	w0, [x19, #24]
  40fd68:	321e0000 	orr	w0, w0, #0x4
  40fd6c:	b9001a60 	str	w0, [x19, #24]
			work->queue = *queuep;
  40fd70:	f9400280 	ldr	x0, [x20]
  40fd74:	f9000a60 	str	x0, [x19, #16]
}
  40fd78:	2a1603e0 	mov	w0, w22
  40fd7c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fd80:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fd84:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40fd88:	d65f03c0 	ret
		ret = 1;
  40fd8c:	52800036 	mov	w22, #0x1                   	// #1
  40fd90:	17ffffda 	b	40fcf8 <submit_to_queue_locked+0x98>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  40fd94:	52800000 	mov	w0, #0x0                   	// #0
  40fd98:	17ffffe2 	b	40fd20 <submit_to_queue_locked+0xc0>
	parent->next = child;
  40fd9c:	f9000013 	str	x19, [x0]
	list->tail = node;
  40fda0:	f90066b3 	str	x19, [x21, #200]
}
  40fda4:	17ffffee 	b	40fd5c <submit_to_queue_locked+0xfc>
		ret = -EBUSY;
  40fda8:	128001f6 	mov	w22, #0xfffffff0            	// #-16
		*queuep = NULL;
  40fdac:	f900029f 	str	xzr, [x20]
	return ret;
  40fdb0:	17fffff2 	b	40fd78 <submit_to_queue_locked+0x118>
	int ret = 0;
  40fdb4:	52800016 	mov	w22, #0x0                   	// #0
  40fdb8:	17fffffd 	b	40fdac <submit_to_queue_locked+0x14c>
		return -EINVAL;
  40fdbc:	128002b6 	mov	w22, #0xffffffea            	// #-22
  40fdc0:	17fffffb 	b	40fdac <submit_to_queue_locked+0x14c>
		ret = -ENODEV;
  40fdc4:	12800256 	mov	w22, #0xffffffed            	// #-19
  40fdc8:	17fffff9 	b	40fdac <submit_to_queue_locked+0x14c>

000000000040fdcc <k_work_init>:
{
  40fdcc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40fdd0:	910003fd 	mov	x29, sp
  40fdd4:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(work != NULL);
  40fdd8:	b5000240 	cbnz	x0, 40fe20 <k_work_init+0x54>
  40fddc:	f0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  40fde0:	910c8e73 	add	x19, x19, #0x323
  40fde4:	aa1303e2 	mov	x2, x19
  40fde8:	52801123 	mov	w3, #0x89                  	// #137
  40fdec:	f0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  40fdf0:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fdf4:	910dd821 	add	x1, x1, #0x376
  40fdf8:	911a8800 	add	x0, x0, #0x6a2
  40fdfc:	97ffdf1f 	bl	407a78 <assert_print>
  40fe00:	aa1303e0 	mov	x0, x19
  40fe04:	52801121 	mov	w1, #0x89                  	// #137
  40fe08:	97ffdf46 	bl	407b20 <assert_post_action>
  40fe0c:	52801122 	mov	w2, #0x89                  	// #137
	__ASSERT_NO_MSG(handler != NULL);
  40fe10:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fe14:	aa1303e1 	mov	x1, x19
  40fe18:	911b8000 	add	x0, x0, #0x6e0
  40fe1c:	97ffe933 	bl	40a2e8 <posix_print_error_and_exit>
  40fe20:	b50001e1 	cbnz	x1, 40fe5c <k_work_init+0x90>
  40fe24:	f0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  40fe28:	910c8e73 	add	x19, x19, #0x323
  40fe2c:	aa1303e2 	mov	x2, x19
  40fe30:	52801143 	mov	w3, #0x8a                  	// #138
  40fe34:	f0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  40fe38:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fe3c:	910d1021 	add	x1, x1, #0x344
  40fe40:	911a8800 	add	x0, x0, #0x6a2
  40fe44:	97ffdf0d 	bl	407a78 <assert_print>
  40fe48:	aa1303e0 	mov	x0, x19
  40fe4c:	52801141 	mov	w1, #0x8a                  	// #138
  40fe50:	97ffdf34 	bl	407b20 <assert_post_action>
  40fe54:	52801142 	mov	w2, #0x8a                  	// #138
  40fe58:	17ffffee 	b	40fe10 <k_work_init+0x44>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  40fe5c:	a9007c1f 	stp	xzr, xzr, [x0]
  40fe60:	f9000401 	str	x1, [x0, #8]
  40fe64:	a9017c1f 	stp	xzr, xzr, [x0, #16]
}
  40fe68:	f9400bf3 	ldr	x19, [sp, #16]
  40fe6c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40fe70:	d65f03c0 	ret

000000000040fe74 <z_work_submit_to_queue>:
{
  40fe74:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40fe78:	910003fd 	mov	x29, sp
  40fe7c:	a90153f3 	stp	x19, x20, [sp, #16]
  40fe80:	f90013f5 	str	x21, [sp, #32]
  40fe84:	f9001fe0 	str	x0, [sp, #56]
	__ASSERT_NO_MSG(work != NULL);
  40fe88:	b5000241 	cbnz	x1, 40fed0 <z_work_submit_to_queue+0x5c>
  40fe8c:	f0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  40fe90:	910c8e73 	add	x19, x19, #0x323
  40fe94:	aa1303e2 	mov	x2, x19
  40fe98:	52802e83 	mov	w3, #0x174                 	// #372
  40fe9c:	f0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  40fea0:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fea4:	910dd821 	add	x1, x1, #0x376
  40fea8:	911a8800 	add	x0, x0, #0x6a2
  40feac:	97ffdef3 	bl	407a78 <assert_print>
  40feb0:	52802e81 	mov	w1, #0x174                 	// #372
  40feb4:	aa1303e0 	mov	x0, x19
  40feb8:	97ffdf1a 	bl	407b20 <assert_post_action>
  40febc:	aa1303e1 	mov	x1, x19
  40fec0:	52802e82 	mov	w2, #0x174                 	// #372
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fec4:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40fec8:	911b8000 	add	x0, x0, #0x6e0
  40fecc:	97ffe907 	bl	40a2e8 <posix_print_error_and_exit>
  40fed0:	aa0103f4 	mov	x20, x1
  40fed4:	d00000f3 	adrp	x19, 42d000 <counter_value>
	return posix_irq_lock();
  40fed8:	97ffe7ee 	bl	409e90 <posix_irq_lock>
  40fedc:	9132c273 	add	x19, x19, #0xcb0
  40fee0:	2a0003f5 	mov	w21, w0
  40fee4:	aa1303e0 	mov	x0, x19
  40fee8:	97fff9a8 	bl	40e588 <z_spin_lock_valid>
  40feec:	72001c1f 	tst	w0, #0xff
  40fef0:	54000281 	b.ne	40ff40 <z_work_submit_to_queue+0xcc>  // b.any
  40fef4:	d0000034 	adrp	x20, 415000 <random_data+0xd8c>
  40fef8:	912faa94 	add	x20, x20, #0xbea
  40fefc:	aa1403e2 	mov	x2, x20
  40ff00:	52801283 	mov	w3, #0x94                  	// #148
  40ff04:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40ff08:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ff0c:	91305c21 	add	x1, x1, #0xc17
  40ff10:	911a8800 	add	x0, x0, #0x6a2
  40ff14:	97ffded9 	bl	407a78 <assert_print>
  40ff18:	aa1303e1 	mov	x1, x19
  40ff1c:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40ff20:	9130b000 	add	x0, x0, #0xc2c
  40ff24:	97ffded5 	bl	407a78 <assert_print>
  40ff28:	aa1403e0 	mov	x0, x20
  40ff2c:	52801281 	mov	w1, #0x94                  	// #148
  40ff30:	97ffdefc 	bl	407b20 <assert_post_action>
  40ff34:	52801282 	mov	w2, #0x94                  	// #148
  40ff38:	aa1403e1 	mov	x1, x20
  40ff3c:	17ffffe2 	b	40fec4 <z_work_submit_to_queue+0x50>
	z_spin_lock_set_owner(l);
  40ff40:	aa1303e0 	mov	x0, x19
  40ff44:	97fff9a9 	bl	40e5e8 <z_spin_lock_set_owner>
	int ret = submit_to_queue_locked(work, &queue);
  40ff48:	9100e3e1 	add	x1, sp, #0x38
  40ff4c:	aa1403e0 	mov	x0, x20
  40ff50:	97ffff44 	bl	40fc60 <submit_to_queue_locked>
  40ff54:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40ff58:	aa1303e0 	mov	x0, x19
  40ff5c:	97fff996 	bl	40e5b4 <z_spin_unlock_valid>
  40ff60:	72001c1f 	tst	w0, #0xff
  40ff64:	54000261 	b.ne	40ffb0 <z_work_submit_to_queue+0x13c>  // b.any
  40ff68:	d0000034 	adrp	x20, 415000 <random_data+0xd8c>
  40ff6c:	912faa94 	add	x20, x20, #0xbea
  40ff70:	aa1403e2 	mov	x2, x20
  40ff74:	52801863 	mov	w3, #0xc3                  	// #195
  40ff78:	d0000021 	adrp	x1, 415000 <random_data+0xd8c>
  40ff7c:	b0000020 	adrp	x0, 414000 <__func__.1+0xd>
  40ff80:	91311021 	add	x1, x1, #0xc44
  40ff84:	911a8800 	add	x0, x0, #0x6a2
  40ff88:	97ffdebc 	bl	407a78 <assert_print>
  40ff8c:	aa1303e1 	mov	x1, x19
  40ff90:	d0000020 	adrp	x0, 415000 <random_data+0xd8c>
  40ff94:	91316c00 	add	x0, x0, #0xc5b
  40ff98:	97ffdeb8 	bl	407a78 <assert_print>
  40ff9c:	aa1403e0 	mov	x0, x20
  40ffa0:	52801861 	mov	w1, #0xc3                  	// #195
  40ffa4:	97ffdedf 	bl	407b20 <assert_post_action>
  40ffa8:	52801862 	mov	w2, #0xc3                  	// #195
  40ffac:	17ffffe3 	b	40ff38 <z_work_submit_to_queue+0xc4>
	posix_irq_unlock(key);
  40ffb0:	2a1503e0 	mov	w0, w21
  40ffb4:	97ffe7b9 	bl	409e98 <posix_irq_unlock>
}
  40ffb8:	2a1403e0 	mov	w0, w20
  40ffbc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ffc0:	f94013f5 	ldr	x21, [sp, #32]
  40ffc4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40ffc8:	d65f03c0 	ret

000000000040ffcc <k_work_submit_to_queue>:
{
  40ffcc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40ffd0:	910003fd 	mov	x29, sp
  40ffd4:	f9000bf3 	str	x19, [sp, #16]
	int ret = z_work_submit_to_queue(queue, work);
  40ffd8:	97ffffa7 	bl	40fe74 <z_work_submit_to_queue>
  40ffdc:	2a0003f3 	mov	w19, w0
	if (ret > 0) {
  40ffe0:	7100001f 	cmp	w0, #0x0
  40ffe4:	5400006d 	b.le	40fff0 <k_work_submit_to_queue+0x24>
	return posix_irq_lock();
  40ffe8:	97ffe7aa 	bl	409e90 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
  40ffec:	94000150 	bl	41052c <z_reschedule_irqlock>
}
  40fff0:	2a1303e0 	mov	w0, w19
  40fff4:	f9400bf3 	ldr	x19, [sp, #16]
  40fff8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40fffc:	d65f03c0 	ret

0000000000410000 <k_work_submit>:
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
  410000:	aa0003e1 	mov	x1, x0
  410004:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  410008:	f947f400 	ldr	x0, [x0, #4072]
  41000c:	17fffff0 	b	40ffcc <k_work_submit_to_queue>

0000000000410010 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
  410010:	d100c3ff 	sub	sp, sp, #0x30
  410014:	a9017bfd 	stp	x29, x30, [sp, #16]
  410018:	910043fd 	add	x29, sp, #0x10
  41001c:	a90253f3 	stp	x19, x20, [sp, #32]
	__ASSERT_NO_MSG(queue);
  410020:	b5000240 	cbnz	x0, 410068 <k_work_queue_start+0x58>
  410024:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  410028:	910c8e73 	add	x19, x19, #0x323
  41002c:	aa1303e2 	mov	x2, x19
  410030:	52805903 	mov	w3, #0x2c8                 	// #712
  410034:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  410038:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  41003c:	910e2821 	add	x1, x1, #0x38a
  410040:	911a8800 	add	x0, x0, #0x6a2
  410044:	97ffde8d 	bl	407a78 <assert_print>
  410048:	aa1303e0 	mov	x0, x19
  41004c:	52805901 	mov	w1, #0x2c8                 	// #712
  410050:	97ffdeb4 	bl	407b20 <assert_post_action>
  410054:	52805902 	mov	w2, #0x2c8                 	// #712
	__ASSERT_NO_MSG(stack);
  410058:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  41005c:	aa1303e1 	mov	x1, x19
  410060:	911b8000 	add	x0, x0, #0x6e0
  410064:	97ffe8a1 	bl	40a2e8 <posix_print_error_and_exit>
  410068:	b50001e1 	cbnz	x1, 4100a4 <k_work_queue_start+0x94>
  41006c:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  410070:	910c8e73 	add	x19, x19, #0x323
  410074:	aa1303e2 	mov	x2, x19
  410078:	52805923 	mov	w3, #0x2c9                 	// #713
  41007c:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  410080:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410084:	910e4021 	add	x1, x1, #0x390
  410088:	911a8800 	add	x0, x0, #0x6a2
  41008c:	97ffde7b 	bl	407a78 <assert_print>
  410090:	aa1303e0 	mov	x0, x19
  410094:	52805921 	mov	w1, #0x2c9                 	// #713
  410098:	97ffdea2 	bl	407b20 <assert_post_action>
  41009c:	52805922 	mov	w2, #0x2c9                 	// #713
  4100a0:	17ffffee 	b	410058 <k_work_queue_start+0x48>
  4100a4:	aa0003f3 	mov	x19, x0
	return (*flagp & BIT(bit)) != 0U;
  4100a8:	b940f000 	ldr	w0, [x0, #240]
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
  4100ac:	360001e0 	tbz	w0, #0, 4100e8 <k_work_queue_start+0xd8>
  4100b0:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  4100b4:	910c8e73 	add	x19, x19, #0x323
  4100b8:	aa1303e2 	mov	x2, x19
  4100bc:	52805943 	mov	w3, #0x2ca                 	// #714
  4100c0:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  4100c4:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4100c8:	910e5821 	add	x1, x1, #0x396
  4100cc:	911a8800 	add	x0, x0, #0x6a2
  4100d0:	97ffde6a 	bl	407a78 <assert_print>
  4100d4:	aa1303e0 	mov	x0, x19
  4100d8:	52805941 	mov	w1, #0x2ca                 	// #714
  4100dc:	97ffde91 	bl	407b20 <assert_post_action>
  4100e0:	52805942 	mov	w2, #0x2ca                 	// #714
  4100e4:	17ffffdd 	b	410058 <k_work_queue_start+0x48>
  4100e8:	91034260 	add	x0, x19, #0xd0
	list->tail = NULL;
  4100ec:	a90c7e7f 	stp	xzr, xzr, [x19, #192]
  4100f0:	2a0303e7 	mov	w7, w3
  4100f4:	a90d0260 	stp	x0, x0, [x19, #208]
  4100f8:	91038260 	add	x0, x19, #0xe0
  4100fc:	aa0403f4 	mov	x20, x4
  410100:	a90e0260 	stp	x0, x0, [x19, #224]

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
  410104:	b4000344 	cbz	x4, 41016c <k_work_queue_start+0x15c>
  410108:	39402080 	ldrb	w0, [x4, #8]
		flags |= K_WORK_QUEUE_NO_YIELD;
  41010c:	7100001f 	cmp	w0, #0x0
  410110:	52802020 	mov	w0, #0x101                 	// #257
  410114:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
	*flagp = flags;
  410118:	b900f260 	str	w0, [x19, #240]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  41011c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  410120:	b90003ff 	str	wzr, [sp]
  410124:	f90007e0 	str	x0, [sp, #8]
  410128:	f0ffffe3 	adrp	x3, 40f000 <z_impl_k_mutex_unlock+0xc>
  41012c:	aa1303e4 	mov	x4, x19
  410130:	9126a063 	add	x3, x3, #0x9a8
  410134:	aa1303e0 	mov	x0, x19
  410138:	d2800006 	mov	x6, #0x0                   	// #0
  41013c:	d2800005 	mov	x5, #0x0                   	// #0
  410140:	97fff880 	bl	40e340 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
  410144:	b40000b4 	cbz	x20, 410158 <k_work_queue_start+0x148>
  410148:	f9400281 	ldr	x1, [x20]
  41014c:	b4000061 	cbz	x1, 410158 <k_work_queue_start+0x148>
	return z_impl_k_thread_name_set(thread, str);
  410150:	aa1303e0 	mov	x0, x19
  410154:	97fff806 	bl	40e16c <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
  410158:	aa1303e0 	mov	x0, x19
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
  41015c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  410160:	a94253f3 	ldp	x19, x20, [sp, #32]
  410164:	9100c3ff 	add	sp, sp, #0x30
  410168:	17fff814 	b	40e1b8 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
  41016c:	52800020 	mov	w0, #0x1                   	// #1
  410170:	17ffffea 	b	410118 <k_work_queue_start+0x108>

0000000000410174 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
  410174:	79403401 	ldrh	w1, [x0, #26]
  410178:	7101fc3f 	cmp	w1, #0x7f
  41017c:	54000248 	b.hi	4101c4 <sliceable+0x50>  // b.pmore
	int ret = slice_ticks;
  410180:	b00000e1 	adrp	x1, 42d000 <counter_value>
  410184:	b94f5021 	ldr	w1, [x1, #3920]
		&& slice_time(thread) != 0
  410188:	340001a1 	cbz	w1, 4101bc <sliceable+0x48>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
  41018c:	b00000e1 	adrp	x1, 42d000 <counter_value>
  410190:	39c06802 	ldrsb	w2, [x0, #26]
  410194:	b94f4c21 	ldr	w1, [x1, #3916]
  410198:	6b01005f 	cmp	w2, w1
  41019c:	5400014b 	b.lt	4101c4 <sliceable+0x50>  // b.tstop
		&& !z_is_thread_prevented_from_running(thread)
  4101a0:	39406401 	ldrb	w1, [x0, #25]
  4101a4:	f240103f 	tst	x1, #0x1f
  4101a8:	540000e1 	b.ne	4101c4 <sliceable+0x50>  // b.any
		&& !z_is_idle_thread_object(thread);
  4101ac:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4101b0:	f946fc21 	ldr	x1, [x1, #3576]
  4101b4:	eb01001f 	cmp	x0, x1
  4101b8:	1a9f07e1 	cset	w1, ne  // ne = any
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
  4101bc:	12000020 	and	w0, w1, #0x1
  4101c0:	d65f03c0 	ret
		&& !z_is_idle_thread_object(thread);
  4101c4:	52800001 	mov	w1, #0x0                   	// #0
  4101c8:	17fffffd 	b	4101bc <sliceable+0x48>

00000000004101cc <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  4101cc:	b4000160 	cbz	x0, 4101f8 <slice_timeout+0x2c>
  4101d0:	b00000e1 	adrp	x1, 42d000 <counter_value>
  4101d4:	91334021 	add	x1, x1, #0xcd0
  4101d8:	eb01001f 	cmp	x0, x1
  4101dc:	540000e3 	b.cc	4101f8 <slice_timeout+0x2c>  // b.lo, b.ul, b.last
  4101e0:	91008022 	add	x2, x1, #0x20
  4101e4:	eb02001f 	cmp	x0, x2
  4101e8:	54000082 	b.cs	4101f8 <slice_timeout+0x2c>  // b.hs, b.nlast
  4101ec:	cb010000 	sub	x0, x0, x1
  4101f0:	f240101f 	tst	x0, #0x1f
  4101f4:	540002a0 	b.eq	410248 <slice_timeout+0x7c>  // b.none
{
  4101f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  4101fc:	528038e3 	mov	w3, #0x1c7                 	// #455
  410200:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
{
  410204:	910003fd 	mov	x29, sp
  410208:	f9000bf3 	str	x19, [sp, #16]
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  41020c:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  410210:	910f2a73 	add	x19, x19, #0x3ca
  410214:	910fb021 	add	x1, x1, #0x3ec
  410218:	aa1303e2 	mov	x2, x19
  41021c:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410220:	911a8800 	add	x0, x0, #0x6a2
  410224:	97ffde15 	bl	407a78 <assert_print>
  410228:	aa1303e0 	mov	x0, x19
  41022c:	528038e1 	mov	w1, #0x1c7                 	// #455
  410230:	97ffde3c 	bl	407b20 <assert_post_action>
  410234:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410238:	aa1303e1 	mov	x1, x19
  41023c:	911b8000 	add	x0, x0, #0x6e0
  410240:	528038e2 	mov	w2, #0x1c7                 	// #455
  410244:	97ffe829 	bl	40a2e8 <posix_print_error_and_exit>

	slice_expired[cpu] = true;
  410248:	93459000 	sbfx	x0, x0, #5, #32
  41024c:	d00000e1 	adrp	x1, 42e000 <des_frames+0x27>
  410250:	91102821 	add	x1, x1, #0x40a
  410254:	52800022 	mov	w2, #0x1                   	// #1
  410258:	38206822 	strb	w2, [x1, x0]
  41025c:	d65f03c0 	ret

0000000000410260 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
  410260:	39c06802 	ldrsb	w2, [x0, #26]
	int32_t b2 = thread_2->base.prio;
  410264:	39c06821 	ldrsb	w1, [x1, #26]
		return b2 - b1;
  410268:	4b020020 	sub	w0, w1, w2
  41026c:	6b01005f 	cmp	w2, w1
}
  410270:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  410274:	d65f03c0 	ret

0000000000410278 <z_reset_time_slice>:
		flag_ipi();
	}
}

void z_reset_time_slice(struct k_thread *curr)
{
  410278:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int cpu = _current_cpu->id;
  41027c:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
{
  410280:	910003fd 	mov	x29, sp
	int cpu = _current_cpu->id;
  410284:	f9472c21 	ldr	x1, [x1, #3672]
{
  410288:	a90153f3 	stp	x19, x20, [sp, #16]
  41028c:	aa0003f4 	mov	x20, x0
  410290:	f90013f5 	str	x21, [sp, #32]

	z_abort_timeout(&slice_timeouts[cpu]);
  410294:	b00000e0 	adrp	x0, 42d000 <counter_value>
  410298:	91334000 	add	x0, x0, #0xcd0
  41029c:	39408033 	ldrb	w19, [x1, #32]
	int cpu = _current_cpu->id;
  4102a0:	39408035 	ldrb	w21, [x1, #32]
	z_abort_timeout(&slice_timeouts[cpu]);
  4102a4:	8b131413 	add	x19, x0, x19, lsl #5
  4102a8:	aa1303e0 	mov	x0, x19
  4102ac:	94000a17 	bl	412b08 <z_abort_timeout>
	slice_expired[cpu] = false;
  4102b0:	d00000e0 	adrp	x0, 42e000 <des_frames+0x27>
  4102b4:	91102800 	add	x0, x0, #0x40a
  4102b8:	3835c81f 	strb	wzr, [x0, w21, sxtw]
	if (sliceable(curr)) {
  4102bc:	aa1403e0 	mov	x0, x20
  4102c0:	97ffffad 	bl	410174 <sliceable>
  4102c4:	72001c1f 	tst	w0, #0xff
  4102c8:	54000180 	b.eq	4102f8 <z_reset_time_slice+0x80>  // b.none
	int ret = slice_ticks;
  4102cc:	b00000e0 	adrp	x0, 42d000 <counter_value>
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  4102d0:	90000001 	adrp	x1, 410000 <k_work_submit>
			      K_TICKS(slice_time(curr) - 1));
	}
}
  4102d4:	f94013f5 	ldr	x21, [sp, #32]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  4102d8:	91073021 	add	x1, x1, #0x1cc
			      K_TICKS(slice_time(curr) - 1));
  4102dc:	b94f5002 	ldr	w2, [x0, #3920]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  4102e0:	aa1303e0 	mov	x0, x19
}
  4102e4:	a94153f3 	ldp	x19, x20, [sp, #16]
			      K_TICKS(slice_time(curr) - 1));
  4102e8:	51000442 	sub	w2, w2, #0x1
}
  4102ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  4102f0:	93407c42 	sxtw	x2, w2
  4102f4:	14000973 	b	4128c0 <z_add_timeout>
}
  4102f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4102fc:	f94013f5 	ldr	x21, [sp, #32]
  410300:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410304:	d65f03c0 	ret

0000000000410308 <z_unpend_thread_no_timeout>:
	z_mark_thread_as_not_pending(thread);
	thread->base.pended_on = NULL;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
  410308:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  41030c:	910003fd 	mov	x29, sp
  410310:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410314:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  410318:	aa0003f4 	mov	x20, x0
  41031c:	a9025bf5 	stp	x21, x22, [sp, #32]
  410320:	97ffe6dc 	bl	409e90 <posix_irq_lock>
  410324:	2a0003f5 	mov	w21, w0
  410328:	f947ca76 	ldr	x22, [x19, #3984]
  41032c:	aa1603e0 	mov	x0, x22
  410330:	97fff896 	bl	40e588 <z_spin_lock_valid>
  410334:	72001c1f 	tst	w0, #0xff
  410338:	540002c1 	b.ne	410390 <z_unpend_thread_no_timeout+0x88>  // b.any
  41033c:	b0000033 	adrp	x19, 415000 <random_data+0xd8c>
  410340:	912faa73 	add	x19, x19, #0xbea
  410344:	aa1303e2 	mov	x2, x19
  410348:	52801283 	mov	w3, #0x94                  	// #148
  41034c:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410350:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410354:	91305c21 	add	x1, x1, #0xc17
  410358:	911a8800 	add	x0, x0, #0x6a2
  41035c:	97ffddc7 	bl	407a78 <assert_print>
  410360:	aa1603e1 	mov	x1, x22
  410364:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410368:	9130b000 	add	x0, x0, #0xc2c
  41036c:	97ffddc3 	bl	407a78 <assert_print>
  410370:	52801281 	mov	w1, #0x94                  	// #148
  410374:	aa1303e0 	mov	x0, x19
  410378:	97ffddea 	bl	407b20 <assert_post_action>
  41037c:	aa1303e1 	mov	x1, x19
  410380:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410384:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410388:	911b8000 	add	x0, x0, #0x6e0
  41038c:	97ffe7d7 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410390:	aa1603e0 	mov	x0, x22
  410394:	97fff895 	bl	40e5e8 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		if (thread->base.pended_on != NULL) {
  410398:	f9400a80 	ldr	x0, [x20, #16]
  41039c:	b4000060 	cbz	x0, 4103a8 <z_unpend_thread_no_timeout+0xa0>
			unpend_thread_no_timeout(thread);
  4103a0:	aa1403e0 	mov	x0, x20
  4103a4:	940000f5 	bl	410778 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4103a8:	f947ca73 	ldr	x19, [x19, #3984]
  4103ac:	aa1303e0 	mov	x0, x19
  4103b0:	97fff881 	bl	40e5b4 <z_spin_unlock_valid>
  4103b4:	72001c1f 	tst	w0, #0xff
  4103b8:	54000281 	b.ne	410408 <z_unpend_thread_no_timeout+0x100>  // b.any
  4103bc:	b0000034 	adrp	x20, 415000 <random_data+0xd8c>
  4103c0:	912faa94 	add	x20, x20, #0xbea
  4103c4:	aa1403e2 	mov	x2, x20
  4103c8:	52801863 	mov	w3, #0xc3                  	// #195
  4103cc:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  4103d0:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4103d4:	91311021 	add	x1, x1, #0xc44
  4103d8:	911a8800 	add	x0, x0, #0x6a2
  4103dc:	97ffdda7 	bl	407a78 <assert_print>
  4103e0:	aa1303e1 	mov	x1, x19
  4103e4:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  4103e8:	91316c00 	add	x0, x0, #0xc5b
  4103ec:	97ffdda3 	bl	407a78 <assert_print>
  4103f0:	52801861 	mov	w1, #0xc3                  	// #195
  4103f4:	aa1403e0 	mov	x0, x20
  4103f8:	97ffddca 	bl	407b20 <assert_post_action>
  4103fc:	aa1403e1 	mov	x1, x20
  410400:	52801862 	mov	w2, #0xc3                  	// #195
  410404:	17ffffe0 	b	410384 <z_unpend_thread_no_timeout+0x7c>
	posix_irq_unlock(key);
  410408:	2a1503e0 	mov	w0, w21
		}
	}
}
  41040c:	a94153f3 	ldp	x19, x20, [sp, #16]
  410410:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410414:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410418:	17ffe6a0 	b	409e98 <posix_irq_unlock>

000000000041041c <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
  41041c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return _kernel.cpus[0].nested != 0U;
  410420:	f00000c2 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
  410424:	910003fd 	mov	x29, sp
  410428:	f9472c42 	ldr	x2, [x2, #3672]
  41042c:	a90153f3 	stp	x19, x20, [sp, #16]
  410430:	2a0103f3 	mov	w19, w1
  410434:	aa0003f4 	mov	x20, x0
	if (resched(key.key) && need_swap()) {
  410438:	b9400041 	ldr	w1, [x2]
  41043c:	2a010261 	orr	w1, w19, w1
  410440:	35000421 	cbnz	w1, 4104c4 <z_reschedule+0xa8>
  410444:	f9400841 	ldr	x1, [x2, #16]
  410448:	f9401443 	ldr	x3, [x2, #40]
  41044c:	eb01007f 	cmp	x3, x1
  410450:	540003a0 	b.eq	4104c4 <z_reschedule+0xa8>  // b.none
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410454:	97fff858 	bl	40e5b4 <z_spin_unlock_valid>
  410458:	72001c1f 	tst	w0, #0xff
  41045c:	540002c1 	b.ne	4104b4 <z_reschedule+0x98>  // b.any
  410460:	b0000033 	adrp	x19, 415000 <random_data+0xd8c>
  410464:	912faa73 	add	x19, x19, #0xbea
  410468:	aa1303e2 	mov	x2, x19
  41046c:	52801c43 	mov	w3, #0xe2                  	// #226
  410470:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410474:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410478:	91311021 	add	x1, x1, #0xc44
  41047c:	911a8800 	add	x0, x0, #0x6a2
  410480:	97ffdd7e 	bl	407a78 <assert_print>
  410484:	aa1403e1 	mov	x1, x20
  410488:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  41048c:	91316c00 	add	x0, x0, #0xc5b
  410490:	97ffdd7a 	bl	407a78 <assert_print>
  410494:	aa1303e0 	mov	x0, x19
  410498:	52801c41 	mov	w1, #0xe2                  	// #226
  41049c:	97ffdda1 	bl	407b20 <assert_post_action>
  4104a0:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4104a4:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4104a8:	aa1303e1 	mov	x1, x19
  4104ac:	911b8000 	add	x0, x0, #0x6e0
  4104b0:	97ffe78e 	bl	40a2e8 <posix_print_error_and_exit>
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
  4104b4:	a94153f3 	ldp	x19, x20, [sp, #16]
	ret = arch_swap(key);
  4104b8:	52800000 	mov	w0, #0x0                   	// #0
  4104bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4104c0:	17ffe34a 	b	4091e8 <arch_swap>
  4104c4:	aa1403e0 	mov	x0, x20
  4104c8:	97fff83b 	bl	40e5b4 <z_spin_unlock_valid>
  4104cc:	72001c1f 	tst	w0, #0xff
  4104d0:	54000261 	b.ne	41051c <z_reschedule+0x100>  // b.any
  4104d4:	b0000033 	adrp	x19, 415000 <random_data+0xd8c>
  4104d8:	912faa73 	add	x19, x19, #0xbea
  4104dc:	aa1303e2 	mov	x2, x19
  4104e0:	52801863 	mov	w3, #0xc3                  	// #195
  4104e4:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  4104e8:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4104ec:	91311021 	add	x1, x1, #0xc44
  4104f0:	911a8800 	add	x0, x0, #0x6a2
  4104f4:	97ffdd61 	bl	407a78 <assert_print>
  4104f8:	aa1403e1 	mov	x1, x20
  4104fc:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410500:	91316c00 	add	x0, x0, #0xc5b
  410504:	97ffdd5d 	bl	407a78 <assert_print>
  410508:	aa1303e0 	mov	x0, x19
  41050c:	52801861 	mov	w1, #0xc3                  	// #195
  410510:	97ffdd84 	bl	407b20 <assert_post_action>
  410514:	52801862 	mov	w2, #0xc3                  	// #195
  410518:	17ffffe3 	b	4104a4 <z_reschedule+0x88>
  41051c:	2a1303e0 	mov	w0, w19
  410520:	a94153f3 	ldp	x19, x20, [sp, #16]
  410524:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410528:	17ffe65c 	b	409e98 <posix_irq_unlock>

000000000041052c <z_reschedule_irqlock>:
  41052c:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  410530:	f9472c21 	ldr	x1, [x1, #3672]

void z_reschedule_irqlock(uint32_t key)
{
	if (resched(key)) {
  410534:	b9400021 	ldr	w1, [x1]
  410538:	2a010001 	orr	w1, w0, w1
  41053c:	35000061 	cbnz	w1, 410548 <z_reschedule_irqlock+0x1c>
  410540:	52800000 	mov	w0, #0x0                   	// #0
  410544:	17ffe329 	b	4091e8 <arch_swap>
  410548:	17ffe654 	b	409e98 <posix_irq_unlock>

000000000041054c <z_reschedule_unlocked>:
{
  41054c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410550:	910003fd 	mov	x29, sp
	return posix_irq_lock();
  410554:	97ffe64f 	bl	409e90 <posix_irq_lock>
}
  410558:	a8c17bfd 	ldp	x29, x30, [sp], #16
	(void) z_reschedule_irqlock(arch_irq_lock());
  41055c:	17fffff4 	b	41052c <z_reschedule_irqlock>

0000000000410560 <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
  410560:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410564:	910003fd 	mov	x29, sp
  410568:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41056c:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  410570:	97ffe648 	bl	409e90 <posix_irq_lock>
  410574:	f947ca73 	ldr	x19, [x19, #3984]
  410578:	2a0003f4 	mov	w20, w0
  41057c:	aa1303e0 	mov	x0, x19
  410580:	97fff802 	bl	40e588 <z_spin_lock_valid>
  410584:	72001c1f 	tst	w0, #0xff
  410588:	54000281 	b.ne	4105d8 <k_sched_lock+0x78>  // b.any
  41058c:	b0000034 	adrp	x20, 415000 <random_data+0xd8c>
  410590:	912faa94 	add	x20, x20, #0xbea
  410594:	aa1403e2 	mov	x2, x20
  410598:	52801283 	mov	w3, #0x94                  	// #148
  41059c:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  4105a0:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4105a4:	91305c21 	add	x1, x1, #0xc17
  4105a8:	911a8800 	add	x0, x0, #0x6a2
  4105ac:	97ffdd33 	bl	407a78 <assert_print>
  4105b0:	aa1303e1 	mov	x1, x19
  4105b4:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  4105b8:	9130b000 	add	x0, x0, #0xc2c
  4105bc:	97ffdd2f 	bl	407a78 <assert_print>
  4105c0:	aa1403e0 	mov	x0, x20
  4105c4:	52801281 	mov	w1, #0x94                  	// #148
  4105c8:	97ffdd56 	bl	407b20 <assert_post_action>
  4105cc:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4105d0:	aa1403e1 	mov	x1, x20
  4105d4:	14000018 	b	410634 <k_sched_lock+0xd4>
	z_spin_lock_set_owner(l);
  4105d8:	aa1303e0 	mov	x0, x19
  4105dc:	97fff803 	bl	40e5e8 <z_spin_lock_set_owner>
  4105e0:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4105e4:	f9472c21 	ldr	x1, [x1, #3672]
	__ASSERT(!arch_is_in_isr(), "");
  4105e8:	b9400020 	ldr	w0, [x1]
  4105ec:	340002a0 	cbz	w0, 410640 <k_sched_lock+0xe0>
  4105f0:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  4105f4:	91161673 	add	x19, x19, #0x585
  4105f8:	aa1303e2 	mov	x2, x19
  4105fc:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  410600:	9104f021 	add	x1, x1, #0x13c
  410604:	52801fa3 	mov	w3, #0xfd                  	// #253
  410608:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  41060c:	911a8800 	add	x0, x0, #0x6a2
  410610:	97ffdd1a 	bl	407a78 <assert_print>
  410614:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410618:	91320400 	add	x0, x0, #0xc81
  41061c:	97ffdd17 	bl	407a78 <assert_print>
  410620:	aa1303e0 	mov	x0, x19
  410624:	52801fa1 	mov	w1, #0xfd                  	// #253
  410628:	97ffdd3e 	bl	407b20 <assert_post_action>
  41062c:	52801fa2 	mov	w2, #0xfd                  	// #253
  410630:	aa1303e1 	mov	x1, x19
  410634:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410638:	911b8000 	add	x0, x0, #0x6e0
  41063c:	97ffe72b 	bl	40a2e8 <posix_print_error_and_exit>
	__ASSERT(_current->base.sched_locked != 1U, "");
  410640:	f9400820 	ldr	x0, [x1, #16]
  410644:	39406c01 	ldrb	w1, [x0, #27]
  410648:	7100043f 	cmp	w1, #0x1
  41064c:	54000241 	b.ne	410694 <k_sched_lock+0x134>  // b.any
  410650:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  410654:	91161673 	add	x19, x19, #0x585
  410658:	aa1303e2 	mov	x2, x19
  41065c:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  410660:	9116c021 	add	x1, x1, #0x5b0
  410664:	52801fc3 	mov	w3, #0xfe                  	// #254
  410668:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  41066c:	911a8800 	add	x0, x0, #0x6a2
  410670:	97ffdd02 	bl	407a78 <assert_print>
  410674:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410678:	91320400 	add	x0, x0, #0xc81
  41067c:	97ffdcff 	bl	407a78 <assert_print>
  410680:	aa1303e0 	mov	x0, x19
  410684:	52801fc1 	mov	w1, #0xfe                  	// #254
  410688:	97ffdd26 	bl	407b20 <assert_post_action>
  41068c:	52801fc2 	mov	w2, #0xfe                  	// #254
  410690:	17ffffe8 	b	410630 <k_sched_lock+0xd0>
	--_current->base.sched_locked;
  410694:	51000421 	sub	w1, w1, #0x1
  410698:	39006c01 	strb	w1, [x0, #27]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41069c:	aa1303e0 	mov	x0, x19
  4106a0:	97fff7c5 	bl	40e5b4 <z_spin_unlock_valid>
  4106a4:	72001c1f 	tst	w0, #0xff
  4106a8:	54000261 	b.ne	4106f4 <k_sched_lock+0x194>  // b.any
  4106ac:	b0000034 	adrp	x20, 415000 <random_data+0xd8c>
  4106b0:	912faa94 	add	x20, x20, #0xbea
  4106b4:	aa1403e2 	mov	x2, x20
  4106b8:	52801863 	mov	w3, #0xc3                  	// #195
  4106bc:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  4106c0:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4106c4:	91311021 	add	x1, x1, #0xc44
  4106c8:	911a8800 	add	x0, x0, #0x6a2
  4106cc:	97ffdceb 	bl	407a78 <assert_print>
  4106d0:	aa1303e1 	mov	x1, x19
  4106d4:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  4106d8:	91316c00 	add	x0, x0, #0xc5b
  4106dc:	97ffdce7 	bl	407a78 <assert_print>
  4106e0:	aa1403e0 	mov	x0, x20
  4106e4:	52801861 	mov	w1, #0xc3                  	// #195
  4106e8:	97ffdd0e 	bl	407b20 <assert_post_action>
  4106ec:	52801862 	mov	w2, #0xc3                  	// #195
  4106f0:	17ffffb8 	b	4105d0 <k_sched_lock+0x70>
	posix_irq_unlock(key);
  4106f4:	2a1403e0 	mov	w0, w20
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
  4106f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4106fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410700:	17ffe5e6 	b	409e98 <posix_irq_unlock>

0000000000410704 <z_priq_dumb_remove>:
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410704:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  410708:	f946fc00 	ldr	x0, [x0, #3576]
  41070c:	eb00003f 	cmp	x1, x0
  410710:	540002a1 	b.ne	410764 <z_priq_dumb_remove+0x60>  // b.any
{
  410714:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410718:	52808f63 	mov	w3, #0x47b                 	// #1147
  41071c:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
{
  410720:	910003fd 	mov	x29, sp
  410724:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410728:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  41072c:	910f2a73 	add	x19, x19, #0x3ca
  410730:	91178421 	add	x1, x1, #0x5e1
  410734:	aa1303e2 	mov	x2, x19
  410738:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  41073c:	911a8800 	add	x0, x0, #0x6a2
  410740:	97ffdcce 	bl	407a78 <assert_print>
  410744:	aa1303e0 	mov	x0, x19
  410748:	52808f61 	mov	w1, #0x47b                 	// #1147
  41074c:	97ffdcf5 	bl	407b20 <assert_post_action>
  410750:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410754:	aa1303e1 	mov	x1, x19
  410758:	911b8000 	add	x0, x0, #0x6e0
  41075c:	52808f62 	mov	w2, #0x47b                 	// #1147
  410760:	97ffe6e2 	bl	40a2e8 <posix_print_error_and_exit>
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
  410764:	a9400820 	ldp	x0, x2, [x1]
	sys_dnode_t *const next = node->next;

	prev->next = next;
  410768:	f9000040 	str	x0, [x2]
	next->prev = prev;
  41076c:	f9000402 	str	x2, [x0, #8]
	node->prev = NULL;
  410770:	a9007c3f 	stp	xzr, xzr, [x1]
  410774:	d65f03c0 	ret

0000000000410778 <unpend_thread_no_timeout>:
{
  410778:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  41077c:	910003fd 	mov	x29, sp
  410780:	f9000bf3 	str	x19, [sp, #16]
  410784:	aa0003f3 	mov	x19, x0
  410788:	f9400800 	ldr	x0, [x0, #16]
	__ASSERT_NO_MSG(thread->base.pended_on);
  41078c:	b5000240 	cbnz	x0, 4107d4 <unpend_thread_no_timeout+0x5c>
  410790:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  410794:	910f2a73 	add	x19, x19, #0x3ca
  410798:	aa1303e2 	mov	x2, x19
  41079c:	528058a3 	mov	w3, #0x2c5                 	// #709
  4107a0:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  4107a4:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4107a8:	91180821 	add	x1, x1, #0x602
  4107ac:	911a8800 	add	x0, x0, #0x6a2
  4107b0:	97ffdcb2 	bl	407a78 <assert_print>
  4107b4:	aa1303e0 	mov	x0, x19
  4107b8:	528058a1 	mov	w1, #0x2c5                 	// #709
  4107bc:	97ffdcd9 	bl	407b20 <assert_post_action>
  4107c0:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4107c4:	aa1303e1 	mov	x1, x19
  4107c8:	911b8000 	add	x0, x0, #0x6e0
  4107cc:	528058a2 	mov	w2, #0x2c5                 	// #709
  4107d0:	97ffe6c6 	bl	40a2e8 <posix_print_error_and_exit>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
  4107d4:	aa1303e1 	mov	x1, x19
  4107d8:	97ffffcb 	bl	410704 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  4107dc:	39406660 	ldrb	w0, [x19, #25]
	thread->base.pended_on = NULL;
  4107e0:	f9000a7f 	str	xzr, [x19, #16]
  4107e4:	121e7800 	and	w0, w0, #0xfffffffd
  4107e8:	39006660 	strb	w0, [x19, #25]
}
  4107ec:	f9400bf3 	ldr	x19, [sp, #16]
  4107f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4107f4:	d65f03c0 	ret

00000000004107f8 <z_unpend_thread>:
{
  4107f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4107fc:	910003fd 	mov	x29, sp
  410800:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410804:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  410808:	aa0003f4 	mov	x20, x0
  41080c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  410810:	97ffe5a0 	bl	409e90 <posix_irq_lock>
  410814:	2a0003f5 	mov	w21, w0
  410818:	f947ca76 	ldr	x22, [x19, #3984]
  41081c:	aa1603e0 	mov	x0, x22
  410820:	97fff75a 	bl	40e588 <z_spin_lock_valid>
  410824:	72001c1f 	tst	w0, #0xff
  410828:	540002c1 	b.ne	410880 <z_unpend_thread+0x88>  // b.any
  41082c:	b0000033 	adrp	x19, 415000 <random_data+0xd8c>
  410830:	912faa73 	add	x19, x19, #0xbea
  410834:	aa1303e2 	mov	x2, x19
  410838:	52801283 	mov	w3, #0x94                  	// #148
  41083c:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410840:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410844:	91305c21 	add	x1, x1, #0xc17
  410848:	911a8800 	add	x0, x0, #0x6a2
  41084c:	97ffdc8b 	bl	407a78 <assert_print>
  410850:	aa1603e1 	mov	x1, x22
  410854:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410858:	9130b000 	add	x0, x0, #0xc2c
  41085c:	97ffdc87 	bl	407a78 <assert_print>
  410860:	52801281 	mov	w1, #0x94                  	// #148
  410864:	aa1303e0 	mov	x0, x19
  410868:	97ffdcae 	bl	407b20 <assert_post_action>
  41086c:	aa1303e1 	mov	x1, x19
  410870:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410874:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410878:	911b8000 	add	x0, x0, #0x6e0
  41087c:	97ffe69b 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410880:	aa1603e0 	mov	x0, x22
  410884:	97fff759 	bl	40e5e8 <z_spin_lock_set_owner>
		if (thread->base.pended_on != NULL) {
  410888:	f9400a80 	ldr	x0, [x20, #16]
  41088c:	b4000060 	cbz	x0, 410898 <z_unpend_thread+0xa0>
			unpend_thread_no_timeout(thread);
  410890:	aa1403e0 	mov	x0, x20
  410894:	97ffffb9 	bl	410778 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410898:	f947ca73 	ldr	x19, [x19, #3984]
  41089c:	aa1303e0 	mov	x0, x19
  4108a0:	97fff745 	bl	40e5b4 <z_spin_unlock_valid>
  4108a4:	72001c1f 	tst	w0, #0xff
  4108a8:	54000281 	b.ne	4108f8 <z_unpend_thread+0x100>  // b.any
  4108ac:	b0000034 	adrp	x20, 415000 <random_data+0xd8c>
  4108b0:	912faa94 	add	x20, x20, #0xbea
  4108b4:	aa1403e2 	mov	x2, x20
  4108b8:	52801863 	mov	w3, #0xc3                  	// #195
  4108bc:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  4108c0:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4108c4:	91311021 	add	x1, x1, #0xc44
  4108c8:	911a8800 	add	x0, x0, #0x6a2
  4108cc:	97ffdc6b 	bl	407a78 <assert_print>
  4108d0:	aa1303e1 	mov	x1, x19
  4108d4:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  4108d8:	91316c00 	add	x0, x0, #0xc5b
  4108dc:	97ffdc67 	bl	407a78 <assert_print>
  4108e0:	52801861 	mov	w1, #0xc3                  	// #195
  4108e4:	aa1403e0 	mov	x0, x20
  4108e8:	97ffdc8e 	bl	407b20 <assert_post_action>
  4108ec:	aa1403e1 	mov	x1, x20
  4108f0:	52801862 	mov	w2, #0xc3                  	// #195
  4108f4:	17ffffe0 	b	410874 <z_unpend_thread+0x7c>
	posix_irq_unlock(key);
  4108f8:	2a1503e0 	mov	w0, w21
  4108fc:	97ffe567 	bl	409e98 <posix_irq_unlock>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  410900:	9100a280 	add	x0, x20, #0x28
}
  410904:	a94153f3 	ldp	x19, x20, [sp, #16]
  410908:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41090c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410910:	1400087e 	b	412b08 <z_abort_timeout>

0000000000410914 <z_priq_dumb_best>:
	return list->head == list;
  410914:	f9400001 	ldr	x1, [x0]
	sys_dlist_remove(&thread->base.qnode_dlist);
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
  410918:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
  41091c:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
  410920:	d65f03c0 	ret

0000000000410924 <update_cache>:
{
  410924:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410928:	910003fd 	mov	x29, sp
  41092c:	a90153f3 	stp	x19, x20, [sp, #16]
	return _priq_run_best(curr_cpu_runq());
  410930:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
{
  410934:	a9025bf5 	stp	x21, x22, [sp, #32]
  410938:	2a0003f5 	mov	w21, w0
	return _priq_run_best(curr_cpu_runq());
  41093c:	f9472e76 	ldr	x22, [x19, #3672]
  410940:	9100c2c0 	add	x0, x22, #0x30
  410944:	97fffff4 	bl	410914 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
  410948:	b5000340 	cbnz	x0, 4109b0 <update_cache+0x8c>
  41094c:	f9400ed4 	ldr	x20, [x22, #24]
	__ASSERT(_current != NULL, "");
  410950:	f9472e60 	ldr	x0, [x19, #3672]
  410954:	f9400801 	ldr	x1, [x0, #16]
	if (preempt_ok != 0) {
  410958:	350003d5 	cbnz	w21, 4109d0 <update_cache+0xac>
	__ASSERT(_current != NULL, "");
  41095c:	b50002e1 	cbnz	x1, 4109b8 <update_cache+0x94>
  410960:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  410964:	910f2a73 	add	x19, x19, #0x3ca
  410968:	aa1303e2 	mov	x2, x19
  41096c:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  410970:	91186421 	add	x1, x1, #0x619
  410974:	52801143 	mov	w3, #0x8a                  	// #138
  410978:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  41097c:	911a8800 	add	x0, x0, #0x6a2
  410980:	97ffdc3e 	bl	407a78 <assert_print>
  410984:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410988:	91320400 	add	x0, x0, #0xc81
  41098c:	97ffdc3b 	bl	407a78 <assert_print>
  410990:	aa1303e0 	mov	x0, x19
  410994:	52801141 	mov	w1, #0x8a                  	// #138
  410998:	97ffdc62 	bl	407b20 <assert_post_action>
  41099c:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  4109a0:	aa1303e1 	mov	x1, x19
  4109a4:	911b8000 	add	x0, x0, #0x6e0
  4109a8:	52801142 	mov	w2, #0x8a                  	// #138
  4109ac:	97ffe64f 	bl	40a2e8 <posix_print_error_and_exit>
  4109b0:	aa0003f4 	mov	x20, x0
  4109b4:	17ffffe7 	b	410950 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
  4109b8:	39406420 	ldrb	w0, [x1, #25]
  4109bc:	f240101f 	tst	x0, #0x1f
  4109c0:	54000081 	b.ne	4109d0 <update_cache+0xac>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
  4109c4:	79403420 	ldrh	w0, [x1, #26]
  4109c8:	7101fc1f 	cmp	w0, #0x7f
  4109cc:	540000c8 	b.hi	4109e4 <update_cache+0xc0>  // b.pmore
		if (thread != _current) {
  4109d0:	eb01029f 	cmp	x20, x1
  4109d4:	54000060 	b.eq	4109e0 <update_cache+0xbc>  // b.none
			z_reset_time_slice(thread);
  4109d8:	aa1403e0 	mov	x0, x20
  4109dc:	97fffe27 	bl	410278 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
  4109e0:	aa1403e1 	mov	x1, x20
  4109e4:	f9472e73 	ldr	x19, [x19, #3672]
  4109e8:	f9001661 	str	x1, [x19, #40]
}
  4109ec:	a94153f3 	ldp	x19, x20, [sp, #16]
  4109f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4109f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4109f8:	d65f03c0 	ret

00000000004109fc <move_thread_to_end_of_prio_q>:
{
  4109fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410a00:	910003fd 	mov	x29, sp
  410a04:	a90153f3 	stp	x19, x20, [sp, #16]
  410a08:	aa0003f3 	mov	x19, x0
  410a0c:	a9025bf5 	stp	x21, x22, [sp, #32]
  410a10:	f00000d5 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
	if (z_is_thread_queued(thread)) {
  410a14:	39c06661 	ldrsb	w1, [x19, #25]
	return (thread->base.thread_state & state) != 0U;
  410a18:	39406400 	ldrb	w0, [x0, #25]
  410a1c:	36f800e1 	tbz	w1, #31, 410a38 <move_thread_to_end_of_prio_q+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  410a20:	12001800 	and	w0, w0, #0x7f
  410a24:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  410a28:	f9472ea0 	ldr	x0, [x21, #3672]
  410a2c:	aa1303e1 	mov	x1, x19
  410a30:	9100c000 	add	x0, x0, #0x30
  410a34:	97ffff34 	bl	410704 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  410a38:	39406660 	ldrb	w0, [x19, #25]
  410a3c:	32196000 	orr	w0, w0, #0xffffff80
  410a40:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410a44:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  410a48:	f946fc00 	ldr	x0, [x0, #3576]
  410a4c:	eb00027f 	cmp	x19, x0
  410a50:	54000241 	b.ne	410a98 <move_thread_to_end_of_prio_q+0x9c>  // b.any
  410a54:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  410a58:	910f2a73 	add	x19, x19, #0x3ca
  410a5c:	aa1303e2 	mov	x2, x19
  410a60:	52801783 	mov	w3, #0xbc                  	// #188
  410a64:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  410a68:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410a6c:	91178421 	add	x1, x1, #0x5e1
  410a70:	911a8800 	add	x0, x0, #0x6a2
  410a74:	97ffdc01 	bl	407a78 <assert_print>
  410a78:	aa1303e0 	mov	x0, x19
  410a7c:	52801781 	mov	w1, #0xbc                  	// #188
  410a80:	97ffdc28 	bl	407b20 <assert_post_action>
  410a84:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410a88:	aa1303e1 	mov	x1, x19
  410a8c:	911b8000 	add	x0, x0, #0x6e0
  410a90:	52801782 	mov	w2, #0xbc                  	// #188
  410a94:	97ffe615 	bl	40a2e8 <posix_print_error_and_exit>
  410a98:	f9472eb6 	ldr	x22, [x21, #3672]
  410a9c:	aa1603e0 	mov	x0, x22
  410aa0:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  410aa4:	eb00029f 	cmp	x20, x0
  410aa8:	54000261 	b.ne	410af4 <move_thread_to_end_of_prio_q+0xf8>  // b.any
	sys_dnode_t *const tail = list->tail;
  410aac:	f9472ea0 	ldr	x0, [x21, #3672]
	node->next = list;
  410ab0:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  410ab4:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  410ab8:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  410abc:	f9000033 	str	x19, [x1]
	list->tail = node;
  410ac0:	f9001c13 	str	x19, [x0, #56]
	update_cache(thread == _current);
  410ac4:	f9472eb5 	ldr	x21, [x21, #3672]
  410ac8:	f9400aa0 	ldr	x0, [x21, #16]
}
  410acc:	a9425bf5 	ldp	x21, x22, [sp, #32]
	update_cache(thread == _current);
  410ad0:	eb13001f 	cmp	x0, x19
}
  410ad4:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  410ad8:	1a9f17e0 	cset	w0, eq  // eq = none
}
  410adc:	a8c37bfd 	ldp	x29, x30, [sp], #48
	update_cache(thread == _current);
  410ae0:	17ffff91 	b	410924 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  410ae4:	f9401ec0 	ldr	x0, [x22, #56]
  410ae8:	eb14001f 	cmp	x0, x20
  410aec:	54fffe00 	b.eq	410aac <move_thread_to_end_of_prio_q+0xb0>  // b.none
  410af0:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  410af4:	b4fffdd4 	cbz	x20, 410aac <move_thread_to_end_of_prio_q+0xb0>
		if (z_sched_prio_cmp(thread, t) > 0) {
  410af8:	aa1403e1 	mov	x1, x20
  410afc:	aa1303e0 	mov	x0, x19
  410b00:	97fffdd8 	bl	410260 <z_sched_prio_cmp>
  410b04:	7100001f 	cmp	w0, #0x0
  410b08:	54fffeed 	b.le	410ae4 <move_thread_to_end_of_prio_q+0xe8>
	sys_dnode_t *const prev = successor->prev;
  410b0c:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  410b10:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  410b14:	f9000013 	str	x19, [x0]
	successor->prev = node;
  410b18:	f9000693 	str	x19, [x20, #8]
}
  410b1c:	17ffffea 	b	410ac4 <move_thread_to_end_of_prio_q+0xc8>

0000000000410b20 <z_time_slice>:
{
  410b20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410b24:	910003fd 	mov	x29, sp
  410b28:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410b2c:	f00000d4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  410b30:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  410b34:	97ffe4d7 	bl	409e90 <posix_irq_lock>
  410b38:	2a0003f6 	mov	w22, w0
  410b3c:	f947ca95 	ldr	x21, [x20, #3984]
  410b40:	aa1503e0 	mov	x0, x21
  410b44:	97fff691 	bl	40e588 <z_spin_lock_valid>
  410b48:	72001c1f 	tst	w0, #0xff
  410b4c:	540002c1 	b.ne	410ba4 <z_time_slice+0x84>  // b.any
  410b50:	b0000033 	adrp	x19, 415000 <random_data+0xd8c>
  410b54:	912faa73 	add	x19, x19, #0xbea
  410b58:	aa1303e2 	mov	x2, x19
  410b5c:	52801283 	mov	w3, #0x94                  	// #148
  410b60:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410b64:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410b68:	91305c21 	add	x1, x1, #0xc17
  410b6c:	911a8800 	add	x0, x0, #0x6a2
  410b70:	97ffdbc2 	bl	407a78 <assert_print>
  410b74:	aa1503e1 	mov	x1, x21
  410b78:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410b7c:	9130b000 	add	x0, x0, #0xc2c
  410b80:	97ffdbbe 	bl	407a78 <assert_print>
  410b84:	aa1303e0 	mov	x0, x19
  410b88:	52801281 	mov	w1, #0x94                  	// #148
  410b8c:	97ffdbe5 	bl	407b20 <assert_post_action>
  410b90:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410b94:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410b98:	aa1303e1 	mov	x1, x19
  410b9c:	911b8000 	add	x0, x0, #0x6e0
  410ba0:	97ffe5d2 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410ba4:	aa1503e0 	mov	x0, x21
  410ba8:	97fff690 	bl	40e5e8 <z_spin_lock_set_owner>
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  410bac:	f00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  410bb0:	d00000e2 	adrp	x2, 42e000 <des_frames+0x27>
  410bb4:	91102842 	add	x2, x2, #0x40a
  410bb8:	f9472c21 	ldr	x1, [x1, #3672]
  410bbc:	39408020 	ldrb	w0, [x1, #32]
  410bc0:	38606840 	ldrb	w0, [x2, x0]
  410bc4:	340001a0 	cbz	w0, 410bf8 <z_time_slice+0xd8>
	struct k_thread *curr = _current;
  410bc8:	f9400833 	ldr	x19, [x1, #16]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  410bcc:	aa1303e0 	mov	x0, x19
  410bd0:	97fffd69 	bl	410174 <sliceable>
  410bd4:	72001c1f 	tst	w0, #0xff
  410bd8:	54000100 	b.eq	410bf8 <z_time_slice+0xd8>  // b.none
		if (!z_is_thread_prevented_from_running(curr)) {
  410bdc:	39406660 	ldrb	w0, [x19, #25]
  410be0:	f240101f 	tst	x0, #0x1f
  410be4:	54000061 	b.ne	410bf0 <z_time_slice+0xd0>  // b.any
			move_thread_to_end_of_prio_q(curr);
  410be8:	aa1303e0 	mov	x0, x19
  410bec:	97ffff84 	bl	4109fc <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
  410bf0:	aa1303e0 	mov	x0, x19
  410bf4:	97fffda1 	bl	410278 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410bf8:	f947ca94 	ldr	x20, [x20, #3984]
  410bfc:	aa1403e0 	mov	x0, x20
  410c00:	97fff66d 	bl	40e5b4 <z_spin_unlock_valid>
  410c04:	72001c1f 	tst	w0, #0xff
  410c08:	54000261 	b.ne	410c54 <z_time_slice+0x134>  // b.any
  410c0c:	b0000033 	adrp	x19, 415000 <random_data+0xd8c>
  410c10:	912faa73 	add	x19, x19, #0xbea
  410c14:	aa1303e2 	mov	x2, x19
  410c18:	52801863 	mov	w3, #0xc3                  	// #195
  410c1c:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410c20:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410c24:	91311021 	add	x1, x1, #0xc44
  410c28:	911a8800 	add	x0, x0, #0x6a2
  410c2c:	97ffdb93 	bl	407a78 <assert_print>
  410c30:	aa1403e1 	mov	x1, x20
  410c34:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410c38:	91316c00 	add	x0, x0, #0xc5b
  410c3c:	97ffdb8f 	bl	407a78 <assert_print>
  410c40:	aa1303e0 	mov	x0, x19
  410c44:	52801861 	mov	w1, #0xc3                  	// #195
  410c48:	97ffdbb6 	bl	407b20 <assert_post_action>
  410c4c:	52801862 	mov	w2, #0xc3                  	// #195
  410c50:	17ffffd1 	b	410b94 <z_time_slice+0x74>
	posix_irq_unlock(key);
  410c54:	2a1603e0 	mov	w0, w22
}
  410c58:	a94153f3 	ldp	x19, x20, [sp, #16]
  410c5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410c60:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410c64:	17ffe48d 	b	409e98 <posix_irq_unlock>

0000000000410c68 <ready_thread>:
{
  410c68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410c6c:	910003fd 	mov	x29, sp
  410c70:	a90153f3 	stp	x19, x20, [sp, #16]
  410c74:	aa0003f3 	mov	x19, x0
  410c78:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  410c7c:	39c06661 	ldrsb	w1, [x19, #25]
  410c80:	39406400 	ldrb	w0, [x0, #25]
  410c84:	37f807a1 	tbnz	w1, #31, 410d78 <ready_thread+0x110>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  410c88:	f240101f 	tst	x0, #0x1f
  410c8c:	54000761 	b.ne	410d78 <ready_thread+0x110>  // b.any
  410c90:	f9401661 	ldr	x1, [x19, #40]
  410c94:	b5000721 	cbnz	x1, 410d78 <ready_thread+0x110>
	thread->base.thread_state |= _THREAD_QUEUED;
  410c98:	32196000 	orr	w0, w0, #0xffffff80
  410c9c:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  410ca0:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  410ca4:	f946fc00 	ldr	x0, [x0, #3576]
  410ca8:	eb00027f 	cmp	x19, x0
  410cac:	54000241 	b.ne	410cf4 <ready_thread+0x8c>  // b.any
  410cb0:	d0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  410cb4:	910f2a73 	add	x19, x19, #0x3ca
  410cb8:	aa1303e2 	mov	x2, x19
  410cbc:	52801783 	mov	w3, #0xbc                  	// #188
  410cc0:	d0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  410cc4:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410cc8:	91178421 	add	x1, x1, #0x5e1
  410ccc:	911a8800 	add	x0, x0, #0x6a2
  410cd0:	97ffdb6a 	bl	407a78 <assert_print>
  410cd4:	aa1303e0 	mov	x0, x19
  410cd8:	52801781 	mov	w1, #0xbc                  	// #188
  410cdc:	97ffdb91 	bl	407b20 <assert_post_action>
  410ce0:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410ce4:	aa1303e1 	mov	x1, x19
  410ce8:	911b8000 	add	x0, x0, #0x6e0
  410cec:	52801782 	mov	w2, #0xbc                  	// #188
  410cf0:	97ffe57e 	bl	40a2e8 <posix_print_error_and_exit>
	return list->head == list;
  410cf4:	f00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  410cf8:	aa0003f5 	mov	x21, x0
  410cfc:	f9472c16 	ldr	x22, [x0, #3672]
  410d00:	aa1603e1 	mov	x1, x22
  410d04:	f8430c34 	ldr	x20, [x1, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  410d08:	eb01029f 	cmp	x20, x1
  410d0c:	54000201 	b.ne	410d4c <ready_thread+0xe4>  // b.any
	sys_dnode_t *const tail = list->tail;
  410d10:	f9472ea0 	ldr	x0, [x21, #3672]
	node->next = list;
  410d14:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  410d18:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  410d1c:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  410d20:	f9000033 	str	x19, [x1]
	list->tail = node;
  410d24:	f9001c13 	str	x19, [x0, #56]
}
  410d28:	a94153f3 	ldp	x19, x20, [sp, #16]
		update_cache(0);
  410d2c:	52800000 	mov	w0, #0x0                   	// #0
}
  410d30:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410d34:	a8c37bfd 	ldp	x29, x30, [sp], #48
		update_cache(0);
  410d38:	17fffefb 	b	410924 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  410d3c:	f9401ec0 	ldr	x0, [x22, #56]
  410d40:	eb14001f 	cmp	x0, x20
  410d44:	54fffe60 	b.eq	410d10 <ready_thread+0xa8>  // b.none
  410d48:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  410d4c:	b4fffe34 	cbz	x20, 410d10 <ready_thread+0xa8>
		if (z_sched_prio_cmp(thread, t) > 0) {
  410d50:	aa1403e1 	mov	x1, x20
  410d54:	aa1303e0 	mov	x0, x19
  410d58:	97fffd42 	bl	410260 <z_sched_prio_cmp>
  410d5c:	7100001f 	cmp	w0, #0x0
  410d60:	54fffeed 	b.le	410d3c <ready_thread+0xd4>
	sys_dnode_t *const prev = successor->prev;
  410d64:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  410d68:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  410d6c:	f9000013 	str	x19, [x0]
	successor->prev = node;
  410d70:	f9000693 	str	x19, [x20, #8]
}
  410d74:	17ffffed 	b	410d28 <ready_thread+0xc0>
}
  410d78:	a94153f3 	ldp	x19, x20, [sp, #16]
  410d7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410d80:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410d84:	d65f03c0 	ret

0000000000410d88 <z_ready_thread>:
{
  410d88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410d8c:	910003fd 	mov	x29, sp
  410d90:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410d94:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  410d98:	f90013f5 	str	x21, [sp, #32]
  410d9c:	aa0003f5 	mov	x21, x0
	return posix_irq_lock();
  410da0:	97ffe43c 	bl	409e90 <posix_irq_lock>
  410da4:	2a0003f4 	mov	w20, w0
  410da8:	f947ca73 	ldr	x19, [x19, #3984]
  410dac:	aa1303e0 	mov	x0, x19
  410db0:	97fff5f6 	bl	40e588 <z_spin_lock_valid>
  410db4:	72001c1f 	tst	w0, #0xff
  410db8:	540002c1 	b.ne	410e10 <z_ready_thread+0x88>  // b.any
  410dbc:	b0000034 	adrp	x20, 415000 <random_data+0xd8c>
  410dc0:	912faa94 	add	x20, x20, #0xbea
  410dc4:	aa1403e2 	mov	x2, x20
  410dc8:	52801283 	mov	w3, #0x94                  	// #148
  410dcc:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410dd0:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410dd4:	91305c21 	add	x1, x1, #0xc17
  410dd8:	911a8800 	add	x0, x0, #0x6a2
  410ddc:	97ffdb27 	bl	407a78 <assert_print>
  410de0:	aa1303e1 	mov	x1, x19
  410de4:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410de8:	9130b000 	add	x0, x0, #0xc2c
  410dec:	97ffdb23 	bl	407a78 <assert_print>
  410df0:	aa1403e0 	mov	x0, x20
  410df4:	52801281 	mov	w1, #0x94                  	// #148
  410df8:	97ffdb4a 	bl	407b20 <assert_post_action>
  410dfc:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410e00:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410e04:	aa1403e1 	mov	x1, x20
  410e08:	911b8000 	add	x0, x0, #0x6e0
  410e0c:	97ffe537 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410e10:	aa1303e0 	mov	x0, x19
  410e14:	97fff5f5 	bl	40e5e8 <z_spin_lock_set_owner>
			ready_thread(thread);
  410e18:	aa1503e0 	mov	x0, x21
  410e1c:	97ffff93 	bl	410c68 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410e20:	aa1303e0 	mov	x0, x19
  410e24:	97fff5e4 	bl	40e5b4 <z_spin_unlock_valid>
  410e28:	72001c1f 	tst	w0, #0xff
  410e2c:	54000261 	b.ne	410e78 <z_ready_thread+0xf0>  // b.any
  410e30:	b0000034 	adrp	x20, 415000 <random_data+0xd8c>
  410e34:	912faa94 	add	x20, x20, #0xbea
  410e38:	aa1403e2 	mov	x2, x20
  410e3c:	52801863 	mov	w3, #0xc3                  	// #195
  410e40:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410e44:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410e48:	91311021 	add	x1, x1, #0xc44
  410e4c:	911a8800 	add	x0, x0, #0x6a2
  410e50:	97ffdb0a 	bl	407a78 <assert_print>
  410e54:	aa1303e1 	mov	x1, x19
  410e58:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410e5c:	91316c00 	add	x0, x0, #0xc5b
  410e60:	97ffdb06 	bl	407a78 <assert_print>
  410e64:	aa1403e0 	mov	x0, x20
  410e68:	52801861 	mov	w1, #0xc3                  	// #195
  410e6c:	97ffdb2d 	bl	407b20 <assert_post_action>
  410e70:	52801862 	mov	w2, #0xc3                  	// #195
  410e74:	17ffffe3 	b	410e00 <z_ready_thread+0x78>
	posix_irq_unlock(key);
  410e78:	2a1403e0 	mov	w0, w20
}
  410e7c:	a94153f3 	ldp	x19, x20, [sp, #16]
  410e80:	f94013f5 	ldr	x21, [sp, #32]
  410e84:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410e88:	17ffe404 	b	409e98 <posix_irq_unlock>

0000000000410e8c <z_sched_start>:
{
  410e8c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410e90:	910003fd 	mov	x29, sp
  410e94:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410e98:	f00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  410e9c:	aa0003f4 	mov	x20, x0
  410ea0:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  410ea4:	97ffe3fb 	bl	409e90 <posix_irq_lock>
  410ea8:	f947ca73 	ldr	x19, [x19, #3984]
  410eac:	2a0003f5 	mov	w21, w0
  410eb0:	aa1303e0 	mov	x0, x19
  410eb4:	97fff5b5 	bl	40e588 <z_spin_lock_valid>
  410eb8:	72001c1f 	tst	w0, #0xff
  410ebc:	540002c1 	b.ne	410f14 <z_sched_start+0x88>  // b.any
  410ec0:	b0000034 	adrp	x20, 415000 <random_data+0xd8c>
  410ec4:	912faa94 	add	x20, x20, #0xbea
  410ec8:	aa1403e2 	mov	x2, x20
  410ecc:	52801283 	mov	w3, #0x94                  	// #148
  410ed0:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410ed4:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410ed8:	91305c21 	add	x1, x1, #0xc17
  410edc:	911a8800 	add	x0, x0, #0x6a2
  410ee0:	97ffdae6 	bl	407a78 <assert_print>
  410ee4:	aa1303e1 	mov	x1, x19
  410ee8:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410eec:	9130b000 	add	x0, x0, #0xc2c
  410ef0:	97ffdae2 	bl	407a78 <assert_print>
  410ef4:	aa1403e0 	mov	x0, x20
  410ef8:	52801281 	mov	w1, #0x94                  	// #148
  410efc:	97ffdb09 	bl	407b20 <assert_post_action>
  410f00:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410f04:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410f08:	aa1403e1 	mov	x1, x20
  410f0c:	911b8000 	add	x0, x0, #0x6e0
  410f10:	97ffe4f6 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410f14:	aa1303e0 	mov	x0, x19
  410f18:	97fff5b4 	bl	40e5e8 <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
  410f1c:	39406680 	ldrb	w0, [x20, #25]
	if (z_has_thread_started(thread)) {
  410f20:	37100380 	tbnz	w0, #2, 410f90 <z_sched_start+0x104>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410f24:	aa1303e0 	mov	x0, x19
  410f28:	97fff5a3 	bl	40e5b4 <z_spin_unlock_valid>
  410f2c:	72001c1f 	tst	w0, #0xff
  410f30:	54000261 	b.ne	410f7c <z_sched_start+0xf0>  // b.any
  410f34:	b0000034 	adrp	x20, 415000 <random_data+0xd8c>
  410f38:	912faa94 	add	x20, x20, #0xbea
  410f3c:	aa1403e2 	mov	x2, x20
  410f40:	52801863 	mov	w3, #0xc3                  	// #195
  410f44:	b0000021 	adrp	x1, 415000 <random_data+0xd8c>
  410f48:	90000020 	adrp	x0, 414000 <__func__.1+0xd>
  410f4c:	91311021 	add	x1, x1, #0xc44
  410f50:	911a8800 	add	x0, x0, #0x6a2
  410f54:	97ffdac9 	bl	407a78 <assert_print>
  410f58:	aa1303e1 	mov	x1, x19
  410f5c:	b0000020 	adrp	x0, 415000 <random_data+0xd8c>
  410f60:	91316c00 	add	x0, x0, #0xc5b
  410f64:	97ffdac5 	bl	407a78 <assert_print>
  410f68:	aa1403e0 	mov	x0, x20
  410f6c:	52801861 	mov	w1, #0xc3                  	// #195
  410f70:	97ffdaec 	bl	407b20 <assert_post_action>
  410f74:	52801862 	mov	w2, #0xc3                  	// #195
  410f78:	17ffffe3 	b	410f04 <z_sched_start+0x78>
	posix_irq_unlock(key);
  410f7c:	2a1503e0 	mov	w0, w21
}
  410f80:	a94153f3 	ldp	x19, x20, [sp, #16]
  410f84:	f94013f5 	ldr	x21, [sp, #32]
  410f88:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410f8c:	17ffe3c3 	b	409e98 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
  410f90:	121d7800 	and	w0, w0, #0xfffffffb
  410f94:	39006680 	strb	w0, [x20, #25]
	ready_thread(thread);
  410f98:	aa1403e0 	mov	x0, x20
  410f9c:	97ffff33 	bl	410c68 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  410fa0:	2a1503e1 	mov	w1, w21
  410fa4:	aa1303e0 	mov	x0, x19
}
  410fa8:	a94153f3 	ldp	x19, x20, [sp, #16]
  410fac:	f94013f5 	ldr	x21, [sp, #32]
  410fb0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&sched_spinlock, key);
  410fb4:	17fffd1a 	b	41041c <z_reschedule>

0000000000410fb8 <z_sched_wake_thread>:
{
  410fb8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  410fbc:	910003fd 	mov	x29, sp
  410fc0:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410fc4:	f00000d4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  410fc8:	aa0003f3 	mov	x19, x0
  410fcc:	a9025bf5 	stp	x21, x22, [sp, #32]
  410fd0:	f9001bf7 	str	x23, [sp, #48]
  410fd4:	12001c37 	and	w23, w1, #0xff
	return posix_irq_lock();
  410fd8:	97ffe3ae 	bl	409e90 <posix_irq_lock>
  410fdc:	2a0003f6 	mov	w22, w0
  410fe0:	f947ca95 	ldr	x21, [x20, #3984]
  410fe4:	aa1503e0 	mov	x0, x21
  410fe8:	97fff568 	bl	40e588 <z_spin_lock_valid>
  410fec:	72001c1f 	tst	w0, #0xff
  410ff0:	540002c1 	b.ne	411048 <z_sched_wake_thread+0x90>  // b.any
  410ff4:	b0000033 	adrp	x19, 415000 <random_data+0xd8c>
  410ff8:	912faa73 	add	x19, x19, #0xbea
  410ffc:	aa1303e2 	mov	x2, x19
  411000:	52801283 	mov	w3, #0x94                  	// #148
  411004:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411008:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  41100c:	91305c21 	add	x1, x1, #0xc17
  411010:	911a8800 	add	x0, x0, #0x6a2
  411014:	97ffda99 	bl	407a78 <assert_print>
  411018:	aa1503e1 	mov	x1, x21
  41101c:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411020:	9130b000 	add	x0, x0, #0xc2c
  411024:	97ffda95 	bl	407a78 <assert_print>
  411028:	aa1303e0 	mov	x0, x19
  41102c:	52801281 	mov	w1, #0x94                  	// #148
  411030:	97ffdabc 	bl	407b20 <assert_post_action>
  411034:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411038:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  41103c:	aa1303e1 	mov	x1, x19
  411040:	911b8000 	add	x0, x0, #0x6e0
  411044:	97ffe4a9 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411048:	aa1503e0 	mov	x0, x21
  41104c:	97fff567 	bl	40e5e8 <z_spin_lock_set_owner>
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  411050:	39422260 	ldrb	w0, [x19, #136]
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
  411054:	39406661 	ldrb	w1, [x19, #25]
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  411058:	34000060 	cbz	w0, 411064 <z_sched_wake_thread+0xac>
		thread->no_wake_on_timeout = false;
  41105c:	3902227f 	strb	wzr, [x19, #136]
		if (do_nothing) {
  411060:	35000237 	cbnz	w23, 4110a4 <z_sched_wake_thread+0xec>
		if (!killed) {
  411064:	52800500 	mov	w0, #0x28                  	// #40
  411068:	6a00003f 	tst	w1, w0
  41106c:	540001c1 	b.ne	4110a4 <z_sched_wake_thread+0xec>  // b.any
			if (thread->base.pended_on != NULL) {
  411070:	f9400a60 	ldr	x0, [x19, #16]
  411074:	b4000060 	cbz	x0, 411080 <z_sched_wake_thread+0xc8>
				unpend_thread_no_timeout(thread);
  411078:	aa1303e0 	mov	x0, x19
  41107c:	97fffdbf 	bl	410778 <unpend_thread_no_timeout>
  411080:	39406662 	ldrb	w2, [x19, #25]
  411084:	710002ff 	cmp	w23, #0x0
  411088:	12800281 	mov	w1, #0xffffffeb            	// #-21
			ready_thread(thread);
  41108c:	aa1303e0 	mov	x0, x19
  411090:	0a010041 	and	w1, w2, w1
  411094:	121d7842 	and	w2, w2, #0xfffffffb
  411098:	1a810042 	csel	w2, w2, w1, eq  // eq = none
  41109c:	39006662 	strb	w2, [x19, #25]
  4110a0:	97fffef2 	bl	410c68 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4110a4:	f947ca94 	ldr	x20, [x20, #3984]
  4110a8:	aa1403e0 	mov	x0, x20
  4110ac:	97fff542 	bl	40e5b4 <z_spin_unlock_valid>
  4110b0:	72001c1f 	tst	w0, #0xff
  4110b4:	54000261 	b.ne	411100 <z_sched_wake_thread+0x148>  // b.any
  4110b8:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  4110bc:	912faa73 	add	x19, x19, #0xbea
  4110c0:	aa1303e2 	mov	x2, x19
  4110c4:	52801863 	mov	w3, #0xc3                  	// #195
  4110c8:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  4110cc:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4110d0:	91311021 	add	x1, x1, #0xc44
  4110d4:	911a8800 	add	x0, x0, #0x6a2
  4110d8:	97ffda68 	bl	407a78 <assert_print>
  4110dc:	aa1403e1 	mov	x1, x20
  4110e0:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  4110e4:	91316c00 	add	x0, x0, #0xc5b
  4110e8:	97ffda64 	bl	407a78 <assert_print>
  4110ec:	aa1303e0 	mov	x0, x19
  4110f0:	52801861 	mov	w1, #0xc3                  	// #195
  4110f4:	97ffda8b 	bl	407b20 <assert_post_action>
  4110f8:	52801862 	mov	w2, #0xc3                  	// #195
  4110fc:	17ffffcf 	b	411038 <z_sched_wake_thread+0x80>
	posix_irq_unlock(key);
  411100:	2a1603e0 	mov	w0, w22
}
  411104:	a94153f3 	ldp	x19, x20, [sp, #16]
  411108:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41110c:	f9401bf7 	ldr	x23, [sp, #48]
  411110:	a8c47bfd 	ldp	x29, x30, [sp], #64
  411114:	17ffe361 	b	409e98 <posix_irq_unlock>

0000000000411118 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
  411118:	d100a000 	sub	x0, x0, #0x28
  41111c:	52800021 	mov	w1, #0x1                   	// #1
  411120:	17ffffa6 	b	410fb8 <z_sched_wake_thread>

0000000000411124 <unready_thread>:
{
  411124:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411128:	910003fd 	mov	x29, sp
  41112c:	a90153f3 	stp	x19, x20, [sp, #16]
  411130:	aa0003f3 	mov	x19, x0
	return (thread->base.thread_state & state) != 0U;
  411134:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  411138:	39406400 	ldrb	w0, [x0, #25]
	if (z_is_thread_queued(thread)) {
  41113c:	39c06661 	ldrsb	w1, [x19, #25]
  411140:	36f800e1 	tbz	w1, #31, 41115c <unready_thread+0x38>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411144:	12001800 	and	w0, w0, #0x7f
  411148:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  41114c:	f9472e80 	ldr	x0, [x20, #3672]
  411150:	aa1303e1 	mov	x1, x19
  411154:	9100c000 	add	x0, x0, #0x30
  411158:	97fffd6b 	bl	410704 <z_priq_dumb_remove>
	update_cache(thread == _current);
  41115c:	f9472e94 	ldr	x20, [x20, #3672]
  411160:	f9400a80 	ldr	x0, [x20, #16]
  411164:	eb13001f 	cmp	x0, x19
}
  411168:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  41116c:	1a9f17e0 	cset	w0, eq  // eq = none
}
  411170:	a8c27bfd 	ldp	x29, x30, [sp], #32
	update_cache(thread == _current);
  411174:	17fffdec 	b	410924 <update_cache>

0000000000411178 <add_to_waitq_locked>:
{
  411178:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  41117c:	910003fd 	mov	x29, sp
  411180:	a90153f3 	stp	x19, x20, [sp, #16]
  411184:	aa0003f3 	mov	x19, x0
  411188:	aa0103f4 	mov	x20, x1
  41118c:	f90013f5 	str	x21, [sp, #32]
	unready_thread(thread);
  411190:	97ffffe5 	bl	411124 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
  411194:	39406660 	ldrb	w0, [x19, #25]
  411198:	321f0000 	orr	w0, w0, #0x2
  41119c:	39006660 	strb	w0, [x19, #25]
	if (wait_q != NULL) {
  4111a0:	b40003d4 	cbz	x20, 411218 <add_to_waitq_locked+0xa0>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4111a4:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
		thread->base.pended_on = wait_q;
  4111a8:	f9000a74 	str	x20, [x19, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4111ac:	f946fc00 	ldr	x0, [x0, #3576]
  4111b0:	eb00027f 	cmp	x19, x0
  4111b4:	54000241 	b.ne	4111fc <add_to_waitq_locked+0x84>  // b.any
  4111b8:	b0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  4111bc:	910f2a73 	add	x19, x19, #0x3ca
  4111c0:	aa1303e2 	mov	x2, x19
  4111c4:	52801783 	mov	w3, #0xbc                  	// #188
  4111c8:	b0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  4111cc:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4111d0:	91178421 	add	x1, x1, #0x5e1
  4111d4:	911a8800 	add	x0, x0, #0x6a2
  4111d8:	97ffda28 	bl	407a78 <assert_print>
  4111dc:	aa1303e0 	mov	x0, x19
  4111e0:	52801781 	mov	w1, #0xbc                  	// #188
  4111e4:	97ffda4f 	bl	407b20 <assert_post_action>
  4111e8:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4111ec:	aa1303e1 	mov	x1, x19
  4111f0:	911b8000 	add	x0, x0, #0x6e0
  4111f4:	52801782 	mov	w2, #0xbc                  	// #188
  4111f8:	97ffe43c 	bl	40a2e8 <posix_print_error_and_exit>
	return list->head == list;
  4111fc:	f9400295 	ldr	x21, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411200:	eb15029f 	cmp	x20, x21
  411204:	540001a1 	b.ne	411238 <add_to_waitq_locked+0xc0>  // b.any
	sys_dnode_t *const tail = list->tail;
  411208:	f9400680 	ldr	x0, [x20, #8]
	node->prev = tail;
  41120c:	a9000274 	stp	x20, x0, [x19]
	tail->next = node;
  411210:	f9000013 	str	x19, [x0]
	list->tail = node;
  411214:	f9000693 	str	x19, [x20, #8]
}
  411218:	a94153f3 	ldp	x19, x20, [sp, #16]
  41121c:	f94013f5 	ldr	x21, [sp, #32]
  411220:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411224:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
  411228:	f9400680 	ldr	x0, [x20, #8]
  41122c:	eb15001f 	cmp	x0, x21
  411230:	54fffec0 	b.eq	411208 <add_to_waitq_locked+0x90>  // b.none
  411234:	f94002b5 	ldr	x21, [x21]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  411238:	b4fffe95 	cbz	x21, 411208 <add_to_waitq_locked+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
  41123c:	aa1503e1 	mov	x1, x21
  411240:	aa1303e0 	mov	x0, x19
  411244:	97fffc07 	bl	410260 <z_sched_prio_cmp>
  411248:	7100001f 	cmp	w0, #0x0
  41124c:	54fffeed 	b.le	411228 <add_to_waitq_locked+0xb0>
	sys_dnode_t *const prev = successor->prev;
  411250:	f94006a0 	ldr	x0, [x21, #8]
	node->prev = prev;
  411254:	a9000275 	stp	x21, x0, [x19]
	prev->next = node;
  411258:	f9000013 	str	x19, [x0]
	successor->prev = node;
  41125c:	f90006b3 	str	x19, [x21, #8]
}
  411260:	17ffffee 	b	411218 <add_to_waitq_locked+0xa0>

0000000000411264 <pend_locked>:
{
  411264:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411268:	910003fd 	mov	x29, sp
  41126c:	a90153f3 	stp	x19, x20, [sp, #16]
  411270:	aa0203f3 	mov	x19, x2
  411274:	aa0003f4 	mov	x20, x0
	add_to_waitq_locked(thread, wait_q);
  411278:	97ffffc0 	bl	411178 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  41127c:	b100067f 	cmn	x19, #0x1
  411280:	54000100 	b.eq	4112a0 <pend_locked+0x3c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  411284:	aa1303e2 	mov	x2, x19
  411288:	9100a280 	add	x0, x20, #0x28
  41128c:	d00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
}
  411290:	a94153f3 	ldp	x19, x20, [sp, #16]
  411294:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411298:	f9472421 	ldr	x1, [x1, #3656]
  41129c:	14000589 	b	4128c0 <z_add_timeout>
  4112a0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4112a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4112a8:	d65f03c0 	ret

00000000004112ac <z_pend_curr>:
{
  4112ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4112b0:	910003fd 	mov	x29, sp
  4112b4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  4112b8:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  4112bc:	f947ca73 	ldr	x19, [x19, #3984]
{
  4112c0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4112c4:	f9001bf7 	str	x23, [sp, #48]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  4112c8:	eb13001f 	cmp	x0, x19
  4112cc:	54000201 	b.ne	41130c <z_pend_curr+0x60>  // b.any
  4112d0:	b0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  4112d4:	910f2a73 	add	x19, x19, #0x3ca
  4112d8:	aa1303e2 	mov	x2, x19
  4112dc:	52806a43 	mov	w3, #0x352                 	// #850
  4112e0:	b0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  4112e4:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4112e8:	91190021 	add	x1, x1, #0x640
  4112ec:	911a8800 	add	x0, x0, #0x6a2
  4112f0:	97ffd9e2 	bl	407a78 <assert_print>
  4112f4:	aa1303e0 	mov	x0, x19
  4112f8:	52806a41 	mov	w1, #0x352                 	// #850
  4112fc:	97ffda09 	bl	407b20 <assert_post_action>
  411300:	52806a42 	mov	w2, #0x352                 	// #850
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411304:	aa1303e1 	mov	x1, x19
  411308:	1400001c 	b	411378 <z_pend_curr+0xcc>
  41130c:	aa0003f4 	mov	x20, x0
  411310:	2a0103f5 	mov	w21, w1
  411314:	aa0203f6 	mov	x22, x2
  411318:	aa0303f7 	mov	x23, x3
	return posix_irq_lock();
  41131c:	97ffe2dd 	bl	409e90 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411320:	aa1303e0 	mov	x0, x19
  411324:	97fff499 	bl	40e588 <z_spin_lock_valid>
  411328:	72001c1f 	tst	w0, #0xff
  41132c:	540002c1 	b.ne	411384 <z_pend_curr+0xd8>  // b.any
  411330:	90000034 	adrp	x20, 415000 <random_data+0xd8c>
  411334:	912faa94 	add	x20, x20, #0xbea
  411338:	aa1403e2 	mov	x2, x20
  41133c:	52801283 	mov	w3, #0x94                  	// #148
  411340:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411344:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411348:	91305c21 	add	x1, x1, #0xc17
  41134c:	911a8800 	add	x0, x0, #0x6a2
  411350:	97ffd9ca 	bl	407a78 <assert_print>
  411354:	aa1303e1 	mov	x1, x19
  411358:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  41135c:	9130b000 	add	x0, x0, #0xc2c
  411360:	97ffd9c6 	bl	407a78 <assert_print>
  411364:	aa1403e0 	mov	x0, x20
  411368:	52801281 	mov	w1, #0x94                  	// #148
  41136c:	97ffd9ed 	bl	407b20 <assert_post_action>
  411370:	52801282 	mov	w2, #0x94                  	// #148
  411374:	aa1403e1 	mov	x1, x20
  411378:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  41137c:	911b8000 	add	x0, x0, #0x6e0
  411380:	97ffe3da 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411384:	aa1303e0 	mov	x0, x19
  411388:	97fff498 	bl	40e5e8 <z_spin_lock_set_owner>
	pend_locked(_current, wait_q, timeout);
  41138c:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  411390:	aa1703e2 	mov	x2, x23
  411394:	aa1603e1 	mov	x1, x22
  411398:	f9472c00 	ldr	x0, [x0, #3672]
  41139c:	f9400800 	ldr	x0, [x0, #16]
  4113a0:	97ffffb1 	bl	411264 <pend_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4113a4:	aa1403e0 	mov	x0, x20
  4113a8:	97fff483 	bl	40e5b4 <z_spin_unlock_valid>
  4113ac:	72001c1f 	tst	w0, #0xff
  4113b0:	54000261 	b.ne	4113fc <z_pend_curr+0x150>  // b.any
  4113b4:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  4113b8:	912faa73 	add	x19, x19, #0xbea
  4113bc:	aa1303e2 	mov	x2, x19
  4113c0:	52801c43 	mov	w3, #0xe2                  	// #226
  4113c4:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  4113c8:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4113cc:	91311021 	add	x1, x1, #0xc44
  4113d0:	911a8800 	add	x0, x0, #0x6a2
  4113d4:	97ffd9a9 	bl	407a78 <assert_print>
  4113d8:	aa1403e1 	mov	x1, x20
  4113dc:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  4113e0:	91316c00 	add	x0, x0, #0xc5b
  4113e4:	97ffd9a5 	bl	407a78 <assert_print>
  4113e8:	aa1303e0 	mov	x0, x19
  4113ec:	52801c41 	mov	w1, #0xe2                  	// #226
  4113f0:	97ffd9cc 	bl	407b20 <assert_post_action>
  4113f4:	52801c42 	mov	w2, #0xe2                  	// #226
  4113f8:	17ffffc3 	b	411304 <z_pend_curr+0x58>
  4113fc:	aa1303e0 	mov	x0, x19
  411400:	97fff46d 	bl	40e5b4 <z_spin_unlock_valid>
  411404:	72001c1f 	tst	w0, #0xff
  411408:	54000261 	b.ne	411454 <z_pend_curr+0x1a8>  // b.any
  41140c:	90000034 	adrp	x20, 415000 <random_data+0xd8c>
  411410:	912faa94 	add	x20, x20, #0xbea
  411414:	aa1403e2 	mov	x2, x20
  411418:	52801c43 	mov	w3, #0xe2                  	// #226
  41141c:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411420:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411424:	91311021 	add	x1, x1, #0xc44
  411428:	911a8800 	add	x0, x0, #0x6a2
  41142c:	97ffd993 	bl	407a78 <assert_print>
  411430:	aa1303e1 	mov	x1, x19
  411434:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411438:	91316c00 	add	x0, x0, #0xc5b
  41143c:	97ffd98f 	bl	407a78 <assert_print>
  411440:	aa1403e0 	mov	x0, x20
  411444:	52801c41 	mov	w1, #0xe2                  	// #226
  411448:	97ffd9b6 	bl	407b20 <assert_post_action>
  41144c:	52801c42 	mov	w2, #0xe2                  	// #226
  411450:	17ffffc9 	b	411374 <z_pend_curr+0xc8>
  411454:	2a1503e0 	mov	w0, w21
}
  411458:	a94153f3 	ldp	x19, x20, [sp, #16]
  41145c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411460:	f9401bf7 	ldr	x23, [sp, #48]
  411464:	a8c47bfd 	ldp	x29, x30, [sp], #64
  411468:	17ffdf60 	b	4091e8 <arch_swap>

000000000041146c <z_set_prio>:
{
  41146c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  411470:	910003fd 	mov	x29, sp
  411474:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411478:	d00000d8 	adrp	x24, 42b000 <__FRAME_END__+0x1007c>
  41147c:	a90153f3 	stp	x19, x20, [sp, #16]
  411480:	aa0003f3 	mov	x19, x0
  411484:	a9025bf5 	stp	x21, x22, [sp, #32]
  411488:	2a0103f5 	mov	w21, w1
  41148c:	f90023f9 	str	x25, [sp, #64]
  411490:	97ffe280 	bl	409e90 <posix_irq_lock>
  411494:	f947cb19 	ldr	x25, [x24, #3984]
  411498:	2a0003f7 	mov	w23, w0
  41149c:	aa1903e0 	mov	x0, x25
  4114a0:	97fff43a 	bl	40e588 <z_spin_lock_valid>
  4114a4:	72001c16 	ands	w22, w0, #0xff
  4114a8:	540002c1 	b.ne	411500 <z_set_prio+0x94>  // b.any
  4114ac:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  4114b0:	912faa73 	add	x19, x19, #0xbea
  4114b4:	aa1303e2 	mov	x2, x19
  4114b8:	52801283 	mov	w3, #0x94                  	// #148
  4114bc:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  4114c0:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4114c4:	91305c21 	add	x1, x1, #0xc17
  4114c8:	911a8800 	add	x0, x0, #0x6a2
  4114cc:	97ffd96b 	bl	407a78 <assert_print>
  4114d0:	aa1903e1 	mov	x1, x25
  4114d4:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  4114d8:	9130b000 	add	x0, x0, #0xc2c
  4114dc:	97ffd967 	bl	407a78 <assert_print>
  4114e0:	aa1303e0 	mov	x0, x19
  4114e4:	52801281 	mov	w1, #0x94                  	// #148
  4114e8:	97ffd98e 	bl	407b20 <assert_post_action>
  4114ec:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4114f0:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4114f4:	aa1303e1 	mov	x1, x19
  4114f8:	911b8000 	add	x0, x0, #0x6e0
  4114fc:	97ffe37b 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411500:	aa1903e0 	mov	x0, x25
  411504:	97fff439 	bl	40e5e8 <z_spin_lock_set_owner>
	uint8_t state = thread->base.thread_state;
  411508:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  41150c:	13001eb5 	sxtb	w21, w21
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  411510:	f240101f 	tst	x0, #0x1f
  411514:	54000a61 	b.ne	411660 <z_set_prio+0x1f4>  // b.any
		if (need_sched) {
  411518:	f9401661 	ldr	x1, [x19, #40]
  41151c:	b5000a21 	cbnz	x1, 411660 <z_set_prio+0x1f4>
	_priq_run_remove(thread_runq(thread), thread);
  411520:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411524:	12001800 	and	w0, w0, #0x7f
  411528:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  41152c:	aa1303e1 	mov	x1, x19
  411530:	f9472e99 	ldr	x25, [x20, #3672]
  411534:	9100c320 	add	x0, x25, #0x30
  411538:	97fffc73 	bl	410704 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  41153c:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  411540:	39006a75 	strb	w21, [x19, #26]
	thread->base.thread_state |= _THREAD_QUEUED;
  411544:	aa1403f5 	mov	x21, x20
  411548:	32196000 	orr	w0, w0, #0xffffff80
  41154c:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411550:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  411554:	f946fc00 	ldr	x0, [x0, #3576]
  411558:	eb00027f 	cmp	x19, x0
  41155c:	540001e1 	b.ne	411598 <z_set_prio+0x12c>  // b.any
  411560:	b0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  411564:	910f2a73 	add	x19, x19, #0x3ca
  411568:	aa1303e2 	mov	x2, x19
  41156c:	52801783 	mov	w3, #0xbc                  	// #188
  411570:	b0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  411574:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411578:	91178421 	add	x1, x1, #0x5e1
  41157c:	911a8800 	add	x0, x0, #0x6a2
  411580:	97ffd93e 	bl	407a78 <assert_print>
  411584:	aa1303e0 	mov	x0, x19
  411588:	52801781 	mov	w1, #0xbc                  	// #188
  41158c:	97ffd965 	bl	407b20 <assert_post_action>
  411590:	52801782 	mov	w2, #0xbc                  	// #188
  411594:	17ffffd7 	b	4114f0 <z_set_prio+0x84>
	return list->head == list;
  411598:	aa1903e0 	mov	x0, x25
  41159c:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4115a0:	eb00029f 	cmp	x20, x0
  4115a4:	54000481 	b.ne	411634 <z_set_prio+0x1c8>  // b.any
	sys_dnode_t *const tail = list->tail;
  4115a8:	f9472ea2 	ldr	x2, [x21, #3672]
	node->next = list;
  4115ac:	9100c041 	add	x1, x2, #0x30
	sys_dnode_t *const tail = list->tail;
  4115b0:	f9401c40 	ldr	x0, [x2, #56]
	node->prev = tail;
  4115b4:	a9000261 	stp	x1, x0, [x19]
	tail->next = node;
  4115b8:	f9000013 	str	x19, [x0]
	list->tail = node;
  4115bc:	f9001c53 	str	x19, [x2, #56]
			update_cache(1);
  4115c0:	52800020 	mov	w0, #0x1                   	// #1
  4115c4:	97fffcd8 	bl	410924 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4115c8:	f947cb18 	ldr	x24, [x24, #3984]
  4115cc:	aa1803e0 	mov	x0, x24
  4115d0:	97fff3f9 	bl	40e5b4 <z_spin_unlock_valid>
  4115d4:	72001c1f 	tst	w0, #0xff
  4115d8:	540004a1 	b.ne	41166c <z_set_prio+0x200>  // b.any
  4115dc:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  4115e0:	912faa73 	add	x19, x19, #0xbea
  4115e4:	aa1303e2 	mov	x2, x19
  4115e8:	52801863 	mov	w3, #0xc3                  	// #195
  4115ec:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  4115f0:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4115f4:	91311021 	add	x1, x1, #0xc44
  4115f8:	911a8800 	add	x0, x0, #0x6a2
  4115fc:	97ffd91f 	bl	407a78 <assert_print>
  411600:	aa1803e1 	mov	x1, x24
  411604:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411608:	91316c00 	add	x0, x0, #0xc5b
  41160c:	97ffd91b 	bl	407a78 <assert_print>
  411610:	aa1303e0 	mov	x0, x19
  411614:	52801861 	mov	w1, #0xc3                  	// #195
  411618:	97ffd942 	bl	407b20 <assert_post_action>
  41161c:	52801862 	mov	w2, #0xc3                  	// #195
  411620:	17ffffb4 	b	4114f0 <z_set_prio+0x84>
	return (node == list->tail) ? NULL : node->next;
  411624:	f9401f20 	ldr	x0, [x25, #56]
  411628:	eb00029f 	cmp	x20, x0
  41162c:	54fffbe0 	b.eq	4115a8 <z_set_prio+0x13c>  // b.none
  411630:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  411634:	b4fffbb4 	cbz	x20, 4115a8 <z_set_prio+0x13c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  411638:	aa1403e1 	mov	x1, x20
  41163c:	aa1303e0 	mov	x0, x19
  411640:	97fffb08 	bl	410260 <z_sched_prio_cmp>
  411644:	7100001f 	cmp	w0, #0x0
  411648:	54fffeed 	b.le	411624 <z_set_prio+0x1b8>
	sys_dnode_t *const prev = successor->prev;
  41164c:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  411650:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  411654:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411658:	f9000693 	str	x19, [x20, #8]
}
  41165c:	17ffffd9 	b	4115c0 <z_set_prio+0x154>
			thread->base.prio = prio;
  411660:	52800016 	mov	w22, #0x0                   	// #0
  411664:	39006a75 	strb	w21, [x19, #26]
  411668:	17ffffd8 	b	4115c8 <z_set_prio+0x15c>
	posix_irq_unlock(key);
  41166c:	2a1703e0 	mov	w0, w23
  411670:	97ffe20a 	bl	409e98 <posix_irq_unlock>
}
  411674:	2a1603e0 	mov	w0, w22
  411678:	a94153f3 	ldp	x19, x20, [sp, #16]
  41167c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411680:	a94363f7 	ldp	x23, x24, [sp, #48]
  411684:	f94023f9 	ldr	x25, [sp, #64]
  411688:	a8c57bfd 	ldp	x29, x30, [sp], #80
  41168c:	d65f03c0 	ret

0000000000411690 <z_impl_k_thread_suspend>:
{
  411690:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411694:	910003fd 	mov	x29, sp
  411698:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41169c:	d00000d5 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
  4116a0:	a90153f3 	stp	x19, x20, [sp, #16]
  4116a4:	aa0003f3 	mov	x19, x0
	return z_abort_timeout(&thread->base.timeout);
  4116a8:	9100a000 	add	x0, x0, #0x28
  4116ac:	94000517 	bl	412b08 <z_abort_timeout>
	return posix_irq_lock();
  4116b0:	97ffe1f8 	bl	409e90 <posix_irq_lock>
  4116b4:	2a0003f6 	mov	w22, w0
  4116b8:	f947cab4 	ldr	x20, [x21, #3984]
  4116bc:	aa1403e0 	mov	x0, x20
  4116c0:	97fff3b2 	bl	40e588 <z_spin_lock_valid>
  4116c4:	72001c1f 	tst	w0, #0xff
  4116c8:	540002c1 	b.ne	411720 <z_impl_k_thread_suspend+0x90>  // b.any
  4116cc:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  4116d0:	912faa73 	add	x19, x19, #0xbea
  4116d4:	aa1303e2 	mov	x2, x19
  4116d8:	52801283 	mov	w3, #0x94                  	// #148
  4116dc:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  4116e0:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4116e4:	91305c21 	add	x1, x1, #0xc17
  4116e8:	911a8800 	add	x0, x0, #0x6a2
  4116ec:	97ffd8e3 	bl	407a78 <assert_print>
  4116f0:	aa1403e1 	mov	x1, x20
  4116f4:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  4116f8:	9130b000 	add	x0, x0, #0xc2c
  4116fc:	97ffd8df 	bl	407a78 <assert_print>
  411700:	aa1303e0 	mov	x0, x19
  411704:	52801281 	mov	w1, #0x94                  	// #148
  411708:	97ffd906 	bl	407b20 <assert_post_action>
  41170c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411710:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411714:	aa1303e1 	mov	x1, x19
  411718:	911b8000 	add	x0, x0, #0x6e0
  41171c:	97ffe2f3 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411720:	aa1403e0 	mov	x0, x20
  411724:	97fff3b1 	bl	40e5e8 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
  411728:	39c06661 	ldrsb	w1, [x19, #25]
  41172c:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
	return (thread->base.thread_state & state) != 0U;
  411730:	39406660 	ldrb	w0, [x19, #25]
  411734:	36f800e1 	tbz	w1, #31, 411750 <z_impl_k_thread_suspend+0xc0>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411738:	12001800 	and	w0, w0, #0x7f
  41173c:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411740:	f9472e80 	ldr	x0, [x20, #3672]
  411744:	aa1303e1 	mov	x1, x19
  411748:	9100c000 	add	x0, x0, #0x30
  41174c:	97fffbee 	bl	410704 <z_priq_dumb_remove>
		update_cache(thread == _current);
  411750:	f9472e94 	ldr	x20, [x20, #3672]
	thread->base.thread_state |= _THREAD_SUSPENDED;
  411754:	39406660 	ldrb	w0, [x19, #25]
  411758:	321c0000 	orr	w0, w0, #0x10
  41175c:	39006660 	strb	w0, [x19, #25]
  411760:	f9400a80 	ldr	x0, [x20, #16]
  411764:	eb13001f 	cmp	x0, x19
  411768:	1a9f17e0 	cset	w0, eq  // eq = none
  41176c:	97fffc6e 	bl	410924 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411770:	f947cab5 	ldr	x21, [x21, #3984]
  411774:	aa1503e0 	mov	x0, x21
  411778:	97fff38f 	bl	40e5b4 <z_spin_unlock_valid>
  41177c:	72001c1f 	tst	w0, #0xff
  411780:	54000261 	b.ne	4117cc <z_impl_k_thread_suspend+0x13c>  // b.any
  411784:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  411788:	912faa73 	add	x19, x19, #0xbea
  41178c:	aa1303e2 	mov	x2, x19
  411790:	52801863 	mov	w3, #0xc3                  	// #195
  411794:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411798:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  41179c:	91311021 	add	x1, x1, #0xc44
  4117a0:	911a8800 	add	x0, x0, #0x6a2
  4117a4:	97ffd8b5 	bl	407a78 <assert_print>
  4117a8:	aa1503e1 	mov	x1, x21
  4117ac:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  4117b0:	91316c00 	add	x0, x0, #0xc5b
  4117b4:	97ffd8b1 	bl	407a78 <assert_print>
  4117b8:	aa1303e0 	mov	x0, x19
  4117bc:	52801861 	mov	w1, #0xc3                  	// #195
  4117c0:	97ffd8d8 	bl	407b20 <assert_post_action>
  4117c4:	52801862 	mov	w2, #0xc3                  	// #195
  4117c8:	17ffffd2 	b	411710 <z_impl_k_thread_suspend+0x80>
	posix_irq_unlock(key);
  4117cc:	2a1603e0 	mov	w0, w22
  4117d0:	97ffe1b2 	bl	409e98 <posix_irq_unlock>
	if (thread == _current) {
  4117d4:	f9400a80 	ldr	x0, [x20, #16]
  4117d8:	eb13001f 	cmp	x0, x19
  4117dc:	540000a1 	b.ne	4117f0 <z_impl_k_thread_suspend+0x160>  // b.any
}
  4117e0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4117e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4117e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule_unlocked();
  4117ec:	17fffb58 	b	41054c <z_reschedule_unlocked>
}
  4117f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4117f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4117f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4117fc:	d65f03c0 	ret

0000000000411800 <k_sched_unlock>:
{
  411800:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411804:	910003fd 	mov	x29, sp
  411808:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41180c:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
	return posix_irq_lock();
  411810:	97ffe1a0 	bl	409e90 <posix_irq_lock>
  411814:	f947ca73 	ldr	x19, [x19, #3984]
  411818:	2a0003f4 	mov	w20, w0
  41181c:	aa1303e0 	mov	x0, x19
  411820:	97fff35a 	bl	40e588 <z_spin_lock_valid>
  411824:	72001c1f 	tst	w0, #0xff
  411828:	54000281 	b.ne	411878 <k_sched_unlock+0x78>  // b.any
  41182c:	90000034 	adrp	x20, 415000 <random_data+0xd8c>
  411830:	912faa94 	add	x20, x20, #0xbea
  411834:	aa1403e2 	mov	x2, x20
  411838:	52801283 	mov	w3, #0x94                  	// #148
  41183c:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411840:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411844:	91305c21 	add	x1, x1, #0xc17
  411848:	911a8800 	add	x0, x0, #0x6a2
  41184c:	97ffd88b 	bl	407a78 <assert_print>
  411850:	aa1303e1 	mov	x1, x19
  411854:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411858:	9130b000 	add	x0, x0, #0xc2c
  41185c:	97ffd887 	bl	407a78 <assert_print>
  411860:	aa1403e0 	mov	x0, x20
  411864:	52801281 	mov	w1, #0x94                  	// #148
  411868:	97ffd8ae 	bl	407b20 <assert_post_action>
  41186c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411870:	aa1403e1 	mov	x1, x20
  411874:	14000019 	b	4118d8 <k_sched_unlock+0xd8>
	z_spin_lock_set_owner(l);
  411878:	aa1303e0 	mov	x0, x19
  41187c:	97fff35b 	bl	40e5e8 <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0U, "");
  411880:	d00000c2 	adrp	x2, 42b000 <__FRAME_END__+0x1007c>
  411884:	f9472c42 	ldr	x2, [x2, #3672]
  411888:	f9400840 	ldr	x0, [x2, #16]
  41188c:	39406c01 	ldrb	w1, [x0, #27]
  411890:	350002a1 	cbnz	w1, 4118e4 <k_sched_unlock+0xe4>
  411894:	b0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  411898:	910f2a73 	add	x19, x19, #0x3ca
  41189c:	aa1303e2 	mov	x2, x19
  4118a0:	b0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  4118a4:	9119dc21 	add	x1, x1, #0x677
  4118a8:	52807d63 	mov	w3, #0x3eb                 	// #1003
  4118ac:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4118b0:	911a8800 	add	x0, x0, #0x6a2
  4118b4:	97ffd871 	bl	407a78 <assert_print>
  4118b8:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  4118bc:	91320400 	add	x0, x0, #0xc81
  4118c0:	97ffd86e 	bl	407a78 <assert_print>
  4118c4:	aa1303e0 	mov	x0, x19
  4118c8:	52807d61 	mov	w1, #0x3eb                 	// #1003
  4118cc:	97ffd895 	bl	407b20 <assert_post_action>
  4118d0:	52807d62 	mov	w2, #0x3eb                 	// #1003
  4118d4:	aa1303e1 	mov	x1, x19
  4118d8:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4118dc:	911b8000 	add	x0, x0, #0x6e0
  4118e0:	97ffe282 	bl	40a2e8 <posix_print_error_and_exit>
		__ASSERT(!arch_is_in_isr(), "");
  4118e4:	b9400042 	ldr	w2, [x2]
  4118e8:	34000242 	cbz	w2, 411930 <k_sched_unlock+0x130>
  4118ec:	b0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  4118f0:	910f2a73 	add	x19, x19, #0x3ca
  4118f4:	aa1303e2 	mov	x2, x19
  4118f8:	b0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  4118fc:	9104f021 	add	x1, x1, #0x13c
  411900:	52807d83 	mov	w3, #0x3ec                 	// #1004
  411904:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411908:	911a8800 	add	x0, x0, #0x6a2
  41190c:	97ffd85b 	bl	407a78 <assert_print>
  411910:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411914:	91320400 	add	x0, x0, #0xc81
  411918:	97ffd858 	bl	407a78 <assert_print>
  41191c:	aa1303e0 	mov	x0, x19
  411920:	52807d81 	mov	w1, #0x3ec                 	// #1004
  411924:	97ffd87f 	bl	407b20 <assert_post_action>
  411928:	52807d82 	mov	w2, #0x3ec                 	// #1004
  41192c:	17ffffea 	b	4118d4 <k_sched_unlock+0xd4>
		++_current->base.sched_locked;
  411930:	11000421 	add	w1, w1, #0x1
  411934:	39006c01 	strb	w1, [x0, #27]
		update_cache(0);
  411938:	52800000 	mov	w0, #0x0                   	// #0
  41193c:	97fffbfa 	bl	410924 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411940:	aa1303e0 	mov	x0, x19
  411944:	97fff31c 	bl	40e5b4 <z_spin_unlock_valid>
  411948:	72001c1f 	tst	w0, #0xff
  41194c:	54000261 	b.ne	411998 <k_sched_unlock+0x198>  // b.any
  411950:	90000034 	adrp	x20, 415000 <random_data+0xd8c>
  411954:	912faa94 	add	x20, x20, #0xbea
  411958:	aa1403e2 	mov	x2, x20
  41195c:	52801863 	mov	w3, #0xc3                  	// #195
  411960:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411964:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411968:	91311021 	add	x1, x1, #0xc44
  41196c:	911a8800 	add	x0, x0, #0x6a2
  411970:	97ffd842 	bl	407a78 <assert_print>
  411974:	aa1303e1 	mov	x1, x19
  411978:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  41197c:	91316c00 	add	x0, x0, #0xc5b
  411980:	97ffd83e 	bl	407a78 <assert_print>
  411984:	aa1403e0 	mov	x0, x20
  411988:	52801861 	mov	w1, #0xc3                  	// #195
  41198c:	97ffd865 	bl	407b20 <assert_post_action>
  411990:	52801862 	mov	w2, #0xc3                  	// #195
  411994:	17ffffb7 	b	411870 <k_sched_unlock+0x70>
	posix_irq_unlock(key);
  411998:	2a1403e0 	mov	w0, w20
  41199c:	97ffe13f 	bl	409e98 <posix_irq_unlock>
}
  4119a0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4119a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
  4119a8:	17fffae9 	b	41054c <z_reschedule_unlocked>

00000000004119ac <z_unpend1_no_timeout>:
{
  4119ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4119b0:	910003fd 	mov	x29, sp
  4119b4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4119b8:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  4119bc:	aa0003f4 	mov	x20, x0
  4119c0:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  4119c4:	97ffe133 	bl	409e90 <posix_irq_lock>
  4119c8:	2a0003f5 	mov	w21, w0
  4119cc:	f947ca76 	ldr	x22, [x19, #3984]
  4119d0:	aa1603e0 	mov	x0, x22
  4119d4:	97fff2ed 	bl	40e588 <z_spin_lock_valid>
  4119d8:	72001c1f 	tst	w0, #0xff
  4119dc:	540002c1 	b.ne	411a34 <z_unpend1_no_timeout+0x88>  // b.any
  4119e0:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  4119e4:	912faa73 	add	x19, x19, #0xbea
  4119e8:	aa1303e2 	mov	x2, x19
  4119ec:	52801283 	mov	w3, #0x94                  	// #148
  4119f0:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  4119f4:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4119f8:	91305c21 	add	x1, x1, #0xc17
  4119fc:	911a8800 	add	x0, x0, #0x6a2
  411a00:	97ffd81e 	bl	407a78 <assert_print>
  411a04:	aa1603e1 	mov	x1, x22
  411a08:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411a0c:	9130b000 	add	x0, x0, #0xc2c
  411a10:	97ffd81a 	bl	407a78 <assert_print>
  411a14:	52801281 	mov	w1, #0x94                  	// #148
  411a18:	aa1303e0 	mov	x0, x19
  411a1c:	97ffd841 	bl	407b20 <assert_post_action>
  411a20:	aa1303e1 	mov	x1, x19
  411a24:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411a28:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411a2c:	911b8000 	add	x0, x0, #0x6e0
  411a30:	97ffe22e 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411a34:	aa1603e0 	mov	x0, x22
  411a38:	97fff2ec 	bl	40e5e8 <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  411a3c:	aa1403e0 	mov	x0, x20
  411a40:	97fffbb5 	bl	410914 <z_priq_dumb_best>
  411a44:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  411a48:	b4000040 	cbz	x0, 411a50 <z_unpend1_no_timeout+0xa4>
			unpend_thread_no_timeout(thread);
  411a4c:	97fffb4b 	bl	410778 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411a50:	f947ca73 	ldr	x19, [x19, #3984]
  411a54:	aa1303e0 	mov	x0, x19
  411a58:	97fff2d7 	bl	40e5b4 <z_spin_unlock_valid>
  411a5c:	72001c1f 	tst	w0, #0xff
  411a60:	54000281 	b.ne	411ab0 <z_unpend1_no_timeout+0x104>  // b.any
  411a64:	90000034 	adrp	x20, 415000 <random_data+0xd8c>
  411a68:	912faa94 	add	x20, x20, #0xbea
  411a6c:	aa1403e2 	mov	x2, x20
  411a70:	52801863 	mov	w3, #0xc3                  	// #195
  411a74:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411a78:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411a7c:	91311021 	add	x1, x1, #0xc44
  411a80:	911a8800 	add	x0, x0, #0x6a2
  411a84:	97ffd7fd 	bl	407a78 <assert_print>
  411a88:	aa1303e1 	mov	x1, x19
  411a8c:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411a90:	91316c00 	add	x0, x0, #0xc5b
  411a94:	97ffd7f9 	bl	407a78 <assert_print>
  411a98:	52801861 	mov	w1, #0xc3                  	// #195
  411a9c:	aa1403e0 	mov	x0, x20
  411aa0:	97ffd820 	bl	407b20 <assert_post_action>
  411aa4:	aa1403e1 	mov	x1, x20
  411aa8:	52801862 	mov	w2, #0xc3                  	// #195
  411aac:	17ffffdf 	b	411a28 <z_unpend1_no_timeout+0x7c>
	posix_irq_unlock(key);
  411ab0:	2a1503e0 	mov	w0, w21
  411ab4:	97ffe0f9 	bl	409e98 <posix_irq_unlock>
}
  411ab8:	aa1403e0 	mov	x0, x20
  411abc:	a94153f3 	ldp	x19, x20, [sp, #16]
  411ac0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411ac4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411ac8:	d65f03c0 	ret

0000000000411acc <z_unpend_first_thread>:
{
  411acc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411ad0:	910003fd 	mov	x29, sp
  411ad4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411ad8:	d00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  411adc:	aa0003f4 	mov	x20, x0
  411ae0:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  411ae4:	97ffe0eb 	bl	409e90 <posix_irq_lock>
  411ae8:	2a0003f5 	mov	w21, w0
  411aec:	f947ca76 	ldr	x22, [x19, #3984]
  411af0:	aa1603e0 	mov	x0, x22
  411af4:	97fff2a5 	bl	40e588 <z_spin_lock_valid>
  411af8:	72001c1f 	tst	w0, #0xff
  411afc:	540002c1 	b.ne	411b54 <z_unpend_first_thread+0x88>  // b.any
  411b00:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  411b04:	912faa73 	add	x19, x19, #0xbea
  411b08:	aa1303e2 	mov	x2, x19
  411b0c:	52801283 	mov	w3, #0x94                  	// #148
  411b10:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411b14:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411b18:	91305c21 	add	x1, x1, #0xc17
  411b1c:	911a8800 	add	x0, x0, #0x6a2
  411b20:	97ffd7d6 	bl	407a78 <assert_print>
  411b24:	aa1603e1 	mov	x1, x22
  411b28:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411b2c:	9130b000 	add	x0, x0, #0xc2c
  411b30:	97ffd7d2 	bl	407a78 <assert_print>
  411b34:	52801281 	mov	w1, #0x94                  	// #148
  411b38:	aa1303e0 	mov	x0, x19
  411b3c:	97ffd7f9 	bl	407b20 <assert_post_action>
  411b40:	aa1303e1 	mov	x1, x19
  411b44:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411b48:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411b4c:	911b8000 	add	x0, x0, #0x6e0
  411b50:	97ffe1e6 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411b54:	aa1603e0 	mov	x0, x22
  411b58:	97fff2a4 	bl	40e5e8 <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  411b5c:	aa1403e0 	mov	x0, x20
  411b60:	97fffb6d 	bl	410914 <z_priq_dumb_best>
  411b64:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  411b68:	b4000080 	cbz	x0, 411b78 <z_unpend_first_thread+0xac>
			unpend_thread_no_timeout(thread);
  411b6c:	97fffb03 	bl	410778 <unpend_thread_no_timeout>
  411b70:	9100a280 	add	x0, x20, #0x28
  411b74:	940003e5 	bl	412b08 <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411b78:	f947ca73 	ldr	x19, [x19, #3984]
  411b7c:	aa1303e0 	mov	x0, x19
  411b80:	97fff28d 	bl	40e5b4 <z_spin_unlock_valid>
  411b84:	72001c1f 	tst	w0, #0xff
  411b88:	54000281 	b.ne	411bd8 <z_unpend_first_thread+0x10c>  // b.any
  411b8c:	90000034 	adrp	x20, 415000 <random_data+0xd8c>
  411b90:	912faa94 	add	x20, x20, #0xbea
  411b94:	aa1403e2 	mov	x2, x20
  411b98:	52801863 	mov	w3, #0xc3                  	// #195
  411b9c:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411ba0:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411ba4:	91311021 	add	x1, x1, #0xc44
  411ba8:	911a8800 	add	x0, x0, #0x6a2
  411bac:	97ffd7b3 	bl	407a78 <assert_print>
  411bb0:	aa1303e1 	mov	x1, x19
  411bb4:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411bb8:	91316c00 	add	x0, x0, #0xc5b
  411bbc:	97ffd7af 	bl	407a78 <assert_print>
  411bc0:	52801861 	mov	w1, #0xc3                  	// #195
  411bc4:	aa1403e0 	mov	x0, x20
  411bc8:	97ffd7d6 	bl	407b20 <assert_post_action>
  411bcc:	aa1403e1 	mov	x1, x20
  411bd0:	52801862 	mov	w2, #0xc3                  	// #195
  411bd4:	17ffffdd 	b	411b48 <z_unpend_first_thread+0x7c>
	posix_irq_unlock(key);
  411bd8:	2a1503e0 	mov	w0, w21
  411bdc:	97ffe0af 	bl	409e98 <posix_irq_unlock>
}
  411be0:	aa1403e0 	mov	x0, x20
  411be4:	a94153f3 	ldp	x19, x20, [sp, #16]
  411be8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411bec:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411bf0:	d65f03c0 	ret

0000000000411bf4 <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
  411bf4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411bf8:	910003fd 	mov	x29, sp
  411bfc:	a90153f3 	stp	x19, x20, [sp, #16]
  411c00:	aa0003f4 	mov	x20, x0
	int need_sched = 0;
  411c04:	52800000 	mov	w0, #0x0                   	// #0
	return list->head == list;
  411c08:	f9400293 	ldr	x19, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411c0c:	eb13029f 	cmp	x20, x19
  411c10:	54000040 	b.eq	411c18 <z_unpend_all+0x24>  // b.none
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
  411c14:	b5000093 	cbnz	x19, 411c24 <z_unpend_all+0x30>
		z_ready_thread(thread);
		need_sched = 1;
	}

	return need_sched;
}
  411c18:	a94153f3 	ldp	x19, x20, [sp, #16]
  411c1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411c20:	d65f03c0 	ret
		z_unpend_thread(thread);
  411c24:	aa1303e0 	mov	x0, x19
  411c28:	97fffaf4 	bl	4107f8 <z_unpend_thread>
		z_ready_thread(thread);
  411c2c:	aa1303e0 	mov	x0, x19
  411c30:	97fffc56 	bl	410d88 <z_ready_thread>
		need_sched = 1;
  411c34:	52800020 	mov	w0, #0x1                   	// #1
  411c38:	17fffff4 	b	411c08 <z_unpend_all+0x14>

0000000000411c3c <init_ready_q>:
#elif defined(CONFIG_SCHED_MULTIQ)
	for (int i = 0; i < ARRAY_SIZE(_kernel.ready_q.runq.queues); i++) {
		sys_dlist_init(&rq->runq.queues[i]);
	}
#else
	sys_dlist_init(&rq->runq);
  411c3c:	91002001 	add	x1, x0, #0x8
	list->tail = (sys_dnode_t *)list;
  411c40:	a9008401 	stp	x1, x1, [x0, #8]
#endif
}
  411c44:	d65f03c0 	ret

0000000000411c48 <z_sched_init>:
#ifdef CONFIG_SCHED_CPU_MASK_PIN_ONLY
	for (int i = 0; i < CONFIG_MP_MAX_NUM_CPUS; i++) {
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
  411c48:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  411c4c:	f9472c00 	ldr	x0, [x0, #3672]
  411c50:	9100a000 	add	x0, x0, #0x28
  411c54:	17fffffa 	b	411c3c <init_ready_q>

0000000000411c58 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
  411c58:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  411c5c:	d00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  411c60:	910003fd 	mov	x29, sp
  411c64:	a9025bf5 	stp	x21, x22, [sp, #32]
  411c68:	f9472c35 	ldr	x21, [x1, #3672]
  411c6c:	a90153f3 	stp	x19, x20, [sp, #16]
  411c70:	a90363f7 	stp	x23, x24, [sp, #48]
  411c74:	f90023f9 	str	x25, [sp, #64]
	__ASSERT(!arch_is_in_isr(), "");
  411c78:	b94002a0 	ldr	w0, [x21]
  411c7c:	340002a0 	cbz	w0, 411cd0 <z_impl_k_yield+0x78>
  411c80:	b0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  411c84:	910f2a73 	add	x19, x19, #0x3ca
  411c88:	aa1303e2 	mov	x2, x19
  411c8c:	b0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  411c90:	9104f021 	add	x1, x1, #0x13c
  411c94:	5280ae23 	mov	w3, #0x571                 	// #1393
  411c98:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411c9c:	911a8800 	add	x0, x0, #0x6a2
  411ca0:	97ffd776 	bl	407a78 <assert_print>
  411ca4:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411ca8:	91320400 	add	x0, x0, #0xc81
  411cac:	97ffd773 	bl	407a78 <assert_print>
  411cb0:	aa1303e0 	mov	x0, x19
  411cb4:	5280ae21 	mov	w1, #0x571                 	// #1393
  411cb8:	97ffd79a 	bl	407b20 <assert_post_action>
  411cbc:	5280ae22 	mov	w2, #0x571                 	// #1393
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411cc0:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411cc4:	aa1303e1 	mov	x1, x19
  411cc8:	911b8000 	add	x0, x0, #0x6e0
  411ccc:	97ffe187 	bl	40a2e8 <posix_print_error_and_exit>
  411cd0:	d00000d7 	adrp	x23, 42b000 <__FRAME_END__+0x1007c>
  411cd4:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  411cd8:	97ffe06e 	bl	409e90 <posix_irq_lock>
  411cdc:	2a0003f8 	mov	w24, w0
  411ce0:	f947caf9 	ldr	x25, [x23, #3984]
  411ce4:	aa1903e0 	mov	x0, x25
  411ce8:	97fff228 	bl	40e588 <z_spin_lock_valid>
  411cec:	72001c1f 	tst	w0, #0xff
  411cf0:	54000261 	b.ne	411d3c <z_impl_k_yield+0xe4>  // b.any
  411cf4:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  411cf8:	912faa73 	add	x19, x19, #0xbea
  411cfc:	aa1303e2 	mov	x2, x19
  411d00:	52801283 	mov	w3, #0x94                  	// #148
  411d04:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411d08:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411d0c:	91305c21 	add	x1, x1, #0xc17
  411d10:	911a8800 	add	x0, x0, #0x6a2
  411d14:	97ffd759 	bl	407a78 <assert_print>
  411d18:	aa1903e1 	mov	x1, x25
  411d1c:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411d20:	9130b000 	add	x0, x0, #0xc2c
  411d24:	97ffd755 	bl	407a78 <assert_print>
  411d28:	aa1303e0 	mov	x0, x19
  411d2c:	52801281 	mov	w1, #0x94                  	// #148
  411d30:	97ffd77c 	bl	407b20 <assert_post_action>
  411d34:	52801282 	mov	w2, #0x94                  	// #148
  411d38:	17ffffe2 	b	411cc0 <z_impl_k_yield+0x68>
	z_spin_lock_set_owner(l);
  411d3c:	aa1903e0 	mov	x0, x25
  411d40:	97fff22a 	bl	40e5e8 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
  411d44:	f9400aa1 	ldr	x1, [x21, #16]
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411d48:	39406420 	ldrb	w0, [x1, #25]
  411d4c:	12001800 	and	w0, w0, #0x7f
  411d50:	39006420 	strb	w0, [x1, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411d54:	9100c2a0 	add	x0, x21, #0x30
  411d58:	97fffa6b 	bl	410704 <z_priq_dumb_remove>
	}
	queue_thread(_current);
  411d5c:	f9400ab3 	ldr	x19, [x21, #16]
	thread->base.thread_state |= _THREAD_QUEUED;
  411d60:	39406660 	ldrb	w0, [x19, #25]
  411d64:	32196000 	orr	w0, w0, #0xffffff80
  411d68:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411d6c:	d00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  411d70:	f946fc00 	ldr	x0, [x0, #3576]
  411d74:	eb00027f 	cmp	x19, x0
  411d78:	540001e1 	b.ne	411db4 <z_impl_k_yield+0x15c>  // b.any
  411d7c:	b0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  411d80:	910f2a73 	add	x19, x19, #0x3ca
  411d84:	aa1303e2 	mov	x2, x19
  411d88:	52801783 	mov	w3, #0xbc                  	// #188
  411d8c:	b0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  411d90:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411d94:	91178421 	add	x1, x1, #0x5e1
  411d98:	911a8800 	add	x0, x0, #0x6a2
  411d9c:	97ffd737 	bl	407a78 <assert_print>
  411da0:	aa1303e0 	mov	x0, x19
  411da4:	52801781 	mov	w1, #0xbc                  	// #188
  411da8:	97ffd75e 	bl	407b20 <assert_post_action>
  411dac:	52801782 	mov	w2, #0xbc                  	// #188
  411db0:	17ffffc4 	b	411cc0 <z_impl_k_yield+0x68>
	return list->head == list;
  411db4:	aa1503e0 	mov	x0, x21
  411db8:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411dbc:	eb00029f 	cmp	x20, x0
  411dc0:	54000481 	b.ne	411e50 <z_impl_k_yield+0x1f8>  // b.any
	sys_dnode_t *const tail = list->tail;
  411dc4:	f9472ec1 	ldr	x1, [x22, #3672]
	node->next = list;
  411dc8:	9100c022 	add	x2, x1, #0x30
	sys_dnode_t *const tail = list->tail;
  411dcc:	f9401c20 	ldr	x0, [x1, #56]
	node->prev = tail;
  411dd0:	a9000262 	stp	x2, x0, [x19]
	tail->next = node;
  411dd4:	f9000013 	str	x19, [x0]
	list->tail = node;
  411dd8:	f9001c33 	str	x19, [x1, #56]
	update_cache(1);
  411ddc:	52800020 	mov	w0, #0x1                   	// #1
  411de0:	97fffad1 	bl	410924 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411de4:	f947caf7 	ldr	x23, [x23, #3984]
  411de8:	aa1703e0 	mov	x0, x23
  411dec:	97fff1f2 	bl	40e5b4 <z_spin_unlock_valid>
  411df0:	72001c1f 	tst	w0, #0xff
  411df4:	54000441 	b.ne	411e7c <z_impl_k_yield+0x224>  // b.any
  411df8:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  411dfc:	912faa73 	add	x19, x19, #0xbea
  411e00:	aa1303e2 	mov	x2, x19
  411e04:	52801c43 	mov	w3, #0xe2                  	// #226
  411e08:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411e0c:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411e10:	91311021 	add	x1, x1, #0xc44
  411e14:	911a8800 	add	x0, x0, #0x6a2
  411e18:	97ffd718 	bl	407a78 <assert_print>
  411e1c:	aa1703e1 	mov	x1, x23
  411e20:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411e24:	91316c00 	add	x0, x0, #0xc5b
  411e28:	97ffd714 	bl	407a78 <assert_print>
  411e2c:	aa1303e0 	mov	x0, x19
  411e30:	52801c41 	mov	w1, #0xe2                  	// #226
  411e34:	97ffd73b 	bl	407b20 <assert_post_action>
  411e38:	52801c42 	mov	w2, #0xe2                  	// #226
  411e3c:	17ffffa1 	b	411cc0 <z_impl_k_yield+0x68>
	return (node == list->tail) ? NULL : node->next;
  411e40:	f9401ea0 	ldr	x0, [x21, #56]
  411e44:	eb14001f 	cmp	x0, x20
  411e48:	54fffbe0 	b.eq	411dc4 <z_impl_k_yield+0x16c>  // b.none
  411e4c:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  411e50:	b4fffbb4 	cbz	x20, 411dc4 <z_impl_k_yield+0x16c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  411e54:	aa1403e1 	mov	x1, x20
  411e58:	aa1303e0 	mov	x0, x19
  411e5c:	97fff901 	bl	410260 <z_sched_prio_cmp>
  411e60:	7100001f 	cmp	w0, #0x0
  411e64:	54fffeed 	b.le	411e40 <z_impl_k_yield+0x1e8>
	sys_dnode_t *const prev = successor->prev;
  411e68:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  411e6c:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  411e70:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411e74:	f9000693 	str	x19, [x20, #8]
}
  411e78:	17ffffd9 	b	411ddc <z_impl_k_yield+0x184>
  411e7c:	2a1803e0 	mov	w0, w24
	z_swap(&sched_spinlock, key);
}
  411e80:	a94153f3 	ldp	x19, x20, [sp, #16]
  411e84:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411e88:	a94363f7 	ldp	x23, x24, [sp, #48]
  411e8c:	f94023f9 	ldr	x25, [sp, #64]
  411e90:	a8c57bfd 	ldp	x29, x30, [sp], #80
  411e94:	17ffdcd5 	b	4091e8 <arch_swap>

0000000000411e98 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
  411e98:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  411e9c:	910003fd 	mov	x29, sp
  411ea0:	a90153f3 	stp	x19, x20, [sp, #16]
  411ea4:	d00000d4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  411ea8:	a9025bf5 	stp	x21, x22, [sp, #32]
  411eac:	aa0003f6 	mov	x22, x0
  411eb0:	f9472e80 	ldr	x0, [x20, #3672]
  411eb4:	f9001bf7 	str	x23, [sp, #48]
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
  411eb8:	b9400000 	ldr	w0, [x0]
  411ebc:	340002a0 	cbz	w0, 411f10 <z_tick_sleep+0x78>
  411ec0:	b0000033 	adrp	x19, 416000 <__func__.0+0xc27>
  411ec4:	910f2a73 	add	x19, x19, #0x3ca
  411ec8:	aa1303e2 	mov	x2, x19
  411ecc:	b0000021 	adrp	x1, 416000 <__func__.0+0xc27>
  411ed0:	9104f021 	add	x1, x1, #0x13c
  411ed4:	5280b1a3 	mov	w3, #0x58d                 	// #1421
  411ed8:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411edc:	911a8800 	add	x0, x0, #0x6a2
  411ee0:	97ffd6e6 	bl	407a78 <assert_print>
  411ee4:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411ee8:	91320400 	add	x0, x0, #0xc81
  411eec:	97ffd6e3 	bl	407a78 <assert_print>
  411ef0:	aa1303e0 	mov	x0, x19
  411ef4:	5280b1a1 	mov	w1, #0x58d                 	// #1421
  411ef8:	97ffd70a 	bl	407b20 <assert_post_action>
  411efc:	5280b1a2 	mov	w2, #0x58d                 	// #1421
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411f00:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411f04:	aa1303e1 	mov	x1, x19
  411f08:	911b8000 	add	x0, x0, #0x6e0
  411f0c:	97ffe0f7 	bl	40a2e8 <posix_print_error_and_exit>

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
  411f10:	b5000116 	cbnz	x22, 411f30 <z_tick_sleep+0x98>
	z_impl_k_yield();
  411f14:	97ffff51 	bl	411c58 <z_impl_k_yield>
		k_yield();
		return 0;
  411f18:	52800000 	mov	w0, #0x0                   	// #0
		return ticks;
	}
#endif

	return 0;
}
  411f1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411f20:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411f24:	f9401bf7 	ldr	x23, [sp, #48]
  411f28:	a8c47bfd 	ldp	x29, x30, [sp], #64
  411f2c:	d65f03c0 	ret
	if (Z_TICK_ABS(ticks) <= 0) {
  411f30:	b1000adf 	cmn	x22, #0x2
  411f34:	540003ab 	b.lt	411fa8 <z_tick_sleep+0x110>  // b.tstop
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
  411f38:	940003fe 	bl	412f30 <sys_clock_tick_get_32>
  411f3c:	0b160013 	add	w19, w0, w22
  411f40:	d00000d5 	adrp	x21, 42b000 <__FRAME_END__+0x1007c>
  411f44:	97ffdfd3 	bl	409e90 <posix_irq_lock>
  411f48:	2a0003f7 	mov	w23, w0
  411f4c:	f947cab5 	ldr	x21, [x21, #3984]
  411f50:	aa1503e0 	mov	x0, x21
  411f54:	97fff18d 	bl	40e588 <z_spin_lock_valid>
  411f58:	72001c1f 	tst	w0, #0xff
  411f5c:	540002c1 	b.ne	411fb4 <z_tick_sleep+0x11c>  // b.any
  411f60:	90000033 	adrp	x19, 415000 <random_data+0xd8c>
  411f64:	912faa73 	add	x19, x19, #0xbea
  411f68:	aa1303e2 	mov	x2, x19
  411f6c:	52801283 	mov	w3, #0x94                  	// #148
  411f70:	90000021 	adrp	x1, 415000 <random_data+0xd8c>
  411f74:	f0000000 	adrp	x0, 414000 <__func__.1+0xd>
  411f78:	91305c21 	add	x1, x1, #0xc17
  411f7c:	911a8800 	add	x0, x0, #0x6a2
  411f80:	97ffd6be 	bl	407a78 <assert_print>
  411f84:	aa1503e1 	mov	x1, x21
  411f88:	90000020 	adrp	x0, 415000 <random_data+0xd8c>
  411f8c:	9130b000 	add	x0, x0, #0xc2c
  411f90:	97ffd6ba 	bl	407a78 <assert_print>
  411f94:	aa1303e0 	mov	x0, x19
  411f98:	52801281 	mov	w1, #0x94                  	// #148
  411f9c:	97ffd6e1 	bl	407b20 <assert_post_action>
  411fa0:	52801282 	mov	w2, #0x94                  	// #148
  411fa4:	17ffffd7 	b	411f00 <z_tick_sleep+0x68>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
  411fa8:	12800033 	mov	w19, #0xfffffffe            	// #-2
  411fac:	4b160273 	sub	w19, w19, w22
  411fb0:	17ffffe4 	b	411f40 <z_tick_sleep+0xa8>
	z_spin_lock_set_owner(l);
  411fb4:	aa1503e0 	mov	x0, x21
  411fb8:	97fff18c 	bl	40e5e8 <z_spin_lock_set_owner>
	unready_thread(_current);
  411fbc:	f9472e94 	ldr	x20, [x20, #3672]
  411fc0:	f9400a80 	ldr	x0, [x20, #16]
  411fc4:	97fffc58 	bl	411124 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  411fc8:	d00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  411fcc:	aa1603e2 	mov	x2, x22
	z_add_thread_timeout(_current, timeout);
  411fd0:	f9400a80 	ldr	x0, [x20, #16]
  411fd4:	f9472421 	ldr	x1, [x1, #3656]
  411fd8:	9100a000 	add	x0, x0, #0x28
  411fdc:	94000239 	bl	4128c0 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
  411fe0:	f9400a82 	ldr	x2, [x20, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411fe4:	aa1503e0 	mov	x0, x21
  411fe8:	39406441 	ldrb	w1, [x2, #25]
  411fec:	321c0021 	orr	w1, w1, #0x10
  411ff0:	39006441 	strb	w1, [x2, #25]
  411ff4:	97fff170 	bl	40e5b4 <z_spin_unlock_valid>
  411ff8:	72001c1f 	tst	w0, #0xff
  411ffc:	54000261 	b.ne	412048 <z_tick_sleep+0x1b0>  // b.any
  412000:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412004:	912faa73 	add	x19, x19, #0xbea
  412008:	aa1303e2 	mov	x2, x19
  41200c:	52801c43 	mov	w3, #0xe2                  	// #226
  412010:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412014:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412018:	91311021 	add	x1, x1, #0xc44
  41201c:	911a8800 	add	x0, x0, #0x6a2
  412020:	97ffd696 	bl	407a78 <assert_print>
  412024:	aa1503e1 	mov	x1, x21
  412028:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  41202c:	91316c00 	add	x0, x0, #0xc5b
  412030:	97ffd692 	bl	407a78 <assert_print>
  412034:	aa1303e0 	mov	x0, x19
  412038:	52801c41 	mov	w1, #0xe2                  	// #226
  41203c:	97ffd6b9 	bl	407b20 <assert_post_action>
  412040:	52801c42 	mov	w2, #0xe2                  	// #226
  412044:	17ffffaf 	b	411f00 <z_tick_sleep+0x68>
  412048:	2a1703e0 	mov	w0, w23
  41204c:	97ffdc67 	bl	4091e8 <arch_swap>
	return (thread->base.thread_state & state) != 0U;
  412050:	f9400a80 	ldr	x0, [x20, #16]
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
  412054:	39406400 	ldrb	w0, [x0, #25]
  412058:	36200240 	tbz	w0, #4, 4120a0 <z_tick_sleep+0x208>
  41205c:	90000033 	adrp	x19, 416000 <__func__.0+0xc27>
  412060:	910f2a73 	add	x19, x19, #0x3ca
  412064:	aa1303e2 	mov	x2, x19
  412068:	90000021 	adrp	x1, 416000 <__func__.0+0xc27>
  41206c:	911aa021 	add	x1, x1, #0x6a8
  412070:	5280b523 	mov	w3, #0x5a9                 	// #1449
  412074:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412078:	911a8800 	add	x0, x0, #0x6a2
  41207c:	97ffd67f 	bl	407a78 <assert_print>
  412080:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412084:	91320400 	add	x0, x0, #0xc81
  412088:	97ffd67c 	bl	407a78 <assert_print>
  41208c:	aa1303e0 	mov	x0, x19
  412090:	5280b521 	mov	w1, #0x5a9                 	// #1449
  412094:	97ffd6a3 	bl	407b20 <assert_post_action>
  412098:	5280b522 	mov	w2, #0x5a9                 	// #1449
  41209c:	17ffff99 	b	411f00 <z_tick_sleep+0x68>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
  4120a0:	940003a4 	bl	412f30 <sys_clock_tick_get_32>
  4120a4:	cb204260 	sub	x0, x19, w0, uxtw
		return ticks;
  4120a8:	f100001f 	cmp	x0, #0x0
  4120ac:	1a9fc000 	csel	w0, w0, wzr, gt
  4120b0:	17ffff9b 	b	411f1c <z_tick_sleep+0x84>

00000000004120b4 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
  4120b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4120b8:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4120bc:	910003fd 	mov	x29, sp
  4120c0:	f9472c21 	ldr	x1, [x1, #3672]
  4120c4:	f9000bf3 	str	x19, [sp, #16]
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
  4120c8:	b9400022 	ldr	w2, [x1]
  4120cc:	340002a2 	cbz	w2, 412120 <z_impl_k_sleep+0x6c>
  4120d0:	90000033 	adrp	x19, 416000 <__func__.0+0xc27>
  4120d4:	910f2a73 	add	x19, x19, #0x3ca
  4120d8:	aa1303e2 	mov	x2, x19
  4120dc:	90000021 	adrp	x1, 416000 <__func__.0+0xc27>
  4120e0:	9104f021 	add	x1, x1, #0x13c
  4120e4:	5280b703 	mov	w3, #0x5b8                 	// #1464
  4120e8:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4120ec:	911a8800 	add	x0, x0, #0x6a2
  4120f0:	97ffd662 	bl	407a78 <assert_print>
  4120f4:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  4120f8:	91320400 	add	x0, x0, #0xc81
  4120fc:	97ffd65f 	bl	407a78 <assert_print>
  412100:	aa1303e0 	mov	x0, x19
  412104:	5280b701 	mov	w1, #0x5b8                 	// #1464
  412108:	97ffd686 	bl	407b20 <assert_post_action>
  41210c:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412110:	aa1303e1 	mov	x1, x19
  412114:	911b8000 	add	x0, x0, #0x6e0
  412118:	5280b702 	mov	w2, #0x5b8                 	// #1464
  41211c:	97ffe073 	bl	40a2e8 <posix_print_error_and_exit>
  412120:	aa0003f3 	mov	x19, x0

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  412124:	b100041f 	cmn	x0, #0x1
  412128:	540000e1 	b.ne	412144 <z_impl_k_sleep+0x90>  // b.any
		k_thread_suspend(_current);
  41212c:	f9400820 	ldr	x0, [x1, #16]
	z_impl_k_thread_suspend(thread);
  412130:	97fffd58 	bl	411690 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
  412134:	2a1303e0 	mov	w0, w19
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
  412138:	f9400bf3 	ldr	x19, [sp, #16]
  41213c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412140:	d65f03c0 	ret
	ticks = z_tick_sleep(ticks);
  412144:	97ffff55 	bl	411e98 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
  412148:	52800141 	mov	w1, #0xa                   	// #10
  41214c:	1b017c00 	mul	w0, w0, w1
	return ret;
  412150:	17fffffa 	b	412138 <z_impl_k_sleep+0x84>

0000000000412154 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
  412154:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  412158:	f9472c00 	ldr	x0, [x0, #3672]
  41215c:	f9400800 	ldr	x0, [x0, #16]
  412160:	d65f03c0 	ret

0000000000412164 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
  412164:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412168:	910003fd 	mov	x29, sp
  41216c:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412170:	b00000d4 	adrp	x20, 42b000 <__FRAME_END__+0x1007c>
  412174:	aa0003f3 	mov	x19, x0
  412178:	a9025bf5 	stp	x21, x22, [sp, #32]
  41217c:	f9001bf7 	str	x23, [sp, #48]
  412180:	97ffdf44 	bl	409e90 <posix_irq_lock>
  412184:	f947ca96 	ldr	x22, [x20, #3984]
  412188:	2a0003f5 	mov	w21, w0
  41218c:	aa1603e0 	mov	x0, x22
  412190:	97fff0fe 	bl	40e588 <z_spin_lock_valid>
  412194:	72001c1f 	tst	w0, #0xff
  412198:	540002c1 	b.ne	4121f0 <z_thread_abort+0x8c>  // b.any
  41219c:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  4121a0:	912faa73 	add	x19, x19, #0xbea
  4121a4:	aa1303e2 	mov	x2, x19
  4121a8:	52801283 	mov	w3, #0x94                  	// #148
  4121ac:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  4121b0:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4121b4:	91305c21 	add	x1, x1, #0xc17
  4121b8:	911a8800 	add	x0, x0, #0x6a2
  4121bc:	97ffd62f 	bl	407a78 <assert_print>
  4121c0:	aa1603e1 	mov	x1, x22
  4121c4:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  4121c8:	9130b000 	add	x0, x0, #0xc2c
  4121cc:	97ffd62b 	bl	407a78 <assert_print>
  4121d0:	aa1303e0 	mov	x0, x19
  4121d4:	52801281 	mov	w1, #0x94                  	// #148
  4121d8:	97ffd652 	bl	407b20 <assert_post_action>
  4121dc:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4121e0:	aa1303e1 	mov	x1, x19
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
  4121e4:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4121e8:	911b8000 	add	x0, x0, #0x6e0
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
  4121ec:	97ffe03f 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4121f0:	aa1603e0 	mov	x0, x22
  4121f4:	97fff0fd 	bl	40e5e8 <z_spin_lock_set_owner>
	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
  4121f8:	39406260 	ldrb	w0, [x19, #24]
  4121fc:	36000580 	tbz	w0, #0, 4122ac <z_thread_abort+0x148>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412200:	aa1603e0 	mov	x0, x22
  412204:	97fff0ec 	bl	40e5b4 <z_spin_unlock_valid>
  412208:	72001c1f 	tst	w0, #0xff
  41220c:	54000261 	b.ne	412258 <z_thread_abort+0xf4>  // b.any
  412210:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412214:	912faa73 	add	x19, x19, #0xbea
  412218:	aa1303e2 	mov	x2, x19
  41221c:	52801863 	mov	w3, #0xc3                  	// #195
  412220:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412224:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412228:	91311021 	add	x1, x1, #0xc44
  41222c:	911a8800 	add	x0, x0, #0x6a2
  412230:	97ffd612 	bl	407a78 <assert_print>
  412234:	f947ca81 	ldr	x1, [x20, #3984]
  412238:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  41223c:	91316c00 	add	x0, x0, #0xc5b
  412240:	97ffd60e 	bl	407a78 <assert_print>
  412244:	aa1303e0 	mov	x0, x19
  412248:	52801861 	mov	w1, #0xc3                  	// #195
  41224c:	97ffd635 	bl	407b20 <assert_post_action>
  412250:	52801862 	mov	w2, #0xc3                  	// #195
  412254:	17ffffe3 	b	4121e0 <z_thread_abort+0x7c>
	posix_irq_unlock(key);
  412258:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborting essential thread %p", thread);
  41225c:	90000034 	adrp	x20, 416000 <__func__.0+0xc27>
  412260:	97ffdf0e 	bl	409e98 <posix_irq_unlock>
  412264:	910f2a94 	add	x20, x20, #0x3ca
  412268:	aa1403e2 	mov	x2, x20
  41226c:	5280d9c3 	mov	w3, #0x6ce                 	// #1742
  412270:	90000021 	adrp	x1, 416000 <__func__.0+0xc27>
  412274:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412278:	911f5821 	add	x1, x1, #0x7d6
  41227c:	911a8800 	add	x0, x0, #0x6a2
  412280:	97ffd5fe 	bl	407a78 <assert_print>
  412284:	aa1303e1 	mov	x1, x19
  412288:	90000020 	adrp	x0, 416000 <__func__.0+0xc27>
  41228c:	911ba000 	add	x0, x0, #0x6e8
  412290:	97ffd5fa 	bl	407a78 <assert_print>
  412294:	5280d9c1 	mov	w1, #0x6ce                 	// #1742
  412298:	aa1403e0 	mov	x0, x20
  41229c:	97ffd621 	bl	407b20 <assert_post_action>
  4122a0:	aa1403e1 	mov	x1, x20
  4122a4:	5280d9c2 	mov	w2, #0x6ce                 	// #1742
  4122a8:	17ffffcf 	b	4121e4 <z_thread_abort+0x80>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  4122ac:	39406661 	ldrb	w1, [x19, #25]
  4122b0:	36180161 	tbz	w1, #3, 4122dc <z_thread_abort+0x178>
  4122b4:	aa1603e0 	mov	x0, x22
  4122b8:	97fff0bf 	bl	40e5b4 <z_spin_unlock_valid>
  4122bc:	72001c1f 	tst	w0, #0xff
  4122c0:	54fffa80 	b.eq	412210 <z_thread_abort+0xac>  // b.none
  4122c4:	2a1503e0 	mov	w0, w21
	}
	k_spin_unlock(&sched_spinlock, key);
}
  4122c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4122cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4122d0:	f9401bf7 	ldr	x23, [sp, #48]
  4122d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4122d8:	17ffdef0 	b	409e98 <posix_irq_unlock>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  4122dc:	121a7820 	and	w0, w1, #0xffffffdf
  4122e0:	321d0002 	orr	w2, w0, #0x8
		if (z_is_thread_queued(thread)) {
  4122e4:	37380600 	tbnz	w0, #7, 4123a4 <z_thread_abort+0x240>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  4122e8:	39006662 	strb	w2, [x19, #25]
		if (thread->base.pended_on != NULL) {
  4122ec:	f9400a60 	ldr	x0, [x19, #16]
  4122f0:	b4000060 	cbz	x0, 4122fc <z_thread_abort+0x198>
			unpend_thread_no_timeout(thread);
  4122f4:	aa1303e0 	mov	x0, x19
  4122f8:	97fff920 	bl	410778 <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  4122fc:	91018277 	add	x23, x19, #0x60
	return z_abort_timeout(&thread->base.timeout);
  412300:	9100a260 	add	x0, x19, #0x28
  412304:	94000201 	bl	412b08 <z_abort_timeout>
	return list->head == list;
  412308:	f9403276 	ldr	x22, [x19, #96]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  41230c:	eb1702df 	cmp	x22, x23
  412310:	54000040 	b.eq	412318 <z_thread_abort+0x1b4>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  412314:	b50005d6 	cbnz	x22, 4123cc <z_thread_abort+0x268>
		update_cache(1);
  412318:	52800020 	mov	w0, #0x1                   	// #1
  41231c:	97fff982 	bl	410924 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
  412320:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  412324:	f9472c00 	ldr	x0, [x0, #3672]
  412328:	f9400801 	ldr	x1, [x0, #16]
  41232c:	eb13003f 	cmp	x1, x19
  412330:	54000821 	b.ne	412434 <z_thread_abort+0x2d0>  // b.any
  412334:	b9400000 	ldr	w0, [x0]
  412338:	350007e0 	cbnz	w0, 412434 <z_thread_abort+0x2d0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41233c:	f947ca94 	ldr	x20, [x20, #3984]
  412340:	d0000017 	adrp	x23, 414000 <__func__.1+0xd>
  412344:	d0000016 	adrp	x22, 414000 <__func__.1+0xd>
  412348:	aa1403e0 	mov	x0, x20
  41234c:	97fff09a 	bl	40e5b4 <z_spin_unlock_valid>
  412350:	72001c1f 	tst	w0, #0xff
  412354:	540004c1 	b.ne	4123ec <z_thread_abort+0x288>  // b.any
  412358:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  41235c:	912faa73 	add	x19, x19, #0xbea
  412360:	aa1303e2 	mov	x2, x19
  412364:	52801c43 	mov	w3, #0xe2                  	// #226
  412368:	911a8ae0 	add	x0, x23, #0x6a2
  41236c:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412370:	91311021 	add	x1, x1, #0xc44
  412374:	97ffd5c1 	bl	407a78 <assert_print>
  412378:	aa1403e1 	mov	x1, x20
  41237c:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412380:	91316c00 	add	x0, x0, #0xc5b
  412384:	97ffd5bd 	bl	407a78 <assert_print>
  412388:	aa1303e0 	mov	x0, x19
  41238c:	52801c41 	mov	w1, #0xe2                  	// #226
  412390:	97ffd5e4 	bl	407b20 <assert_post_action>
  412394:	52801c42 	mov	w2, #0xe2                  	// #226
		__ASSERT(false, "aborted _current back from dead");
  412398:	aa1303e1 	mov	x1, x19
  41239c:	911b82c0 	add	x0, x22, #0x6e0
  4123a0:	17ffff93 	b	4121ec <z_thread_abort+0x88>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4123a4:	52800be0 	mov	w0, #0x5f                  	// #95
  4123a8:	0a000021 	and	w1, w1, w0
	_priq_run_remove(thread_runq(thread), thread);
  4123ac:	b00000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4123b0:	321d0021 	orr	w1, w1, #0x8
  4123b4:	39006661 	strb	w1, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4123b8:	aa1303e1 	mov	x1, x19
  4123bc:	f9472c00 	ldr	x0, [x0, #3672]
  4123c0:	9100c000 	add	x0, x0, #0x30
  4123c4:	97fff8d0 	bl	410704 <z_priq_dumb_remove>
}
  4123c8:	17ffffc9 	b	4122ec <z_thread_abort+0x188>
		unpend_thread_no_timeout(thread);
  4123cc:	aa1603e0 	mov	x0, x22
  4123d0:	97fff8ea 	bl	410778 <unpend_thread_no_timeout>
  4123d4:	9100a2c0 	add	x0, x22, #0x28
  4123d8:	940001cc 	bl	412b08 <z_abort_timeout>
	thread->callee_saved.retval = value;
  4123dc:	b9004edf 	str	wzr, [x22, #76]
		ready_thread(thread);
  4123e0:	aa1603e0 	mov	x0, x22
  4123e4:	97fffa21 	bl	410c68 <ready_thread>
  4123e8:	17ffffc8 	b	412308 <z_thread_abort+0x1a4>
  4123ec:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborted _current back from dead");
  4123f0:	90000033 	adrp	x19, 416000 <__func__.0+0xc27>
  4123f4:	97ffdb7d 	bl	4091e8 <arch_swap>
  4123f8:	910f2a73 	add	x19, x19, #0x3ca
  4123fc:	aa1303e2 	mov	x2, x19
  412400:	90000021 	adrp	x1, 416000 <__func__.0+0xc27>
  412404:	911f5821 	add	x1, x1, #0x7d6
  412408:	5280e083 	mov	w3, #0x704                 	// #1796
  41240c:	911a8ae0 	add	x0, x23, #0x6a2
  412410:	97ffd59a 	bl	407a78 <assert_print>
  412414:	90000020 	adrp	x0, 416000 <__func__.0+0xc27>
  412418:	911c1c00 	add	x0, x0, #0x707
  41241c:	97ffd597 	bl	407a78 <assert_print>
  412420:	aa1303e0 	mov	x0, x19
  412424:	5280e081 	mov	w1, #0x704                 	// #1796
  412428:	97ffd5be 	bl	407b20 <assert_post_action>
  41242c:	5280e082 	mov	w2, #0x704                 	// #1796
  412430:	17ffffda 	b	412398 <z_thread_abort+0x234>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412434:	f947ca80 	ldr	x0, [x20, #3984]
  412438:	17ffffa0 	b	4122b8 <z_thread_abort+0x154>

000000000041243c <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
  41243c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412440:	910003fd 	mov	x29, sp
  412444:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412448:	b00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  41244c:	aa0003f4 	mov	x20, x0
  412450:	a9025bf5 	stp	x21, x22, [sp, #32]
  412454:	aa0103f5 	mov	x21, x1
  412458:	f9001bf7 	str	x23, [sp, #48]
	return posix_irq_lock();
  41245c:	97ffde8d 	bl	409e90 <posix_irq_lock>
  412460:	f947ca76 	ldr	x22, [x19, #3984]
  412464:	2a0003f7 	mov	w23, w0
  412468:	aa1603e0 	mov	x0, x22
  41246c:	97fff047 	bl	40e588 <z_spin_lock_valid>
  412470:	72001c1f 	tst	w0, #0xff
  412474:	540002c1 	b.ne	4124cc <z_impl_k_thread_join+0x90>  // b.any
  412478:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  41247c:	912faa73 	add	x19, x19, #0xbea
  412480:	aa1303e2 	mov	x2, x19
  412484:	52801283 	mov	w3, #0x94                  	// #148
  412488:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  41248c:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412490:	91305c21 	add	x1, x1, #0xc17
  412494:	911a8800 	add	x0, x0, #0x6a2
  412498:	97ffd578 	bl	407a78 <assert_print>
  41249c:	aa1603e1 	mov	x1, x22
  4124a0:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  4124a4:	9130b000 	add	x0, x0, #0xc2c
  4124a8:	97ffd574 	bl	407a78 <assert_print>
  4124ac:	aa1303e0 	mov	x0, x19
  4124b0:	52801281 	mov	w1, #0x94                  	// #148
  4124b4:	97ffd59b 	bl	407b20 <assert_post_action>
  4124b8:	52801282 	mov	w2, #0x94                  	// #148
		ret = -EBUSY;
	} else if ((thread == _current) ||
		   (thread->base.pended_on == &_current->join_queue)) {
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  4124bc:	aa1303e1 	mov	x1, x19
  4124c0:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4124c4:	911b8000 	add	x0, x0, #0x6e0
  4124c8:	97ffdf88 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4124cc:	aa1603e0 	mov	x0, x22
  4124d0:	97fff046 	bl	40e5e8 <z_spin_lock_set_owner>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  4124d4:	39406680 	ldrb	w0, [x20, #25]
  4124d8:	371808c0 	tbnz	w0, #3, 4125f0 <z_impl_k_thread_join+0x1b4>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  4124dc:	b4000bb5 	cbz	x21, 412650 <z_impl_k_thread_join+0x214>
	} else if ((thread == _current) ||
  4124e0:	b00000d6 	adrp	x22, 42b000 <__FRAME_END__+0x1007c>
  4124e4:	f9472ed6 	ldr	x22, [x22, #3672]
  4124e8:	f9400ac0 	ldr	x0, [x22, #16]
  4124ec:	eb14001f 	cmp	x0, x20
  4124f0:	54000b40 	b.eq	412658 <z_impl_k_thread_join+0x21c>  // b.none
  4124f4:	f9400a82 	ldr	x2, [x20, #16]
		   (thread->base.pended_on == &_current->join_queue)) {
  4124f8:	91018001 	add	x1, x0, #0x60
	} else if ((thread == _current) ||
  4124fc:	eb01005f 	cmp	x2, x1
  412500:	54000ac0 	b.eq	412658 <z_impl_k_thread_join+0x21c>  // b.none
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  412504:	b94002c1 	ldr	w1, [x22]
  412508:	34000241 	cbz	w1, 412550 <z_impl_k_thread_join+0x114>
  41250c:	90000033 	adrp	x19, 416000 <__func__.0+0xc27>
  412510:	910f2a73 	add	x19, x19, #0x3ca
  412514:	aa1303e2 	mov	x2, x19
  412518:	90000021 	adrp	x1, 416000 <__func__.0+0xc27>
  41251c:	9104f021 	add	x1, x1, #0x13c
  412520:	5280e483 	mov	w3, #0x724                 	// #1828
  412524:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412528:	911a8800 	add	x0, x0, #0x6a2
  41252c:	97ffd553 	bl	407a78 <assert_print>
  412530:	90000020 	adrp	x0, 416000 <__func__.0+0xc27>
  412534:	911ca400 	add	x0, x0, #0x729
  412538:	97ffd550 	bl	407a78 <assert_print>
  41253c:	aa1303e0 	mov	x0, x19
  412540:	5280e481 	mov	w1, #0x724                 	// #1828
  412544:	97ffd577 	bl	407b20 <assert_post_action>
  412548:	5280e482 	mov	w2, #0x724                 	// #1828
  41254c:	17ffffdc 	b	4124bc <z_impl_k_thread_join+0x80>
		add_to_waitq_locked(_current, &thread->join_queue);
  412550:	91018281 	add	x1, x20, #0x60
  412554:	97fffb09 	bl	411178 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  412558:	b10006bf 	cmn	x21, #0x1
  41255c:	540000e0 	b.eq	412578 <z_impl_k_thread_join+0x13c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  412560:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  412564:	aa1503e2 	mov	x2, x21
		add_thread_timeout(_current, timeout);
  412568:	f9400ac0 	ldr	x0, [x22, #16]
  41256c:	f9472421 	ldr	x1, [x1, #3656]
  412570:	9100a000 	add	x0, x0, #0x28
  412574:	940000d3 	bl	4128c0 <z_add_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412578:	f947ca73 	ldr	x19, [x19, #3984]
  41257c:	aa1303e0 	mov	x0, x19
  412580:	97fff00d 	bl	40e5b4 <z_spin_unlock_valid>
  412584:	72001c1f 	tst	w0, #0xff
  412588:	54000281 	b.ne	4125d8 <z_impl_k_thread_join+0x19c>  // b.any
  41258c:	f0000014 	adrp	x20, 415000 <random_data+0xd8c>
  412590:	912faa94 	add	x20, x20, #0xbea
  412594:	aa1403e2 	mov	x2, x20
  412598:	52801c43 	mov	w3, #0xe2                  	// #226
  41259c:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  4125a0:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4125a4:	91311021 	add	x1, x1, #0xc44
  4125a8:	911a8800 	add	x0, x0, #0x6a2
  4125ac:	97ffd533 	bl	407a78 <assert_print>
  4125b0:	aa1303e1 	mov	x1, x19
  4125b4:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  4125b8:	91316c00 	add	x0, x0, #0xc5b
  4125bc:	97ffd52f 	bl	407a78 <assert_print>
  4125c0:	aa1403e0 	mov	x0, x20
  4125c4:	52801c41 	mov	w1, #0xe2                  	// #226
  4125c8:	97ffd556 	bl	407b20 <assert_post_action>
  4125cc:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4125d0:	aa1403e1 	mov	x1, x20
  4125d4:	17ffffbb 	b	4124c0 <z_impl_k_thread_join+0x84>
  4125d8:	2a1703e0 	mov	w0, w23

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
  4125dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4125e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4125e4:	f9401bf7 	ldr	x23, [sp, #48]
  4125e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4125ec:	17ffdaff 	b	4091e8 <arch_swap>
		ret = 0;
  4125f0:	52800014 	mov	w20, #0x0                   	// #0
  4125f4:	f947ca73 	ldr	x19, [x19, #3984]
  4125f8:	aa1303e0 	mov	x0, x19
  4125fc:	97ffefee 	bl	40e5b4 <z_spin_unlock_valid>
  412600:	72001c1f 	tst	w0, #0xff
  412604:	540002e1 	b.ne	412660 <z_impl_k_thread_join+0x224>  // b.any
  412608:	f0000014 	adrp	x20, 415000 <random_data+0xd8c>
  41260c:	912faa94 	add	x20, x20, #0xbea
  412610:	aa1403e2 	mov	x2, x20
  412614:	52801863 	mov	w3, #0xc3                  	// #195
  412618:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  41261c:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412620:	91311021 	add	x1, x1, #0xc44
  412624:	911a8800 	add	x0, x0, #0x6a2
  412628:	97ffd514 	bl	407a78 <assert_print>
  41262c:	aa1303e1 	mov	x1, x19
  412630:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412634:	91316c00 	add	x0, x0, #0xc5b
  412638:	97ffd510 	bl	407a78 <assert_print>
  41263c:	aa1403e0 	mov	x0, x20
  412640:	52801861 	mov	w1, #0xc3                  	// #195
  412644:	97ffd537 	bl	407b20 <assert_post_action>
  412648:	52801862 	mov	w2, #0xc3                  	// #195
  41264c:	17ffffe1 	b	4125d0 <z_impl_k_thread_join+0x194>
		ret = -EBUSY;
  412650:	128001f4 	mov	w20, #0xfffffff0            	// #-16
  412654:	17ffffe8 	b	4125f4 <z_impl_k_thread_join+0x1b8>
		ret = -EDEADLK;
  412658:	12800454 	mov	w20, #0xffffffdd            	// #-35
  41265c:	17ffffe6 	b	4125f4 <z_impl_k_thread_join+0x1b8>
	posix_irq_unlock(key);
  412660:	2a1703e0 	mov	w0, w23
  412664:	97ffde0d 	bl	409e98 <posix_irq_unlock>
}
  412668:	2a1403e0 	mov	w0, w20
  41266c:	a94153f3 	ldp	x19, x20, [sp, #16]
  412670:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412674:	f9401bf7 	ldr	x23, [sp, #48]
  412678:	a8c47bfd 	ldp	x29, x30, [sp], #64
  41267c:	d65f03c0 	ret

0000000000412680 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
  412680:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  412684:	910003fd 	mov	x29, sp
  412688:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41268c:	b00000d3 	adrp	x19, 42b000 <__FRAME_END__+0x1007c>
  412690:	aa0003f4 	mov	x20, x0
  412694:	a9025bf5 	stp	x21, x22, [sp, #32]
  412698:	a90363f7 	stp	x23, x24, [sp, #48]
  41269c:	2a0103f8 	mov	w24, w1
  4126a0:	aa0203f7 	mov	x23, x2
  4126a4:	f90023f9 	str	x25, [sp, #64]
	return posix_irq_lock();
  4126a8:	97ffddfa 	bl	409e90 <posix_irq_lock>
  4126ac:	f947ca79 	ldr	x25, [x19, #3984]
  4126b0:	2a0003f6 	mov	w22, w0
  4126b4:	aa1903e0 	mov	x0, x25
  4126b8:	97ffefb4 	bl	40e588 <z_spin_lock_valid>
  4126bc:	72001c15 	ands	w21, w0, #0xff
  4126c0:	540002c1 	b.ne	412718 <z_sched_wake+0x98>  // b.any
  4126c4:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  4126c8:	912faa73 	add	x19, x19, #0xbea
  4126cc:	aa1303e2 	mov	x2, x19
  4126d0:	52801283 	mov	w3, #0x94                  	// #148
  4126d4:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  4126d8:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4126dc:	91305c21 	add	x1, x1, #0xc17
  4126e0:	911a8800 	add	x0, x0, #0x6a2
  4126e4:	97ffd4e5 	bl	407a78 <assert_print>
  4126e8:	aa1903e1 	mov	x1, x25
  4126ec:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  4126f0:	9130b000 	add	x0, x0, #0xc2c
  4126f4:	97ffd4e1 	bl	407a78 <assert_print>
  4126f8:	52801281 	mov	w1, #0x94                  	// #148
  4126fc:	aa1303e0 	mov	x0, x19
  412700:	97ffd508 	bl	407b20 <assert_post_action>
  412704:	aa1303e1 	mov	x1, x19
  412708:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41270c:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412710:	911b8000 	add	x0, x0, #0x6e0
  412714:	97ffdef5 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412718:	aa1903e0 	mov	x0, x25
  41271c:	97ffefb3 	bl	40e5e8 <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
  412720:	aa1403e0 	mov	x0, x20
  412724:	97fff87c 	bl	410914 <z_priq_dumb_best>
  412728:	aa0003f4 	mov	x20, x0

		if (thread != NULL) {
  41272c:	b4000400 	cbz	x0, 4127ac <z_sched_wake+0x12c>
	thread->base.swap_data = data;
  412730:	f9001017 	str	x23, [x0, #32]
  412734:	b9004c18 	str	w24, [x0, #76]
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
  412738:	97fff810 	bl	410778 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
  41273c:	9100a280 	add	x0, x20, #0x28
  412740:	940000f2 	bl	412b08 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
  412744:	aa1403e0 	mov	x0, x20
  412748:	97fff948 	bl	410c68 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41274c:	f947ca73 	ldr	x19, [x19, #3984]
  412750:	aa1303e0 	mov	x0, x19
  412754:	97ffef98 	bl	40e5b4 <z_spin_unlock_valid>
  412758:	72001c1f 	tst	w0, #0xff
  41275c:	540002c1 	b.ne	4127b4 <z_sched_wake+0x134>  // b.any
  412760:	f0000014 	adrp	x20, 415000 <random_data+0xd8c>
  412764:	912faa94 	add	x20, x20, #0xbea
  412768:	aa1403e2 	mov	x2, x20
  41276c:	52801863 	mov	w3, #0xc3                  	// #195
  412770:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412774:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412778:	91311021 	add	x1, x1, #0xc44
  41277c:	911a8800 	add	x0, x0, #0x6a2
  412780:	97ffd4be 	bl	407a78 <assert_print>
  412784:	aa1303e1 	mov	x1, x19
  412788:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  41278c:	91316c00 	add	x0, x0, #0xc5b
  412790:	97ffd4ba 	bl	407a78 <assert_print>
  412794:	52801861 	mov	w1, #0xc3                  	// #195
  412798:	aa1403e0 	mov	x0, x20
  41279c:	97ffd4e1 	bl	407b20 <assert_post_action>
  4127a0:	aa1403e1 	mov	x1, x20
  4127a4:	52801862 	mov	w2, #0xc3                  	// #195
  4127a8:	17ffffd9 	b	41270c <z_sched_wake+0x8c>
	bool ret = false;
  4127ac:	52800015 	mov	w21, #0x0                   	// #0
  4127b0:	17ffffe7 	b	41274c <z_sched_wake+0xcc>
	posix_irq_unlock(key);
  4127b4:	2a1603e0 	mov	w0, w22
  4127b8:	97ffddb8 	bl	409e98 <posix_irq_unlock>
			ret = true;
		}
	}

	return ret;
}
  4127bc:	2a1503e0 	mov	w0, w21
  4127c0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4127c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4127c8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4127cc:	f94023f9 	ldr	x25, [sp, #64]
  4127d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4127d4:	d65f03c0 	ret

00000000004127d8 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
  4127d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4127dc:	910003fd 	mov	x29, sp
  4127e0:	f9000bf3 	str	x19, [sp, #16]
  4127e4:	aa0403f3 	mov	x19, x4
	int ret = z_pend_curr(lock, key, wait_q, timeout);
  4127e8:	97fffab1 	bl	4112ac <z_pend_curr>

	if (data != NULL) {
  4127ec:	b40000d3 	cbz	x19, 412804 <z_sched_wait+0x2c>
		*data = _current->base.swap_data;
  4127f0:	b00000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4127f4:	f9472c21 	ldr	x1, [x1, #3672]
  4127f8:	f9400821 	ldr	x1, [x1, #16]
  4127fc:	f9401021 	ldr	x1, [x1, #32]
  412800:	f9000261 	str	x1, [x19]
	}
	return ret;
}
  412804:	f9400bf3 	ldr	x19, [sp, #16]
  412808:	a8c27bfd 	ldp	x29, x30, [sp], #32
  41280c:	d65f03c0 	ret

0000000000412810 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
  412810:	f00000c0 	adrp	x0, 42d000 <counter_value>
  412814:	b94f5400 	ldr	w0, [x0, #3924]
  412818:	35000040 	cbnz	w0, 412820 <elapsed+0x10>
  41281c:	17ffeaf3 	b	40d3e8 <sys_clock_elapsed>
}
  412820:	52800000 	mov	w0, #0x0                   	// #0
  412824:	d65f03c0 	ret

0000000000412828 <next_timeout>:

static int32_t next_timeout(void)
{
  412828:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
  41282c:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
  412830:	910fa001 	add	x1, x0, #0x3e8
  412834:	910003fd 	mov	x29, sp
  412838:	f9000bf3 	str	x19, [sp, #16]
  41283c:	f941f413 	ldr	x19, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412840:	eb01027f 	cmp	x19, x1
  412844:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
  412848:	97fffff2 	bl	412810 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
  41284c:	b4000173 	cbz	x19, 412878 <next_timeout+0x50>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
  412850:	f9400e61 	ldr	x1, [x19, #24]
  412854:	cb20c021 	sub	x1, x1, w0, sxtw
	if ((to == NULL) ||
  412858:	b2407be0 	mov	x0, #0x7fffffff            	// #2147483647
  41285c:	eb00003f 	cmp	x1, x0
  412860:	5400006c 	b.gt	41286c <next_timeout+0x44>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
  412864:	f100003f 	cmp	x1, #0x0
  412868:	9a9fa020 	csel	x0, x1, xzr, ge  // ge = tcont
	}

	return ret;
}
  41286c:	f9400bf3 	ldr	x19, [sp, #16]
  412870:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412874:	d65f03c0 	ret
		ret = MAX_WAIT;
  412878:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
  41287c:	17fffffc 	b	41286c <next_timeout+0x44>

0000000000412880 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  412880:	b4000160 	cbz	x0, 4128ac <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
  412884:	d00000c1 	adrp	x1, 42c000 <__dso_handle>
  412888:	f941f821 	ldr	x1, [x1, #1008]
  41288c:	eb01001f 	cmp	x0, x1
  412890:	540000e0 	b.eq	4128ac <remove_timeout+0x2c>  // b.none
  412894:	f9400001 	ldr	x1, [x0]
	if (next(t) != NULL) {
  412898:	b40000a1 	cbz	x1, 4128ac <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
  41289c:	f9400c03 	ldr	x3, [x0, #24]
  4128a0:	f9400c22 	ldr	x2, [x1, #24]
  4128a4:	8b030042 	add	x2, x2, x3
  4128a8:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
  4128ac:	a9400801 	ldp	x1, x2, [x0]
	prev->next = next;
  4128b0:	f9000041 	str	x1, [x2]
	next->prev = prev;
  4128b4:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
  4128b8:	a9007c1f 	stp	xzr, xzr, [x0]
}
  4128bc:	d65f03c0 	ret

00000000004128c0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4128c0:	b100045f 	cmn	x2, #0x1
  4128c4:	54001200 	b.eq	412b04 <z_add_timeout+0x244>  // b.none
{
  4128c8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4128cc:	910003fd 	mov	x29, sp
  4128d0:	a90153f3 	stp	x19, x20, [sp, #16]
  4128d4:	aa0003f3 	mov	x19, x0
  4128d8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4128dc:	f9001bf7 	str	x23, [sp, #48]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
  4128e0:	f9400000 	ldr	x0, [x0]
  4128e4:	b40002a0 	cbz	x0, 412938 <z_add_timeout+0x78>
  4128e8:	90000033 	adrp	x19, 416000 <__func__.0+0xc27>
  4128ec:	911cfa73 	add	x19, x19, #0x73e
  4128f0:	aa1303e2 	mov	x2, x19
  4128f4:	90000021 	adrp	x1, 416000 <__func__.0+0xc27>
  4128f8:	911d8821 	add	x1, x1, #0x762
  4128fc:	52800bc3 	mov	w3, #0x5e                  	// #94
  412900:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412904:	911a8800 	add	x0, x0, #0x6a2
  412908:	97ffd45c 	bl	407a78 <assert_print>
  41290c:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412910:	91320400 	add	x0, x0, #0xc81
  412914:	97ffd459 	bl	407a78 <assert_print>
  412918:	aa1303e0 	mov	x0, x19
  41291c:	52800bc1 	mov	w1, #0x5e                  	// #94
  412920:	97ffd480 	bl	407b20 <assert_post_action>
  412924:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412928:	aa1303e1 	mov	x1, x19
  41292c:	911b8000 	add	x0, x0, #0x6e0
  412930:	52800bc2 	mov	w2, #0x5e                  	// #94
  412934:	97ffde6d 	bl	40a2e8 <posix_print_error_and_exit>
	to->fn = fn;
  412938:	f9000a61 	str	x1, [x19, #16]
  41293c:	aa0203f4 	mov	x20, x2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412940:	f00000d5 	adrp	x21, 42d000 <counter_value>
  412944:	9133e2b7 	add	x23, x21, #0xcf8
	return posix_irq_lock();
  412948:	97ffdd52 	bl	409e90 <posix_irq_lock>
  41294c:	2a0003f6 	mov	w22, w0
  412950:	aa1703e0 	mov	x0, x23
  412954:	97ffef0d 	bl	40e588 <z_spin_lock_valid>
  412958:	72001c1f 	tst	w0, #0xff
  41295c:	540002c1 	b.ne	4129b4 <z_add_timeout+0xf4>  // b.any
  412960:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412964:	912faa73 	add	x19, x19, #0xbea
  412968:	aa1303e2 	mov	x2, x19
  41296c:	52801283 	mov	w3, #0x94                  	// #148
  412970:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412974:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412978:	91305c21 	add	x1, x1, #0xc17
  41297c:	911a8800 	add	x0, x0, #0x6a2
  412980:	97ffd43e 	bl	407a78 <assert_print>
  412984:	aa1703e1 	mov	x1, x23
  412988:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  41298c:	9130b000 	add	x0, x0, #0xc2c
  412990:	97ffd43a 	bl	407a78 <assert_print>
  412994:	aa1303e0 	mov	x0, x19
  412998:	52801281 	mov	w1, #0x94                  	// #148
  41299c:	97ffd461 	bl	407b20 <assert_post_action>
  4129a0:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  4129a4:	aa1303e1 	mov	x1, x19
  4129a8:	911b8000 	add	x0, x0, #0x6e0
  4129ac:	52801282 	mov	w2, #0x94                  	// #148
  4129b0:	97ffde4e 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4129b4:	aa1703e0 	mov	x0, x23
  4129b8:	97ffef0c 	bl	40e5e8 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
  4129bc:	b1000a9f 	cmn	x20, #0x2
  4129c0:	5400028c 	b.gt	412a10 <z_add_timeout+0x150>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
  4129c4:	f00000c0 	adrp	x0, 42d000 <counter_value>
  4129c8:	92800023 	mov	x3, #0xfffffffffffffffe    	// #-2
  4129cc:	f9467800 	ldr	x0, [x0, #3312]
  4129d0:	cb000063 	sub	x3, x3, x0
  4129d4:	cb140062 	sub	x2, x3, x20

			to->dticks = MAX(1, ticks);
  4129d8:	f100005f 	cmp	x2, #0x0
  4129dc:	9a9fc442 	csinc	x2, x2, xzr, gt
	return list->head == list;
  4129e0:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
  4129e4:	910fa001 	add	x1, x0, #0x3e8
  4129e8:	f9000e62 	str	x2, [x19, #24]
  4129ec:	f941f402 	ldr	x2, [x0, #1000]
	sys_dnode_t *const tail = list->tail;
  4129f0:	f9400424 	ldr	x4, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4129f4:	eb01005f 	cmp	x2, x1
  4129f8:	540001e1 	b.ne	412a34 <z_add_timeout+0x174>  // b.any
	node->next = list;
  4129fc:	910fa001 	add	x1, x0, #0x3e8
	node->prev = tail;
  412a00:	a9001261 	stp	x1, x4, [x19]
	tail->next = node;
  412a04:	f9000093 	str	x19, [x4]
	list->tail = node;
  412a08:	f9000433 	str	x19, [x1, #8]
}
  412a0c:	14000015 	b	412a60 <z_add_timeout+0x1a0>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
  412a10:	91000694 	add	x20, x20, #0x1
  412a14:	97ffff7f 	bl	412810 <elapsed>
  412a18:	8b20c282 	add	x2, x20, w0, sxtw
  412a1c:	17fffff1 	b	4129e0 <z_add_timeout+0x120>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
  412a20:	cb030021 	sub	x1, x1, x3
  412a24:	f9000e61 	str	x1, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
  412a28:	eb02009f 	cmp	x4, x2
  412a2c:	54fffe80 	b.eq	4129fc <z_add_timeout+0x13c>  // b.none
  412a30:	f9400042 	ldr	x2, [x2]
		for (t = first(); t != NULL; t = next(t)) {
  412a34:	b4fffe42 	cbz	x2, 4129fc <z_add_timeout+0x13c>
			if (t->dticks > to->dticks) {
  412a38:	f9400c43 	ldr	x3, [x2, #24]
  412a3c:	f9400e61 	ldr	x1, [x19, #24]
  412a40:	eb01007f 	cmp	x3, x1
  412a44:	54fffeed 	b.le	412a20 <z_add_timeout+0x160>
				t->dticks -= to->dticks;
  412a48:	cb010063 	sub	x3, x3, x1
  412a4c:	f9000c43 	str	x3, [x2, #24]
	sys_dnode_t *const prev = successor->prev;
  412a50:	f9400441 	ldr	x1, [x2, #8]
	node->prev = prev;
  412a54:	a9000662 	stp	x2, x1, [x19]
	prev->next = node;
  412a58:	f9000033 	str	x19, [x1]
	successor->prev = node;
  412a5c:	f9000453 	str	x19, [x2, #8]
	return list->head == list;
  412a60:	910fa001 	add	x1, x0, #0x3e8
  412a64:	f941f400 	ldr	x0, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412a68:	eb01001f 	cmp	x0, x1
  412a6c:	540000c0 	b.eq	412a84 <z_add_timeout+0x1c4>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
  412a70:	eb00027f 	cmp	x19, x0
  412a74:	54000081 	b.ne	412a84 <z_add_timeout+0x1c4>  // b.any
			sys_clock_set_timeout(next_timeout(), false);
  412a78:	97ffff6c 	bl	412828 <next_timeout>
  412a7c:	52800001 	mov	w1, #0x0                   	// #0
  412a80:	97ffea51 	bl	40d3c4 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412a84:	9133e2b5 	add	x21, x21, #0xcf8
  412a88:	aa1503e0 	mov	x0, x21
  412a8c:	97ffeeca 	bl	40e5b4 <z_spin_unlock_valid>
  412a90:	72001c1f 	tst	w0, #0xff
  412a94:	540002c1 	b.ne	412aec <z_add_timeout+0x22c>  // b.any
  412a98:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412a9c:	912faa73 	add	x19, x19, #0xbea
  412aa0:	aa1303e2 	mov	x2, x19
  412aa4:	52801863 	mov	w3, #0xc3                  	// #195
  412aa8:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412aac:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412ab0:	91311021 	add	x1, x1, #0xc44
  412ab4:	911a8800 	add	x0, x0, #0x6a2
  412ab8:	97ffd3f0 	bl	407a78 <assert_print>
  412abc:	aa1503e1 	mov	x1, x21
  412ac0:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412ac4:	91316c00 	add	x0, x0, #0xc5b
  412ac8:	97ffd3ec 	bl	407a78 <assert_print>
  412acc:	aa1303e0 	mov	x0, x19
  412ad0:	52801861 	mov	w1, #0xc3                  	// #195
  412ad4:	97ffd413 	bl	407b20 <assert_post_action>
  412ad8:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412adc:	aa1303e1 	mov	x1, x19
  412ae0:	911b8000 	add	x0, x0, #0x6e0
  412ae4:	52801862 	mov	w2, #0xc3                  	// #195
  412ae8:	97ffde00 	bl	40a2e8 <posix_print_error_and_exit>
	posix_irq_unlock(key);
  412aec:	2a1603e0 	mov	w0, w22
		}
	}
}
  412af0:	a94153f3 	ldp	x19, x20, [sp, #16]
  412af4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412af8:	f9401bf7 	ldr	x23, [sp, #48]
  412afc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412b00:	17ffdce6 	b	409e98 <posix_irq_unlock>
  412b04:	d65f03c0 	ret

0000000000412b08 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
  412b08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412b0c:	910003fd 	mov	x29, sp
  412b10:	a90153f3 	stp	x19, x20, [sp, #16]
  412b14:	aa0003f4 	mov	x20, x0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412b18:	f00000d3 	adrp	x19, 42d000 <counter_value>
  412b1c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  412b20:	97ffdcdc 	bl	409e90 <posix_irq_lock>
  412b24:	9133e276 	add	x22, x19, #0xcf8
  412b28:	2a0003f5 	mov	w21, w0
  412b2c:	aa1603e0 	mov	x0, x22
  412b30:	97ffee96 	bl	40e588 <z_spin_lock_valid>
  412b34:	72001c1f 	tst	w0, #0xff
  412b38:	540002c1 	b.ne	412b90 <z_abort_timeout+0x88>  // b.any
  412b3c:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412b40:	912faa73 	add	x19, x19, #0xbea
  412b44:	aa1303e2 	mov	x2, x19
  412b48:	52801283 	mov	w3, #0x94                  	// #148
  412b4c:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412b50:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412b54:	91305c21 	add	x1, x1, #0xc17
  412b58:	911a8800 	add	x0, x0, #0x6a2
  412b5c:	97ffd3c7 	bl	407a78 <assert_print>
  412b60:	aa1603e1 	mov	x1, x22
  412b64:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412b68:	9130b000 	add	x0, x0, #0xc2c
  412b6c:	97ffd3c3 	bl	407a78 <assert_print>
  412b70:	aa1303e0 	mov	x0, x19
  412b74:	52801281 	mov	w1, #0x94                  	// #148
  412b78:	97ffd3ea 	bl	407b20 <assert_post_action>
  412b7c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412b80:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412b84:	aa1303e1 	mov	x1, x19
  412b88:	911b8000 	add	x0, x0, #0x6e0
  412b8c:	97ffddd7 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412b90:	aa1603e0 	mov	x0, x22
  412b94:	97ffee95 	bl	40e5e8 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
  412b98:	f9400280 	ldr	x0, [x20]
  412b9c:	b4000360 	cbz	x0, 412c08 <z_abort_timeout+0x100>
			remove_timeout(to);
			ret = 0;
  412ba0:	52800016 	mov	w22, #0x0                   	// #0
			remove_timeout(to);
  412ba4:	aa1403e0 	mov	x0, x20
  412ba8:	97ffff36 	bl	412880 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412bac:	9133e274 	add	x20, x19, #0xcf8
  412bb0:	aa1403e0 	mov	x0, x20
  412bb4:	97ffee80 	bl	40e5b4 <z_spin_unlock_valid>
  412bb8:	72001c1f 	tst	w0, #0xff
  412bbc:	540002a1 	b.ne	412c10 <z_abort_timeout+0x108>  // b.any
  412bc0:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412bc4:	912faa73 	add	x19, x19, #0xbea
  412bc8:	aa1303e2 	mov	x2, x19
  412bcc:	52801863 	mov	w3, #0xc3                  	// #195
  412bd0:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412bd4:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412bd8:	91311021 	add	x1, x1, #0xc44
  412bdc:	911a8800 	add	x0, x0, #0x6a2
  412be0:	97ffd3a6 	bl	407a78 <assert_print>
  412be4:	aa1403e1 	mov	x1, x20
  412be8:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412bec:	91316c00 	add	x0, x0, #0xc5b
  412bf0:	97ffd3a2 	bl	407a78 <assert_print>
  412bf4:	aa1303e0 	mov	x0, x19
  412bf8:	52801861 	mov	w1, #0xc3                  	// #195
  412bfc:	97ffd3c9 	bl	407b20 <assert_post_action>
  412c00:	52801862 	mov	w2, #0xc3                  	// #195
  412c04:	17ffffdf 	b	412b80 <z_abort_timeout+0x78>
	int ret = -EINVAL;
  412c08:	128002b6 	mov	w22, #0xffffffea            	// #-22
  412c0c:	17ffffe8 	b	412bac <z_abort_timeout+0xa4>
	posix_irq_unlock(key);
  412c10:	2a1503e0 	mov	w0, w21
  412c14:	97ffdca1 	bl	409e98 <posix_irq_unlock>
		}
	}

	return ret;
}
  412c18:	2a1603e0 	mov	w0, w22
  412c1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  412c20:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412c24:	a8c37bfd 	ldp	x29, x30, [sp], #48
  412c28:	d65f03c0 	ret

0000000000412c2c <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
  412c2c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  412c30:	910003fd 	mov	x29, sp
  412c34:	a90153f3 	stp	x19, x20, [sp, #16]
  412c38:	2a0003f3 	mov	w19, w0
  412c3c:	a9025bf5 	stp	x21, x22, [sp, #32]
  412c40:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412c44:	f00000d7 	adrp	x23, 42d000 <counter_value>
  412c48:	9133e2f6 	add	x22, x23, #0xcf8
  412c4c:	a9046bf9 	stp	x25, x26, [sp, #64]
  412c50:	f9002bfb 	str	x27, [sp, #80]
	return posix_irq_lock();
  412c54:	97ffdc8f 	bl	409e90 <posix_irq_lock>
  412c58:	2a0003f4 	mov	w20, w0
  412c5c:	aa1603e0 	mov	x0, x22
  412c60:	97ffee4a 	bl	40e588 <z_spin_lock_valid>
  412c64:	72001c1f 	tst	w0, #0xff
  412c68:	540002c1 	b.ne	412cc0 <sys_clock_announce+0x94>  // b.any
  412c6c:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412c70:	912faa73 	add	x19, x19, #0xbea
  412c74:	aa1303e2 	mov	x2, x19
  412c78:	52801283 	mov	w3, #0x94                  	// #148
  412c7c:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412c80:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412c84:	91305c21 	add	x1, x1, #0xc17
  412c88:	911a8800 	add	x0, x0, #0x6a2
  412c8c:	97ffd37b 	bl	407a78 <assert_print>
  412c90:	9133e2e1 	add	x1, x23, #0xcf8
  412c94:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412c98:	9130b000 	add	x0, x0, #0xc2c
  412c9c:	97ffd377 	bl	407a78 <assert_print>
  412ca0:	aa1303e0 	mov	x0, x19
  412ca4:	52801281 	mov	w1, #0x94                  	// #148
  412ca8:	97ffd39e 	bl	407b20 <assert_post_action>
  412cac:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412cb0:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412cb4:	aa1303e1 	mov	x1, x19
  412cb8:	911b8000 	add	x0, x0, #0x6e0
  412cbc:	97ffdd8b 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412cc0:	aa1603e0 	mov	x0, x22
  412cc4:	97ffee49 	bl	40e5e8 <z_spin_lock_set_owner>
	return list->head == list;
  412cc8:	d00000c0 	adrp	x0, 42c000 <__dso_handle>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
  412ccc:	f00000d8 	adrp	x24, 42d000 <counter_value>
  412cd0:	910fa01a 	add	x26, x0, #0x3e8
  412cd4:	f00000d9 	adrp	x25, 42d000 <counter_value>
  412cd8:	b90f5713 	str	w19, [x24, #3924]
  412cdc:	f941f413 	ldr	x19, [x0, #1000]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412ce0:	eb1a027f 	cmp	x19, x26
  412ce4:	54000740 	b.eq	412dcc <sys_clock_announce+0x1a0>  // b.none

	struct _timeout *t = first();

	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
  412ce8:	913d531b 	add	x27, x24, #0xf54
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
  412cec:	f9467b20 	ldr	x0, [x25, #3312]
	     (t != NULL) && (t->dticks <= announce_remaining);
  412cf0:	b9400361 	ldr	w1, [x27]
  412cf4:	b40006d3 	cbz	x19, 412dcc <sys_clock_announce+0x1a0>
  412cf8:	f9400e75 	ldr	x21, [x19, #24]
  412cfc:	93407c22 	sxtw	x2, w1
  412d00:	eb21c2bf 	cmp	x21, w1, sxtw
  412d04:	5400008d 	b.le	412d14 <sys_clock_announce+0xe8>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
  412d08:	cb0202b5 	sub	x21, x21, x2
  412d0c:	f9000e75 	str	x21, [x19, #24]
  412d10:	1400002f 	b	412dcc <sys_clock_announce+0x1a0>
		t->dticks = 0;
  412d14:	f9000e7f 	str	xzr, [x19, #24]
		curr_tick += dt;
  412d18:	8b35c000 	add	x0, x0, w21, sxtw
  412d1c:	f9067b20 	str	x0, [x25, #3312]
		remove_timeout(t);
  412d20:	aa1303e0 	mov	x0, x19
  412d24:	97fffed7 	bl	412880 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412d28:	aa1603e0 	mov	x0, x22
  412d2c:	97ffee22 	bl	40e5b4 <z_spin_unlock_valid>
  412d30:	72001c1f 	tst	w0, #0xff
  412d34:	54000261 	b.ne	412d80 <sys_clock_announce+0x154>  // b.any
  412d38:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412d3c:	912faa73 	add	x19, x19, #0xbea
  412d40:	aa1303e2 	mov	x2, x19
  412d44:	52801863 	mov	w3, #0xc3                  	// #195
  412d48:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412d4c:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412d50:	91311021 	add	x1, x1, #0xc44
  412d54:	911a8800 	add	x0, x0, #0x6a2
  412d58:	97ffd348 	bl	407a78 <assert_print>
  412d5c:	9133e2e1 	add	x1, x23, #0xcf8
  412d60:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412d64:	91316c00 	add	x0, x0, #0xc5b
  412d68:	97ffd344 	bl	407a78 <assert_print>
  412d6c:	aa1303e0 	mov	x0, x19
  412d70:	52801861 	mov	w1, #0xc3                  	// #195
  412d74:	97ffd36b 	bl	407b20 <assert_post_action>
  412d78:	52801862 	mov	w2, #0xc3                  	// #195
  412d7c:	17ffffcd 	b	412cb0 <sys_clock_announce+0x84>
	posix_irq_unlock(key);
  412d80:	2a1403e0 	mov	w0, w20
  412d84:	97ffdc45 	bl	409e98 <posix_irq_unlock>
		t->fn(t);
  412d88:	f9400a61 	ldr	x1, [x19, #16]
  412d8c:	aa1303e0 	mov	x0, x19
  412d90:	d63f0020 	blr	x1
	return posix_irq_lock();
  412d94:	97ffdc3f 	bl	409e90 <posix_irq_lock>
  412d98:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412d9c:	aa1603e0 	mov	x0, x22
  412da0:	97ffedfa 	bl	40e588 <z_spin_lock_valid>
  412da4:	72001c1f 	tst	w0, #0xff
  412da8:	54fff620 	b.eq	412c6c <sys_clock_announce+0x40>  // b.none
	z_spin_lock_set_owner(l);
  412dac:	aa1603e0 	mov	x0, x22
  412db0:	97ffee0e 	bl	40e5e8 <z_spin_lock_set_owner>
		announce_remaining -= dt;
  412db4:	b9400360 	ldr	w0, [x27]
	return list->head == list;
  412db8:	f9400353 	ldr	x19, [x26]
  412dbc:	4b150000 	sub	w0, w0, w21
  412dc0:	b9000360 	str	w0, [x27]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412dc4:	eb1a027f 	cmp	x19, x26
  412dc8:	54fff921 	b.ne	412cec <sys_clock_announce+0xc0>  // b.any
	}

	curr_tick += announce_remaining;
  412dcc:	f9467b21 	ldr	x1, [x25, #3312]
  412dd0:	b98f5700 	ldrsw	x0, [x24, #3924]
	announce_remaining = 0;
  412dd4:	b90f571f 	str	wzr, [x24, #3924]
	curr_tick += announce_remaining;
  412dd8:	8b010000 	add	x0, x0, x1
  412ddc:	f9067b20 	str	x0, [x25, #3312]

	sys_clock_set_timeout(next_timeout(), false);
  412de0:	97fffe92 	bl	412828 <next_timeout>
  412de4:	52800001 	mov	w1, #0x0                   	// #0
  412de8:	97ffe977 	bl	40d3c4 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412dec:	9133e2e0 	add	x0, x23, #0xcf8
  412df0:	97ffedf1 	bl	40e5b4 <z_spin_unlock_valid>
  412df4:	72001c1f 	tst	w0, #0xff
  412df8:	54fffa00 	b.eq	412d38 <sys_clock_announce+0x10c>  // b.none
	posix_irq_unlock(key);
  412dfc:	2a1403e0 	mov	w0, w20
  412e00:	97ffdc26 	bl	409e98 <posix_irq_unlock>
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
  412e04:	a94153f3 	ldp	x19, x20, [sp, #16]
  412e08:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412e0c:	a94363f7 	ldp	x23, x24, [sp, #48]
  412e10:	a9446bf9 	ldp	x25, x26, [sp, #64]
  412e14:	f9402bfb 	ldr	x27, [sp, #80]
  412e18:	a8c67bfd 	ldp	x29, x30, [sp], #96
	z_time_slice();
  412e1c:	17fff741 	b	410b20 <z_time_slice>

0000000000412e20 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
  412e20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412e24:	910003fd 	mov	x29, sp
  412e28:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412e2c:	f00000d3 	adrp	x19, 42d000 <counter_value>
  412e30:	9133e273 	add	x19, x19, #0xcf8
  412e34:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  412e38:	97ffdc16 	bl	409e90 <posix_irq_lock>
  412e3c:	2a0003f5 	mov	w21, w0
  412e40:	aa1303e0 	mov	x0, x19
  412e44:	97ffedd1 	bl	40e588 <z_spin_lock_valid>
  412e48:	72001c1f 	tst	w0, #0xff
  412e4c:	540002c1 	b.ne	412ea4 <sys_clock_tick_get+0x84>  // b.any
  412e50:	f0000014 	adrp	x20, 415000 <random_data+0xd8c>
  412e54:	912faa94 	add	x20, x20, #0xbea
  412e58:	aa1403e2 	mov	x2, x20
  412e5c:	52801283 	mov	w3, #0x94                  	// #148
  412e60:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412e64:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412e68:	91305c21 	add	x1, x1, #0xc17
  412e6c:	911a8800 	add	x0, x0, #0x6a2
  412e70:	97ffd302 	bl	407a78 <assert_print>
  412e74:	aa1303e1 	mov	x1, x19
  412e78:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412e7c:	9130b000 	add	x0, x0, #0xc2c
  412e80:	97ffd2fe 	bl	407a78 <assert_print>
  412e84:	aa1403e0 	mov	x0, x20
  412e88:	52801281 	mov	w1, #0x94                  	// #148
  412e8c:	97ffd325 	bl	407b20 <assert_post_action>
  412e90:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412e94:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412e98:	aa1403e1 	mov	x1, x20
  412e9c:	911b8000 	add	x0, x0, #0x6e0
  412ea0:	97ffdd12 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412ea4:	aa1303e0 	mov	x0, x19
  412ea8:	97ffedd0 	bl	40e5e8 <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
  412eac:	97fffe59 	bl	412810 <elapsed>
  412eb0:	f00000c1 	adrp	x1, 42d000 <counter_value>
  412eb4:	f9467821 	ldr	x1, [x1, #3312]
  412eb8:	8b20c034 	add	x20, x1, w0, sxtw
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412ebc:	aa1303e0 	mov	x0, x19
  412ec0:	97ffedbd 	bl	40e5b4 <z_spin_unlock_valid>
  412ec4:	72001c1f 	tst	w0, #0xff
  412ec8:	54000261 	b.ne	412f14 <sys_clock_tick_get+0xf4>  // b.any
  412ecc:	f0000014 	adrp	x20, 415000 <random_data+0xd8c>
  412ed0:	912faa94 	add	x20, x20, #0xbea
  412ed4:	aa1403e2 	mov	x2, x20
  412ed8:	52801863 	mov	w3, #0xc3                  	// #195
  412edc:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412ee0:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412ee4:	91311021 	add	x1, x1, #0xc44
  412ee8:	911a8800 	add	x0, x0, #0x6a2
  412eec:	97ffd2e3 	bl	407a78 <assert_print>
  412ef0:	aa1303e1 	mov	x1, x19
  412ef4:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412ef8:	91316c00 	add	x0, x0, #0xc5b
  412efc:	97ffd2df 	bl	407a78 <assert_print>
  412f00:	aa1403e0 	mov	x0, x20
  412f04:	52801861 	mov	w1, #0xc3                  	// #195
  412f08:	97ffd306 	bl	407b20 <assert_post_action>
  412f0c:	52801862 	mov	w2, #0xc3                  	// #195
  412f10:	17ffffe1 	b	412e94 <sys_clock_tick_get+0x74>
	posix_irq_unlock(key);
  412f14:	2a1503e0 	mov	w0, w21
  412f18:	97ffdbe0 	bl	409e98 <posix_irq_unlock>
	}
	return t;
}
  412f1c:	aa1403e0 	mov	x0, x20
  412f20:	a94153f3 	ldp	x19, x20, [sp, #16]
  412f24:	f94013f5 	ldr	x21, [sp, #32]
  412f28:	a8c37bfd 	ldp	x29, x30, [sp], #48
  412f2c:	d65f03c0 	ret

0000000000412f30 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
  412f30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  412f34:	910003fd 	mov	x29, sp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
  412f38:	97ffffba 	bl	412e20 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
  412f3c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  412f40:	d65f03c0 	ret

0000000000412f44 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
  412f44:	17ffffb7 	b	412e20 <sys_clock_tick_get>

0000000000412f48 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
  412f48:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  412f4c:	910003fd 	mov	x29, sp
  412f50:	f9000bf3 	str	x19, [sp, #16]
  412f54:	aa0003f3 	mov	x19, x0
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  412f58:	b100041f 	cmn	x0, #0x1
  412f5c:	54000180 	b.eq	412f8c <sys_clock_timeout_end_calc+0x44>  // b.none
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  412f60:	b5000080 	cbnz	x0, 412f70 <sys_clock_timeout_end_calc+0x28>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
  412f64:	f9400bf3 	ldr	x19, [sp, #16]
  412f68:	a8c27bfd 	ldp	x29, x30, [sp], #32
		return sys_clock_tick_get();
  412f6c:	17ffffad 	b	412e20 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
  412f70:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
  412f74:	eb130000 	subs	x0, x0, x19
  412f78:	540000a5 	b.pl	412f8c <sys_clock_timeout_end_calc+0x44>  // b.nfrst
		return sys_clock_tick_get() + MAX(1, dt);
  412f7c:	97ffffa9 	bl	412e20 <sys_clock_tick_get>
  412f80:	f100027f 	cmp	x19, #0x0
  412f84:	9a9fc673 	csinc	x19, x19, xzr, gt
  412f88:	8b000260 	add	x0, x19, x0
}
  412f8c:	f9400bf3 	ldr	x19, [sp, #16]
  412f90:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412f94:	d65f03c0 	ret

0000000000412f98 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  412f98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412f9c:	910003fd 	mov	x29, sp
  412fa0:	a90153f3 	stp	x19, x20, [sp, #16]
  412fa4:	aa0003f3 	mov	x19, x0
  412fa8:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  412fac:	97ffdbb9 	bl	409e90 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412fb0:	f00000d6 	adrp	x22, 42d000 <counter_value>
  412fb4:	913402d5 	add	x21, x22, #0xd00
  412fb8:	2a0003f4 	mov	w20, w0
  412fbc:	aa1503e0 	mov	x0, x21
  412fc0:	97ffed72 	bl	40e588 <z_spin_lock_valid>
  412fc4:	72001c1f 	tst	w0, #0xff
  412fc8:	540002c1 	b.ne	413020 <z_timer_expiration_handler+0x88>  // b.any
  412fcc:	f0000013 	adrp	x19, 415000 <random_data+0xd8c>
  412fd0:	912faa73 	add	x19, x19, #0xbea
  412fd4:	aa1303e2 	mov	x2, x19
  412fd8:	52801283 	mov	w3, #0x94                  	// #148
  412fdc:	f0000001 	adrp	x1, 415000 <random_data+0xd8c>
  412fe0:	d0000000 	adrp	x0, 414000 <__func__.1+0xd>
  412fe4:	91305c21 	add	x1, x1, #0xc17
  412fe8:	911a8800 	add	x0, x0, #0x6a2
  412fec:	97ffd2a3 	bl	407a78 <assert_print>
  412ff0:	913402c1 	add	x1, x22, #0xd00
  412ff4:	f0000000 	adrp	x0, 415000 <random_data+0xd8c>
  412ff8:	9130b000 	add	x0, x0, #0xc2c
  412ffc:	97ffd29f 	bl	407a78 <assert_print>
  413000:	aa1303e0 	mov	x0, x19
  413004:	52801281 	mov	w1, #0x94                  	// #148
  413008:	97ffd2c6 	bl	407b20 <assert_post_action>
  41300c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413010:	b0000000 	adrp	x0, 414000 <__func__.1+0xd>
  413014:	aa1303e1 	mov	x1, x19
  413018:	911b8000 	add	x0, x0, #0x6e0
  41301c:	97ffdcb3 	bl	40a2e8 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413020:	aa1503e0 	mov	x0, x21
  413024:	97ffed71 	bl	40e5e8 <z_spin_lock_set_owner>
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
  413028:	f9400260 	ldr	x0, [x19]
  41302c:	b40002e0 	cbz	x0, 413088 <z_timer_expiration_handler+0xf0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413030:	aa1503e0 	mov	x0, x21
  413034:	97ffed60 	bl	40e5b4 <z_spin_unlock_valid>
  413038:	72001c1f 	tst	w0, #0xff
  41303c:	540008e1 	b.ne	413158 <z_timer_expiration_handler+0x1c0>  // b.any
  413040:	d0000013 	adrp	x19, 415000 <random_data+0xd8c>
  413044:	912faa73 	add	x19, x19, #0xbea
  413048:	aa1303e2 	mov	x2, x19
  41304c:	52801863 	mov	w3, #0xc3                  	// #195
  413050:	d0000001 	adrp	x1, 415000 <random_data+0xd8c>
  413054:	b0000000 	adrp	x0, 414000 <__func__.1+0xd>
  413058:	91311021 	add	x1, x1, #0xc44
  41305c:	911a8800 	add	x0, x0, #0x6a2
  413060:	97ffd286 	bl	407a78 <assert_print>
  413064:	913402c1 	add	x1, x22, #0xd00
  413068:	d0000000 	adrp	x0, 415000 <random_data+0xd8c>
  41306c:	91316c00 	add	x0, x0, #0xc5b
  413070:	97ffd282 	bl	407a78 <assert_print>
  413074:	aa1303e0 	mov	x0, x19
  413078:	52801861 	mov	w1, #0xc3                  	// #195
  41307c:	97ffd2a9 	bl	407b20 <assert_post_action>
  413080:	52801862 	mov	w2, #0xc3                  	// #195
  413084:	17ffffe3 	b	413010 <z_timer_expiration_handler+0x78>

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
  413088:	f9402260 	ldr	x0, [x19, #64]
  41308c:	91000401 	add	x1, x0, #0x1
  413090:	f100043f 	cmp	x1, #0x1
  413094:	54000249 	b.ls	4130dc <z_timer_expiration_handler+0x144>  // b.plast
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		k_timeout_t next = timer->period;

		/* see note about z_add_timeout() in z_impl_k_timer_start() */
		next.ticks = MAX(next.ticks - 1, 0);
  413098:	f100001f 	cmp	x0, #0x0
  41309c:	9a9fc400 	csinc	x0, x0, xzr, gt
  4130a0:	d1000415 	sub	x21, x0, #0x1
	return z_impl_k_uptime_ticks();
  4130a4:	97ffffa8 	bl	412f44 <z_impl_k_uptime_ticks>
		 * we "should" have run.  Requires absolute timeouts.
		 * (Note offset by one: we're nominally at the
		 * beginning of a tick, so need to defeat the "round
		 * down" behavior on timeout addition).
		 */
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
  4130a8:	91000400 	add	x0, x0, #0x1
  4130ac:	8b150000 	add	x0, x0, x21
  4130b0:	f100001f 	cmp	x0, #0x0
  4130b4:	540004ed 	b.le	413150 <z_timer_expiration_handler+0x1b8>
  4130b8:	97ffffa3 	bl	412f44 <z_impl_k_uptime_ticks>
  4130bc:	91000400 	add	x0, x0, #0x1
  4130c0:	8b150000 	add	x0, x0, x21
  4130c4:	92800022 	mov	x2, #0xfffffffffffffffe    	// #-2
  4130c8:	cb000042 	sub	x2, x2, x0
#endif
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  4130cc:	900000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
  4130d0:	aa1303e0 	mov	x0, x19
  4130d4:	f947d821 	ldr	x1, [x1, #4016]
  4130d8:	97fffdfa 	bl	4128c0 <z_add_timeout>
			      next);
	}

	/* update timer's status */
	timer->status += 1U;
  4130dc:	b9404a60 	ldr	w0, [x19, #72]
  4130e0:	11000400 	add	w0, w0, #0x1
  4130e4:	b9004a60 	str	w0, [x19, #72]

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  4130e8:	f9401a60 	ldr	x0, [x19, #48]
  4130ec:	b4000260 	cbz	x0, 413138 <z_timer_expiration_handler+0x1a0>
  4130f0:	913402d5 	add	x21, x22, #0xd00
  4130f4:	aa1503e0 	mov	x0, x21
  4130f8:	97ffed2f 	bl	40e5b4 <z_spin_unlock_valid>
  4130fc:	72001c1f 	tst	w0, #0xff
  413100:	54fffa00 	b.eq	413040 <z_timer_expiration_handler+0xa8>  // b.none
	posix_irq_unlock(key);
  413104:	2a1403e0 	mov	w0, w20
  413108:	97ffdb64 	bl	409e98 <posix_irq_unlock>
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
  41310c:	f9401a61 	ldr	x1, [x19, #48]
  413110:	aa1303e0 	mov	x0, x19
  413114:	d63f0020 	blr	x1
	return posix_irq_lock();
  413118:	97ffdb5e 	bl	409e90 <posix_irq_lock>
  41311c:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413120:	aa1503e0 	mov	x0, x21
  413124:	97ffed19 	bl	40e588 <z_spin_lock_valid>
  413128:	72001c1f 	tst	w0, #0xff
  41312c:	54fff500 	b.eq	412fcc <z_timer_expiration_handler+0x34>  // b.none
	z_spin_lock_set_owner(l);
  413130:	aa1503e0 	mov	x0, x21
  413134:	97ffed2d 	bl	40e5e8 <z_spin_lock_set_owner>
	return list->head == list;
  413138:	f8420e75 	ldr	x21, [x19, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  41313c:	eb1302bf 	cmp	x21, x19
  413140:	54000040 	b.eq	413148 <z_timer_expiration_handler+0x1b0>  // b.none
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
  413144:	b5000155 	cbnz	x21, 41316c <z_timer_expiration_handler+0x1d4>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413148:	913402c0 	add	x0, x22, #0xd00
  41314c:	17ffffba 	b	413034 <z_timer_expiration_handler+0x9c>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
  413150:	92800022 	mov	x2, #0xfffffffffffffffe    	// #-2
  413154:	17ffffde 	b	4130cc <z_timer_expiration_handler+0x134>
	posix_irq_unlock(key);
  413158:	2a1403e0 	mov	w0, w20
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
  41315c:	a94153f3 	ldp	x19, x20, [sp, #16]
  413160:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413164:	a8c37bfd 	ldp	x29, x30, [sp], #48
  413168:	17ffdb4c 	b	409e98 <posix_irq_unlock>
	z_unpend_thread_no_timeout(thread);
  41316c:	aa1503e0 	mov	x0, x21
  413170:	97fff466 	bl	410308 <z_unpend_thread_no_timeout>
  413174:	b9004ebf 	str	wzr, [x21, #76]
  413178:	913402c0 	add	x0, x22, #0xd00
  41317c:	97ffed0e 	bl	40e5b4 <z_spin_unlock_valid>
  413180:	72001c1f 	tst	w0, #0xff
  413184:	54fff5e0 	b.eq	413040 <z_timer_expiration_handler+0xa8>  // b.none
  413188:	2a1403e0 	mov	w0, w20
  41318c:	97ffdb43 	bl	409e98 <posix_irq_unlock>
	z_ready_thread(thread);
  413190:	aa1503e0 	mov	x0, x21
}
  413194:	a94153f3 	ldp	x19, x20, [sp, #16]
  413198:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41319c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_ready_thread(thread);
  4131a0:	17fff6fa 	b	410d88 <z_ready_thread>

00000000004131a4 <k_timer_init>:
	node->prev = NULL;
  4131a4:	a9007c1f 	stp	xzr, xzr, [x0]
void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
	timer->stop_fn = stop_fn;
  4131a8:	a9030801 	stp	x1, x2, [x0, #48]
	sys_dlist_init(&w->waitq);
  4131ac:	91008001 	add	x1, x0, #0x20
	list->tail = (sys_dnode_t *)list;
  4131b0:	a9020401 	stp	x1, x1, [x0, #32]
	timer->status = 0U;
  4131b4:	b900481f 	str	wzr, [x0, #72]

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
  4131b8:	f900281f 	str	xzr, [x0, #80]

	z_object_init(timer);
}
  4131bc:	d65f03c0 	ret

00000000004131c0 <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
  4131c0:	b100043f 	cmn	x1, #0x1
  4131c4:	54000320 	b.eq	413228 <z_impl_k_timer_start+0x68>  // b.none
{
  4131c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4131cc:	910003fd 	mov	x29, sp
  4131d0:	a90153f3 	stp	x19, x20, [sp, #16]
  4131d4:	aa0003f4 	mov	x20, x0
  4131d8:	aa0103f3 	mov	x19, x1
  4131dc:	f90013f5 	str	x21, [sp, #32]
  4131e0:	aa0203f5 	mov	x21, x2
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
  4131e4:	b100083f 	cmn	x1, #0x2
  4131e8:	5400008d 	b.le	4131f8 <z_impl_k_timer_start+0x38>
		duration.ticks = MAX(duration.ticks - 1, 0);
  4131ec:	f100003f 	cmp	x1, #0x0
  4131f0:	9a9fc433 	csinc	x19, x1, xzr, gt
  4131f4:	d1000673 	sub	x19, x19, #0x1
	}

	(void)z_abort_timeout(&timer->timeout);
  4131f8:	aa1403e0 	mov	x0, x20
  4131fc:	97fffe43 	bl	412b08 <z_abort_timeout>
	timer->period = period;
  413200:	f9002295 	str	x21, [x20, #64]
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  413204:	aa1303e2 	mov	x2, x19
	timer->status = 0U;
  413208:	b9004a9f 	str	wzr, [x20, #72]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  41320c:	aa1403e0 	mov	x0, x20
  413210:	900000c1 	adrp	x1, 42b000 <__FRAME_END__+0x1007c>
		     duration);
}
  413214:	a94153f3 	ldp	x19, x20, [sp, #16]
  413218:	f94013f5 	ldr	x21, [sp, #32]
  41321c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  413220:	f947d821 	ldr	x1, [x1, #4016]
  413224:	17fffda7 	b	4128c0 <z_add_timeout>
  413228:	d65f03c0 	ret

000000000041322c <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
  41322c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  413230:	910003fd 	mov	x29, sp
  413234:	f9000bf3 	str	x19, [sp, #16]
  413238:	aa0003f3 	mov	x19, x0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
  41323c:	97fffe33 	bl	412b08 <z_abort_timeout>

	if (inactive) {
  413240:	350001a0 	cbnz	w0, 413274 <z_impl_k_timer_stop+0x48>
		return;
	}

	if (timer->stop_fn != NULL) {
  413244:	f9401e61 	ldr	x1, [x19, #56]
  413248:	b4000061 	cbz	x1, 413254 <z_impl_k_timer_stop+0x28>
		timer->stop_fn(timer);
  41324c:	aa1303e0 	mov	x0, x19
  413250:	d63f0020 	blr	x1
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
  413254:	91008260 	add	x0, x19, #0x20
  413258:	97fff9d5 	bl	4119ac <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
  41325c:	b40000c0 	cbz	x0, 413274 <z_impl_k_timer_stop+0x48>
			z_ready_thread(pending_thread);
  413260:	97fff6ca 	bl	410d88 <z_ready_thread>
	return posix_irq_lock();
  413264:	97ffdb0b 	bl	409e90 <posix_irq_lock>
			z_reschedule_unlocked();
		}
	}
}
  413268:	f9400bf3 	ldr	x19, [sp, #16]
  41326c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	(void) z_reschedule_irqlock(arch_irq_lock());
  413270:	17fff4af 	b	41052c <z_reschedule_irqlock>
  413274:	f9400bf3 	ldr	x19, [sp, #16]
  413278:	a8c27bfd 	ldp	x29, x30, [sp], #32
  41327c:	d65f03c0 	ret

0000000000413280 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
  413280:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  413284:	910003fd 	mov	x29, sp
  413288:	a90153f3 	stp	x19, x20, [sp, #16]
  41328c:	aa0003f4 	mov	x20, x0
  413290:	a9025bf5 	stp	x21, x22, [sp, #32]
  413294:	2a0103f5 	mov	w21, w1
  413298:	f9001bf7 	str	x23, [sp, #48]
	struct z_poller *poller = event->poller;
  41329c:	f9400813 	ldr	x19, [x0, #16]
	int retcode = 0;

	if (poller != NULL) {
  4132a0:	b4000113 	cbz	x19, 4132c0 <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
  4132a4:	39400660 	ldrb	w0, [x19, #1]
  4132a8:	7100041f 	cmp	w0, #0x1
  4132ac:	540004c1 	b.ne	413344 <signal_poll_event+0xc4>  // b.any
	if (!z_is_thread_pending(thread)) {
  4132b0:	385a9260 	ldurb	w0, [x19, #-87]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
  4132b4:	d101c276 	sub	x22, x19, #0x70
  4132b8:	37080160 	tbnz	w0, #1, 4132e4 <signal_poll_event+0x64>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
  4132bc:	3900027f 	strb	wzr, [x19]
	event->state |= state;
  4132c0:	f9400e80 	ldr	x0, [x20, #24]
	event->poller = NULL;
  4132c4:	f9000a9f 	str	xzr, [x20, #16]
	event->state |= state;
  4132c8:	d34e5000 	ubfx	x0, x0, #14, #7
  4132cc:	2a0002b5 	orr	w21, w21, w0
  4132d0:	b9401a80 	ldr	w0, [x20, #24]
  4132d4:	33121aa0 	bfi	w0, w21, #14, #7
  4132d8:	b9001a80 	str	w0, [x20, #24]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
  4132dc:	52800000 	mov	w0, #0x0                   	// #0
  4132e0:	14000006 	b	4132f8 <signal_poll_event+0x78>
	if (z_is_thread_timeout_expired(thread)) {
  4132e4:	f94022c0 	ldr	x0, [x22, #64]
  4132e8:	b100081f 	cmn	x0, #0x2
  4132ec:	54000101 	b.ne	41330c <signal_poll_event+0x8c>  // b.any
		return -EAGAIN;
  4132f0:	12800140 	mov	w0, #0xfffffff5            	// #-11
		poller->is_polling = false;
  4132f4:	3900027f 	strb	wzr, [x19]
}
  4132f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4132fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413300:	f9401bf7 	ldr	x23, [sp, #48]
  413304:	a8c47bfd 	ldp	x29, x30, [sp], #64
  413308:	d65f03c0 	ret
	z_unpend_thread(thread);
  41330c:	aa1603e0 	mov	x0, x22
  413310:	97fff53a 	bl	4107f8 <z_unpend_thread>
	arch_thread_return_value_set(thread,
  413314:	710022bf 	cmp	w21, #0x8
  413318:	12800060 	mov	w0, #0xfffffffc            	// #-4
  41331c:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  413320:	b9004ec0 	str	w0, [x22, #76]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  413324:	394066c0 	ldrb	w0, [x22, #25]
  413328:	f240101f 	tst	x0, #0x1f
  41332c:	54fffc81 	b.ne	4132bc <signal_poll_event+0x3c>  // b.any
	if (!z_is_thread_ready(thread)) {
  413330:	f85b8260 	ldur	x0, [x19, #-72]
  413334:	b5fffc40 	cbnz	x0, 4132bc <signal_poll_event+0x3c>
	z_ready_thread(thread);
  413338:	aa1603e0 	mov	x0, x22
  41333c:	97fff693 	bl	410d88 <z_ready_thread>
		poller->is_polling = false;
  413340:	17ffffdf 	b	4132bc <signal_poll_event+0x3c>
		} else if (poller->mode == MODE_TRIGGERED) {
  413344:	7100081f 	cmp	w0, #0x2
  413348:	54fffba1 	b.ne	4132bc <signal_poll_event+0x3c>  // b.any
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
  41334c:	39400260 	ldrb	w0, [x19]
  413350:	34fffb80 	cbz	w0, 4132c0 <signal_poll_event+0x40>
  413354:	f85f8277 	ldur	x23, [x19, #-8]
  413358:	d100a276 	sub	x22, x19, #0x28
  41335c:	b4fffb17 	cbz	x23, 4132bc <signal_poll_event+0x3c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
  413360:	91008260 	add	x0, x19, #0x20
  413364:	97fffde9 	bl	412b08 <z_abort_timeout>
		twork->poll_result = 0;
  413368:	b900427f 	str	wzr, [x19, #64]
		z_work_submit_to_queue(work_q, &twork->work);
  41336c:	aa1603e1 	mov	x1, x22
  413370:	aa1703e0 	mov	x0, x23
  413374:	97fff2c0 	bl	40fe74 <z_work_submit_to_queue>
		poller->is_polling = false;
  413378:	17ffffd1 	b	4132bc <signal_poll_event+0x3c>

000000000041337c <z_handle_obj_poll_events>:
{
  41337c:	aa0003e2 	mov	x2, x0
	return list->head == list;
  413380:	f9400000 	ldr	x0, [x0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
  413384:	eb00005f 	cmp	x2, x0
  413388:	540000c0 	b.eq	4133a0 <z_handle_obj_poll_events+0x24>  // b.none
	sys_dnode_t *const prev = node->prev;
  41338c:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
  413390:	f9000062 	str	x2, [x3]
	next->prev = prev;
  413394:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
  413398:	a9007c1f 	stp	xzr, xzr, [x0]
		(void) signal_poll_event(poll_event, state);
  41339c:	17ffffb9 	b	413280 <signal_poll_event>
}
  4133a0:	d65f03c0 	ret

00000000004133a4 <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
  4133a4:	b4000080 	cbz	x0, 4133b4 <k_free+0x10>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
  4133a8:	d1002001 	sub	x1, x0, #0x8
  4133ac:	f85f8000 	ldur	x0, [x0, #-8]
  4133b0:	17ffea2f 	b	40dc6c <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
  4133b4:	d65f03c0 	ret

00000000004133b8 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
  4133b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4133bc:	910003fd 	mov	x29, sp
  4133c0:	a90153f3 	stp	x19, x20, [sp, #16]
  4133c4:	aa0103f4 	mov	x20, x1
  4133c8:	f90013f5 	str	x21, [sp, #32]
  4133cc:	aa0003f5 	mov	x21, x0
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
  4133d0:	97ffeb61 	bl	40e154 <k_is_in_isr>
  4133d4:	72001c1f 	tst	w0, #0xff
  4133d8:	54000521 	b.ne	41347c <z_thread_aligned_alloc+0xc4>  // b.any
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
  4133dc:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4133e0:	f9472c00 	ldr	x0, [x0, #3672]
  4133e4:	f9400800 	ldr	x0, [x0, #16]
  4133e8:	f9405813 	ldr	x19, [x0, #176]
	}

	if (heap != NULL) {
  4133ec:	b40004b3 	cbz	x19, 413480 <z_thread_aligned_alloc+0xc8>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
  4133f0:	b1002282 	adds	x2, x20, #0x8
  4133f4:	54000442 	b.cs	41347c <z_thread_aligned_alloc+0xc4>  // b.hs, b.nlast
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
  4133f8:	b27d02a1 	orr	x1, x21, #0x8
  4133fc:	aa1303e0 	mov	x0, x19
  413400:	d2800003 	mov	x3, #0x0                   	// #0
  413404:	97ffe99a 	bl	40da6c <k_heap_aligned_alloc>
	if (mem == NULL) {
  413408:	b40003a0 	cbz	x0, 41347c <z_thread_aligned_alloc+0xc4>
	*heap_ref = heap;
  41340c:	f9000013 	str	x19, [x0]
	mem = ++heap_ref;
  413410:	91002013 	add	x19, x0, #0x8
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
  413414:	b4000375 	cbz	x21, 413480 <z_thread_aligned_alloc+0xc8>
  413418:	d10006a0 	sub	x0, x21, #0x1
  41341c:	ea00027f 	tst	x19, x0
  413420:	54000300 	b.eq	413480 <z_thread_aligned_alloc+0xc8>  // b.none
  413424:	f0000014 	adrp	x20, 416000 <__func__.0+0xc27>
  413428:	911e0a94 	add	x20, x20, #0x782
  41342c:	528004a3 	mov	w3, #0x25                  	// #37
  413430:	aa1403e2 	mov	x2, x20
  413434:	f0000001 	adrp	x1, 416000 <__func__.0+0xc27>
  413438:	b0000000 	adrp	x0, 414000 <__func__.1+0xd>
  41343c:	911e9821 	add	x1, x1, #0x7a6
  413440:	911a8800 	add	x0, x0, #0x6a2
  413444:	97ffd18d 	bl	407a78 <assert_print>
  413448:	aa1503e2 	mov	x2, x21
  41344c:	aa1303e1 	mov	x1, x19
  413450:	f0000000 	adrp	x0, 416000 <__func__.0+0xc27>
  413454:	911f6000 	add	x0, x0, #0x7d8
  413458:	97ffd188 	bl	407a78 <assert_print>
  41345c:	aa1403e0 	mov	x0, x20
  413460:	528004a1 	mov	w1, #0x25                  	// #37
  413464:	97ffd1af 	bl	407b20 <assert_post_action>
  413468:	b0000000 	adrp	x0, 414000 <__func__.1+0xd>
  41346c:	aa1403e1 	mov	x1, x20
  413470:	911b8000 	add	x0, x0, #0x6e0
  413474:	528004a2 	mov	w2, #0x25                  	// #37
  413478:	97ffdb9c 	bl	40a2e8 <posix_print_error_and_exit>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
  41347c:	d2800013 	mov	x19, #0x0                   	// #0
	}

	return ret;
}
  413480:	aa1303e0 	mov	x0, x19
  413484:	a94153f3 	ldp	x19, x20, [sp, #16]
  413488:	f94013f5 	ldr	x21, [sp, #32]
  41348c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  413490:	d65f03c0 	ret

0000000000413494 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
  413494:	f0000000 	adrp	x0, 416000 <__func__.0+0xc27>
  413498:	91200000 	add	x0, x0, #0x800
  41349c:	17ffcbba 	b	406384 <printk>

00000000004134a0 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
  4134a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4134a4:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
	struct k_work_queue_config cfg = {
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
  4134a8:	d2808002 	mov	x2, #0x400                 	// #1024
{
  4134ac:	910003fd 	mov	x29, sp
  4134b0:	f9476800 	ldr	x0, [x0, #3792]
	k_work_queue_start(&k_sys_work_q,
  4134b4:	910063e4 	add	x4, sp, #0x18
  4134b8:	12800003 	mov	w3, #0xffffffff            	// #-1
{
  4134bc:	f9400001 	ldr	x1, [x0]
  4134c0:	f90017e1 	str	x1, [sp, #40]
  4134c4:	d2800001 	mov	x1, #0x0                   	// #0
	struct k_work_queue_config cfg = {
  4134c8:	f0000000 	adrp	x0, 416000 <__func__.0+0xc27>
  4134cc:	91210c00 	add	x0, x0, #0x843
  4134d0:	f9000fe0 	str	x0, [sp, #24]
	k_work_queue_start(&k_sys_work_q,
  4134d4:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4134d8:	b00000e1 	adrp	x1, 430000 <kheap_net_buf_mem_pool_isotp_tx_pool+0xe8>
  4134dc:	913c6021 	add	x1, x1, #0xf18
	struct k_work_queue_config cfg = {
  4134e0:	390083ff 	strb	wzr, [sp, #32]
	k_work_queue_start(&k_sys_work_q,
  4134e4:	f947f400 	ldr	x0, [x0, #4072]
  4134e8:	97fff2ca 	bl	410010 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
  4134ec:	900000c0 	adrp	x0, 42b000 <__FRAME_END__+0x1007c>
  4134f0:	f9476800 	ldr	x0, [x0, #3792]
  4134f4:	f94017e2 	ldr	x2, [sp, #40]
  4134f8:	f9400001 	ldr	x1, [x0]
  4134fc:	eb010042 	subs	x2, x2, x1
  413500:	d2800001 	mov	x1, #0x0                   	// #0
  413504:	54000040 	b.eq	41350c <k_sys_work_q_init+0x6c>  // b.none
  413508:	97ffb786 	bl	401320 <__stack_chk_fail@plt>
  41350c:	52800000 	mov	w0, #0x0                   	// #0
  413510:	a8c37bfd 	ldp	x29, x30, [sp], #48
  413514:	d65f03c0 	ret

Disassembly of section .fini:

0000000000413518 <_fini>:
  413518:	d503201f 	nop
  41351c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  413520:	910003fd 	mov	x29, sp
  413524:	a8c17bfd 	ldp	x29, x30, [sp], #16
  413528:	d65f03c0 	ret
