
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section .init:

0000000000401288 <_init>:
  401288:	d503201f 	nop
  40128c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  401290:	910003fd 	mov	x29, sp
  401294:	940003f7 	bl	402270 <call_weak_fn>
  401298:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40129c:	d65f03c0 	ret

Disassembly of section .plt:

00000000004012a0 <.plt>:
  4012a0:	a9bf7bf0 	stp	x16, x30, [sp, #-16]!
  4012a4:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4012a8:	f9460e11 	ldr	x17, [x16, #3096]
  4012ac:	91306210 	add	x16, x16, #0xc18
  4012b0:	d61f0220 	br	x17
  4012b4:	d503201f 	nop
  4012b8:	d503201f 	nop
  4012bc:	d503201f 	nop

00000000004012c0 <memcpy@plt>:
  4012c0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4012c4:	f9461211 	ldr	x17, [x16, #3104]
  4012c8:	91308210 	add	x16, x16, #0xc20
  4012cc:	d61f0220 	br	x17

00000000004012d0 <memmove@plt>:
  4012d0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4012d4:	f9461611 	ldr	x17, [x16, #3112]
  4012d8:	9130a210 	add	x16, x16, #0xc28
  4012dc:	d61f0220 	br	x17

00000000004012e0 <getcwd@plt>:
  4012e0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4012e4:	f9461a11 	ldr	x17, [x16, #3120]
  4012e8:	9130c210 	add	x16, x16, #0xc30
  4012ec:	d61f0220 	br	x17

00000000004012f0 <strtoul@plt>:
  4012f0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4012f4:	f9461e11 	ldr	x17, [x16, #3128]
  4012f8:	9130e210 	add	x16, x16, #0xc38
  4012fc:	d61f0220 	br	x17

0000000000401300 <strlen@plt>:
  401300:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401304:	f9462211 	ldr	x17, [x16, #3136]
  401308:	91310210 	add	x16, x16, #0xc40
  40130c:	d61f0220 	br	x17

0000000000401310 <exit@plt>:
  401310:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401314:	f9462611 	ldr	x17, [x16, #3144]
  401318:	91312210 	add	x16, x16, #0xc48
  40131c:	d61f0220 	br	x17

0000000000401320 <__libc_start_main@plt>:
  401320:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401324:	f9462a11 	ldr	x17, [x16, #3152]
  401328:	91314210 	add	x16, x16, #0xc50
  40132c:	d61f0220 	br	x17

0000000000401330 <strtoll@plt>:
  401330:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401334:	f9462e11 	ldr	x17, [x16, #3160]
  401338:	91316210 	add	x16, x16, #0xc58
  40133c:	d61f0220 	br	x17

0000000000401340 <strnlen@plt>:
  401340:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401344:	f9463211 	ldr	x17, [x16, #3168]
  401348:	91318210 	add	x16, x16, #0xc60
  40134c:	d61f0220 	br	x17

0000000000401350 <strtod@plt>:
  401350:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401354:	f9463611 	ldr	x17, [x16, #3176]
  401358:	9131a210 	add	x16, x16, #0xc68
  40135c:	d61f0220 	br	x17

0000000000401360 <__sigsetjmp@plt>:
  401360:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401364:	f9463a11 	ldr	x17, [x16, #3184]
  401368:	9131c210 	add	x16, x16, #0xc70
  40136c:	d61f0220 	br	x17

0000000000401370 <__cxa_finalize@plt>:
  401370:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401374:	f9463e11 	ldr	x17, [x16, #3192]
  401378:	9131e210 	add	x16, x16, #0xc78
  40137c:	d61f0220 	br	x17

0000000000401380 <clock_gettime@plt>:
  401380:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401384:	f9464211 	ldr	x17, [x16, #3200]
  401388:	91320210 	add	x16, x16, #0xc80
  40138c:	d61f0220 	br	x17

0000000000401390 <setvbuf@plt>:
  401390:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401394:	f9464611 	ldr	x17, [x16, #3208]
  401398:	91322210 	add	x16, x16, #0xc88
  40139c:	d61f0220 	br	x17

00000000004013a0 <snprintf@plt>:
  4013a0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4013a4:	f9464a11 	ldr	x17, [x16, #3216]
  4013a8:	91324210 	add	x16, x16, #0xc90
  4013ac:	d61f0220 	br	x17

00000000004013b0 <__memcpy_chk@plt>:
  4013b0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4013b4:	f9464e11 	ldr	x17, [x16, #3224]
  4013b8:	91326210 	add	x16, x16, #0xc98
  4013bc:	d61f0220 	br	x17

00000000004013c0 <__snprintf_chk@plt>:
  4013c0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4013c4:	f9465211 	ldr	x17, [x16, #3232]
  4013c8:	91328210 	add	x16, x16, #0xca0
  4013cc:	d61f0220 	br	x17

00000000004013d0 <strtok_r@plt>:
  4013d0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4013d4:	f9465611 	ldr	x17, [x16, #3240]
  4013d8:	9132a210 	add	x16, x16, #0xca8
  4013dc:	d61f0220 	br	x17

00000000004013e0 <__vsnprintf_chk@plt>:
  4013e0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4013e4:	f9465a11 	ldr	x17, [x16, #3248]
  4013e8:	9132c210 	add	x16, x16, #0xcb0
  4013ec:	d61f0220 	br	x17

00000000004013f0 <lroundf@plt>:
  4013f0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4013f4:	f9465e11 	ldr	x17, [x16, #3256]
  4013f8:	9132e210 	add	x16, x16, #0xcb8
  4013fc:	d61f0220 	br	x17

0000000000401400 <sigemptyset@plt>:
  401400:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401404:	f9466211 	ldr	x17, [x16, #3264]
  401408:	91330210 	add	x16, x16, #0xcc0
  40140c:	d61f0220 	br	x17

0000000000401410 <strncmp@plt>:
  401410:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401414:	f9466611 	ldr	x17, [x16, #3272]
  401418:	91332210 	add	x16, x16, #0xcc8
  40141c:	d61f0220 	br	x17

0000000000401420 <memset@plt>:
  401420:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401424:	f9466a11 	ldr	x17, [x16, #3280]
  401428:	91334210 	add	x16, x16, #0xcd0
  40142c:	d61f0220 	br	x17

0000000000401430 <sleep@plt>:
  401430:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401434:	f9466e11 	ldr	x17, [x16, #3288]
  401438:	91336210 	add	x16, x16, #0xcd8
  40143c:	d61f0220 	br	x17

0000000000401440 <random@plt>:
  401440:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401444:	f9467211 	ldr	x17, [x16, #3296]
  401448:	91338210 	add	x16, x16, #0xce0
  40144c:	d61f0220 	br	x17

0000000000401450 <__vfprintf_chk@plt>:
  401450:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401454:	f9467611 	ldr	x17, [x16, #3304]
  401458:	9133a210 	add	x16, x16, #0xce8
  40145c:	d61f0220 	br	x17

0000000000401460 <calloc@plt>:
  401460:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401464:	f9467a11 	ldr	x17, [x16, #3312]
  401468:	9133c210 	add	x16, x16, #0xcf0
  40146c:	d61f0220 	br	x17

0000000000401470 <pthread_cond_broadcast@plt>:
  401470:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401474:	f9467e11 	ldr	x17, [x16, #3320]
  401478:	9133e210 	add	x16, x16, #0xcf8
  40147c:	d61f0220 	br	x17

0000000000401480 <strcasecmp@plt>:
  401480:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401484:	f9468211 	ldr	x17, [x16, #3328]
  401488:	91340210 	add	x16, x16, #0xd00
  40148c:	d61f0220 	br	x17

0000000000401490 <realloc@plt>:
  401490:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401494:	f9468611 	ldr	x17, [x16, #3336]
  401498:	91342210 	add	x16, x16, #0xd08
  40149c:	d61f0220 	br	x17

00000000004014a0 <strdup@plt>:
  4014a0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4014a4:	f9468a11 	ldr	x17, [x16, #3344]
  4014a8:	91344210 	add	x16, x16, #0xd10
  4014ac:	d61f0220 	br	x17

00000000004014b0 <__stack_chk_fail@plt>:
  4014b0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4014b4:	f9468e11 	ldr	x17, [x16, #3352]
  4014b8:	91346210 	add	x16, x16, #0xd18
  4014bc:	d61f0220 	br	x17

00000000004014c0 <sigaction@plt>:
  4014c0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4014c4:	f9469211 	ldr	x17, [x16, #3360]
  4014c8:	91348210 	add	x16, x16, #0xd20
  4014cc:	d61f0220 	br	x17

00000000004014d0 <__gmon_start__@plt>:
  4014d0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4014d4:	f9469611 	ldr	x17, [x16, #3368]
  4014d8:	9134a210 	add	x16, x16, #0xd28
  4014dc:	d61f0220 	br	x17

00000000004014e0 <__getauxval@plt>:
  4014e0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4014e4:	f9469a11 	ldr	x17, [x16, #3376]
  4014e8:	9134c210 	add	x16, x16, #0xd30
  4014ec:	d61f0220 	br	x17

00000000004014f0 <abort@plt>:
  4014f0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4014f4:	f9469e11 	ldr	x17, [x16, #3384]
  4014f8:	9134e210 	add	x16, x16, #0xd38
  4014fc:	d61f0220 	br	x17

0000000000401500 <pthread_exit@plt>:
  401500:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401504:	f946a211 	ldr	x17, [x16, #3392]
  401508:	91350210 	add	x16, x16, #0xd40
  40150c:	d61f0220 	br	x17

0000000000401510 <__fprintf_chk@plt>:
  401510:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401514:	f946a611 	ldr	x17, [x16, #3400]
  401518:	91352210 	add	x16, x16, #0xd48
  40151c:	d61f0220 	br	x17

0000000000401520 <strcmp@plt>:
  401520:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401524:	f946aa11 	ldr	x17, [x16, #3408]
  401528:	91354210 	add	x16, x16, #0xd50
  40152c:	d61f0220 	br	x17

0000000000401530 <__ctype_b_loc@plt>:
  401530:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401534:	f946ae11 	ldr	x17, [x16, #3416]
  401538:	91356210 	add	x16, x16, #0xd58
  40153c:	d61f0220 	br	x17

0000000000401540 <pthread_detach@plt>:
  401540:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401544:	f946b211 	ldr	x17, [x16, #3424]
  401548:	91358210 	add	x16, x16, #0xd60
  40154c:	d61f0220 	br	x17

0000000000401550 <strtol@plt>:
  401550:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401554:	f946b611 	ldr	x17, [x16, #3432]
  401558:	9135a210 	add	x16, x16, #0xd68
  40155c:	d61f0220 	br	x17

0000000000401560 <free@plt>:
  401560:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401564:	f946ba11 	ldr	x17, [x16, #3440]
  401568:	9135c210 	add	x16, x16, #0xd70
  40156c:	d61f0220 	br	x17

0000000000401570 <pthread_cond_wait@plt>:
  401570:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401574:	f946be11 	ldr	x17, [x16, #3448]
  401578:	9135e210 	add	x16, x16, #0xd78
  40157c:	d61f0220 	br	x17

0000000000401580 <nanosleep@plt>:
  401580:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401584:	f946c211 	ldr	x17, [x16, #3456]
  401588:	91360210 	add	x16, x16, #0xd80
  40158c:	d61f0220 	br	x17

0000000000401590 <__pthread_unwind_next@plt>:
  401590:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401594:	f946c611 	ldr	x17, [x16, #3464]
  401598:	91362210 	add	x16, x16, #0xd88
  40159c:	d61f0220 	br	x17

00000000004015a0 <strtoull@plt>:
  4015a0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4015a4:	f946ca11 	ldr	x17, [x16, #3472]
  4015a8:	91364210 	add	x16, x16, #0xd90
  4015ac:	d61f0220 	br	x17

00000000004015b0 <pthread_create@plt>:
  4015b0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4015b4:	f946ce11 	ldr	x17, [x16, #3480]
  4015b8:	91366210 	add	x16, x16, #0xd98
  4015bc:	d61f0220 	br	x17

00000000004015c0 <isatty@plt>:
  4015c0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4015c4:	f946d211 	ldr	x17, [x16, #3488]
  4015c8:	91368210 	add	x16, x16, #0xda0
  4015cc:	d61f0220 	br	x17

00000000004015d0 <srandom@plt>:
  4015d0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4015d4:	f946d611 	ldr	x17, [x16, #3496]
  4015d8:	9136a210 	add	x16, x16, #0xda8
  4015dc:	d61f0220 	br	x17

00000000004015e0 <strncpy@plt>:
  4015e0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4015e4:	f946da11 	ldr	x17, [x16, #3504]
  4015e8:	9136c210 	add	x16, x16, #0xdb0
  4015ec:	d61f0220 	br	x17

00000000004015f0 <__pthread_register_cancel@plt>:
  4015f0:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  4015f4:	f946de11 	ldr	x17, [x16, #3512]
  4015f8:	9136e210 	add	x16, x16, #0xdb8
  4015fc:	d61f0220 	br	x17

0000000000401600 <pthread_self@plt>:
  401600:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401604:	f946e211 	ldr	x17, [x16, #3520]
  401608:	91370210 	add	x16, x16, #0xdc0
  40160c:	d61f0220 	br	x17

0000000000401610 <__errno_location@plt>:
  401610:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401614:	f946e611 	ldr	x17, [x16, #3528]
  401618:	91372210 	add	x16, x16, #0xdc8
  40161c:	d61f0220 	br	x17

0000000000401620 <pthread_cancel@plt>:
  401620:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401624:	f946ea11 	ldr	x17, [x16, #3536]
  401628:	91374210 	add	x16, x16, #0xdd0
  40162c:	d61f0220 	br	x17

0000000000401630 <pthread_mutex_lock@plt>:
  401630:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401634:	f946ee11 	ldr	x17, [x16, #3544]
  401638:	91376210 	add	x16, x16, #0xdd8
  40163c:	d61f0220 	br	x17

0000000000401640 <pthread_mutex_unlock@plt>:
  401640:	f0000150 	adrp	x16, 42c000 <__FRAME_END__+0xfbbc>
  401644:	f946f211 	ldr	x17, [x16, #3552]
  401648:	91378210 	add	x16, x16, #0xde0
  40164c:	d61f0220 	br	x17

Disassembly of section .text:

0000000000401680 <init_have_lse_atomics>:
  401680:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  401684:	d2800200 	mov	x0, #0x10                  	// #16
  401688:	910003fd 	mov	x29, sp
  40168c:	97ffff95 	bl	4014e0 <__getauxval@plt>
  401690:	53082000 	ubfx	w0, w0, #8, #1
  401694:	f0000161 	adrp	x1, 430000 <stdout_buff+0x6f>
  401698:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40169c:	39024c20 	strb	w0, [x1, #147]
  4016a0:	d65f03c0 	ret
  4016a4:	d503201f 	nop
  4016a8:	d503201f 	nop
  4016ac:	d503201f 	nop
  4016b0:	d503201f 	nop
  4016b4:	d503201f 	nop
  4016b8:	d503201f 	nop
  4016bc:	d503201f 	nop

00000000004016c0 <_start>:
  4016c0:	d503201f 	nop
  4016c4:	d280001d 	mov	x29, #0x0                   	// #0
  4016c8:	d280001e 	mov	x30, #0x0                   	// #0
  4016cc:	aa0003e5 	mov	x5, x0
  4016d0:	f94003e1 	ldr	x1, [sp]
  4016d4:	910023e2 	add	x2, sp, #0x8
  4016d8:	910003e6 	mov	x6, sp
  4016dc:	f0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4016e0:	f947bc00 	ldr	x0, [x0, #3960]
  4016e4:	d2800003 	mov	x3, #0x0                   	// #0
  4016e8:	d2800004 	mov	x4, #0x0                   	// #0
  4016ec:	97ffff0d 	bl	401320 <__libc_start_main@plt>
  4016f0:	97ffff80 	bl	4014f0 <abort@plt>
  4016f4:	d503201f 	nop
  4016f8:	d503201f 	nop
  4016fc:	d503201f 	nop

0000000000401700 <deregister_tm_clones>:
  401700:	90000160 	adrp	x0, 42d000 <__dso_handle>
  401704:	912bc000 	add	x0, x0, #0xaf0
  401708:	90000161 	adrp	x1, 42d000 <__dso_handle>
  40170c:	912bc021 	add	x1, x1, #0xaf0
  401710:	eb00003f 	cmp	x1, x0
  401714:	540000c0 	b.eq	40172c <deregister_tm_clones+0x2c>  // b.none
  401718:	f0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40171c:	f9470021 	ldr	x1, [x1, #3584]
  401720:	b4000061 	cbz	x1, 40172c <deregister_tm_clones+0x2c>
  401724:	aa0103f0 	mov	x16, x1
  401728:	d61f0200 	br	x16
  40172c:	d65f03c0 	ret

0000000000401730 <register_tm_clones>:
  401730:	90000160 	adrp	x0, 42d000 <__dso_handle>
  401734:	912bc000 	add	x0, x0, #0xaf0
  401738:	90000161 	adrp	x1, 42d000 <__dso_handle>
  40173c:	912bc021 	add	x1, x1, #0xaf0
  401740:	cb000021 	sub	x1, x1, x0
  401744:	d37ffc22 	lsr	x2, x1, #63
  401748:	8b810c41 	add	x1, x2, x1, asr #3
  40174c:	9341fc21 	asr	x1, x1, #1
  401750:	b40000c1 	cbz	x1, 401768 <register_tm_clones+0x38>
  401754:	f0000142 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  401758:	f947e842 	ldr	x2, [x2, #4048]
  40175c:	b4000062 	cbz	x2, 401768 <register_tm_clones+0x38>
  401760:	aa0203f0 	mov	x16, x2
  401764:	d61f0200 	br	x16
  401768:	d65f03c0 	ret
  40176c:	d503201f 	nop

0000000000401770 <__do_global_dtors_aux>:
  401770:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  401774:	910003fd 	mov	x29, sp
  401778:	f9000bf3 	str	x19, [sp, #16]
  40177c:	d0000173 	adrp	x19, 42f000 <can_loopback_dev_data_0+0xc0>
  401780:	39753260 	ldrb	w0, [x19, #3404]
  401784:	35000140 	cbnz	w0, 4017ac <__do_global_dtors_aux+0x3c>
  401788:	f0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40178c:	f9471800 	ldr	x0, [x0, #3632]
  401790:	b4000080 	cbz	x0, 4017a0 <__do_global_dtors_aux+0x30>
  401794:	90000160 	adrp	x0, 42d000 <__dso_handle>
  401798:	f9400000 	ldr	x0, [x0]
  40179c:	97fffef5 	bl	401370 <__cxa_finalize@plt>
  4017a0:	97ffffd8 	bl	401700 <deregister_tm_clones>
  4017a4:	52800020 	mov	w0, #0x1                   	// #1
  4017a8:	39353260 	strb	w0, [x19, #3404]
  4017ac:	f9400bf3 	ldr	x19, [sp, #16]
  4017b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4017b4:	d65f03c0 	ret
  4017b8:	d503201f 	nop
  4017bc:	d503201f 	nop

00000000004017c0 <frame_dummy>:
  4017c0:	17ffffdc 	b	401730 <register_tm_clones>
  4017c4:	d503201f 	nop
  4017c8:	d503201f 	nop
  4017cc:	d503201f 	nop

00000000004017d0 <__aarch64_ldadd8_acq_rel>:
  4017d0:	d503245f 	bti	c
  4017d4:	f0000170 	adrp	x16, 430000 <stdout_buff+0x6f>
  4017d8:	39424e10 	ldrb	w16, [x16, #147]
  4017dc:	34000070 	cbz	w16, 4017e8 <__aarch64_ldadd8_acq_rel+0x18>
  4017e0:	f8e00020 	ldaddal	x0, x0, [x1]
  4017e4:	d65f03c0 	ret
  4017e8:	aa0003f0 	mov	x16, x0
  4017ec:	c85ffc20 	ldaxr	x0, [x1]
  4017f0:	8b100011 	add	x17, x0, x16
  4017f4:	c80ffc31 	stlxr	w15, x17, [x1]
  4017f8:	35ffffaf 	cbnz	w15, 4017ec <__aarch64_ldadd8_acq_rel+0x1c>
  4017fc:	d65f03c0 	ret

0000000000401800 <__divtf3>:
  401800:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  401804:	910003fd 	mov	x29, sp
  401808:	3d8007e0 	str	q0, [sp, #16]
  40180c:	3d800be1 	str	q1, [sp, #32]
  401810:	a94103e1 	ldp	x1, x0, [sp, #16]
  401814:	a9420fe6 	ldp	x6, x3, [sp, #32]
  401818:	d53b440c 	mrs	x12, fpcr
  40181c:	d37ffc04 	lsr	x4, x0, #63
  401820:	d340bc02 	ubfx	x2, x0, #0, #48
  401824:	12001c8d 	and	w13, w4, #0xff
  401828:	aa0403ea 	mov	x10, x4
  40182c:	d370f808 	ubfx	x8, x0, #48, #15
  401830:	34001ee8 	cbz	w8, 401c0c <__divtf3+0x40c>
  401834:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401838:	6b04011f 	cmp	w8, w4
  40183c:	540020c0 	b.eq	401c54 <__divtf3+0x454>  // b.none
  401840:	92403d08 	and	x8, x8, #0xffff
  401844:	93c1f442 	extr	x2, x2, x1, #61
  401848:	9287ffce 	mov	x14, #0xffffffffffffc001    	// #-16383
  40184c:	d37df021 	lsl	x1, x1, #3
  401850:	8b0e0108 	add	x8, x8, x14
  401854:	b24d0045 	orr	x5, x2, #0x8000000000000
  401858:	d2800010 	mov	x16, #0x0                   	// #0
  40185c:	d2800002 	mov	x2, #0x0                   	// #0
  401860:	52800000 	mov	w0, #0x0                   	// #0
  401864:	d37ffc64 	lsr	x4, x3, #63
  401868:	d340bc67 	ubfx	x7, x3, #0, #48
  40186c:	12001c8f 	and	w15, w4, #0xff
  401870:	aa0403e9 	mov	x9, x4
  401874:	d370f864 	ubfx	x4, x3, #48, #15
  401878:	34001a04 	cbz	w4, 401bb8 <__divtf3+0x3b8>
  40187c:	528fffeb 	mov	w11, #0x7fff                	// #32767
  401880:	6b0b009f 	cmp	w4, w11
  401884:	54001f80 	b.eq	401c74 <__divtf3+0x474>  // b.none
  401888:	9287ffcb 	mov	x11, #0xffffffffffffc001    	// #-16383
  40188c:	92403c84 	and	x4, x4, #0xffff
  401890:	8b0b0084 	add	x4, x4, x11
  401894:	93c6f4e7 	extr	x7, x7, x6, #61
  401898:	4a0f01ab 	eor	w11, w13, w15
  40189c:	b24d00e7 	orr	x7, x7, #0x8000000000000
  4018a0:	cb040108 	sub	x8, x8, x4
  4018a4:	d37df0c6 	lsl	x6, x6, #3
  4018a8:	92401d6e 	and	x14, x11, #0xff
  4018ac:	d2800003 	mov	x3, #0x0                   	// #0
  4018b0:	f100245f 	cmp	x2, #0x9
  4018b4:	5400046c 	b.gt	401940 <__divtf3+0x140>
  4018b8:	f1001c5f 	cmp	x2, #0x7
  4018bc:	54002bcc 	b.gt	401e34 <__divtf3+0x634>
  4018c0:	f1000c5f 	cmp	x2, #0x3
  4018c4:	540000e0 	b.eq	4018e0 <__divtf3+0xe0>  // b.none
  4018c8:	5400050d 	b.le	401968 <__divtf3+0x168>
  4018cc:	f100145f 	cmp	x2, #0x5
  4018d0:	54000400 	b.eq	401950 <__divtf3+0x150>  // b.none
  4018d4:	5400080d 	b.le	4019d4 <__divtf3+0x1d4>
  4018d8:	f100185f 	cmp	x2, #0x6
  4018dc:	54000640 	b.eq	4019a4 <__divtf3+0x1a4>  // b.none
  4018e0:	f100047f 	cmp	x3, #0x1
  4018e4:	54002780 	b.eq	401dd4 <__divtf3+0x5d4>  // b.none
  4018e8:	b40000a3 	cbz	x3, 4018fc <__divtf3+0xfc>
  4018ec:	f100087f 	cmp	x3, #0x2
  4018f0:	54003260 	b.eq	401f3c <__divtf3+0x73c>  // b.none
  4018f4:	f1000c7f 	cmp	x3, #0x3
  4018f8:	54003160 	b.eq	401f24 <__divtf3+0x724>  // b.none
  4018fc:	d287ffe1 	mov	x1, #0x3fff                	// #16383
  401900:	8b010104 	add	x4, x8, x1
  401904:	f100009f 	cmp	x4, #0x0
  401908:	5400222d 	b.le	401d4c <__divtf3+0x54c>
  40190c:	f24008df 	tst	x6, #0x7
  401910:	540026c1 	b.ne	401de8 <__divtf3+0x5e8>  // b.any
  401914:	1200012b 	and	w11, w9, #0x1
  401918:	b6a00067 	tbz	x7, #52, 401924 <__divtf3+0x124>
  40191c:	924bf8e7 	and	x7, x7, #0xffefffffffffffff
  401920:	91401104 	add	x4, x8, #0x4, lsl #12
  401924:	d28fffc2 	mov	x2, #0x7ffe                	// #32766
  401928:	eb02009f 	cmp	x4, x2
  40192c:	54002cec 	b.gt	401ec8 <__divtf3+0x6c8>
  401930:	d343c8e5 	ubfx	x5, x7, #3, #48
  401934:	93c60ce1 	extr	x1, x7, x6, #3
  401938:	12003884 	and	w4, w4, #0x7fff
  40193c:	1400001d 	b	4019b0 <__divtf3+0x1b0>
  401940:	f1002c5f 	cmp	x2, #0xb
  401944:	54001c4c 	b.gt	401ccc <__divtf3+0x4cc>
  401948:	f100285f 	cmp	x2, #0xa
  40194c:	54fffca1 	b.ne	4018e0 <__divtf3+0xe0>  // b.any
  401950:	5280000b 	mov	w11, #0x0                   	// #0
  401954:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401958:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40195c:	52800020 	mov	w0, #0x1                   	// #1
  401960:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401964:	14000013 	b	4019b0 <__divtf3+0x1b0>
  401968:	f100045f 	cmp	x2, #0x1
  40196c:	54000181 	b.ne	40199c <__divtf3+0x19c>  // b.any
  401970:	d2800002 	mov	x2, #0x0                   	// #0
  401974:	9e670040 	fmov	d0, x2
  401978:	d34101ce 	lsl	x14, x14, #63
  40197c:	321f0000 	orr	w0, w0, #0x2
  401980:	b25039c3 	orr	x3, x14, #0x7fff000000000000
  401984:	9eaf0060 	fmov	v0.d[1], x3
  401988:	3d8007e0 	str	q0, [sp, #16]
  40198c:	9400021d 	bl	402200 <__sfp_handle_exceptions>
  401990:	3dc007e0 	ldr	q0, [sp, #16]
  401994:	a8c37bfd 	ldp	x29, x30, [sp], #48
  401998:	d65f03c0 	ret
  40199c:	f100085f 	cmp	x2, #0x2
  4019a0:	540001e1 	b.ne	4019dc <__divtf3+0x1dc>  // b.any
  4019a4:	52800004 	mov	w4, #0x0                   	// #0
  4019a8:	d2800005 	mov	x5, #0x0                   	// #0
  4019ac:	d2800001 	mov	x1, #0x0                   	// #0
  4019b0:	d2800003 	mov	x3, #0x0                   	// #0
  4019b4:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  4019b8:	b340bca3 	bfxil	x3, x5, #0, #48
  4019bc:	9e670020 	fmov	d0, x1
  4019c0:	b3503c83 	bfi	x3, x4, #48, #16
  4019c4:	9eaf0060 	fmov	v0.d[1], x3
  4019c8:	35fffe00 	cbnz	w0, 401988 <__divtf3+0x188>
  4019cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4019d0:	d65f03c0 	ret
  4019d4:	f100105f 	cmp	x2, #0x4
  4019d8:	54fffe60 	b.eq	4019a4 <__divtf3+0x1a4>  // b.none
  4019dc:	eb0700bf 	cmp	x5, x7
  4019e0:	54000068 	b.hi	4019ec <__divtf3+0x1ec>  // b.pmore
  4019e4:	fa4100c2 	ccmp	x6, x1, #0x2, eq  // eq = none
  4019e8:	54002da8 	b.hi	401f9c <__divtf3+0x79c>  // b.pmore
  4019ec:	d341fca3 	lsr	x3, x5, #1
  4019f0:	93c104a2 	extr	x2, x5, x1, #1
  4019f4:	d3410021 	lsl	x1, x1, #63
  4019f8:	d354cce9 	ubfx	x9, x7, #20, #32
  4019fc:	93c6d0e4 	extr	x4, x7, x6, #52
  401a00:	92407c8a 	and	x10, x4, #0xffffffff
  401a04:	d374ccc5 	lsl	x5, x6, #12
  401a08:	9ac90867 	udiv	x7, x3, x9
  401a0c:	9b098ce3 	msub	x3, x7, x9, x3
  401a10:	9b077d46 	mul	x6, x10, x7
  401a14:	93c28063 	extr	x3, x3, x2, #32
  401a18:	eb0300df 	cmp	x6, x3
  401a1c:	540000c9 	b.ls	401a34 <__divtf3+0x234>  // b.plast
  401a20:	ab030083 	adds	x3, x4, x3
  401a24:	d10004ed 	sub	x13, x7, #0x1
  401a28:	fa4330c0 	ccmp	x6, x3, #0x0, cc  // cc = lo, ul, last
  401a2c:	54003088 	b.hi	40203c <__divtf3+0x83c>  // b.pmore
  401a30:	aa0d03e7 	mov	x7, x13
  401a34:	cb060063 	sub	x3, x3, x6
  401a38:	9ac90866 	udiv	x6, x3, x9
  401a3c:	9b098cc3 	msub	x3, x6, x9, x3
  401a40:	9b067d50 	mul	x16, x10, x6
  401a44:	b3607c62 	bfi	x2, x3, #32, #32
  401a48:	eb02021f 	cmp	x16, x2
  401a4c:	540000c9 	b.ls	401a64 <__divtf3+0x264>  // b.plast
  401a50:	ab020082 	adds	x2, x4, x2
  401a54:	d10004c3 	sub	x3, x6, #0x1
  401a58:	fa423200 	ccmp	x16, x2, #0x0, cc  // cc = lo, ul, last
  401a5c:	54002ea8 	b.hi	402030 <__divtf3+0x830>  // b.pmore
  401a60:	aa0303e6 	mov	x6, x3
  401a64:	aa0780d1 	orr	x17, x6, x7, lsl #32
  401a68:	92407caf 	and	x15, x5, #0xffffffff
  401a6c:	92407e27 	and	x7, x17, #0xffffffff
  401a70:	d360fcad 	lsr	x13, x5, #32
  401a74:	d360fe26 	lsr	x6, x17, #32
  401a78:	cb100042 	sub	x2, x2, x16
  401a7c:	d2c00032 	mov	x18, #0x100000000           	// #4294967296
  401a80:	9b0f7ce3 	mul	x3, x7, x15
  401a84:	9b0f7cde 	mul	x30, x6, x15
  401a88:	9b0779a7 	madd	x7, x13, x7, x30
  401a8c:	92407c70 	and	x16, x3, #0xffffffff
  401a90:	9b0d7cc6 	mul	x6, x6, x13
  401a94:	8b4380e3 	add	x3, x7, x3, lsr #32
  401a98:	8b1200c7 	add	x7, x6, x18
  401a9c:	eb0303df 	cmp	x30, x3
  401aa0:	9a8680e6 	csel	x6, x7, x6, hi  // hi = pmore
  401aa4:	8b038210 	add	x16, x16, x3, lsl #32
  401aa8:	8b4380c3 	add	x3, x6, x3, lsr #32
  401aac:	eb03005f 	cmp	x2, x3
  401ab0:	54001ca3 	b.cc	401e44 <__divtf3+0x644>  // b.lo, b.ul, b.last
  401ab4:	fa500022 	ccmp	x1, x16, #0x2, eq  // eq = none
  401ab8:	aa1103e7 	mov	x7, x17
  401abc:	54001c43 	b.cc	401e44 <__divtf3+0x644>  // b.lo, b.ul, b.last
  401ac0:	eb100021 	subs	x1, x1, x16
  401ac4:	da030042 	sbc	x2, x2, x3
  401ac8:	eb02009f 	cmp	x4, x2
  401acc:	54002be0 	b.eq	402048 <__divtf3+0x848>  // b.none
  401ad0:	9ac90846 	udiv	x6, x2, x9
  401ad4:	9b0988c2 	msub	x2, x6, x9, x2
  401ad8:	9b067d43 	mul	x3, x10, x6
  401adc:	93c18042 	extr	x2, x2, x1, #32
  401ae0:	eb02007f 	cmp	x3, x2
  401ae4:	540000c9 	b.ls	401afc <__divtf3+0x2fc>  // b.plast
  401ae8:	ab020082 	adds	x2, x4, x2
  401aec:	d10004cb 	sub	x11, x6, #0x1
  401af0:	fa423060 	ccmp	x3, x2, #0x0, cc  // cc = lo, ul, last
  401af4:	540030e8 	b.hi	402110 <__divtf3+0x910>  // b.pmore
  401af8:	aa0b03e6 	mov	x6, x11
  401afc:	cb030042 	sub	x2, x2, x3
  401b00:	9ac90843 	udiv	x3, x2, x9
  401b04:	9b098869 	msub	x9, x3, x9, x2
  401b08:	9b037d4a 	mul	x10, x10, x3
  401b0c:	b3607d21 	bfi	x1, x9, #32, #32
  401b10:	eb01015f 	cmp	x10, x1
  401b14:	540000c9 	b.ls	401b2c <__divtf3+0x32c>  // b.plast
  401b18:	ab010081 	adds	x1, x4, x1
  401b1c:	d1000462 	sub	x2, x3, #0x1
  401b20:	fa413140 	ccmp	x10, x1, #0x0, cc  // cc = lo, ul, last
  401b24:	54002f08 	b.hi	402104 <__divtf3+0x904>  // b.pmore
  401b28:	aa0203e3 	mov	x3, x2
  401b2c:	aa068066 	orr	x6, x3, x6, lsl #32
  401b30:	cb0a0021 	sub	x1, x1, x10
  401b34:	92407cc3 	and	x3, x6, #0xffffffff
  401b38:	d2c0002b 	mov	x11, #0x100000000           	// #4294967296
  401b3c:	d360fcca 	lsr	x10, x6, #32
  401b40:	9b037de2 	mul	x2, x15, x3
  401b44:	9b0f7d4f 	mul	x15, x10, x15
  401b48:	9b033da3 	madd	x3, x13, x3, x15
  401b4c:	92407c49 	and	x9, x2, #0xffffffff
  401b50:	9b0a7dad 	mul	x13, x13, x10
  401b54:	8b428062 	add	x2, x3, x2, lsr #32
  401b58:	8b0b01a3 	add	x3, x13, x11
  401b5c:	eb0201ff 	cmp	x15, x2
  401b60:	9a8d806d 	csel	x13, x3, x13, hi  // hi = pmore
  401b64:	8b028123 	add	x3, x9, x2, lsl #32
  401b68:	8b4281a2 	add	x2, x13, x2, lsr #32
  401b6c:	eb02003f 	cmp	x1, x2
  401b70:	54002042 	b.cs	401f78 <__divtf3+0x778>  // b.hs, b.nlast
  401b74:	ab010089 	adds	x9, x4, x1
  401b78:	d10004ca 	sub	x10, x6, #0x1
  401b7c:	aa0903e1 	mov	x1, x9
  401b80:	540000a2 	b.cs	401b94 <__divtf3+0x394>  // b.hs, b.nlast
  401b84:	eb02013f 	cmp	x9, x2
  401b88:	54002823 	b.cc	40208c <__divtf3+0x88c>  // b.lo, b.ul, b.last
  401b8c:	fa4300a2 	ccmp	x5, x3, #0x2, eq  // eq = none
  401b90:	540027e3 	b.cc	40208c <__divtf3+0x88c>  // b.lo, b.ul, b.last
  401b94:	eb0300bf 	cmp	x5, x3
  401b98:	aa0a03e6 	mov	x6, x10
  401b9c:	1a9f07e9 	cset	w9, ne  // ne = any
  401ba0:	7100013f 	cmp	w9, #0x0
  401ba4:	aa0e03e9 	mov	x9, x14
  401ba8:	fa420020 	ccmp	x1, x2, #0x0, eq  // eq = none
  401bac:	b24000c1 	orr	x1, x6, #0x1
  401bb0:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  401bb4:	17ffff52 	b	4018fc <__divtf3+0xfc>
  401bb8:	aa0700c3 	orr	x3, x6, x7
  401bbc:	b4000b63 	cbz	x3, 401d28 <__divtf3+0x528>
  401bc0:	b4001707 	cbz	x7, 401ea0 <__divtf3+0x6a0>
  401bc4:	dac010e3 	clz	x3, x7
  401bc8:	d1003c64 	sub	x4, x3, #0xf
  401bcc:	11000c8e 	add	w14, w4, #0x3
  401bd0:	528007ab 	mov	w11, #0x3d                  	// #61
  401bd4:	4b040164 	sub	w4, w11, w4
  401bd8:	9ace20e7 	lsl	x7, x7, x14
  401bdc:	9ac424c4 	lsr	x4, x6, x4
  401be0:	aa070087 	orr	x7, x4, x7
  401be4:	9ace20c6 	lsl	x6, x6, x14
  401be8:	8b080064 	add	x4, x3, x8
  401bec:	4a0f01ab 	eor	w11, w13, w15
  401bf0:	d287fde8 	mov	x8, #0x3fef                	// #16367
  401bf4:	92401d6e 	and	x14, x11, #0xff
  401bf8:	8b080088 	add	x8, x4, x8
  401bfc:	d2800003 	mov	x3, #0x0                   	// #0
  401c00:	f100245f 	cmp	x2, #0x9
  401c04:	54ffe5ad 	b.le	4018b8 <__divtf3+0xb8>
  401c08:	17ffff4e 	b	401940 <__divtf3+0x140>
  401c0c:	aa020025 	orr	x5, x1, x2
  401c10:	b4000805 	cbz	x5, 401d10 <__divtf3+0x510>
  401c14:	b4001342 	cbz	x2, 401e7c <__divtf3+0x67c>
  401c18:	dac01040 	clz	x0, x2
  401c1c:	d1003c05 	sub	x5, x0, #0xf
  401c20:	11000ca7 	add	w7, w5, #0x3
  401c24:	528007a4 	mov	w4, #0x3d                  	// #61
  401c28:	4b050084 	sub	w4, w4, w5
  401c2c:	9ac72042 	lsl	x2, x2, x7
  401c30:	9ac42424 	lsr	x4, x1, x4
  401c34:	aa020085 	orr	x5, x4, x2
  401c38:	9ac72021 	lsl	x1, x1, x7
  401c3c:	9287fdc8 	mov	x8, #0xffffffffffffc011    	// #-16367
  401c40:	d2800002 	mov	x2, #0x0                   	// #0
  401c44:	cb000108 	sub	x8, x8, x0
  401c48:	d2800010 	mov	x16, #0x0                   	// #0
  401c4c:	52800000 	mov	w0, #0x0                   	// #0
  401c50:	17ffff05 	b	401864 <__divtf3+0x64>
  401c54:	aa020025 	orr	x5, x1, x2
  401c58:	b50004e5 	cbnz	x5, 401cf4 <__divtf3+0x4f4>
  401c5c:	d2800001 	mov	x1, #0x0                   	// #0
  401c60:	d2800102 	mov	x2, #0x8                   	// #8
  401c64:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401c68:	d2800050 	mov	x16, #0x2                   	// #2
  401c6c:	52800000 	mov	w0, #0x0                   	// #0
  401c70:	17fffefd 	b	401864 <__divtf3+0x64>
  401c74:	928fffc3 	mov	x3, #0xffffffffffff8001    	// #-32767
  401c78:	8b030108 	add	x8, x8, x3
  401c7c:	aa0700c3 	orr	x3, x6, x7
  401c80:	b4000303 	cbz	x3, 401ce0 <__divtf3+0x4e0>
  401c84:	f25100ff 	tst	x7, #0x800000000000
  401c88:	b2400442 	orr	x2, x2, #0x3
  401c8c:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
  401c90:	d2800063 	mov	x3, #0x3                   	// #3
  401c94:	4a0f01ab 	eor	w11, w13, w15
  401c98:	92401d6e 	and	x14, x11, #0xff
  401c9c:	f100245f 	cmp	x2, #0x9
  401ca0:	54ffe0cd 	b.le	4018b8 <__divtf3+0xb8>
  401ca4:	f1003c5f 	cmp	x2, #0xf
  401ca8:	54ffe4c1 	b.ne	401940 <__divtf3+0x140>  // b.any
  401cac:	b6780ba5 	tbz	x5, #47, 401e20 <__divtf3+0x620>
  401cb0:	b7780b87 	tbnz	x7, #47, 401e20 <__divtf3+0x620>
  401cb4:	b25100e5 	orr	x5, x7, #0x800000000000
  401cb8:	2a0f03eb 	mov	w11, w15
  401cbc:	9240bca5 	and	x5, x5, #0xffffffffffff
  401cc0:	aa0603e1 	mov	x1, x6
  401cc4:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401cc8:	17ffff3a 	b	4019b0 <__divtf3+0x1b0>
  401ccc:	aa0503e7 	mov	x7, x5
  401cd0:	aa0103e6 	mov	x6, x1
  401cd4:	aa0a03e9 	mov	x9, x10
  401cd8:	aa1003e3 	mov	x3, x16
  401cdc:	17ffff01 	b	4018e0 <__divtf3+0xe0>
  401ce0:	b27f0042 	orr	x2, x2, #0x2
  401ce4:	d2800007 	mov	x7, #0x0                   	// #0
  401ce8:	d2800006 	mov	x6, #0x0                   	// #0
  401cec:	d2800043 	mov	x3, #0x2                   	// #2
  401cf0:	17ffffe9 	b	401c94 <__divtf3+0x494>
  401cf4:	d36ffc40 	lsr	x0, x2, #47
  401cf8:	aa0203e5 	mov	x5, x2
  401cfc:	52000000 	eor	w0, w0, #0x1
  401d00:	d2800182 	mov	x2, #0xc                   	// #12
  401d04:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401d08:	d2800070 	mov	x16, #0x3                   	// #3
  401d0c:	17fffed6 	b	401864 <__divtf3+0x64>
  401d10:	d2800001 	mov	x1, #0x0                   	// #0
  401d14:	d2800082 	mov	x2, #0x4                   	// #4
  401d18:	d2800008 	mov	x8, #0x0                   	// #0
  401d1c:	d2800030 	mov	x16, #0x1                   	// #1
  401d20:	52800000 	mov	w0, #0x0                   	// #0
  401d24:	17fffed0 	b	401864 <__divtf3+0x64>
  401d28:	4a0f01ab 	eor	w11, w13, w15
  401d2c:	b2400042 	orr	x2, x2, #0x1
  401d30:	92401d6e 	and	x14, x11, #0xff
  401d34:	d2800007 	mov	x7, #0x0                   	// #0
  401d38:	d2800006 	mov	x6, #0x0                   	// #0
  401d3c:	d2800023 	mov	x3, #0x1                   	// #1
  401d40:	f100245f 	cmp	x2, #0x9
  401d44:	54ffdbad 	b.le	4018b8 <__divtf3+0xb8>
  401d48:	17fffefe 	b	401940 <__divtf3+0x140>
  401d4c:	d2800021 	mov	x1, #0x1                   	// #1
  401d50:	cb040024 	sub	x4, x1, x4
  401d54:	1200012b 	and	w11, w9, #0x1
  401d58:	f101d09f 	cmp	x4, #0x74
  401d5c:	5400102c 	b.gt	401f60 <__divtf3+0x760>
  401d60:	f100fc9f 	cmp	x4, #0x3f
  401d64:	5400126d 	b.le	401fb0 <__divtf3+0x7b0>
  401d68:	52801001 	mov	w1, #0x80                  	// #128
  401d6c:	4b040021 	sub	w1, w1, w4
  401d70:	f101009f 	cmp	x4, #0x40
  401d74:	51010084 	sub	w4, w4, #0x40
  401d78:	9ac120e1 	lsl	x1, x7, x1
  401d7c:	aa0100c1 	orr	x1, x6, x1
  401d80:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  401d84:	9ac424e1 	lsr	x1, x7, x4
  401d88:	f10000df 	cmp	x6, #0x0
  401d8c:	9a9f07e2 	cset	x2, ne  // ne = any
  401d90:	aa010041 	orr	x1, x2, x1
  401d94:	f2400825 	ands	x5, x1, #0x7
  401d98:	54001260 	b.eq	401fe4 <__divtf3+0x7e4>  // b.none
  401d9c:	d2800005 	mov	x5, #0x0                   	// #0
  401da0:	926a058c 	and	x12, x12, #0xc00000
  401da4:	321c0000 	orr	w0, w0, #0x10
  401da8:	f150019f 	cmp	x12, #0x400, lsl #12
  401dac:	54001800 	b.eq	4020ac <__divtf3+0x8ac>  // b.none
  401db0:	f160019f 	cmp	x12, #0x800, lsl #12
  401db4:	54001c80 	b.eq	402144 <__divtf3+0x944>  // b.none
  401db8:	b4001b8c 	cbz	x12, 402128 <__divtf3+0x928>
  401dbc:	b7981805 	tbnz	x5, #51, 4020bc <__divtf3+0x8bc>
  401dc0:	321d0000 	orr	w0, w0, #0x8
  401dc4:	93c10ca1 	extr	x1, x5, x1, #3
  401dc8:	52800004 	mov	w4, #0x0                   	// #0
  401dcc:	d343c8a5 	ubfx	x5, x5, #3, #48
  401dd0:	1400004b 	b	401efc <__divtf3+0x6fc>
  401dd4:	1200012b 	and	w11, w9, #0x1
  401dd8:	52800004 	mov	w4, #0x0                   	// #0
  401ddc:	d2800005 	mov	x5, #0x0                   	// #0
  401de0:	d2800001 	mov	x1, #0x0                   	// #0
  401de4:	17fffef3 	b	4019b0 <__divtf3+0x1b0>
  401de8:	926a0581 	and	x1, x12, #0xc00000
  401dec:	321c0000 	orr	w0, w0, #0x10
  401df0:	f150003f 	cmp	x1, #0x400, lsl #12
  401df4:	540017c0 	b.eq	4020ec <__divtf3+0x8ec>  // b.none
  401df8:	f160003f 	cmp	x1, #0x800, lsl #12
  401dfc:	540010e0 	b.eq	402018 <__divtf3+0x818>  // b.none
  401e00:	b5ffd8a1 	cbnz	x1, 401914 <__divtf3+0x114>
  401e04:	92400cc1 	and	x1, x6, #0xf
  401e08:	1200012b 	and	w11, w9, #0x1
  401e0c:	f100103f 	cmp	x1, #0x4
  401e10:	54ffd840 	b.eq	401918 <__divtf3+0x118>  // b.none
  401e14:	b10010c6 	adds	x6, x6, #0x4
  401e18:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401e1c:	17fffebf 	b	401918 <__divtf3+0x118>
  401e20:	b25100a5 	orr	x5, x5, #0x800000000000
  401e24:	2a0d03eb 	mov	w11, w13
  401e28:	9240bca5 	and	x5, x5, #0xffffffffffff
  401e2c:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401e30:	17fffee0 	b	4019b0 <__divtf3+0x1b0>
  401e34:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401e38:	d2800005 	mov	x5, #0x0                   	// #0
  401e3c:	d2800001 	mov	x1, #0x0                   	// #0
  401e40:	17fffedc 	b	4019b0 <__divtf3+0x1b0>
  401e44:	ab050026 	adds	x6, x1, x5
  401e48:	d1000627 	sub	x7, x17, #0x1
  401e4c:	9a040042 	adc	x2, x2, x4
  401e50:	9a9f37f2 	cset	x18, cs  // cs = hs, nlast
  401e54:	aa0603e1 	mov	x1, x6
  401e58:	eb02009f 	cmp	x4, x2
  401e5c:	540007a2 	b.cs	401f50 <__divtf3+0x750>  // b.hs, b.nlast
  401e60:	eb02007f 	cmp	x3, x2
  401e64:	54000969 	b.ls	401f90 <__divtf3+0x790>  // b.plast
  401e68:	ab0600a6 	adds	x6, x5, x6
  401e6c:	d1000a27 	sub	x7, x17, #0x2
  401e70:	aa0603e1 	mov	x1, x6
  401e74:	9a040042 	adc	x2, x2, x4
  401e78:	17ffff12 	b	401ac0 <__divtf3+0x2c0>
  401e7c:	dac01020 	clz	x0, x1
  401e80:	9100c405 	add	x5, x0, #0x31
  401e84:	91010000 	add	x0, x0, #0x40
  401e88:	f100f0bf 	cmp	x5, #0x3c
  401e8c:	54ffecad 	b.le	401c20 <__divtf3+0x420>
  401e90:	5100f4a5 	sub	w5, w5, #0x3d
  401e94:	9ac52025 	lsl	x5, x1, x5
  401e98:	d2800001 	mov	x1, #0x0                   	// #0
  401e9c:	17ffff68 	b	401c3c <__divtf3+0x43c>
  401ea0:	dac010c3 	clz	x3, x6
  401ea4:	9100c464 	add	x4, x3, #0x31
  401ea8:	91010063 	add	x3, x3, #0x40
  401eac:	f100f09f 	cmp	x4, #0x3c
  401eb0:	54ffe8ed 	b.le	401bcc <__divtf3+0x3cc>
  401eb4:	5100f484 	sub	w4, w4, #0x3d
  401eb8:	9ac420c4 	lsl	x4, x6, x4
  401ebc:	d2800006 	mov	x6, #0x0                   	// #0
  401ec0:	aa0403e7 	mov	x7, x4
  401ec4:	17ffff49 	b	401be8 <__divtf3+0x3e8>
  401ec8:	926a0581 	and	x1, x12, #0xc00000
  401ecc:	f150003f 	cmp	x1, #0x400, lsl #12
  401ed0:	54001000 	b.eq	4020d0 <__divtf3+0x8d0>  // b.none
  401ed4:	f160003f 	cmp	x1, #0x800, lsl #12
  401ed8:	54000920 	b.eq	401ffc <__divtf3+0x7fc>  // b.none
  401edc:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401ee0:	d2800005 	mov	x5, #0x0                   	// #0
  401ee4:	b4000081 	cbz	x1, 401ef4 <__divtf3+0x6f4>
  401ee8:	2a0203e4 	mov	w4, w2
  401eec:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401ef0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  401ef4:	52800282 	mov	w2, #0x14                  	// #20
  401ef8:	2a020000 	orr	w0, w0, w2
  401efc:	d2800003 	mov	x3, #0x0                   	// #0
  401f00:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  401f04:	b340bca3 	bfxil	x3, x5, #0, #48
  401f08:	9e670020 	fmov	d0, x1
  401f0c:	b3503c83 	bfi	x3, x4, #48, #16
  401f10:	9eaf0060 	fmov	v0.d[1], x3
  401f14:	3d8007e0 	str	q0, [sp, #16]
  401f18:	940000ba 	bl	402200 <__sfp_handle_exceptions>
  401f1c:	3dc007e0 	ldr	q0, [sp, #16]
  401f20:	17fffe9d 	b	401994 <__divtf3+0x194>
  401f24:	b25100e5 	orr	x5, x7, #0x800000000000
  401f28:	1200012b 	and	w11, w9, #0x1
  401f2c:	9240bca5 	and	x5, x5, #0xffffffffffff
  401f30:	aa0603e1 	mov	x1, x6
  401f34:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401f38:	17fffe9e 	b	4019b0 <__divtf3+0x1b0>
  401f3c:	1200012b 	and	w11, w9, #0x1
  401f40:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401f44:	d2800005 	mov	x5, #0x0                   	// #0
  401f48:	d2800001 	mov	x1, #0x0                   	// #0
  401f4c:	17fffe99 	b	4019b0 <__divtf3+0x1b0>
  401f50:	f100025f 	cmp	x18, #0x0
  401f54:	fa420080 	ccmp	x4, x2, #0x0, eq  // eq = none
  401f58:	54ffdb41 	b.ne	401ac0 <__divtf3+0x2c0>  // b.any
  401f5c:	17ffffc1 	b	401e60 <__divtf3+0x660>
  401f60:	aa0700c1 	orr	x1, x6, x7
  401f64:	b5000861 	cbnz	x1, 402070 <__divtf3+0x870>
  401f68:	321d0000 	orr	w0, w0, #0x8
  401f6c:	52800004 	mov	w4, #0x0                   	// #0
  401f70:	d2800005 	mov	x5, #0x0                   	// #0
  401f74:	17ffffe2 	b	401efc <__divtf3+0x6fc>
  401f78:	f100007f 	cmp	x3, #0x0
  401f7c:	1a9f07e9 	cset	w9, ne  // ne = any
  401f80:	7100013f 	cmp	w9, #0x0
  401f84:	fa421020 	ccmp	x1, x2, #0x0, ne  // ne = any
  401f88:	54ffe0c1 	b.ne	401ba0 <__divtf3+0x3a0>  // b.any
  401f8c:	17fffefa 	b	401b74 <__divtf3+0x374>
  401f90:	fa460200 	ccmp	x16, x6, #0x0, eq  // eq = none
  401f94:	54ffd969 	b.ls	401ac0 <__divtf3+0x2c0>  // b.plast
  401f98:	17ffffb4 	b	401e68 <__divtf3+0x668>
  401f9c:	aa0103e2 	mov	x2, x1
  401fa0:	d1000508 	sub	x8, x8, #0x1
  401fa4:	aa0503e3 	mov	x3, x5
  401fa8:	d2800001 	mov	x1, #0x0                   	// #0
  401fac:	17fffe93 	b	4019f8 <__divtf3+0x1f8>
  401fb0:	52800801 	mov	w1, #0x40                  	// #64
  401fb4:	4b040021 	sub	w1, w1, w4
  401fb8:	9ac424c3 	lsr	x3, x6, x4
  401fbc:	9ac120c6 	lsl	x6, x6, x1
  401fc0:	f10000df 	cmp	x6, #0x0
  401fc4:	9a9f07e2 	cset	x2, ne  // ne = any
  401fc8:	9ac120e1 	lsl	x1, x7, x1
  401fcc:	aa030021 	orr	x1, x1, x3
  401fd0:	9ac424e5 	lsr	x5, x7, x4
  401fd4:	aa020021 	orr	x1, x1, x2
  401fd8:	f240083f 	tst	x1, #0x7
  401fdc:	54ffee21 	b.ne	401da0 <__divtf3+0x5a0>  // b.any
  401fe0:	b7980b85 	tbnz	x5, #51, 402150 <__divtf3+0x950>
  401fe4:	52800004 	mov	w4, #0x0                   	// #0
  401fe8:	93c10ca1 	extr	x1, x5, x1, #3
  401fec:	d343c8a5 	ubfx	x5, x5, #3, #48
  401ff0:	365fce0c 	tbz	w12, #11, 4019b0 <__divtf3+0x1b0>
  401ff4:	321d0000 	orr	w0, w0, #0x8
  401ff8:	17ffffc1 	b	401efc <__divtf3+0x6fc>
  401ffc:	f100013f 	cmp	x9, #0x0
  402000:	528fffe1 	mov	w1, #0x7fff                	// #32767
  402004:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  402008:	1a810044 	csel	w4, w2, w1, eq  // eq = none
  40200c:	9a9f00a5 	csel	x5, x5, xzr, eq  // eq = none
  402010:	da9f13e1 	csetm	x1, eq  // eq = none
  402014:	17ffffb8 	b	401ef4 <__divtf3+0x6f4>
  402018:	5280000b 	mov	w11, #0x0                   	// #0
  40201c:	b4ffc7e9 	cbz	x9, 401918 <__divtf3+0x118>
  402020:	b10020c6 	adds	x6, x6, #0x8
  402024:	5280002b 	mov	w11, #0x1                   	// #1
  402028:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  40202c:	17fffe3b 	b	401918 <__divtf3+0x118>
  402030:	d10008c6 	sub	x6, x6, #0x2
  402034:	8b040042 	add	x2, x2, x4
  402038:	17fffe8b 	b	401a64 <__divtf3+0x264>
  40203c:	d10008e7 	sub	x7, x7, #0x2
  402040:	8b040063 	add	x3, x3, x4
  402044:	17fffe7c 	b	401a34 <__divtf3+0x234>
  402048:	d287ffe2 	mov	x2, #0x3fff                	// #16383
  40204c:	8b020104 	add	x4, x8, x2
  402050:	aa0e03e9 	mov	x9, x14
  402054:	92800006 	mov	x6, #0xffffffffffffffff    	// #-1
  402058:	f100009f 	cmp	x4, #0x0
  40205c:	54ffec6c 	b.gt	401de8 <__divtf3+0x5e8>
  402060:	d2800021 	mov	x1, #0x1                   	// #1
  402064:	cb040024 	sub	x4, x1, x4
  402068:	f101d09f 	cmp	x4, #0x74
  40206c:	54ffe7ad 	b.le	401d60 <__divtf3+0x560>
  402070:	926a058c 	and	x12, x12, #0xc00000
  402074:	321c0000 	orr	w0, w0, #0x10
  402078:	f150019f 	cmp	x12, #0x400, lsl #12
  40207c:	54000500 	b.eq	40211c <__divtf3+0x91c>  // b.none
  402080:	f160019f 	cmp	x12, #0x800, lsl #12
  402084:	9a9f0121 	csel	x1, x9, xzr, eq  // eq = none
  402088:	17ffffb8 	b	401f68 <__divtf3+0x768>
  40208c:	d37ff8aa 	lsl	x10, x5, #1
  402090:	d10008c6 	sub	x6, x6, #0x2
  402094:	eb0a00bf 	cmp	x5, x10
  402098:	9a849481 	cinc	x1, x4, hi  // hi = pmore
  40209c:	eb0a007f 	cmp	x3, x10
  4020a0:	8b010121 	add	x1, x9, x1
  4020a4:	1a9f07e9 	cset	w9, ne  // ne = any
  4020a8:	17fffebe 	b	401ba0 <__divtf3+0x3a0>
  4020ac:	b5000069 	cbnz	x9, 4020b8 <__divtf3+0x8b8>
  4020b0:	b1002021 	adds	x1, x1, #0x8
  4020b4:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  4020b8:	b69fe845 	tbz	x5, #51, 401dc0 <__divtf3+0x5c0>
  4020bc:	321d0000 	orr	w0, w0, #0x8
  4020c0:	52800024 	mov	w4, #0x1                   	// #1
  4020c4:	d2800005 	mov	x5, #0x0                   	// #0
  4020c8:	d2800001 	mov	x1, #0x0                   	// #0
  4020cc:	17ffff8c 	b	401efc <__divtf3+0x6fc>
  4020d0:	f100013f 	cmp	x9, #0x0
  4020d4:	528fffe1 	mov	w1, #0x7fff                	// #32767
  4020d8:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  4020dc:	1a811044 	csel	w4, w2, w1, ne  // ne = any
  4020e0:	9a9f10a5 	csel	x5, x5, xzr, ne  // ne = any
  4020e4:	da9f03e1 	csetm	x1, ne  // ne = any
  4020e8:	17ffff83 	b	401ef4 <__divtf3+0x6f4>
  4020ec:	5280002b 	mov	w11, #0x1                   	// #1
  4020f0:	b5ffc149 	cbnz	x9, 401918 <__divtf3+0x118>
  4020f4:	b10020c6 	adds	x6, x6, #0x8
  4020f8:	5280000b 	mov	w11, #0x0                   	// #0
  4020fc:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  402100:	17fffe06 	b	401918 <__divtf3+0x118>
  402104:	d1000863 	sub	x3, x3, #0x2
  402108:	8b040021 	add	x1, x1, x4
  40210c:	17fffe88 	b	401b2c <__divtf3+0x32c>
  402110:	d10008c6 	sub	x6, x6, #0x2
  402114:	8b040042 	add	x2, x2, x4
  402118:	17fffe79 	b	401afc <__divtf3+0x2fc>
  40211c:	d2800021 	mov	x1, #0x1                   	// #1
  402120:	cb090021 	sub	x1, x1, x9
  402124:	17ffff91 	b	401f68 <__divtf3+0x768>
  402128:	92400c22 	and	x2, x1, #0xf
  40212c:	f100105f 	cmp	x2, #0x4
  402130:	54fffc40 	b.eq	4020b8 <__divtf3+0x8b8>  // b.none
  402134:	b1001021 	adds	x1, x1, #0x4
  402138:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  40213c:	b79ffc05 	tbnz	x5, #51, 4020bc <__divtf3+0x8bc>
  402140:	17ffff20 	b	401dc0 <__divtf3+0x5c0>
  402144:	b5fffb69 	cbnz	x9, 4020b0 <__divtf3+0x8b0>
  402148:	b79ffba5 	tbnz	x5, #51, 4020bc <__divtf3+0x8bc>
  40214c:	17ffff1d 	b	401dc0 <__divtf3+0x5c0>
  402150:	321c0000 	orr	w0, w0, #0x10
  402154:	17ffffda 	b	4020bc <__divtf3+0x8bc>
  402158:	d503201f 	nop
  40215c:	d503201f 	nop

0000000000402160 <__floatunditf>:
  402160:	b40002a0 	cbz	x0, 4021b4 <__floatunditf+0x54>
  402164:	dac01001 	clz	x1, x0
  402168:	528807c2 	mov	w2, #0x403e                	// #16446
  40216c:	4b010042 	sub	w2, w2, w1
  402170:	d2880de3 	mov	x3, #0x406f                	// #16495
  402174:	12003844 	and	w4, w2, #0x7fff
  402178:	cb22c062 	sub	x2, x3, w2, sxtw
  40217c:	f100fc5f 	cmp	x2, #0x3f
  402180:	540002ac 	b.gt	4021d4 <__floatunditf+0x74>
  402184:	1100c423 	add	w3, w1, #0x31
  402188:	528001e2 	mov	w2, #0xf                   	// #15
  40218c:	4b010041 	sub	w1, w2, w1
  402190:	9ac12401 	lsr	x1, x0, x1
  402194:	9240bc21 	and	x1, x1, #0xffffffffffff
  402198:	9ac32000 	lsl	x0, x0, x3
  40219c:	d2800003 	mov	x3, #0x0                   	// #0
  4021a0:	b340bc23 	bfxil	x3, x1, #0, #48
  4021a4:	9e670000 	fmov	d0, x0
  4021a8:	b3503c83 	bfi	x3, x4, #48, #16
  4021ac:	9eaf0060 	fmov	v0.d[1], x3
  4021b0:	d65f03c0 	ret
  4021b4:	d2800001 	mov	x1, #0x0                   	// #0
  4021b8:	d2800003 	mov	x3, #0x0                   	// #0
  4021bc:	b340bc23 	bfxil	x3, x1, #0, #48
  4021c0:	9e670000 	fmov	d0, x0
  4021c4:	52800004 	mov	w4, #0x0                   	// #0
  4021c8:	b3503c83 	bfi	x3, x4, #48, #16
  4021cc:	9eaf0060 	fmov	v0.d[1], x3
  4021d0:	d65f03c0 	ret
  4021d4:	51003c21 	sub	w1, w1, #0xf
  4021d8:	d2800003 	mov	x3, #0x0                   	// #0
  4021dc:	9ac12001 	lsl	x1, x0, x1
  4021e0:	9240bc21 	and	x1, x1, #0xffffffffffff
  4021e4:	d2800000 	mov	x0, #0x0                   	// #0
  4021e8:	9e670000 	fmov	d0, x0
  4021ec:	b340bc23 	bfxil	x3, x1, #0, #48
  4021f0:	b3503c83 	bfi	x3, x4, #48, #16
  4021f4:	9eaf0060 	fmov	v0.d[1], x3
  4021f8:	d65f03c0 	ret
  4021fc:	d503201f 	nop

0000000000402200 <__sfp_handle_exceptions>:
  402200:	36000080 	tbz	w0, #0, 402210 <__sfp_handle_exceptions+0x10>
  402204:	0f000401 	movi	v1.2s, #0x0
  402208:	1e211820 	fdiv	s0, s1, s1
  40220c:	d53b4421 	mrs	x1, fpsr
  402210:	360800a0 	tbz	w0, #1, 402224 <__sfp_handle_exceptions+0x24>
  402214:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
  402218:	0f000402 	movi	v2.2s, #0x0
  40221c:	1e221820 	fdiv	s0, s1, s2
  402220:	d53b4421 	mrs	x1, fpsr
  402224:	36100100 	tbz	w0, #2, 402244 <__sfp_handle_exceptions+0x44>
  402228:	5298b5c2 	mov	w2, #0xc5ae                	// #50606
  40222c:	12b01001 	mov	w1, #0x7f7fffff            	// #2139095039
  402230:	72ae93a2 	movk	w2, #0x749d, lsl #16
  402234:	1e270021 	fmov	s1, w1
  402238:	1e270042 	fmov	s2, w2
  40223c:	1e222820 	fadd	s0, s1, s2
  402240:	d53b4421 	mrs	x1, fpsr
  402244:	36180080 	tbz	w0, #3, 402254 <__sfp_handle_exceptions+0x54>
  402248:	0f044401 	movi	v1.2s, #0x80, lsl #16
  40224c:	1e210820 	fmul	s0, s1, s1
  402250:	d53b4421 	mrs	x1, fpsr
  402254:	362000c0 	tbz	w0, #4, 40226c <__sfp_handle_exceptions+0x6c>
  402258:	12b01000 	mov	w0, #0x7f7fffff            	// #2139095039
  40225c:	1e2e1002 	fmov	s2, #1.000000000000000000e+00
  402260:	1e270001 	fmov	s1, w0
  402264:	1e223820 	fsub	s0, s1, s2
  402268:	d53b4420 	mrs	x0, fpsr
  40226c:	d65f03c0 	ret

0000000000402270 <call_weak_fn>:
  402270:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402274:	f9478000 	ldr	x0, [x0, #3840]
  402278:	b4000040 	cbz	x0, 402280 <call_weak_fn+0x10>
  40227c:	17fffc95 	b	4014d0 <__gmon_start__@plt>
  402280:	d65f03c0 	ret

0000000000402284 <_OffsetAbsSyms>:
#include <zephyr/kernel.h>
#include <kernel_arch_data.h>
#include <gen_offset.h>
#include <kernel_offsets.h>

GEN_ABS_SYM_END
  402284:	d65f03c0 	ret

0000000000402288 <z_log_msg_runtime_create.constprop.0>:
 *
 * @param fmt String.
 *
 * @param ... String arguments.
 */
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  402288:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40228c:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402290:	910003fd 	mov	x29, sp
  402294:	f9478400 	ldr	x0, [x0, #3848]
  402298:	3d8023e0 	str	q0, [sp, #128]
  40229c:	3d8027e1 	str	q1, [sp, #144]
  4022a0:	3d802be2 	str	q2, [sp, #160]
  4022a4:	3d802fe3 	str	q3, [sp, #176]
  4022a8:	3d8033e4 	str	q4, [sp, #192]
  4022ac:	3d8037e5 	str	q5, [sp, #208]
  4022b0:	3d803be6 	str	q6, [sp, #224]
  4022b4:	3d803fe7 	str	q7, [sp, #240]
  4022b8:	f90087e7 	str	x7, [sp, #264]
  4022bc:	f9400002 	ldr	x2, [x0]
  4022c0:	f9003fe2 	str	x2, [sp, #120]
  4022c4:	d2800002 	mov	x2, #0x0                   	// #0
					     size_t dlen, uint32_t package_flags,
					     const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
  4022c8:	910443e0 	add	x0, sp, #0x110
  4022cc:	a90383e0 	stp	x0, x0, [sp, #56]
  4022d0:	910403e0 	add	x0, sp, #0x100
  4022d4:	9100e3e2 	add	x2, sp, #0x38
  4022d8:	f90027e0 	str	x0, [sp, #72]
  4022dc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  4022e0:	b90053e0 	str	w0, [sp, #80]
  4022e4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  4022e8:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  4022ec:	910163e0 	add	x0, sp, #0x58
  4022f0:	ad400440 	ldp	q0, q1, [x2]
  4022f4:	ad000400 	stp	q0, q1, [x0]
		va_end(parm7.val);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_runtime_vcreate(domain_id, source, level, data, dlen, package_flags, fmt, ap);
  4022f8:	ad400400 	ldp	q0, q1, [x0]
  4022fc:	910043e7 	add	x7, sp, #0x10
  402300:	52800062 	mov	w2, #0x3                   	// #3
  402304:	52800000 	mov	w0, #0x0                   	// #0
  402308:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  40230c:	52800005 	mov	w5, #0x0                   	// #0
  402310:	912244c6 	add	x6, x6, #0x891
  402314:	d2800004 	mov	x4, #0x0                   	// #0
  402318:	d2800003 	mov	x3, #0x0                   	// #0
  40231c:	ad0004e0 	stp	q0, q1, [x7]
  402320:	94000d87 	bl	40593c <z_impl_z_log_msg_runtime_vcreate>
				   data, dlen, package_flags, fmt, ap);
	va_end(ap);
}
  402324:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402328:	f9478400 	ldr	x0, [x0, #3848]
  40232c:	f9403fe2 	ldr	x2, [sp, #120]
  402330:	f9400001 	ldr	x1, [x0]
  402334:	eb010042 	subs	x2, x2, x1
  402338:	d2800001 	mov	x1, #0x0                   	// #0
  40233c:	54000040 	b.eq	402344 <z_log_msg_runtime_create.constprop.0+0xbc>  // b.none
  402340:	97fffc5c 	bl	4014b0 <__stack_chk_fail@plt>
  402344:	a8d17bfd 	ldp	x29, x30, [sp], #272
  402348:	d65f03c0 	ret

000000000040234c <thingset_sdk_init>:
{
    return k_work_reschedule_for_queue(&thingset_workq, dwork, delay);
}

static int thingset_sdk_init(void)
{
  40234c:	d101c3ff 	sub	sp, sp, #0x70
  402350:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402354:	a9037bfd 	stp	x29, x30, [sp, #48]
  402358:	9100c3fd 	add	x29, sp, #0x30
  40235c:	f9478400 	ldr	x0, [x0, #3848]
  402360:	a90453f3 	stp	x19, x20, [sp, #64]
  402364:	f9400001 	ldr	x1, [x0]
  402368:	f90037e1 	str	x1, [sp, #104]
  40236c:	d2800001 	mov	x1, #0x0                   	// #0
		union { uintptr_t x; unsigned int val; } parm2 = { .val = limit };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_K_SEM_INIT);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_init(sem, initial_count, limit);
  402370:	52800022 	mov	w2, #0x1                   	// #1
  402374:	2a0203e1 	mov	w1, w2
  402378:	f0000140 	adrp	x0, 42d000 <__dso_handle>
    k_sem_init(&sbuf.lock, 1, 1);

    k_work_queue_init(&thingset_workq);
  40237c:	f0000153 	adrp	x19, 42d000 <__dso_handle>
  402380:	91002000 	add	x0, x0, #0x8
  402384:	913fe273 	add	x19, x19, #0xff8
  402388:	9400381a 	bl	4103f0 <z_impl_k_sem_init>
  40238c:	aa1303e0 	mov	x0, x19
  402390:	94003b10 	bl	410fd0 <k_work_queue_init>
    k_work_queue_start(&thingset_workq, thread_stack_area, K_THREAD_STACK_SIZEOF(thread_stack_area),
  402394:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402398:	aa1303e0 	mov	x0, x19
  40239c:	d2800004 	mov	x4, #0x0                   	// #0
  4023a0:	52800043 	mov	w3, #0x2                   	// #2
  4023a4:	f947ac21 	ldr	x1, [x1, #3928]
  4023a8:	d2810002 	mov	x2, #0x800                 	// #2048
  4023ac:	94003b24 	bl	41103c <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
  4023b0:	d0000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  4023b4:	aa1303e0 	mov	x0, x19
  4023b8:	9122bc21 	add	x1, x1, #0x8af
  4023bc:	94003376 	bl	40f194 <z_impl_k_thread_name_set>
                       CONFIG_THINGSET_SDK_THREAD_PRIORITY, NULL);

    k_thread_name_set(&thingset_workq.thread, "thingset_sdk");

    thingset_init_global(&ts);
  4023c0:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
        buf[i] = sys_rand32_get() & 0xFF;
  4023c4:	910163f4 	add	x20, sp, #0x58
    uint8_t buf[12] = { 0 };
  4023c8:	d2800013 	mov	x19, #0x0                   	// #0
    thingset_init_global(&ts);
  4023cc:	f9475400 	ldr	x0, [x0, #3752]
  4023d0:	94002347 	bl	40b0ec <thingset_init_global>
    uint8_t buf[12] = { 0 };
  4023d4:	f805a3ff 	stur	xzr, [sp, #90]
  4023d8:	d0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4023dc:	91247400 	add	x0, x0, #0x91d
  4023e0:	7900c7ff 	strh	wzr, [sp, #98]
  4023e4:	79400000 	ldrh	w0, [x0]
  4023e8:	7900b3e0 	strh	w0, [sp, #88]
	if (z_syscall_trap()) {
		return (uint32_t) arch_syscall_invoke0(K_SYSCALL_SYS_RAND32_GET);
	}
#endif
	compiler_barrier();
	return z_impl_sys_rand32_get();
  4023ec:	94001c57 	bl	409548 <z_impl_sys_rand32_get>
        buf[i] = sys_rand32_get() & 0xFF;
  4023f0:	38336a80 	strb	w0, [x20, x19]
    for (int i = 0; i < sizeof(buf); i++) {
  4023f4:	91000673 	add	x19, x19, #0x1
  4023f8:	f100327f 	cmp	x19, #0xc
  4023fc:	54ffff81 	b.ne	4023ec <thingset_sdk_init+0xa0>  // b.any
    crc = crc32_ieee(buf, 8);
  402400:	d0000153 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  402404:	aa1403e0 	mov	x0, x20
  402408:	d2800101 	mov	x1, #0x8                   	// #8
  40240c:	94000815 	bl	404460 <crc32_ieee>
    memcpy(eui64, &crc, 4);
  402410:	f9473a73 	ldr	x19, [x19, #3696]
    crc = crc32_ieee(buf + 4, 8);
  402414:	d2800101 	mov	x1, #0x8                   	// #8
# ifdef __va_arg_pack
__fortify_function int
__NTH (snprintf (char *__restrict __s, size_t __n,
		 const char *__restrict __fmt, ...))
{
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  402418:	d0000154 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  40241c:	b9000260 	str	w0, [x19]
  402420:	910173e0 	add	x0, sp, #0x5c
  402424:	9400080f 	bl	404460 <crc32_ieee>
    snprintf(node_id, sizeof(node_id), "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X", eui64[0], eui64[1],
  402428:	53187c01 	lsr	w1, w0, #24
    eui64[0] &= ~(1U << 1);
  40242c:	39400265 	ldrb	w5, [x19]
  402430:	d2800223 	mov	x3, #0x11                  	// #17
  402434:	b9000660 	str	w0, [x19, #4]
  402438:	52800022 	mov	w2, #0x1                   	// #1
  40243c:	121e78a5 	and	w5, w5, #0xfffffffd
    snprintf(node_id, sizeof(node_id), "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X", eui64[0], eui64[1],
  402440:	39400a67 	ldrb	w7, [x19, #2]
    eui64[0] &= ~(1U << 1);
  402444:	12001ca5 	and	w5, w5, #0xff
  402448:	39000265 	strb	w5, [x19]
    snprintf(node_id, sizeof(node_id), "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X", eui64[0], eui64[1],
  40244c:	39400666 	ldrb	w6, [x19, #1]
  402450:	d0000084 	adrp	x4, 414000 <sys_clock_tick_get+0x78>
  402454:	b90023e1 	str	w1, [sp, #32]
  402458:	d3505c01 	ubfx	x1, x0, #16, #8
  40245c:	b9001be1 	str	w1, [sp, #24]
  402460:	d3483c01 	ubfx	x1, x0, #8, #8
  402464:	12001c00 	and	w0, w0, #0xff
  402468:	b9000be0 	str	w0, [sp, #8]
  40246c:	b90013e1 	str	w1, [sp, #16]
  402470:	9122f084 	add	x4, x4, #0x8bc
  402474:	f9474e94 	ldr	x20, [x20, #3736]
  402478:	aa0303e1 	mov	x1, x3
  40247c:	39400e60 	ldrb	w0, [x19, #3]
  402480:	b90003e0 	str	w0, [sp]
  402484:	aa1403e0 	mov	x0, x20
  402488:	97fffbce 	bl	4013c0 <__snprintf_chk@plt>
    LOG_INF("ThingSet Node ID (EUI-64): %s", node_id);
  40248c:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402490:	52800062 	mov	w2, #0x3                   	// #3
  402494:	52800000 	mov	w0, #0x0                   	// #0
  402498:	aa1403e7 	mov	x7, x20
  40249c:	f946f821 	ldr	x1, [x1, #3568]
  4024a0:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  4024a4:	52800005 	mov	w5, #0x0                   	// #0
  4024a8:	912244c6 	add	x6, x6, #0x891
  4024ac:	d2800004 	mov	x4, #0x0                   	// #0
  4024b0:	d2800003 	mov	x3, #0x0                   	// #0
  4024b4:	97ffff75 	bl	402288 <z_log_msg_runtime_create.constprop.0>
    thingset_storage_load();
    thingset_set_update_callback(&ts, TS_SUBSET_NVM, thingset_storage_save_queued);
#endif

    return 0;
}
  4024b8:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4024bc:	f9478400 	ldr	x0, [x0, #3848]
  4024c0:	f94037e2 	ldr	x2, [sp, #104]
  4024c4:	f9400001 	ldr	x1, [x0]
  4024c8:	eb010042 	subs	x2, x2, x1
  4024cc:	d2800001 	mov	x1, #0x0                   	// #0
  4024d0:	54000040 	b.eq	4024d8 <thingset_sdk_init+0x18c>  // b.none
  4024d4:	97fffbf7 	bl	4014b0 <__stack_chk_fail@plt>
  4024d8:	52800000 	mov	w0, #0x0                   	// #0
  4024dc:	a9437bfd 	ldp	x29, x30, [sp, #48]
  4024e0:	a94453f3 	ldp	x19, x20, [sp, #64]
  4024e4:	9101c3ff 	add	sp, sp, #0x70
  4024e8:	d65f03c0 	ret

00000000004024ec <thingset_sdk_shared_buffer>:
}
  4024ec:	f0000140 	adrp	x0, 42d000 <__dso_handle>
  4024f0:	91002000 	add	x0, x0, #0x8
  4024f4:	d65f03c0 	ret

00000000004024f8 <thingset_sdk_reschedule_work>:
    return k_work_reschedule_for_queue(&thingset_workq, dwork, delay);
  4024f8:	aa0103e2 	mov	x2, x1
  4024fc:	aa0003e1 	mov	x1, x0
  402500:	f0000140 	adrp	x0, 42d000 <__dso_handle>
  402504:	913fe000 	add	x0, x0, #0xff8
  402508:	14003b54 	b	411258 <k_work_reschedule_for_queue>

000000000040250c <thingset_can_report_rx_cb>:
    /* Optimization: store in internal database to exclude from potentially available addresses */
}

static void thingset_can_report_rx_cb(const struct device *dev, struct can_frame *frame,
                                      void *user_data)
{
  40250c:	aa0103e4 	mov	x4, x1
    struct thingset_can *ts_can = user_data;
    uint16_t data_id = THINGSET_CAN_DATA_ID_GET(frame->id);
  402510:	b8408423 	ldr	w3, [x1], #8
        }
    }
    else
#endif /* CONFIG_THINGSET_CAN_PACKETIZED_REPORTS_RX */
    {
        ts_can->report_rx_cb(data_id, frame->data, can_dlc_to_bytes(frame->dlc), source_addr);
  402514:	f9425c45 	ldr	x5, [x2, #1208]
  402518:	39401084 	ldrb	w4, [x4, #4]
    uint16_t data_id = THINGSET_CAN_DATA_ID_GET(frame->id);
  40251c:	d3485c60 	ubfx	x0, x3, #8, #16
    uint8_t source_addr = THINGSET_CAN_SOURCE_GET(frame->id);
  402520:	12001c63 	and	w3, w3, #0xff
static inline uint8_t can_dlc_to_bytes(uint8_t dlc)
{
	static const uint8_t dlc_table[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 12,
					    16, 20, 24, 32, 48, 64};

	return dlc > 0x0F ? 64 : dlc_table[dlc];
  402524:	71003c9f 	cmp	w4, #0xf
  402528:	540000e8 	b.hi	402544 <thingset_can_report_rx_cb+0x38>  // b.pmore
  40252c:	d0000082 	adrp	x2, 414000 <sys_clock_tick_get+0x78>
  402530:	912ce442 	add	x2, x2, #0xb39
  402534:	3864c842 	ldrb	w2, [x2, w4, sxtw]
        ts_can->report_rx_cb(data_id, frame->data, can_dlc_to_bytes(frame->dlc), source_addr);
  402538:	92401c42 	and	x2, x2, #0xff
  40253c:	aa0503f0 	mov	x16, x5
  402540:	d61f0200 	br	x16
  402544:	52800802 	mov	w2, #0x40                  	// #64
  402548:	17fffffc 	b	402538 <thingset_can_report_rx_cb+0x2c>

000000000040254c <thingset_can_report_tx_cb>:
}

static void thingset_can_report_tx_cb(const struct device *dev, int error, void *user_data)
{
    /* Do nothing: Reports are fire and forget. */
}
  40254c:	d65f03c0 	ret

0000000000402550 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  402550:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  402554:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402558:	12001c42 	and	w2, w2, #0xff
  40255c:	910003fd 	mov	x29, sp
  402560:	f9478400 	ldr	x0, [x0, #3848]
  402564:	3d8023e0 	str	q0, [sp, #128]
  402568:	3d8027e1 	str	q1, [sp, #144]
  40256c:	3d802be2 	str	q2, [sp, #160]
  402570:	3d802fe3 	str	q3, [sp, #176]
  402574:	3d8033e4 	str	q4, [sp, #192]
  402578:	3d8037e5 	str	q5, [sp, #208]
  40257c:	3d803be6 	str	q6, [sp, #224]
  402580:	3d803fe7 	str	q7, [sp, #240]
  402584:	f90087e7 	str	x7, [sp, #264]
  402588:	f9400003 	ldr	x3, [x0]
  40258c:	f9003fe3 	str	x3, [sp, #120]
  402590:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(ap, fmt);
  402594:	910443e0 	add	x0, sp, #0x110
  402598:	a90383e0 	stp	x0, x0, [sp, #56]
  40259c:	910403e0 	add	x0, sp, #0x100
  4025a0:	9100e3e3 	add	x3, sp, #0x38
  4025a4:	f90027e0 	str	x0, [sp, #72]
  4025a8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  4025ac:	b90053e0 	str	w0, [sp, #80]
  4025b0:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  4025b4:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  4025b8:	910163e0 	add	x0, sp, #0x58
  4025bc:	ad400460 	ldp	q0, q1, [x3]
  4025c0:	ad000400 	stp	q0, q1, [x0]
  4025c4:	ad400400 	ldp	q0, q1, [x0]
  4025c8:	910043e7 	add	x7, sp, #0x10
  4025cc:	52800000 	mov	w0, #0x0                   	// #0
  4025d0:	52800005 	mov	w5, #0x0                   	// #0
  4025d4:	d2800004 	mov	x4, #0x0                   	// #0
  4025d8:	d2800003 	mov	x3, #0x0                   	// #0
  4025dc:	ad0004e0 	stp	q0, q1, [x7]
  4025e0:	94000cd7 	bl	40593c <z_impl_z_log_msg_runtime_vcreate>
}
  4025e4:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4025e8:	f9478400 	ldr	x0, [x0, #3848]
  4025ec:	f9403fe2 	ldr	x2, [sp, #120]
  4025f0:	f9400001 	ldr	x1, [x0]
  4025f4:	eb010042 	subs	x2, x2, x1
  4025f8:	d2800001 	mov	x1, #0x0                   	// #0
  4025fc:	54000040 	b.eq	402604 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  402600:	97fffbac 	bl	4014b0 <__stack_chk_fail@plt>
  402604:	a8d17bfd 	ldp	x29, x30, [sp], #272
  402608:	d65f03c0 	ret

000000000040260c <thingset_can_addr_claim_rx_cb>:
{
  40260c:	d10183ff 	sub	sp, sp, #0x60
    LOG_INF("Received address claim from node 0x%.2X with EUI-64 "
  402610:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402614:	52800005 	mov	w5, #0x0                   	// #0
  402618:	9124a4c6 	add	x6, x6, #0x929
  40261c:	d2800004 	mov	x4, #0x0                   	// #0
  402620:	d2800003 	mov	x3, #0x0                   	// #0
{
  402624:	a9047bfd 	stp	x29, x30, [sp, #64]
  402628:	910103fd 	add	x29, sp, #0x40
  40262c:	a90553f3 	stp	x19, x20, [sp, #80]
  402630:	aa0103f3 	mov	x19, x1
  402634:	aa0203f4 	mov	x20, x2
    LOG_INF("Received address claim from node 0x%.2X with EUI-64 "
  402638:	39404020 	ldrb	w0, [x1, #16]
  40263c:	52800062 	mov	w2, #0x3                   	// #3
  402640:	b9003be0 	str	w0, [sp, #56]
  402644:	39403820 	ldrb	w0, [x1, #14]
  402648:	b90033e0 	str	w0, [sp, #48]
  40264c:	39403420 	ldrb	w0, [x1, #13]
  402650:	b9002be0 	str	w0, [sp, #40]
  402654:	39403020 	ldrb	w0, [x1, #12]
  402658:	b90023e0 	str	w0, [sp, #32]
  40265c:	39402c20 	ldrb	w0, [x1, #11]
  402660:	b9001be0 	str	w0, [sp, #24]
  402664:	39402820 	ldrb	w0, [x1, #10]
  402668:	b90013e0 	str	w0, [sp, #16]
  40266c:	39402420 	ldrb	w0, [x1, #9]
  402670:	b9000be0 	str	w0, [sp, #8]
  402674:	39402020 	ldrb	w0, [x1, #8]
  402678:	b90003e0 	str	w0, [sp]
  40267c:	52800000 	mov	w0, #0x0                   	// #0
  402680:	39400027 	ldrb	w7, [x1]
  402684:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402688:	f9472421 	ldr	x1, [x1, #3656]
  40268c:	97ffffb1 	bl	402550 <z_log_msg_runtime_create.constprop.0>
    if (ts_can->node_addr == THINGSET_CAN_SOURCE_GET(frame->id)) {
  402690:	39532281 	ldrb	w1, [x20, #1224]
  402694:	39400260 	ldrb	w0, [x19]
  402698:	6b00003f 	cmp	w1, w0
  40269c:	540000e1 	b.ne	4026b8 <thingset_can_addr_claim_rx_cb+0xac>  // b.any
	z_impl_k_event_post(event, events);
  4026a0:	91090280 	add	x0, x20, #0x240
  4026a4:	52800061 	mov	w1, #0x3                   	// #3
}
  4026a8:	a9447bfd 	ldp	x29, x30, [sp, #64]
  4026ac:	a94553f3 	ldp	x19, x20, [sp, #80]
  4026b0:	910183ff 	add	sp, sp, #0x60
  4026b4:	140047c3 	b	4145c0 <z_impl_k_event_post>
  4026b8:	a9447bfd 	ldp	x29, x30, [sp, #64]
  4026bc:	a94553f3 	ldp	x19, x20, [sp, #80]
  4026c0:	910183ff 	add	sp, sp, #0x60
  4026c4:	d65f03c0 	ret

00000000004026c8 <thingset_can_addr_claim_tx_handler>:
{
  4026c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4026cc:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
                  | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  4026d0:	d1014004 	sub	x4, x0, #0x50
{
  4026d4:	910003fd 	mov	x29, sp
  4026d8:	f9478421 	ldr	x1, [x1, #3848]
  4026dc:	f9400022 	ldr	x2, [x1]
  4026e0:	f90017e2 	str	x2, [sp, #40]
  4026e4:	d2800002 	mov	x2, #0x0                   	// #0
                  | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  4026e8:	3951e001 	ldrb	w1, [x0, #1144]
  4026ec:	529fe002 	mov	w2, #0xff00                	// #65280
    struct can_frame tx_frame = {
  4026f0:	f9000fff 	str	xzr, [sp, #24]
                  | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  4026f4:	72a26002 	movk	w2, #0x1300, lsl #16
  4026f8:	2a020021 	orr	w1, w1, w2
    tx_frame.id = THINGSET_CAN_TYPE_NETWORK | THINGSET_CAN_PRIO_NETWORK_MGMT
  4026fc:	b9001be1 	str	w1, [sp, #24]
    tx_frame.dlc = sizeof(eui64);
  402700:	52802101 	mov	w1, #0x108                 	// #264
  402704:	79003be1 	strh	w1, [sp, #28]
    memcpy(tx_frame.data, eui64, sizeof(eui64));
  402708:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
    int err = can_send(ts_can->dev, &tx_frame, K_MSEC(100), thingset_can_addr_claim_tx_cb, ts_can);
  40270c:	f85b0000 	ldur	x0, [x0, #-80]
  402710:	f9473821 	ldr	x1, [x1, #3696]
  402714:	f9400021 	ldr	x1, [x1]
  402718:	f90013e1 	str	x1, [sp, #32]
		union { uintptr_t x; void * val; } parm4 = { .val = user_data };
		return (int) arch_syscall_invoke5(parm0.x, parm1.x, parm2.x, parm3.x, parm4.x, K_SYSCALL_CAN_SEND);
	}
#endif
	compiler_barrier();
	return z_impl_can_send(dev, frame, timeout, callback, user_data);
  40271c:	90000003 	adrp	x3, 402000 <__divtf3+0x800>
  402720:	910063e1 	add	x1, sp, #0x18
  402724:	9127a063 	add	x3, x3, #0x9e8
  402728:	d2800142 	mov	x2, #0xa                   	// #10
  40272c:	94001fa3 	bl	40a5b8 <z_impl_can_send>
    if (err != 0) {
  402730:	34000180 	cbz	w0, 402760 <thingset_can_addr_claim_tx_handler+0x98>
        LOG_ERR("Address claim failed with %d", err);
  402734:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402738:	2a0003e7 	mov	w7, w0
  40273c:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402740:	52800005 	mov	w5, #0x0                   	// #0
  402744:	f9472421 	ldr	x1, [x1, #3656]
  402748:	912614c6 	add	x6, x6, #0x985
  40274c:	d2800004 	mov	x4, #0x0                   	// #0
  402750:	d2800003 	mov	x3, #0x0                   	// #0
  402754:	52800022 	mov	w2, #0x1                   	// #1
  402758:	52800000 	mov	w0, #0x0                   	// #0
  40275c:	97ffff7d 	bl	402550 <z_log_msg_runtime_create.constprop.0>
}
  402760:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402764:	f9478400 	ldr	x0, [x0, #3848]
  402768:	f94017e2 	ldr	x2, [sp, #40]
  40276c:	f9400001 	ldr	x1, [x0]
  402770:	eb010042 	subs	x2, x2, x1
  402774:	d2800001 	mov	x1, #0x0                   	// #0
  402778:	54000040 	b.eq	402780 <thingset_can_addr_claim_tx_handler+0xb8>  // b.none
  40277c:	97fffb4d 	bl	4014b0 <__stack_chk_fail@plt>
  402780:	a8c37bfd 	ldp	x29, x30, [sp], #48
  402784:	d65f03c0 	ret

0000000000402788 <thingset_can_addr_discovery_rx_cb>:
{
  402788:	d100c3ff 	sub	sp, sp, #0x30
    LOG_INF("Received address discovery frame with ID %X (rand %.2X)", frame->id,
  40278c:	52800005 	mov	w5, #0x0                   	// #0
  402790:	d2800004 	mov	x4, #0x0                   	// #0
  402794:	d2800003 	mov	x3, #0x0                   	// #0
  402798:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  40279c:	912688c6 	add	x6, x6, #0x9a2
{
  4027a0:	a9017bfd 	stp	x29, x30, [sp, #16]
  4027a4:	910043fd 	add	x29, sp, #0x10
  4027a8:	f90013f3 	str	x19, [sp, #32]
  4027ac:	aa0203f3 	mov	x19, x2
    LOG_INF("Received address discovery frame with ID %X (rand %.2X)", frame->id,
  4027b0:	52800062 	mov	w2, #0x3                   	// #3
  4027b4:	b9400027 	ldr	w7, [x1]
  4027b8:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4027bc:	f9472421 	ldr	x1, [x1, #3656]
  4027c0:	d3505ce0 	ubfx	x0, x7, #16, #8
  4027c4:	b90003e0 	str	w0, [sp]
  4027c8:	120070e7 	and	w7, w7, #0x1fffffff
  4027cc:	52800000 	mov	w0, #0x0                   	// #0
  4027d0:	97ffff60 	bl	402550 <z_log_msg_runtime_create.constprop.0>
}
  4027d4:	a9417bfd 	ldp	x29, x30, [sp, #16]
    thingset_sdk_reschedule_work(&ts_can->addr_claim_work, K_NO_WAIT);
  4027d8:	91014260 	add	x0, x19, #0x50
}
  4027dc:	f94013f3 	ldr	x19, [sp, #32]
    thingset_sdk_reschedule_work(&ts_can->addr_claim_work, K_NO_WAIT);
  4027e0:	d2800001 	mov	x1, #0x0                   	// #0
}
  4027e4:	9100c3ff 	add	sp, sp, #0x30
    thingset_sdk_reschedule_work(&ts_can->addr_claim_work, K_NO_WAIT);
  4027e8:	17ffff44 	b	4024f8 <thingset_sdk_reschedule_work>

00000000004027ec <k_sleep.isra.0>:
	return z_impl_k_sleep(timeout);
  4027ec:	14004234 	b	4130bc <z_impl_k_sleep>

00000000004027f0 <thingset_can_report_tx_handler>:

static void thingset_can_report_tx_handler(struct k_work *work)
{
  4027f0:	d10203ff 	sub	sp, sp, #0x80
  4027f4:	a9017bfd 	stp	x29, x30, [sp, #16]
  4027f8:	910043fd 	add	x29, sp, #0x10
  4027fc:	a9035bf5 	stp	x21, x22, [sp, #48]
  402800:	aa0003f6 	mov	x22, x0
  402804:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402808:	a90253f3 	stp	x19, x20, [sp, #32]
  40280c:	f9478400 	ldr	x0, [x0, #3848]
  402810:	a90463f7 	stp	x23, x24, [sp, #64]
        .flags = CAN_FRAME_IDE,
    };
    struct shared_buffer *sbuf = thingset_sdk_shared_buffer();

    struct thingset_data_object *obj = NULL;
    while ((obj = thingset_iterate_subsets(&ts, TS_SUBSET_LIVE, obj)) != NULL) {
  402814:	d0000157 	adrp	x23, 42c000 <__FRAME_END__+0xfbbc>
{
  402818:	f9002bf9 	str	x25, [sp, #80]
  40281c:	90000018 	adrp	x24, 402000 <__divtf3+0x800>
                    break;
                }
            }
            k_sem_give(&sbuf->lock);
#else
            LOG_WRN("Unable to send CAN frame with ID %x as it is too large (%d)", frame.id,
  402820:	d0000099 	adrp	x25, 414000 <sys_clock_tick_get+0x78>
  402824:	91153318 	add	x24, x24, #0x54c
{
  402828:	f9400001 	ldr	x1, [x0]
  40282c:	f9003fe1 	str	x1, [sp, #120]
  402830:	d2800001 	mov	x1, #0x0                   	// #0
    struct can_frame frame = {
  402834:	52800020 	mov	w0, #0x1                   	// #1
  402838:	a906ffff 	stp	xzr, xzr, [sp, #104]
            LOG_WRN("Unable to send CAN frame with ID %x as it is too large (%d)", frame.id,
  40283c:	91276b39 	add	x25, x25, #0x9da
    struct can_frame frame = {
  402840:	3901b7e0 	strb	w0, [sp, #109]
    struct shared_buffer *sbuf = thingset_sdk_shared_buffer();
  402844:	97ffff2a 	bl	4024ec <thingset_sdk_shared_buffer>
    while ((obj = thingset_iterate_subsets(&ts, TS_SUBSET_LIVE, obj)) != NULL) {
  402848:	f94756f7 	ldr	x23, [x23, #3752]
    struct shared_buffer *sbuf = thingset_sdk_shared_buffer();
  40284c:	aa0003f4 	mov	x20, x0
    struct thingset_data_object *obj = NULL;
  402850:	d2800002 	mov	x2, #0x0                   	// #0
    while ((obj = thingset_iterate_subsets(&ts, TS_SUBSET_LIVE, obj)) != NULL) {
  402854:	aa1703e0 	mov	x0, x23
  402858:	52800041 	mov	w1, #0x2                   	// #2
  40285c:	94002270 	bl	40b21c <thingset_iterate_subsets>
  402860:	aa0003f3 	mov	x19, x0
  402864:	b50004e0 	cbnz	x0, 402900 <thingset_can_report_tx_handler+0x110>
            k_sem_give(&sbuf->lock);
        }
        obj++; /* continue with object behind current one */
    }

    ts_can->next_pub_time += 1000 * live_reporting_period;
  402868:	d0000155 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
  40286c:	52807d17 	mov	w23, #0x3e8                 	// #1000
  402870:	f9425ec0 	ldr	x0, [x22, #1208]
  402874:	d10022d4 	sub	x20, x22, #0x8
  402878:	f9477eb5 	ldr	x21, [x21, #3832]
  40287c:	b94002b3 	ldr	w19, [x21]
  402880:	1b177e73 	mul	w19, w19, w23
  402884:	8b334013 	add	x19, x0, w19, uxtw
  402888:	f9026293 	str	x19, [x20, #1216]
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
  40288c:	d2800158 	mov	x24, #0xa                   	// #10
	return z_impl_k_uptime_ticks();
  402890:	94004607 	bl	4140ac <z_impl_k_uptime_ticks>
  402894:	9b187c00 	mul	x0, x0, x24
    if (ts_can->next_pub_time <= k_uptime_get()) {
  402898:	eb00027f 	cmp	x19, x0
  40289c:	540000ec 	b.gt	4028b8 <thingset_can_report_tx_handler+0xc8>
  4028a0:	94004603 	bl	4140ac <z_impl_k_uptime_ticks>
  4028a4:	9b187c00 	mul	x0, x0, x24
        /* ensure proper initialization of t_start */
        ts_can->next_pub_time = k_uptime_get() + 1000 * live_reporting_period;
  4028a8:	b94002a1 	ldr	w1, [x21]
  4028ac:	1b177c21 	mul	w1, w1, w23
  4028b0:	8b214001 	add	x1, x0, w1, uxtw
  4028b4:	f9026281 	str	x1, [x20, #1216]
		t += off;
  4028b8:	f9426280 	ldr	x0, [x20, #1216]
  4028bc:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
  4028c0:	91002400 	add	x0, x0, #0x9
    }

    thingset_sdk_reschedule_work(dwork, K_TIMEOUT_ABS_MS(ts_can->next_pub_time));
  4028c4:	f100241f 	cmp	x0, #0x9
  4028c8:	54000089 	b.ls	4028d8 <thingset_can_report_tx_handler+0xe8>  // b.plast
			return t / ((uint64_t)from_hz / to_hz);
  4028cc:	d2800142 	mov	x2, #0xa                   	// #10
  4028d0:	9ac20800 	udiv	x0, x0, x2
  4028d4:	cb000021 	sub	x1, x1, x0
  4028d8:	aa1603e0 	mov	x0, x22
  4028dc:	97ffff07 	bl	4024f8 <thingset_sdk_reschedule_work>
}
  4028e0:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4028e4:	f9478400 	ldr	x0, [x0, #3848]
  4028e8:	f9403fe2 	ldr	x2, [sp, #120]
  4028ec:	f9400001 	ldr	x1, [x0]
  4028f0:	eb010042 	subs	x2, x2, x1
  4028f4:	d2800001 	mov	x1, #0x0                   	// #0
  4028f8:	540006a0 	b.eq	4029cc <thingset_can_report_tx_handler+0x1dc>  // b.none
  4028fc:	97fffaed 	bl	4014b0 <__stack_chk_fail@plt>
		union { uintptr_t x; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
  402900:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  402904:	aa1403e0 	mov	x0, x20
  402908:	940036fc 	bl	4104f8 <z_impl_k_sem_take>
        data_len = thingset_export_item(&ts, sbuf->data, sbuf->size, obj, THINGSET_BIN_VALUES_ONLY);
  40290c:	a9428a81 	ldp	x1, x2, [x20, #40]
  402910:	aa1303e3 	mov	x3, x19
  402914:	aa1703e0 	mov	x0, x23
  402918:	528000c4 	mov	w4, #0x6                   	// #6
  40291c:	94002201 	bl	40b120 <thingset_export_item>
  402920:	2a0003f5 	mov	w21, w0
        if (data_len > CAN_MAX_DLEN) {
  402924:	7100201f 	cmp	w0, #0x8
  402928:	540001e9 	b.ls	402964 <thingset_can_report_tx_handler+0x174>  // b.plast
            LOG_WRN("Unable to send CAN frame with ID %x as it is too large (%d)", frame.id,
  40292c:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402930:	b90003f5 	str	w21, [sp]
  402934:	f94037e7 	ldr	x7, [sp, #104]
  402938:	aa1903e6 	mov	x6, x25
  40293c:	f9472421 	ldr	x1, [x1, #3656]
  402940:	120070e7 	and	w7, w7, #0x1fffffff
  402944:	52800005 	mov	w5, #0x0                   	// #0
  402948:	d2800004 	mov	x4, #0x0                   	// #0
  40294c:	d2800003 	mov	x3, #0x0                   	// #0
  402950:	52800042 	mov	w2, #0x2                   	// #2
  402954:	52800000 	mov	w0, #0x0                   	// #0
  402958:	97fffefe 	bl	402550 <z_log_msg_runtime_create.constprop.0>
        obj++; /* continue with object behind current one */
  40295c:	91008262 	add	x2, x19, #0x20
  402960:	17ffffbd 	b	402854 <thingset_can_report_tx_handler+0x64>
        else if (data_len > 0) {
  402964:	340002e0 	cbz	w0, 4029c0 <thingset_can_report_tx_handler+0x1d0>

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len,
  402968:	f9401681 	ldr	x1, [x20, #40]
  40296c:	93407c02 	sxtw	x2, w0
  402970:	d2800103 	mov	x3, #0x8                   	// #8
  402974:	9101c3e0 	add	x0, sp, #0x70
  402978:	97fffa8e 	bl	4013b0 <__memcpy_chk@plt>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
  40297c:	aa1403e0 	mov	x0, x20
  402980:	940036a7 	bl	41041c <z_impl_k_sem_give>
                       | THINGSET_CAN_DATA_ID_SET(obj->id)
  402984:	79400661 	ldrh	w1, [x19, #2]
                       | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  402988:	395302c0 	ldrb	w0, [x22, #1216]
            frame.dlc = data_len;
  40298c:	3901b3f5 	strb	w21, [sp, #108]
                       | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  402990:	2a012001 	orr	w1, w0, w1, lsl #8
            frame.id = THINGSET_CAN_TYPE_REPORT | THINGSET_CAN_PRIO_REPORT_LOW
  402994:	b9406be0 	ldr	w0, [sp, #104]
                       | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  402998:	32070c21 	orr	w1, w1, #0x1e000000
            frame.id = THINGSET_CAN_TYPE_REPORT | THINGSET_CAN_PRIO_REPORT_LOW
  40299c:	33007020 	bfxil	w0, w1, #0, #29
  4029a0:	b9006be0 	str	w0, [sp, #104]
            if (can_send(ts_can->dev, &frame, K_MSEC(10), thingset_can_report_tx_cb, NULL) != 0) {
  4029a4:	f85f82c0 	ldur	x0, [x22, #-8]
  4029a8:	d2800004 	mov	x4, #0x0                   	// #0
  4029ac:	aa1803e3 	mov	x3, x24
  4029b0:	9101a3e1 	add	x1, sp, #0x68
  4029b4:	d2800022 	mov	x2, #0x1                   	// #1
  4029b8:	94001f00 	bl	40a5b8 <z_impl_can_send>
                LOG_DBG("Error sending CAN frame with ID %x", frame.id);
  4029bc:	17ffffe8 	b	40295c <thingset_can_report_tx_handler+0x16c>
  4029c0:	aa1403e0 	mov	x0, x20
  4029c4:	94003696 	bl	41041c <z_impl_k_sem_give>
}
  4029c8:	17ffffe5 	b	40295c <thingset_can_report_tx_handler+0x16c>
}
  4029cc:	a9417bfd 	ldp	x29, x30, [sp, #16]
  4029d0:	a94253f3 	ldp	x19, x20, [sp, #32]
  4029d4:	a9435bf5 	ldp	x21, x22, [sp, #48]
  4029d8:	a94463f7 	ldp	x23, x24, [sp, #64]
  4029dc:	f9402bf9 	ldr	x25, [sp, #80]
  4029e0:	910203ff 	add	sp, sp, #0x80
  4029e4:	d65f03c0 	ret

00000000004029e8 <thingset_can_addr_claim_tx_cb>:
{
  4029e8:	2a0103e7 	mov	w7, w1
    if (error == 0) {
  4029ec:	35000081 	cbnz	w1, 4029fc <thingset_can_addr_claim_tx_cb+0x14>
	z_impl_k_event_post(event, events);
  4029f0:	52800021 	mov	w1, #0x1                   	// #1
  4029f4:	91090040 	add	x0, x2, #0x240
  4029f8:	140046f2 	b	4145c0 <z_impl_k_event_post>
        LOG_ERR("Address claim failed with %d", error);
  4029fc:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402a00:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402a04:	52800005 	mov	w5, #0x0                   	// #0
  402a08:	912614c6 	add	x6, x6, #0x985
  402a0c:	f9472421 	ldr	x1, [x1, #3656]
  402a10:	d2800004 	mov	x4, #0x0                   	// #0
  402a14:	d2800003 	mov	x3, #0x0                   	// #0
  402a18:	52800022 	mov	w2, #0x1                   	// #1
  402a1c:	52800000 	mov	w0, #0x0                   	// #0
  402a20:	17fffecc 	b	402550 <z_log_msg_runtime_create.constprop.0>

0000000000402a24 <thingset_can_send_inst>:
    }
}
#else
int thingset_can_send_inst(struct thingset_can *ts_can, uint8_t *tx_buf, size_t tx_len,
                           uint8_t target_addr)
{
  402a24:	d10103ff 	sub	sp, sp, #0x40
  402a28:	a9017bfd 	stp	x29, x30, [sp, #16]
  402a2c:	910043fd 	add	x29, sp, #0x10
  402a30:	a90253f3 	stp	x19, x20, [sp, #32]
  402a34:	aa0003f3 	mov	x19, x0
  402a38:	12001c74 	and	w20, w3, #0xff
  402a3c:	a9035bf5 	stp	x21, x22, [sp, #48]
  402a40:	aa0103f5 	mov	x21, x1
  402a44:	aa0203f6 	mov	x22, x2
    if (!device_is_ready(ts_can->dev)) {
  402a48:	f9400000 	ldr	x0, [x0]
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
  402a4c:	94002f4a 	bl	40e774 <z_device_is_ready>
  402a50:	72001c1f 	tst	w0, #0xff
  402a54:	54000500 	b.eq	402af4 <thingset_can_send_inst+0xd0>  // b.none
        return -ENODEV;
    }

    ts_can->tx_addr.ext_id = THINGSET_CAN_TYPE_CHANNEL | THINGSET_CAN_PRIO_CHANNEL
                             | THINGSET_CAN_TARGET_SET(target_addr)
                             | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  402a58:	39532260 	ldrb	w0, [x19, #1224]

    ts_can->rx_addr.ext_id = THINGSET_CAN_TYPE_CHANNEL | THINGSET_CAN_PRIO_CHANNEL
                             | THINGSET_CAN_TARGET_SET(ts_can->node_addr)
                             | THINGSET_CAN_SOURCE_SET(target_addr);

    int ret = isotp_send(&ts_can->send_ctx, ts_can->dev, tx_buf, tx_len, &ts_can->tx_addr,
  402a5c:	9108c265 	add	x5, x19, #0x230
    ts_can->tx_addr.ext_id = THINGSET_CAN_TYPE_CHANNEL | THINGSET_CAN_PRIO_CHANNEL
  402a60:	b9423a62 	ldr	w2, [x19, #568]
    int ret = isotp_send(&ts_can->send_ctx, ts_can->dev, tx_buf, tx_len, &ts_can->tx_addr,
  402a64:	9108e264 	add	x4, x19, #0x238
  402a68:	aa1603e3 	mov	x3, x22
  402a6c:	d2800007 	mov	x7, #0x0                   	// #0
                             | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  402a70:	2a142001 	orr	w1, w0, w20, lsl #8
                             | THINGSET_CAN_SOURCE_SET(target_addr);
  402a74:	2a002280 	orr	w0, w20, w0, lsl #8
                             | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  402a78:	32050421 	orr	w1, w1, #0x18000000
                             | THINGSET_CAN_SOURCE_SET(target_addr);
  402a7c:	32050400 	orr	w0, w0, #0x18000000
    int ret = isotp_send(&ts_can->send_ctx, ts_can->dev, tx_buf, tx_len, &ts_can->tx_addr,
  402a80:	d2800006 	mov	x6, #0x0                   	// #0
    ts_can->tx_addr.ext_id = THINGSET_CAN_TYPE_CHANNEL | THINGSET_CAN_PRIO_CHANNEL
  402a84:	33007022 	bfxil	w2, w1, #0, #29
    ts_can->rx_addr.ext_id = THINGSET_CAN_TYPE_CHANNEL | THINGSET_CAN_PRIO_CHANNEL
  402a88:	b9423261 	ldr	w1, [x19, #560]
    ts_can->tx_addr.ext_id = THINGSET_CAN_TYPE_CHANNEL | THINGSET_CAN_PRIO_CHANNEL
  402a8c:	b9023a62 	str	w2, [x19, #568]
    int ret = isotp_send(&ts_can->send_ctx, ts_can->dev, tx_buf, tx_len, &ts_can->tx_addr,
  402a90:	aa1503e2 	mov	x2, x21
    ts_can->rx_addr.ext_id = THINGSET_CAN_TYPE_CHANNEL | THINGSET_CAN_PRIO_CHANNEL
  402a94:	33007001 	bfxil	w1, w0, #0, #29
  402a98:	b9023261 	str	w1, [x19, #560]
    int ret = isotp_send(&ts_can->send_ctx, ts_can->dev, tx_buf, tx_len, &ts_can->tx_addr,
  402a9c:	f9400261 	ldr	x1, [x19]
  402aa0:	91058260 	add	x0, x19, #0x160
  402aa4:	94001a7d 	bl	409498 <isotp_send>
                         &ts_can->rx_addr, NULL, NULL);

    if (ret == ISOTP_N_OK) {
  402aa8:	340001c0 	cbz	w0, 402ae0 <thingset_can_send_inst+0xbc>
        return 0;
    }
    else {
        LOG_ERR("Error sending data to addr %d: %d", target_addr, ret);
  402aac:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402ab0:	b90003e0 	str	w0, [sp]
  402ab4:	2a1403e7 	mov	w7, w20
  402ab8:	52800000 	mov	w0, #0x0                   	// #0
  402abc:	f9472421 	ldr	x1, [x1, #3656]
  402ac0:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402ac4:	52800005 	mov	w5, #0x0                   	// #0
  402ac8:	912858c6 	add	x6, x6, #0xa16
  402acc:	d2800004 	mov	x4, #0x0                   	// #0
  402ad0:	d2800003 	mov	x3, #0x0                   	// #0
  402ad4:	52800022 	mov	w2, #0x1                   	// #1
  402ad8:	97fffe9e 	bl	402550 <z_log_msg_runtime_create.constprop.0>
        return -EIO;
  402adc:	12800080 	mov	w0, #0xfffffffb            	// #-5
    }
}
  402ae0:	a9417bfd 	ldp	x29, x30, [sp, #16]
  402ae4:	a94253f3 	ldp	x19, x20, [sp, #32]
  402ae8:	a9435bf5 	ldp	x21, x22, [sp, #48]
  402aec:	910103ff 	add	sp, sp, #0x40
  402af0:	d65f03c0 	ret
        return -ENODEV;
  402af4:	12800240 	mov	w0, #0xffffffed            	// #-19
  402af8:	17fffffa 	b	402ae0 <thingset_can_send_inst+0xbc>

0000000000402afc <thingset_can_init_inst>:
    return 0;
}
#endif /* CONFIG_ISOTP_FAST */

int thingset_can_init_inst(struct thingset_can *ts_can, const struct device *can_dev)
{
  402afc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  402b00:	910003fd 	mov	x29, sp
  402b04:	a90153f3 	stp	x19, x20, [sp, #16]
  402b08:	aa0003f3 	mov	x19, x0
  402b0c:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402b10:	a9025bf5 	stp	x21, x22, [sp, #32]
  402b14:	aa0103f4 	mov	x20, x1
    struct can_frame tx_frame = {
  402b18:	52800035 	mov	w21, #0x1                   	// #1
{
  402b1c:	f9478400 	ldr	x0, [x0, #3848]
  402b20:	a90363f7 	stp	x23, x24, [sp, #48]
  402b24:	a9046bf9 	stp	x25, x26, [sp, #64]
  402b28:	f9400001 	ldr	x1, [x0]
  402b2c:	f9003fe1 	str	x1, [sp, #120]
  402b30:	d2800001 	mov	x1, #0x0                   	// #0
    struct can_frame tx_frame = {
  402b34:	a906ffff 	stp	xzr, xzr, [sp, #104]
  402b38:	3901b7f5 	strb	w21, [sp, #109]
  402b3c:	aa1403e0 	mov	x0, x20
  402b40:	94002f0d 	bl	40e774 <z_device_is_ready>
        .flags = CAN_FRAME_IDE,
    };
    int filter_id;
    int err;

    if (!device_is_ready(can_dev)) {
  402b44:	72001c1f 	tst	w0, #0xff
  402b48:	54000261 	b.ne	402b94 <thingset_can_init_inst+0x98>  // b.any
        LOG_ERR("CAN device not ready");
  402b4c:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
        return -ENODEV;
  402b50:	12800254 	mov	w20, #0xffffffed            	// #-19
        LOG_ERR("CAN device not ready");
  402b54:	2a1503e2 	mov	w2, w21
  402b58:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402b5c:	f9472421 	ldr	x1, [x1, #3656]
  402b60:	9128e0c6 	add	x6, x6, #0xa38
  402b64:	52800005 	mov	w5, #0x0                   	// #0
  402b68:	d2800004 	mov	x4, #0x0                   	// #0
  402b6c:	d2800003 	mov	x3, #0x0                   	// #0
  402b70:	97fffe78 	bl	402550 <z_log_msg_runtime_create.constprop.0>
#endif

    thingset_sdk_reschedule_work(&ts_can->reporting_work, K_NO_WAIT);

    return 0;
}
  402b74:	d0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  402b78:	f9478400 	ldr	x0, [x0, #3848]
  402b7c:	f9403fe2 	ldr	x2, [sp, #120]
  402b80:	f9400001 	ldr	x1, [x0]
  402b84:	eb010042 	subs	x2, x2, x1
  402b88:	d2800001 	mov	x1, #0x0                   	// #0
  402b8c:	54001700 	b.eq	402e6c <thingset_can_init_inst+0x370>  // b.none
  402b90:	97fffa48 	bl	4014b0 <__stack_chk_fail@plt>
    k_work_init_delayable(&ts_can->reporting_work, thingset_can_report_tx_handler);
  402b94:	91002276 	add	x22, x19, #0x8
    k_work_init_delayable(&ts_can->addr_claim_work, thingset_can_addr_claim_tx_handler);
  402b98:	91014277 	add	x23, x19, #0x50
    k_work_init_delayable(&ts_can->reporting_work, thingset_can_report_tx_handler);
  402b9c:	aa1603e0 	mov	x0, x22
  402ba0:	90000001 	adrp	x1, 402000 <__divtf3+0x800>
  402ba4:	911fc021 	add	x1, x1, #0x7f0
  402ba8:	9400397e 	bl	4111a0 <k_work_init_delayable>
    k_work_init_delayable(&ts_can->addr_claim_work, thingset_can_addr_claim_tx_handler);
  402bac:	aa1703e0 	mov	x0, x23
  402bb0:	90000001 	adrp	x1, 402000 <__divtf3+0x800>
  402bb4:	911b2021 	add	x1, x1, #0x6c8
  402bb8:	9400397a 	bl	4111a0 <k_work_init_delayable>
    if (ts_can->node_addr < 1 || ts_can->node_addr > THINGSET_CAN_ADDR_MAX) {
  402bbc:	39532260 	ldrb	w0, [x19, #1224]
    ts_can->dev = can_dev;
  402bc0:	f9000274 	str	x20, [x19]
    if (ts_can->node_addr < 1 || ts_can->node_addr > THINGSET_CAN_ADDR_MAX) {
  402bc4:	51000400 	sub	w0, w0, #0x1
  402bc8:	12001c00 	and	w0, w0, #0xff
  402bcc:	7103f01f 	cmp	w0, #0xfc
  402bd0:	54000049 	b.ls	402bd8 <thingset_can_init_inst+0xdc>  // b.plast
        ts_can->node_addr = 1;
  402bd4:	39132275 	strb	w21, [x19, #1224]
    k_event_init(&ts_can->events);
  402bd8:	91090275 	add	x21, x19, #0x240
	z_impl_k_event_init(event);
  402bdc:	aa1503e0 	mov	x0, x21
  402be0:	94004674 	bl	4145b0 <z_impl_k_event_init>
    can_start(ts_can->dev);
  402be4:	f9400260 	ldr	x0, [x19]
	return api->start(dev);
  402be8:	f9400801 	ldr	x1, [x0, #16]
  402bec:	f9400421 	ldr	x1, [x1, #8]
  402bf0:	d63f0020 	blr	x1
        can_add_rx_filter(ts_can->dev, thingset_can_addr_claim_rx_cb, ts_can, &addr_claim_filter);
  402bf4:	f9400260 	ldr	x0, [x19]
	return api->add_rx_filter(dev, callback, user_data, filter);
  402bf8:	aa1303e2 	mov	x2, x19
  402bfc:	d0000083 	adrp	x3, 414000 <sys_clock_tick_get+0x78>
  402c00:	911dc063 	add	x3, x3, #0x770
  402c04:	f9400801 	ldr	x1, [x0, #16]
  402c08:	f9401824 	ldr	x4, [x1, #48]
  402c0c:	90000001 	adrp	x1, 402000 <__divtf3+0x800>
  402c10:	91183021 	add	x1, x1, #0x60c
  402c14:	d63f0080 	blr	x4
  402c18:	2a0003f4 	mov	w20, w0
    if (filter_id < 0) {
  402c1c:	37f803a0 	tbnz	w0, #31, 402c90 <thingset_can_init_inst+0x194>
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  402c20:	d0000158 	adrp	x24, 42c000 <__FRAME_END__+0xfbbc>
                      | THINGSET_CAN_SOURCE_SET(THINGSET_CAN_ADDR_ANONYMOUS);
  402c24:	52801fd9 	mov	w25, #0xfe                  	// #254
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  402c28:	d0000094 	adrp	x20, 414000 <sys_clock_tick_get+0x78>
  402c2c:	9129c694 	add	x20, x20, #0xa71
  402c30:	f9472718 	ldr	x24, [x24, #3656]
                      | THINGSET_CAN_SOURCE_SET(THINGSET_CAN_ADDR_ANONYMOUS);
  402c34:	72a26019 	movk	w25, #0x1300, lsl #16
	z_impl_k_event_clear(event, events);
  402c38:	52800061 	mov	w1, #0x3                   	// #3
  402c3c:	aa1503e0 	mov	x0, x21
  402c40:	94004662 	bl	4145c8 <z_impl_k_event_clear>
  402c44:	94001a41 	bl	409548 <z_impl_sys_rand32_get>
                      | THINGSET_CAN_RAND_SET(rand) | THINGSET_CAN_TARGET_SET(ts_can->node_addr)
  402c48:	53101c01 	ubfiz	w1, w0, #16, #8
  402c4c:	39532260 	ldrb	w0, [x19, #1224]
        tx_frame.dlc = 0;
  402c50:	3901b3ff 	strb	wzr, [sp, #108]
                      | THINGSET_CAN_RAND_SET(rand) | THINGSET_CAN_TARGET_SET(ts_can->node_addr)
  402c54:	2a002020 	orr	w0, w1, w0, lsl #8
        tx_frame.id = THINGSET_CAN_PRIO_NETWORK_MGMT | THINGSET_CAN_TYPE_NETWORK
  402c58:	b9406be1 	ldr	w1, [sp, #104]
                      | THINGSET_CAN_SOURCE_SET(THINGSET_CAN_ADDR_ANONYMOUS);
  402c5c:	2a190000 	orr	w0, w0, w25
        tx_frame.id = THINGSET_CAN_PRIO_NETWORK_MGMT | THINGSET_CAN_TYPE_NETWORK
  402c60:	33007001 	bfxil	w1, w0, #0, #29
  402c64:	b9006be1 	str	w1, [sp, #104]
        err = can_send(ts_can->dev, &tx_frame, K_MSEC(10), NULL, NULL);
  402c68:	f9400260 	ldr	x0, [x19]
  402c6c:	d2800004 	mov	x4, #0x0                   	// #0
  402c70:	9101a3e1 	add	x1, sp, #0x68
  402c74:	d2800003 	mov	x3, #0x0                   	// #0
  402c78:	d2800022 	mov	x2, #0x1                   	// #1
  402c7c:	94001e4f 	bl	40a5b8 <z_impl_can_send>
        if (err != 0) {
  402c80:	34000200 	cbz	w0, 402cc0 <thingset_can_init_inst+0x1c4>
                k_sleep(K_MSEC(100));
  402c84:	d2800140 	mov	x0, #0xa                   	// #10
  402c88:	97fffed9 	bl	4027ec <k_sleep.isra.0>
                continue;
  402c8c:	17ffffeb 	b	402c38 <thingset_can_init_inst+0x13c>
        LOG_ERR("Unable to add addr_claim filter: %d", filter_id);
  402c90:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402c94:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402c98:	2a0003e7 	mov	w7, w0
  402c9c:	912934c6 	add	x6, x6, #0xa4d
  402ca0:	f9472421 	ldr	x1, [x1, #3656]
  402ca4:	52800005 	mov	w5, #0x0                   	// #0
  402ca8:	d2800004 	mov	x4, #0x0                   	// #0
  402cac:	d2800003 	mov	x3, #0x0                   	// #0
  402cb0:	52800022 	mov	w2, #0x1                   	// #1
        LOG_ERR("Unable to add addr_discovery filter: %d", filter_id);
  402cb4:	52800000 	mov	w0, #0x0                   	// #0
  402cb8:	97fffe26 	bl	402550 <z_log_msg_runtime_create.constprop.0>
        return filter_id;
  402cbc:	17ffffae 	b	402b74 <thingset_can_init_inst+0x78>
	return z_impl_k_event_wait(event, events, reset, timeout);
  402cc0:	d2800643 	mov	x3, #0x32                  	// #50
  402cc4:	aa1503e0 	mov	x0, x21
  402cc8:	52800002 	mov	w2, #0x0                   	// #0
  402ccc:	52800061 	mov	w1, #0x3                   	// #3
  402cd0:	94004641 	bl	4145d4 <z_impl_k_event_wait>
        if (event & EVENT_ADDRESS_ALREADY_USED) {
  402cd4:	f240041f 	tst	x0, #0x3
  402cd8:	54000220 	b.eq	402d1c <thingset_can_init_inst+0x220>  // b.none
  402cdc:	94001a1b 	bl	409548 <z_impl_sys_rand32_get>
            ts_can->node_addr = 1 + sys_rand32_get() % THINGSET_CAN_ADDR_MAX;
  402ce0:	52801fa1 	mov	w1, #0xfd                  	// #253
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  402ce4:	aa1403e6 	mov	x6, x20
  402ce8:	52800005 	mov	w5, #0x0                   	// #0
  402cec:	d2800004 	mov	x4, #0x0                   	// #0
            ts_can->node_addr = 1 + sys_rand32_get() % THINGSET_CAN_ADDR_MAX;
  402cf0:	1ac10807 	udiv	w7, w0, w1
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  402cf4:	d2800003 	mov	x3, #0x0                   	// #0
  402cf8:	52800042 	mov	w2, #0x2                   	// #2
            ts_can->node_addr = 1 + sys_rand32_get() % THINGSET_CAN_ADDR_MAX;
  402cfc:	1b0180e7 	msub	w7, w7, w1, w0
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  402d00:	aa1803e1 	mov	x1, x24
  402d04:	52800000 	mov	w0, #0x0                   	// #0
            ts_can->node_addr = 1 + sys_rand32_get() % THINGSET_CAN_ADDR_MAX;
  402d08:	110004e7 	add	w7, w7, #0x1
  402d0c:	12001ce7 	and	w7, w7, #0xff
  402d10:	39132267 	strb	w7, [x19, #1224]
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  402d14:	97fffe0f 	bl	402550 <z_log_msg_runtime_create.constprop.0>
  402d18:	17ffffc8 	b	402c38 <thingset_can_init_inst+0x13c>
            can_get_state(ts_can->dev, NULL, &err_cnt_before);
  402d1c:	f9400260 	ldr	x0, [x19]
	return api->get_state(dev, state, err_cnt);
  402d20:	f9400801 	ldr	x1, [x0, #16]
  402d24:	910143e2 	add	x2, sp, #0x50
  402d28:	f9402023 	ldr	x3, [x1, #64]
  402d2c:	d2800001 	mov	x1, #0x0                   	// #0
  402d30:	d63f0060 	blr	x3
            thingset_sdk_reschedule_work(&ts_can->addr_claim_work, K_NO_WAIT);
  402d34:	aa1703e0 	mov	x0, x23
  402d38:	d2800001 	mov	x1, #0x0                   	// #0
  402d3c:	97fffdef 	bl	4024f8 <thingset_sdk_reschedule_work>
  402d40:	d2800143 	mov	x3, #0xa                   	// #10
  402d44:	aa1503e0 	mov	x0, x21
  402d48:	52800002 	mov	w2, #0x0                   	// #0
  402d4c:	52800021 	mov	w1, #0x1                   	// #1
  402d50:	94004621 	bl	4145d4 <z_impl_k_event_wait>
            if (!(event & EVENT_ADDRESS_CLAIM_MSG_SENT)) {
  402d54:	3607f980 	tbz	w0, #0, 402c84 <thingset_can_init_inst+0x188>
            can_get_state(ts_can->dev, NULL, &err_cnt_after);
  402d58:	f9400260 	ldr	x0, [x19]
  402d5c:	f9400801 	ldr	x1, [x0, #16]
  402d60:	910163fa 	add	x26, sp, #0x58
  402d64:	aa1a03e2 	mov	x2, x26
  402d68:	f9402023 	ldr	x3, [x1, #64]
  402d6c:	d2800001 	mov	x1, #0x0                   	// #0
  402d70:	d63f0060 	blr	x3
            if (err_cnt_after.tx_err_cnt <= err_cnt_before.tx_err_cnt) {
  402d74:	394163e1 	ldrb	w1, [sp, #88]
  402d78:	394143e0 	ldrb	w0, [sp, #80]
  402d7c:	6b00003f 	cmp	w1, w0
  402d80:	54fff5c8 	b.hi	402c38 <thingset_can_init_inst+0x13c>  // b.pmore
	z_impl_k_event_post(event, events);
  402d84:	52800041 	mov	w1, #0x2                   	// #2
  402d88:	aa1503e0 	mov	x0, x21
                LOG_INF("Using CAN node address 0x%.2X", ts_can->node_addr);
  402d8c:	d0000155 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
  402d90:	9400460c 	bl	4145c0 <z_impl_k_event_post>
  402d94:	39532267 	ldrb	w7, [x19, #1224]
  402d98:	52800005 	mov	w5, #0x0                   	// #0
  402d9c:	f94726b5 	ldr	x21, [x21, #3656]
  402da0:	d2800004 	mov	x4, #0x0                   	// #0
  402da4:	d2800003 	mov	x3, #0x0                   	// #0
  402da8:	52800062 	mov	w2, #0x3                   	// #3
  402dac:	aa1503e1 	mov	x1, x21
  402db0:	52800000 	mov	w0, #0x0                   	// #0
  402db4:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402db8:	912a64c6 	add	x6, x6, #0xa99
  402dbc:	97fffde5 	bl	402550 <z_log_msg_runtime_create.constprop.0>
    struct can_filter addr_discovery_filter = {
  402dc0:	b90063ff 	str	wzr, [sp, #96]
    ts_can->rx_addr.ide = 1;
  402dc4:	3948d660 	ldrb	w0, [x19, #565]
  402dc8:	528000a1 	mov	w1, #0x5                   	// #5
              | THINGSET_CAN_TARGET_SET(ts_can->node_addr),
  402dcc:	52801fc2 	mov	w2, #0xfe                  	// #254
    struct can_filter addr_discovery_filter = {
  402dd0:	390183e1 	strb	w1, [sp, #96]
    ts_can->rx_addr.ide = 1;
  402dd4:	121d7000 	and	w0, w0, #0xfffffff8
              | THINGSET_CAN_TARGET_SET(ts_can->node_addr),
  402dd8:	72a06002 	movk	w2, #0x300, lsl #16
    ts_can->rx_addr.ide = 1;
  402ddc:	2a010000 	orr	w0, w0, w1
  402de0:	3908d660 	strb	w0, [x19, #565]
    ts_can->tx_addr.ide = 1;
  402de4:	3948f660 	ldrb	w0, [x19, #573]
	return api->add_rx_filter(dev, callback, user_data, filter);
  402de8:	aa1a03e3 	mov	x3, x26
  402dec:	121d7000 	and	w0, w0, #0xfffffff8
  402df0:	2a010000 	orr	w0, w0, w1
  402df4:	3908f660 	strb	w0, [x19, #573]
              | THINGSET_CAN_TARGET_SET(ts_can->node_addr),
  402df8:	39532260 	ldrb	w0, [x19, #1224]
  402dfc:	2a002040 	orr	w0, w2, w0, lsl #8
    struct can_filter addr_discovery_filter = {
  402e00:	d2dfffe2 	mov	x2, #0xffff00000000        	// #281470681743360
  402e04:	f2e06002 	movk	x2, #0x300, lsl #48
  402e08:	aa020000 	orr	x0, x0, x2
  402e0c:	f9002fe0 	str	x0, [sp, #88]
  402e10:	aa1303e2 	mov	x2, x19
    filter_id = can_add_rx_filter(ts_can->dev, thingset_can_addr_discovery_rx_cb, ts_can,
  402e14:	f9400260 	ldr	x0, [x19]
  402e18:	f9400801 	ldr	x1, [x0, #16]
  402e1c:	f9401824 	ldr	x4, [x1, #48]
  402e20:	90000001 	adrp	x1, 402000 <__divtf3+0x800>
  402e24:	911e2021 	add	x1, x1, #0x788
  402e28:	d63f0080 	blr	x4
  402e2c:	2a0003f4 	mov	w20, w0
    if (filter_id < 0) {
  402e30:	36f80140 	tbz	w0, #31, 402e58 <thingset_can_init_inst+0x35c>
        LOG_ERR("Unable to add addr_discovery filter: %d", filter_id);
  402e34:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402e38:	2a0003e7 	mov	w7, w0
  402e3c:	912adcc6 	add	x6, x6, #0xab7
  402e40:	aa1503e1 	mov	x1, x21
  402e44:	52800005 	mov	w5, #0x0                   	// #0
  402e48:	d2800004 	mov	x4, #0x0                   	// #0
  402e4c:	d2800003 	mov	x3, #0x0                   	// #0
  402e50:	52800022 	mov	w2, #0x1                   	// #1
  402e54:	17ffff98 	b	402cb4 <thingset_can_init_inst+0x1b8>
    thingset_sdk_reschedule_work(&ts_can->reporting_work, K_NO_WAIT);
  402e58:	aa1603e0 	mov	x0, x22
  402e5c:	d2800001 	mov	x1, #0x0                   	// #0
    return 0;
  402e60:	52800014 	mov	w20, #0x0                   	// #0
    thingset_sdk_reschedule_work(&ts_can->reporting_work, K_NO_WAIT);
  402e64:	97fffda5 	bl	4024f8 <thingset_sdk_reschedule_work>
    return 0;
  402e68:	17ffff43 	b	402b74 <thingset_can_init_inst+0x78>
}
  402e6c:	2a1403e0 	mov	w0, w20
  402e70:	a94153f3 	ldp	x19, x20, [sp, #16]
  402e74:	a9425bf5 	ldp	x21, x22, [sp, #32]
  402e78:	a94363f7 	ldp	x23, x24, [sp, #48]
  402e7c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  402e80:	a8c87bfd 	ldp	x29, x30, [sp], #128
  402e84:	d65f03c0 	ret

0000000000402e88 <thingset_can_thread>:
{
    return &ts_can_single;
}

static void thingset_can_thread()
{
  402e88:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    int err;

    err = thingset_can_init_inst(&ts_can_single, can_dev);
  402e8c:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402e90:	f0000140 	adrp	x0, 42d000 <__dso_handle>
{
  402e94:	910003fd 	mov	x29, sp
    err = thingset_can_init_inst(&ts_can_single, can_dev);
  402e98:	f9472c21 	ldr	x1, [x1, #3672]
  402e9c:	91012000 	add	x0, x0, #0x48
  402ea0:	97ffff17 	bl	402afc <thingset_can_init_inst>
    if (err != 0) {
  402ea4:	340001a0 	cbz	w0, 402ed8 <thingset_can_thread+0x50>
    }

    while (true) {
        k_sleep(K_FOREVER);
    }
}
  402ea8:	a8c17bfd 	ldp	x29, x30, [sp], #16
        LOG_ERR("Failed to init ThingSet CAN: %d", err);
  402eac:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402eb0:	2a0003e7 	mov	w7, w0
  402eb4:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402eb8:	f9472421 	ldr	x1, [x1, #3656]
  402ebc:	912b7cc6 	add	x6, x6, #0xadf
  402ec0:	52800005 	mov	w5, #0x0                   	// #0
  402ec4:	d2800004 	mov	x4, #0x0                   	// #0
  402ec8:	d2800003 	mov	x3, #0x0                   	// #0
  402ecc:	52800022 	mov	w2, #0x1                   	// #1
  402ed0:	52800000 	mov	w0, #0x0                   	// #0
  402ed4:	17fffd9f 	b	402550 <z_log_msg_runtime_create.constprop.0>
        k_sleep(K_FOREVER);
  402ed8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  402edc:	97fffe44 	bl	4027ec <k_sleep.isra.0>
    while (true) {
  402ee0:	17fffffe 	b	402ed8 <thingset_can_thread+0x50>

0000000000402ee4 <thingset_can_set_report_rx_callback_inst>:
{
  402ee4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402ee8:	910003fd 	mov	x29, sp
  402eec:	a90153f3 	stp	x19, x20, [sp, #16]
  402ef0:	aa0003f3 	mov	x19, x0
  402ef4:	aa0103f4 	mov	x20, x1
    if (!device_is_ready(ts_can->dev)) {
  402ef8:	f9400000 	ldr	x0, [x0]
  402efc:	94002e1e 	bl	40e774 <z_device_is_ready>
  402f00:	72001c1f 	tst	w0, #0xff
  402f04:	540003a0 	b.eq	402f78 <thingset_can_set_report_rx_callback_inst+0x94>  // b.none
    if (rx_cb == NULL) {
  402f08:	b40003d4 	cbz	x20, 402f80 <thingset_can_set_report_rx_callback_inst+0x9c>
        can_add_rx_filter(ts_can->dev, thingset_can_report_rx_cb, ts_can, &report_filter);
  402f0c:	f9400260 	ldr	x0, [x19]
    ts_can->report_rx_cb = rx_cb;
  402f10:	f9025e74 	str	x20, [x19, #1208]
  402f14:	aa1303e2 	mov	x2, x19
  402f18:	d0000083 	adrp	x3, 414000 <sys_clock_tick_get+0x78>
  402f1c:	911df063 	add	x3, x3, #0x77c
  402f20:	f9400801 	ldr	x1, [x0, #16]
  402f24:	f9401824 	ldr	x4, [x1, #48]
  402f28:	90000001 	adrp	x1, 402000 <__divtf3+0x800>
  402f2c:	91143021 	add	x1, x1, #0x50c
  402f30:	d63f0080 	blr	x4
  402f34:	2a0003f3 	mov	w19, w0
    if (filter_id < 0) {
  402f38:	36f80280 	tbz	w0, #31, 402f88 <thingset_can_set_report_rx_callback_inst+0xa4>
        LOG_ERR("Unable to add report filter: %d", filter_id);
  402f3c:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402f40:	2a0003e7 	mov	w7, w0
  402f44:	d0000086 	adrp	x6, 414000 <sys_clock_tick_get+0x78>
  402f48:	52800005 	mov	w5, #0x0                   	// #0
  402f4c:	f9472421 	ldr	x1, [x1, #3656]
  402f50:	912bfcc6 	add	x6, x6, #0xaff
  402f54:	d2800004 	mov	x4, #0x0                   	// #0
  402f58:	d2800003 	mov	x3, #0x0                   	// #0
  402f5c:	52800022 	mov	w2, #0x1                   	// #1
  402f60:	52800000 	mov	w0, #0x0                   	// #0
  402f64:	97fffd7b 	bl	402550 <z_log_msg_runtime_create.constprop.0>
}
  402f68:	2a1303e0 	mov	w0, w19
  402f6c:	a94153f3 	ldp	x19, x20, [sp, #16]
  402f70:	a8c27bfd 	ldp	x29, x30, [sp], #32
  402f74:	d65f03c0 	ret
        return -ENODEV;
  402f78:	12800253 	mov	w19, #0xffffffed            	// #-19
  402f7c:	17fffffb 	b	402f68 <thingset_can_set_report_rx_callback_inst+0x84>
        return -EINVAL;
  402f80:	128002b3 	mov	w19, #0xffffffea            	// #-22
  402f84:	17fffff9 	b	402f68 <thingset_can_set_report_rx_callback_inst+0x84>
    return 0;
  402f88:	52800013 	mov	w19, #0x0                   	// #0
  402f8c:	17fffff7 	b	402f68 <thingset_can_set_report_rx_callback_inst+0x84>

0000000000402f90 <thingset_can_send>:
    return thingset_can_send_inst(&ts_can_single, tx_buf, tx_len, target_addr);
  402f90:	2a0203e3 	mov	w3, w2
  402f94:	aa0103e2 	mov	x2, x1
  402f98:	aa0003e1 	mov	x1, x0
  402f9c:	f0000140 	adrp	x0, 42d000 <__dso_handle>
  402fa0:	91012000 	add	x0, x0, #0x48
  402fa4:	17fffea0 	b	402a24 <thingset_can_send_inst>

0000000000402fa8 <thingset_can_set_report_rx_callback>:
    return thingset_can_set_report_rx_callback_inst(&ts_can_single, rx_cb);
  402fa8:	aa0003e1 	mov	x1, x0
  402fac:	f0000140 	adrp	x0, 42d000 <__dso_handle>
  402fb0:	91012000 	add	x0, x0, #0x48
  402fb4:	17ffffcc 	b	402ee4 <thingset_can_set_report_rx_callback_inst>

0000000000402fb8 <report_rx_callback>:
	z_impl_k_sem_give(sem);
  402fb8:	90000160 	adrp	x0, 42e000 <thingset_workq+0x8>
  402fbc:	9115e000 	add	x0, x0, #0x578
  402fc0:	14003517 	b	41041c <z_impl_k_sem_give>

0000000000402fc4 <z_zassert.constprop.0>:

#define z_zexpect(cond, default_msg, file, line, func, msg, ...) z_zexpect_(cond, file, line)

#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  402fc4:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  402fc8:	910003fd 	mov	x29, sp
  402fcc:	a9025bf5 	stp	x21, x22, [sp, #32]
  402fd0:	aa0103f6 	mov	x22, x1
  402fd4:	d0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  402fd8:	a90153f3 	stp	x19, x20, [sp, #16]
  402fdc:	f9478421 	ldr	x1, [x1, #3848]
  402fe0:	f9001bf7 	str	x23, [sp, #48]
  402fe4:	3d8027e0 	str	q0, [sp, #144]
			     const char *func, const char *msg, ...)
{
	if (cond == false) {
  402fe8:	72001c17 	ands	w23, w0, #0xff
static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  402fec:	3d802be1 	str	q1, [sp, #160]
  402ff0:	3d802fe2 	str	q2, [sp, #176]
  402ff4:	3d8033e3 	str	q3, [sp, #192]
  402ff8:	3d8037e4 	str	q4, [sp, #208]
  402ffc:	3d803be5 	str	q5, [sp, #224]
  403000:	3d803fe6 	str	q6, [sp, #240]
  403004:	3d8043e7 	str	q7, [sp, #256]
  403008:	a9111fe6 	stp	x6, x7, [sp, #272]
  40300c:	f9400022 	ldr	x2, [x1]
  403010:	f90047e2 	str	x2, [sp, #136]
  403014:	d2800002 	mov	x2, #0x0                   	// #0
	if (cond == false) {
  403018:	54000401 	b.ne	403098 <z_zassert.constprop.0+0xd4>  // b.any
		va_list vargs;

		va_start(vargs, msg);
  40301c:	910483e0 	add	x0, sp, #0x120
  403020:	a90683e0 	stp	x0, x0, [sp, #104]
  403024:	910443e0 	add	x0, sp, #0x110
  403028:	f9003fe0 	str	x0, [sp, #120]
  40302c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  403030:	b90083e0 	str	w0, [sp, #128]
  403034:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  403038:	aa0503f3 	mov	x19, x5
  40303c:	2a0303f4 	mov	w20, w3
  403040:	aa0403f5 	mov	x21, x4
  403044:	b90087e0 	str	w0, [sp, #132]
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n", ztest_relative_filename(file),
  403048:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40304c:	912d2400 	add	x0, x0, #0xb49
  403050:	94001c65 	bl	40a1e4 <ztest_relative_filename>
  403054:	aa0003e1 	mov	x1, x0
  403058:	aa1603e4 	mov	x4, x22
  40305c:	aa1503e3 	mov	x3, x21
  403060:	2a1403e2 	mov	w2, w20
  403064:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  403068:	912e0800 	add	x0, x0, #0xb82
  40306c:	94000318 	bl	403ccc <printk>
		      line, func, default_msg);
		vprintk(msg, vargs);
  403070:	9101a3e0 	add	x0, sp, #0x68
  403074:	910103e1 	add	x1, sp, #0x40
  403078:	ad400400 	ldp	q0, q1, [x0]
  40307c:	aa1303e0 	mov	x0, x19
  403080:	ad000420 	stp	q0, q1, [x1]
  403084:	94000309 	bl	403ca8 <vprintk>
		printk("\n");
  403088:	f0000080 	adrp	x0, 416000 <__func__.0+0x57a>
  40308c:	91255000 	add	x0, x0, #0x954
  403090:	9400030f 	bl	403ccc <printk>
		va_end(vargs);
		ztest_test_fail();
  403094:	940019c7 	bl	4097b0 <ztest_test_fail>
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n", ztest_relative_filename(file),
		      line, func);
	}
#endif
	return true;
}
  403098:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40309c:	f9478400 	ldr	x0, [x0, #3848]
  4030a0:	f94047e2 	ldr	x2, [sp, #136]
  4030a4:	f9400001 	ldr	x1, [x0]
  4030a8:	eb010042 	subs	x2, x2, x1
  4030ac:	d2800001 	mov	x1, #0x0                   	// #0
  4030b0:	54000040 	b.eq	4030b8 <z_zassert.constprop.0+0xf4>  // b.none
  4030b4:	97fff8ff 	bl	4014b0 <__stack_chk_fail@plt>
  4030b8:	2a1703e0 	mov	w0, w23
  4030bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4030c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4030c4:	f9401bf7 	ldr	x23, [sp, #48]
  4030c8:	a8d27bfd 	ldp	x29, x30, [sp], #288
  4030cc:	d65f03c0 	ret

00000000004030d0 <_thingset_can_test_send_request_to_node_wrapper>:
static void request_rx_cb(const struct device *dev, struct can_frame *frame, void *user_data)
{
    k_sem_give(&request_tx_sem);
}

ZTEST(thingset_can, test_send_request_to_node)
  4030d0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4030d4:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4030d8:	910003fd 	mov	x29, sp
  4030dc:	f9478400 	ldr	x0, [x0, #3848]
  4030e0:	a90153f3 	stp	x19, x20, [sp, #16]
  4030e4:	f90013f5 	str	x21, [sp, #32]
  4030e8:	f9400001 	ldr	x1, [x0]
  4030ec:	f90027e1 	str	x1, [sp, #72]
  4030f0:	d2800001 	mov	x1, #0x0                   	// #0
{
    struct can_filter other_node_filter = {
  4030f4:	d2998000 	mov	x0, #0xcc00                	// #52224
  4030f8:	f2a30000 	movk	x0, #0x1800, lsl #16
  4030fc:	f2dfe000 	movk	x0, #0xff00, lsl #32
  403100:	f2e3e000 	movk	x0, #0x1f00, lsl #48
  403104:	f9001be0 	str	x0, [sp, #48]
  403108:	528000a0 	mov	w0, #0x5                   	// #5
  40310c:	b9003be0 	str	w0, [sp, #56]
        .id = 0x1800CC00,
        .mask = 0x1F00FF00,
        .flags = CAN_FILTER_DATA | CAN_FILTER_IDE,
    };
    uint8_t req_buf[] = { 0x01, 0x00 }; /* simple single-frame request via ISO-TP */
  403110:	52800020 	mov	w0, #0x1                   	// #1
  403114:	790083e0 	strh	w0, [sp, #64]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_RESET);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_reset(sem);
  403118:	f0000155 	adrp	x21, 42e000 <thingset_workq+0x8>
  40311c:	911682a0 	add	x0, x21, #0x5a0
  403120:	94003567 	bl	4106bc <z_impl_k_sem_reset>
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  403124:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
	if (filter == NULL || (filter->flags & (CAN_FILTER_DATA | CAN_FILTER_RTR)) == 0) {
  403128:	3940e3e2 	ldrb	w2, [sp, #56]
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  40312c:	f9472c00 	ldr	x0, [x0, #3672]
  403130:	f9400801 	ldr	x1, [x0, #16]
	if (filter == NULL || (filter->flags & (CAN_FILTER_DATA | CAN_FILTER_RTR)) == 0) {
  403134:	721f045f 	tst	w2, #0x6
  403138:	540005e0 	b.eq	4031f4 <_thingset_can_test_send_request_to_node_wrapper+0x124>  // b.none
	return api->add_rx_filter(dev, callback, user_data, filter);
  40313c:	f9401824 	ldr	x4, [x1, #48]
  403140:	9100c3e3 	add	x3, sp, #0x30
  403144:	d2800002 	mov	x2, #0x0                   	// #0
  403148:	90000001 	adrp	x1, 403000 <z_zassert.constprop.0+0x3c>
  40314c:	91083021 	add	x1, x1, #0x20c
  403150:	d63f0080 	blr	x4
  403154:	2a0003e6 	mov	w6, w0
    int err;

    k_sem_reset(&request_tx_sem);

    err = can_add_rx_filter(can_dev, &request_rx_cb, NULL, &other_node_filter);
    zassert_false(err < 0, "adding rx filter failed: %d", err);
  403158:	b0000094 	adrp	x20, 414000 <sys_clock_tick_get+0x78>
  40315c:	91333694 	add	x20, x20, #0xccd
  403160:	2a2603e0 	mvn	w0, w6
  403164:	aa1403e4 	mov	x4, x20
  403168:	b0000085 	adrp	x5, 414000 <sys_clock_tick_get+0x78>
  40316c:	912ea8a5 	add	x5, x5, #0xbaa
  403170:	52800823 	mov	w3, #0x41                  	// #65
  403174:	b0000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  403178:	912d2673 	add	x19, x19, #0xb49
  40317c:	531f7c00 	lsr	w0, w0, #31
  403180:	aa1303e2 	mov	x2, x19
  403184:	b0000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  403188:	912f1821 	add	x1, x1, #0xbc6
  40318c:	97ffff8e 	bl	402fc4 <z_zassert.constprop.0>

    thingset_can_send(req_buf, sizeof(req_buf), 0xCC);
  403190:	910103e0 	add	x0, sp, #0x40
  403194:	12800662 	mov	w2, #0xffffffcc            	// #-52
  403198:	d2800041 	mov	x1, #0x2                   	// #2
  40319c:	97ffff7d 	bl	402f90 <thingset_can_send>
	return z_impl_k_sem_take(sem, timeout);
  4031a0:	d2800141 	mov	x1, #0xa                   	// #10
  4031a4:	911682a0 	add	x0, x21, #0x5a0
  4031a8:	940034d4 	bl	4104f8 <z_impl_k_sem_take>

    err = k_sem_take(&request_tx_sem, TEST_RECEIVE_TIMEOUT);
    zassert_equal(err, 0, "receive timeout");
  4031ac:	7100001f 	cmp	w0, #0x0
  4031b0:	aa1303e2 	mov	x2, x19
  4031b4:	1a9f17e0 	cset	w0, eq  // eq = none
  4031b8:	aa1403e4 	mov	x4, x20
  4031bc:	b0000085 	adrp	x5, 414000 <sys_clock_tick_get+0x78>
  4031c0:	528008c3 	mov	w3, #0x46                  	// #70
  4031c4:	912f60a5 	add	x5, x5, #0xbd8
  4031c8:	b0000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  4031cc:	912fa021 	add	x1, x1, #0xbe8
  4031d0:	97ffff7d 	bl	402fc4 <z_zassert.constprop.0>
ZTEST(thingset_can, test_send_request_to_node)
  4031d4:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4031d8:	f9478400 	ldr	x0, [x0, #3848]
  4031dc:	f94027e2 	ldr	x2, [sp, #72]
  4031e0:	f9400001 	ldr	x1, [x0]
  4031e4:	eb010042 	subs	x2, x2, x1
  4031e8:	d2800001 	mov	x1, #0x0                   	// #0
  4031ec:	54000080 	b.eq	4031fc <_thingset_can_test_send_request_to_node_wrapper+0x12c>  // b.none
  4031f0:	97fff8b0 	bl	4014b0 <__stack_chk_fail@plt>
		return -EINVAL;
  4031f4:	128002a6 	mov	w6, #0xffffffea            	// #-22
  4031f8:	17ffffd8 	b	403158 <_thingset_can_test_send_request_to_node_wrapper+0x88>
  4031fc:	a94153f3 	ldp	x19, x20, [sp, #16]
  403200:	f94013f5 	ldr	x21, [sp, #32]
  403204:	a8c57bfd 	ldp	x29, x30, [sp], #80
  403208:	d65f03c0 	ret

000000000040320c <request_rx_cb>:
	z_impl_k_sem_give(sem);
  40320c:	f0000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  403210:	91168000 	add	x0, x0, #0x5a0
  403214:	14003482 	b	41041c <z_impl_k_sem_give>

0000000000403218 <_thingset_can_test_receive_report_from_node_wrapper>:
ZTEST(thingset_can, test_receive_report_from_node)
  403218:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40321c:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  403220:	910003fd 	mov	x29, sp
  403224:	f9478400 	ldr	x0, [x0, #3848]
  403228:	a90153f3 	stp	x19, x20, [sp, #16]
  40322c:	a9025bf5 	stp	x21, x22, [sp, #32]
  403230:	f9400001 	ldr	x1, [x0]
  403234:	f90027e1 	str	x1, [sp, #72]
  403238:	d2800001 	mov	x1, #0x0                   	// #0
    struct can_frame report_frame = {
  40323c:	d2800040 	mov	x0, #0x2                   	// #2
  403240:	f2a3c000 	movk	x0, #0x1e00, lsl #16
  403244:	f2c02020 	movk	x0, #0x101, lsl #32
  403248:	f9001fe0 	str	x0, [sp, #56]
  40324c:	d2801ec0 	mov	x0, #0xf6                  	// #246
  403250:	f90023e0 	str	x0, [sp, #64]
	z_impl_k_sem_reset(sem);
  403254:	f0000156 	adrp	x22, 42e000 <thingset_workq+0x8>
  403258:	9115e2d6 	add	x22, x22, #0x578
  40325c:	aa1603e0 	mov	x0, x22
  403260:	94003517 	bl	4106bc <z_impl_k_sem_reset>
  403264:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  403268:	9100e3e1 	add	x1, sp, #0x38
  40326c:	d2800004 	mov	x4, #0x0                   	// #0
  403270:	d2800003 	mov	x3, #0x0                   	// #0
  403274:	f9472c00 	ldr	x0, [x0, #3672]
  403278:	d2800022 	mov	x2, #0x1                   	// #1
    zassert_equal(err, 0, "can_send failed: %d", err);
  40327c:	b0000095 	adrp	x21, 414000 <sys_clock_tick_get+0x78>
  403280:	b0000094 	adrp	x20, 414000 <sys_clock_tick_get+0x78>
  403284:	9133d2b5 	add	x21, x21, #0xcf4
  403288:	912d2694 	add	x20, x20, #0xb49
  40328c:	94001ccb 	bl	40a5b8 <z_impl_can_send>
  403290:	7100001f 	cmp	w0, #0x0
  403294:	b0000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  403298:	912fa273 	add	x19, x19, #0xbe8
  40329c:	2a0003e6 	mov	w6, w0
  4032a0:	aa1503e4 	mov	x4, x21
  4032a4:	aa1403e2 	mov	x2, x20
  4032a8:	aa1303e1 	mov	x1, x19
  4032ac:	1a9f17e0 	cset	w0, eq  // eq = none
  4032b0:	52800523 	mov	w3, #0x29                  	// #41
  4032b4:	b0000085 	adrp	x5, 414000 <sys_clock_tick_get+0x78>
  4032b8:	912ff4a5 	add	x5, x5, #0xbfd
  4032bc:	97ffff42 	bl	402fc4 <z_zassert.constprop.0>
	return z_impl_k_sem_take(sem, timeout);
  4032c0:	d2800141 	mov	x1, #0xa                   	// #10
  4032c4:	aa1603e0 	mov	x0, x22
  4032c8:	9400348c 	bl	4104f8 <z_impl_k_sem_take>
    zassert_equal(err, 0, "receive timeout");
  4032cc:	7100001f 	cmp	w0, #0x0
  4032d0:	aa1403e2 	mov	x2, x20
  4032d4:	aa1303e1 	mov	x1, x19
  4032d8:	1a9f17e0 	cset	w0, eq  // eq = none
  4032dc:	aa1503e4 	mov	x4, x21
  4032e0:	b0000085 	adrp	x5, 414000 <sys_clock_tick_get+0x78>
  4032e4:	52800583 	mov	w3, #0x2c                  	// #44
  4032e8:	912f60a5 	add	x5, x5, #0xbd8
  4032ec:	97ffff36 	bl	402fc4 <z_zassert.constprop.0>
ZTEST(thingset_can, test_receive_report_from_node)
  4032f0:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4032f4:	f9478400 	ldr	x0, [x0, #3848]
  4032f8:	f94027e2 	ldr	x2, [sp, #72]
  4032fc:	f9400001 	ldr	x1, [x0]
  403300:	eb010042 	subs	x2, x2, x1
  403304:	d2800001 	mov	x1, #0x0                   	// #0
  403308:	54000040 	b.eq	403310 <_thingset_can_test_receive_report_from_node_wrapper+0xf8>  // b.none
  40330c:	97fff869 	bl	4014b0 <__stack_chk_fail@plt>
  403310:	a94153f3 	ldp	x19, x20, [sp, #16]
  403314:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403318:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40331c:	d65f03c0 	ret

0000000000403320 <thingset_can_setup>:
}

static void *thingset_can_setup(void)
{
  403320:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  403324:	910003fd 	mov	x29, sp
  403328:	a90153f3 	stp	x19, x20, [sp, #16]
  40332c:	a9025bf5 	stp	x21, x22, [sp, #32]
  403330:	f9001bf7 	str	x23, [sp, #48]
	return z_impl_k_sem_init(sem, initial_count, limit);
  403334:	52800022 	mov	w2, #0x1                   	// #1
  403338:	52800001 	mov	w1, #0x0                   	// #0
  40333c:	f0000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  403340:	9115e000 	add	x0, x0, #0x578
  403344:	9400342b 	bl	4103f0 <z_impl_k_sem_init>
  403348:	52800022 	mov	w2, #0x1                   	// #1
  40334c:	52800001 	mov	w1, #0x0                   	// #0
  403350:	f0000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  403354:	91168000 	add	x0, x0, #0x5a0
  403358:	94003426 	bl	4103f0 <z_impl_k_sem_init>
    int err;

    k_sem_init(&report_rx_sem, 0, 1);
    k_sem_init(&request_tx_sem, 0, 1);

    thingset_init_global(&ts);
  40335c:	f0000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  403360:	91172000 	add	x0, x0, #0x5c8
  403364:	94001f62 	bl	40b0ec <thingset_init_global>
  403368:	b0000153 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>

    zassert_true(device_is_ready(can_dev), "CAN device not ready");
  40336c:	b0000095 	adrp	x21, 414000 <sys_clock_tick_get+0x78>
  403370:	b0000094 	adrp	x20, 414000 <sys_clock_tick_get+0x78>
  403374:	9132eab5 	add	x21, x21, #0xcba
  403378:	f9472e73 	ldr	x19, [x19, #3672]
  40337c:	912d2694 	add	x20, x20, #0xb49
  403380:	aa1303e0 	mov	x0, x19
  403384:	94002cfc 	bl	40e774 <z_device_is_ready>
  403388:	aa1503e4 	mov	x4, x21
  40338c:	aa1403e2 	mov	x2, x20
  403390:	52800a43 	mov	w3, #0x52                  	// #82
  403394:	b0000085 	adrp	x5, 414000 <sys_clock_tick_get+0x78>
  403398:	b0000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  40339c:	9128e0a5 	add	x5, x5, #0xa38
  4033a0:	91304421 	add	x1, x1, #0xc11
  4033a4:	97ffff08 	bl	402fc4 <z_zassert.constprop.0>
	return api->stop(dev);
  4033a8:	f9400a77 	ldr	x23, [x19, #16]
  4033ac:	aa1303e0 	mov	x0, x19
  4033b0:	f9400ae1 	ldr	x1, [x23, #16]
  4033b4:	d63f0020 	blr	x1
	return api->set_mode(dev, mode);
  4033b8:	f9400ee2 	ldr	x2, [x23, #24]
  4033bc:	aa1303e0 	mov	x0, x19
  4033c0:	52800021 	mov	w1, #0x1                   	// #1

    (void)can_stop(can_dev);

    err = can_set_mode(can_dev, CAN_MODE_LOOPBACK);
    zassert_equal(err, 0, "failed to set loopback mode (err %d)", err);
  4033c4:	b0000096 	adrp	x22, 414000 <sys_clock_tick_get+0x78>
  4033c8:	912fa2d6 	add	x22, x22, #0xbe8
  4033cc:	d63f0040 	blr	x2
  4033d0:	7100001f 	cmp	w0, #0x0
  4033d4:	2a0003e6 	mov	w6, w0
  4033d8:	aa1503e4 	mov	x4, x21
  4033dc:	aa1403e2 	mov	x2, x20
  4033e0:	aa1603e1 	mov	x1, x22
  4033e4:	1a9f17e0 	cset	w0, eq  // eq = none
  4033e8:	52800ae3 	mov	w3, #0x57                  	// #87
  4033ec:	b0000085 	adrp	x5, 414000 <sys_clock_tick_get+0x78>
  4033f0:	9130d4a5 	add	x5, x5, #0xc35
  4033f4:	97fffef4 	bl	402fc4 <z_zassert.constprop.0>
	return api->start(dev);
  4033f8:	f94006e1 	ldr	x1, [x23, #8]
  4033fc:	aa1303e0 	mov	x0, x19
  403400:	d63f0020 	blr	x1

    err = can_start(can_dev);
    zassert_equal(err, 0, "failed to start CAN controller (err %d)", err);
  403404:	7100001f 	cmp	w0, #0x0
  403408:	2a0003e6 	mov	w6, w0
  40340c:	aa1503e4 	mov	x4, x21
  403410:	aa1403e2 	mov	x2, x20
  403414:	aa1603e1 	mov	x1, x22
  403418:	1a9f17e0 	cset	w0, eq  // eq = none
  40341c:	52800b43 	mov	w3, #0x5a                  	// #90
  403420:	b0000085 	adrp	x5, 414000 <sys_clock_tick_get+0x78>
  403424:	913168a5 	add	x5, x5, #0xc5a
  403428:	97fffee7 	bl	402fc4 <z_zassert.constprop.0>
	return z_impl_k_sleep(timeout);
  40342c:	d2800c80 	mov	x0, #0x64                  	// #100
  403430:	94003f23 	bl	4130bc <z_impl_k_sleep>

    /* wait for address claiming to finish */
    k_sleep(K_MSEC(1000));

    thingset_can_set_report_rx_callback(report_rx_callback);
  403434:	f0ffffe0 	adrp	x0, 402000 <__divtf3+0x800>
  403438:	913ee000 	add	x0, x0, #0xfb8
  40343c:	97fffedb 	bl	402fa8 <thingset_can_set_report_rx_callback>

    return NULL;
}
  403440:	d2800000 	mov	x0, #0x0                   	// #0
  403444:	a94153f3 	ldp	x19, x20, [sp, #16]
  403448:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40344c:	f9401bf7 	ldr	x23, [sp, #48]
  403450:	a8c47bfd 	ldp	x29, x30, [sp], #64
  403454:	d65f03c0 	ret

0000000000403458 <cbvprintf_package>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
  403458:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  40345c:	910003fd 	mov	x29, sp
  403460:	a90153f3 	stp	x19, x20, [sp, #16]
  403464:	aa0003f4 	mov	x20, x0
  403468:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40346c:	a9025bf5 	stp	x21, x22, [sp, #32]
  403470:	aa0103f5 	mov	x21, x1
  403474:	f9478400 	ldr	x0, [x0, #3848]
  403478:	a90363f7 	stp	x23, x24, [sp, #48]
  40347c:	a9046bf9 	stp	x25, x26, [sp, #64]
  403480:	a90573fb 	stp	x27, x28, [sp, #80]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
	bool is_str_arg = false;
	union cbprintf_package_hdr *pkg_hdr = packaged;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
  403484:	f2400a9c 	ands	x28, x20, #0x7
{
  403488:	f9400001 	ldr	x1, [x0]
  40348c:	f90067e1 	str	x1, [sp, #200]
  403490:	d2800001 	mov	x1, #0x0                   	// #0
  403494:	121e0040 	and	w0, w2, #0x4
  403498:	b90083e0 	str	w0, [sp, #128]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
  40349c:	d3431441 	ubfx	x1, x2, #3, #3
  4034a0:	29436488 	ldp	w8, w25, [x4, #24]
  4034a4:	a940289b 	ldp	x27, x10, [x4]
  4034a8:	f940088c 	ldr	x12, [x4, #16]
	if ((uintptr_t)packaged % sizeof(void *)) {
  4034ac:	54003781 	b.ne	403b9c <cbvprintf_package+0x744>  // b.any
  4034b0:	aa0303fa 	mov	x26, x3
  4034b4:	11000421 	add	w1, w1, #0x1
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * multiple of pointer size for the above to preserve alignment.
	 *
	 * Refer to union cbprintf_package_hdr for more details.
	 */
	buf += sizeof(*pkg_hdr);
  4034b8:	91002293 	add	x19, x20, #0x8
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
  4034bc:	b5003754 	cbnz	x20, 403ba4 <cbvprintf_package+0x74c>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  4034c0:	92400ab5 	and	x21, x21, #0x7
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  4034c4:	d2800100 	mov	x0, #0x8                   	// #8
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  4034c8:	910022b3 	add	x19, x21, #0x8
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  4034cc:	cb150015 	sub	x21, x0, x21
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
	align = VA_STACK_ALIGN(char *);
  4034d0:	52800118 	mov	w24, #0x8                   	// #8
					align = VA_STACK_ALIGN(int);
					size = sizeof(int);
				}
				continue;
			}
			switch (*fmt) {
  4034d4:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  4034d8:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  4034dc:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  4034e0:	b000008b 	adrp	x11, 414000 <sys_clock_tick_get+0x78>
	s = fmt--;
  4034e4:	d1000749 	sub	x9, x26, #0x1
	size = sizeof(char *);
  4034e8:	2a1803f6 	mov	w22, w24
			switch (*fmt) {
  4034ec:	911e716b 	add	x11, x11, #0x79c
  4034f0:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
	bool parsing = false;
  4034f4:	52800017 	mov	w23, #0x0                   	// #0
			switch (*fmt) {
  4034f8:	911e2000 	add	x0, x0, #0x788
	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
  4034fc:	12800006 	mov	w6, #0xffffffff            	// #-1
	unsigned int s_ro_cnt = 0; /* number of ro strings */
  403500:	52800005 	mov	w5, #0x0                   	// #0
	unsigned int s_rw_cnt = 0; /* number of rw strings */
  403504:	52800004 	mov	w4, #0x0                   	// #0
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
  403508:	52800003 	mov	w3, #0x0                   	// #0
  40350c:	d280002d 	mov	x13, #0x1                   	// #1
			switch (*fmt) {
  403510:	f2c0004e 	movk	x14, #0x2, lsl #32
  403514:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  403518:	f2e06012 	movk	x18, #0x300, lsl #48
  40351c:	f90033e0 	str	x0, [sp, #96]

		/* copy va_list data over to our buffer */
		if (is_str_arg) {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
  403520:	b4000054 	cbz	x20, 403528 <cbvprintf_package+0xd0>
				*(const char **)buf = s;
  403524:	f900027a 	str	x26, [x19]
			}

			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);

			if (is_ro && !do_ro) {
  403528:	721f0050 	ands	w16, w2, #0x2
  40352c:	7a400824 	ccmp	w1, #0x0, #0x4, eq  // eq = none
  403530:	54001aec 	b.gt	40388c <cbvprintf_package+0x434>
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
  403534:	cb140260 	sub	x0, x19, x20
  403538:	d342fc00 	lsr	x0, x0, #2
				 * In the do_ro case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
  40353c:	7101fc1f 	cmp	w0, #0x7f
  403540:	7a408a04 	ccmp	w16, #0x0, #0x4, hi  // hi = pmore
  403544:	54001640 	b.eq	40380c <cbvprintf_package+0x3b4>  // b.none
					__ASSERT(false, "String with too many arguments");
  403548:	b0000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  40354c:	91347e73 	add	x19, x19, #0xd1f
  403550:	aa1303e2 	mov	x2, x19
  403554:	900000a1 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  403558:	91055821 	add	x1, x1, #0x156
  40355c:	52804f63 	mov	w3, #0x27b                 	// #635
  403560:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  403564:	91353400 	add	x0, x0, #0xd4d
  403568:	94000715 	bl	4051bc <assert_print>
  40356c:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  403570:	9135a800 	add	x0, x0, #0xd6a
  403574:	94000712 	bl	4051bc <assert_print>
  403578:	aa1303e0 	mov	x0, x19
  40357c:	52804f61 	mov	w1, #0x27b                 	// #635
  403580:	94000739 	bl	405264 <assert_post_action>
  403584:	52804f62 	mov	w2, #0x27b                 	// #635
					return -EINVAL;
				}

				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
					__ASSERT(false, "str_ptr_pos[] too small");
  403588:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40358c:	aa1303e1 	mov	x1, x19
  403590:	91362c00 	add	x0, x0, #0xd8b
  403594:	94001126 	bl	407a2c <posix_print_error_and_exit>
			switch (*fmt) {
  403598:	7101e91f 	cmp	w8, #0x7a
  40359c:	540000e8 	b.hi	4035b8 <cbvprintf_package+0x160>  // b.pmore
  4035a0:	71019d1f 	cmp	w8, #0x67
  4035a4:	54000208 	b.hi	4035e4 <cbvprintf_package+0x18c>  // b.pmore
  4035a8:	7100a91f 	cmp	w8, #0x2a
  4035ac:	54000408 	b.hi	40362c <cbvprintf_package+0x1d4>  // b.pmore
  4035b0:	71007d1f 	cmp	w8, #0x1f
  4035b4:	540002e8 	b.hi	403610 <cbvprintf_package+0x1b8>  // b.pmore
				parsing = false;
  4035b8:	52800017 	mov	w23, #0x0                   	// #0
			if (*++fmt == '\0') {
  4035bc:	38401d28 	ldrb	w8, [x9, #1]!
  4035c0:	340022a8 	cbz	w8, 403a14 <cbvprintf_package+0x5bc>
			if (!parsing) {
  4035c4:	35fffeb7 	cbnz	w23, 403598 <cbvprintf_package+0x140>
				if (*fmt == '%') {
  4035c8:	7100951f 	cmp	w8, #0x25
  4035cc:	54ffff81 	b.ne	4035bc <cbvprintf_package+0x164>  // b.any
					arg_idx++;
  4035d0:	110004c6 	add	w6, w6, #0x1
					parsing = true;
  4035d4:	52800037 	mov	w23, #0x1                   	// #1
					align = VA_STACK_ALIGN(int);
  4035d8:	52800118 	mov	w24, #0x8                   	// #8
					size = sizeof(int);
  4035dc:	52800096 	mov	w22, #0x4                   	// #4
  4035e0:	17fffff7 	b	4035bc <cbvprintf_package+0x164>
			switch (*fmt) {
  4035e4:	5101a108 	sub	w8, w8, #0x68
  4035e8:	7100491f 	cmp	w8, #0x12
  4035ec:	54fffe68 	b.hi	4035b8 <cbvprintf_package+0x160>  // b.pmore
  4035f0:	f94033e7 	ldr	x7, [sp, #96]
  4035f4:	386848e8 	ldrb	w8, [x7, w8, uxtw]
  4035f8:	10000070 	adr	x16, 403604 <cbvprintf_package+0x1ac>
  4035fc:	8b288a08 	add	x8, x16, w8, sxtb #2
  403600:	d61f0100 	br	x8
  403604:	52800118 	mov	w24, #0x8                   	// #8
  403608:	2a1803f6 	mov	w22, w24
  40360c:	17ffffec 	b	4035bc <cbvprintf_package+0x164>
  403610:	51008108 	sub	w8, w8, #0x20
  403614:	7100291f 	cmp	w8, #0xa
  403618:	54fffd08 	b.hi	4035b8 <cbvprintf_package+0x160>  // b.pmore
  40361c:	38684968 	ldrb	w8, [x11, w8, uxtw]
  403620:	10000070 	adr	x16, 40362c <cbvprintf_package+0x1d4>
  403624:	8b288a08 	add	x8, x16, w8, sxtb #2
  403628:	d61f0100 	br	x8
  40362c:	5100ad08 	sub	w8, w8, #0x2b
  403630:	9ac821a8 	lsl	x8, x13, x8
  403634:	ea0e011f 	tst	x8, x14
  403638:	54fffc21 	b.ne	4035bc <cbvprintf_package+0x164>  // b.any
  40363c:	ea0f011f 	tst	x8, x15
  403640:	540003e1 	b.ne	4036bc <cbvprintf_package+0x264>  // b.any
  403644:	ea12011f 	tst	x8, x18
  403648:	54fffb80 	b.eq	4035b8 <cbvprintf_package+0x160>  // b.none
				if (fmt[-1] == 'l') {
  40364c:	385ff128 	ldurb	w8, [x9, #-1]
				parsing = false;
  403650:	52800017 	mov	w23, #0x0                   	// #0
				if (fmt[-1] == 'l') {
  403654:	7101b11f 	cmp	w8, #0x6c
  403658:	52800008 	mov	w8, #0x0                   	// #0
  40365c:	54000061 	b.ne	403668 <cbvprintf_package+0x210>  // b.any
				align = VA_STACK_ALIGN(void *);
  403660:	52800118 	mov	w24, #0x8                   	// #8
				size = sizeof(void *);
  403664:	2a1803f6 	mov	w22, w24
		buf = (void *) ROUND_UP(buf, align);
  403668:	2a1803f0 	mov	w16, w24
  40366c:	d1000673 	sub	x19, x19, #0x1
  403670:	8b384273 	add	x19, x19, w24, uxtw
  403674:	cb1003f0 	neg	x16, x16
  403678:	8a100273 	and	x19, x19, x16
		if (buf0 != NULL && BUF_OFFSET + size > len) {
  40367c:	b40000d4 	cbz	x20, 403694 <cbvprintf_package+0x23c>
  403680:	2a1603f0 	mov	w16, w22
  403684:	cb140210 	sub	x16, x16, x20
  403688:	8b130210 	add	x16, x16, x19
  40368c:	eb15021f 	cmp	x16, x21
  403690:	54000408 	b.hi	403710 <cbvprintf_package+0x2b8>  // b.pmore
		if (is_str_arg) {
  403694:	34001488 	cbz	w8, 403924 <cbvprintf_package+0x4cc>
			s = va_arg(ap, char *);
  403698:	37f80a80 	tbnz	w0, #31, 4037e8 <cbvprintf_package+0x390>
  40369c:	91003fdb 	add	x27, x30, #0xf
  4036a0:	2a0003e8 	mov	w8, w0
  4036a4:	927df37b 	and	x27, x27, #0xfffffffffffffff8
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
  4036a8:	51000421 	sub	w1, w1, #0x1
			s = va_arg(ap, char *);
  4036ac:	f94003da 	ldr	x26, [x30]
  4036b0:	17ffff9c 	b	403520 <cbvprintf_package+0xc8>
				arg_idx--;
  4036b4:	510004c6 	sub	w6, w6, #0x1
				continue;
  4036b8:	17ffffc0 	b	4035b8 <cbvprintf_package+0x160>
				if (fmt[-1] == 'L') {
  4036bc:	385ff138 	ldurb	w24, [x9, #-1]
  4036c0:	7101331f 	cmp	w24, #0x4c
  4036c4:	540004a1 	b.ne	403758 <cbvprintf_package+0x300>  // b.any
					v.ld = va_arg(ap, long double);
  4036c8:	37f80379 	tbnz	w25, #31, 403734 <cbvprintf_package+0x2dc>
  4036cc:	91003fc8 	add	x8, x30, #0xf
  4036d0:	2a1903f7 	mov	w23, w25
  4036d4:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  4036d8:	9100411e 	add	x30, x8, #0x10
  4036dc:	a9404510 	ldp	x16, x17, [x8]
					size = sizeof(long double);
  4036e0:	aa1e03e8 	mov	x8, x30
  4036e4:	52800216 	mov	w22, #0x10                  	// #16
				buf = (void *) ROUND_UP(buf, align);
  4036e8:	2a1603f9 	mov	w25, w22
  4036ec:	d1000673 	sub	x19, x19, #0x1
  4036f0:	8b364273 	add	x19, x19, w22, uxtw
  4036f4:	cb1903fb 	neg	x27, x25
  4036f8:	8a1b0273 	and	x19, x19, x27
				if (buf0 != NULL) {
  4036fc:	b40005b4 	cbz	x20, 4037b0 <cbvprintf_package+0x358>
					if (BUF_OFFSET + size > len) {
  403700:	cb14033b 	sub	x27, x25, x20
  403704:	8b13037b 	add	x27, x27, x19
  403708:	eb15037f 	cmp	x27, x21
  40370c:	54000489 	b.ls	40379c <cbvprintf_package+0x344>  // b.plast
			return -ENOSPC;
  403710:	12800360 	mov	w0, #0xffffffe4            	// #-28
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
  403714:	b0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  403718:	f9478421 	ldr	x1, [x1, #3848]
  40371c:	f94067e3 	ldr	x3, [sp, #200]
  403720:	f9400022 	ldr	x2, [x1]
  403724:	eb020063 	subs	x3, x3, x2
  403728:	d2800002 	mov	x2, #0x0                   	// #0
  40372c:	54002420 	b.eq	403bb0 <cbvprintf_package+0x758>  // b.none
  403730:	97fff760 	bl	4014b0 <__stack_chk_fail@plt>
					v.ld = va_arg(ap, long double);
  403734:	11004337 	add	w23, w25, #0x10
  403738:	710002ff 	cmp	w23, #0x0
  40373c:	540000ad 	b.le	403750 <cbvprintf_package+0x2f8>
  403740:	91003fc8 	add	x8, x30, #0xf
  403744:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  403748:	9100411e 	add	x30, x8, #0x10
  40374c:	17ffffe4 	b	4036dc <cbvprintf_package+0x284>
  403750:	8b39c188 	add	x8, x12, w25, sxtw
  403754:	17ffffe2 	b	4036dc <cbvprintf_package+0x284>
					v.d = va_arg(ap, double);
  403758:	37f80119 	tbnz	w25, #31, 403778 <cbvprintf_package+0x320>
  40375c:	91003fc8 	add	x8, x30, #0xf
  403760:	2a1903f7 	mov	w23, w25
  403764:	927df108 	and	x8, x8, #0xfffffffffffffff8
  403768:	d2800011 	mov	x17, #0x0                   	// #0
					size = sizeof(double);
  40376c:	52800116 	mov	w22, #0x8                   	// #8
					v.d = va_arg(ap, double);
  403770:	f94003d0 	ldr	x16, [x30]
					size = sizeof(double);
  403774:	17ffffdd 	b	4036e8 <cbvprintf_package+0x290>
					v.d = va_arg(ap, double);
  403778:	11004337 	add	w23, w25, #0x10
  40377c:	710002ff 	cmp	w23, #0x0
  403780:	5400008d 	b.le	403790 <cbvprintf_package+0x338>
  403784:	91003fc8 	add	x8, x30, #0xf
  403788:	927df108 	and	x8, x8, #0xfffffffffffffff8
  40378c:	17fffff7 	b	403768 <cbvprintf_package+0x310>
  403790:	aa1e03e8 	mov	x8, x30
  403794:	8b39c19e 	add	x30, x12, w25, sxtw
  403798:	17fffff4 	b	403768 <cbvprintf_package+0x310>
					} else if (fmt[-1] == 'L') {
  40379c:	7101331f 	cmp	w24, #0x4c
  4037a0:	54000121 	b.ne	4037c4 <cbvprintf_package+0x36c>  // b.any
						*(long double *)buf = v.ld;
  4037a4:	9e670200 	fmov	d0, x16
  4037a8:	9eaf0220 	fmov	v0.d[1], x17
  4037ac:	3d800260 	str	q0, [x19]
				buf += size;
  4037b0:	8b190273 	add	x19, x19, x25
				continue;
  4037b4:	aa0803fe 	mov	x30, x8
  4037b8:	2a1703f9 	mov	w25, w23
  4037bc:	2a1603f8 	mov	w24, w22
  4037c0:	17ffff7e 	b	4035b8 <cbvprintf_package+0x160>
						*(double *)buf = v.d;
  4037c4:	f9000270 	str	x16, [x19]
  4037c8:	17fffffa 	b	4037b0 <cbvprintf_package+0x358>
			switch (*fmt) {
  4037cc:	52800008 	mov	w8, #0x0                   	// #0
				parsing = false;
  4037d0:	52800017 	mov	w23, #0x0                   	// #0
  4037d4:	17ffffa3 	b	403660 <cbvprintf_package+0x208>
				is_str_arg = true;
  4037d8:	2a1703e8 	mov	w8, w23
  4037dc:	17fffffd 	b	4037d0 <cbvprintf_package+0x378>
			switch (*fmt) {
  4037e0:	52800008 	mov	w8, #0x0                   	// #0
  4037e4:	17ffffa1 	b	403668 <cbvprintf_package+0x210>
			s = va_arg(ap, char *);
  4037e8:	11002008 	add	w8, w0, #0x8
  4037ec:	7100011f 	cmp	w8, #0x0
  4037f0:	5400008d 	b.le	403800 <cbvprintf_package+0x3a8>
  4037f4:	91003fdb 	add	x27, x30, #0xf
  4037f8:	927df37b 	and	x27, x27, #0xfffffffffffffff8
  4037fc:	17ffffab 	b	4036a8 <cbvprintf_package+0x250>
  403800:	aa1e03fb 	mov	x27, x30
  403804:	8b20c15e 	add	x30, x10, w0, sxtw
  403808:	17ffffa8 	b	4036a8 <cbvprintf_package+0x250>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
  40380c:	71003c7f 	cmp	w3, #0xf
  403810:	54000249 	b.ls	403858 <cbvprintf_package+0x400>  // b.plast
					__ASSERT(false, "str_ptr_pos[] too small");
  403814:	b0000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  403818:	91347e73 	add	x19, x19, #0xd1f
  40381c:	aa1303e2 	mov	x2, x19
  403820:	900000a1 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  403824:	91055821 	add	x1, x1, #0x156
  403828:	52805003 	mov	w3, #0x280                 	// #640
  40382c:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  403830:	91353400 	add	x0, x0, #0xd4d
  403834:	94000662 	bl	4051bc <assert_print>
  403838:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40383c:	9136c000 	add	x0, x0, #0xdb0
  403840:	9400065f 	bl	4051bc <assert_print>
  403844:	aa1303e0 	mov	x0, x19
  403848:	52805001 	mov	w1, #0x280                 	// #640
  40384c:	94000686 	bl	405264 <assert_post_action>
  403850:	52805002 	mov	w2, #0x280                 	// #640
  403854:	17ffff4d 	b	403588 <cbvprintf_package+0x130>
				if (buf0 != NULL) {
  403858:	b4000274 	cbz	x20, 4038a4 <cbvprintf_package+0x44c>
					str_ptr_pos[s_idx] = s_ptr_idx;
  40385c:	2a0303f0 	mov	w16, w3
  403860:	9102a3f1 	add	x17, sp, #0xa8
					str_ptr_arg[s_idx] = arg_idx;
  403864:	9102e3fe 	add	x30, sp, #0xb8
					str_ptr_pos[s_idx] = s_ptr_idx;
  403868:	12001c00 	and	w0, w0, #0xff
  40386c:	38306a20 	strb	w0, [x17, x16]
					str_ptr_arg[s_idx] = arg_idx;
  403870:	38306bc6 	strb	w6, [x30, x16]
					if (is_ro) {
  403874:	7100003f 	cmp	w1, #0x0
  403878:	5400012d 	b.le	40389c <cbvprintf_package+0x444>
						s_ro_cnt++;
  40387c:	110004a5 	add	w5, w5, #0x1
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
  403880:	32196000 	orr	w0, w0, #0xffffff80
  403884:	38306a20 	strb	w0, [x17, x16]
				s_idx++;
  403888:	11000463 	add	w3, w3, #0x1
			buf += sizeof(char *);
  40388c:	91002273 	add	x19, x19, #0x8
			is_str_arg = false;
  403890:	2a0803e0 	mov	w0, w8
  403894:	aa1b03fe 	mov	x30, x27
  403898:	17ffff49 	b	4035bc <cbvprintf_package+0x164>
						s_rw_cnt++;
  40389c:	11000484 	add	w4, w4, #0x1
  4038a0:	17fffffa 	b	403888 <cbvprintf_package+0x430>
				} else if (is_ro) {
  4038a4:	7100003f 	cmp	w1, #0x0
  4038a8:	5400006d 	b.le	4038b4 <cbvprintf_package+0x45c>
					len += 1;
  4038ac:	910006b5 	add	x21, x21, #0x1
  4038b0:	17fffff6 	b	403888 <cbvprintf_package+0x430>
				} else if (rws_pos_en) {
  4038b4:	b94083e0 	ldr	w0, [sp, #128]
					len += 2;
  4038b8:	91000ab5 	add	x21, x21, #0x2
				} else if (rws_pos_en) {
  4038bc:	35fffe60 	cbnz	w0, 403888 <cbvprintf_package+0x430>
					len += strlen(s) + 1 + 1;
  4038c0:	aa1a03e0 	mov	x0, x26
  4038c4:	a906b3ea 	stp	x10, x12, [sp, #104]
  4038c8:	f9003fe9 	str	x9, [sp, #120]
  4038cc:	291093e3 	stp	w3, w4, [sp, #132]
  4038d0:	29119be5 	stp	w5, w6, [sp, #140]
  4038d4:	2912a3e1 	stp	w1, w8, [sp, #148]
  4038d8:	b9009fe2 	str	w2, [sp, #156]
  4038dc:	97fff689 	bl	401300 <strlen@plt>
  4038e0:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  4038e4:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  4038e8:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  4038ec:	8b0002b5 	add	x21, x21, x0
  4038f0:	295093e3 	ldp	w3, w4, [sp, #132]
  4038f4:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4038f8:	29519be5 	ldp	w5, w6, [sp, #140]
  4038fc:	911e700b 	add	x11, x0, #0x79c
  403900:	2952a3e1 	ldp	w1, w8, [sp, #148]
  403904:	f2e06012 	movk	x18, #0x300, lsl #48
  403908:	b9409fe2 	ldr	w2, [sp, #156]
  40390c:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  403910:	f2c0004e 	movk	x14, #0x2, lsl #32
  403914:	d280002d 	mov	x13, #0x1                   	// #1
  403918:	a946b3ea 	ldp	x10, x12, [sp, #104]
  40391c:	f9403fe9 	ldr	x9, [sp, #120]
  403920:	17ffffda 	b	403888 <cbvprintf_package+0x430>
		} else if (size == sizeof(int)) {
  403924:	710012df 	cmp	w22, #0x4
  403928:	540002a1 	b.ne	40397c <cbvprintf_package+0x524>  // b.any
			int v = va_arg(ap, int);
  40392c:	37f80160 	tbnz	w0, #31, 403958 <cbvprintf_package+0x500>
  403930:	91002fc8 	add	x8, x30, #0xb
  403934:	2a0003f0 	mov	w16, w0
  403938:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  40393c:	b4000074 	cbz	x20, 403948 <cbvprintf_package+0x4f0>
			int v = va_arg(ap, int);
  403940:	b94003c0 	ldr	w0, [x30]
				*(int *)buf = v;
  403944:	b9000260 	str	w0, [x19]
			buf += sizeof(int);
  403948:	91001273 	add	x19, x19, #0x4
  40394c:	2a1003e0 	mov	w0, w16
  403950:	aa0803fe 	mov	x30, x8
  403954:	17ffff1a 	b	4035bc <cbvprintf_package+0x164>
			int v = va_arg(ap, int);
  403958:	11002010 	add	w16, w0, #0x8
  40395c:	7100021f 	cmp	w16, #0x0
  403960:	5400008d 	b.le	403970 <cbvprintf_package+0x518>
  403964:	91002fc8 	add	x8, x30, #0xb
  403968:	927df108 	and	x8, x8, #0xfffffffffffffff8
  40396c:	17fffff4 	b	40393c <cbvprintf_package+0x4e4>
  403970:	aa1e03e8 	mov	x8, x30
  403974:	8b20c15e 	add	x30, x10, w0, sxtw
  403978:	17fffff1 	b	40393c <cbvprintf_package+0x4e4>
		} else if (size == sizeof(long)) {
  40397c:	710022df 	cmp	w22, #0x8
  403980:	54000261 	b.ne	4039cc <cbvprintf_package+0x574>  // b.any
			long v = va_arg(ap, long);
  403984:	37f80120 	tbnz	w0, #31, 4039a8 <cbvprintf_package+0x550>
  403988:	91003fc8 	add	x8, x30, #0xf
  40398c:	2a0003f0 	mov	w16, w0
  403990:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  403994:	b4000074 	cbz	x20, 4039a0 <cbvprintf_package+0x548>
			long v = va_arg(ap, long);
  403998:	f94003c0 	ldr	x0, [x30]
				*(long *)buf = v;
  40399c:	f9000260 	str	x0, [x19]
			buf += sizeof(long);
  4039a0:	91002273 	add	x19, x19, #0x8
  4039a4:	17ffffea 	b	40394c <cbvprintf_package+0x4f4>
			long v = va_arg(ap, long);
  4039a8:	11002010 	add	w16, w0, #0x8
  4039ac:	7100021f 	cmp	w16, #0x0
  4039b0:	5400008d 	b.le	4039c0 <cbvprintf_package+0x568>
  4039b4:	91003fc8 	add	x8, x30, #0xf
  4039b8:	927df108 	and	x8, x8, #0xfffffffffffffff8
  4039bc:	17fffff6 	b	403994 <cbvprintf_package+0x53c>
  4039c0:	aa1e03e8 	mov	x8, x30
  4039c4:	8b20c15e 	add	x30, x10, w0, sxtw
  4039c8:	17fffff3 	b	403994 <cbvprintf_package+0x53c>
			__ASSERT(false, "unexpected size %u", size);
  4039cc:	b0000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  4039d0:	91347e73 	add	x19, x19, #0xd1f
  4039d4:	aa1303e2 	mov	x2, x19
  4039d8:	528058a3 	mov	w3, #0x2c5                 	// #709
  4039dc:	900000a1 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  4039e0:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4039e4:	91055821 	add	x1, x1, #0x156
  4039e8:	91353400 	add	x0, x0, #0xd4d
  4039ec:	940005f4 	bl	4051bc <assert_print>
  4039f0:	2a1603e1 	mov	w1, w22
  4039f4:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4039f8:	91372800 	add	x0, x0, #0xdca
  4039fc:	940005f0 	bl	4051bc <assert_print>
  403a00:	aa1303e0 	mov	x0, x19
  403a04:	528058a1 	mov	w1, #0x2c5                 	// #709
  403a08:	94000617 	bl	405264 <assert_post_action>
  403a0c:	528058a2 	mov	w2, #0x2c5                 	// #709
  403a10:	17fffede 	b	403588 <cbvprintf_package+0x130>
	if (BUF_OFFSET / sizeof(int) > 255) {
  403a14:	cb140261 	sub	x1, x19, x20
  403a18:	f10ffc3f 	cmp	x1, #0x3ff
  403a1c:	54000249 	b.ls	403a64 <cbvprintf_package+0x60c>  // b.plast
		__ASSERT(false, "too many format args");
  403a20:	b0000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  403a24:	91347e73 	add	x19, x19, #0xd1f
  403a28:	aa1303e2 	mov	x2, x19
  403a2c:	900000a1 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  403a30:	91055821 	add	x1, x1, #0x156
  403a34:	52805a23 	mov	w3, #0x2d1                 	// #721
  403a38:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  403a3c:	91353400 	add	x0, x0, #0xd4d
  403a40:	940005df 	bl	4051bc <assert_print>
  403a44:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  403a48:	91377c00 	add	x0, x0, #0xddf
  403a4c:	940005dc 	bl	4051bc <assert_print>
  403a50:	aa1303e0 	mov	x0, x19
  403a54:	52805a21 	mov	w1, #0x2d1                 	// #721
  403a58:	94000603 	bl	405264 <assert_post_action>
  403a5c:	52805a22 	mov	w2, #0x2d1                 	// #721
  403a60:	17fffeca 	b	403588 <cbvprintf_package+0x130>
	if (buf0 == NULL) {
  403a64:	b5000094 	cbnz	x20, 403a74 <cbvprintf_package+0x61c>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
  403a68:	510022a0 	sub	w0, w21, #0x8
  403a6c:	0b010000 	add	w0, w0, w1
  403a70:	17ffff29 	b	403714 <cbvprintf_package+0x2bc>
	if (rws_pos_en) {
  403a74:	b94083e0 	ldr	w0, [sp, #128]
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  403a78:	d342fc21 	lsr	x1, x1, #2
	*(char **)buf0 = NULL;
  403a7c:	f900029f 	str	xzr, [x20]
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  403a80:	12001c84 	and	w4, w4, #0xff
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  403a84:	39000281 	strb	w1, [x20]
	if (rws_pos_en) {
  403a88:	34000120 	cbz	w0, 403aac <cbvprintf_package+0x654>
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  403a8c:	39000e84 	strb	w4, [x20, #3]
	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
  403a90:	39000a85 	strb	w5, [x20, #2]
	if (s_ro_cnt) {
  403a94:	9102a3f8 	add	x24, sp, #0xa8
  403a98:	35000265 	cbnz	w5, 403ae4 <cbvprintf_package+0x68c>
		if (BUF_OFFSET + 1 + size > len) {
  403a9c:	d2800036 	mov	x22, #0x1                   	// #1
			*buf++ = str_ptr_arg[i];
  403aa0:	9102e3f7 	add	x23, sp, #0xb8
		if (BUF_OFFSET + 1 + size > len) {
  403aa4:	cb1402d6 	sub	x22, x22, x20
  403aa8:	1400002d 	b	403b5c <cbvprintf_package+0x704>
		pkg_hdr->desc.str_cnt = s_rw_cnt;
  403aac:	39000684 	strb	w4, [x20, #1]
		pkg_hdr->desc.rw_str_cnt = 0;
  403ab0:	17fffff8 	b	403a90 <cbvprintf_package+0x638>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
  403ab4:	38e16b04 	ldrsb	w4, [x24, x1]
  403ab8:	38786820 	ldrb	w0, [x1, x24]
  403abc:	36f800c4 	tbz	w4, #31, 403ad4 <cbvprintf_package+0x67c>
			if (BUF_OFFSET + 1 > len) {
  403ac0:	8b020264 	add	x4, x19, x2
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
  403ac4:	12001800 	and	w0, w0, #0x7f
			if (BUF_OFFSET + 1 > len) {
  403ac8:	eb15009f 	cmp	x4, x21
  403acc:	54ffe228 	b.hi	403710 <cbvprintf_package+0x2b8>  // b.pmore
			*buf++ = pos;
  403ad0:	38001660 	strb	w0, [x19], #1
		for (i = 0; i < s_idx; i++) {
  403ad4:	91000421 	add	x1, x1, #0x1
  403ad8:	6b01007f 	cmp	w3, w1
  403adc:	54fffec8 	b.hi	403ab4 <cbvprintf_package+0x65c>  // b.pmore
  403ae0:	17ffffef 	b	403a9c <cbvprintf_package+0x644>
			if (BUF_OFFSET + 1 > len) {
  403ae4:	d2800022 	mov	x2, #0x1                   	// #1
  403ae8:	d2800001 	mov	x1, #0x0                   	// #0
  403aec:	cb140042 	sub	x2, x2, x20
  403af0:	17fffffa 	b	403ad8 <cbvprintf_package+0x680>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
  403af4:	34000065 	cbz	w5, 403b00 <cbvprintf_package+0x6a8>
  403af8:	39c00300 	ldrsb	w0, [x24]
  403afc:	37f802c0 	tbnz	w0, #31, 403b54 <cbvprintf_package+0x6fc>
		if (rws_pos_en) {
  403b00:	b94083e0 	ldr	w0, [sp, #128]
  403b04:	34000340 	cbz	w0, 403b6c <cbvprintf_package+0x714>
			*buf++ = str_ptr_arg[i];
  403b08:	38776b80 	ldrb	w0, [x28, x23]
  403b0c:	38001660 	strb	w0, [x19], #1
			size = 0;
  403b10:	52800000 	mov	w0, #0x0                   	// #0
		if (BUF_OFFSET + 1 + size > len) {
  403b14:	2a0003f9 	mov	w25, w0
  403b18:	8b204260 	add	x0, x19, w0, uxtw
  403b1c:	8b160000 	add	x0, x0, x22
  403b20:	b90063e3 	str	w3, [sp, #96]
  403b24:	b9006be5 	str	w5, [sp, #104]
  403b28:	eb15001f 	cmp	x0, x21
  403b2c:	54ffdf28 	b.hi	403710 <cbvprintf_package+0x2b8>  // b.pmore
		*buf++ = str_ptr_pos[i];
  403b30:	39400300 	ldrb	w0, [x24]
  403b34:	aa1903e2 	mov	x2, x25
  403b38:	38001660 	strb	w0, [x19], #1
  403b3c:	aa1a03e1 	mov	x1, x26
  403b40:	aa1303e0 	mov	x0, x19
  403b44:	97fff5df 	bl	4012c0 <memcpy@plt>
		buf += size;
  403b48:	b94063e3 	ldr	w3, [sp, #96]
  403b4c:	8b190273 	add	x19, x19, x25
  403b50:	b9406be5 	ldr	w5, [sp, #104]
	for (i = 0; i < s_idx; i++) {
  403b54:	9100079c 	add	x28, x28, #0x1
  403b58:	91000718 	add	x24, x24, #0x1
  403b5c:	6b1c007f 	cmp	w3, w28
  403b60:	54fffca8 	b.hi	403af4 <cbvprintf_package+0x69c>  // b.pmore
	return BUF_OFFSET;
  403b64:	4b140260 	sub	w0, w19, w20
  403b68:	17fffeeb 	b	403714 <cbvprintf_package+0x2bc>
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
  403b6c:	39400300 	ldrb	w0, [x24]
  403b70:	b90063e3 	str	w3, [sp, #96]
  403b74:	b9006be5 	str	w5, [sp, #104]
  403b78:	d37ef400 	lsl	x0, x0, #2
  403b7c:	f8606a9a 	ldr	x26, [x20, x0]
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
  403b80:	f8206a9f 	str	xzr, [x20, x0]
			size = strlen(s) + 1;
  403b84:	aa1a03e0 	mov	x0, x26
  403b88:	97fff5de 	bl	401300 <strlen@plt>
  403b8c:	b94063e3 	ldr	w3, [sp, #96]
  403b90:	11000400 	add	w0, w0, #0x1
  403b94:	b9406be5 	ldr	w5, [sp, #104]
  403b98:	17ffffdf 	b	403b14 <cbvprintf_package+0x6bc>
		return -EFAULT;
  403b9c:	128001a0 	mov	w0, #0xfffffff2            	// #-14
  403ba0:	17fffedd 	b	403714 <cbvprintf_package+0x2bc>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
  403ba4:	f1003ebf 	cmp	x21, #0xf
  403ba8:	54ffc948 	b.hi	4034d0 <cbvprintf_package+0x78>  // b.pmore
  403bac:	17fffed9 	b	403710 <cbvprintf_package+0x2b8>
}
  403bb0:	a94153f3 	ldp	x19, x20, [sp, #16]
  403bb4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403bb8:	a94363f7 	ldp	x23, x24, [sp, #48]
  403bbc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  403bc0:	a94573fb 	ldp	x27, x28, [sp, #80]
  403bc4:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  403bc8:	d65f03c0 	ret

0000000000403bcc <cbpprintf_external>:
	uint8_t *buf = packaged;
	struct cbprintf_package_hdr_ext *hdr = packaged;
	char *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, rws_nbr, s_idx;

	if (buf == NULL) {
  403bcc:	b40005e3 	cbz	x3, 403c88 <cbpprintf_external+0xbc>
{
  403bd0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  403bd4:	910003fd 	mov	x29, sp
  403bd8:	a90153f3 	stp	x19, x20, [sp, #16]
  403bdc:	aa0303f4 	mov	x20, x3
  403be0:	a9025bf5 	stp	x21, x22, [sp, #32]
  403be4:	aa0003f6 	mov	x22, x0
  403be8:	aa0103f5 	mov	x21, x1
  403bec:	a90363f7 	stp	x23, x24, [sp, #48]
  403bf0:	aa0203f7 	mov	x23, x2
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
  403bf4:	52800018 	mov	w24, #0x0                   	// #0
{
  403bf8:	f90023f9 	str	x25, [sp, #64]
	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
  403bfc:	39400c60 	ldrb	w0, [x3, #3]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  403c00:	39400073 	ldrb	w19, [x3]
	s_nbr     = hdr->hdr.desc.str_cnt;
  403c04:	39400479 	ldrb	w25, [x3, #1]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  403c08:	d37f1c00 	ubfiz	x0, x0, #1, #8
  403c0c:	8b334813 	add	x19, x0, w19, uxtw #2
  403c10:	39400860 	ldrb	w0, [x3, #2]
  403c14:	8b000273 	add	x19, x19, x0
  403c18:	8b130073 	add	x19, x3, x19
	for (i = 0; i < s_nbr; i++) {
  403c1c:	6b19031f 	cmp	w24, w25
  403c20:	54000223 	b.cc	403c64 <cbpprintf_external+0x98>  // b.lo, b.ul, b.last
		/* move to next string */
		s += strlen(s) + 1;
	}

	/* Skip past the header */
	buf += sizeof(*hdr);
  403c24:	91004280 	add	x0, x20, #0x10
	u.__ap.__gr_top = NULL;
  403c28:	a9077fe0 	stp	x0, xzr, [sp, #112]
	return formatter(out, ctx, fmt, u.ap);
  403c2c:	910143e3 	add	x3, sp, #0x50
	u.__ap.__gr_offs = 0;
  403c30:	a9087fff 	stp	xzr, xzr, [sp, #128]
	return formatter(out, ctx, fmt, u.ap);
  403c34:	aa1703e1 	mov	x1, x23
  403c38:	aa1603e0 	mov	x0, x22
  403c3c:	ad4387e0 	ldp	q0, q1, [sp, #112]
  403c40:	ad000460 	stp	q0, q1, [x3]
  403c44:	f9400682 	ldr	x2, [x20, #8]
  403c48:	d63f02a0 	blr	x21

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
}
  403c4c:	a94153f3 	ldp	x19, x20, [sp, #16]
  403c50:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403c54:	a94363f7 	ldp	x23, x24, [sp, #48]
  403c58:	f94023f9 	ldr	x25, [sp, #64]
  403c5c:	a8c97bfd 	ldp	x29, x30, [sp], #144
  403c60:	d65f03c0 	ret
		ps = (char **)(buf + s_idx * sizeof(int));
  403c64:	38401660 	ldrb	w0, [x19], #1
	for (i = 0; i < s_nbr; i++) {
  403c68:	11000718 	add	w24, w24, #0x1
		ps = (char **)(buf + s_idx * sizeof(int));
  403c6c:	d37ef400 	lsl	x0, x0, #2
		*ps = s;
  403c70:	f8206a93 	str	x19, [x20, x0]
		s += strlen(s) + 1;
  403c74:	aa1303e0 	mov	x0, x19
  403c78:	97fff5a2 	bl	401300 <strlen@plt>
  403c7c:	91000400 	add	x0, x0, #0x1
  403c80:	8b000273 	add	x19, x19, x0
	for (i = 0; i < s_nbr; i++) {
  403c84:	17ffffe6 	b	403c1c <cbpprintf_external+0x50>
		return -EINVAL;
  403c88:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  403c8c:	d65f03c0 	ret

0000000000403c90 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  403c90:	52800000 	mov	w0, #0x0                   	// #0
  403c94:	d65f03c0 	ret

0000000000403c98 <__printk_hook_install>:
 * routine that outputs one ASCII character at a time.
 * @param fn putc routine to install
 */
void __printk_hook_install(int (*fn)(int c))
{
	_char_out = fn;
  403c98:	b0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  403c9c:	f947d021 	ldr	x1, [x1, #4000]
  403ca0:	f9000020 	str	x0, [x1]
}
  403ca4:	d65f03c0 	ret

0000000000403ca8 <vprintk>:
	(void) ctx_p;
	return _char_out(c);
}

void vprintk(const char *fmt, va_list ap)
{
  403ca8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  403cac:	910003fd 	mov	x29, sp
	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		z_log_vprintk(fmt, ap);
  403cb0:	ad400420 	ldp	q0, q1, [x1]
  403cb4:	910043e2 	add	x2, sp, #0x10
  403cb8:	aa0203e1 	mov	x1, x2
  403cbc:	ad000440 	stp	q0, q1, [x2]
  403cc0:	94000606 	bl	4054d8 <z_log_vprintk>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
  403cc4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  403cc8:	d65f03c0 	ret

0000000000403ccc <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
  403ccc:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  403cd0:	910003fd 	mov	x29, sp
  403cd4:	a90e8be1 	stp	x1, x2, [sp, #232]
  403cd8:	b0000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  403cdc:	f9478421 	ldr	x1, [x1, #3848]
  403ce0:	3d801be0 	str	q0, [sp, #96]
  403ce4:	3d801fe1 	str	q1, [sp, #112]
  403ce8:	3d8023e2 	str	q2, [sp, #128]
  403cec:	3d8027e3 	str	q3, [sp, #144]
  403cf0:	3d802be4 	str	q4, [sp, #160]
  403cf4:	3d802fe5 	str	q5, [sp, #176]
  403cf8:	3d8033e6 	str	q6, [sp, #192]
  403cfc:	3d8037e7 	str	q7, [sp, #208]
  403d00:	a90f93e3 	stp	x3, x4, [sp, #248]
  403d04:	a9109be5 	stp	x5, x6, [sp, #264]
  403d08:	f9008fe7 	str	x7, [sp, #280]
  403d0c:	f9400022 	ldr	x2, [x1]
  403d10:	f9002fe2 	str	x2, [sp, #88]
  403d14:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  403d18:	910483e1 	add	x1, sp, #0x120
  403d1c:	a90387e1 	stp	x1, x1, [sp, #56]
  403d20:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  403d24:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  403d28:	f90027e1 	str	x1, [sp, #72]
  403d2c:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  403d30:	b90053e1 	str	w1, [sp, #80]
  403d34:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  403d38:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  403d3c:	910043e1 	add	x1, sp, #0x10
  403d40:	ad400440 	ldp	q0, q1, [x2]
  403d44:	ad000420 	stp	q0, q1, [x1]
  403d48:	97ffffd8 	bl	403ca8 <vprintk>

	va_end(ap);
}
  403d4c:	b0000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  403d50:	f9478400 	ldr	x0, [x0, #3848]
  403d54:	f9402fe2 	ldr	x2, [sp, #88]
  403d58:	f9400001 	ldr	x1, [x0]
  403d5c:	eb010042 	subs	x2, x2, x1
  403d60:	d2800001 	mov	x1, #0x0                   	// #0
  403d64:	54000040 	b.eq	403d6c <printk+0xa0>  // b.none
  403d68:	97fff5d2 	bl	4014b0 <__stack_chk_fail@plt>
  403d6c:	a8d27bfd 	ldp	x29, x30, [sp], #288
  403d70:	d65f03c0 	ret

0000000000403d74 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  403d74:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  403d78:	aa0003e4 	mov	x4, x0
  403d7c:	aa0103e0 	mov	x0, x1
  403d80:	910003fd 	mov	x29, sp
  403d84:	aa0203e1 	mov	x1, x2
  403d88:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
  403d8c:	d63f0080 	blr	x4
	return z_impl_z_current_get();
  403d90:	94003cf3 	bl	41315c <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
  403d94:	94000abd 	bl	406888 <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  403d98:	b0000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  403d9c:	b0000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  403da0:	91381c21 	add	x1, x1, #0xe07
  403da4:	91362c00 	add	x0, x0, #0xd8b
  403da8:	528005a2 	mov	w2, #0x2d                  	// #45
  403dac:	94000f20 	bl	407a2c <posix_print_error_and_exit>

0000000000403db0 <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
  403db0:	d2800082 	mov	x2, #0x4                   	// #4
  403db4:	8b214c41 	add	x1, x2, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  403db8:	b8616800 	ldr	w0, [x0, x1]
}
  403dbc:	53017c00 	lsr	w0, w0, #1
  403dc0:	d65f03c0 	ret

0000000000403dc4 <free_list_remove_bidx>:
		return ((uint32_t *)cmem)[f];
  403dc4:	8b214c04 	add	x4, x0, w1, uxtw #3
  403dc8:	b9400c83 	ldr	w3, [x4, #12]

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & BIT(bidx));

	if (next_free_chunk(h, c) == c) {
  403dcc:	6b03003f 	cmp	w1, w3
  403dd0:	93407c41 	sxtw	x1, w2
  403dd4:	54000121 	b.ne	403df8 <free_list_remove_bidx+0x34>  // b.any
		/* this is the last chunk */
		h->avail_buckets &= ~BIT(bidx);
  403dd8:	d2800023 	mov	x3, #0x1                   	// #1
		b->next = 0;
  403ddc:	91001021 	add	x1, x1, #0x4
		h->avail_buckets &= ~BIT(bidx);
  403de0:	9ac22062 	lsl	x2, x3, x2
  403de4:	b9400c03 	ldr	w3, [x0, #12]
  403de8:	0a220062 	bic	w2, w3, w2
  403dec:	b9000c02 	str	w2, [x0, #12]
		b->next = 0;
  403df0:	b821781f 	str	wzr, [x0, x1, lsl #2]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes -= chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
  403df4:	d65f03c0 	ret
		b->next = second;
  403df8:	91001021 	add	x1, x1, #0x4
  403dfc:	b9400882 	ldr	w2, [x4, #8]
  403e00:	b8217803 	str	w3, [x0, x1, lsl #2]
		((uint32_t *)cmem)[f] = val;
  403e04:	d2800181 	mov	x1, #0xc                   	// #12
  403e08:	8b224c21 	add	x1, x1, w2, uxtw #3
  403e0c:	b8216803 	str	w3, [x0, x1]
  403e10:	d37d7c63 	ubfiz	x3, x3, #3, #32
  403e14:	91002063 	add	x3, x3, #0x8
  403e18:	b8236802 	str	w2, [x0, x3]
}
  403e1c:	17fffff6 	b	403df4 <free_list_remove_bidx+0x30>

0000000000403e20 <alloc_chunk>:
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  403e20:	51000424 	sub	w4, w1, #0x1
	return 31 - __builtin_clz(usable_sz);
  403e24:	528003e6 	mov	w6, #0x1f                  	// #31
  403e28:	5ac01084 	clz	w4, w4

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
  403e2c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  403e30:	4b0400c6 	sub	w6, w6, w4
  403e34:	910003fd 	mov	x29, sp
  403e38:	8b26c808 	add	x8, x0, w6, sxtw #2
  403e3c:	aa0003e3 	mov	x3, x0
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
  403e40:	b940110a 	ldr	w10, [x8, #16]
  403e44:	3400030a 	cbz	w10, 403ea4 <alloc_chunk+0x84>
  403e48:	2a0103e7 	mov	w7, w1
  403e4c:	52800069 	mov	w9, #0x3                   	// #3
		return ((uint32_t *)cmem)[f];
  403e50:	d280018b 	mov	x11, #0xc                   	// #12
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
  403e54:	b9401105 	ldr	w5, [x8, #16]
			if (chunk_size(h, c) >= sz) {
  403e58:	aa0303e0 	mov	x0, x3
  403e5c:	2a0503e1 	mov	w1, w5
  403e60:	97ffffd4 	bl	403db0 <chunk_size>
  403e64:	6b07001f 	cmp	w0, w7
  403e68:	54000103 	b.cc	403e88 <alloc_chunk+0x68>  // b.lo, b.ul, b.last
				free_list_remove_bidx(h, c, bi);
  403e6c:	2a0603e2 	mov	w2, w6

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
  403e70:	2a0503e1 	mov	w1, w5
  403e74:	aa0303e0 	mov	x0, x3
  403e78:	97ffffd3 	bl	403dc4 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
  403e7c:	2a0503e0 	mov	w0, w5
  403e80:	a8c17bfd 	ldp	x29, x30, [sp], #16
  403e84:	d65f03c0 	ret
  403e88:	8b254d65 	add	x5, x11, w5, uxtw #3
		} while (--i && b->next != first);
  403e8c:	71000529 	subs	w9, w9, #0x1
  403e90:	b8656860 	ldr	w0, [x3, x5]
			b->next = next_free_chunk(h, c);
  403e94:	b9001100 	str	w0, [x8, #16]
		} while (--i && b->next != first);
  403e98:	54000060 	b.eq	403ea4 <alloc_chunk+0x84>  // b.none
  403e9c:	6b00015f 	cmp	w10, w0
  403ea0:	54fffda1 	b.ne	403e54 <alloc_chunk+0x34>  // b.any
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
  403ea4:	52800400 	mov	w0, #0x20                  	// #32
  403ea8:	4b040000 	sub	w0, w0, w4
  403eac:	d2800025 	mov	x5, #0x1                   	// #1
  403eb0:	9ac020a5 	lsl	x5, x5, x0
  403eb4:	b9400c60 	ldr	w0, [x3, #12]
  403eb8:	4b0503e5 	neg	w5, w5
	if (bmask != 0U) {
  403ebc:	6a0000a5 	ands	w5, w5, w0
  403ec0:	54fffde0 	b.eq	403e7c <alloc_chunk+0x5c>  // b.none
		int minbucket = __builtin_ctz(bmask);
  403ec4:	5ac000a2 	rbit	w2, w5
  403ec8:	5ac01042 	clz	w2, w2
		chunkid_t c = h->buckets[minbucket].next;
  403ecc:	8b22c860 	add	x0, x3, w2, sxtw #2
  403ed0:	b9401005 	ldr	w5, [x0, #16]
  403ed4:	17ffffe7 	b	403e70 <alloc_chunk+0x50>

0000000000403ed8 <free_list_add>:
{
  403ed8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  403edc:	aa0003e3 	mov	x3, x0
  403ee0:	2a0103e4 	mov	w4, w1
  403ee4:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  403ee8:	97ffffb2 	bl	403db0 <chunk_size>
	if (!solo_free_header(h, c)) {
  403eec:	7100041f 	cmp	w0, #0x1
  403ef0:	54000260 	b.eq	403f3c <free_list_add+0x64>  // b.none
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  403ef4:	51000400 	sub	w0, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  403ef8:	528003e1 	mov	w1, #0x1f                  	// #31
  403efc:	5ac01000 	clz	w0, w0
  403f00:	4b000021 	sub	w1, w1, w0
	if (b->next == 0U) {
  403f04:	d37d7c80 	ubfiz	x0, x4, #3, #32
  403f08:	91002006 	add	x6, x0, #0x8
		((uint32_t *)cmem)[f] = val;
  403f0c:	91003000 	add	x0, x0, #0xc
  403f10:	8b21c867 	add	x7, x3, w1, sxtw #2
  403f14:	b94010e5 	ldr	w5, [x7, #16]
  403f18:	35000165 	cbnz	w5, 403f44 <free_list_add+0x6c>
		h->avail_buckets |= BIT(bidx);
  403f1c:	d2800022 	mov	x2, #0x1                   	// #1
  403f20:	9ac12042 	lsl	x2, x2, x1
  403f24:	b9400c61 	ldr	w1, [x3, #12]
  403f28:	2a020021 	orr	w1, w1, w2
  403f2c:	b9000c61 	str	w1, [x3, #12]
		b->next = c;
  403f30:	b90010e4 	str	w4, [x7, #16]
  403f34:	b8266864 	str	w4, [x3, x6]
  403f38:	b8206864 	str	w4, [x3, x0]
}
  403f3c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  403f40:	d65f03c0 	ret
		return ((uint32_t *)cmem)[f];
  403f44:	d37d7ca1 	ubfiz	x1, x5, #3, #32
  403f48:	91002021 	add	x1, x1, #0x8
  403f4c:	b8616862 	ldr	w2, [x3, x1]
		((uint32_t *)cmem)[f] = val;
  403f50:	b8266862 	str	w2, [x3, x6]
  403f54:	b8206865 	str	w5, [x3, x0]
  403f58:	d2800180 	mov	x0, #0xc                   	// #12
  403f5c:	8b224c02 	add	x2, x0, w2, uxtw #3
  403f60:	b8226864 	str	w4, [x3, x2]
  403f64:	b8216864 	str	w4, [x3, x1]
  403f68:	17fffff5 	b	403f3c <free_list_add+0x64>

0000000000403f6c <split_chunks>:
{
  403f6c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  403f70:	2a0203e3 	mov	w3, w2
  403f74:	2a0103e5 	mov	w5, w1
  403f78:	aa0003e4 	mov	x4, x0
  403f7c:	910003fd 	mov	x29, sp
	chunksz_t rsz = sz0 - lsz;
  403f80:	4b0300a6 	sub	w6, w5, w3
	chunksz_t sz0 = chunk_size(h, lc);
  403f84:	97ffff8b 	bl	403db0 <chunk_size>
	chunksz_t rsz = sz0 - lsz;
  403f88:	0b0000c6 	add	w6, w6, w0
  403f8c:	d2800080 	mov	x0, #0x4                   	// #4
	chunksz_t lsz = rc - lc;
  403f90:	4b050061 	sub	w1, w3, w5
  403f94:	8b254c05 	add	x5, x0, w5, uxtw #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  403f98:	531f7820 	lsl	w0, w1, #1
		((uint32_t *)cmem)[f] = val;
  403f9c:	b8256880 	str	w0, [x4, x5]
	void *cmem = &buf[c];
  403fa0:	d37d7c60 	ubfiz	x0, x3, #3, #32
		((uint32_t *)cmem)[f] = val;
  403fa4:	8b000082 	add	x2, x4, x0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  403fa8:	531f78c5 	lsl	w5, w6, #1
		((uint32_t *)cmem)[f] = val;
  403fac:	b9000445 	str	w5, [x2, #4]
  403fb0:	b8206881 	str	w1, [x4, x0]
	return c + chunk_size(h, c);
  403fb4:	2a0303e1 	mov	w1, w3
  403fb8:	aa0403e0 	mov	x0, x4
  403fbc:	97ffff7d 	bl	403db0 <chunk_size>
	void *cmem = &buf[c];
  403fc0:	0b000063 	add	w3, w3, w0
  403fc4:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  403fc8:	b8236886 	str	w6, [x4, x3]
}
  403fcc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  403fd0:	d65f03c0 	ret

0000000000403fd4 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
	struct z_heap *h = heap->heap;
  403fd4:	f940000d 	ldr	x13, [x0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
  403fd8:	b50000c1 	cbnz	x1, 403ff0 <sys_heap_alloc+0x1c>
		return NULL;
  403fdc:	d2800000 	mov	x0, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  403fe0:	d65f03c0 	ret
		return NULL;
  403fe4:	d2800000 	mov	x0, #0x0                   	// #0
}
  403fe8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  403fec:	d65f03c0 	ret
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  403ff0:	b94009a0 	ldr	w0, [x13, #8]
	if (bytes == 0U || size_too_big(h, bytes)) {
  403ff4:	eb410c1f 	cmp	x0, x1, lsr #3
  403ff8:	54ffff29 	b.ls	403fdc <sys_heap_alloc+0x8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  403ffc:	91003c21 	add	x1, x1, #0xf
{
  404000:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	chunkid_t c = alloc_chunk(h, chunk_sz);
  404004:	aa0d03e0 	mov	x0, x13
  404008:	d343fc2c 	lsr	x12, x1, #3
{
  40400c:	910003fd 	mov	x29, sp
	chunkid_t c = alloc_chunk(h, chunk_sz);
  404010:	2a0c03e1 	mov	w1, w12
  404014:	97ffff83 	bl	403e20 <alloc_chunk>
  404018:	2a0003e8 	mov	w8, w0
	if (c == 0U) {
  40401c:	34fffe40 	cbz	w0, 403fe4 <sys_heap_alloc+0x10>
	if (chunk_size(h, c) > chunk_sz) {
  404020:	2a0003e1 	mov	w1, w0
  404024:	aa0d03e0 	mov	x0, x13
  404028:	97ffff62 	bl	403db0 <chunk_size>
  40402c:	6b0c001f 	cmp	w0, w12
  404030:	54000129 	b.ls	404054 <sys_heap_alloc+0x80>  // b.plast
		split_chunks(h, c, c + chunk_sz);
  404034:	0b0c010c 	add	w12, w8, w12
  404038:	2a0803e1 	mov	w1, w8
  40403c:	2a0c03e2 	mov	w2, w12
  404040:	aa0d03e0 	mov	x0, x13
  404044:	97ffffca 	bl	403f6c <split_chunks>
		free_list_add(h, c + chunk_sz);
  404048:	2a0c03e1 	mov	w1, w12
  40404c:	aa0d03e0 	mov	x0, x13
  404050:	97ffffa2 	bl	403ed8 <free_list_add>
	void *cmem = &buf[c];
  404054:	d37d7d08 	ubfiz	x8, x8, #3, #32
  404058:	8b0801a1 	add	x1, x13, x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  40405c:	91002108 	add	x8, x8, #0x8
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  404060:	b9400420 	ldr	w0, [x1, #4]
  404064:	32000000 	orr	w0, w0, #0x1
  404068:	b9000420 	str	w0, [x1, #4]
  40406c:	8b0801a0 	add	x0, x13, x8
	return mem;
  404070:	17ffffde 	b	403fe8 <sys_heap_alloc+0x14>

0000000000404074 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
  404074:	aa0203ec 	mov	x12, x2
  404078:	91003c43 	add	x3, x2, #0xf
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
  40407c:	cb0103e2 	neg	x2, x1
  404080:	8a01004e 	and	x14, x2, x1
	struct z_heap *h = heap->heap;
  404084:	f940000d 	ldr	x13, [x0]
	if (align != rew) {
  404088:	ea22003f 	bics	xzr, x1, x2
  40408c:	54000400 	b.eq	40410c <sys_heap_aligned_alloc+0x98>  // b.none
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
  404090:	f10021df 	cmp	x14, #0x8
  404094:	aa0e03ef 	mov	x15, x14
  404098:	d2800100 	mov	x0, #0x8                   	// #8
  40409c:	9a8091c0 	csel	x0, x14, x0, ls  // ls = plast
		align -= rew;
  4040a0:	cb0e002e 	sub	x14, x1, x14
{
  4040a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  4040a8:	d10005d2 	sub	x18, x14, #0x1
{
  4040ac:	910003fd 	mov	x29, sp
  4040b0:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  4040b4:	ea0e025f 	tst	x18, x14
  4040b8:	54000380 	b.eq	404128 <sys_heap_aligned_alloc+0xb4>  // b.none
  4040bc:	90000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  4040c0:	9138c273 	add	x19, x19, #0xe30
  4040c4:	aa1303e2 	mov	x2, x19
  4040c8:	90000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  4040cc:	913bf021 	add	x1, x1, #0xefc
  4040d0:	52802883 	mov	w3, #0x144                 	// #324
  4040d4:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4040d8:	91353400 	add	x0, x0, #0xd4d
  4040dc:	94000438 	bl	4051bc <assert_print>
  4040e0:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4040e4:	913c5c00 	add	x0, x0, #0xf17
  4040e8:	94000435 	bl	4051bc <assert_print>
  4040ec:	aa1303e0 	mov	x0, x19
  4040f0:	52802881 	mov	w1, #0x144                 	// #324
  4040f4:	9400045c 	bl	405264 <assert_post_action>
  4040f8:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4040fc:	aa1303e1 	mov	x1, x19
  404100:	91362c00 	add	x0, x0, #0xd8b
  404104:	52802882 	mov	w2, #0x144                 	// #324
  404108:	94000e49 	bl	407a2c <posix_print_error_and_exit>
		if (align <= chunk_header_bytes(h)) {
  40410c:	f100203f 	cmp	x1, #0x8
  404110:	54000068 	b.hi	40411c <sys_heap_aligned_alloc+0xa8>  // b.pmore
			return sys_heap_alloc(heap, bytes);
  404114:	aa0c03e1 	mov	x1, x12
  404118:	17ffffaf 	b	403fd4 <sys_heap_alloc>
		rew = 0;
  40411c:	d280000f 	mov	x15, #0x0                   	// #0
		gap = chunk_header_bytes(h);
  404120:	d2800100 	mov	x0, #0x8                   	// #8
  404124:	17ffffe0 	b	4040a4 <sys_heap_aligned_alloc+0x30>

	if (bytes == 0 || size_too_big(h, bytes)) {
  404128:	b50000cc 	cbnz	x12, 404140 <sys_heap_aligned_alloc+0xcc>
		return NULL;
  40412c:	d2800009 	mov	x9, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  404130:	aa0903e0 	mov	x0, x9
  404134:	f9400bf3 	ldr	x19, [sp, #16]
  404138:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40413c:	d65f03c0 	ret
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  404140:	b94009a1 	ldr	w1, [x13, #8]
	if (bytes == 0 || size_too_big(h, bytes)) {
  404144:	eb4c0c3f 	cmp	x1, x12, lsr #3
  404148:	54ffff29 	b.ls	40412c <sys_heap_aligned_alloc+0xb8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  40414c:	cb0001c1 	sub	x1, x14, x0
	chunkid_t c0 = alloc_chunk(h, padded_sz);
  404150:	aa0d03e0 	mov	x0, x13
  404154:	8b030021 	add	x1, x1, x3
  404158:	d3438821 	ubfx	x1, x1, #3, #32
  40415c:	97ffff31 	bl	403e20 <alloc_chunk>
  404160:	2a0003e7 	mov	w7, w0
	if (c0 == 0) {
  404164:	34fffe40 	cbz	w0, 40412c <sys_heap_aligned_alloc+0xb8>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  404168:	d37d7ce9 	ubfiz	x9, x7, #3, #32
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  40416c:	cb0e03ee 	neg	x14, x14
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  404170:	91002129 	add	x9, x9, #0x8
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  404174:	d2800100 	mov	x0, #0x8                   	// #8
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  404178:	8b0f0129 	add	x9, x9, x15
  40417c:	8b0901a9 	add	x9, x13, x9
  404180:	8b120129 	add	x9, x9, x18
  404184:	8a0e0129 	and	x9, x9, x14
  404188:	cb0f0129 	sub	x9, x9, x15
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  40418c:	d100212a 	sub	x10, x9, #0x8
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  404190:	8b0c0128 	add	x8, x9, x12
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  404194:	cb0d014a 	sub	x10, x10, x13
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  404198:	91001d08 	add	x8, x8, #0x7
  40419c:	927df108 	and	x8, x8, #0xfffffffffffffff8
	chunkid_t c_end = end - chunk_buf(h);
  4041a0:	cb0d0108 	sub	x8, x8, x13
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  4041a4:	9ac00d4a 	sdiv	x10, x10, x0
	chunkid_t c_end = end - chunk_buf(h);
  4041a8:	9343fd08 	asr	x8, x8, #3
	if (c > c0) {
  4041ac:	6b0a00ff 	cmp	w7, w10
  4041b0:	54000102 	b.cs	4041d0 <sys_heap_aligned_alloc+0x15c>  // b.hs, b.nlast
		split_chunks(h, c0, c);
  4041b4:	2a0a03e2 	mov	w2, w10
  4041b8:	2a0703e1 	mov	w1, w7
  4041bc:	aa0d03e0 	mov	x0, x13
  4041c0:	97ffff6b 	bl	403f6c <split_chunks>
		free_list_add(h, c0);
  4041c4:	2a0703e1 	mov	w1, w7
  4041c8:	aa0d03e0 	mov	x0, x13
  4041cc:	97ffff43 	bl	403ed8 <free_list_add>
	return c + chunk_size(h, c);
  4041d0:	2a0a03e1 	mov	w1, w10
  4041d4:	aa0d03e0 	mov	x0, x13
  4041d8:	97fffef6 	bl	403db0 <chunk_size>
  4041dc:	0b0a0000 	add	w0, w0, w10
	if (right_chunk(h, c) > c_end) {
  4041e0:	6b00011f 	cmp	w8, w0
  4041e4:	54000102 	b.cs	404204 <sys_heap_aligned_alloc+0x190>  // b.hs, b.nlast
		split_chunks(h, c, c_end);
  4041e8:	2a0803e2 	mov	w2, w8
  4041ec:	2a0a03e1 	mov	w1, w10
  4041f0:	aa0d03e0 	mov	x0, x13
  4041f4:	97ffff5e 	bl	403f6c <split_chunks>
		free_list_add(h, c_end);
  4041f8:	2a0803e1 	mov	w1, w8
  4041fc:	aa0d03e0 	mov	x0, x13
  404200:	97ffff36 	bl	403ed8 <free_list_add>
	void *cmem = &buf[c];
  404204:	8b2a4daa 	add	x10, x13, w10, uxtw #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  404208:	b9400540 	ldr	w0, [x10, #4]
  40420c:	32000000 	orr	w0, w0, #0x1
  404210:	b9000540 	str	w0, [x10, #4]
  404214:	17ffffc7 	b	404130 <sys_heap_aligned_alloc+0xbc>

0000000000404218 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
  404218:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		/* Must fit in a 15 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
	} else {
		/* Must fit in a 31 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  40421c:	b24087e3 	mov	x3, #0x3ffffffff           	// #17179869183
{
  404220:	910003fd 	mov	x29, sp
  404224:	a90153f3 	stp	x19, x20, [sp, #16]
  404228:	f90013f5 	str	x21, [sp, #32]
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  40422c:	eb03005f 	cmp	x2, x3
  404230:	540002a9 	b.ls	404284 <sys_heap_init+0x6c>  // b.plast
  404234:	90000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  404238:	9138c273 	add	x19, x19, #0xe30
  40423c:	aa1303e2 	mov	x2, x19
  404240:	90000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  404244:	913cd021 	add	x1, x1, #0xf34
  404248:	52803dc3 	mov	w3, #0x1ee                 	// #494
  40424c:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  404250:	91353400 	add	x0, x0, #0xd4d
  404254:	940003da 	bl	4051bc <assert_print>
  404258:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40425c:	913d3800 	add	x0, x0, #0xf4e
  404260:	940003d7 	bl	4051bc <assert_print>
  404264:	aa1303e0 	mov	x0, x19
  404268:	52803dc1 	mov	w1, #0x1ee                 	// #494
  40426c:	940003fe 	bl	405264 <assert_post_action>
  404270:	52803dc2 	mov	w2, #0x1ee                 	// #494
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
  404274:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  404278:	aa1303e1 	mov	x1, x19
  40427c:	91362c00 	add	x0, x0, #0xd8b
  404280:	94000deb 	bl	407a2c <posix_print_error_and_exit>
  404284:	f100205f 	cmp	x2, #0x8
  404288:	54000248 	b.hi	4042d0 <sys_heap_init+0xb8>  // b.pmore
  40428c:	90000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  404290:	9138c273 	add	x19, x19, #0xe30
  404294:	aa1303e2 	mov	x2, x19
  404298:	90000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  40429c:	913d9421 	add	x1, x1, #0xf65
  4042a0:	52803e43 	mov	w3, #0x1f2                 	// #498
  4042a4:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4042a8:	91353400 	add	x0, x0, #0xd4d
  4042ac:	940003c4 	bl	4051bc <assert_print>
  4042b0:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4042b4:	913e1800 	add	x0, x0, #0xf86
  4042b8:	940003c1 	bl	4051bc <assert_print>
  4042bc:	aa1303e0 	mov	x0, x19
  4042c0:	52803e41 	mov	w1, #0x1f2                 	// #498
  4042c4:	940003e8 	bl	405264 <assert_post_action>
  4042c8:	52803e42 	mov	w2, #0x1f2                 	// #498
  4042cc:	17ffffea 	b	404274 <sys_heap_init+0x5c>
	bytes -= heap_footer_bytes(bytes);
  4042d0:	d1002042 	sub	x2, x2, #0x8

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  4042d4:	91001c34 	add	x20, x1, #0x7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  4042d8:	8b020033 	add	x19, x1, x2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  4042dc:	927df294 	and	x20, x20, #0xfffffffffffffff8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  4042e0:	927df273 	and	x19, x19, #0xfffffffffffffff8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
  4042e4:	cb140273 	sub	x19, x19, x20
  4042e8:	d343fe73 	lsr	x19, x19, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
  4042ec:	71000a7f 	cmp	w19, #0x2
  4042f0:	54000248 	b.hi	404338 <sys_heap_init+0x120>  // b.pmore
  4042f4:	90000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  4042f8:	9138c273 	add	x19, x19, #0xe30
  4042fc:	aa1303e2 	mov	x2, x19
  404300:	90000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  404304:	913e7c21 	add	x1, x1, #0xf9f
  404308:	52803f63 	mov	w3, #0x1fb                 	// #507
  40430c:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  404310:	91353400 	add	x0, x0, #0xd4d
  404314:	940003aa 	bl	4051bc <assert_print>
  404318:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40431c:	913e1800 	add	x0, x0, #0xf86
  404320:	940003a7 	bl	4051bc <assert_print>
  404324:	aa1303e0 	mov	x0, x19
  404328:	52803f61 	mov	w1, #0x1fb                 	// #507
  40432c:	940003ce 	bl	405264 <assert_post_action>
  404330:	52803f62 	mov	w2, #0x1fb                 	// #507
  404334:	17ffffd0 	b	404274 <sys_heap_init+0x5c>

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
  404338:	f9000014 	str	x20, [x0]
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  40433c:	51000660 	sub	w0, w19, #0x1
	return 31 - __builtin_clz(usable_sz);
  404340:	5ac01000 	clz	w0, w0
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  404344:	52800495 	mov	w21, #0x24                  	// #36
  404348:	4b0002b5 	sub	w21, w21, w0
  40434c:	d28000e1 	mov	x1, #0x7                   	// #7
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
  404350:	29017e93 	stp	w19, wzr, [x20, #8]
  404354:	8b35c835 	add	x21, x1, w21, sxtw #2
  404358:	d343feb5 	lsr	x21, x21, #3

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
  40435c:	11000aa1 	add	w1, w21, #0x2
  404360:	6b13003f 	cmp	w1, w19
  404364:	54000249 	b.ls	4043ac <sys_heap_init+0x194>  // b.plast
  404368:	90000093 	adrp	x19, 414000 <sys_clock_tick_get+0x78>
  40436c:	9138c273 	add	x19, x19, #0xe30
  404370:	aa1303e2 	mov	x2, x19
  404374:	90000081 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  404378:	913f2021 	add	x1, x1, #0xfc8
  40437c:	52804183 	mov	w3, #0x20c                 	// #524
  404380:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  404384:	91353400 	add	x0, x0, #0xd4d
  404388:	9400038d 	bl	4051bc <assert_print>
  40438c:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  404390:	913e1800 	add	x0, x0, #0xf86
  404394:	9400038a 	bl	4051bc <assert_print>
  404398:	aa1303e0 	mov	x0, x19
  40439c:	52804181 	mov	w1, #0x20c                 	// #524
  4043a0:	940003b1 	bl	405264 <assert_post_action>
  4043a4:	52804182 	mov	w2, #0x20c                 	// #524
  4043a8:	17ffffb3 	b	404274 <sys_heap_init+0x5c>

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
  4043ac:	52800402 	mov	w2, #0x20                  	// #32
  4043b0:	4b000042 	sub	w2, w2, w0
  4043b4:	52800001 	mov	w1, #0x0                   	// #0
  4043b8:	91004280 	add	x0, x20, #0x10
  4043bc:	d37ef442 	lsl	x2, x2, #2
  4043c0:	97fff418 	bl	401420 <memset@plt>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  4043c4:	531f7aa0 	lsl	w0, w21, #1
		((uint32_t *)cmem)[f] = val;
  4043c8:	8b150e82 	add	x2, x20, x21, lsl #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  4043cc:	32000000 	orr	w0, w0, #0x1
	void *cmem = &buf[c];
  4043d0:	d37df2a1 	lsl	x1, x21, #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  4043d4:	2900029f 	stp	wzr, w0, [x20]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  4043d8:	4b150260 	sub	w0, w19, w21
	void *cmem = &buf[c];
  4043dc:	d37d7e73 	ubfiz	x19, x19, #3, #32
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  4043e0:	531f7803 	lsl	w3, w0, #1
		((uint32_t *)cmem)[f] = val;
  4043e4:	b9000443 	str	w3, [x2, #4]
  4043e8:	b8216a95 	str	w21, [x20, x1]
  4043ec:	8b130281 	add	x1, x20, x19
  4043f0:	b8336a80 	str	w0, [x20, x19]
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  4043f4:	52800020 	mov	w0, #0x1                   	// #1
  4043f8:	b9000420 	str	w0, [x1, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
  4043fc:	2a1503e1 	mov	w1, w21
  404400:	aa1403e0 	mov	x0, x20
}
  404404:	a94153f3 	ldp	x19, x20, [sp, #16]
  404408:	f94013f5 	ldr	x21, [sp, #32]
  40440c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	free_list_add(h, chunk0_size);
  404410:	17fffeb2 	b	403ed8 <free_list_add>

0000000000404414 <crc32_ieee_update>:
	crc = ~crc;

	for (size_t i = 0; i < len; i++) {
		uint8_t byte = data[i];

		crc = (crc >> 4) ^ table[(crc ^ byte) & 0x0f];
  404414:	90000085 	adrp	x5, 414000 <sys_clock_tick_get+0x78>
	crc = ~crc;
  404418:	2a2003e0 	mvn	w0, w0
		crc = (crc >> 4) ^ table[(crc ^ byte) & 0x0f];
  40441c:	911ea0a5 	add	x5, x5, #0x7a8
	for (size_t i = 0; i < len; i++) {
  404420:	d2800004 	mov	x4, #0x0                   	// #0
  404424:	eb02009f 	cmp	x4, x2
  404428:	54000061 	b.ne	404434 <crc32_ieee_update+0x20>  // b.any
		crc = (crc >> 4) ^ table[(crc ^ ((uint32_t)byte >> 4)) & 0x0f];
	}

	return (~crc);
}
  40442c:	2a2003e0 	mvn	w0, w0
  404430:	d65f03c0 	ret
		uint8_t byte = data[i];
  404434:	38646823 	ldrb	w3, [x1, x4]
	for (size_t i = 0; i < len; i++) {
  404438:	91000484 	add	x4, x4, #0x1
		crc = (crc >> 4) ^ table[(crc ^ byte) & 0x0f];
  40443c:	4a000066 	eor	w6, w3, w0
  404440:	92400cc6 	and	x6, x6, #0xf
  404444:	b86678a6 	ldr	w6, [x5, x6, lsl #2]
  404448:	4a4010c0 	eor	w0, w6, w0, lsr #4
		crc = (crc >> 4) ^ table[(crc ^ ((uint32_t)byte >> 4)) & 0x0f];
  40444c:	4a431003 	eor	w3, w0, w3, lsr #4
  404450:	92400c63 	and	x3, x3, #0xf
  404454:	b86378a3 	ldr	w3, [x5, x3, lsl #2]
  404458:	4a401060 	eor	w0, w3, w0, lsr #4
	for (size_t i = 0; i < len; i++) {
  40445c:	17fffff2 	b	404424 <crc32_ieee_update+0x10>

0000000000404460 <crc32_ieee>:
	return crc32_ieee_update(0x0, data, len);
  404460:	aa0103e2 	mov	x2, x1
  404464:	aa0003e1 	mov	x1, x0
  404468:	52800000 	mov	w0, #0x0                   	// #0
  40446c:	17ffffea 	b	404414 <crc32_ieee_update>

0000000000404470 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
  404470:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  404474:	910003fd 	mov	x29, sp
  404478:	a90153f3 	stp	x19, x20, [sp, #16]
  40447c:	aa0203f4 	mov	x20, x2
	size_t count = 0;
  404480:	d2800013 	mov	x19, #0x0                   	// #0
{
  404484:	a9025bf5 	stp	x21, x22, [sp, #32]
  404488:	aa0003f6 	mov	x22, x0
  40448c:	aa0303f5 	mov	x21, x3
  404490:	f9001bf7 	str	x23, [sp, #48]
  404494:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
  404498:	8b130280 	add	x0, x20, x19
  40449c:	eb0002bf 	cmp	x21, x0
  4044a0:	54000148 	b.hi	4044c8 <outs+0x58>  // b.pmore
  4044a4:	b40000f5 	cbz	x21, 4044c0 <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
  4044a8:	2a1303e0 	mov	w0, w19
}
  4044ac:	a94153f3 	ldp	x19, x20, [sp, #16]
  4044b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4044b4:	f9401bf7 	ldr	x23, [sp, #48]
  4044b8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4044bc:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
  4044c0:	38736a80 	ldrb	w0, [x20, x19]
  4044c4:	34ffff20 	cbz	w0, 4044a8 <outs+0x38>
		int rc = out((int)*sp++, ctx);
  4044c8:	38736a80 	ldrb	w0, [x20, x19]
  4044cc:	aa1703e1 	mov	x1, x23
  4044d0:	d63f02c0 	blr	x22
		if (rc < 0) {
  4044d4:	37fffec0 	tbnz	w0, #31, 4044ac <outs+0x3c>
		++count;
  4044d8:	91000673 	add	x19, x19, #0x1
  4044dc:	17ffffef 	b	404498 <outs+0x28>

00000000004044e0 <extract_decimal>:
{
  4044e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4044e4:	910003fd 	mov	x29, sp
  4044e8:	a90153f3 	stp	x19, x20, [sp, #16]
  4044ec:	aa0003f4 	mov	x20, x0
	const char *sp = *str;
  4044f0:	f9400013 	ldr	x19, [x0]
	while (isdigit((int)(unsigned char)*sp) != 0) {
  4044f4:	97fff40f 	bl	401530 <__ctype_b_loc@plt>
		val = 10U * val + *sp++ - '0';
  4044f8:	d2800144 	mov	x4, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp) != 0) {
  4044fc:	f9400002 	ldr	x2, [x0]
	size_t val = 0;
  404500:	d2800000 	mov	x0, #0x0                   	// #0
	while (isdigit((int)(unsigned char)*sp) != 0) {
  404504:	39400263 	ldrb	w3, [x19]
  404508:	78637841 	ldrh	w1, [x2, x3, lsl #1]
  40450c:	375800a1 	tbnz	w1, #11, 404520 <extract_decimal+0x40>
	*str = sp;
  404510:	f9000293 	str	x19, [x20]
}
  404514:	a94153f3 	ldp	x19, x20, [sp, #16]
  404518:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40451c:	d65f03c0 	ret
		val = 10U * val + *sp++ - '0';
  404520:	9b040c00 	madd	x0, x0, x4, x3
  404524:	91000673 	add	x19, x19, #0x1
  404528:	d100c000 	sub	x0, x0, #0x30
  40452c:	17fffff6 	b	404504 <extract_decimal+0x24>

0000000000404530 <encode_uint>:
{
  404530:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  404534:	910003fd 	mov	x29, sp
  404538:	a90153f3 	stp	x19, x20, [sp, #16]
  40453c:	aa0103f3 	mov	x19, x1
  404540:	aa0303f4 	mov	x20, x3
  404544:	a9025bf5 	stp	x21, x22, [sp, #32]
  404548:	aa0203f6 	mov	x22, x2
  40454c:	aa0003f5 	mov	x21, x0
	bool upcase = isupper((int)conv->specifier) != 0;
  404550:	97fff3f8 	bl	401530 <__ctype_b_loc@plt>
  404554:	39400e62 	ldrb	w2, [x19, #3]
  404558:	f9400000 	ldr	x0, [x0]
  40455c:	39400e61 	ldrb	w1, [x19, #3]
  404560:	78627802 	ldrh	w2, [x0, x2, lsl #1]
  404564:	12180042 	and	w2, w2, #0x100
	switch (specifier) {
  404568:	7101bc3f 	cmp	w1, #0x6f
  40456c:	54000400 	b.eq	4045ec <encode_uint+0xbc>  // b.none
  404570:	54000388 	b.hi	4045e0 <encode_uint+0xb0>  // b.pmore
		return 16;
  404574:	7101603f 	cmp	w1, #0x58
  404578:	d2800145 	mov	x5, #0xa                   	// #10
  40457c:	d2800200 	mov	x0, #0x10                  	// #16
  404580:	9a8010a5 	csel	x5, x5, x0, ne  // ne = any
	char *bp = bps + (bpe - bps);
  404584:	aa1403e0 	mov	x0, x20
		unsigned int lsv = (unsigned int)(value % radix);
  404588:	9ac50aa3 	udiv	x3, x21, x5
  40458c:	9b05d461 	msub	x1, x3, x5, x21
		*--bp = (lsv <= 9) ? ('0' + lsv)
  404590:	12001c24 	and	w4, w1, #0xff
  404594:	f100243f 	cmp	x1, #0x9
  404598:	54000328 	b.hi	4045fc <encode_uint+0xcc>  // b.pmore
  40459c:	1100c084 	add	w4, w4, #0x30
  4045a0:	12001c84 	and	w4, w4, #0xff
  4045a4:	381ffc04 	strb	w4, [x0, #-1]!
	} while ((value != 0) && (bps < bp));
  4045a8:	eb0502bf 	cmp	x21, x5
  4045ac:	fa562000 	ccmp	x0, x22, #0x0, cs  // cs = hs, nlast
  4045b0:	54000228 	b.hi	4045f4 <encode_uint+0xc4>  // b.pmore
	if (conv->flag_hash) {
  4045b4:	79400261 	ldrh	w1, [x19]
  4045b8:	362800c1 	tbz	w1, #5, 4045d0 <encode_uint+0xa0>
		if (radix == 8) {
  4045bc:	f10020bf 	cmp	x5, #0x8
  4045c0:	540002c1 	b.ne	404618 <encode_uint+0xe8>  // b.any
			conv->altform_0 = true;
  4045c4:	39400a61 	ldrb	w1, [x19, #2]
  4045c8:	321d0021 	orr	w1, w1, #0x8
			conv->altform_0c = true;
  4045cc:	39000a61 	strb	w1, [x19, #2]
}
  4045d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4045d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4045d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4045dc:	d65f03c0 	ret
	switch (specifier) {
  4045e0:	121c7821 	and	w1, w1, #0xfffffff7
		return 16;
  4045e4:	7101c03f 	cmp	w1, #0x70
  4045e8:	17ffffe4 	b	404578 <encode_uint+0x48>
	switch (specifier) {
  4045ec:	d2800105 	mov	x5, #0x8                   	// #8
  4045f0:	17ffffe5 	b	404584 <encode_uint+0x54>
		value /= radix;
  4045f4:	aa0303f5 	mov	x21, x3
  4045f8:	17ffffe4 	b	404588 <encode_uint+0x58>
		*--bp = (lsv <= 9) ? ('0' + lsv)
  4045fc:	1100dc81 	add	w1, w4, #0x37
  404600:	11015c84 	add	w4, w4, #0x57
  404604:	12001c21 	and	w1, w1, #0xff
  404608:	12001c84 	and	w4, w4, #0xff
  40460c:	7100005f 	cmp	w2, #0x0
  404610:	1a810084 	csel	w4, w4, w1, eq  // eq = none
  404614:	17ffffe4 	b	4045a4 <encode_uint+0x74>
		} else if (radix == 16) {
  404618:	f10040bf 	cmp	x5, #0x10
  40461c:	54fffda1 	b.ne	4045d0 <encode_uint+0xa0>  // b.any
			conv->altform_0c = true;
  404620:	39400a61 	ldrb	w1, [x19, #2]
  404624:	321c0021 	orr	w1, w1, #0x10
  404628:	17ffffe9 	b	4045cc <encode_uint+0x9c>

000000000040462c <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
  40462c:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  404630:	910003fd 	mov	x29, sp
  404634:	a9046bf9 	stp	x25, x26, [sp, #64]
  404638:	aa0003f9 	mov	x25, x0
  40463c:	90000140 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  404640:	a90153f3 	stp	x19, x20, [sp, #16]
  404644:	aa0103fa 	mov	x26, x1
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
  404648:	d2800013 	mov	x19, #0x0                   	// #0
{
  40464c:	a9025bf5 	stp	x21, x22, [sp, #32]
  404650:	aa0203f5 	mov	x21, x2
  404654:	a90363f7 	stp	x23, x24, [sp, #48]
  404658:	a90573fb 	stp	x27, x28, [sp, #80]
  40465c:	f9478400 	ldr	x0, [x0, #3848]
  404660:	a940607c 	ldp	x28, x24, [x3]
  404664:	f9400001 	ldr	x1, [x0]
  404668:	f90067e1 	str	x1, [sp, #200]
  40466c:	d2800001 	mov	x1, #0x0                   	// #0
  404670:	b940187b 	ldr	w27, [x3, #24]
  404674:	f9400860 	ldr	x0, [x3, #16]
  404678:	f9003be0 	str	x0, [sp, #112]
  40467c:	b9401c60 	ldr	w0, [x3, #28]
  404680:	b90067e0 	str	w0, [sp, #100]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
  404684:	91031be0 	add	x0, sp, #0xc6
  404688:	f90037e0 	str	x0, [sp, #104]
  40468c:	394002a0 	ldrb	w0, [x21]
  404690:	35000140 	cbnz	w0, 4046b8 <z_cbvprintf_impl+0x8c>
			OUTC(' ');
			--width;
		}
	}

	return count;
  404694:	2a1303e0 	mov	w0, w19
#undef OUTS
#undef OUTC
}
  404698:	90000141 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40469c:	f9478421 	ldr	x1, [x1, #3848]
  4046a0:	f94067e3 	ldr	x3, [sp, #200]
  4046a4:	f9400022 	ldr	x2, [x1]
  4046a8:	eb020063 	subs	x3, x3, x2
  4046ac:	d2800002 	mov	x2, #0x0                   	// #0
  4046b0:	54005780 	b.eq	4051a0 <z_cbvprintf_impl+0xb74>  // b.none
  4046b4:	97fff37f 	bl	4014b0 <__stack_chk_fail@plt>
			OUTC(*fp++);
  4046b8:	910006b4 	add	x20, x21, #0x1
		if (*fp != '%') {
  4046bc:	7100941f 	cmp	w0, #0x25
  4046c0:	540000c0 	b.eq	4046d8 <z_cbvprintf_impl+0xac>  // b.none
			OUTC('%');
  4046c4:	aa1a03e1 	mov	x1, x26
  4046c8:	d63f0320 	blr	x25
  4046cc:	37fffe60 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  4046d0:	91000673 	add	x19, x19, #0x1
			break;
  4046d4:	14000140 	b	404bd4 <z_cbvprintf_impl+0x5a8>
		} state = {
  4046d8:	a9097fff 	stp	xzr, xzr, [sp, #144]
  4046dc:	a90a7fff 	stp	xzr, xzr, [sp, #160]
	if (*sp == '%') {
  4046e0:	394006a0 	ldrb	w0, [x21, #1]
  4046e4:	7100941f 	cmp	w0, #0x25
  4046e8:	54000661 	b.ne	4047b4 <z_cbvprintf_impl+0x188>  // b.any
		conv->specifier = *sp++;
  4046ec:	91000ab4 	add	x20, x21, #0x2
  4046f0:	39028fe0 	strb	w0, [sp, #163]
		if (conv->width_star) {
  4046f4:	794143e0 	ldrh	w0, [sp, #160]
  4046f8:	364021c0 	tbz	w0, #8, 404b30 <z_cbvprintf_impl+0x504>
			width = va_arg(ap, int);
  4046fc:	37f8205b 	tbnz	w27, #31, 404b04 <z_cbvprintf_impl+0x4d8>
  404700:	91002f81 	add	x1, x28, #0xb
  404704:	aa1c03e0 	mov	x0, x28
  404708:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  40470c:	b9400016 	ldr	w22, [x0]
			if (width < 0) {
  404710:	36f800b6 	tbz	w22, #31, 404724 <z_cbvprintf_impl+0xf8>
				conv->flag_dash = true;
  404714:	794143e0 	ldrh	w0, [sp, #160]
				width = -width;
  404718:	4b1603f6 	neg	w22, w22
				conv->flag_dash = true;
  40471c:	321e0000 	orr	w0, w0, #0x4
  404720:	790143e0 	strh	w0, [sp, #160]
		if (conv->prec_star) {
  404724:	794143e0 	ldrh	w0, [sp, #160]
  404728:	36502220 	tbz	w0, #10, 404b6c <z_cbvprintf_impl+0x540>
			int arg = va_arg(ap, int);
  40472c:	37f820bb 	tbnz	w27, #31, 404b40 <z_cbvprintf_impl+0x514>
  404730:	91002f81 	add	x1, x28, #0xb
  404734:	aa1c03e0 	mov	x0, x28
  404738:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  40473c:	b9400017 	ldr	w23, [x0]
			if (arg < 0) {
  404740:	36f800b7 	tbz	w23, #31, 404754 <z_cbvprintf_impl+0x128>
				conv->prec_present = false;
  404744:	794143e0 	ldrh	w0, [sp, #160]
		int precision = -1;
  404748:	12800017 	mov	w23, #0xffffffff            	// #-1
				conv->prec_present = false;
  40474c:	12167800 	and	w0, w0, #0xfffffdff
  404750:	790143e0 	strh	w0, [sp, #160]
		conv->pad0_value = 0;
  404754:	f80a43ff 	stur	xzr, [sp, #164]
			= (enum specifier_cat_enum)conv->specifier_cat;
  404758:	f94053e1 	ldr	x1, [sp, #160]
		enum specifier_cat_enum specifier_cat
  40475c:	53104820 	ubfx	w0, w1, #16, #3
			= (enum length_mod_enum)conv->length_mod;
  404760:	530b3821 	ubfx	w1, w1, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
  404764:	7100041f 	cmp	w0, #0x1
  404768:	54002721 	b.ne	404c4c <z_cbvprintf_impl+0x620>  // b.any
			switch (length_mod) {
  40476c:	51000c22 	sub	w2, w1, #0x3
  404770:	7100105f 	cmp	w2, #0x4
  404774:	54002048 	b.hi	404b7c <z_cbvprintf_impl+0x550>  // b.pmore
  404778:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40477c:	911fa000 	add	x0, x0, #0x7e8
  404780:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
  404784:	10000062 	adr	x2, 404790 <z_cbvprintf_impl+0x164>
  404788:	8b20a840 	add	x0, x2, w0, sxth #2
  40478c:	d61f0000 	br	x0
		switch (*sp) {
  404790:	7100b43f 	cmp	w1, #0x2d
  404794:	540000a0 	b.eq	4047a8 <z_cbvprintf_impl+0x17c>  // b.none
  404798:	7100c03f 	cmp	w1, #0x30
  40479c:	540001e1 	b.ne	4047d8 <z_cbvprintf_impl+0x1ac>  // b.any
			conv->flag_zero = true;
  4047a0:	321a0000 	orr	w0, w0, #0x40
  4047a4:	14000002 	b	4047ac <z_cbvprintf_impl+0x180>
			conv->flag_dash = true;
  4047a8:	321e0000 	orr	w0, w0, #0x4
			++sp;
  4047ac:	91000694 	add	x20, x20, #0x1
			conv->flag_zero = true;
  4047b0:	790143e0 	strh	w0, [sp, #160]
		switch (*sp) {
  4047b4:	39400281 	ldrb	w1, [x20]
  4047b8:	794143e0 	ldrh	w0, [sp, #160]
  4047bc:	7100ac3f 	cmp	w1, #0x2b
  4047c0:	54000b00 	b.eq	404920 <z_cbvprintf_impl+0x2f4>  // b.none
  4047c4:	54fffe68 	b.hi	404790 <z_cbvprintf_impl+0x164>  // b.pmore
  4047c8:	7100803f 	cmp	w1, #0x20
  4047cc:	54000ae0 	b.eq	404928 <z_cbvprintf_impl+0x2fc>  // b.none
  4047d0:	71008c3f 	cmp	w1, #0x23
  4047d4:	54000ae0 	b.eq	404930 <z_cbvprintf_impl+0x304>  // b.none
	if (conv->flag_zero && conv->flag_dash) {
  4047d8:	b940a3e1 	ldr	w1, [sp, #160]
  4047dc:	52800882 	mov	w2, #0x44                  	// #68
  4047e0:	0a020021 	and	w1, w1, w2
  4047e4:	6b02003f 	cmp	w1, w2
  4047e8:	54000061 	b.ne	4047f4 <z_cbvprintf_impl+0x1c8>  // b.any
		conv->flag_zero = false;
  4047ec:	12197800 	and	w0, w0, #0xffffffbf
  4047f0:	790143e0 	strh	w0, [sp, #160]
	conv->width_present = true;
  4047f4:	794143e0 	ldrh	w0, [sp, #160]
  4047f8:	f90047f4 	str	x20, [sp, #136]
  4047fc:	32190001 	orr	w1, w0, #0x80
  404800:	790143e1 	strh	w1, [sp, #160]
	if (*sp == '*') {
  404804:	39400281 	ldrb	w1, [x20]
  404808:	7100a83f 	cmp	w1, #0x2a
  40480c:	54000961 	b.ne	404938 <z_cbvprintf_impl+0x30c>  // b.any
		return ++sp;
  404810:	91000694 	add	x20, x20, #0x1
		conv->width_star = true;
  404814:	32190400 	orr	w0, w0, #0x180
  404818:	790143e0 	strh	w0, [sp, #160]
	sp = extract_prec(conv, sp);
  40481c:	f90047f4 	str	x20, [sp, #136]
	conv->prec_present = (*sp == '.');
  404820:	39400280 	ldrb	w0, [x20]
  404824:	7100b81f 	cmp	w0, #0x2e
  404828:	794143e0 	ldrh	w0, [sp, #160]
  40482c:	1a9f17e1 	cset	w1, eq  // eq = none
  404830:	33170020 	bfi	w0, w1, #9, #1
  404834:	790143e0 	strh	w0, [sp, #160]
	if (!conv->prec_present) {
  404838:	54000121 	b.ne	40485c <z_cbvprintf_impl+0x230>  // b.any
	++sp;
  40483c:	91000681 	add	x1, x20, #0x1
  404840:	f90047e1 	str	x1, [sp, #136]
	if (*sp == '*') {
  404844:	39400681 	ldrb	w1, [x20, #1]
  404848:	7100a83f 	cmp	w1, #0x2a
  40484c:	54000961 	b.ne	404978 <z_cbvprintf_impl+0x34c>  // b.any
		return ++sp;
  404850:	91000a94 	add	x20, x20, #0x2
		conv->prec_star = true;
  404854:	32160000 	orr	w0, w0, #0x400
  404858:	790143e0 	strh	w0, [sp, #160]
	switch (*sp) {
  40485c:	aa1403e1 	mov	x1, x20
  404860:	38401420 	ldrb	w0, [x1], #1
  404864:	7101b01f 	cmp	w0, #0x6c
  404868:	54000d00 	b.eq	404a08 <z_cbvprintf_impl+0x3dc>  // b.none
  40486c:	54000a68 	b.hi	4049b8 <z_cbvprintf_impl+0x38c>  // b.pmore
  404870:	7101a01f 	cmp	w0, #0x68
  404874:	54000b00 	b.eq	4049d4 <z_cbvprintf_impl+0x3a8>  // b.none
  404878:	7101a81f 	cmp	w0, #0x6a
  40487c:	54000d60 	b.eq	404a28 <z_cbvprintf_impl+0x3fc>  // b.none
  404880:	7101301f 	cmp	w0, #0x4c
  404884:	54000de0 	b.eq	404a40 <z_cbvprintf_impl+0x414>  // b.none
  404888:	aa1403e1 	mov	x1, x20
	conv->specifier = *sp++;
  40488c:	aa0103f4 	mov	x20, x1
  404890:	38401682 	ldrb	w2, [x20], #1
  404894:	39028fe2 	strb	w2, [sp, #163]
	switch (conv->specifier) {
  404898:	7101a45f 	cmp	w2, #0x69
  40489c:	54001028 	b.hi	404aa0 <z_cbvprintf_impl+0x474>  // b.pmore
  4048a0:	7101005f 	cmp	w2, #0x40
  4048a4:	54001069 	b.ls	404ab0 <z_cbvprintf_impl+0x484>  // b.plast
  4048a8:	51010441 	sub	w1, w2, #0x41
  4048ac:	d2800020 	mov	x0, #0x1                   	// #1
  4048b0:	d2800e23 	mov	x3, #0x71                  	// #113
  4048b4:	9ac12001 	lsl	x1, x0, x1
  4048b8:	f2c00e23 	movk	x3, #0x71, lsl #32
  4048bc:	ea03003f 	tst	x1, x3
  4048c0:	54001021 	b.ne	404ac4 <z_cbvprintf_impl+0x498>  // b.any
  4048c4:	d2c02103 	mov	x3, #0x10800000000         	// #1133871366144
  4048c8:	ea03003f 	tst	x1, x3
  4048cc:	540000c1 	b.ne	4048e4 <z_cbvprintf_impl+0x2b8>  // b.any
  4048d0:	d2a01000 	mov	x0, #0x800000              	// #8388608
  4048d4:	f2c00080 	movk	x0, #0x4, lsl #32
  4048d8:	ea00003f 	tst	x1, x0
  4048dc:	54000ea0 	b.eq	404ab0 <z_cbvprintf_impl+0x484>  // b.none
  4048e0:	52800040 	mov	w0, #0x2                   	// #2
		conv->specifier_cat = SPECIFIER_SINT;
  4048e4:	39428be1 	ldrb	w1, [sp, #162]
  4048e8:	33000801 	bfxil	w1, w0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
  4048ec:	794143e0 	ldrh	w0, [sp, #160]
		conv->specifier_cat = SPECIFIER_SINT;
  4048f0:	39028be1 	strb	w1, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  4048f4:	12150c01 	and	w1, w0, #0x7800
  4048f8:	7140103f 	cmp	w1, #0x4, lsl #12
  4048fc:	54000061 	b.ne	404908 <z_cbvprintf_impl+0x2dc>  // b.any
			conv->invalid = true;
  404900:	32000000 	orr	w0, w0, #0x1
  404904:	790143e0 	strh	w0, [sp, #160]
		if (conv->specifier == 'c') {
  404908:	71018c5f 	cmp	w2, #0x63
  40490c:	54000d81 	b.ne	404abc <z_cbvprintf_impl+0x490>  // b.any
		if (conv->length_mod != LENGTH_NONE) {
  404910:	794143e0 	ldrh	w0, [sp, #160]
  404914:	72150c1f 	tst	w0, #0x7800
  404918:	1a9f07e0 	cset	w0, ne  // ne = any
  40491c:	1400006e 	b	404ad4 <z_cbvprintf_impl+0x4a8>
			conv->flag_plus = true;
  404920:	321d0000 	orr	w0, w0, #0x8
  404924:	17ffffa2 	b	4047ac <z_cbvprintf_impl+0x180>
			conv->flag_space = true;
  404928:	321c0000 	orr	w0, w0, #0x10
  40492c:	17ffffa0 	b	4047ac <z_cbvprintf_impl+0x180>
			conv->flag_hash = true;
  404930:	321b0000 	orr	w0, w0, #0x20
  404934:	17ffff9e 	b	4047ac <z_cbvprintf_impl+0x180>
	size_t width = extract_decimal(&sp);
  404938:	910223e0 	add	x0, sp, #0x88
  40493c:	97fffee9 	bl	4044e0 <extract_decimal>
	if (sp != wp) {
  404940:	f94047e1 	ldr	x1, [sp, #136]
  404944:	eb14003f 	cmp	x1, x20
  404948:	54fff6a0 	b.eq	40481c <z_cbvprintf_impl+0x1f0>  // b.none
		conv->width_value = width;
  40494c:	b900a7e0 	str	w0, [sp, #164]
				      || (width != (size_t)conv->width_value));
  404950:	37f80100 	tbnz	w0, #31, 404970 <z_cbvprintf_impl+0x344>
  404954:	eb20c01f 	cmp	x0, w0, sxtw
  404958:	1a9f07e2 	cset	w2, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
  40495c:	794143e0 	ldrh	w0, [sp, #160]
  404960:	aa0103f4 	mov	x20, x1
  404964:	331f0040 	bfi	w0, w2, #1, #1
  404968:	790143e0 	strh	w0, [sp, #160]
  40496c:	17ffffac 	b	40481c <z_cbvprintf_impl+0x1f0>
				      || (width != (size_t)conv->width_value));
  404970:	52800022 	mov	w2, #0x1                   	// #1
  404974:	17fffffa 	b	40495c <z_cbvprintf_impl+0x330>
	size_t prec = extract_decimal(&sp);
  404978:	910223e0 	add	x0, sp, #0x88
  40497c:	97fffed9 	bl	4044e0 <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
  404980:	f94053e1 	ldr	x1, [sp, #160]
	conv->prec_value = prec;
  404984:	b900abe0 	str	w0, [sp, #168]
	conv->unsupported |= ((conv->prec_value < 0)
  404988:	53010421 	ubfx	w1, w1, #1, #1
			      || (prec != (size_t)conv->prec_value));
  40498c:	37f80120 	tbnz	w0, #31, 4049b0 <z_cbvprintf_impl+0x384>
  404990:	eb20c01f 	cmp	x0, w0, sxtw
  404994:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
  404998:	2a000020 	orr	w0, w1, w0
  40499c:	794143e1 	ldrh	w1, [sp, #160]
	return sp;
  4049a0:	f94047f4 	ldr	x20, [sp, #136]
	conv->unsupported |= ((conv->prec_value < 0)
  4049a4:	331f0001 	bfi	w1, w0, #1, #1
  4049a8:	790143e1 	strh	w1, [sp, #160]
	return sp;
  4049ac:	17ffffac 	b	40485c <z_cbvprintf_impl+0x230>
			      || (prec != (size_t)conv->prec_value));
  4049b0:	52800020 	mov	w0, #0x1                   	// #1
  4049b4:	17fffff9 	b	404998 <z_cbvprintf_impl+0x36c>
	switch (*sp) {
  4049b8:	7101d01f 	cmp	w0, #0x74
  4049bc:	540003c0 	b.eq	404a34 <z_cbvprintf_impl+0x408>  // b.none
  4049c0:	7101e81f 	cmp	w0, #0x7a
  4049c4:	54fff621 	b.ne	404888 <z_cbvprintf_impl+0x25c>  // b.any
		conv->length_mod = LENGTH_Z;
  4049c8:	794143e0 	ldrh	w0, [sp, #160]
  4049cc:	528000c2 	mov	w2, #0x6                   	// #6
  4049d0:	1400000b 	b	4049fc <z_cbvprintf_impl+0x3d0>
		if (*++sp == 'h') {
  4049d4:	39400680 	ldrb	w0, [x20, #1]
  4049d8:	7101a01f 	cmp	w0, #0x68
  4049dc:	794143e0 	ldrh	w0, [sp, #160]
  4049e0:	540000c1 	b.ne	4049f8 <z_cbvprintf_impl+0x3cc>  // b.any
			conv->length_mod = LENGTH_HH;
  4049e4:	52800021 	mov	w1, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
  4049e8:	33150c20 	bfi	w0, w1, #11, #4
			++sp;
  4049ec:	91000a81 	add	x1, x20, #0x2
			conv->length_mod = LENGTH_LL;
  4049f0:	790143e0 	strh	w0, [sp, #160]
			++sp;
  4049f4:	17ffffa6 	b	40488c <z_cbvprintf_impl+0x260>
			conv->length_mod = LENGTH_H;
  4049f8:	52800042 	mov	w2, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
  4049fc:	33150c40 	bfi	w0, w2, #11, #4
		conv->unsupported = true;
  404a00:	790143e0 	strh	w0, [sp, #160]
		break;
  404a04:	17ffffa2 	b	40488c <z_cbvprintf_impl+0x260>
		if (*++sp == 'l') {
  404a08:	39400680 	ldrb	w0, [x20, #1]
  404a0c:	7101b01f 	cmp	w0, #0x6c
  404a10:	794143e0 	ldrh	w0, [sp, #160]
  404a14:	54000061 	b.ne	404a20 <z_cbvprintf_impl+0x3f4>  // b.any
			conv->length_mod = LENGTH_LL;
  404a18:	52800081 	mov	w1, #0x4                   	// #4
  404a1c:	17fffff3 	b	4049e8 <z_cbvprintf_impl+0x3bc>
			conv->length_mod = LENGTH_L;
  404a20:	52800062 	mov	w2, #0x3                   	// #3
  404a24:	17fffff6 	b	4049fc <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_J;
  404a28:	794143e0 	ldrh	w0, [sp, #160]
  404a2c:	528000a2 	mov	w2, #0x5                   	// #5
  404a30:	17fffff3 	b	4049fc <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_T;
  404a34:	794143e0 	ldrh	w0, [sp, #160]
  404a38:	528000e2 	mov	w2, #0x7                   	// #7
  404a3c:	17fffff0 	b	4049fc <z_cbvprintf_impl+0x3d0>
		conv->unsupported = true;
  404a40:	794143e0 	ldrh	w0, [sp, #160]
  404a44:	128f0042 	mov	w2, #0xffff87fd            	// #-30723
  404a48:	0a020000 	and	w0, w0, w2
  404a4c:	52880042 	mov	w2, #0x4002                	// #16386
  404a50:	2a020000 	orr	w0, w0, w2
  404a54:	17ffffeb 	b	404a00 <z_cbvprintf_impl+0x3d4>
  404a58:	d2800020 	mov	x0, #0x1                   	// #1
  404a5c:	9ac12000 	lsl	x0, x0, x1
	switch (conv->specifier) {
  404a60:	d2809041 	mov	x1, #0x482                 	// #1154
  404a64:	ea01001f 	tst	x0, x1
  404a68:	54fff3c1 	b.ne	4048e0 <z_cbvprintf_impl+0x2b4>  // b.any
  404a6c:	d2800481 	mov	x1, #0x24                  	// #36
  404a70:	ea01001f 	tst	x0, x1
  404a74:	540003e1 	b.ne	404af0 <z_cbvprintf_impl+0x4c4>  // b.any
  404a78:	360001c0 	tbz	w0, #0, 404ab0 <z_cbvprintf_impl+0x484>
		conv->specifier_cat = SPECIFIER_PTR;
  404a7c:	39428be0 	ldrb	w0, [sp, #162]
  404a80:	52800061 	mov	w1, #0x3                   	// #3
  404a84:	33000820 	bfxil	w0, w1, #0, #3
  404a88:	39028be0 	strb	w0, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  404a8c:	794143e0 	ldrh	w0, [sp, #160]
  404a90:	12150c00 	and	w0, w0, #0x7800
  404a94:	7140101f 	cmp	w0, #0x4, lsl #12
  404a98:	1a9f17e0 	cset	w0, eq  // eq = none
  404a9c:	1400000e 	b	404ad4 <z_cbvprintf_impl+0x4a8>
	switch (conv->specifier) {
  404aa0:	5101b841 	sub	w1, w2, #0x6e
  404aa4:	12001c21 	and	w1, w1, #0xff
  404aa8:	7100283f 	cmp	w1, #0xa
  404aac:	54fffd69 	b.ls	404a58 <z_cbvprintf_impl+0x42c>  // b.plast
		conv->invalid = true;
  404ab0:	794143e0 	ldrh	w0, [sp, #160]
  404ab4:	32000000 	orr	w0, w0, #0x1
  404ab8:	790143e0 	strh	w0, [sp, #160]
	bool unsupported = false;
  404abc:	52800000 	mov	w0, #0x0                   	// #0
  404ac0:	14000005 	b	404ad4 <z_cbvprintf_impl+0x4a8>
		conv->specifier_cat = SPECIFIER_FP;
  404ac4:	39428be1 	ldrb	w1, [sp, #162]
  404ac8:	52800082 	mov	w2, #0x4                   	// #4
  404acc:	33000841 	bfxil	w1, w2, #0, #3
  404ad0:	39028be1 	strb	w1, [sp, #162]
	conv->unsupported |= unsupported;
  404ad4:	f94053e1 	ldr	x1, [sp, #160]
  404ad8:	d3410421 	ubfx	x1, x1, #1, #1
  404adc:	2a010000 	orr	w0, w0, w1
  404ae0:	794143e1 	ldrh	w1, [sp, #160]
  404ae4:	331f0001 	bfi	w1, w0, #1, #1
  404ae8:	790143e1 	strh	w1, [sp, #160]
	return sp;
  404aec:	17ffff02 	b	4046f4 <z_cbvprintf_impl+0xc8>
		conv->specifier_cat = SPECIFIER_PTR;
  404af0:	39428be0 	ldrb	w0, [sp, #162]
  404af4:	52800061 	mov	w1, #0x3                   	// #3
  404af8:	33000820 	bfxil	w0, w1, #0, #3
  404afc:	39028be0 	strb	w0, [sp, #162]
  404b00:	17ffff84 	b	404910 <z_cbvprintf_impl+0x2e4>
			width = va_arg(ap, int);
  404b04:	11002361 	add	w1, w27, #0x8
  404b08:	7100003f 	cmp	w1, #0x0
  404b0c:	540000cd 	b.le	404b24 <z_cbvprintf_impl+0x4f8>
  404b10:	91002f82 	add	x2, x28, #0xb
  404b14:	aa1c03e0 	mov	x0, x28
  404b18:	2a0103fb 	mov	w27, w1
  404b1c:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  404b20:	17fffefb 	b	40470c <z_cbvprintf_impl+0xe0>
  404b24:	8b3bc300 	add	x0, x24, w27, sxtw
  404b28:	2a0103fb 	mov	w27, w1
  404b2c:	17fffef8 	b	40470c <z_cbvprintf_impl+0xe0>
			width = conv->width_value;
  404b30:	b940a7f6 	ldr	w22, [sp, #164]
  404b34:	f279001f 	tst	x0, #0x80
  404b38:	5a9f12d6 	csinv	w22, w22, wzr, ne  // ne = any
  404b3c:	17fffefa 	b	404724 <z_cbvprintf_impl+0xf8>
			int arg = va_arg(ap, int);
  404b40:	11002361 	add	w1, w27, #0x8
  404b44:	7100003f 	cmp	w1, #0x0
  404b48:	540000cd 	b.le	404b60 <z_cbvprintf_impl+0x534>
  404b4c:	91002f82 	add	x2, x28, #0xb
  404b50:	aa1c03e0 	mov	x0, x28
  404b54:	2a0103fb 	mov	w27, w1
  404b58:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  404b5c:	17fffef8 	b	40473c <z_cbvprintf_impl+0x110>
  404b60:	8b3bc300 	add	x0, x24, w27, sxtw
  404b64:	2a0103fb 	mov	w27, w1
  404b68:	17fffef5 	b	40473c <z_cbvprintf_impl+0x110>
			precision = conv->prec_value;
  404b6c:	b940abf7 	ldr	w23, [sp, #168]
  404b70:	f277001f 	tst	x0, #0x200
  404b74:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
  404b78:	17fffef7 	b	404754 <z_cbvprintf_impl+0x128>
				value->sint = va_arg(ap, int);
  404b7c:	37f8031b 	tbnz	w27, #31, 404bdc <z_cbvprintf_impl+0x5b0>
  404b80:	91002f82 	add	x2, x28, #0xb
  404b84:	2a1b03e3 	mov	w3, w27
  404b88:	927df042 	and	x2, x2, #0xfffffffffffffff8
  404b8c:	b9800380 	ldrsw	x0, [x28]
  404b90:	f9004be0 	str	x0, [sp, #144]
				break;
  404b94:	2a0303fb 	mov	w27, w3
  404b98:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  404b9c:	7100043f 	cmp	w1, #0x1
  404ba0:	540004e1 	b.ne	404c3c <z_cbvprintf_impl+0x610>  // b.any
				value->sint = (signed char)value->sint;
  404ba4:	93401c00 	sxtb	x0, w0
				value->uint = (unsigned short)value->uint;
  404ba8:	f9004be0 	str	x0, [sp, #144]
		if (conv->invalid || conv->unsupported) {
  404bac:	b940a3e0 	ldr	w0, [sp, #160]
  404bb0:	f240041f 	tst	x0, #0x3
  404bb4:	540015a0 	b.eq	404e68 <z_cbvprintf_impl+0x83c>  // b.none
			OUTS(sp, fp);
  404bb8:	aa1403e3 	mov	x3, x20
  404bbc:	aa1503e2 	mov	x2, x21
  404bc0:	aa1a03e1 	mov	x1, x26
  404bc4:	aa1903e0 	mov	x0, x25
  404bc8:	97fffe2a 	bl	404470 <outs>
  404bcc:	37ffd660 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  404bd0:	8b20c273 	add	x19, x19, w0, sxtw
			continue;
  404bd4:	aa1403f5 	mov	x21, x20
  404bd8:	17fffead 	b	40468c <z_cbvprintf_impl+0x60>
				value->sint = va_arg(ap, int);
  404bdc:	11002363 	add	w3, w27, #0x8
  404be0:	7100007f 	cmp	w3, #0x0
  404be4:	5400008d 	b.le	404bf4 <z_cbvprintf_impl+0x5c8>
  404be8:	91002f82 	add	x2, x28, #0xb
  404bec:	927df042 	and	x2, x2, #0xfffffffffffffff8
  404bf0:	17ffffe7 	b	404b8c <z_cbvprintf_impl+0x560>
  404bf4:	aa1c03e2 	mov	x2, x28
  404bf8:	8b3bc31c 	add	x28, x24, w27, sxtw
  404bfc:	17ffffe4 	b	404b8c <z_cbvprintf_impl+0x560>
					(sint_value_type)va_arg(ap, ptrdiff_t);
  404c00:	37f800db 	tbnz	w27, #31, 404c18 <z_cbvprintf_impl+0x5ec>
  404c04:	91003f82 	add	x2, x28, #0xf
  404c08:	2a1b03e3 	mov	w3, w27
  404c0c:	927df042 	and	x2, x2, #0xfffffffffffffff8
  404c10:	f9400380 	ldr	x0, [x28]
  404c14:	17ffffdf 	b	404b90 <z_cbvprintf_impl+0x564>
  404c18:	11002363 	add	w3, w27, #0x8
  404c1c:	7100007f 	cmp	w3, #0x0
  404c20:	5400008d 	b.le	404c30 <z_cbvprintf_impl+0x604>
  404c24:	91003f82 	add	x2, x28, #0xf
  404c28:	927df042 	and	x2, x2, #0xfffffffffffffff8
  404c2c:	17fffff9 	b	404c10 <z_cbvprintf_impl+0x5e4>
  404c30:	aa1c03e2 	mov	x2, x28
  404c34:	8b3bc31c 	add	x28, x24, w27, sxtw
  404c38:	17fffff6 	b	404c10 <z_cbvprintf_impl+0x5e4>
			} else if (length_mod == LENGTH_H) {
  404c3c:	7100083f 	cmp	w1, #0x2
  404c40:	54fffb61 	b.ne	404bac <z_cbvprintf_impl+0x580>  // b.any
				value->sint = (short)value->sint;
  404c44:	93403c00 	sxth	x0, w0
  404c48:	17ffffd8 	b	404ba8 <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_UINT) {
  404c4c:	7100081f 	cmp	w0, #0x2
  404c50:	540008c1 	b.ne	404d68 <z_cbvprintf_impl+0x73c>  // b.any
			switch (length_mod) {
  404c54:	51000c22 	sub	w2, w1, #0x3
  404c58:	7100105f 	cmp	w2, #0x4
  404c5c:	540000e8 	b.hi	404c78 <z_cbvprintf_impl+0x64c>  // b.pmore
  404c60:	90000080 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  404c64:	911fd000 	add	x0, x0, #0x7f4
  404c68:	38624800 	ldrb	w0, [x0, w2, uxtw]
  404c6c:	10000062 	adr	x2, 404c78 <z_cbvprintf_impl+0x64c>
  404c70:	8b208840 	add	x0, x2, w0, sxtb #2
  404c74:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
  404c78:	37f8019b 	tbnz	w27, #31, 404ca8 <z_cbvprintf_impl+0x67c>
  404c7c:	91002f82 	add	x2, x28, #0xb
  404c80:	2a1b03e3 	mov	w3, w27
  404c84:	927df042 	and	x2, x2, #0xfffffffffffffff8
  404c88:	b9400380 	ldr	w0, [x28]
  404c8c:	f9004be0 	str	x0, [sp, #144]
				break;
  404c90:	2a0303fb 	mov	w27, w3
  404c94:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  404c98:	7100043f 	cmp	w1, #0x1
  404c9c:	540005e1 	b.ne	404d58 <z_cbvprintf_impl+0x72c>  // b.any
				value->uint = (unsigned char)value->uint;
  404ca0:	92401c00 	and	x0, x0, #0xff
  404ca4:	17ffffc1 	b	404ba8 <z_cbvprintf_impl+0x57c>
				value->uint = va_arg(ap, unsigned int);
  404ca8:	11002363 	add	w3, w27, #0x8
  404cac:	7100007f 	cmp	w3, #0x0
  404cb0:	5400008d 	b.le	404cc0 <z_cbvprintf_impl+0x694>
  404cb4:	91002f82 	add	x2, x28, #0xb
  404cb8:	927df042 	and	x2, x2, #0xfffffffffffffff8
  404cbc:	17fffff3 	b	404c88 <z_cbvprintf_impl+0x65c>
  404cc0:	aa1c03e2 	mov	x2, x28
  404cc4:	8b3bc31c 	add	x28, x24, w27, sxtw
  404cc8:	17fffff0 	b	404c88 <z_cbvprintf_impl+0x65c>
				if ((!WCHAR_IS_SIGNED)
  404ccc:	39428fe0 	ldrb	w0, [sp, #163]
  404cd0:	71018c1f 	cmp	w0, #0x63
  404cd4:	54000ac1 	b.ne	404e2c <z_cbvprintf_impl+0x800>  // b.any
					value->uint = (wchar_t)va_arg(ap,
  404cd8:	37f8011b 	tbnz	w27, #31, 404cf8 <z_cbvprintf_impl+0x6cc>
  404cdc:	91002f80 	add	x0, x28, #0xb
  404ce0:	2a1b03e2 	mov	w2, w27
  404ce4:	927df000 	and	x0, x0, #0xfffffffffffffff8
  404ce8:	b9400383 	ldr	w3, [x28]
			value->ptr = va_arg(ap, void *);
  404cec:	2a0203fb 	mov	w27, w2
  404cf0:	f9004be3 	str	x3, [sp, #144]
  404cf4:	1400003e 	b	404dec <z_cbvprintf_impl+0x7c0>
					value->uint = (wchar_t)va_arg(ap,
  404cf8:	11002362 	add	w2, w27, #0x8
  404cfc:	7100005f 	cmp	w2, #0x0
  404d00:	5400008d 	b.le	404d10 <z_cbvprintf_impl+0x6e4>
  404d04:	91002f80 	add	x0, x28, #0xb
  404d08:	927df000 	and	x0, x0, #0xfffffffffffffff8
  404d0c:	17fffff7 	b	404ce8 <z_cbvprintf_impl+0x6bc>
  404d10:	aa1c03e0 	mov	x0, x28
  404d14:	8b3bc31c 	add	x28, x24, w27, sxtw
  404d18:	17fffff4 	b	404ce8 <z_cbvprintf_impl+0x6bc>
					(uint_value_type)va_arg(ap, size_t);
  404d1c:	37f800db 	tbnz	w27, #31, 404d34 <z_cbvprintf_impl+0x708>
  404d20:	91003f82 	add	x2, x28, #0xf
  404d24:	2a1b03e3 	mov	w3, w27
  404d28:	927df042 	and	x2, x2, #0xfffffffffffffff8
  404d2c:	f9400380 	ldr	x0, [x28]
  404d30:	17ffffd7 	b	404c8c <z_cbvprintf_impl+0x660>
  404d34:	11002363 	add	w3, w27, #0x8
  404d38:	7100007f 	cmp	w3, #0x0
  404d3c:	5400008d 	b.le	404d4c <z_cbvprintf_impl+0x720>
  404d40:	91003f82 	add	x2, x28, #0xf
  404d44:	927df042 	and	x2, x2, #0xfffffffffffffff8
  404d48:	17fffff9 	b	404d2c <z_cbvprintf_impl+0x700>
  404d4c:	aa1c03e2 	mov	x2, x28
  404d50:	8b3bc31c 	add	x28, x24, w27, sxtw
  404d54:	17fffff6 	b	404d2c <z_cbvprintf_impl+0x700>
			} else if (length_mod == LENGTH_H) {
  404d58:	7100083f 	cmp	w1, #0x2
  404d5c:	54fff281 	b.ne	404bac <z_cbvprintf_impl+0x580>  // b.any
				value->uint = (unsigned short)value->uint;
  404d60:	92403c00 	and	x0, x0, #0xffff
  404d64:	17ffff91 	b	404ba8 <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_FP) {
  404d68:	7100101f 	cmp	w0, #0x4
  404d6c:	540005c1 	b.ne	404e24 <z_cbvprintf_impl+0x7f8>  // b.any
				value->ldbl = va_arg(ap, long double);
  404d70:	b94067e0 	ldr	w0, [sp, #100]
			if (length_mod == LENGTH_UPPER_L) {
  404d74:	7100203f 	cmp	w1, #0x8
  404d78:	540002c1 	b.ne	404dd0 <z_cbvprintf_impl+0x7a4>  // b.any
				value->ldbl = va_arg(ap, long double);
  404d7c:	37f80120 	tbnz	w0, #31, 404da0 <z_cbvprintf_impl+0x774>
  404d80:	91003f80 	add	x0, x28, #0xf
  404d84:	b94067e2 	ldr	w2, [sp, #100]
  404d88:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  404d8c:	9100401c 	add	x28, x0, #0x10
  404d90:	3dc00000 	ldr	q0, [x0]
  404d94:	b90067e2 	str	w2, [sp, #100]
  404d98:	3d8027e0 	str	q0, [sp, #144]
  404d9c:	17ffff84 	b	404bac <z_cbvprintf_impl+0x580>
  404da0:	b94067e0 	ldr	w0, [sp, #100]
  404da4:	11004002 	add	w2, w0, #0x10
  404da8:	7100005f 	cmp	w2, #0x0
  404dac:	540000ad 	b.le	404dc0 <z_cbvprintf_impl+0x794>
  404db0:	91003f80 	add	x0, x28, #0xf
  404db4:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  404db8:	9100401c 	add	x28, x0, #0x10
  404dbc:	17fffff5 	b	404d90 <z_cbvprintf_impl+0x764>
  404dc0:	f9403be3 	ldr	x3, [sp, #112]
  404dc4:	b94067e0 	ldr	w0, [sp, #100]
  404dc8:	8b20c060 	add	x0, x3, w0, sxtw
  404dcc:	17fffff1 	b	404d90 <z_cbvprintf_impl+0x764>
				value->dbl = va_arg(ap, double);
  404dd0:	37f80120 	tbnz	w0, #31, 404df4 <z_cbvprintf_impl+0x7c8>
  404dd4:	91003f80 	add	x0, x28, #0xf
  404dd8:	b94067e2 	ldr	w2, [sp, #100]
  404ddc:	927df000 	and	x0, x0, #0xfffffffffffffff8
  404de0:	fd400380 	ldr	d0, [x28]
  404de4:	b90067e2 	str	w2, [sp, #100]
  404de8:	fd004be0 	str	d0, [sp, #144]
			value->ptr = va_arg(ap, void *);
  404dec:	aa0003fc 	mov	x28, x0
  404df0:	17ffff6f 	b	404bac <z_cbvprintf_impl+0x580>
				value->dbl = va_arg(ap, double);
  404df4:	b94067e0 	ldr	w0, [sp, #100]
  404df8:	11004002 	add	w2, w0, #0x10
  404dfc:	7100005f 	cmp	w2, #0x0
  404e00:	5400008d 	b.le	404e10 <z_cbvprintf_impl+0x7e4>
  404e04:	91003f80 	add	x0, x28, #0xf
  404e08:	927df000 	and	x0, x0, #0xfffffffffffffff8
  404e0c:	17fffff5 	b	404de0 <z_cbvprintf_impl+0x7b4>
  404e10:	f9403be4 	ldr	x4, [sp, #112]
  404e14:	aa1c03e0 	mov	x0, x28
  404e18:	b94067e3 	ldr	w3, [sp, #100]
  404e1c:	8b23c09c 	add	x28, x4, w3, sxtw
  404e20:	17fffff0 	b	404de0 <z_cbvprintf_impl+0x7b4>
		} else if (specifier_cat == SPECIFIER_PTR) {
  404e24:	71000c1f 	cmp	w0, #0x3
  404e28:	54ffec21 	b.ne	404bac <z_cbvprintf_impl+0x580>  // b.any
			value->ptr = va_arg(ap, void *);
  404e2c:	37f800db 	tbnz	w27, #31, 404e44 <z_cbvprintf_impl+0x818>
  404e30:	91003f80 	add	x0, x28, #0xf
  404e34:	2a1b03e2 	mov	w2, w27
  404e38:	927df000 	and	x0, x0, #0xfffffffffffffff8
  404e3c:	f9400383 	ldr	x3, [x28]
  404e40:	17ffffab 	b	404cec <z_cbvprintf_impl+0x6c0>
  404e44:	11002362 	add	w2, w27, #0x8
  404e48:	7100005f 	cmp	w2, #0x0
  404e4c:	5400008d 	b.le	404e5c <z_cbvprintf_impl+0x830>
  404e50:	91003f80 	add	x0, x28, #0xf
  404e54:	927df000 	and	x0, x0, #0xfffffffffffffff8
  404e58:	17fffff9 	b	404e3c <z_cbvprintf_impl+0x810>
  404e5c:	aa1c03e0 	mov	x0, x28
  404e60:	8b3bc31c 	add	x28, x24, w27, sxtw
  404e64:	17fffff6 	b	404e3c <z_cbvprintf_impl+0x810>
		switch (conv->specifier) {
  404e68:	39428fe0 	ldrb	w0, [sp, #163]
  404e6c:	7101e01f 	cmp	w0, #0x78
  404e70:	54ffeb28 	b.hi	404bd4 <z_cbvprintf_impl+0x5a8>  // b.pmore
  404e74:	7101881f 	cmp	w0, #0x62
  404e78:	540000e8 	b.hi	404e94 <z_cbvprintf_impl+0x868>  // b.pmore
  404e7c:	7100941f 	cmp	w0, #0x25
  404e80:	54ffc220 	b.eq	4046c4 <z_cbvprintf_impl+0x98>  // b.none
  404e84:	7101601f 	cmp	w0, #0x58
  404e88:	54ffea61 	b.ne	404bd4 <z_cbvprintf_impl+0x5a8>  // b.any
  404e8c:	52800006 	mov	w6, #0x0                   	// #0
  404e90:	14000043 	b	404f9c <z_cbvprintf_impl+0x970>
  404e94:	51018c00 	sub	w0, w0, #0x63
  404e98:	7100541f 	cmp	w0, #0x15
  404e9c:	54ffe9c8 	b.hi	404bd4 <z_cbvprintf_impl+0x5a8>  // b.pmore
  404ea0:	90000082 	adrp	x2, 414000 <sys_clock_tick_get+0x78>
  404ea4:	911ff042 	add	x2, x2, #0x7fc
  404ea8:	78605842 	ldrh	w2, [x2, w0, uxtw #1]
  404eac:	10000060 	adr	x0, 404eb8 <z_cbvprintf_impl+0x88c>
  404eb0:	8b22a802 	add	x2, x0, w2, sxth #2
  404eb4:	d61f0040 	br	x2
			bps = (const char *)value->ptr;
  404eb8:	f9404bf5 	ldr	x21, [sp, #144]
			if (precision >= 0) {
  404ebc:	37f80497 	tbnz	w23, #31, 404f4c <z_cbvprintf_impl+0x920>
				len = strnlen(bps, precision);
  404ec0:	93407ee1 	sxtw	x1, w23
  404ec4:	aa1503e0 	mov	x0, x21
  404ec8:	97fff11e 	bl	401340 <strnlen@plt>
			bpe = bps + len;
  404ecc:	8b0002b7 	add	x23, x21, x0
		char sign = 0;
  404ed0:	52800006 	mov	w6, #0x0                   	// #0
		if (bps == NULL) {
  404ed4:	b4ffe815 	cbz	x21, 404bd4 <z_cbvprintf_impl+0x5a8>
		size_t nj_len = (bpe - bps);
  404ed8:	cb1502e0 	sub	x0, x23, x21
		if (sign != 0) {
  404edc:	34000046 	cbz	w6, 404ee4 <z_cbvprintf_impl+0x8b8>
			nj_len += 1U;
  404ee0:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
  404ee4:	39428be2 	ldrb	w2, [sp, #162]
  404ee8:	36200ce2 	tbz	w2, #4, 405084 <z_cbvprintf_impl+0xa58>
			nj_len += 2U;
  404eec:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
  404ef0:	b980a7e1 	ldrsw	x1, [sp, #164]
  404ef4:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
  404ef8:	36300062 	tbz	w2, #6, 404f04 <z_cbvprintf_impl+0x8d8>
			nj_len += conv->pad0_pre_exp;
  404efc:	b980abe1 	ldrsw	x1, [sp, #168]
  404f00:	8b010000 	add	x0, x0, x1
		if (width > 0) {
  404f04:	710002df 	cmp	w22, #0x0
  404f08:	54000dad 	b.le	4050bc <z_cbvprintf_impl+0xa90>
			width -= (int)nj_len;
  404f0c:	4b0002d6 	sub	w22, w22, w0
			if (!conv->flag_dash) {
  404f10:	f94053e0 	ldr	x0, [sp, #160]
  404f14:	721e001f 	tst	w0, #0x4
  404f18:	54000d21 	b.ne	4050bc <z_cbvprintf_impl+0xa90>  // b.any
				if (conv->flag_zero) {
  404f1c:	794143e0 	ldrh	w0, [sp, #160]
  404f20:	36301280 	tbz	w0, #6, 405170 <z_cbvprintf_impl+0xb44>
					if (sign != 0) {
  404f24:	340012a6 	cbz	w6, 405178 <z_cbvprintf_impl+0xb4c>
						OUTC(sign);
  404f28:	aa1a03e1 	mov	x1, x26
  404f2c:	2a0603e0 	mov	w0, w6
  404f30:	d63f0320 	blr	x25
  404f34:	37ffbb20 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  404f38:	91000673 	add	x19, x19, #0x1
					pad = '0';
  404f3c:	52800602 	mov	w2, #0x30                  	// #48
						OUTC(sign);
  404f40:	52800006 	mov	w6, #0x0                   	// #0
					pad = '0';
  404f44:	2a1603e0 	mov	w0, w22
  404f48:	1400005a 	b	4050b0 <z_cbvprintf_impl+0xa84>
				len = strlen(bps);
  404f4c:	aa1503e0 	mov	x0, x21
  404f50:	97fff0ec 	bl	401300 <strlen@plt>
  404f54:	17ffffde 	b	404ecc <z_cbvprintf_impl+0x8a0>
			bps = buf;
  404f58:	9102c3f5 	add	x21, sp, #0xb0
			bpe = buf + 1;
  404f5c:	9102c7f7 	add	x23, sp, #0xb1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  404f60:	f9404be0 	ldr	x0, [sp, #144]
  404f64:	3902c3e0 	strb	w0, [sp, #176]
			break;
  404f68:	52800006 	mov	w6, #0x0                   	// #0
  404f6c:	17ffffdb 	b	404ed8 <z_cbvprintf_impl+0x8ac>
			if (conv->flag_plus) {
  404f70:	794143e0 	ldrh	w0, [sp, #160]
			} else if (conv->flag_space) {
  404f74:	d3441006 	ubfx	x6, x0, #4, #1
  404f78:	f27d001f 	tst	x0, #0x8
  404f7c:	52800560 	mov	w0, #0x2b                  	// #43
  404f80:	531b68c6 	lsl	w6, w6, #5
  404f84:	1a8000c6 	csel	w6, w6, w0, eq  // eq = none
			sint = value->sint;
  404f88:	f9404be0 	ldr	x0, [sp, #144]
			if (sint < 0) {
  404f8c:	b6f80080 	tbz	x0, #63, 404f9c <z_cbvprintf_impl+0x970>
				value->uint = (uint_value_type)-sint;
  404f90:	cb0003e0 	neg	x0, x0
				sign = '-';
  404f94:	528005a6 	mov	w6, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
  404f98:	f9004be0 	str	x0, [sp, #144]
			bps = encode_uint(value->uint, conv, buf, bpe);
  404f9c:	f94037e3 	ldr	x3, [sp, #104]
  404fa0:	9102c3e2 	add	x2, sp, #0xb0
  404fa4:	f9404be0 	ldr	x0, [sp, #144]
  404fa8:	910283e1 	add	x1, sp, #0xa0
  404fac:	b9007be6 	str	w6, [sp, #120]
  404fb0:	97fffd60 	bl	404530 <encode_uint>
  404fb4:	aa0003f5 	mov	x21, x0
  404fb8:	b9407be6 	ldr	w6, [sp, #120]
			if (precision >= 0) {
  404fbc:	37f80157 	tbnz	w23, #31, 404fe4 <z_cbvprintf_impl+0x9b8>
				size_t len = bpe - bps;
  404fc0:	f94037e0 	ldr	x0, [sp, #104]
				conv->flag_zero = false;
  404fc4:	794143e1 	ldrh	w1, [sp, #160]
				size_t len = bpe - bps;
  404fc8:	cb150000 	sub	x0, x0, x21
				conv->flag_zero = false;
  404fcc:	12197821 	and	w1, w1, #0xffffffbf
  404fd0:	790143e1 	strh	w1, [sp, #160]
				if (len < (size_t)precision) {
  404fd4:	eb37c01f 	cmp	x0, w23, sxtw
  404fd8:	54000062 	b.cs	404fe4 <z_cbvprintf_impl+0x9b8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
  404fdc:	4b0002e0 	sub	w0, w23, w0
  404fe0:	b900a7e0 	str	w0, [sp, #164]
		const char *bpe = buf + sizeof(buf);
  404fe4:	f94037f7 	ldr	x23, [sp, #104]
  404fe8:	17ffffbb 	b	404ed4 <z_cbvprintf_impl+0x8a8>
			if (value->ptr != NULL) {
  404fec:	f9404be0 	ldr	x0, [sp, #144]
  404ff0:	b4000400 	cbz	x0, 405070 <z_cbvprintf_impl+0xa44>
				bps = encode_uint((uintptr_t)value->ptr, conv,
  404ff4:	f94037e3 	ldr	x3, [sp, #104]
  404ff8:	910283e1 	add	x1, sp, #0xa0
  404ffc:	9102c3e2 	add	x2, sp, #0xb0
  405000:	97fffd4c 	bl	404530 <encode_uint>
  405004:	aa0003f5 	mov	x21, x0
				conv->altform_0c = true;
  405008:	794147e0 	ldrh	w0, [sp, #162]
  40500c:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
  405010:	52800006 	mov	w6, #0x0                   	// #0
				conv->altform_0c = true;
  405014:	0a010000 	and	w0, w0, w1
  405018:	528f0201 	mov	w1, #0x7810                	// #30736
  40501c:	2a010000 	orr	w0, w0, w1
  405020:	790147e0 	strh	w0, [sp, #162]
				goto prec_int_pad0;
  405024:	17ffffe6 	b	404fbc <z_cbvprintf_impl+0x990>
				store_count(conv, value->ptr, count);
  405028:	93407e60 	sxtw	x0, w19
  40502c:	f9404be2 	ldr	x2, [sp, #144]
	switch ((enum length_mod_enum)conv->length_mod) {
  405030:	71001c3f 	cmp	w1, #0x7
  405034:	54ffdd08 	b.hi	404bd4 <z_cbvprintf_impl+0x5a8>  // b.pmore
  405038:	f0000063 	adrp	x3, 414000 <sys_clock_tick_get+0x78>
  40503c:	9120a063 	add	x3, x3, #0x828
  405040:	38614863 	ldrb	w3, [x3, w1, uxtw]
  405044:	10000061 	adr	x1, 405050 <z_cbvprintf_impl+0xa24>
  405048:	8b238823 	add	x3, x1, w3, sxtb #2
  40504c:	d61f0060 	br	x3
		*(int *)dp = count;
  405050:	b9000040 	str	w0, [x2]
		break;
  405054:	17fffee0 	b	404bd4 <z_cbvprintf_impl+0x5a8>
		*(signed char *)dp = (signed char)count;
  405058:	39000053 	strb	w19, [x2]
		break;
  40505c:	17fffede 	b	404bd4 <z_cbvprintf_impl+0x5a8>
		*(short *)dp = (short)count;
  405060:	79000053 	strh	w19, [x2]
		break;
  405064:	17fffedc 	b	404bd4 <z_cbvprintf_impl+0x5a8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
  405068:	f9000040 	str	x0, [x2]
		break;
  40506c:	17fffeda 	b	404bd4 <z_cbvprintf_impl+0x5a8>
			bps = "(nil)";
  405070:	f0000075 	adrp	x21, 414000 <sys_clock_tick_get+0x78>
			bpe = bps + 5;
  405074:	f0000077 	adrp	x23, 414000 <sys_clock_tick_get+0x78>
			bps = "(nil)";
  405078:	913fceb5 	add	x21, x21, #0xff3
			bpe = bps + 5;
  40507c:	913fe2f7 	add	x23, x23, #0xff8
  405080:	17ffffba 	b	404f68 <z_cbvprintf_impl+0x93c>
		} else if (conv->altform_0) {
  405084:	361ff362 	tbz	w2, #3, 404ef0 <z_cbvprintf_impl+0x8c4>
			nj_len += 1U;
  405088:	91000400 	add	x0, x0, #0x1
  40508c:	17ffff99 	b	404ef0 <z_cbvprintf_impl+0x8c4>
  405090:	290f1be2 	stp	w2, w6, [sp, #120]
					OUTC(pad);
  405094:	aa1a03e1 	mov	x1, x26
  405098:	2a0203e0 	mov	w0, w2
  40509c:	d63f0320 	blr	x25
  4050a0:	37ffafc0 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  4050a4:	294f1be2 	ldp	w2, w6, [sp, #120]
  4050a8:	91000673 	add	x19, x19, #0x1
				while (width-- > 0) {
  4050ac:	2a1603e0 	mov	w0, w22
  4050b0:	510006d6 	sub	w22, w22, #0x1
  4050b4:	7100001f 	cmp	w0, #0x0
  4050b8:	54fffecc 	b.gt	405090 <z_cbvprintf_impl+0xa64>
		if (sign != 0) {
  4050bc:	340000c6 	cbz	w6, 4050d4 <z_cbvprintf_impl+0xaa8>
			OUTC(sign);
  4050c0:	aa1a03e1 	mov	x1, x26
  4050c4:	2a0603e0 	mov	w0, w6
  4050c8:	d63f0320 	blr	x25
  4050cc:	37ffae60 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  4050d0:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c | conv->altform_0) {
  4050d4:	f94053e0 	ldr	x0, [sp, #160]
  4050d8:	d3545001 	ubfx	x1, x0, #20, #1
  4050dc:	d3534c00 	ubfx	x0, x0, #19, #1
  4050e0:	2a000020 	orr	w0, w1, w0
  4050e4:	360000c0 	tbz	w0, #0, 4050fc <z_cbvprintf_impl+0xad0>
				OUTC('0');
  4050e8:	aa1a03e1 	mov	x1, x26
  4050ec:	52800600 	mov	w0, #0x30                  	// #48
  4050f0:	d63f0320 	blr	x25
  4050f4:	37ffad20 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  4050f8:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c) {
  4050fc:	39428be0 	ldrb	w0, [sp, #162]
  405100:	362000c0 	tbz	w0, #4, 405118 <z_cbvprintf_impl+0xaec>
				OUTC(conv->specifier);
  405104:	39428fe0 	ldrb	w0, [sp, #163]
  405108:	aa1a03e1 	mov	x1, x26
  40510c:	d63f0320 	blr	x25
  405110:	37ffac40 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  405114:	91000673 	add	x19, x19, #0x1
			while (pad_len-- > 0) {
  405118:	b940a7e2 	ldr	w2, [sp, #164]
  40511c:	0b130042 	add	w2, w2, w19
  405120:	4b130040 	sub	w0, w2, w19
  405124:	7100001f 	cmp	w0, #0x0
  405128:	540002cc 	b.gt	405180 <z_cbvprintf_impl+0xb54>
			OUTS(bps, bpe);
  40512c:	aa1703e3 	mov	x3, x23
  405130:	aa1503e2 	mov	x2, x21
  405134:	aa1a03e1 	mov	x1, x26
  405138:	aa1903e0 	mov	x0, x25
  40513c:	97fffccd 	bl	404470 <outs>
  405140:	37ffaac0 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  405144:	8b20c273 	add	x19, x19, w0, sxtw
		while (width > 0) {
  405148:	0b1302d6 	add	w22, w22, w19
  40514c:	4b1302c0 	sub	w0, w22, w19
  405150:	7100001f 	cmp	w0, #0x0
  405154:	54ffd40d 	b.le	404bd4 <z_cbvprintf_impl+0x5a8>
			OUTC(' ');
  405158:	aa1a03e1 	mov	x1, x26
  40515c:	52800400 	mov	w0, #0x20                  	// #32
  405160:	d63f0320 	blr	x25
  405164:	37ffa9a0 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  405168:	91000673 	add	x19, x19, #0x1
			--width;
  40516c:	17fffff8 	b	40514c <z_cbvprintf_impl+0xb20>
				char pad = ' ';
  405170:	52800402 	mov	w2, #0x20                  	// #32
  405174:	17ffff74 	b	404f44 <z_cbvprintf_impl+0x918>
					pad = '0';
  405178:	52800602 	mov	w2, #0x30                  	// #48
  40517c:	17ffff72 	b	404f44 <z_cbvprintf_impl+0x918>
  405180:	b9007be2 	str	w2, [sp, #120]
				OUTC('0');
  405184:	aa1a03e1 	mov	x1, x26
  405188:	52800600 	mov	w0, #0x30                  	// #48
  40518c:	d63f0320 	blr	x25
  405190:	37ffa840 	tbnz	w0, #31, 404698 <z_cbvprintf_impl+0x6c>
  405194:	b9407be2 	ldr	w2, [sp, #120]
  405198:	91000673 	add	x19, x19, #0x1
  40519c:	17ffffe1 	b	405120 <z_cbvprintf_impl+0xaf4>
}
  4051a0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4051a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4051a8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4051ac:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4051b0:	a94573fb 	ldp	x27, x28, [sp, #80]
  4051b4:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  4051b8:	d65f03c0 	ret

00000000004051bc <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
  4051bc:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  4051c0:	910003fd 	mov	x29, sp
  4051c4:	a90e8be1 	stp	x1, x2, [sp, #232]
  4051c8:	f0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4051cc:	f9478421 	ldr	x1, [x1, #3848]
  4051d0:	3d801be0 	str	q0, [sp, #96]
  4051d4:	3d801fe1 	str	q1, [sp, #112]
  4051d8:	3d8023e2 	str	q2, [sp, #128]
  4051dc:	3d8027e3 	str	q3, [sp, #144]
  4051e0:	3d802be4 	str	q4, [sp, #160]
  4051e4:	3d802fe5 	str	q5, [sp, #176]
  4051e8:	3d8033e6 	str	q6, [sp, #192]
  4051ec:	3d8037e7 	str	q7, [sp, #208]
  4051f0:	a90f93e3 	stp	x3, x4, [sp, #248]
  4051f4:	a9109be5 	stp	x5, x6, [sp, #264]
  4051f8:	f9008fe7 	str	x7, [sp, #280]
  4051fc:	f9400022 	ldr	x2, [x1]
  405200:	f9002fe2 	str	x2, [sp, #88]
  405204:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  405208:	910483e1 	add	x1, sp, #0x120
  40520c:	a90387e1 	stp	x1, x1, [sp, #56]
  405210:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  405214:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  405218:	f90027e1 	str	x1, [sp, #72]
  40521c:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  405220:	b90053e1 	str	w1, [sp, #80]
  405224:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  405228:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  40522c:	910043e1 	add	x1, sp, #0x10
  405230:	ad400440 	ldp	q0, q1, [x2]
  405234:	ad000420 	stp	q0, q1, [x1]
  405238:	97fffa9c 	bl	403ca8 <vprintk>

	va_end(ap);
}
  40523c:	f0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  405240:	f9478400 	ldr	x0, [x0, #3848]
  405244:	f9402fe2 	ldr	x2, [sp, #88]
  405248:	f9400001 	ldr	x1, [x0]
  40524c:	eb010042 	subs	x2, x2, x1
  405250:	d2800001 	mov	x1, #0x0                   	// #0
  405254:	54000040 	b.eq	40525c <assert_print+0xa0>  // b.none
  405258:	97fff096 	bl	4014b0 <__stack_chk_fail@plt>
  40525c:	a8d27bfd 	ldp	x29, x30, [sp], #288
  405260:	d65f03c0 	ret

0000000000405264 <assert_post_action>:
{
  405264:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	k_panic();
  405268:	52800562 	mov	w2, #0x2b                  	// #43
  40526c:	f0000061 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
{
  405270:	910003fd 	mov	x29, sp
	k_panic();
  405274:	913fe421 	add	x1, x1, #0xff9
  405278:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40527c:	91358400 	add	x0, x0, #0xd61
  405280:	97ffffcf 	bl	4051bc <assert_print>
}
  405284:	a8c17bfd 	ldp	x29, x30, [sp], #16
	k_panic();
  405288:	d2800001 	mov	x1, #0x0                   	// #0
  40528c:	52800080 	mov	w0, #0x4                   	// #4
  405290:	14002584 	b	40e8a0 <z_fatal_error>

0000000000405294 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_EXPERIMENTAL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  405294:	d65f03c0 	ret

0000000000405298 <dummy_timestamp>:
static void msg_process(union log_msg_generic *msg);

static log_timestamp_t dummy_timestamp(void)
{
	return 0;
}
  405298:	52800000 	mov	w0, #0x0                   	// #0
  40529c:	d65f03c0 	ret

00000000004052a0 <default_get_timestamp>:

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
  4052a0:	1400174b 	b	40afcc <sys_clock_cycle_get_32>

00000000004052a4 <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  4052a4:	f9400400 	ldr	x0, [x0, #8]
}
  4052a8:	39402400 	ldrb	w0, [x0, #9]
  4052ac:	d65f03c0 	ret

00000000004052b0 <log_backend_is_ready>:
	if (backend->api->is_ready != NULL) {
  4052b0:	f9400001 	ldr	x1, [x0]
  4052b4:	f9401021 	ldr	x1, [x1, #32]
  4052b8:	b4000061 	cbz	x1, 4052c4 <log_backend_is_ready+0x14>
		return backend->api->is_ready(backend);
  4052bc:	aa0103f0 	mov	x16, x1
  4052c0:	d61f0200 	br	x16
}
  4052c4:	52800000 	mov	w0, #0x0                   	// #0
  4052c8:	d65f03c0 	ret

00000000004052cc <z_log_init.isra.0>:
	}

	return mask;
}

static uint32_t z_log_init(bool blocking, bool can_sleep)
  4052cc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4052d0:	910003fd 	mov	x29, sp
  4052d4:	a9025bf5 	stp	x21, x22, [sp, #32]
	STRUCT_SECTION_COUNT(log_backend, &cnt);
  4052d8:	f0000136 	adrp	x22, 42c000 <__FRAME_END__+0xfbbc>
  4052dc:	f0000135 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
  4052e0:	f947fed6 	ldr	x22, [x22, #4088]
  4052e4:	a90153f3 	stp	x19, x20, [sp, #16]
  4052e8:	f947c6b3 	ldr	x19, [x21, #3976]
  4052ec:	a9046bf9 	stp	x25, x26, [sp, #64]
  4052f0:	12001c19 	and	w25, w0, #0xff
  4052f4:	cb1302c0 	sub	x0, x22, x19
  4052f8:	a90363f7 	stp	x23, x24, [sp, #48]
  4052fc:	d345fc00 	lsr	x0, x0, #5

	if (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY)) {
		return 0;
	}

	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
  405300:	7100241f 	cmp	w0, #0x9
  405304:	54000249 	b.ls	40534c <z_log_init.isra.0+0x80>  // b.plast
  405308:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  40530c:	91007273 	add	x19, x19, #0x1c
  405310:	aa1303e2 	mov	x2, x19
  405314:	52802323 	mov	w3, #0x119                 	// #281
  405318:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  40531c:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405320:	91012421 	add	x1, x1, #0x49
  405324:	91353400 	add	x0, x0, #0xd4d
  405328:	97ffffa5 	bl	4051bc <assert_print>
  40532c:	aa1303e0 	mov	x0, x19
  405330:	52802321 	mov	w1, #0x119                 	// #281
  405334:	97ffffcc 	bl	405264 <assert_post_action>
  405338:	52802322 	mov	w2, #0x119                 	// #281
		z_log_links_initiate();
	}


	/* Assign ids to backends. */
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  40533c:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405340:	aa1303e1 	mov	x1, x19
  405344:	91362c00 	add	x0, x0, #0xd8b
  405348:	940009b9 	bl	407a2c <posix_print_error_and_exit>
  40534c:	12001c37 	and	w23, w1, #0xff
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  405350:	d2800020 	mov	x0, #0x1                   	// #1
  405354:	b0000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  405358:	91268021 	add	x1, x1, #0x9a0
  40535c:	97fff11d 	bl	4017d0 <__aarch64_ldadd8_acq_rel>
	if (atomic_inc(&initialized) != 0) {
  405360:	b40005c0 	cbz	x0, 405418 <z_log_init.isra.0+0x14c>
			}
		}
	}

	return mask;
}
  405364:	a94153f3 	ldp	x19, x20, [sp, #16]
  405368:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40536c:	a94363f7 	ldp	x23, x24, [sp, #48]
  405370:	a9446bf9 	ldp	x25, x26, [sp, #64]
  405374:	a8c57bfd 	ldp	x29, x30, [sp], #80
  405378:	d65f03c0 	ret
		if (backend->autostart) {
  40537c:	39406260 	ldrb	w0, [x19, #24]
  405380:	340001e0 	cbz	w0, 4053bc <z_log_init.isra.0+0xf0>
	if (backend->api->init) {
  405384:	f9400260 	ldr	x0, [x19]
  405388:	f9400c01 	ldr	x1, [x0, #24]
  40538c:	b4000061 	cbz	x1, 405398 <z_log_init.isra.0+0xcc>
		backend->api->init(backend);
  405390:	aa1303e0 	mov	x0, x19
  405394:	d63f0020 	blr	x1
			if (log_backend_is_ready(backend) == 0) {
  405398:	aa1303e0 	mov	x0, x19
  40539c:	97ffffc5 	bl	4052b0 <log_backend_is_ready>
  4053a0:	35000360 	cbnz	w0, 40540c <z_log_init.isra.0+0x140>
				log_backend_enable(backend,
  4053a4:	f9400660 	ldr	x0, [x19, #8]
  4053a8:	52800082 	mov	w2, #0x4                   	// #4
  4053ac:	f9400001 	ldr	x1, [x0]
  4053b0:	aa1303e0 	mov	x0, x19
  4053b4:	94000125 	bl	405848 <log_backend_enable>
			i++;
  4053b8:	11000718 	add	w24, w24, #0x1
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4053bc:	91008273 	add	x19, x19, #0x20
  4053c0:	eb16027f 	cmp	x19, x22
  4053c4:	54000329 	b.ls	405428 <z_log_init.isra.0+0x15c>  // b.plast
  4053c8:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  4053cc:	91007273 	add	x19, x19, #0x1c
  4053d0:	aa1303e2 	mov	x2, x19
  4053d4:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  4053d8:	9101b421 	add	x1, x1, #0x6d
  4053dc:	528024c3 	mov	w3, #0x126                 	// #294
  4053e0:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4053e4:	91353400 	add	x0, x0, #0xd4d
  4053e8:	97ffff75 	bl	4051bc <assert_print>
  4053ec:	90000080 	adrp	x0, 415000 <__func__.2+0x30c>
  4053f0:	91023800 	add	x0, x0, #0x8e
  4053f4:	97ffff72 	bl	4051bc <assert_print>
  4053f8:	aa1303e0 	mov	x0, x19
  4053fc:	528024c1 	mov	w1, #0x126                 	// #294
  405400:	97ffff99 	bl	405264 <assert_post_action>
  405404:	528024c2 	mov	w2, #0x126                 	// #294
  405408:	17ffffcd 	b	40533c <z_log_init.isra.0+0x70>
				mask |= BIT(i);
  40540c:	9ad82340 	lsl	x0, x26, x24
  405410:	2a000294 	orr	w20, w20, w0
  405414:	17ffffe9 	b	4053b8 <z_log_init.isra.0+0xec>
	int i = 0;
  405418:	52800018 	mov	w24, #0x0                   	// #0
	uint32_t mask = 0;
  40541c:	52800014 	mov	w20, #0x0                   	// #0
				mask |= BIT(i);
  405420:	d280003a 	mov	x26, #0x1                   	// #1
  405424:	17ffffe7 	b	4053c0 <z_log_init.isra.0+0xf4>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  405428:	54fffaa3 	b.cc	40537c <z_log_init.isra.0+0xb0>  // b.lo, b.ul, b.last
	if (blocking) {
  40542c:	34fff9d9 	cbz	w25, 405364 <z_log_init.isra.0+0x98>
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  405430:	f947c6b5 	ldr	x21, [x21, #3976]
		mask_cpy &= ~BIT(i);
  405434:	d2800039 	mov	x25, #0x1                   	// #1
		while (mask) {
  405438:	34fff974 	cbz	w20, 405364 <z_log_init.isra.0+0x98>
  40543c:	2a1403f8 	mov	w24, w20
		uint32_t i = __builtin_ctz(mask_cpy);
  405440:	5ac00280 	rbit	w0, w20
  405444:	5ac01000 	clz	w0, w0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  405448:	d37b1416 	ubfiz	x22, x0, #5, #6
		mask_cpy &= ~BIT(i);
  40544c:	9ac02321 	lsl	x1, x25, x0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  405450:	8b1602b6 	add	x22, x21, x22
		mask_cpy &= ~BIT(i);
  405454:	2a2103fa 	mvn	w26, w1
  405458:	0a210294 	bic	w20, w20, w1
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  40545c:	394062c1 	ldrb	w1, [x22, #24]
  405460:	34000181 	cbz	w1, 405490 <z_log_init.isra.0+0x1c4>
	STRUCT_SECTION_GET(log_backend, idx, &backend);
  405464:	937b7c00 	sbfiz	x0, x0, #5, #32
  405468:	8b150013 	add	x19, x0, x21
  40546c:	aa1303e0 	mov	x0, x19
  405470:	97ffff90 	bl	4052b0 <log_backend_is_ready>
  405474:	350000e0 	cbnz	w0, 405490 <z_log_init.isra.0+0x1c4>
			log_backend_enable(backend,
  405478:	f94006c0 	ldr	x0, [x22, #8]
			mask &= ~BIT(i);
  40547c:	0a1a0318 	and	w24, w24, w26
			log_backend_enable(backend,
  405480:	52800082 	mov	w2, #0x4                   	// #4
  405484:	f9400001 	ldr	x1, [x0]
  405488:	aa1303e0 	mov	x0, x19
  40548c:	940000ef 	bl	405848 <log_backend_enable>
	while (mask_cpy) {
  405490:	35fffd94 	cbnz	w20, 405440 <z_log_init.isra.0+0x174>
			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
  405494:	34000077 	cbz	w23, 4054a0 <z_log_init.isra.0+0x1d4>
	return z_impl_k_sleep(timeout);
  405498:	d2800020 	mov	x0, #0x1                   	// #1
  40549c:	94003708 	bl	4130bc <z_impl_k_sleep>
  4054a0:	2a1803f4 	mov	w20, w24
  4054a4:	17ffffe5 	b	405438 <z_log_init.isra.0+0x16c>

00000000004054a8 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(void)
{
  4054a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
				COND_CODE_1(CONFIG_LOG_PROCESS_THREAD,
					K_MSEC(CONFIG_LOG_PROCESS_THREAD_STARTUP_DELAY_MS),
					K_NO_WAIT));
		k_thread_name_set(&logging_thread, "logging");
	} else {
		(void)z_log_init(false, false);
  4054ac:	52800001 	mov	w1, #0x0                   	// #0
  4054b0:	52800000 	mov	w0, #0x0                   	// #0
{
  4054b4:	910003fd 	mov	x29, sp
		(void)z_log_init(false, false);
  4054b8:	97ffff85 	bl	4052cc <z_log_init.isra.0>
	}

	return 0;
}
  4054bc:	52800000 	mov	w0, #0x0                   	// #0
  4054c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4054c4:	d65f03c0 	ret

00000000004054c8 <log_format_func_t_get>:
}
  4054c8:	f0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4054cc:	91250021 	add	x1, x1, #0x940
  4054d0:	f8605820 	ldr	x0, [x1, w0, uxtw #3]
  4054d4:	d65f03c0 	ret

00000000004054d8 <z_log_vprintk>:
{
  4054d8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4054dc:	aa0003e6 	mov	x6, x0
  4054e0:	910003fd 	mov	x29, sp
  4054e4:	ad400420 	ldp	q0, q1, [x1]
  4054e8:	9100c3e2 	add	x2, sp, #0x30
  4054ec:	ad000440 	stp	q0, q1, [x2]
  4054f0:	ad400440 	ldp	q0, q1, [x2]
  4054f4:	910043e7 	add	x7, sp, #0x10
  4054f8:	52800005 	mov	w5, #0x0                   	// #0
  4054fc:	d2800004 	mov	x4, #0x0                   	// #0
  405500:	d2800003 	mov	x3, #0x0                   	// #0
  405504:	52800002 	mov	w2, #0x0                   	// #0
  405508:	d2800001 	mov	x1, #0x0                   	// #0
  40550c:	52800000 	mov	w0, #0x0                   	// #0
  405510:	ad0004e0 	stp	q0, q1, [x7]
  405514:	9400010a 	bl	40593c <z_impl_z_log_msg_runtime_vcreate>
}
  405518:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40551c:	d65f03c0 	ret

0000000000405520 <log_set_timestamp_func>:
{
  405520:	aa0003e2 	mov	x2, x0
	if (timestamp_getter == NULL) {
  405524:	b4000140 	cbz	x0, 40554c <log_set_timestamp_func+0x2c>
{
  405528:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40552c:	2a0103e0 	mov	w0, w1
	timestamp_func = timestamp_getter;
  405530:	90000141 	adrp	x1, 42d000 <__dso_handle>
{
  405534:	910003fd 	mov	x29, sp
	timestamp_func = timestamp_getter;
  405538:	f9029022 	str	x2, [x1, #1312]
		log_output_timestamp_freq_set(freq);
  40553c:	9400033c 	bl	40622c <log_output_timestamp_freq_set>
	return 0;
  405540:	52800000 	mov	w0, #0x0                   	// #0
}
  405544:	a8c17bfd 	ldp	x29, x30, [sp], #16
  405548:	d65f03c0 	ret
		return -EINVAL;
  40554c:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  405550:	d65f03c0 	ret

0000000000405554 <log_core_init>:
	panic_mode = false;
  405554:	d0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
		log_set_timestamp_func(default_get_timestamp,
  405558:	52884801 	mov	w1, #0x4240                	// #16960
  40555c:	72a001e1 	movk	w1, #0xf, lsl #16
	panic_mode = false;
  405560:	3935981f 	strb	wzr, [x0, #3430]
	dropped_cnt = 0;
  405564:	b0000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  405568:	f904cc1f 	str	xzr, [x0, #2456]
	buffered_cnt = 0;
  40556c:	b0000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  405570:	f904c81f 	str	xzr, [x0, #2448]
		log_set_timestamp_func(default_get_timestamp,
  405574:	90000000 	adrp	x0, 405000 <z_cbvprintf_impl+0x9d4>
  405578:	910a8000 	add	x0, x0, #0x2a0
  40557c:	17ffffe9 	b	405520 <log_set_timestamp_func>

0000000000405580 <z_impl_log_panic>:
{
  405580:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  405584:	910003fd 	mov	x29, sp
  405588:	f90013f5 	str	x21, [sp, #32]
	if (panic_mode) {
  40558c:	d0000155 	adrp	x21, 42f000 <can_loopback_dev_data_0+0xc0>
{
  405590:	a90153f3 	stp	x19, x20, [sp, #16]
	if (panic_mode) {
  405594:	39759aa0 	ldrb	w0, [x21, #3430]
  405598:	35000740 	cbnz	w0, 405680 <z_impl_log_panic+0x100>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  40559c:	f0000133 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  4055a0:	f0000134 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
	(void)z_log_init(true, false);
  4055a4:	52800001 	mov	w1, #0x0                   	// #0
  4055a8:	52800020 	mov	w0, #0x1                   	// #1
  4055ac:	97ffff48 	bl	4052cc <z_log_init.isra.0>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4055b0:	f947c673 	ldr	x19, [x19, #3976]
  4055b4:	f947fe94 	ldr	x20, [x20, #4088]
  4055b8:	eb14027f 	cmp	x19, x20
  4055bc:	540005c9 	b.ls	405674 <z_impl_log_panic+0xf4>  // b.plast
  4055c0:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  4055c4:	91007273 	add	x19, x19, #0x1c
  4055c8:	aa1303e2 	mov	x2, x19
  4055cc:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  4055d0:	9101b421 	add	x1, x1, #0x6d
  4055d4:	52803103 	mov	w3, #0x188                 	// #392
  4055d8:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4055dc:	91353400 	add	x0, x0, #0xd4d
  4055e0:	97fffef7 	bl	4051bc <assert_print>
  4055e4:	90000080 	adrp	x0, 415000 <__func__.2+0x30c>
  4055e8:	91023800 	add	x0, x0, #0x8e
  4055ec:	97fffef4 	bl	4051bc <assert_print>
  4055f0:	aa1303e0 	mov	x0, x19
  4055f4:	52803101 	mov	w1, #0x188                 	// #392
  4055f8:	97ffff1b 	bl	405264 <assert_post_action>
  4055fc:	52803102 	mov	w2, #0x188                 	// #392
  405600:	14000013 	b	40564c <z_impl_log_panic+0xcc>
		if (log_backend_is_active(backend)) {
  405604:	aa1303e0 	mov	x0, x19
  405608:	97ffff27 	bl	4052a4 <log_backend_is_active>
  40560c:	72001c1f 	tst	w0, #0xff
  405610:	540002e0 	b.eq	40566c <z_impl_log_panic+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  405614:	b5000253 	cbnz	x19, 40565c <z_impl_log_panic+0xdc>
  405618:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  40561c:	9102b673 	add	x19, x19, #0xad
  405620:	aa1303e2 	mov	x2, x19
  405624:	52801a03 	mov	w3, #0xd0                  	// #208
  405628:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  40562c:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405630:	91039421 	add	x1, x1, #0xe5
  405634:	91353400 	add	x0, x0, #0xd4d
  405638:	97fffee1 	bl	4051bc <assert_print>
  40563c:	aa1303e0 	mov	x0, x19
  405640:	52801a01 	mov	w1, #0xd0                  	// #208
  405644:	97ffff08 	bl	405264 <assert_post_action>
  405648:	52801a02 	mov	w2, #0xd0                  	// #208
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  40564c:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405650:	aa1303e1 	mov	x1, x19
  405654:	91362c00 	add	x0, x0, #0xd8b
  405658:	940008f5 	bl	407a2c <posix_print_error_and_exit>
	backend->api->panic(backend);
  40565c:	f9400260 	ldr	x0, [x19]
  405660:	f9400801 	ldr	x1, [x0, #16]
  405664:	aa1303e0 	mov	x0, x19
  405668:	d63f0020 	blr	x1
  40566c:	91008273 	add	x19, x19, #0x20
  405670:	17ffffd2 	b	4055b8 <z_impl_log_panic+0x38>
  405674:	54fffc83 	b.cc	405604 <z_impl_log_panic+0x84>  // b.lo, b.ul, b.last
	panic_mode = true;
  405678:	52800020 	mov	w0, #0x1                   	// #1
  40567c:	39359aa0 	strb	w0, [x21, #3430]
}
  405680:	a94153f3 	ldp	x19, x20, [sp, #16]
  405684:	f94013f5 	ldr	x21, [sp, #32]
  405688:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40568c:	d65f03c0 	ret

0000000000405690 <z_log_notify_backend_enabled>:
}
  405690:	d65f03c0 	ret

0000000000405694 <z_impl_log_process>:
  405694:	52800000 	mov	w0, #0x0                   	// #0
  405698:	d65f03c0 	ret

000000000040569c <z_log_dropped>:
{
  40569c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4056a0:	b0000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  4056a4:	91266021 	add	x1, x1, #0x998
  4056a8:	910003fd 	mov	x29, sp
  4056ac:	f9000bf3 	str	x19, [sp, #16]
  4056b0:	12001c13 	and	w19, w0, #0xff
  4056b4:	d2800020 	mov	x0, #0x1                   	// #1
  4056b8:	97fff046 	bl	4017d0 <__aarch64_ldadd8_acq_rel>
	if (buffered) {
  4056bc:	340000b3 	cbz	w19, 4056d0 <z_log_dropped+0x34>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  4056c0:	b0000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  4056c4:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  4056c8:	91264021 	add	x1, x1, #0x990
  4056cc:	97fff041 	bl	4017d0 <__aarch64_ldadd8_acq_rel>
}
  4056d0:	f9400bf3 	ldr	x19, [sp, #16]
  4056d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4056d8:	d65f03c0 	ret

00000000004056dc <z_log_msg_commit>:
{
  4056dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4056e0:	910003fd 	mov	x29, sp
  4056e4:	a90153f3 	stp	x19, x20, [sp, #16]
  4056e8:	aa0003f4 	mov	x20, x0
	msg->hdr.timestamp = timestamp_func();
  4056ec:	90000140 	adrp	x0, 42d000 <__dso_handle>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4056f0:	f0000133 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
{
  4056f4:	f90013f5 	str	x21, [sp, #32]
	msg->hdr.timestamp = timestamp_func();
  4056f8:	f9429000 	ldr	x0, [x0, #1312]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4056fc:	f0000135 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
	msg->hdr.timestamp = timestamp_func();
  405700:	d63f0000 	blr	x0
  405704:	b9000680 	str	w0, [x20, #4]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  405708:	f947c673 	ldr	x19, [x19, #3976]
  40570c:	f947feb5 	ldr	x21, [x21, #4088]
  405710:	eb15027f 	cmp	x19, x21
  405714:	540005e9 	b.ls	4057d0 <z_log_msg_commit+0xf4>  // b.plast
  405718:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  40571c:	91007273 	add	x19, x19, #0x1c
  405720:	aa1303e2 	mov	x2, x19
  405724:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405728:	9101b421 	add	x1, x1, #0x6d
  40572c:	528038a3 	mov	w3, #0x1c5                 	// #453
  405730:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405734:	91353400 	add	x0, x0, #0xd4d
  405738:	97fffea1 	bl	4051bc <assert_print>
  40573c:	90000080 	adrp	x0, 415000 <__func__.2+0x30c>
  405740:	91023800 	add	x0, x0, #0x8e
  405744:	97fffe9e 	bl	4051bc <assert_print>
  405748:	aa1303e0 	mov	x0, x19
  40574c:	528038a1 	mov	w1, #0x1c5                 	// #453
  405750:	97fffec5 	bl	405264 <assert_post_action>
  405754:	528038a2 	mov	w2, #0x1c5                 	// #453
  405758:	14000013 	b	4057a4 <z_log_msg_commit+0xc8>
		if (log_backend_is_active(backend) &&
  40575c:	aa1303e0 	mov	x0, x19
  405760:	97fffed1 	bl	4052a4 <log_backend_is_active>
  405764:	72001c1f 	tst	w0, #0xff
  405768:	54000300 	b.eq	4057c8 <z_log_msg_commit+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  40576c:	b5000253 	cbnz	x19, 4057b4 <z_log_msg_commit+0xd8>
  405770:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  405774:	9102b673 	add	x19, x19, #0xad
  405778:	aa1303e2 	mov	x2, x19
  40577c:	52801643 	mov	w3, #0xb2                  	// #178
  405780:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405784:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405788:	91039421 	add	x1, x1, #0xe5
  40578c:	91353400 	add	x0, x0, #0xd4d
  405790:	97fffe8b 	bl	4051bc <assert_print>
  405794:	aa1303e0 	mov	x0, x19
  405798:	52801641 	mov	w1, #0xb2                  	// #178
  40579c:	97fffeb2 	bl	405264 <assert_post_action>
  4057a0:	52801642 	mov	w2, #0xb2                  	// #178
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4057a4:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4057a8:	aa1303e1 	mov	x1, x19
  4057ac:	91362c00 	add	x0, x0, #0xd8b
  4057b0:	9400089f 	bl	407a2c <posix_print_error_and_exit>
	backend->api->process(backend, msg);
  4057b4:	f9400260 	ldr	x0, [x19]
  4057b8:	aa1403e1 	mov	x1, x20
  4057bc:	f9400002 	ldr	x2, [x0]
  4057c0:	aa1303e0 	mov	x0, x19
  4057c4:	d63f0040 	blr	x2
  4057c8:	91008273 	add	x19, x19, #0x20
  4057cc:	17ffffd1 	b	405710 <z_log_msg_commit+0x34>
  4057d0:	54fffc63 	b.cc	40575c <z_log_msg_commit+0x80>  // b.lo, b.ul, b.last
}
  4057d4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4057d8:	f94013f5 	ldr	x21, [sp, #32]
  4057dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4057e0:	d65f03c0 	ret

00000000004057e4 <z_log_get_tag>:
}
  4057e4:	d2800000 	mov	x0, #0x0                   	// #0
  4057e8:	d65f03c0 	ret

00000000004057ec <log_src_cnt_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
  4057ec:	f0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4057f0:	f0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4057f4:	f9477400 	ldr	x0, [x0, #3816]
  4057f8:	f9473421 	ldr	x1, [x1, #3688]
  4057fc:	cb010000 	sub	x0, x0, x1
	if (z_log_is_local_domain(domain_id)) {
		return z_log_sources_count();
	}

	return link_source_count(domain_id);
}
  405800:	d3448c00 	ubfx	x0, x0, #4, #32
  405804:	d65f03c0 	ret

0000000000405808 <log_source_name_get>:

	return (const char *)cached;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t source_id)
{
  405808:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40580c:	910003fd 	mov	x29, sp
  405810:	f9000bf3 	str	x19, [sp, #16]
  405814:	2a0103f3 	mov	w19, w1
	if (z_log_is_local_domain(domain_id)) {
		if (source_id < log_src_cnt_get(domain_id)) {
  405818:	97fffff5 	bl	4057ec <log_src_cnt_get>
  40581c:	6b13001f 	cmp	w0, w19
  405820:	54000109 	b.ls	405840 <log_source_name_get+0x38>  // b.plast
			return TYPE_SECTION_START(log_const)[source_id].name;
  405824:	f0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  405828:	d37c7e73 	ubfiz	x19, x19, #4, #32
  40582c:	f9473400 	ldr	x0, [x0, #3688]
  405830:	f8736800 	ldr	x0, [x0, x19]
			return NULL;
		}
	}

	return link_source_name_get(domain_id, source_id);
}
  405834:	f9400bf3 	ldr	x19, [sp, #16]
  405838:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40583c:	d65f03c0 	ret
			return NULL;
  405840:	d2800000 	mov	x0, #0x0                   	// #0
  405844:	17fffffc 	b	405834 <log_source_name_get+0x2c>

0000000000405848 <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
  405848:	f0000123 	adrp	x3, 42c000 <__FRAME_END__+0xfbbc>
  40584c:	f947c463 	ldr	x3, [x3, #3976]
  405850:	cb030003 	sub	x3, x0, x3
	__ASSERT_NO_MSG(backend != NULL);
  405854:	b50002a0 	cbnz	x0, 4058a8 <log_backend_enable+0x60>
{
  405858:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40585c:	52801be3 	mov	w3, #0xdf                  	// #223
  405860:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405864:	910003fd 	mov	x29, sp
  405868:	f9000bf3 	str	x19, [sp, #16]
  40586c:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  405870:	9102b673 	add	x19, x19, #0xad
  405874:	91039421 	add	x1, x1, #0xe5
  405878:	aa1303e2 	mov	x2, x19
  40587c:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405880:	91353400 	add	x0, x0, #0xd4d
  405884:	97fffe4e 	bl	4051bc <assert_print>
  405888:	aa1303e0 	mov	x0, x19
  40588c:	52801be1 	mov	w1, #0xdf                  	// #223
  405890:	97fffe75 	bl	405264 <assert_post_action>
  405894:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405898:	aa1303e1 	mov	x1, x19
  40589c:	91362c00 	add	x0, x0, #0xd8b
  4058a0:	52801be2 	mov	w2, #0xdf                  	// #223
  4058a4:	94000862 	bl	407a2c <posix_print_error_and_exit>
	backend->cb->id = id;
  4058a8:	f9400404 	ldr	x4, [x0, #8]
  4058ac:	9345fc63 	asr	x3, x3, #5
  4058b0:	11000463 	add	w3, w3, #0x1
  4058b4:	12001c63 	and	w3, w3, #0xff
  4058b8:	39002083 	strb	w3, [x4, #8]

	log_backend_id_set(backend, id);
	backend->cb->level = level;
  4058bc:	f9400403 	ldr	x3, [x0, #8]
  4058c0:	39002862 	strb	w2, [x3, #10]
	backend->cb->ctx = ctx;
  4058c4:	f9400402 	ldr	x2, [x0, #8]
  4058c8:	f9000041 	str	x1, [x2]
	backend->cb->active = true;
  4058cc:	52800021 	mov	w1, #0x1                   	// #1
  4058d0:	f9400400 	ldr	x0, [x0, #8]
  4058d4:	39002401 	strb	w1, [x0, #9]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
  4058d8:	17ffff6e 	b	405690 <z_log_notify_backend_enabled>

00000000004058dc <z_log_msg_finalize>:
	 (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY) || log_backend_count_get() == 0))

void z_log_msg_finalize(struct log_msg *msg, const void *source,
			 const struct log_msg_desc desc, const void *data)
{
	if (!msg) {
  4058dc:	b5000060 	cbnz	x0, 4058e8 <z_log_msg_finalize+0xc>
		z_log_dropped(false);
  4058e0:	52800000 	mov	w0, #0x0                   	// #0
  4058e4:	17ffff6e 	b	40569c <z_log_dropped>
{
  4058e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4058ec:	910003fd 	mov	x29, sp
  4058f0:	a90153f3 	stp	x19, x20, [sp, #16]
  4058f4:	aa0003f3 	mov	x19, x0
  4058f8:	2a0203f4 	mov	w20, w2
  4058fc:	f90013f5 	str	x21, [sp, #32]
  405900:	aa0103f5 	mov	x21, x1
  405904:	aa0303e1 	mov	x1, x3

		return;
	}

	if (data) {
  405908:	b40000c3 	cbz	x3, 405920 <z_log_msg_finalize+0x44>
		uint8_t *d = msg->data + desc.package_len;
  40590c:	d3494e83 	ubfx	x3, x20, #9, #11
  405910:	91004000 	add	x0, x0, #0x10
  405914:	53147c42 	lsr	w2, w2, #20
  405918:	8b030000 	add	x0, x0, x3
  40591c:	97ffee69 	bl	4012c0 <memcpy@plt>

		memcpy(d, data, desc.data_len);
	}

	msg->hdr.desc = desc;
  405920:	b9000274 	str	w20, [x19]
	msg->hdr.source = source;
	z_log_msg_commit(msg);
  405924:	aa1303e0 	mov	x0, x19
	msg->hdr.source = source;
  405928:	f9000675 	str	x21, [x19, #8]
}
  40592c:	a94153f3 	ldp	x19, x20, [sp, #16]
  405930:	f94013f5 	ldr	x21, [sp, #32]
  405934:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_log_msg_commit(msg);
  405938:	17ffff69 	b	4056dc <z_log_msg_commit>

000000000040593c <z_impl_z_log_msg_runtime_vcreate>:
#endif

void z_impl_z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				uint32_t package_flags, const char *fmt, va_list ap)
{
  40593c:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  405940:	910003fd 	mov	x29, sp
  405944:	a9046bf9 	stp	x25, x26, [sp, #64]
  405948:	12001c1a 	and	w26, w0, #0xff
  40594c:	f0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  405950:	a90153f3 	stp	x19, x20, [sp, #16]
  405954:	aa0103f4 	mov	x20, x1
  405958:	12001c53 	and	w19, w2, #0xff
  40595c:	f9478400 	ldr	x0, [x0, #3848]
  405960:	a9025bf5 	stp	x21, x22, [sp, #32]
  405964:	2a0503f9 	mov	w25, w5
  405968:	a90363f7 	stp	x23, x24, [sp, #48]
  40596c:	aa0303f5 	mov	x21, x3
  405970:	d10043ff 	sub	sp, sp, #0x10
  405974:	f9400001 	ldr	x1, [x0]
  405978:	f9004fa1 	str	x1, [x29, #152]
  40597c:	d2800001 	mov	x1, #0x0                   	// #0
  405980:	aa0403f8 	mov	x24, x4
  405984:	aa0603f6 	mov	x22, x6
  405988:	aa0703f7 	mov	x23, x7
	int plen;

	if (fmt) {
  40598c:	b40003a6 	cbz	x6, 405a00 <z_impl_z_log_msg_runtime_vcreate+0xc4>
		va_list ap2;

		va_copy(ap2, ap);
  405990:	ad4004e0 	ldp	q0, q1, [x7]
  405994:	9101e3a0 	add	x0, x29, #0x78
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  405998:	910143a4 	add	x4, x29, #0x50
  40599c:	aa0603e3 	mov	x3, x6
  4059a0:	2a0503e2 	mov	w2, w5
  4059a4:	d2800201 	mov	x1, #0x10                  	// #16
		va_copy(ap2, ap);
  4059a8:	ad000400 	stp	q0, q1, [x0]
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  4059ac:	d2800000 	mov	x0, #0x0                   	// #0
  4059b0:	ad000480 	stp	q0, q1, [x4]
  4059b4:	97fff6a9 	bl	403458 <cbvprintf_package>
					 package_flags, fmt, ap2);
		__ASSERT_NO_MSG(plen >= 0);
  4059b8:	36f80260 	tbz	w0, #31, 405a04 <z_impl_z_log_msg_runtime_vcreate+0xc8>
  4059bc:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  4059c0:	91054673 	add	x19, x19, #0x151
  4059c4:	aa1303e2 	mov	x2, x19
  4059c8:	52800ea3 	mov	w3, #0x75                  	// #117
  4059cc:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  4059d0:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4059d4:	9105f421 	add	x1, x1, #0x17d
  4059d8:	91353400 	add	x0, x0, #0xd4d
  4059dc:	97fffdf8 	bl	4051bc <assert_print>
  4059e0:	aa1303e0 	mov	x0, x19
  4059e4:	52800ea1 	mov	w1, #0x75                  	// #117
  4059e8:	97fffe1f 	bl	405264 <assert_post_action>
  4059ec:	52800ea2 	mov	w2, #0x75                  	// #117
		pkg = msg->data;
	}

	if (pkg && fmt) {
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
		__ASSERT_NO_MSG(plen >= 0);
  4059f0:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4059f4:	aa1303e1 	mov	x1, x19
  4059f8:	91362c00 	add	x0, x0, #0xd8b
  4059fc:	9400080c 	bl	407a2c <posix_print_error_and_exit>
		plen = 0;
  405a00:	52800000 	mov	w0, #0x0                   	// #0
	struct log_msg_desc desc =
  405a04:	531a0a73 	ubfiz	w19, w19, #6, #3
  405a08:	531d0b5a 	ubfiz	w26, w26, #3, #3
  405a0c:	53172802 	ubfiz	w2, w0, #9, #11
  405a10:	2a1a0273 	orr	w19, w19, w26
  405a14:	2a020273 	orr	w19, w19, w2
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  405a18:	93407c01 	sxtw	x1, w0
	struct log_msg_desc desc =
  405a1c:	2a185273 	orr	w19, w19, w24, lsl #20
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  405a20:	91005f18 	add	x24, x24, #0x17
  405a24:	8b20c300 	add	x0, x24, w0, sxtw
		msg = alloca(msg_wlen * sizeof(int));
  405a28:	927df000 	and	x0, x0, #0xfffffffffffffff8
  405a2c:	91003c00 	add	x0, x0, #0xf
  405a30:	927cec02 	and	x2, x0, #0xfffffffffffffff0
  405a34:	9270bc00 	and	x0, x0, #0xffffffffffff0000
  405a38:	cb2063e0 	sub	x0, sp, x0
  405a3c:	eb2063ff 	cmp	sp, x0
  405a40:	54000080 	b.eq	405a50 <z_impl_z_log_msg_runtime_vcreate+0x114>  // b.none
  405a44:	d14043ff 	sub	sp, sp, #0x10, lsl #12
  405a48:	f90203ff 	str	xzr, [sp, #1024]
  405a4c:	17fffffc 	b	405a3c <z_impl_z_log_msg_runtime_vcreate+0x100>
  405a50:	92403c40 	and	x0, x2, #0xffff
  405a54:	cb2063ff 	sub	sp, sp, x0
  405a58:	f90003ff 	str	xzr, [sp]
  405a5c:	f110001f 	cmp	x0, #0x400
  405a60:	54000043 	b.cc	405a68 <z_impl_z_log_msg_runtime_vcreate+0x12c>  // b.lo, b.ul, b.last
  405a64:	f90203ff 	str	xzr, [sp, #1024]
  405a68:	910043f8 	add	x24, sp, #0x10
	if (pkg && fmt) {
  405a6c:	b40002f6 	cbz	x22, 405ac8 <z_impl_z_log_msg_runtime_vcreate+0x18c>
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
  405a70:	ad4006e0 	ldp	q0, q1, [x23]
  405a74:	910143a4 	add	x4, x29, #0x50
  405a78:	aa1603e3 	mov	x3, x22
  405a7c:	2a1903e2 	mov	w2, w25
  405a80:	91004300 	add	x0, x24, #0x10
  405a84:	ad000480 	stp	q0, q1, [x4]
  405a88:	97fff674 	bl	403458 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
  405a8c:	36f801e0 	tbz	w0, #31, 405ac8 <z_impl_z_log_msg_runtime_vcreate+0x18c>
  405a90:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  405a94:	91054673 	add	x19, x19, #0x151
  405a98:	aa1303e2 	mov	x2, x19
  405a9c:	528011e3 	mov	w3, #0x8f                  	// #143
  405aa0:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405aa4:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405aa8:	9105f421 	add	x1, x1, #0x17d
  405aac:	91353400 	add	x0, x0, #0xd4d
  405ab0:	97fffdc3 	bl	4051bc <assert_print>
  405ab4:	aa1303e0 	mov	x0, x19
  405ab8:	528011e1 	mov	w1, #0x8f                  	// #143
  405abc:	97fffdea 	bl	405264 <assert_post_action>
  405ac0:	528011e2 	mov	w2, #0x8f                  	// #143
  405ac4:	17ffffcb 	b	4059f0 <z_impl_z_log_msg_runtime_vcreate+0xb4>
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_msg(source, desc, pkg, data);
	}

	if (BACKENDS_IN_USE()) {
		z_log_msg_finalize(msg, source, desc, data);
  405ac8:	2a1303e2 	mov	w2, w19
  405acc:	aa1403e1 	mov	x1, x20
  405ad0:	aa1803e0 	mov	x0, x24
  405ad4:	aa1503e3 	mov	x3, x21
  405ad8:	97ffff81 	bl	4058dc <z_log_msg_finalize>
	}
}
  405adc:	f0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  405ae0:	f9478400 	ldr	x0, [x0, #3848]
  405ae4:	f9404fa2 	ldr	x2, [x29, #152]
  405ae8:	f9400001 	ldr	x1, [x0]
  405aec:	eb010042 	subs	x2, x2, x1
  405af0:	d2800001 	mov	x1, #0x0                   	// #0
  405af4:	54000040 	b.eq	405afc <z_impl_z_log_msg_runtime_vcreate+0x1c0>  // b.none
  405af8:	97ffee6e 	bl	4014b0 <__stack_chk_fail@plt>
  405afc:	910003bf 	mov	sp, x29
  405b00:	a94153f3 	ldp	x19, x20, [sp, #16]
  405b04:	a9425bf5 	ldp	x21, x22, [sp, #32]
  405b08:	a94363f7 	ldp	x23, x24, [sp, #48]
  405b0c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  405b10:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  405b14:	d65f03c0 	ret

0000000000405b18 <out_func>:

	return ret;
}

static int out_func(int c, void *ctx)
{
  405b18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  405b1c:	f0000122 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  405b20:	910003fd 	mov	x29, sp
  405b24:	f9478442 	ldr	x2, [x2, #3848]
  405b28:	f9400043 	ldr	x3, [x2]
  405b2c:	f9000fe3 	str	x3, [sp, #24]
  405b30:	d2800003 	mov	x3, #0x0                   	// #0
	int idx;

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		/* Backend must be thread safe in synchronous operation. */
		/* Need that step for big endian */
		char x = (char)c;
  405b34:	39005fe0 	strb	w0, [sp, #23]

		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
  405b38:	a9400023 	ldp	x3, x0, [x1]
  405b3c:	d2800021 	mov	x1, #0x1                   	// #1
  405b40:	f9400402 	ldr	x2, [x0, #8]
  405b44:	91005fe0 	add	x0, sp, #0x17
  405b48:	d63f0060 	blr	x3
	out_ctx->buf[idx] = (uint8_t)c;

	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);

	return 0;
}
  405b4c:	f0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  405b50:	f9478400 	ldr	x0, [x0, #3848]
  405b54:	f9400fe2 	ldr	x2, [sp, #24]
  405b58:	f9400001 	ldr	x1, [x0]
  405b5c:	eb010042 	subs	x2, x2, x1
  405b60:	d2800001 	mov	x1, #0x0                   	// #0
  405b64:	54000040 	b.eq	405b6c <out_func+0x54>  // b.none
  405b68:	97ffee52 	bl	4014b0 <__stack_chk_fail@plt>
  405b6c:	52800000 	mov	w0, #0x0                   	// #0
  405b70:	a8c27bfd 	ldp	x29, x30, [sp], #32
  405b74:	d65f03c0 	ret

0000000000405b78 <cr_out_func>:

static int cr_out_func(int c, void *ctx)
{
  405b78:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  405b7c:	910003fd 	mov	x29, sp
  405b80:	a90153f3 	stp	x19, x20, [sp, #16]
  405b84:	2a0003f3 	mov	w19, w0
  405b88:	aa0103f4 	mov	x20, x1
	if (c == '\n') {
  405b8c:	7100281f 	cmp	w0, #0xa
  405b90:	54000061 	b.ne	405b9c <cr_out_func+0x24>  // b.any
		out_func((int)'\r', ctx);
  405b94:	528001a0 	mov	w0, #0xd                   	// #13
  405b98:	97ffffe0 	bl	405b18 <out_func>
	}
	out_func(c, ctx);
  405b9c:	aa1403e1 	mov	x1, x20
  405ba0:	2a1303e0 	mov	w0, w19
  405ba4:	97ffffdd 	bl	405b18 <out_func>

	return 0;
}
  405ba8:	52800000 	mov	w0, #0x0                   	// #0
  405bac:	a94153f3 	ldp	x19, x20, [sp, #16]
  405bb0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  405bb4:	d65f03c0 	ret

0000000000405bb8 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
  405bb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  405bbc:	910003fd 	mov	x29, sp
  405bc0:	a90153f3 	stp	x19, x20, [sp, #16]
  405bc4:	aa0103f4 	mov	x20, x1
  405bc8:	aa0203f3 	mov	x19, x2
  405bcc:	a9025bf5 	stp	x21, x22, [sp, #32]
  405bd0:	aa0003f5 	mov	x21, x0
  405bd4:	aa0303f6 	mov	x22, x3
	int processed;

	do {
		processed = outf(buf, len, ctx);
  405bd8:	aa1303e1 	mov	x1, x19
  405bdc:	aa1403e0 	mov	x0, x20
  405be0:	aa1603e2 	mov	x2, x22
  405be4:	d63f02a0 	blr	x21
		len -= processed;
		buf += processed;
  405be8:	8b20c294 	add	x20, x20, w0, sxtw
	} while (len != 0);
  405bec:	eb20c273 	subs	x19, x19, w0, sxtw
  405bf0:	54ffff41 	b.ne	405bd8 <buffer_write+0x20>  // b.any
}
  405bf4:	a94153f3 	ldp	x19, x20, [sp, #16]
  405bf8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  405bfc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  405c00:	d65f03c0 	ret

0000000000405c04 <cbvprintf>:
#ifdef CONFIG_PICOLIBC
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
  405c04:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  405c08:	910003fd 	mov	x29, sp
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
  405c0c:	ad400460 	ldp	q0, q1, [x3]
  405c10:	910043e4 	add	x4, sp, #0x10
  405c14:	aa0403e3 	mov	x3, x4
  405c18:	ad000480 	stp	q0, q1, [x4]
  405c1c:	52800004 	mov	w4, #0x0                   	// #0
  405c20:	97fffa83 	bl	40462c <z_cbvprintf_impl>
}
  405c24:	a8c37bfd 	ldp	x29, x30, [sp], #48
  405c28:	d65f03c0 	ret

0000000000405c2c <print_formatted>:
{
  405c2c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  405c30:	910003fd 	mov	x29, sp
  405c34:	a90e0fe2 	stp	x2, x3, [sp, #224]
  405c38:	f0000122 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  405c3c:	f9478442 	ldr	x2, [x2, #3848]
  405c40:	3d801be0 	str	q0, [sp, #96]
  405c44:	3d801fe1 	str	q1, [sp, #112]
  405c48:	3d8023e2 	str	q2, [sp, #128]
  405c4c:	3d8027e3 	str	q3, [sp, #144]
  405c50:	3d802be4 	str	q4, [sp, #160]
  405c54:	3d802fe5 	str	q5, [sp, #176]
  405c58:	3d8033e6 	str	q6, [sp, #192]
  405c5c:	3d8037e7 	str	q7, [sp, #208]
  405c60:	a90f17e4 	stp	x4, x5, [sp, #240]
  405c64:	a9101fe6 	stp	x6, x7, [sp, #256]
  405c68:	f9400043 	ldr	x3, [x2]
  405c6c:	f9002fe3 	str	x3, [sp, #88]
  405c70:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(args, fmt);
  405c74:	910443e2 	add	x2, sp, #0x110
  405c78:	a9038be2 	stp	x2, x2, [sp, #56]
  405c7c:	910383e2 	add	x2, sp, #0xe0
	length = cbvprintf(out_func, (void *)output, fmt, args);
  405c80:	910043e3 	add	x3, sp, #0x10
	va_start(args, fmt);
  405c84:	f90027e2 	str	x2, [sp, #72]
  405c88:	128005e2 	mov	w2, #0xffffffd0            	// #-48
  405c8c:	b90053e2 	str	w2, [sp, #80]
  405c90:	12800fe2 	mov	w2, #0xffffff80            	// #-128
  405c94:	b90057e2 	str	w2, [sp, #84]
	length = cbvprintf(out_func, (void *)output, fmt, args);
  405c98:	9100e3e2 	add	x2, sp, #0x38
  405c9c:	ad400440 	ldp	q0, q1, [x2]
  405ca0:	aa0103e2 	mov	x2, x1
  405ca4:	aa0003e1 	mov	x1, x0
  405ca8:	90000000 	adrp	x0, 405000 <z_cbvprintf_impl+0x9d4>
  405cac:	912c6000 	add	x0, x0, #0xb18
  405cb0:	ad000460 	stp	q0, q1, [x3]
  405cb4:	97ffffd4 	bl	405c04 <cbvprintf>
}
  405cb8:	f0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  405cbc:	f9478421 	ldr	x1, [x1, #3848]
  405cc0:	f9402fe3 	ldr	x3, [sp, #88]
  405cc4:	f9400022 	ldr	x2, [x1]
  405cc8:	eb020063 	subs	x3, x3, x2
  405ccc:	d2800002 	mov	x2, #0x0                   	// #0
  405cd0:	54000040 	b.eq	405cd8 <print_formatted+0xac>  // b.none
  405cd4:	97ffedf7 	bl	4014b0 <__stack_chk_fail@plt>
  405cd8:	a8d17bfd 	ldp	x29, x30, [sp], #272
  405cdc:	d65f03c0 	ret

0000000000405ce0 <log_output_flush>:


void log_output_flush(const struct log_output *output)
{
  405ce0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  405ce4:	910003fd 	mov	x29, sp
  405ce8:	f9000bf3 	str	x19, [sp, #16]
  405cec:	aa0003f3 	mov	x19, x0
	buffer_write(output->func, output->buf,
  405cf0:	a9408400 	ldp	x0, x1, [x0, #8]
  405cf4:	a9400c02 	ldp	x2, x3, [x0]
  405cf8:	f9400260 	ldr	x0, [x19]
  405cfc:	97ffffaf 	bl	405bb8 <buffer_write>
		     output->control_block->offset,
		     output->control_block->ctx);

	output->control_block->offset = 0;
  405d00:	f9400660 	ldr	x0, [x19, #8]
  405d04:	f900001f 	str	xzr, [x0]
}
  405d08:	f9400bf3 	ldr	x19, [sp, #16]
  405d0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  405d10:	d65f03c0 	ret

0000000000405d14 <log_output_process>:
			uint8_t level,
			const uint8_t *package,
			const uint8_t *data,
			size_t data_len,
			uint32_t flags)
{
  405d14:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  405d18:	910003fd 	mov	x29, sp
  405d1c:	a90153f3 	stp	x19, x20, [sp, #16]
  405d20:	aa0003f3 	mov	x19, x0
  405d24:	a9025bf5 	stp	x21, x22, [sp, #32]
  405d28:	aa0703f5 	mov	x21, x7
  405d2c:	b94083f6 	ldr	w22, [sp, #128]
  405d30:	a90363f7 	stp	x23, x24, [sp, #48]
  405d34:	aa0603f7 	mov	x23, x6
  405d38:	a9046bf9 	stp	x25, x26, [sp, #64]
  405d3c:	aa0303fa 	mov	x26, x3
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	uint32_t prefix_offset;
	cbprintf_cb cb;

	if (!raw_string) {
  405d40:	72001c99 	ands	w25, w4, #0xff
{
  405d44:	a90573fb 	stp	x27, x28, [sp, #80]
  405d48:	aa0503fb 	mov	x27, x5
	if (!raw_string) {
  405d4c:	54001100 	b.eq	405f6c <log_output_process+0x258>  // b.none
	__ASSERT_NO_MSG(level <= LOG_LEVEL_DBG);
  405d50:	7100133f 	cmp	w25, #0x4
  405d54:	54000249 	b.ls	405d9c <log_output_process+0x88>  // b.plast
  405d58:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  405d5c:	91063273 	add	x19, x19, #0x18c
  405d60:	aa1303e2 	mov	x2, x19
  405d64:	52803663 	mov	w3, #0x1b3                 	// #435
  405d68:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405d6c:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405d70:	9106ec21 	add	x1, x1, #0x1bb
  405d74:	91353400 	add	x0, x0, #0xd4d
  405d78:	97fffd11 	bl	4051bc <assert_print>
  405d7c:	aa1303e0 	mov	x0, x19
  405d80:	52803661 	mov	w1, #0x1b3                 	// #435
  405d84:	97fffd38 	bl	405264 <assert_post_action>
  405d88:	52803662 	mov	w2, #0x1b3                 	// #435

	if (package) {
		int err = cbpprintf(cb, (void *)output, (void *)package);

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
  405d8c:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405d90:	aa1303e1 	mov	x1, x19
  405d94:	91362c00 	add	x0, x0, #0xd8b
  405d98:	94000725 	bl	407a2c <posix_print_error_and_exit>
  405d9c:	121d02c0 	and	w0, w22, #0x8
  405da0:	aa0203fc 	mov	x28, x2
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  405da4:	2a0103f4 	mov	w20, w1
  405da8:	b9007be0 	str	w0, [sp, #120]
	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
  405dac:	97fffe8e 	bl	4057e4 <z_log_get_tag>
  405db0:	aa0003e2 	mov	x2, x0
	if (tag) {
  405db4:	b40009e0 	cbz	x0, 405ef0 <log_output_process+0x1dc>
		length += print_formatted(output, "%s ", tag);
  405db8:	aa1303e0 	mov	x0, x19
  405dbc:	b0000081 	adrp	x1, 416000 <__func__.0+0x57a>
  405dc0:	911ca421 	add	x1, x1, #0x729
  405dc4:	97ffff9a 	bl	405c2c <print_formatted>
  405dc8:	2a0003f8 	mov	w24, w0
	if (stamp) {
  405dcc:	121f02c0 	and	w0, w22, #0x2
  405dd0:	34000140 	cbz	w0, 405df8 <log_output_process+0xe4>
	if (!format) {
  405dd4:	52800880 	mov	w0, #0x44                  	// #68
  405dd8:	6a0002df 	tst	w22, w0
  405ddc:	540008e1 	b.ne	405ef8 <log_output_process+0x1e4>  // b.any
		length = print_formatted(output, "[%08lu] ", timestamp);
  405de0:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405de4:	2a1403e2 	mov	w2, w20
  405de8:	91071c21 	add	x1, x1, #0x1c7
  405dec:	aa1303e0 	mov	x0, x19
  405df0:	97ffff8f 	bl	405c2c <print_formatted>
		length += timestamp_print(output, flags, timestamp);
  405df4:	0b000318 	add	w24, w24, w0
	if (color) {
  405df8:	120002c0 	and	w0, w22, #0x1
  405dfc:	34000180 	cbz	w0, 405e2c <log_output_process+0x118>
		const char *log_color = start && (colors[level] != NULL) ?
  405e00:	2a1903e1 	mov	w1, w25
  405e04:	f0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  405e08:	911f4000 	add	x0, x0, #0x7d0
  405e0c:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  405e10:	b5000062 	cbnz	x2, 405e1c <log_output_process+0x108>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
  405e14:	90000082 	adrp	x2, 415000 <__func__.2+0x30c>
  405e18:	91061c42 	add	x2, x2, #0x187
		print_formatted(output, "%s", log_color);
  405e1c:	f0000061 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  405e20:	aa1303e0 	mov	x0, x19
  405e24:	9122b021 	add	x1, x1, #0x8ac
  405e28:	97ffff81 	bl	405c2c <print_formatted>
	if (level_on) {
  405e2c:	121d02c0 	and	w0, w22, #0x8
  405e30:	340009a0 	cbz	w0, 405f64 <log_output_process+0x250>
		total += print_formatted(output, "<%s> ", severity[level]);
  405e34:	2a1903e1 	mov	w1, w25
  405e38:	f0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  405e3c:	911fe000 	add	x0, x0, #0x7f8
  405e40:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  405e44:	aa1303e0 	mov	x0, x19
  405e48:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405e4c:	9107b021 	add	x1, x1, #0x1ec
  405e50:	97ffff77 	bl	405c2c <print_formatted>
  405e54:	2a0003f4 	mov	w20, w0
	if (domain) {
  405e58:	b40000fc 	cbz	x28, 405e74 <log_output_process+0x160>
		total += print_formatted(output, "%s/", domain);
  405e5c:	aa1c03e2 	mov	x2, x28
  405e60:	aa1303e0 	mov	x0, x19
  405e64:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405e68:	9107c821 	add	x1, x1, #0x1f2
  405e6c:	97ffff70 	bl	405c2c <print_formatted>
  405e70:	0b000294 	add	w20, w20, w0
	if (source) {
  405e74:	b40000fa 	cbz	x26, 405e90 <log_output_process+0x17c>
		total += print_formatted(output,
  405e78:	aa1a03e2 	mov	x2, x26
  405e7c:	aa1303e0 	mov	x0, x19
  405e80:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405e84:	9107d821 	add	x1, x1, #0x1f6
  405e88:	97ffff69 	bl	405c2c <print_formatted>
  405e8c:	0b000294 	add	w20, w20, w0
		cb = out_func;
  405e90:	90000000 	adrp	x0, 405000 <z_cbvprintf_impl+0x9d4>
	length += ids_print(output, level_on, func_on, domain, source, level);
  405e94:	0b180294 	add	w20, w20, w24
		cb = out_func;
  405e98:	912c6000 	add	x0, x0, #0xb18
	if (package) {
  405e9c:	b40007bb 	cbz	x27, 405f90 <log_output_process+0x27c>
		return cbpprintf_external(out, cbvprintf_tagged_args,
					  ctx, packaged);
	}
#endif

	return cbpprintf_external(out, cbvprintf, ctx, packaged);
  405ea0:	90000001 	adrp	x1, 405000 <z_cbvprintf_impl+0x9d4>
  405ea4:	aa1b03e3 	mov	x3, x27
  405ea8:	aa1303e2 	mov	x2, x19
  405eac:	91301021 	add	x1, x1, #0xc04
  405eb0:	97fff747 	bl	403bcc <cbpprintf_external>
		__ASSERT_NO_MSG(err >= 0);
  405eb4:	36f806e0 	tbz	w0, #31, 405f90 <log_output_process+0x27c>
  405eb8:	90000093 	adrp	x19, 415000 <__func__.2+0x30c>
  405ebc:	91063273 	add	x19, x19, #0x18c
  405ec0:	aa1303e2 	mov	x2, x19
  405ec4:	52804123 	mov	w3, #0x209                 	// #521
  405ec8:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405ecc:	f0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  405ed0:	9107ec21 	add	x1, x1, #0x1fb
  405ed4:	91353400 	add	x0, x0, #0xd4d
  405ed8:	97fffcb9 	bl	4051bc <assert_print>
  405edc:	aa1303e0 	mov	x0, x19
  405ee0:	52804121 	mov	w1, #0x209                 	// #521
  405ee4:	97fffce0 	bl	405264 <assert_post_action>
  405ee8:	52804122 	mov	w2, #0x209                 	// #521
  405eec:	17ffffa8 	b	405d8c <log_output_process+0x78>
	uint32_t length = 0U;
  405ef0:	52800018 	mov	w24, #0x0                   	// #0
  405ef4:	17ffffb6 	b	405dcc <log_output_process+0xb8>
	} else if (freq != 0U) {
  405ef8:	d0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  405efc:	b94cf406 	ldr	w6, [x0, #3316]
  405f00:	340002e6 	cbz	w6, 405f5c <log_output_process+0x248>
		timestamp /= timestamp_div;
  405f04:	d0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  405f08:	5281c201 	mov	w1, #0xe10                 	// #3600
		ms = (remainder * 1000U) / freq;
  405f0c:	52807d03 	mov	w3, #0x3e8                 	// #1000
				length = print_formatted(output,
  405f10:	52800784 	mov	w4, #0x3c                  	// #60
		timestamp /= timestamp_div;
  405f14:	b94cf800 	ldr	w0, [x0, #3320]
  405f18:	1ac00a94 	udiv	w20, w20, w0
		total_seconds = timestamp / freq;
  405f1c:	1ac60a80 	udiv	w0, w20, w6
		seconds -= hours * 3600U;
  405f20:	1ac10802 	udiv	w2, w0, w1
  405f24:	1b018041 	msub	w1, w2, w1, w0
		remainder = timestamp % freq;
  405f28:	1b06d000 	msub	w0, w0, w6, w20
		ms = (remainder * 1000U) / freq;
  405f2c:	1b037c00 	mul	w0, w0, w3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  405f30:	1ac60805 	udiv	w5, w0, w6
  405f34:	1b0680a0 	msub	w0, w5, w6, w0
  405f38:	1b037c00 	mul	w0, w0, w3
				length = print_formatted(output,
  405f3c:	1ac40823 	udiv	w3, w1, w4
  405f40:	1ac60806 	udiv	w6, w0, w6
  405f44:	aa1303e0 	mov	x0, x19
  405f48:	1b048464 	msub	w4, w3, w4, w1
  405f4c:	90000081 	adrp	x1, 415000 <__func__.2+0x30c>
  405f50:	91074021 	add	x1, x1, #0x1d0
  405f54:	97ffff36 	bl	405c2c <print_formatted>
  405f58:	17ffffa7 	b	405df4 <log_output_process+0xe0>
		length = 0;
  405f5c:	52800000 	mov	w0, #0x0                   	// #0
  405f60:	17ffffa5 	b	405df4 <log_output_process+0xe0>
	int total = 0;
  405f64:	52800014 	mov	w20, #0x0                   	// #0
  405f68:	17ffffbc 	b	405e58 <log_output_process+0x144>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  405f6c:	f100047f 	cmp	x3, #0x1
  405f70:	540000a0 	b.eq	405f84 <log_output_process+0x270>  // b.none
  405f74:	90000000 	adrp	x0, 405000 <z_cbvprintf_impl+0x9d4>
  405f78:	912de000 	add	x0, x0, #0xb78
		prefix_offset = 0;
  405f7c:	52800014 	mov	w20, #0x0                   	// #0
  405f80:	17ffffc7 	b	405e9c <log_output_process+0x188>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  405f84:	90000000 	adrp	x0, 405000 <z_cbvprintf_impl+0x9d4>
  405f88:	912c6000 	add	x0, x0, #0xb18
  405f8c:	17fffffc 	b	405f7c <log_output_process+0x268>
	}

	if (data_len) {
  405f90:	b4000895 	cbz	x21, 4060a0 <log_output_process+0x38c>
		print_formatted(output, " ");
  405f94:	90000098 	adrp	x24, 415000 <__func__.2+0x30c>
  405f98:	91083f18 	add	x24, x24, #0x20f
		print_formatted(ctx, "\r\n");
  405f9c:	90000080 	adrp	x0, 415000 <__func__.2+0x30c>
  405fa0:	91081000 	add	x0, x0, #0x204
  405fa4:	f9003be0 	str	x0, [sp, #112]
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
  405fa8:	52800200 	mov	w0, #0x10                  	// #16
  405fac:	6b0002bf 	cmp	w21, w0
  405fb0:	1a8092a1 	csel	w1, w21, w0, ls  // ls = plast
  405fb4:	1a8092a0 	csel	w0, w21, w0, ls  // ls = plast
  405fb8:	f90033e0 	str	x0, [sp, #96]
  405fbc:	b9007be1 	str	w1, [sp, #120]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  405fc0:	372000d6 	tbnz	w22, #4, 405fd8 <log_output_process+0x2c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  405fc4:	362809b6 	tbz	w22, #5, 4060f8 <log_output_process+0x3e4>
		print_formatted(ctx, "\n");
  405fc8:	b0000081 	adrp	x1, 416000 <__func__.0+0x57a>
  405fcc:	91255021 	add	x1, x1, #0x954
		print_formatted(ctx, "\r\n");
  405fd0:	aa1303e0 	mov	x0, x19
  405fd4:	97ffff16 	bl	405c2c <print_formatted>
		prefix_offset = 0;
  405fd8:	5280001b 	mov	w27, #0x0                   	// #0
	for (int i = 0; i < prefix_offset; i++) {
  405fdc:	6b1b029f 	cmp	w20, w27
  405fe0:	5400090c 	b.gt	406100 <log_output_process+0x3ec>
			print_formatted(output, "%02x ", data[i]);
  405fe4:	9000009c 	adrp	x28, 415000 <__func__.2+0x30c>
  405fe8:	91081f9c 	add	x28, x28, #0x207
			print_formatted(output, "   ");
  405fec:	90000080 	adrp	x0, 415000 <__func__.2+0x30c>
  405ff0:	d280001a 	mov	x26, #0x0                   	// #0
  405ff4:	91083400 	add	x0, x0, #0x20d
  405ff8:	f90037e0 	str	x0, [sp, #104]
		if (i < length) {
  405ffc:	b9407be0 	ldr	w0, [sp, #120]
  406000:	2a1a03fb 	mov	w27, w26
  406004:	6b1a001f 	cmp	w0, w26
  406008:	54000969 	b.ls	406134 <log_output_process+0x420>  // b.plast
			print_formatted(output, "%02x ", data[i]);
  40600c:	387a6ae2 	ldrb	w2, [x23, x26]
  406010:	aa1c03e1 	mov	x1, x28
  406014:	aa1303e0 	mov	x0, x19
  406018:	97ffff05 	bl	405c2c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  40601c:	f1003f5f 	cmp	x26, #0xf
  406020:	540007a1 	b.ne	406114 <log_output_process+0x400>  // b.any
			print_formatted(output, "%c",
  406024:	f000007b 	adrp	x27, 415000 <__func__.2+0x30c>
  406028:	91084f7b 	add	x27, x27, #0x213
	print_formatted(output, "|");
  40602c:	d280001c 	mov	x28, #0x0                   	// #0
  406030:	528005da 	mov	w26, #0x2e                  	// #46
  406034:	aa1303e0 	mov	x0, x19
  406038:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  40603c:	91084421 	add	x1, x1, #0x211
  406040:	97fffefb 	bl	405c2c <print_formatted>
		if (i < length) {
  406044:	b9407be0 	ldr	w0, [sp, #120]
  406048:	b9006bfc 	str	w28, [sp, #104]
  40604c:	6b1c001f 	cmp	w0, w28
  406050:	540008c9 	b.ls	406168 <log_output_process+0x454>  // b.plast
			unsigned char c = (unsigned char)data[i];
  406054:	387c6ae2 	ldrb	w2, [x23, x28]
  406058:	b9007fe2 	str	w2, [sp, #124]
			      isprint((int)c) != 0 ? c : '.');
  40605c:	97ffed35 	bl	401530 <__ctype_b_loc@plt>
  406060:	b9407fe2 	ldr	w2, [sp, #124]
  406064:	f9400000 	ldr	x0, [x0]
  406068:	d37f1c41 	ubfiz	x1, x2, #1, #8
			print_formatted(output, "%c",
  40606c:	78616800 	ldrh	w0, [x0, x1]
  406070:	aa1b03e1 	mov	x1, x27
  406074:	f272001f 	tst	x0, #0x4000
  406078:	aa1303e0 	mov	x0, x19
  40607c:	1a9a1042 	csel	w2, w2, w26, ne  // ne = any
  406080:	97fffeeb 	bl	405c2c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  406084:	f1003f9f 	cmp	x28, #0xf
  406088:	540005e1 	b.ne	406144 <log_output_process+0x430>  // b.any
		data += length;
  40608c:	f94033e0 	ldr	x0, [sp, #96]
  406090:	8b0002f7 	add	x23, x23, x0
	} while (len);
  406094:	b9407be0 	ldr	w0, [sp, #120]
  406098:	6b0002b5 	subs	w21, w21, w0
  40609c:	54fff861 	b.ne	405fa8 <log_output_process+0x294>  // b.any
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
	}

	if (!raw_string) {
  4060a0:	340001d9 	cbz	w25, 4060d8 <log_output_process+0x3c4>
	if (color) {
  4060a4:	360000f6 	tbz	w22, #0, 4060c0 <log_output_process+0x3ac>
		print_formatted(output, "%s", log_color);
  4060a8:	f0000062 	adrp	x2, 415000 <__func__.2+0x30c>
  4060ac:	d0000061 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  4060b0:	91061c42 	add	x2, x2, #0x187
  4060b4:	9122b021 	add	x1, x1, #0x8ac
  4060b8:	aa1303e0 	mov	x0, x19
  4060bc:	97fffedc 	bl	405c2c <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  4060c0:	372000d6 	tbnz	w22, #4, 4060d8 <log_output_process+0x3c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  4060c4:	362805b6 	tbz	w22, #5, 406178 <log_output_process+0x464>
		print_formatted(ctx, "\n");
  4060c8:	90000081 	adrp	x1, 416000 <__func__.0+0x57a>
  4060cc:	91255021 	add	x1, x1, #0x954
		print_formatted(ctx, "\r\n");
  4060d0:	aa1303e0 	mov	x0, x19
  4060d4:	97fffed6 	bl	405c2c <print_formatted>
		postfix_print(output, flags, level);
	}

	log_output_flush(output);
  4060d8:	aa1303e0 	mov	x0, x19
}
  4060dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4060e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4060e4:	a94363f7 	ldp	x23, x24, [sp, #48]
  4060e8:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4060ec:	a94573fb 	ldp	x27, x28, [sp, #80]
  4060f0:	a8c87bfd 	ldp	x29, x30, [sp], #128
	log_output_flush(output);
  4060f4:	17fffefb 	b	405ce0 <log_output_flush>
		print_formatted(ctx, "\r\n");
  4060f8:	f9403be1 	ldr	x1, [sp, #112]
  4060fc:	17ffffb5 	b	405fd0 <log_output_process+0x2bc>
		print_formatted(output, " ");
  406100:	aa1803e1 	mov	x1, x24
  406104:	aa1303e0 	mov	x0, x19
	for (int i = 0; i < prefix_offset; i++) {
  406108:	1100077b 	add	w27, w27, #0x1
		print_formatted(output, " ");
  40610c:	97fffec8 	bl	405c2c <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
  406110:	17ffffb3 	b	405fdc <log_output_process+0x2c8>
		if (i > 0 && !(i % 8)) {
  406114:	1100077b 	add	w27, w27, #0x1
  406118:	f2400b7f 	tst	x27, #0x7
  40611c:	54000081 	b.ne	40612c <log_output_process+0x418>  // b.any
			print_formatted(output, " ");
  406120:	aa1803e1 	mov	x1, x24
  406124:	aa1303e0 	mov	x0, x19
  406128:	97fffec1 	bl	405c2c <print_formatted>
  40612c:	9100075a 	add	x26, x26, #0x1
  406130:	17ffffb3 	b	405ffc <log_output_process+0x2e8>
			print_formatted(output, "   ");
  406134:	f94037e1 	ldr	x1, [sp, #104]
  406138:	aa1303e0 	mov	x0, x19
  40613c:	97fffebc 	bl	405c2c <print_formatted>
  406140:	17ffffb7 	b	40601c <log_output_process+0x308>
		if (i > 0 && !(i % 8)) {
  406144:	b9406be0 	ldr	w0, [sp, #104]
  406148:	11000400 	add	w0, w0, #0x1
  40614c:	f240081f 	tst	x0, #0x7
  406150:	54000081 	b.ne	406160 <log_output_process+0x44c>  // b.any
			print_formatted(output, " ");
  406154:	aa1803e1 	mov	x1, x24
  406158:	aa1303e0 	mov	x0, x19
  40615c:	97fffeb4 	bl	405c2c <print_formatted>
  406160:	9100079c 	add	x28, x28, #0x1
  406164:	17ffffb8 	b	406044 <log_output_process+0x330>
			print_formatted(output, " ");
  406168:	aa1803e1 	mov	x1, x24
  40616c:	aa1303e0 	mov	x0, x19
  406170:	97fffeaf 	bl	405c2c <print_formatted>
  406174:	17ffffc4 	b	406084 <log_output_process+0x370>
		print_formatted(ctx, "\r\n");
  406178:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  40617c:	91081021 	add	x1, x1, #0x204
  406180:	17ffffd4 	b	4060d0 <log_output_process+0x3bc>

0000000000406184 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg, uint32_t flags)
{
  406184:	d10143ff 	sub	sp, sp, #0x50
  406188:	a9017bfd 	stp	x29, x30, [sp, #16]
  40618c:	910043fd 	add	x29, sp, #0x10
  406190:	a90253f3 	stp	x19, x20, [sp, #32]
  406194:	aa0003f4 	mov	x20, x0
  406198:	aa0103f3 	mov	x19, x1
  40619c:	a9035bf5 	stp	x21, x22, [sp, #48]
  4061a0:	2a0203f5 	mov	w21, w2
  4061a4:	f90023f7 	str	x23, [sp, #64]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg_get_source(struct log_msg *msg)
{
	return msg->hdr.source;
  4061a8:	a9400c20 	ldp	x0, x3, [x1]
 *
 * @return Timestamp.
 */
static inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)
{
	return msg->hdr.timestamp;
  4061ac:	b9400436 	ldr	w22, [x1, #4]
	return msg->hdr.desc.level;
  4061b0:	d3462017 	ubfx	x23, x0, #6, #3
		/* Remote domain is converting source pointer to ID */
		source_id = (int16_t)(uintptr_t)log_msg_get_source(msg);
	} else {
		void *source = (void *)log_msg_get_source(msg);

		if (source != NULL) {
  4061b4:	b4000143 	cbz	x3, 4061dc <log_output_msg_process+0x58>
  4061b8:	d0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4061bc:	f9473421 	ldr	x1, [x1, #3688]
  4061c0:	cb010063 	sub	x3, x3, x1
  4061c4:	d344fc63 	lsr	x3, x3, #4
			source_id = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
  4061c8:	13003c61 	sxth	w1, w3
		} else {
			source_id = -1;
		}
	}

	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  4061cc:	377802c3 	tbnz	w3, #15, 406224 <log_output_msg_process+0xa0>
  4061d0:	53031400 	ubfx	w0, w0, #3, #3
  4061d4:	97fffd8d 	bl	405808 <log_source_name_get>
  4061d8:	aa0003e3 	mov	x3, x0
 *
 * @return pointer to the package.
 */
static inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;
  4061dc:	f8410667 	ldr	x7, [x19], #16
	size_t plen, dlen;
	uint8_t *package = log_msg_get_package(msg, &plen);
	uint8_t *data = log_msg_get_data(msg, &dlen);

	log_output_process(output, timestamp, NULL, sname, level,
  4061e0:	b90003f5 	str	w21, [sp]
  4061e4:	2a1703e4 	mov	w4, w23
  4061e8:	2a1603e1 	mov	w1, w22
  4061ec:	d2800002 	mov	x2, #0x0                   	// #0
  4061f0:	d3494ce0 	ubfx	x0, x7, #9, #11
  4061f4:	53147ce7 	lsr	w7, w7, #20
  4061f8:	f100001f 	cmp	x0, #0x0
	return msg->data + msg->hdr.desc.package_len;
  4061fc:	8b000266 	add	x6, x19, x0
  406200:	9a9f1265 	csel	x5, x19, xzr, ne  // ne = any
  406204:	aa1403e0 	mov	x0, x20
  406208:	97fffec3 	bl	405d14 <log_output_process>
			   plen > 0 ? package : NULL, data, dlen, flags);
}
  40620c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  406210:	a94253f3 	ldp	x19, x20, [sp, #32]
  406214:	a9435bf5 	ldp	x21, x22, [sp, #48]
  406218:	f94023f7 	ldr	x23, [sp, #64]
  40621c:	910143ff 	add	sp, sp, #0x50
  406220:	d65f03c0 	ret
	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  406224:	d2800003 	mov	x3, #0x0                   	// #0
  406228:	17ffffed 	b	4061dc <log_output_msg_process+0x58>

000000000040622c <log_output_timestamp_freq_set>:
		     output->control_block->ctx);
}

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
  40622c:	b0000142 	adrp	x2, 42f000 <can_loopback_dev_data_0+0xc0>
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  406230:	52884804 	mov	w4, #0x4240                	// #16960
	timestamp_div = 1U;
  406234:	52800021 	mov	w1, #0x1                   	// #1
	while (frequency > 1000000) {
  406238:	52800003 	mov	w3, #0x0                   	// #0
	timestamp_div = 1U;
  40623c:	b90cf841 	str	w1, [x2, #3320]
	while (frequency > 1000000) {
  406240:	72a001e4 	movk	w4, #0xf, lsl #16
  406244:	6b04001f 	cmp	w0, w4
  406248:	540000c8 	b.hi	406260 <log_output_timestamp_freq_set+0x34>  // b.pmore
  40624c:	34000043 	cbz	w3, 406254 <log_output_timestamp_freq_set+0x28>
  406250:	b90cf841 	str	w1, [x2, #3320]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
  406254:	b0000141 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  406258:	b90cf420 	str	w0, [x1, #3316]
}
  40625c:	d65f03c0 	ret
		frequency /= 2U;
  406260:	53017c00 	lsr	w0, w0, #1
		timestamp_div *= 2U;
  406264:	531f7821 	lsl	w1, w1, #1
  406268:	52800023 	mov	w3, #0x1                   	// #1
  40626c:	17fffff6 	b	406244 <log_output_timestamp_freq_set+0x18>

0000000000406270 <format_set>:
	log_output_func(&log_output_posix, &msg->log, flags);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
	log_format_current = log_type;
  406270:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  406274:	b90cfc01 	str	w1, [x0, #3324]
	return 0;
}
  406278:	52800000 	mov	w0, #0x0                   	// #0
  40627c:	d65f03c0 	ret

0000000000406280 <panic>:
	log_output_flush(&log_output_posix);
  406280:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406284:	91216000 	add	x0, x0, #0x858
  406288:	17fffe96 	b	405ce0 <log_output_flush>

000000000040628c <char_out>:
{
  40628c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  406290:	910003fd 	mov	x29, sp
  406294:	a90153f3 	stp	x19, x20, [sp, #16]
  406298:	b0000154 	adrp	x20, 42f000 <can_loopback_dev_data_0+0xc0>
  40629c:	aa0003f3 	mov	x19, x0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  4062a0:	91340294 	add	x20, x20, #0xd00
{
  4062a4:	a9025bf5 	stp	x21, x22, [sp, #32]
		posix_print_trace("%s\n", stdout_buff);
  4062a8:	b0000155 	adrp	x21, 42f000 <can_loopback_dev_data_0+0xc0>
{
  4062ac:	aa0103f6 	mov	x22, x1
		posix_print_trace("%s\n", stdout_buff);
  4062b0:	91399eb5 	add	x21, x21, #0xe67
{
  4062b4:	a90363f7 	stp	x23, x24, [sp, #48]
  4062b8:	8b010017 	add	x23, x0, x1
		posix_print_trace("%s\n", stdout_buff);
  4062bc:	90000098 	adrp	x24, 416000 <__func__.0+0x57a>
	for (size_t i = 0; i < length; i++) {
  4062c0:	eb17027f 	cmp	x19, x23
  4062c4:	540000e1 	b.ne	4062e0 <char_out+0x54>  // b.any
}
  4062c8:	2a1603e0 	mov	w0, w22
  4062cc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4062d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4062d4:	a94363f7 	ldp	x23, x24, [sp, #48]
  4062d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4062dc:	d65f03c0 	ret
		preprint_char(data[i]);
  4062e0:	39400260 	ldrb	w0, [x19]
	if (c == '\r') {
  4062e4:	7100341f 	cmp	w0, #0xd
  4062e8:	54000240 	b.eq	406330 <char_out+0xa4>  // b.none
	if (c != '\n') {
  4062ec:	7100281f 	cmp	w0, #0xa
  4062f0:	54000240 	b.eq	406338 <char_out+0xac>  // b.none
		stdout_buff[n_pend++] = c;
  4062f4:	b9400282 	ldr	w2, [x20]
  4062f8:	11000441 	add	w1, w2, #0x1
  4062fc:	b9000281 	str	w1, [x20]
  406300:	3822caa0 	strb	w0, [x21, w2, sxtw]
	int printnow = 0;
  406304:	52800000 	mov	w0, #0x0                   	// #0
		stdout_buff[n_pend] = 0;
  406308:	3821cabf 	strb	wzr, [x21, w1, sxtw]
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  40630c:	b9400281 	ldr	w1, [x20]
  406310:	7103f83f 	cmp	w1, #0xfe
  406314:	5400004c 	b.gt	40631c <char_out+0x90>
	if (printnow) {
  406318:	340000c0 	cbz	w0, 406330 <char_out+0xa4>
		posix_print_trace("%s\n", stdout_buff);
  40631c:	aa1503e1 	mov	x1, x21
  406320:	91092f00 	add	x0, x24, #0x24b
  406324:	94000628 	bl	407bc4 <posix_print_trace>
		stdout_buff[0] = 0;
  406328:	390002bf 	strb	wzr, [x21]
		n_pend = 0;
  40632c:	b900029f 	str	wzr, [x20]
	for (size_t i = 0; i < length; i++) {
  406330:	91000673 	add	x19, x19, #0x1
  406334:	17ffffe3 	b	4062c0 <char_out+0x34>
		printnow = 1;
  406338:	52800020 	mov	w0, #0x1                   	// #1
  40633c:	17fffff4 	b	40630c <char_out+0x80>

0000000000406340 <process>:
{
  406340:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  406344:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
{
  406348:	910003fd 	mov	x29, sp
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  40634c:	b94cfc00 	ldr	w0, [x0, #3324]
{
  406350:	f9000bf3 	str	x19, [sp, #16]
  406354:	aa0103f3 	mov	x19, x1
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  406358:	97fffc5c 	bl	4054c8 <log_format_func_t_get>
  40635c:	aa0003f0 	mov	x16, x0
	log_output_func(&log_output_posix, &msg->log, flags);
  406360:	aa1303e1 	mov	x1, x19
  406364:	528001e2 	mov	w2, #0xf                   	// #15
}
  406368:	f9400bf3 	ldr	x19, [sp, #16]
	log_output_func(&log_output_posix, &msg->log, flags);
  40636c:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
}
  406370:	a8c27bfd 	ldp	x29, x30, [sp], #32
	log_output_func(&log_output_posix, &msg->log, flags);
  406374:	91216000 	add	x0, x0, #0x858
  406378:	d61f0200 	br	x16

000000000040637c <sys_trace_isr_enter>:
 *
 * SPDX-License-Identifier: Apache-2.0
 */


void sys_trace_isr_enter(void) {}
  40637c:	d65f03c0 	ret

0000000000406380 <sys_trace_isr_exit>:
  406380:	d65f03c0 	ret

0000000000406384 <sys_trace_idle>:
  406384:	d65f03c0 	ret

0000000000406388 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
  406388:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40638c:	910003fd 	mov	x29, sp
	sys_trace_idle();
  406390:	97fffffd 	bl	406384 <sys_trace_idle>
	posix_irq_full_unlock();
  406394:	94000493 	bl	4075e0 <posix_irq_full_unlock>
	posix_halt_cpu();
}
  406398:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_halt_cpu();
  40639c:	140001d9 	b	406b00 <posix_halt_cpu>

00000000004063a0 <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
  4063a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
  4063a4:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  4063a8:	91093c00 	add	x0, x0, #0x24f
{
  4063ac:	910003fd 	mov	x29, sp
	posix_print_error_and_exit("Exiting due to fatal error\n");
  4063b0:	9400059f 	bl	407a2c <posix_print_error_and_exit>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  4063b4:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  4063b8:	d0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4063bc:	9109ac21 	add	x1, x1, #0x26b
  4063c0:	91362c00 	add	x0, x0, #0xd8b
  4063c4:	528002a2 	mov	w2, #0x15                  	// #21
  4063c8:	94000599 	bl	407a2c <posix_print_error_and_exit>

00000000004063cc <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
  4063cc:	14000487 	b	4075e8 <posix_irq_enable>

00000000004063d0 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
  4063d0:	34000080 	cbz	w0, 4063e0 <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  4063d4:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  4063d8:	910a5800 	add	x0, x0, #0x296
  4063dc:	14000594 	b	407a2c <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
  4063e0:	d65f03c0 	ret

00000000004063e4 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
  4063e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  4063e8:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  4063ec:	91280000 	add	x0, x0, #0xa00
{
  4063f0:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  4063f4:	97ffec93 	bl	401640 <pthread_mutex_unlock@plt>
  4063f8:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  4063fc:	910ac021 	add	x1, x1, #0x2b0
  406400:	97fffff4 	bl	4063d0 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  406404:	97ffec7f 	bl	401600 <pthread_self@plt>
}
  406408:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  40640c:	17ffec4d 	b	401540 <pthread_detach@plt>

0000000000406410 <abort_tail>:
{
  406410:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	threads_table[this_th_nbr].running = false;
  406414:	90000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  406418:	937b7c00 	sbfiz	x0, x0, #5, #32
{
  40641c:	910003fd 	mov	x29, sp
	threads_table[this_th_nbr].running = false;
  406420:	f9451821 	ldr	x1, [x1, #2608]
  406424:	8b000022 	add	x2, x1, x0
  406428:	3900105f 	strb	wzr, [x2, #4]
	threads_table[this_th_nbr].state = ABORTED;
  40642c:	52800062 	mov	w2, #0x3                   	// #3
  406430:	b8206822 	str	w2, [x1, x0]
	posix_preexit_cleanup();
  406434:	97ffffec 	bl	4063e4 <posix_preexit_cleanup>
	pthread_exit(NULL);
  406438:	d2800000 	mov	x0, #0x0                   	// #0
  40643c:	97ffec31 	bl	401500 <pthread_exit@plt>

0000000000406440 <posix_wait_until_allowed>:
{
  406440:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  406444:	910003fd 	mov	x29, sp
  406448:	a9025bf5 	stp	x21, x22, [sp, #32]
	threads_table[this_th_nbr].running = false;
  40644c:	90000155 	adrp	x21, 42e000 <thingset_workq+0x8>
	while (this_th_nbr != currently_allowed_thread) {
  406450:	b0000156 	adrp	x22, 42f000 <can_loopback_dev_data_0+0xc0>
{
  406454:	a90153f3 	stp	x19, x20, [sp, #16]
	threads_table[this_th_nbr].running = false;
  406458:	937b7c14 	sbfiz	x20, x0, #5, #32
{
  40645c:	2a0003f3 	mov	w19, w0
	threads_table[this_th_nbr].running = false;
  406460:	f9451aa0 	ldr	x0, [x21, #2608]
	while (this_th_nbr != currently_allowed_thread) {
  406464:	913412d6 	add	x22, x22, #0xd04
{
  406468:	a90363f7 	stp	x23, x24, [sp, #48]
		pthread_cond_wait(&cond_threads, &mtx_threads);
  40646c:	90000157 	adrp	x23, 42e000 <thingset_workq+0x8>
	threads_table[this_th_nbr].running = false;
  406470:	8b140000 	add	x0, x0, x20
		pthread_cond_wait(&cond_threads, &mtx_threads);
  406474:	90000158 	adrp	x24, 42e000 <thingset_workq+0x8>
  406478:	912802f7 	add	x23, x23, #0xa00
  40647c:	91274318 	add	x24, x24, #0x9d0
	threads_table[this_th_nbr].running = false;
  406480:	3900101f 	strb	wzr, [x0, #4]
	while (this_th_nbr != currently_allowed_thread) {
  406484:	b94002c0 	ldr	w0, [x22]
  406488:	6b13001f 	cmp	w0, w19
  40648c:	54000141 	b.ne	4064b4 <posix_wait_until_allowed+0x74>  // b.any
	threads_table[this_th_nbr].running = true;
  406490:	f9451aa0 	ldr	x0, [x21, #2608]
  406494:	52800021 	mov	w1, #0x1                   	// #1
  406498:	8b140000 	add	x0, x0, x20
  40649c:	39001001 	strb	w1, [x0, #4]
}
  4064a0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4064a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4064a8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4064ac:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4064b0:	d65f03c0 	ret
		pthread_cond_wait(&cond_threads, &mtx_threads);
  4064b4:	aa1703e1 	mov	x1, x23
  4064b8:	aa1803e0 	mov	x0, x24
  4064bc:	97ffec2d 	bl	401570 <pthread_cond_wait@plt>
		if (threads_table &&
  4064c0:	f9451aa0 	ldr	x0, [x21, #2608]
  4064c4:	b4fffe00 	cbz	x0, 406484 <posix_wait_until_allowed+0x44>
  4064c8:	b8746800 	ldr	w0, [x0, x20]
  4064cc:	7100081f 	cmp	w0, #0x2
  4064d0:	54fffda1 	b.ne	406484 <posix_wait_until_allowed+0x44>  // b.any
			abort_tail(this_th_nbr);
  4064d4:	2a1303e0 	mov	w0, w19
  4064d8:	97ffffce 	bl	406410 <abort_tail>

00000000004064dc <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
  4064dc:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4064e0:	397d9c00 	ldrb	w0, [x0, #3943]
  4064e4:	34000180 	cbz	w0, 406514 <posix_cleanup_handler+0x38>
{
  4064e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  4064ec:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  4064f0:	91280000 	add	x0, x0, #0xa00
{
  4064f4:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  4064f8:	97ffec52 	bl	401640 <pthread_mutex_unlock@plt>
  4064fc:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406500:	910ac021 	add	x1, x1, #0x2b0
  406504:	97ffffb3 	bl	4063d0 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  406508:	97ffec3e 	bl	401600 <pthread_self@plt>
}
  40650c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  406510:	17ffec0c 	b	401540 <pthread_detach@plt>
  406514:	d65f03c0 	ret

0000000000406518 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
  406518:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  40651c:	910003fd 	mov	x29, sp
  406520:	f9000be0 	str	x0, [sp, #16]
  406524:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406528:	f9478400 	ldr	x0, [x0, #3848]
  40652c:	f9400001 	ldr	x1, [x0]
  406530:	f9007fe1 	str	x1, [sp, #248]
  406534:	d2800001 	mov	x1, #0x0                   	// #0

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  406538:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  40653c:	91280000 	add	x0, x0, #0xa00
  406540:	97ffec3c 	bl	401630 <pthread_mutex_lock@plt>
  406544:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406548:	910b4c21 	add	x1, x1, #0x2d3
  40654c:	97ffffa1 	bl	4063d0 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
  406550:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  406554:	f9451800 	ldr	x0, [x0, #2608]
  406558:	b50000a0 	cbnz	x0, 40656c <posix_thread_starter+0x54>
		posix_cleanup_handler(arg);
  40655c:	f9400be0 	ldr	x0, [sp, #16]
  406560:	97ffffdf 	bl	4064dc <posix_cleanup_handler>
		pthread_exit(NULL);
  406564:	d2800000 	mov	x0, #0x0                   	// #0
  406568:	97ffebe6 	bl	401500 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
  40656c:	90000000 	adrp	x0, 406000 <log_output_process+0x2ec>
  406570:	91137000 	add	x0, x0, #0x4dc
  406574:	52800001 	mov	w1, #0x0                   	// #0
  406578:	f9000fe0 	str	x0, [sp, #24]
  40657c:	910083e0 	add	x0, sp, #0x20
  406580:	97ffeb78 	bl	401360 <__sigsetjmp@plt>
  406584:	340000a0 	cbz	w0, 406598 <posix_thread_starter+0x80>
  406588:	a94107e0 	ldp	x0, x1, [sp, #16]
  40658c:	d63f0020 	blr	x1
  406590:	910083e0 	add	x0, sp, #0x20
  406594:	97ffebff 	bl	401590 <__pthread_unwind_next@plt>
  406598:	910083e0 	add	x0, sp, #0x20
  40659c:	97ffec15 	bl	4015f0 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
  4065a0:	b94013e0 	ldr	w0, [sp, #16]
  4065a4:	97ffffa7 	bl	406440 <posix_wait_until_allowed>

	posix_new_thread_pre_start();
  4065a8:	94000108 	bl	4069c8 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
  4065ac:	90000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  4065b0:	b94013e0 	ldr	w0, [sp, #16]
  4065b4:	f9451821 	ldr	x1, [x1, #2608]
  4065b8:	937b7c00 	sbfiz	x0, x0, #5, #32
  4065bc:	8b000020 	add	x0, x1, x0
  4065c0:	f9400c00 	ldr	x0, [x0, #24]

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
  4065c4:	a9410c02 	ldp	x2, x3, [x0, #16]
  4065c8:	f9400401 	ldr	x1, [x0, #8]
  4065cc:	f9400000 	ldr	x0, [x0]
  4065d0:	97fff5e9 	bl	403d74 <z_thread_entry>

00000000004065d4 <posix_swap>:
{
  4065d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4065d8:	910003fd 	mov	x29, sp
  4065dc:	f9000bf3 	str	x19, [sp, #16]
  4065e0:	2a0103f3 	mov	w19, w1
	currently_allowed_thread = next_allowed_th;
  4065e4:	b0000141 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  4065e8:	b90d0420 	str	w0, [x1, #3332]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  4065ec:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  4065f0:	91274000 	add	x0, x0, #0x9d0
  4065f4:	97ffeb9f 	bl	401470 <pthread_cond_broadcast@plt>
  4065f8:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  4065fc:	910bd021 	add	x1, x1, #0x2f4
  406600:	97ffff74 	bl	4063d0 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
  406604:	90000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  406608:	937b7e60 	sbfiz	x0, x19, #5, #32
  40660c:	f9451821 	ldr	x1, [x1, #2608]
  406610:	b8606820 	ldr	w0, [x1, x0]
  406614:	7100081f 	cmp	w0, #0x2
		abort_tail(this_th_nbr);
  406618:	2a1303e0 	mov	w0, w19
	if (threads_table[this_th_nbr].state == ABORTING) {
  40661c:	54000041 	b.ne	406624 <posix_swap+0x50>  // b.any
		abort_tail(this_th_nbr);
  406620:	97ffff7c 	bl	406410 <abort_tail>
}
  406624:	f9400bf3 	ldr	x19, [sp, #16]
  406628:	a8c27bfd 	ldp	x29, x30, [sp], #32
		posix_wait_until_allowed(this_th_nbr);
  40662c:	17ffff85 	b	406440 <posix_wait_until_allowed>

0000000000406630 <posix_main_thread_start>:
{
  406630:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	currently_allowed_thread = next_allowed_th;
  406634:	b0000141 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
{
  406638:	910003fd 	mov	x29, sp
	currently_allowed_thread = next_allowed_th;
  40663c:	b90d0420 	str	w0, [x1, #3332]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  406640:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  406644:	91274000 	add	x0, x0, #0x9d0
  406648:	97ffeb8a 	bl	401470 <pthread_cond_broadcast@plt>
  40664c:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406650:	910bd021 	add	x1, x1, #0x2f4
  406654:	97ffff5f 	bl	4063d0 <pc_safe_call>
	posix_preexit_cleanup();
  406658:	97ffff63 	bl	4063e4 <posix_preexit_cleanup>
	pthread_exit(NULL);
  40665c:	d2800000 	mov	x0, #0x0                   	// #0
  406660:	97ffeba8 	bl	401500 <pthread_exit@plt>

0000000000406664 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
  406664:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (int i = 0; i < threads_table_size; i++) {
  406668:	d2800002 	mov	x2, #0x0                   	// #0
{
  40666c:	910003fd 	mov	x29, sp
  406670:	a9025bf5 	stp	x21, x22, [sp, #32]
		if ((threads_table[i].state == NOTUSED)
  406674:	90000155 	adrp	x21, 42e000 <thingset_workq+0x8>
	for (int i = 0; i < threads_table_size; i++) {
  406678:	b0000156 	adrp	x22, 42f000 <can_loopback_dev_data_0+0xc0>
{
  40667c:	a90153f3 	stp	x19, x20, [sp, #16]
  406680:	aa0003f4 	mov	x20, x0
	for (int i = 0; i < threads_table_size; i++) {
  406684:	b94d0ec1 	ldr	w1, [x22, #3340]
		if ((threads_table[i].state == NOTUSED)
  406688:	f9451aa0 	ldr	x0, [x21, #2608]
  40668c:	d1008003 	sub	x3, x0, #0x20
  406690:	2a0203f3 	mov	w19, w2
	for (int i = 0; i < threads_table_size; i++) {
  406694:	6b02003f 	cmp	w1, w2
  406698:	5400026c 	b.gt	4066e4 <posix_new_thread+0x80>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
  40669c:	11010021 	add	w1, w1, #0x40
	threads_table = realloc(threads_table,
  4066a0:	937b7c21 	sbfiz	x1, x1, #5, #32
  4066a4:	97ffeb7b 	bl	401490 <realloc@plt>
  4066a8:	f9051aa0 	str	x0, [x21, #2608]
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  4066ac:	b5000080 	cbnz	x0, 4066bc <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  4066b0:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  4066b4:	910c6800 	add	x0, x0, #0x31a
  4066b8:	940004dd 	bl	407a2c <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
  4066bc:	b94d0ed3 	ldr	w19, [x22, #3340]
   case no work is done at all.  We detect these problems by referring
   non-existing functions.  */
__fortify_function void *
__NTH (memset (void *__dest, int __ch, size_t __len))
{
  return __builtin___memset_chk (__dest, __ch, __len,
  4066c0:	d2810002 	mov	x2, #0x800                 	// #2048
  4066c4:	f9451aa3 	ldr	x3, [x21, #2608]
  4066c8:	52800001 	mov	w1, #0x0                   	// #0
  4066cc:	937b7e60 	sbfiz	x0, x19, #5, #32
  4066d0:	8b000060 	add	x0, x3, x0
  4066d4:	97ffeb53 	bl	401420 <memset@plt>
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
  4066d8:	11010260 	add	w0, w19, #0x40
  4066dc:	b90d0ec0 	str	w0, [x22, #3340]
	return threads_table_size - PC_ALLOC_CHUNK_SIZE;
  4066e0:	14000005 	b	4066f4 <posix_new_thread+0x90>
		if ((threads_table[i].state == NOTUSED)
  4066e4:	91000442 	add	x2, x2, #0x1
  4066e8:	d37be844 	lsl	x4, x2, #5
  4066ec:	b8646864 	ldr	w4, [x3, x4]
  4066f0:	35fffd04 	cbnz	w4, 406690 <posix_new_thread+0x2c>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
  4066f4:	f9451aa1 	ldr	x1, [x21, #2608]
  4066f8:	937b7e60 	sbfiz	x0, x19, #5, #32
  4066fc:	52800022 	mov	w2, #0x1                   	// #1
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  406700:	93407e63 	sxtw	x3, w19
	threads_table[t_slot].state = USED;
  406704:	8b000024 	add	x4, x1, x0
  406708:	b8206822 	str	w2, [x1, x0]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  40670c:	b0000141 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  406710:	b94d0820 	ldr	w0, [x1, #3336]
	threads_table[t_slot].running = false;
  406714:	3900109f 	strb	wzr, [x4, #4]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  406718:	b9001080 	str	w0, [x4, #16]
  40671c:	0b020002 	add	w2, w0, w2
	threads_table[t_slot].t_status = ptr;
  406720:	f9000c94 	str	x20, [x4, #24]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  406724:	91002080 	add	x0, x4, #0x8
	ptr->thread_idx = t_slot;
  406728:	b9002293 	str	w19, [x20, #32]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  40672c:	b90d0822 	str	w2, [x1, #3336]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  406730:	d2800001 	mov	x1, #0x0                   	// #0
  406734:	90000002 	adrp	x2, 406000 <log_output_process+0x2ec>
  406738:	91146042 	add	x2, x2, #0x518
  40673c:	97ffeb9d 	bl	4015b0 <pthread_create@plt>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
  406740:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  406744:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
}
  406748:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  40674c:	910d0821 	add	x1, x1, #0x342
}
  406750:	a8c37bfd 	ldp	x29, x30, [sp], #48
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  406754:	17ffff1f 	b	4063d0 <pc_safe_call>

0000000000406758 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
  406758:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_create_count = 0;
  40675c:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>

	currently_allowed_thread = -1;
  406760:	12800001 	mov	w1, #0xffffffff            	// #-1
{
  406764:	910003fd 	mov	x29, sp
	thread_create_count = 0;
  406768:	b90d081f 	str	wzr, [x0, #3336]
	currently_allowed_thread = -1;
  40676c:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  406770:	b90d0401 	str	w1, [x0, #3332]

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
  406774:	d2800401 	mov	x1, #0x20                  	// #32
  406778:	d2800800 	mov	x0, #0x40                  	// #64
  40677c:	97ffeb39 	bl	401460 <calloc@plt>
  406780:	90000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  406784:	f9051820 	str	x0, [x1, #2608]
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  406788:	b5000080 	cbnz	x0, 406798 <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  40678c:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406790:	910c6800 	add	x0, x0, #0x31a
  406794:	940004a6 	bl	407a2c <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
  406798:	52800801 	mov	w1, #0x40                  	// #64
  40679c:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4067a0:	b90d0c01 	str	w1, [x0, #3340]


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  4067a4:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  4067a8:	91280000 	add	x0, x0, #0xa00
  4067ac:	97ffeba1 	bl	401630 <pthread_mutex_lock@plt>
}
  4067b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  4067b4:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  4067b8:	910b4c21 	add	x1, x1, #0x2d3
  4067bc:	17ffff05 	b	4063d0 <pc_safe_call>

00000000004067c0 <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
  4067c0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4067c4:	910003fd 	mov	x29, sp
  4067c8:	a9025bf5 	stp	x21, x22, [sp, #32]

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  4067cc:	90000155 	adrp	x21, 42e000 <thingset_workq+0x8>
  4067d0:	f9451aa0 	ldr	x0, [x21, #2608]
{
  4067d4:	a90153f3 	stp	x19, x20, [sp, #16]
  4067d8:	f9001bf7 	str	x23, [sp, #48]
	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  4067dc:	b4000200 	cbz	x0, 40681c <posix_core_clean_up+0x5c>
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;
  4067e0:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>

	for (int i = 0; i < threads_table_size; i++) {
  4067e4:	b0000154 	adrp	x20, 42f000 <can_loopback_dev_data_0+0xc0>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
  4067e8:	f0000076 	adrp	x22, 415000 <__func__.2+0x30c>
	for (int i = 0; i < threads_table_size; i++) {
  4067ec:	91343294 	add	x20, x20, #0xd0c
			posix_print_warning(
  4067f0:	910e9ad6 	add	x22, x22, #0x3a6
	terminate = true;
  4067f4:	52800021 	mov	w1, #0x1                   	// #1
	for (int i = 0; i < threads_table_size; i++) {
  4067f8:	d2800013 	mov	x19, #0x0                   	// #0
	terminate = true;
  4067fc:	393d9c01 	strb	w1, [x0, #3943]
	for (int i = 0; i < threads_table_size; i++) {
  406800:	b9400281 	ldr	w1, [x20]
		if (threads_table[i].state != USED) {
  406804:	9128c2b7 	add	x23, x21, #0xa30
  406808:	f9451aa0 	ldr	x0, [x21, #2608]
	for (int i = 0; i < threads_table_size; i++) {
  40680c:	6b13003f 	cmp	w1, w19
  406810:	5400010c 	b.gt	406830 <posix_core_clean_up+0x70>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
  406814:	97ffeb53 	bl	401560 <free@plt>
	threads_table = NULL;
  406818:	f90002ff 	str	xzr, [x23]
}
  40681c:	a94153f3 	ldp	x19, x20, [sp, #16]
  406820:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406824:	f9401bf7 	ldr	x23, [sp, #48]
  406828:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40682c:	d65f03c0 	ret
		if (threads_table[i].state != USED) {
  406830:	d37bea61 	lsl	x1, x19, #5
  406834:	8b131402 	add	x2, x0, x19, lsl #5
  406838:	b8616800 	ldr	w0, [x0, x1]
  40683c:	7100041f 	cmp	w0, #0x1
  406840:	540000e1 	b.ne	40685c <posix_core_clean_up+0x9c>  // b.any
		if (pthread_cancel(threads_table[i].thread)) {
  406844:	f9400440 	ldr	x0, [x2, #8]
  406848:	97ffeb76 	bl	401620 <pthread_cancel@plt>
  40684c:	34000080 	cbz	w0, 40685c <posix_core_clean_up+0x9c>
			posix_print_warning(
  406850:	2a1303e1 	mov	w1, w19
  406854:	aa1603e0 	mov	x0, x22
  406858:	940004a9 	bl	407afc <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
  40685c:	91000673 	add	x19, x19, #0x1
  406860:	17ffffe8 	b	406800 <posix_core_clean_up+0x40>

0000000000406864 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
  406864:	90000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  406868:	937b7c00 	sbfiz	x0, x0, #5, #32
  40686c:	f9451821 	ldr	x1, [x1, #2608]
  406870:	b8606822 	ldr	w2, [x1, x0]
  406874:	7100045f 	cmp	w2, #0x1
  406878:	54000061 	b.ne	406884 <posix_abort_thread+0x20>  // b.any

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
  40687c:	52800042 	mov	w2, #0x2                   	// #2
  406880:	b8206822 	str	w2, [x1, x0]
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
  406884:	d65f03c0 	ret

0000000000406888 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
  406888:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40688c:	910003fd 	mov	x29, sp
  406890:	a90153f3 	stp	x19, x20, [sp, #16]
  406894:	aa0003f4 	mov	x20, x0
  406898:	a9025bf5 	stp	x21, x22, [sp, #32]
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
  40689c:	f9402813 	ldr	x19, [x0, #80]
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
  4068a0:	b9402276 	ldr	w22, [x19, #32]
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
  4068a4:	9400034c 	bl	4075d4 <posix_irq_lock>
  4068a8:	2a0003f5 	mov	w21, w0

	key = irq_lock();

	if (_current == thread) {
  4068ac:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4068b0:	f9474000 	ldr	x0, [x0, #3712]
  4068b4:	f9400800 	ldr	x0, [x0, #16]
  4068b8:	eb14001f 	cmp	x0, x20
  4068bc:	54000141 	b.ne	4068e4 <z_impl_k_thread_abort+0x5c>  // b.any
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
  4068c0:	b9402660 	ldr	w0, [x19, #36]
  4068c4:	350002a0 	cbnz	w0, 406918 <z_impl_k_thread_abort+0x90>
			tstatus->aborted = 1;
  4068c8:	52800020 	mov	w0, #0x1                   	// #1
  4068cc:	b9002660 	str	w0, [x19, #36]
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
  4068d0:	90000141 	adrp	x1, 42e000 <thingset_workq+0x8>
  4068d4:	937b7ec0 	sbfiz	x0, x22, #5, #32
  4068d8:	52800042 	mov	w2, #0x2                   	// #2
  4068dc:	f9451821 	ldr	x1, [x1, #2608]
  4068e0:	b8206822 	str	w2, [x1, x0]
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
  4068e4:	aa1403e0 	mov	x0, x20
  4068e8:	94003221 	bl	41316c <z_thread_abort>

	if (tstatus->aborted == 0) {
  4068ec:	b9402660 	ldr	w0, [x19, #36]
  4068f0:	350000a0 	cbnz	w0, 406904 <z_impl_k_thread_abort+0x7c>
		PC_DEBUG("%s aborting now [%i] %i\n",
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
  4068f4:	52800020 	mov	w0, #0x1                   	// #1
  4068f8:	b9002660 	str	w0, [x19, #36]
		posix_abort_thread(thread_idx);
  4068fc:	2a1603e0 	mov	w0, w22
  406900:	97ffffd9 	bl	406864 <posix_abort_thread>
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
  406904:	2a1503e0 	mov	w0, w21
}
  406908:	a94153f3 	ldp	x19, x20, [sp, #16]
  40690c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406910:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule_irqlock(key);
  406914:	14002b62 	b	41169c <z_reschedule_irqlock>
			posix_print_warning(/* LCOV_EXCL_LINE */
  406918:	2a1603e1 	mov	w1, w22
  40691c:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406920:	910f6800 	add	x0, x0, #0x3da
  406924:	94000476 	bl	407afc <posix_print_warning>
  406928:	17ffffea 	b	4068d0 <z_impl_k_thread_abort+0x48>

000000000040692c <arch_swap>:
#include <zephyr/irq.h>
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
  40692c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  406930:	910003fd 	mov	x29, sp
  406934:	f9000bf3 	str	x19, [sp, #16]
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
  406938:	d0000133 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  40693c:	f9474273 	ldr	x19, [x19, #3712]
  406940:	f9400a61 	ldr	x1, [x19, #16]
  406944:	b9004820 	str	w0, [x1, #72]
	_current->callee_saved.retval = -EAGAIN;
  406948:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40694c:	b9004c20 	str	w0, [x1, #76]
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
  406950:	f9401660 	ldr	x0, [x19, #40]
	posix_thread_status_t *this_thread_ptr  =
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
  406954:	f9000a60 	str	x0, [x19, #16]
	posix_thread_status_t *this_thread_ptr  =
  406958:	f9402821 	ldr	x1, [x1, #80]
	posix_thread_status_t *ready_thread_ptr =
  40695c:	f9402802 	ldr	x2, [x0, #80]
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
  406960:	b9402021 	ldr	w1, [x1, #32]
  406964:	b9402040 	ldr	w0, [x2, #32]
  406968:	97ffff1b 	bl	4065d4 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
  40696c:	f9400a60 	ldr	x0, [x19, #16]
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
  406970:	b9404800 	ldr	w0, [x0, #72]
  406974:	9400031a 	bl	4075dc <posix_irq_unlock>

	return _current->callee_saved.retval;
  406978:	f9400a60 	ldr	x0, [x19, #16]
}
  40697c:	f9400bf3 	ldr	x19, [sp, #16]
  406980:	b9404c00 	ldr	w0, [x0, #76]
  406984:	a8c27bfd 	ldp	x29, x30, [sp], #32
  406988:	d65f03c0 	ret

000000000040698c <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
  40698c:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406990:	f9474000 	ldr	x0, [x0, #3712]
  406994:	f9401401 	ldr	x1, [x0, #40]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
  406998:	f9000801 	str	x1, [x0, #16]
	posix_thread_status_t *ready_thread_ptr =
  40699c:	f9402822 	ldr	x2, [x1, #80]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
  4069a0:	b9402040 	ldr	w0, [x2, #32]
  4069a4:	17ffff23 	b	406630 <posix_main_thread_start>

00000000004069a8 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
  4069a8:	aa0003e1 	mov	x1, x0
	posix_thread_status_t *thread_status;

	/* We store it in the same place where normal archs store the
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
  4069ac:	d100a040 	sub	x0, x2, #0x28

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
  4069b0:	f81d8043 	stur	x3, [x2, #-40]
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
  4069b4:	a9009404 	stp	x4, x5, [x0, #8]
	thread_status->arg3 = p3;
  4069b8:	f9000c06 	str	x6, [x0, #24]
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
  4069bc:	b900241f 	str	wzr, [x0, #36]
#endif

	thread->callee_saved.thread_status = thread_status;
  4069c0:	f9002820 	str	x0, [x1, #80]

	posix_new_thread(thread_status);
  4069c4:	17ffff28 	b	406664 <posix_new_thread>

00000000004069c8 <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
  4069c8:	14000306 	b	4075e0 <posix_irq_full_unlock>

00000000004069cc <pc_safe_call>:
	if (unlikely(test)) {
  4069cc:	34000080 	cbz	w0, 4069dc <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  4069d0:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  4069d4:	910a5800 	add	x0, x0, #0x296
  4069d8:	14000415 	b	407a2c <posix_print_error_and_exit>
}
  4069dc:	d65f03c0 	ret

00000000004069e0 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
  4069e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4069e4:	910003fd 	mov	x29, sp
  4069e8:	f9000bf3 	str	x19, [sp, #16]
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4069ec:	90000153 	adrp	x19, 42e000 <thingset_workq+0x8>
  4069f0:	9129a273 	add	x19, x19, #0xa68
  4069f4:	aa1303e0 	mov	x0, x19
  4069f8:	97ffeb0e 	bl	401630 <pthread_mutex_lock@plt>
  4069fc:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406a00:	91115821 	add	x1, x1, #0x456
  406a04:	97fffff2 	bl	4069cc <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  406a08:	aa1303e0 	mov	x0, x19
  406a0c:	97ffeb0d 	bl	401640 <pthread_mutex_unlock@plt>
  406a10:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406a14:	9111cc21 	add	x1, x1, #0x473
  406a18:	97ffffed 	bl	4069cc <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
  406a1c:	97ffff4f 	bl	406758 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
  406a20:	94002065 	bl	40ebb4 <z_cstart>

0000000000406a24 <posix_is_cpu_running>:
	return !cpu_halted;
  406a24:	f0000120 	adrp	x0, 42d000 <__dso_handle>
  406a28:	396b9c00 	ldrb	w0, [x0, #2791]
}
  406a2c:	52000000 	eor	w0, w0, #0x1
  406a30:	d65f03c0 	ret

0000000000406a34 <posix_change_cpu_state_and_wait>:
{
  406a34:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  406a38:	910003fd 	mov	x29, sp
  406a3c:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406a40:	90000155 	adrp	x21, 42e000 <thingset_workq+0x8>
{
  406a44:	12001c16 	and	w22, w0, #0xff
  406a48:	f9001bf7 	str	x23, [sp, #48]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406a4c:	9129a2b7 	add	x23, x21, #0xa68
  406a50:	aa1703e0 	mov	x0, x23
{
  406a54:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406a58:	97ffeaf6 	bl	401630 <pthread_mutex_lock@plt>
	cpu_halted = halted;
  406a5c:	f0000133 	adrp	x19, 42d000 <__dso_handle>
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406a60:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406a64:	91115821 	add	x1, x1, #0x456
  406a68:	97ffffd9 	bl	4069cc <pc_safe_call>
	cpu_halted = halted;
  406a6c:	392b9e76 	strb	w22, [x19, #2791]
	while (cpu_halted == halted) {
  406a70:	912b9e73 	add	x19, x19, #0xae7
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  406a74:	90000154 	adrp	x20, 42e000 <thingset_workq+0x8>
  406a78:	9128e294 	add	x20, x20, #0xa38
  406a7c:	aa1403e0 	mov	x0, x20
  406a80:	97ffea7c 	bl	401470 <pthread_cond_broadcast@plt>
  406a84:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406a88:	91124821 	add	x1, x1, #0x492
  406a8c:	97ffffd0 	bl	4069cc <pc_safe_call>
	while (cpu_halted == halted) {
  406a90:	39400260 	ldrb	w0, [x19]
  406a94:	6b16001f 	cmp	w0, w22
  406a98:	54000140 	b.eq	406ac0 <posix_change_cpu_state_and_wait+0x8c>  // b.none
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  406a9c:	9129a2a0 	add	x0, x21, #0xa68
  406aa0:	97ffeae8 	bl	401640 <pthread_mutex_unlock@plt>
}
  406aa4:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  406aa8:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
}
  406aac:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  406ab0:	9111cc21 	add	x1, x1, #0x473
}
  406ab4:	f9401bf7 	ldr	x23, [sp, #48]
  406ab8:	a8c47bfd 	ldp	x29, x30, [sp], #64
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  406abc:	17ffffc4 	b	4069cc <pc_safe_call>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  406ac0:	aa1703e1 	mov	x1, x23
  406ac4:	aa1403e0 	mov	x0, x20
  406ac8:	97ffeaaa 	bl	401570 <pthread_cond_wait@plt>
  406acc:	17fffff1 	b	406a90 <posix_change_cpu_state_and_wait+0x5c>

0000000000406ad0 <posix_interrupt_raised>:
{
  406ad0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(false);
  406ad4:	52800000 	mov	w0, #0x0                   	// #0
{
  406ad8:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(false);
  406adc:	97ffffd6 	bl	406a34 <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
  406ae0:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  406ae4:	397da000 	ldrb	w0, [x0, #3944]
  406ae8:	34000080 	cbz	w0, 406af8 <posix_interrupt_raised+0x28>
}
  406aec:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_exit(0);
  406af0:	52800000 	mov	w0, #0x0                   	// #0
  406af4:	14000378 	b	4078d4 <posix_exit>
}
  406af8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  406afc:	d65f03c0 	ret

0000000000406b00 <posix_halt_cpu>:
{
  406b00:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(true);
  406b04:	52800020 	mov	w0, #0x1                   	// #1
{
  406b08:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(true);
  406b0c:	97ffffca 	bl	406a34 <posix_change_cpu_state_and_wait>
}
  406b10:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_irq_handler();
  406b14:	14000245 	b	407428 <posix_irq_handler>

0000000000406b18 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
  406b18:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  406b1c:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406b20:	910003fd 	mov	x29, sp
  406b24:	f9478400 	ldr	x0, [x0, #3848]
  406b28:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));

	cpu_halted = false;
  406b2c:	f0000133 	adrp	x19, 42d000 <__dso_handle>
{
  406b30:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406b34:	90000155 	adrp	x21, 42e000 <thingset_workq+0x8>
  406b38:	9129a2b6 	add	x22, x21, #0xa68
{
  406b3c:	f9400001 	ldr	x1, [x0]
  406b40:	f9001fe1 	str	x1, [sp, #56]
  406b44:	d2800001 	mov	x1, #0x0                   	// #0
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406b48:	aa1603e0 	mov	x0, x22
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  406b4c:	90000154 	adrp	x20, 42e000 <thingset_workq+0x8>
  406b50:	9128e294 	add	x20, x20, #0xa38
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406b54:	97ffeab7 	bl	401630 <pthread_mutex_lock@plt>
  406b58:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406b5c:	91115821 	add	x1, x1, #0x456
  406b60:	97ffff9b 	bl	4069cc <pc_safe_call>
	cpu_halted = false;
  406b64:	392b9e7f 	strb	wzr, [x19, #2791]
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  406b68:	90000002 	adrp	x2, 406000 <log_output_process+0x2ec>
	while (cpu_halted == false) {
  406b6c:	912b9e73 	add	x19, x19, #0xae7
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  406b70:	91278042 	add	x2, x2, #0x9e0
  406b74:	d2800003 	mov	x3, #0x0                   	// #0
  406b78:	d2800001 	mov	x1, #0x0                   	// #0
  406b7c:	9100c3e0 	add	x0, sp, #0x30
  406b80:	97ffea8c 	bl	4015b0 <pthread_create@plt>
  406b84:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406b88:	9112d021 	add	x1, x1, #0x4b4
  406b8c:	97ffff90 	bl	4069cc <pc_safe_call>
	while (cpu_halted == false) {
  406b90:	39400260 	ldrb	w0, [x19]
  406b94:	34000260 	cbz	w0, 406be0 <posix_boot_cpu+0xc8>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  406b98:	9129a2a0 	add	x0, x21, #0xa68
  406b9c:	97ffeaa9 	bl	401640 <pthread_mutex_unlock@plt>
  406ba0:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406ba4:	9111cc21 	add	x1, x1, #0x473
  406ba8:	97ffff89 	bl	4069cc <pc_safe_call>

	if (soc_terminate) {
  406bac:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  406bb0:	397da000 	ldrb	w0, [x0, #3944]
  406bb4:	34000060 	cbz	w0, 406bc0 <posix_boot_cpu+0xa8>
		posix_exit(0);
  406bb8:	52800000 	mov	w0, #0x0                   	// #0
  406bbc:	94000346 	bl	4078d4 <posix_exit>
	}
}
  406bc0:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406bc4:	f9478400 	ldr	x0, [x0, #3848]
  406bc8:	f9401fe2 	ldr	x2, [sp, #56]
  406bcc:	f9400001 	ldr	x1, [x0]
  406bd0:	eb010042 	subs	x2, x2, x1
  406bd4:	d2800001 	mov	x1, #0x0                   	// #0
  406bd8:	540000c0 	b.eq	406bf0 <posix_boot_cpu+0xd8>  // b.none
  406bdc:	97ffea35 	bl	4014b0 <__stack_chk_fail@plt>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  406be0:	aa1603e1 	mov	x1, x22
  406be4:	aa1403e0 	mov	x0, x20
  406be8:	97ffea62 	bl	401570 <pthread_cond_wait@plt>
  406bec:	17ffffe9 	b	406b90 <posix_boot_cpu+0x78>
}
  406bf0:	a94153f3 	ldp	x19, x20, [sp, #16]
  406bf4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406bf8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  406bfc:	d65f03c0 	ret

0000000000406c00 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
  406c00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  406c04:	d0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  406c08:	91258021 	add	x1, x1, #0x960
{
  406c0c:	910003fd 	mov	x29, sp
  406c10:	a90153f3 	stp	x19, x20, [sp, #16]
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  406c14:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
  406c18:	11000400 	add	w0, w0, #0x1
  406c1c:	f860d834 	ldr	x20, [x1, w0, sxtw #3]
  406c20:	eb13029f 	cmp	x20, x19
  406c24:	54000088 	b.hi	406c34 <run_native_tasks+0x34>  // b.pmore
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
			(*fptr)();
		}
	}
}
  406c28:	a94153f3 	ldp	x19, x20, [sp, #16]
  406c2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  406c30:	d65f03c0 	ret
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
  406c34:	f9400260 	ldr	x0, [x19]
  406c38:	b4000040 	cbz	x0, 406c40 <run_native_tasks+0x40>
			(*fptr)();
  406c3c:	d63f0000 	blr	x0
		fptr++) {
  406c40:	91002273 	add	x19, x19, #0x8
  406c44:	17fffff7 	b	406c20 <run_native_tasks+0x20>

0000000000406c48 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
  406c48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  406c4c:	910003fd 	mov	x29, sp
  406c50:	a90153f3 	stp	x19, x20, [sp, #16]
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
  406c54:	f0000134 	adrp	x20, 42d000 <__dso_handle>
  406c58:	396b9e80 	ldrb	w0, [x20, #2791]
{
  406c5c:	f90013f5 	str	x21, [sp, #32]
	if (cpu_halted) {
  406c60:	340000e0 	cbz	w0, 406c7c <posix_soc_clean_up+0x34>

		posix_core_clean_up();
  406c64:	97fffed7 	bl	4067c0 <posix_core_clean_up>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
  406c68:	a94153f3 	ldp	x19, x20, [sp, #16]
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  406c6c:	52800080 	mov	w0, #0x4                   	// #4
}
  406c70:	f94013f5 	ldr	x21, [sp, #32]
  406c74:	a8c37bfd 	ldp	x29, x30, [sp], #48
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  406c78:	17ffffe2 	b	406c00 <run_native_tasks>
	} else if (soc_terminate == false) {
  406c7c:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  406c80:	397da001 	ldrb	w1, [x0, #3944]
  406c84:	35000321 	cbnz	w1, 406ce8 <posix_soc_clean_up+0xa0>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406c88:	90000153 	adrp	x19, 42e000 <thingset_workq+0x8>
  406c8c:	9129a273 	add	x19, x19, #0xa68
		soc_terminate = true;
  406c90:	52800035 	mov	w21, #0x1                   	// #1
  406c94:	393da015 	strb	w21, [x0, #3944]
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  406c98:	aa1303e0 	mov	x0, x19
  406c9c:	97ffea65 	bl	401630 <pthread_mutex_lock@plt>
  406ca0:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406ca4:	91115821 	add	x1, x1, #0x456
  406ca8:	97ffff49 	bl	4069cc <pc_safe_call>
		cpu_halted = true;
  406cac:	392b9e95 	strb	w21, [x20, #2791]
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  406cb0:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  406cb4:	9128e000 	add	x0, x0, #0xa38
  406cb8:	97ffe9ee 	bl	401470 <pthread_cond_broadcast@plt>
  406cbc:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406cc0:	91124821 	add	x1, x1, #0x492
  406cc4:	97ffff42 	bl	4069cc <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  406cc8:	aa1303e0 	mov	x0, x19
  406ccc:	97ffea5d 	bl	401640 <pthread_mutex_unlock@plt>
  406cd0:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406cd4:	9111cc21 	add	x1, x1, #0x473
  406cd8:	97ffff3d 	bl	4069cc <pc_safe_call>
			sleep(1);
  406cdc:	52800020 	mov	w0, #0x1                   	// #1
  406ce0:	97ffe9d4 	bl	401430 <sleep@plt>
		while (1) {
  406ce4:	17fffffe 	b	406cdc <posix_soc_clean_up+0x94>
}
  406ce8:	a94153f3 	ldp	x19, x20, [sp, #16]
  406cec:	f94013f5 	ldr	x21, [sp, #32]
  406cf0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  406cf4:	d65f03c0 	ret

0000000000406cf8 <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
  406cf8:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  406cfc:	52800021 	mov	w1, #0x1                   	// #1
  406d00:	b90d1001 	str	w1, [x0, #3344]
}
  406d04:	d65f03c0 	ret

0000000000406d08 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
  406d08:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
  406d0c:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406d10:	910003fd 	mov	x29, sp
  406d14:	f9478400 	ldr	x0, [x0, #3848]
  406d18:	f9000bf3 	str	x19, [sp, #16]
  406d1c:	f9400001 	ldr	x1, [x0]
  406d20:	f9005fe1 	str	x1, [sp, #184]
  406d24:	d2800001 	mov	x1, #0x0                   	// #0
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
  406d28:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406d2c:	f9476c00 	ldr	x0, [x0, #3800]
  406d30:	f90013e0 	str	x0, [sp, #32]
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
  406d34:	9100a3e0 	add	x0, sp, #0x28
  406d38:	97ffe9b2 	bl	401400 <sigemptyset@plt>
	if (unlikely(test)) {
  406d3c:	340000c0 	cbz	w0, 406d54 <hwm_set_sig_handler+0x4c>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  406d40:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406d44:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406d48:	9113bc21 	add	x1, x1, #0x4ef
  406d4c:	910a5800 	add	x0, x0, #0x296
  406d50:	94000337 	bl	407a2c <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;
  406d54:	52b00000 	mov	w0, #0x80000000            	// #-2147483648

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  406d58:	910083f3 	add	x19, sp, #0x20
  406d5c:	aa1303e1 	mov	x1, x19
  406d60:	d2800002 	mov	x2, #0x0                   	// #0
	act.sa_flags = SA_RESETHAND;
  406d64:	b900abe0 	str	w0, [sp, #168]
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  406d68:	528001e0 	mov	w0, #0xf                   	// #15
  406d6c:	97ffe9d5 	bl	4014c0 <sigaction@plt>
	if (unlikely(test)) {
  406d70:	340000c0 	cbz	w0, 406d88 <hwm_set_sig_handler+0x80>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  406d74:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406d78:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406d7c:	91142421 	add	x1, x1, #0x509
  406d80:	910a5800 	add	x0, x0, #0x296
  406d84:	9400032a 	bl	407a2c <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
  406d88:	aa1303e1 	mov	x1, x19
  406d8c:	d2800002 	mov	x2, #0x0                   	// #0
  406d90:	52800040 	mov	w0, #0x2                   	// #2
  406d94:	97ffe9cb 	bl	4014c0 <sigaction@plt>
	if (unlikely(test)) {
  406d98:	340000c0 	cbz	w0, 406db0 <hwm_set_sig_handler+0xa8>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  406d9c:	f0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  406da0:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406da4:	9114a021 	add	x1, x1, #0x528
  406da8:	910a5800 	add	x0, x0, #0x296
  406dac:	94000320 	bl	407a2c <posix_print_error_and_exit>
}
  406db0:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406db4:	f9478400 	ldr	x0, [x0, #3848]
  406db8:	f9405fe2 	ldr	x2, [sp, #184]
  406dbc:	f9400001 	ldr	x1, [x0]
  406dc0:	eb010042 	subs	x2, x2, x1
  406dc4:	d2800001 	mov	x1, #0x0                   	// #0
  406dc8:	54000040 	b.eq	406dd0 <hwm_set_sig_handler+0xc8>  // b.none
  406dcc:	97ffe9b9 	bl	4014b0 <__stack_chk_fail@plt>
  406dd0:	f9400bf3 	ldr	x19, [sp, #16]
  406dd4:	a8cc7bfd 	ldp	x29, x30, [sp], #192
  406dd8:	d65f03c0 	ret

0000000000406ddc <hwm_find_next_timer>:
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
  406ddc:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
  406de0:	d0000122 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
	next_timer_index = 0;
  406de4:	f0000121 	adrp	x1, 42d000 <__dso_handle>
	next_timer_time  = *Timer_list[0];
  406de8:	f9477000 	ldr	x0, [x0, #3808]
	next_timer_index = 0;
  406dec:	b90abc3f 	str	wzr, [x1, #2748]
		if (next_timer_time > *Timer_list[i]) {
  406df0:	f947a442 	ldr	x2, [x2, #3912]
	next_timer_time  = *Timer_list[0];
  406df4:	f9400003 	ldr	x3, [x0]
  406df8:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
		if (next_timer_time > *Timer_list[i]) {
  406dfc:	f9400042 	ldr	x2, [x2]
	next_timer_time  = *Timer_list[0];
  406e00:	f9054c03 	str	x3, [x0, #2712]
		if (next_timer_time > *Timer_list[i]) {
  406e04:	eb02007f 	cmp	x3, x2
  406e08:	54000089 	b.ls	406e18 <hwm_find_next_timer+0x3c>  // b.plast
			next_timer_index = i;
  406e0c:	52800023 	mov	w3, #0x1                   	// #1
			next_timer_time = *Timer_list[i];
  406e10:	f9054c02 	str	x2, [x0, #2712]
			next_timer_index = i;
  406e14:	b90abc23 	str	w3, [x1, #2748]
		if (next_timer_time > *Timer_list[i]) {
  406e18:	d0000122 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  406e1c:	f9454c03 	ldr	x3, [x0, #2712]
  406e20:	f947dc42 	ldr	x2, [x2, #4024]
  406e24:	f9400042 	ldr	x2, [x2]
  406e28:	eb03005f 	cmp	x2, x3
  406e2c:	54000082 	b.cs	406e3c <hwm_find_next_timer+0x60>  // b.hs, b.nlast
			next_timer_index = i;
  406e30:	52800043 	mov	w3, #0x2                   	// #2
			next_timer_time = *Timer_list[i];
  406e34:	f9054c02 	str	x2, [x0, #2712]
			next_timer_index = i;
  406e38:	b90abc23 	str	w3, [x1, #2748]
		}
	}
}
  406e3c:	d65f03c0 	ret

0000000000406e40 <hwm_one_event>:

/**
 * Execute the next scheduled HW event/timer
 */
void hwm_one_event(void)
{
  406e40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  406e44:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
{
  406e48:	910003fd 	mov	x29, sp
  406e4c:	a90153f3 	stp	x19, x20, [sp, #16]
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  406e50:	90000153 	adrp	x19, 42e000 <thingset_workq+0x8>
  406e54:	f0000134 	adrp	x20, 42d000 <__dso_handle>
  406e58:	f9454c01 	ldr	x1, [x0, #2712]
  406e5c:	f9455262 	ldr	x2, [x19, #2720]
  406e60:	eb02003f 	cmp	x1, x2
  406e64:	540003c3 	b.cc	406edc <hwm_one_event+0x9c>  // b.lo, b.ul, b.last
		simu_time = next_timer_time;
  406e68:	f9055261 	str	x1, [x19, #2720]
	if (signaled_end || (simu_time > end_of_time)) {
  406e6c:	b0000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  406e70:	b94d1001 	ldr	w1, [x0, #3344]
  406e74:	f9455260 	ldr	x0, [x19, #2720]
  406e78:	350000a1 	cbnz	w1, 406e8c <hwm_one_event+0x4c>
  406e7c:	f0000121 	adrp	x1, 42d000 <__dso_handle>
  406e80:	f9429421 	ldr	x1, [x1, #1320]
  406e84:	eb00003f 	cmp	x1, x0
  406e88:	54000162 	b.cs	406eb4 <hwm_one_event+0x74>  // b.hs, b.nlast
				((long double)simu_time)/1.0e6L);
  406e8c:	97ffecb5 	bl	402160 <__floatunditf>
		posix_print_trace("\nStopped at %.3Lfs\n",
  406e90:	d0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  406e94:	911d4000 	add	x0, x0, #0x750
  406e98:	3dc00001 	ldr	q1, [x0]
  406e9c:	97ffea59 	bl	401800 <__divtf3>
  406ea0:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406ea4:	9115ec00 	add	x0, x0, #0x57b
  406ea8:	94000347 	bl	407bc4 <posix_print_trace>
		posix_exit(0);
  406eac:	52800000 	mov	w0, #0x0                   	// #0
  406eb0:	94000289 	bl	4078d4 <posix_exit>
	hwm_sleep_until_next_timer();

	switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
  406eb4:	b94abe80 	ldr	w0, [x20, #2748]
  406eb8:	7100041f 	cmp	w0, #0x1
  406ebc:	540001a0 	b.eq	406ef0 <hwm_one_event+0xb0>  // b.none
  406ec0:	7100081f 	cmp	w0, #0x2
  406ec4:	540001a0 	b.eq	406ef8 <hwm_one_event+0xb8>  // b.none
  406ec8:	350001c0 	cbnz	w0, 406f00 <hwm_one_event+0xc0>
	case HWTIMER:
		hwtimer_timer_reached();
  406ecc:	940000b7 	bl	4071a8 <hwtimer_timer_reached>
		break;
		/* LCOV_EXCL_STOP */
	}

	hwm_find_next_timer();
}
  406ed0:	a94153f3 	ldp	x19, x20, [sp, #16]
  406ed4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  406ed8:	17ffffc1 	b	406ddc <hwm_find_next_timer>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
  406edc:	b94abe83 	ldr	w3, [x20, #2748]
  406ee0:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406ee4:	91151800 	add	x0, x0, #0x546
  406ee8:	94000305 	bl	407afc <posix_print_warning>
  406eec:	17ffffe0 	b	406e6c <hwm_one_event+0x2c>
		hw_irq_ctrl_timer_triggered();
  406ef0:	94000274 	bl	4078c0 <hw_irq_ctrl_timer_triggered>
		break;
  406ef4:	17fffff7 	b	406ed0 <hwm_one_event+0x90>
		hw_counter_triggered();
  406ef8:	94000615 	bl	40874c <hw_counter_triggered>
		break;
  406efc:	17fffff5 	b	406ed0 <hwm_one_event+0x90>
		posix_print_error_and_exit(
  406f00:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406f04:	91163c00 	add	x0, x0, #0x58f
  406f08:	940002c9 	bl	407a2c <posix_print_error_and_exit>
		break;
  406f0c:	17fffff1 	b	406ed0 <hwm_one_event+0x90>

0000000000406f10 <hwm_set_end_of_time>:
/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
	end_of_time = new_end_of_time;
  406f10:	f0000121 	adrp	x1, 42d000 <__dso_handle>
  406f14:	f9029420 	str	x0, [x1, #1320]
}
  406f18:	d65f03c0 	ret

0000000000406f1c <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
  406f1c:	90000140 	adrp	x0, 42e000 <thingset_workq+0x8>
  406f20:	f9455000 	ldr	x0, [x0, #2720]
  406f24:	d65f03c0 	ret

0000000000406f28 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
  406f28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406f2c:	910003fd 	mov	x29, sp
	hwm_set_sig_handler();
  406f30:	97ffff76 	bl	406d08 <hwm_set_sig_handler>
	hwtimer_init();
  406f34:	94000055 	bl	407088 <hwtimer_init>
	hw_counter_init();
  406f38:	940005f8 	bl	408718 <hw_counter_init>
	hw_irq_ctrl_init();
  406f3c:	940001da 	bl	4076a4 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
  406f40:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hwm_find_next_timer();
  406f44:	17ffffa6 	b	406ddc <hwm_find_next_timer>

0000000000406f48 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
  406f48:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  406f4c:	910003fd 	mov	x29, sp
	hwtimer_cleanup();
  406f50:	94000086 	bl	407168 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
  406f54:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hw_irq_ctrl_cleanup();
  406f58:	140001e0 	b	4076d8 <hw_irq_ctrl_cleanup>

0000000000406f5c <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
  406f5c:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406f60:	f947c000 	ldr	x0, [x0, #3968]
  406f64:	f9400001 	ldr	x1, [x0]
  406f68:	d0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  406f6c:	f9479800 	ldr	x0, [x0, #3888]
  406f70:	f9400000 	ldr	x0, [x0]
  406f74:	eb01001f 	cmp	x0, x1
  406f78:	9a819000 	csel	x0, x0, x1, ls  // ls = plast
  406f7c:	d0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  406f80:	f9477021 	ldr	x1, [x1, #3808]
  406f84:	f9000020 	str	x0, [x1]
}
  406f88:	d65f03c0 	ret

0000000000406f8c <native_add_time_options>:
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
  406f8c:	f0000120 	adrp	x0, 42d000 <__dso_handle>
  406f90:	9114e000 	add	x0, x0, #0x538
  406f94:	14000573 	b	408560 <native_add_command_line_opts>

0000000000406f98 <cmd_stop_at_found>:
{
  406f98:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  406f9c:	910003fd 	mov	x29, sp
  406fa0:	f9000bf3 	str	x19, [sp, #16]
	if (args.stop_at < 0) {
  406fa4:	90000153 	adrp	x19, 42e000 <thingset_workq+0x8>
  406fa8:	fd455660 	ldr	d0, [x19, #2728]
  406fac:	1e602018 	fcmpe	d0, #0.0
  406fb0:	54000144 	b.mi	406fd8 <cmd_stop_at_found+0x40>  // b.first
	hwm_set_end_of_time(args.stop_at*1e6);
  406fb4:	fd455660 	ldr	d0, [x19, #2728]
  406fb8:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  406fbc:	f2e825c0 	movk	x0, #0x412e, lsl #48
  406fc0:	9e670001 	fmov	d1, x0
}
  406fc4:	f9400bf3 	ldr	x19, [sp, #16]
	hwm_set_end_of_time(args.stop_at*1e6);
  406fc8:	1e610800 	fmul	d0, d0, d1
}
  406fcc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_set_end_of_time(args.stop_at*1e6);
  406fd0:	9e790000 	fcvtzu	x0, d0
  406fd4:	17ffffcf 	b	406f10 <hwm_set_end_of_time>
  406fd8:	aa0003e1 	mov	x1, x0
		posix_print_error_and_exit("Error: stop-at must be positive "
  406fdc:	f0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  406fe0:	9116ac00 	add	x0, x0, #0x5ab
  406fe4:	94000292 	bl	407a2c <posix_print_error_and_exit>
  406fe8:	17fffff3 	b	406fb4 <cmd_stop_at_found+0x1c>

0000000000406fec <hwtimer_set_real_time_mode>:
	real_time_mode = new_rt;
  406fec:	b0000141 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  406ff0:	393da420 	strb	w0, [x1, #3945]
}
  406ff4:	d65f03c0 	ret

0000000000406ff8 <cmd_no_realtime_found>:
	hwtimer_set_real_time_mode(false);
  406ff8:	52800000 	mov	w0, #0x0                   	// #0
  406ffc:	17fffffc 	b	406fec <hwtimer_set_real_time_mode>

0000000000407000 <cmd_realtime_found>:
	hwtimer_set_real_time_mode(true);
  407000:	52800020 	mov	w0, #0x1                   	// #1
  407004:	17fffffa 	b	406fec <hwtimer_set_real_time_mode>

0000000000407008 <get_host_us_time>:
{
  407008:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40700c:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  407010:	910003fd 	mov	x29, sp
  407014:	f9478400 	ldr	x0, [x0, #3848]
  407018:	f9400001 	ldr	x1, [x0]
  40701c:	f90017e1 	str	x1, [sp, #40]
  407020:	d2800001 	mov	x1, #0x0                   	// #0
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
  407024:	52800080 	mov	w0, #0x4                   	// #4
  407028:	910063e1 	add	x1, sp, #0x18
  40702c:	97ffe8d5 	bl	401380 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  407030:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  407034:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  407038:	f2e825c0 	movk	x0, #0x412e, lsl #48
  40703c:	9e670001 	fmov	d1, x0
  407040:	fd400fe0 	ldr	d0, [sp, #24]
  407044:	f94013e0 	ldr	x0, [sp, #32]
  407048:	7e61d800 	ucvtf	d0, d0
  40704c:	9ac10c00 	sdiv	x0, x0, x1
}
  407050:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  407054:	1e610800 	fmul	d0, d0, d1
}
  407058:	f9478421 	ldr	x1, [x1, #3848]
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  40705c:	9e620001 	scvtf	d1, x0
}
  407060:	f94017e3 	ldr	x3, [sp, #40]
  407064:	f9400022 	ldr	x2, [x1]
  407068:	eb020063 	subs	x3, x3, x2
  40706c:	d2800002 	mov	x2, #0x0                   	// #0
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  407070:	1e612800 	fadd	d0, d0, d1
}
  407074:	54000040 	b.eq	40707c <get_host_us_time+0x74>  // b.none
  407078:	97ffe90e 	bl	4014b0 <__stack_chk_fail@plt>
  40707c:	9e790000 	fcvtzu	x0, d0
  407080:	a8c37bfd 	ldp	x29, x30, [sp], #48
  407084:	d65f03c0 	ret

0000000000407088 <hwtimer_init>:
{
  407088:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40708c:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  407090:	910003fd 	mov	x29, sp
  407094:	f9478400 	ldr	x0, [x0, #3848]
  407098:	f9400001 	ldr	x1, [x0]
  40709c:	f90017e1 	str	x1, [sp, #40]
  4070a0:	d2800001 	mov	x1, #0x0                   	// #0
	silent_ticks = 0;
  4070a4:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
	hw_timer_tick_timer = NEVER;
  4070a8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	silent_ticks = 0;
  4070ac:	f9057c1f 	str	xzr, [x0, #2808]
	hw_timer_tick_timer = NEVER;
  4070b0:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4070b4:	f947c000 	ldr	x0, [x0, #3968]
  4070b8:	f9000001 	str	x1, [x0]
	hw_timer_awake_timer = NEVER;
  4070bc:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4070c0:	f9479800 	ldr	x0, [x0, #3888]
  4070c4:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  4070c8:	97ffffa5 	bl	406f5c <hwtimer_update_timer>
	if (real_time_mode) {
  4070cc:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4070d0:	397da400 	ldrb	w0, [x0, #3945]
  4070d4:	340000c0 	cbz	w0, 4070ec <hwtimer_init+0x64>
		boot_time = get_host_us_time();
  4070d8:	97ffffcc 	bl	407008 <get_host_us_time>
		last_radj_rtime = boot_time;
  4070dc:	f0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  4070e0:	f9057020 	str	x0, [x1, #2784]
		last_radj_stime = 0U;
  4070e4:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  4070e8:	f905741f 	str	xzr, [x0, #2792]
	if (!reset_rtc) {
  4070ec:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4070f0:	397da800 	ldrb	w0, [x0, #3946]
  4070f4:	35000260 	cbnz	w0, 407140 <hwtimer_init+0xb8>
		clock_gettime(CLOCK_REALTIME, &tv);
  4070f8:	910063e1 	add	x1, sp, #0x18
  4070fc:	97ffe8a1 	bl	401380 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  407100:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  407104:	d2807d02 	mov	x2, #0x3e8                 	// #1000
  407108:	f2e825c0 	movk	x0, #0x412e, lsl #48
  40710c:	9e670001 	fmov	d1, x0
  407110:	fd400fe0 	ldr	d0, [sp, #24]
		rtc_offset += realhosttime;
  407114:	f0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  407118:	f94013e0 	ldr	x0, [sp, #32]
  40711c:	7e61d800 	ucvtf	d0, d0
  407120:	9ac20c00 	sdiv	x0, x0, x2
		rtc_offset += realhosttime;
  407124:	f9457822 	ldr	x2, [x1, #2800]
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  407128:	1e610800 	fmul	d0, d0, d1
  40712c:	9e620001 	scvtf	d1, x0
  407130:	1e612800 	fadd	d0, d0, d1
  407134:	9e790000 	fcvtzu	x0, d0
		rtc_offset += realhosttime;
  407138:	8b020000 	add	x0, x0, x2
  40713c:	f9057820 	str	x0, [x1, #2800]
}
  407140:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  407144:	f9478400 	ldr	x0, [x0, #3848]
  407148:	f94017e2 	ldr	x2, [sp, #40]
  40714c:	f9400001 	ldr	x1, [x0]
  407150:	eb010042 	subs	x2, x2, x1
  407154:	d2800001 	mov	x1, #0x0                   	// #0
  407158:	54000040 	b.eq	407160 <hwtimer_init+0xd8>  // b.none
  40715c:	97ffe8d5 	bl	4014b0 <__stack_chk_fail@plt>
  407160:	a8c37bfd 	ldp	x29, x30, [sp], #48
  407164:	d65f03c0 	ret

0000000000407168 <hwtimer_cleanup>:
}
  407168:	d65f03c0 	ret

000000000040716c <hwtimer_enable>:
{
  40716c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  407170:	910003fd 	mov	x29, sp
  407174:	f9000bf3 	str	x19, [sp, #16]
	tick_p = period;
  407178:	f0000133 	adrp	x19, 42e000 <thingset_workq+0x8>
  40717c:	f9058260 	str	x0, [x19, #2816]
	hw_timer_tick_timer = hwm_get_time() + tick_p;
  407180:	97ffff67 	bl	406f1c <hwm_get_time>
  407184:	f9458261 	ldr	x1, [x19, #2816]
  407188:	8b000020 	add	x0, x1, x0
  40718c:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  407190:	f947c021 	ldr	x1, [x1, #3968]
  407194:	f9000020 	str	x0, [x1]
	hwtimer_update_timer();
  407198:	97ffff71 	bl	406f5c <hwtimer_update_timer>
}
  40719c:	f9400bf3 	ldr	x19, [sp, #16]
  4071a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  4071a4:	17ffff0e 	b	406ddc <hwm_find_next_timer>

00000000004071a8 <hwtimer_timer_reached>:
{
  4071a8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  4071ac:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4071b0:	910003fd 	mov	x29, sp
  4071b4:	f9478400 	ldr	x0, [x0, #3848]
  4071b8:	a90153f3 	stp	x19, x20, [sp, #16]
  4071bc:	f90013f5 	str	x21, [sp, #32]
  4071c0:	f9400001 	ldr	x1, [x0]
  4071c4:	f9002fe1 	str	x1, [sp, #88]
  4071c8:	d2800001 	mov	x1, #0x0                   	// #0
	uint64_t Now = hw_timer_timer;
  4071cc:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4071d0:	f9477000 	ldr	x0, [x0, #3808]
  4071d4:	f9400013 	ldr	x19, [x0]
	if (hw_timer_awake_timer == Now) {
  4071d8:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4071dc:	f9479800 	ldr	x0, [x0, #3888]
  4071e0:	f9400001 	ldr	x1, [x0]
  4071e4:	eb13003f 	cmp	x1, x19
  4071e8:	540000c1 	b.ne	407200 <hwtimer_timer_reached+0x58>  // b.any
	hw_timer_awake_timer = NEVER;
  4071ec:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  4071f0:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  4071f4:	97ffff5a 	bl	406f5c <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
  4071f8:	529fffe0 	mov	w0, #0xffff                	// #65535
  4071fc:	9400018a 	bl	407824 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
  407200:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  407204:	b0000134 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  407208:	aa0003f5 	mov	x21, x0
  40720c:	f947c001 	ldr	x1, [x0, #3968]
  407210:	f9400021 	ldr	x1, [x1]
  407214:	eb13003f 	cmp	x1, x19
  407218:	54000661 	b.ne	4072e4 <hwtimer_timer_reached+0x13c>  // b.any
	if (real_time_mode) {
  40721c:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  407220:	397da400 	ldrb	w0, [x0, #3945]
  407224:	34000460 	cbz	w0, 4072b0 <hwtimer_timer_reached+0x108>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  407228:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  40722c:	f9457400 	ldr	x0, [x0, #2792]
  407230:	cb000273 	sub	x19, x19, x0
				    / clock_ratio
  407234:	d0000120 	adrp	x0, 42d000 <__dso_handle>
  407238:	9e630260 	ucvtf	d0, x19
  40723c:	fd429801 	ldr	d1, [x0, #1328]
				    + last_radj_rtime;
  407240:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
				    / clock_ratio
  407244:	1e611800 	fdiv	d0, d0, d1
				    + last_radj_rtime;
  407248:	fd457001 	ldr	d1, [x0, #2784]
  40724c:	7e61d821 	ucvtf	d1, d1
  407250:	1e612800 	fadd	d0, d0, d1
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  407254:	9e790013 	fcvtzu	x19, d0
		uint64_t real_time = get_host_us_time();
  407258:	97ffff6c 	bl	407008 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
  40725c:	cb000260 	sub	x0, x19, x0
		if (diff > 0) { /* we need to slow down */
  407260:	f100001f 	cmp	x0, #0x0
  407264:	5400026d 	b.le	4072b0 <hwtimer_timer_reached+0x108>
			requested_time.tv_sec  = diff / 1e6;
  407268:	9e620000 	scvtf	d0, x0
  40726c:	b0000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
			(void) nanosleep(&requested_time, &remaining);
  407270:	910123e1 	add	x1, sp, #0x48
			requested_time.tv_sec  = diff / 1e6;
  407274:	fd43b002 	ldr	d2, [x0, #1888]
						 requested_time.tv_sec*1e6)*1e3;
  407278:	d2c80000 	mov	x0, #0x400000000000        	// #70368744177664
  40727c:	f2e811e0 	movk	x0, #0x408f, lsl #48
			requested_time.tv_sec  = diff / 1e6;
  407280:	1e621801 	fdiv	d1, d0, d2
  407284:	5ee1b821 	fcvtzs	d1, d1
  407288:	fd001fe1 	str	d1, [sp, #56]
						 requested_time.tv_sec*1e6)*1e3;
  40728c:	5e61d821 	scvtf	d1, d1
  407290:	1e620821 	fmul	d1, d1, d2
			requested_time.tv_nsec = (diff -
  407294:	1e613800 	fsub	d0, d0, d1
						 requested_time.tv_sec*1e6)*1e3;
  407298:	9e670001 	fmov	d1, x0
			(void) nanosleep(&requested_time, &remaining);
  40729c:	9100e3e0 	add	x0, sp, #0x38
						 requested_time.tv_sec*1e6)*1e3;
  4072a0:	1e610800 	fmul	d0, d0, d1
			requested_time.tv_nsec = (diff -
  4072a4:	5ee1b800 	fcvtzs	d0, d0
  4072a8:	fd0023e0 	str	d0, [sp, #64]
			(void) nanosleep(&requested_time, &remaining);
  4072ac:	97ffe8b5 	bl	401580 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
  4072b0:	f947c2a0 	ldr	x0, [x21, #3968]
  4072b4:	f0000122 	adrp	x2, 42e000 <thingset_workq+0x8>
  4072b8:	f9458042 	ldr	x2, [x2, #2816]
  4072bc:	f9400001 	ldr	x1, [x0]
  4072c0:	8b020021 	add	x1, x1, x2
  4072c4:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  4072c8:	97ffff25 	bl	406f5c <hwtimer_update_timer>
	if (silent_ticks > 0) {
  4072cc:	f0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  4072d0:	f9457c20 	ldr	x0, [x1, #2808]
  4072d4:	f100001f 	cmp	x0, #0x0
  4072d8:	540001ad 	b.le	40730c <hwtimer_timer_reached+0x164>
		silent_ticks -= 1;
  4072dc:	d1000400 	sub	x0, x0, #0x1
  4072e0:	f9057c20 	str	x0, [x1, #2808]
}
  4072e4:	f9478680 	ldr	x0, [x20, #3848]
  4072e8:	f9402fe2 	ldr	x2, [sp, #88]
  4072ec:	f9400001 	ldr	x1, [x0]
  4072f0:	eb010042 	subs	x2, x2, x1
  4072f4:	d2800001 	mov	x1, #0x0                   	// #0
  4072f8:	54000161 	b.ne	407324 <hwtimer_timer_reached+0x17c>  // b.any
  4072fc:	a94153f3 	ldp	x19, x20, [sp, #16]
  407300:	f94013f5 	ldr	x21, [sp, #32]
  407304:	a8c67bfd 	ldp	x29, x30, [sp], #96
  407308:	d65f03c0 	ret
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  40730c:	f9478680 	ldr	x0, [x20, #3848]
  407310:	f9402fe2 	ldr	x2, [sp, #88]
  407314:	f9400001 	ldr	x1, [x0]
  407318:	eb010042 	subs	x2, x2, x1
  40731c:	d2800001 	mov	x1, #0x0                   	// #0
  407320:	54000040 	b.eq	407328 <hwtimer_timer_reached+0x180>  // b.none
}
  407324:	97ffe863 	bl	4014b0 <__stack_chk_fail@plt>
  407328:	a94153f3 	ldp	x19, x20, [sp, #16]
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  40732c:	52800000 	mov	w0, #0x0                   	// #0
}
  407330:	f94013f5 	ldr	x21, [sp, #32]
  407334:	a8c67bfd 	ldp	x29, x30, [sp], #96
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  407338:	1400013b 	b	407824 <hw_irq_ctrl_set_irq>

000000000040733c <hwtimer_set_silent_ticks>:
	silent_ticks = sys_ticks;
  40733c:	f0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  407340:	f9057c20 	str	x0, [x1, #2808]
}
  407344:	d65f03c0 	ret

0000000000407348 <hwtimer_reset_rtc>:
	reset_rtc = true;
  407348:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  40734c:	52800021 	mov	w1, #0x1                   	// #1
  407350:	393da801 	strb	w1, [x0, #3946]
}
  407354:	d65f03c0 	ret

0000000000407358 <cmd_rtcreset_found>:
	hwtimer_reset_rtc();
  407358:	17fffffc 	b	407348 <hwtimer_reset_rtc>

000000000040735c <hwtimer_set_rtc_offset>:
	rtc_offset = offset;
  40735c:	f0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  407360:	f9057820 	str	x0, [x1, #2800]
}
  407364:	d65f03c0 	ret

0000000000407368 <cmd_rtcoffset_found>:
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
  407368:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  40736c:	fd455800 	ldr	d0, [x0, #2736]
  407370:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  407374:	f2e825c0 	movk	x0, #0x412e, lsl #48
  407378:	9e670001 	fmov	d1, x0
  40737c:	1e610800 	fmul	d0, d0, d1
  407380:	9e780000 	fcvtzs	x0, d0
  407384:	17fffff6 	b	40735c <hwtimer_set_rtc_offset>

0000000000407388 <hwtimer_set_rt_ratio>:
	clock_ratio = ratio;
  407388:	d0000120 	adrp	x0, 42d000 <__dso_handle>
  40738c:	fd029800 	str	d0, [x0, #1328]
}
  407390:	d65f03c0 	ret

0000000000407394 <cmd_rt_ratio_found>:
{
  407394:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  407398:	910003fd 	mov	x29, sp
  40739c:	f9000bf3 	str	x19, [sp, #16]
	if ((args.rt_ratio <= 0)) {
  4073a0:	f0000133 	adrp	x19, 42e000 <thingset_workq+0x8>
  4073a4:	912aa260 	add	x0, x19, #0xaa8
  4073a8:	fd400c00 	ldr	d0, [x0, #24]
  4073ac:	1e602018 	fcmpe	d0, #0.0
  4073b0:	540000c9 	b.ls	4073c8 <cmd_rt_ratio_found+0x34>  // b.plast
	hwtimer_set_rt_ratio(args.rt_ratio);
  4073b4:	912aa273 	add	x19, x19, #0xaa8
  4073b8:	fd400e60 	ldr	d0, [x19, #24]
}
  4073bc:	f9400bf3 	ldr	x19, [sp, #16]
  4073c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  4073c4:	17fffff1 	b	407388 <hwtimer_set_rt_ratio>
		posix_print_error_and_exit("The ratio needs to be > 0. "
  4073c8:	d0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  4073cc:	91174400 	add	x0, x0, #0x5d1
  4073d0:	94000197 	bl	407a2c <posix_print_error_and_exit>
  4073d4:	17fffff8 	b	4073b4 <cmd_rt_ratio_found+0x20>

00000000004073d8 <cmd_rt_drift_found>:
{
  4073d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!(args.rt_drift > -1)) {
  4073dc:	1e7e1000 	fmov	d0, #-1.000000000000000000e+00
{
  4073e0:	910003fd 	mov	x29, sp
  4073e4:	f9000bf3 	str	x19, [sp, #16]
	if (!(args.rt_drift > -1)) {
  4073e8:	f0000133 	adrp	x19, 42e000 <thingset_workq+0x8>
  4073ec:	912aa260 	add	x0, x19, #0xaa8
  4073f0:	fd400801 	ldr	d1, [x0, #16]
  4073f4:	1e602030 	fcmpe	d1, d0
  4073f8:	5400008c 	b.gt	407408 <cmd_rt_drift_found+0x30>
		posix_print_error_and_exit("The drift needs to be > -1. "
  4073fc:	d0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  407400:	91183400 	add	x0, x0, #0x60d
  407404:	9400018a 	bl	407a2c <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
  407408:	912aa273 	add	x19, x19, #0xaa8
  40740c:	1e6e1001 	fmov	d1, #1.000000000000000000e+00
  407410:	fd400a60 	ldr	d0, [x19, #16]
  407414:	1e612800 	fadd	d0, d0, d1
  407418:	fd000e60 	str	d0, [x19, #24]
}
  40741c:	f9400bf3 	ldr	x19, [sp, #16]
  407420:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  407424:	17ffffd9 	b	407388 <hwtimer_set_rt_ratio>

0000000000407428 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
  407428:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40742c:	910003fd 	mov	x29, sp
  407430:	a90153f3 	stp	x19, x20, [sp, #16]
  407434:	a9025bf5 	stp	x21, x22, [sp, #32]
  407438:	a90363f7 	stp	x23, x24, [sp, #48]
  40743c:	f90023f9 	str	x25, [sp, #64]
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
  407440:	940000b5 	bl	407714 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
  407444:	350009c0 	cbnz	w0, 40757c <posix_irq_handler+0x154>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
  407448:	b0000133 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  40744c:	aa1303f4 	mov	x20, x19
  407450:	f9474260 	ldr	x0, [x19, #3712]
  407454:	b9400000 	ldr	w0, [x0]
  407458:	35000060 	cbnz	w0, 407464 <posix_irq_handler+0x3c>
		may_swap = 0;
  40745c:	90000141 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  407460:	b90d143f 	str	wzr, [x1, #3348]
	}

	_kernel.cpus[0].nested++;
  407464:	f9474281 	ldr	x1, [x20, #3712]

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
		int last_running_irq = currently_running_irq;
  407468:	d0000135 	adrp	x21, 42d000 <__dso_handle>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  40746c:	f0000136 	adrp	x22, 42e000 <thingset_workq+0x8>
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
		hw_irq_ctrl_clear_irq(irq_nbr);

		currently_running_irq = irq_nbr;
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;
  407470:	912b02b8 	add	x24, x21, #0xac0
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  407474:	912c22d6 	add	x22, x22, #0xb08
	_kernel.cpus[0].nested++;
  407478:	11000400 	add	w0, w0, #0x1
  40747c:	b9000020 	str	w0, [x1]
	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
  407480:	940000bd 	bl	407774 <hw_irq_ctrl_get_highest_prio_irq>
  407484:	2a0003f3 	mov	w19, w0
  407488:	3100041f 	cmn	w0, #0x1
  40748c:	540002c1 	b.ne	4074e4 <posix_irq_handler+0xbc>  // b.any

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
	}

	_kernel.cpus[0].nested--;
  407490:	f9474294 	ldr	x20, [x20, #3712]
  407494:	b9400280 	ldr	w0, [x20]
  407498:	51000400 	sub	w0, w0, #0x1
  40749c:	b9000280 	str	w0, [x20]
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
  4074a0:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4074a4:	b94d1400 	ldr	w0, [x0, #3348]
  4074a8:	340006a0 	cbz	w0, 40757c <posix_irq_handler+0x154>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
  4074ac:	9400008f 	bl	4076e8 <hw_irq_ctrl_get_cur_prio>
  4074b0:	7104001f 	cmp	w0, #0x100
  4074b4:	54000641 	b.ne	40757c <posix_irq_handler+0x154>  // b.any
		&& (_kernel.ready_q.cache != _current)) {
  4074b8:	f9400a80 	ldr	x0, [x20, #16]
  4074bc:	f9401681 	ldr	x1, [x20, #40]
  4074c0:	eb00003f 	cmp	x1, x0
  4074c4:	540005c0 	b.eq	40757c <posix_irq_handler+0x154>  // b.none

		(void)z_swap_irqlock(irq_lock);
	}
}
  4074c8:	a94153f3 	ldp	x19, x20, [sp, #16]

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
  4074cc:	52800000 	mov	w0, #0x0                   	// #0
  4074d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4074d4:	a94363f7 	ldp	x23, x24, [sp, #48]
  4074d8:	f94023f9 	ldr	x25, [sp, #64]
  4074dc:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4074e0:	17fffd13 	b	40692c <arch_swap>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  4074e4:	94000081 	bl	4076e8 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;
  4074e8:	b94ac2b9 	ldr	w25, [x21, #2752]
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  4074ec:	2a0003f7 	mov	w23, w0
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
  4074f0:	2a1303e0 	mov	w0, w19
  4074f4:	94000084 	bl	407704 <hw_irq_ctrl_get_prio>
  4074f8:	12001c00 	and	w0, w0, #0xff
  4074fc:	94000078 	bl	4076dc <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
  407500:	2a1303e0 	mov	w0, w19
  407504:	940000bd 	bl	4077f8 <hw_irq_ctrl_clear_irq>
		currently_running_irq = irq_nbr;
  407508:	b90ac2b3 	str	w19, [x21, #2752]
	sys_trace_isr_enter();
  40750c:	97fffb9c 	bl	40637c <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  407510:	93407e61 	sxtw	x1, w19
  407514:	d2800300 	mov	x0, #0x18                  	// #24
  407518:	9b005821 	madd	x1, x1, x0, x22
  40751c:	f9400422 	ldr	x2, [x1, #8]
  407520:	b5000142 	cbnz	x2, 407548 <posix_irq_handler+0x120>
		posix_print_error_and_exit("Received irq %i without a "
  407524:	d0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  407528:	2a1303e1 	mov	w1, w19
  40752c:	91288c00 	add	x0, x0, #0xa23
  407530:	9400013f 	bl	407a2c <posix_print_error_and_exit>
	sys_trace_isr_exit();
  407534:	97fffb93 	bl	406380 <sys_trace_isr_exit>
		currently_running_irq = last_running_irq;
  407538:	b9000319 	str	w25, [x24]
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
  40753c:	2a1703e0 	mov	w0, w23
  407540:	94000067 	bl	4076dc <hw_irq_ctrl_set_cur_prio>
  407544:	17ffffcf 	b	407480 <posix_irq_handler+0x58>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
  407548:	b9400420 	ldr	w0, [x1, #4]
  40754c:	90000153 	adrp	x19, 42f000 <can_loopback_dev_data_0+0xc0>
  407550:	360000c0 	tbz	w0, #0, 407568 <posix_irq_handler+0x140>
			*may_swap |= ((direct_irq_f_ptr)
  407554:	d63f0040 	blr	x2
  407558:	b94d1661 	ldr	w1, [x19, #3348]
  40755c:	2a000021 	orr	w1, w1, w0
  407560:	b90d1661 	str	w1, [x19, #3348]
  407564:	17fffff4 	b	407534 <posix_irq_handler+0x10c>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
  407568:	f9400820 	ldr	x0, [x1, #16]
  40756c:	d63f0040 	blr	x2
			*may_swap = 1;
  407570:	52800020 	mov	w0, #0x1                   	// #1
  407574:	b90d1660 	str	w0, [x19, #3348]
  407578:	17ffffef 	b	407534 <posix_irq_handler+0x10c>
}
  40757c:	a94153f3 	ldp	x19, x20, [sp, #16]
  407580:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407584:	a94363f7 	ldp	x23, x24, [sp, #48]
  407588:	f94023f9 	ldr	x25, [sp, #64]
  40758c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  407590:	d65f03c0 	ret

0000000000407594 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
  407594:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  407598:	910003fd 	mov	x29, sp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
  40759c:	94000076 	bl	407774 <hw_irq_ctrl_get_highest_prio_irq>
  4075a0:	3100041f 	cmn	w0, #0x1
  4075a4:	54000140 	b.eq	4075cc <posix_irq_handler_im_from_sw+0x38>  // b.none
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
  4075a8:	97fffd1f 	bl	406a24 <posix_is_cpu_running>
  4075ac:	350000c0 	cbnz	w0, 4075c4 <posix_irq_handler_im_from_sw+0x30>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
  4075b0:	d0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  4075b4:	d0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  4075b8:	912a1821 	add	x1, x1, #0xa86
  4075bc:	91294400 	add	x0, x0, #0xa51
  4075c0:	9400011b 	bl	407a2c <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
  4075c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler();
  4075c8:	17ffff98 	b	407428 <posix_irq_handler>
}
  4075cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4075d0:	d65f03c0 	ret

00000000004075d4 <posix_irq_lock>:
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
	return hw_irq_ctrl_change_lock(true);
  4075d4:	52800020 	mov	w0, #0x1                   	// #1
  4075d8:	14000052 	b	407720 <hw_irq_ctrl_change_lock>

00000000004075dc <posix_irq_unlock>:
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
  4075dc:	14000051 	b	407720 <hw_irq_ctrl_change_lock>

00000000004075e0 <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
	hw_irq_ctrl_change_lock(false);
  4075e0:	52800000 	mov	w0, #0x0                   	// #0
  4075e4:	1400004f 	b	407720 <hw_irq_ctrl_change_lock>

00000000004075e8 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
  4075e8:	140000aa 	b	407890 <hw_irq_ctrl_enable_irq>

00000000004075ec <posix_isr_declare>:
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
	irq_vector_table[irq_p].irq   = irq_p;
  4075ec:	2a0003e4 	mov	w4, w0
  4075f0:	d2800306 	mov	x6, #0x18                  	// #24
  4075f4:	f0000125 	adrp	x5, 42e000 <thingset_workq+0x8>
  4075f8:	912c20a5 	add	x5, x5, #0xb08
  4075fc:	9b067c84 	mul	x4, x4, x6
  407600:	8b0400a6 	add	x6, x5, x4
  407604:	b82468a0 	str	w0, [x5, x4]
	irq_vector_table[irq_p].func  = isr_p;
	irq_vector_table[irq_p].param = isr_param_p;
	irq_vector_table[irq_p].flags = flags;
  407608:	b90004c1 	str	w1, [x6, #4]
	irq_vector_table[irq_p].param = isr_param_p;
  40760c:	a9008cc2 	stp	x2, x3, [x6, #8]
}
  407610:	d65f03c0 	ret

0000000000407614 <posix_irq_priority_set>:
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
  407614:	14000038 	b	4076f4 <hw_irq_ctrl_prio_set>

0000000000407618 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
  407618:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  40761c:	397e2c01 	ldrb	w1, [x0, #3979]
  407620:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  407624:	34000061 	cbz	w1, 407630 <irq_raising_from_hw_now+0x18>
  407628:	397e3001 	ldrb	w1, [x0, #3980]
  40762c:	34000061 	cbz	w1, 407638 <irq_raising_from_hw_now+0x20>
		lock_ignore = false;
  407630:	393e301f 	strb	wzr, [x0, #3980]
		posix_interrupt_raised();
  407634:	17fffd27 	b	406ad0 <posix_interrupt_raised>
	}
}
  407638:	d65f03c0 	ret

000000000040763c <hw_irq_ctrl_irq_raise_prefix>:
	if (irq < N_IRQS) {
  40763c:	71007c1f 	cmp	w0, #0x1f
  407640:	54000248 	b.hi	407688 <hw_irq_ctrl_irq_raise_prefix+0x4c>  // b.pmore
		irq_premask |= ((uint64_t)1<<irq);
  407644:	d2800021 	mov	x1, #0x1                   	// #1
  407648:	f0000124 	adrp	x4, 42e000 <thingset_workq+0x8>
  40764c:	9ac02023 	lsl	x3, x1, x0
		if (irq_mask & (1 << irq)) {
  407650:	1ac02021 	lsl	w1, w1, w0
  407654:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
		irq_premask |= ((uint64_t)1<<irq);
  407658:	f9470882 	ldr	x2, [x4, #3600]
		if (irq_mask & (1 << irq)) {
  40765c:	93407c21 	sxtw	x1, w1
  407660:	f9470400 	ldr	x0, [x0, #3592]
		irq_premask |= ((uint64_t)1<<irq);
  407664:	aa030042 	orr	x2, x2, x3
  407668:	f9070882 	str	x2, [x4, #3600]
		if (irq_mask & (1 << irq)) {
  40766c:	ea00003f 	tst	x1, x0
  407670:	540000a0 	b.eq	407684 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.none
			irq_status |= ((uint64_t)1<<irq);
  407674:	f0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  407678:	f9470c20 	ldr	x0, [x1, #3608]
  40767c:	aa030000 	orr	x0, x0, x3
  407680:	f9070c20 	str	x0, [x1, #3608]
}
  407684:	d65f03c0 	ret
	} else if (irq == PHONY_HARD_IRQ) {
  407688:	529fffe1 	mov	w1, #0xffff                	// #65535
  40768c:	6b01001f 	cmp	w0, w1
  407690:	54ffffa1 	b.ne	407684 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.any
		lock_ignore = true;
  407694:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  407698:	52800021 	mov	w1, #0x1                   	// #1
  40769c:	393e3001 	strb	w1, [x0, #3980]
}
  4076a0:	17fffff9 	b	407684 <hw_irq_ctrl_irq_raise_prefix+0x48>

00000000004076a4 <hw_irq_ctrl_init>:
		irq_prio[i] = 255U;
  4076a4:	6f000400 	mvni	v0.4s, #0x0
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
  4076a8:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  4076ac:	f907041f 	str	xzr, [x0, #3592]
	irq_premask = 0U;
  4076b0:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  4076b4:	f907081f 	str	xzr, [x0, #3600]
	irqs_locked = false;
  4076b8:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4076bc:	393e2c1f 	strb	wzr, [x0, #3979]
	lock_ignore = false;
  4076c0:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4076c4:	393e301f 	strb	wzr, [x0, #3980]
		irq_prio[i] = 255U;
  4076c8:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4076cc:	913dac00 	add	x0, x0, #0xf6b
  4076d0:	ad000000 	stp	q0, q0, [x0]
}
  4076d4:	d65f03c0 	ret

00000000004076d8 <hw_irq_ctrl_cleanup>:
}
  4076d8:	d65f03c0 	ret

00000000004076dc <hw_irq_ctrl_set_cur_prio>:
	currently_running_prio = new;
  4076dc:	d0000121 	adrp	x1, 42d000 <__dso_handle>
  4076e0:	b90ac420 	str	w0, [x1, #2756]
}
  4076e4:	d65f03c0 	ret

00000000004076e8 <hw_irq_ctrl_get_cur_prio>:
}
  4076e8:	d0000120 	adrp	x0, 42d000 <__dso_handle>
  4076ec:	b94ac400 	ldr	w0, [x0, #2756]
  4076f0:	d65f03c0 	ret

00000000004076f4 <hw_irq_ctrl_prio_set>:
	irq_prio[irq] = prio;
  4076f4:	90000142 	adrp	x2, 42f000 <can_loopback_dev_data_0+0xc0>
  4076f8:	913dac42 	add	x2, x2, #0xf6b
  4076fc:	38204841 	strb	w1, [x2, w0, uxtw]
}
  407700:	d65f03c0 	ret

0000000000407704 <hw_irq_ctrl_get_prio>:
}
  407704:	90000141 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  407708:	913dac21 	add	x1, x1, #0xf6b
  40770c:	38604820 	ldrb	w0, [x1, w0, uxtw]
  407710:	d65f03c0 	ret

0000000000407714 <hw_irq_ctrl_get_current_lock>:
}
  407714:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  407718:	397e2c00 	ldrb	w0, [x0, #3979]
  40771c:	d65f03c0 	ret

0000000000407720 <hw_irq_ctrl_change_lock>:
{
  407720:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t previous_lock = irqs_locked;
  407724:	90000141 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
	irqs_locked = new_lock;
  407728:	7100001f 	cmp	w0, #0x0
{
  40772c:	910003fd 	mov	x29, sp
	irqs_locked = new_lock;
  407730:	1a9f07e0 	cset	w0, ne  // ne = any
{
  407734:	f9000bf3 	str	x19, [sp, #16]
	uint32_t previous_lock = irqs_locked;
  407738:	397e2c33 	ldrb	w19, [x1, #3979]
	irqs_locked = new_lock;
  40773c:	393e2c20 	strb	w0, [x1, #3979]
	if ((previous_lock == true) && (new_lock == false)) {
  407740:	7a400a64 	ccmp	w19, #0x0, #0x4, eq  // eq = none
  407744:	540000a0 	b.eq	407758 <hw_irq_ctrl_change_lock+0x38>  // b.none
		if (irq_status != 0U) {
  407748:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  40774c:	f9470c00 	ldr	x0, [x0, #3608]
  407750:	b4000040 	cbz	x0, 407758 <hw_irq_ctrl_change_lock+0x38>
			posix_irq_handler_im_from_sw();
  407754:	97ffff90 	bl	407594 <posix_irq_handler_im_from_sw>
}
  407758:	2a1303e0 	mov	w0, w19
  40775c:	f9400bf3 	ldr	x19, [sp, #16]
  407760:	a8c27bfd 	ldp	x29, x30, [sp], #32
  407764:	d65f03c0 	ret

0000000000407768 <hw_irq_ctrl_get_irq_status>:
}
  407768:	f0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  40776c:	f9470c00 	ldr	x0, [x0, #3608]
  407770:	d65f03c0 	ret

0000000000407774 <hw_irq_ctrl_get_highest_prio_irq>:
	if (irqs_locked) {
  407774:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  407778:	397e2c00 	ldrb	w0, [x0, #3979]
  40777c:	350003a0 	cbnz	w0, 4077f0 <hw_irq_ctrl_get_highest_prio_irq+0x7c>
{
  407780:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  407784:	910003fd 	mov	x29, sp
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
  407788:	97fffff8 	bl	407768 <hw_irq_ctrl_get_irq_status>
  40778c:	aa0003e2 	mov	x2, x0
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  407790:	d0000120 	adrp	x0, 42d000 <__dso_handle>
		if ((winner_prio > (int)irq_prio[irq_nbr])
  407794:	90000144 	adrp	x4, 42f000 <can_loopback_dev_data_0+0xc0>
  407798:	913dac84 	add	x4, x4, #0xf6b
	int winner_prio = 256;
  40779c:	52802003 	mov	w3, #0x100                 	// #256
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  4077a0:	b94ac406 	ldr	w6, [x0, #2756]
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  4077a4:	d2800027 	mov	x7, #0x1                   	// #1
	int winner = -1;
  4077a8:	12800000 	mov	w0, #0xffffffff            	// #-1
	while (irq_status != 0U) {
  4077ac:	b5000062 	cbnz	x2, 4077b8 <hw_irq_ctrl_get_highest_prio_irq+0x44>
}
  4077b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4077b4:	d65f03c0 	ret
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
  4077b8:	5ac00041 	rbit	w1, w2
  4077bc:	7100005f 	cmp	w2, #0x0
  4077c0:	5ac01021 	clz	w1, w1
  4077c4:	1a8107e1 	csinc	w1, wzr, w1, eq  // eq = none
		int irq_nbr = find_lsb_set(irq_status) - 1;
  4077c8:	51000421 	sub	w1, w1, #0x1
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  4077cc:	9ac120e5 	lsl	x5, x7, x1
  4077d0:	8a250042 	bic	x2, x2, x5
		if ((winner_prio > (int)irq_prio[irq_nbr])
  4077d4:	3861c885 	ldrb	w5, [x4, w1, sxtw]
  4077d8:	6b0300bf 	cmp	w5, w3
  4077dc:	54fffe8a 	b.ge	4077ac <hw_irq_ctrl_get_highest_prio_irq+0x38>  // b.tcont
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  4077e0:	6b0600bf 	cmp	w5, w6
  4077e4:	1a85a063 	csel	w3, w3, w5, ge  // ge = tcont
  4077e8:	1a81a000 	csel	w0, w0, w1, ge  // ge = tcont
  4077ec:	17fffff0 	b	4077ac <hw_irq_ctrl_get_highest_prio_irq+0x38>
		return -1;
  4077f0:	12800000 	mov	w0, #0xffffffff            	// #-1
}
  4077f4:	d65f03c0 	ret

00000000004077f8 <hw_irq_ctrl_clear_irq>:
	irq_status  &= ~((uint64_t)1<<irq);
  4077f8:	f0000122 	adrp	x2, 42e000 <thingset_workq+0x8>
  4077fc:	d2800021 	mov	x1, #0x1                   	// #1
  407800:	9ac02020 	lsl	x0, x1, x0
  407804:	f9470c41 	ldr	x1, [x2, #3608]
  407808:	8a200021 	bic	x1, x1, x0
  40780c:	f9070c41 	str	x1, [x2, #3608]
	irq_premask &= ~((uint64_t)1<<irq);
  407810:	f0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  407814:	f9470822 	ldr	x2, [x1, #3600]
  407818:	8a200040 	bic	x0, x2, x0
  40781c:	f9070820 	str	x0, [x1, #3600]
}
  407820:	d65f03c0 	ret

0000000000407824 <hw_irq_ctrl_set_irq>:
{
  407824:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  407828:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  40782c:	97ffff84 	bl	40763c <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
  407830:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  407834:	397e2c00 	ldrb	w0, [x0, #3979]
  407838:	34000080 	cbz	w0, 407848 <hw_irq_ctrl_set_irq+0x24>
  40783c:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  407840:	397e3000 	ldrb	w0, [x0, #3980]
  407844:	340000e0 	cbz	w0, 407860 <hw_irq_ctrl_set_irq+0x3c>
		irq_ctrl_timer = hwm_get_time();
  407848:	97fffdb5 	bl	406f1c <hwm_get_time>
  40784c:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  407850:	f947a421 	ldr	x1, [x1, #3912]
  407854:	f9000020 	str	x0, [x1]
}
  407858:	a8c17bfd 	ldp	x29, x30, [sp], #16
		hwm_find_next_timer();
  40785c:	17fffd60 	b	406ddc <hwm_find_next_timer>
}
  407860:	a8c17bfd 	ldp	x29, x30, [sp], #16
  407864:	d65f03c0 	ret

0000000000407868 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
  407868:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40786c:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  407870:	97ffff73 	bl	40763c <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
  407874:	90000140 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  407878:	397e2c00 	ldrb	w0, [x0, #3979]
  40787c:	35000060 	cbnz	w0, 407888 <hw_irq_ctrl_raise_im_from_sw+0x20>
		posix_irq_handler_im_from_sw();
	}
}
  407880:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler_im_from_sw();
  407884:	17ffff44 	b	407594 <posix_irq_handler_im_from_sw>
}
  407888:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40788c:	d65f03c0 	ret

0000000000407890 <hw_irq_ctrl_enable_irq>:
	irq_mask |= ((uint64_t)1<<irq);
  407890:	f0000123 	adrp	x3, 42e000 <thingset_workq+0x8>
  407894:	d2800021 	mov	x1, #0x1                   	// #1
  407898:	9ac02021 	lsl	x1, x1, x0
  40789c:	f9470464 	ldr	x4, [x3, #3592]
  4078a0:	aa040021 	orr	x1, x1, x4
  4078a4:	f9070461 	str	x1, [x3, #3592]
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
  4078a8:	f0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  4078ac:	f9470821 	ldr	x1, [x1, #3600]
  4078b0:	9ac02421 	lsr	x1, x1, x0
  4078b4:	36000041 	tbz	w1, #0, 4078bc <hw_irq_ctrl_enable_irq+0x2c>
		hw_irq_ctrl_raise_im_from_sw(irq);
  4078b8:	17ffffec 	b	407868 <hw_irq_ctrl_raise_im_from_sw>
}
  4078bc:	d65f03c0 	ret

00000000004078c0 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
  4078c0:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4078c4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  4078c8:	f947a400 	ldr	x0, [x0, #3912]
  4078cc:	f9000001 	str	x1, [x0]
	irq_raising_from_hw_now();
  4078d0:	17ffff52 	b	407618 <irq_raising_from_hw_now>

00000000004078d4 <posix_exit>:
#include <zephyr/sys/time_units.h>
#include "cmdline.h"
#include "irq_ctrl.h"

void posix_exit(int exit_code)
{
  4078d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4078d8:	910003fd 	mov	x29, sp
  4078dc:	f9000bf3 	str	x19, [sp, #16]
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
  4078e0:	90000153 	adrp	x19, 42f000 <can_loopback_dev_data_0+0xc0>
  4078e4:	b94d1a61 	ldr	w1, [x19, #3352]
  4078e8:	6b00003f 	cmp	w1, w0
  4078ec:	1a80a021 	csel	w1, w1, w0, ge  // ge = tcont
  4078f0:	b90d1a61 	str	w1, [x19, #3352]
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
  4078f4:	97fffcd5 	bl	406c48 <posix_soc_clean_up>
	hwm_cleanup();
  4078f8:	97fffd94 	bl	406f48 <hwm_cleanup>
	native_cleanup_cmd_line();
  4078fc:	9400030e 	bl	408534 <native_cleanup_cmd_line>
	exit(max_exit_code);
  407900:	b94d1a60 	ldr	w0, [x19, #3352]
  407904:	97ffe683 	bl	401310 <exit@plt>

0000000000407908 <posix_init>:
 * Run all early native_posix initialization steps, including command
 * line parsing and CPU start, until we are ready to let the HW models
 * run via hwm_one_event()
 */
void posix_init(int argc, char *argv[])
{
  407908:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	 * Let's ensure that even if we are redirecting to a file, we get stdout
	 * and stderr line buffered (default for console)
	 * Note that glibc ignores size. But just in case we set a reasonable
	 * number in case somebody tries to compile against a different library
	 */
	setvbuf(stdout, NULL, _IOLBF, 512);
  40790c:	d2804003 	mov	x3, #0x200                 	// #512
  407910:	52800022 	mov	w2, #0x1                   	// #1
{
  407914:	910003fd 	mov	x29, sp
  407918:	a90153f3 	stp	x19, x20, [sp, #16]
  40791c:	2a0003f3 	mov	w19, w0
	setvbuf(stdout, NULL, _IOLBF, 512);
  407920:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
{
  407924:	aa0103f4 	mov	x20, x1
	setvbuf(stdout, NULL, _IOLBF, 512);
  407928:	d2800001 	mov	x1, #0x0                   	// #0
  40792c:	f9475800 	ldr	x0, [x0, #3760]
  407930:	f9400000 	ldr	x0, [x0]
  407934:	97ffe697 	bl	401390 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
  407938:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40793c:	d2804003 	mov	x3, #0x200                 	// #512
  407940:	52800022 	mov	w2, #0x1                   	// #1
  407944:	d2800001 	mov	x1, #0x0                   	// #0
  407948:	f9472000 	ldr	x0, [x0, #3648]
  40794c:	f9400000 	ldr	x0, [x0]
  407950:	97ffe690 	bl	401390 <setvbuf@plt>

	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
  407954:	52800000 	mov	w0, #0x0                   	// #0
  407958:	97fffcaa 	bl	406c00 <run_native_tasks>

	native_handle_cmd_line(argc, argv);
  40795c:	aa1403e1 	mov	x1, x20
  407960:	2a1303e0 	mov	w0, w19
  407964:	94000335 	bl	408638 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
  407968:	52800020 	mov	w0, #0x1                   	// #1
  40796c:	97fffca5 	bl	406c00 <run_native_tasks>

	hwm_init();
  407970:	97fffd6e 	bl	406f28 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
  407974:	52800040 	mov	w0, #0x2                   	// #2
  407978:	97fffca2 	bl	406c00 <run_native_tasks>

	posix_boot_cpu();
  40797c:	97fffc67 	bl	406b18 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
}
  407980:	a94153f3 	ldp	x19, x20, [sp, #16]
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  407984:	52800060 	mov	w0, #0x3                   	// #3
}
  407988:	a8c27bfd 	ldp	x29, x30, [sp], #32
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  40798c:	17fffc9d 	b	406c00 <run_native_tasks>

0000000000407990 <main>:
 *
 * Not used when building fuzz cases, as libfuzzer has its own main()
 * and calls the "OS" through a per-case fuzz test entry point.
 */
int main(int argc, char *argv[])
{
  407990:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  407994:	910003fd 	mov	x29, sp
	posix_init(argc, argv);
  407998:	97ffffdc 	bl	407908 <posix_init>
	while (true) {
		hwm_one_event();
  40799c:	97fffd29 	bl	406e40 <hwm_one_event>
	while (true) {
  4079a0:	17ffffff 	b	40799c <main+0xc>

00000000004079a4 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
  4079a4:	d0000120 	adrp	x0, 42d000 <__dso_handle>
  4079a8:	912b2000 	add	x0, x0, #0xac8
  4079ac:	f900001f 	str	xzr, [x0]
	is_a_tty[1] = 0;
}
  4079b0:	d65f03c0 	ret

00000000004079b4 <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
  4079b4:	d0000120 	adrp	x0, 42d000 <__dso_handle>
  4079b8:	912b2000 	add	x0, x0, #0xac8
  4079bc:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  4079c0:	f9000001 	str	x1, [x0]
	is_a_tty[1] = -1;

}
  4079c4:	d65f03c0 	ret

00000000004079c8 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
  4079c8:	d0000120 	adrp	x0, 42d000 <__dso_handle>
  4079cc:	912b2000 	add	x0, x0, #0xac8
  4079d0:	b20003e1 	mov	x1, #0x100000001           	// #4294967297
  4079d4:	f9000001 	str	x1, [x0]
	is_a_tty[1] = 1;
}
  4079d8:	d65f03c0 	ret

00000000004079dc <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
  4079dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4079e0:	910003fd 	mov	x29, sp
  4079e4:	f9000bf3 	str	x19, [sp, #16]
	if (is_a_tty[0] == -1) {
  4079e8:	d0000133 	adrp	x19, 42d000 <__dso_handle>
  4079ec:	b94aca60 	ldr	w0, [x19, #2760]
  4079f0:	3100041f 	cmn	w0, #0x1
  4079f4:	54000081 	b.ne	407a04 <decide_about_color+0x28>  // b.any
		is_a_tty[0] = isatty(STDOUT_FILENO);
  4079f8:	52800020 	mov	w0, #0x1                   	// #1
  4079fc:	97ffe6f1 	bl	4015c0 <isatty@plt>
  407a00:	b90aca60 	str	w0, [x19, #2760]
	}
	if (is_a_tty[1] == -1) {
  407a04:	912b2273 	add	x19, x19, #0xac8
  407a08:	b9400660 	ldr	w0, [x19, #4]
  407a0c:	3100041f 	cmn	w0, #0x1
  407a10:	54000081 	b.ne	407a20 <decide_about_color+0x44>  // b.any
		is_a_tty[1] = isatty(STDERR_FILENO);
  407a14:	52800040 	mov	w0, #0x2                   	// #2
  407a18:	97ffe6ea 	bl	4015c0 <isatty@plt>
  407a1c:	b9000660 	str	w0, [x19, #4]
	}
}
  407a20:	f9400bf3 	ldr	x19, [sp, #16]
  407a24:	a8c27bfd 	ldp	x29, x30, [sp], #32
  407a28:	d65f03c0 	ret

0000000000407a2c <posix_print_error_and_exit>:
{
  407a2c:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  407a30:	aa0003e8 	mov	x8, x0
  407a34:	910003fd 	mov	x29, sp
  407a38:	a9108be1 	stp	x1, x2, [sp, #264]
  407a3c:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
  407a40:	aa0803e2 	mov	x2, x8
  407a44:	f9478421 	ldr	x1, [x1, #3848]
  407a48:	3d8023e0 	str	q0, [sp, #128]
  407a4c:	3d8027e1 	str	q1, [sp, #144]
  407a50:	3d802be2 	str	q2, [sp, #160]
  407a54:	3d802fe3 	str	q3, [sp, #176]
  407a58:	3d8033e4 	str	q4, [sp, #192]
  407a5c:	3d8037e5 	str	q5, [sp, #208]
  407a60:	3d803be6 	str	q6, [sp, #224]
  407a64:	3d803fe7 	str	q7, [sp, #240]
  407a68:	a91193e3 	stp	x3, x4, [sp, #280]
  407a6c:	910043e3 	add	x3, sp, #0x10
  407a70:	a9129be5 	stp	x5, x6, [sp, #296]
  407a74:	f9009fe7 	str	x7, [sp, #312]
  407a78:	f9400020 	ldr	x0, [x1]
  407a7c:	f9003fe0 	str	x0, [sp, #120]
  407a80:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  407a84:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
	va_start(variable_args, format);
  407a88:	910503e0 	add	x0, sp, #0x140
  407a8c:	a90383e0 	stp	x0, x0, [sp, #56]
  407a90:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  407a94:	f9472021 	ldr	x1, [x1, #3648]
	va_start(variable_args, format);
  407a98:	f90027e0 	str	x0, [sp, #72]
  407a9c:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  407aa0:	b90053e0 	str	w0, [sp, #80]
  407aa4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  407aa8:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  407aac:	f9400020 	ldr	x0, [x1]
  407ab0:	9100e3e1 	add	x1, sp, #0x38
  407ab4:	ad400420 	ldp	q0, q1, [x1]
  407ab8:	910163e1 	add	x1, sp, #0x58
  407abc:	ad000420 	stp	q0, q1, [x1]
  407ac0:	52800021 	mov	w1, #0x1                   	// #1
  407ac4:	ad000460 	stp	q0, q1, [x3]
  407ac8:	97ffe662 	bl	401450 <__vfprintf_chk@plt>
	posix_exit(1);
  407acc:	52800020 	mov	w0, #0x1                   	// #1
  407ad0:	97ffff81 	bl	4078d4 <posix_exit>
}
  407ad4:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  407ad8:	f9478400 	ldr	x0, [x0, #3848]
  407adc:	f9403fe2 	ldr	x2, [sp, #120]
  407ae0:	f9400001 	ldr	x1, [x0]
  407ae4:	eb010042 	subs	x2, x2, x1
  407ae8:	d2800001 	mov	x1, #0x0                   	// #0
  407aec:	54000040 	b.eq	407af4 <posix_print_error_and_exit+0xc8>  // b.none
  407af0:	97ffe670 	bl	4014b0 <__stack_chk_fail@plt>
  407af4:	a8d47bfd 	ldp	x29, x30, [sp], #320
  407af8:	d65f03c0 	ret

0000000000407afc <posix_print_warning>:
{
  407afc:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  407b00:	aa0003e8 	mov	x8, x0
  407b04:	910003fd 	mov	x29, sp
  407b08:	a9108be1 	stp	x1, x2, [sp, #264]
  407b0c:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  407b10:	aa0803e2 	mov	x2, x8
  407b14:	f9478421 	ldr	x1, [x1, #3848]
  407b18:	3d8023e0 	str	q0, [sp, #128]
  407b1c:	3d8027e1 	str	q1, [sp, #144]
  407b20:	3d802be2 	str	q2, [sp, #160]
  407b24:	3d802fe3 	str	q3, [sp, #176]
  407b28:	3d8033e4 	str	q4, [sp, #192]
  407b2c:	3d8037e5 	str	q5, [sp, #208]
  407b30:	3d803be6 	str	q6, [sp, #224]
  407b34:	3d803fe7 	str	q7, [sp, #240]
  407b38:	a91193e3 	stp	x3, x4, [sp, #280]
  407b3c:	910043e3 	add	x3, sp, #0x10
  407b40:	a9129be5 	stp	x5, x6, [sp, #296]
  407b44:	f9009fe7 	str	x7, [sp, #312]
  407b48:	f9400020 	ldr	x0, [x1]
  407b4c:	f9003fe0 	str	x0, [sp, #120]
  407b50:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  407b54:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
	va_start(variable_args, format);
  407b58:	910503e0 	add	x0, sp, #0x140
  407b5c:	a90383e0 	stp	x0, x0, [sp, #56]
  407b60:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  407b64:	f9472021 	ldr	x1, [x1, #3648]
	va_start(variable_args, format);
  407b68:	f90027e0 	str	x0, [sp, #72]
  407b6c:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  407b70:	b90053e0 	str	w0, [sp, #80]
  407b74:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  407b78:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  407b7c:	f9400020 	ldr	x0, [x1]
  407b80:	9100e3e1 	add	x1, sp, #0x38
  407b84:	ad400420 	ldp	q0, q1, [x1]
  407b88:	910163e1 	add	x1, sp, #0x58
  407b8c:	ad000420 	stp	q0, q1, [x1]
  407b90:	52800021 	mov	w1, #0x1                   	// #1
  407b94:	ad000460 	stp	q0, q1, [x3]
  407b98:	97ffe62e 	bl	401450 <__vfprintf_chk@plt>
}
  407b9c:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  407ba0:	f9478400 	ldr	x0, [x0, #3848]
  407ba4:	f9403fe2 	ldr	x2, [sp, #120]
  407ba8:	f9400001 	ldr	x1, [x0]
  407bac:	eb010042 	subs	x2, x2, x1
  407bb0:	d2800001 	mov	x1, #0x0                   	// #0
  407bb4:	54000040 	b.eq	407bbc <posix_print_warning+0xc0>  // b.none
  407bb8:	97ffe63e 	bl	4014b0 <__stack_chk_fail@plt>
  407bbc:	a8d47bfd 	ldp	x29, x30, [sp], #320
  407bc0:	d65f03c0 	ret

0000000000407bc4 <posix_print_trace>:
{
  407bc4:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  407bc8:	aa0003e8 	mov	x8, x0
  407bcc:	910003fd 	mov	x29, sp
  407bd0:	a9108be1 	stp	x1, x2, [sp, #264]
  407bd4:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  407bd8:	aa0803e2 	mov	x2, x8
  407bdc:	f9478421 	ldr	x1, [x1, #3848]
  407be0:	3d8023e0 	str	q0, [sp, #128]
  407be4:	3d8027e1 	str	q1, [sp, #144]
  407be8:	3d802be2 	str	q2, [sp, #160]
  407bec:	3d802fe3 	str	q3, [sp, #176]
  407bf0:	3d8033e4 	str	q4, [sp, #192]
  407bf4:	3d8037e5 	str	q5, [sp, #208]
  407bf8:	3d803be6 	str	q6, [sp, #224]
  407bfc:	3d803fe7 	str	q7, [sp, #240]
  407c00:	a91193e3 	stp	x3, x4, [sp, #280]
  407c04:	910043e3 	add	x3, sp, #0x10
  407c08:	a9129be5 	stp	x5, x6, [sp, #296]
  407c0c:	f9009fe7 	str	x7, [sp, #312]
  407c10:	f9400020 	ldr	x0, [x1]
  407c14:	f9003fe0 	str	x0, [sp, #120]
  407c18:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stdout, format, variable_args);
  407c1c:	b0000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
	va_start(variable_args, format);
  407c20:	910503e0 	add	x0, sp, #0x140
  407c24:	a90383e0 	stp	x0, x0, [sp, #56]
  407c28:	910403e0 	add	x0, sp, #0x100
	vfprintf(stdout, format, variable_args);
  407c2c:	f9475821 	ldr	x1, [x1, #3760]
	va_start(variable_args, format);
  407c30:	f90027e0 	str	x0, [sp, #72]
  407c34:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  407c38:	b90053e0 	str	w0, [sp, #80]
  407c3c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  407c40:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stdout, format, variable_args);
  407c44:	f9400020 	ldr	x0, [x1]
  407c48:	9100e3e1 	add	x1, sp, #0x38
  407c4c:	ad400420 	ldp	q0, q1, [x1]
  407c50:	910163e1 	add	x1, sp, #0x58
  407c54:	ad000420 	stp	q0, q1, [x1]
  407c58:	52800021 	mov	w1, #0x1                   	// #1
  407c5c:	ad000460 	stp	q0, q1, [x3]
  407c60:	97ffe5fc 	bl	401450 <__vfprintf_chk@plt>
}
  407c64:	b0000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  407c68:	f9478400 	ldr	x0, [x0, #3848]
  407c6c:	f9403fe2 	ldr	x2, [sp, #120]
  407c70:	f9400001 	ldr	x1, [x0]
  407c74:	eb010042 	subs	x2, x2, x1
  407c78:	d2800001 	mov	x1, #0x0                   	// #0
  407c7c:	54000040 	b.eq	407c84 <posix_print_trace+0xc0>  // b.none
  407c80:	97ffe60c 	bl	4014b0 <__stack_chk_fail@plt>
  407c84:	a8d47bfd 	ldp	x29, x30, [sp], #320
  407c88:	d65f03c0 	ret

0000000000407c8c <native_add_tracing_options>:
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
  407c8c:	d0000120 	adrp	x0, 42d000 <__dso_handle>
  407c90:	911c0000 	add	x0, x0, #0x700
  407c94:	14000233 	b	408560 <native_add_command_line_opts>

0000000000407c98 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
  407c98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  407c9c:	910003fd 	mov	x29, sp
  407ca0:	a90153f3 	stp	x19, x20, [sp, #16]
  407ca4:	aa0003f4 	mov	x20, x0
  407ca8:	a9025bf5 	stp	x21, x22, [sp, #32]
  407cac:	aa0103f6 	mov	x22, x1

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
  407cb0:	39400420 	ldrb	w0, [x1, #1]
  407cb4:	35000440 	cbnz	w0, 407d3c <cmd_gen_switch_syntax.constprop.0+0xa4>
		*buf++ = '[';
  407cb8:	52800b60 	mov	w0, #0x5b                  	// #91
		size--;
  407cbc:	528008b5 	mov	w21, #0x45                  	// #69
		*buf++ = '[';
  407cc0:	38001680 	strb	w0, [x20], #1
	}

	if (args_s_el->is_switch == true) {
  407cc4:	39400ac0 	ldrb	w0, [x22, #2]
		ret = snprintf(buf, size, "-%s", args_s_el->option);
  407cc8:	93407ea1 	sxtw	x1, w21
  407ccc:	f94006c5 	ldr	x5, [x22, #8]
	if (args_s_el->is_switch == true) {
  407cd0:	340003a0 	cbz	w0, 407d44 <cmd_gen_switch_syntax.constprop.0+0xac>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  407cd4:	d0000064 	adrp	x4, 415000 <__func__.2+0x30c>
  407cd8:	aa1403e0 	mov	x0, x20
  407cdc:	912d6c84 	add	x4, x4, #0xb5b
  407ce0:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  407ce4:	52800022 	mov	w2, #0x1                   	// #1
  407ce8:	97ffe5b6 	bl	4013c0 <__snprintf_chk@plt>
  407cec:	2a0003f3 	mov	w19, w0
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
  407cf0:	36f800e0 	tbz	w0, #31, 407d0c <cmd_gen_switch_syntax.constprop.0+0x74>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
  407cf4:	d0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  407cf8:	d0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  407cfc:	912dd021 	add	x1, x1, #0xb74
  407d00:	912ec800 	add	x0, x0, #0xbb2
  407d04:	528020e2 	mov	w2, #0x107                 	// #263
  407d08:	97ffff49 	bl	407a2c <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
  407d0c:	6b1302a1 	subs	w1, w21, w19
  407d10:	540003c4 	b.mi	407d88 <cmd_gen_switch_syntax.constprop.0+0xf0>  // b.first
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
  407d14:	394006c2 	ldrb	w2, [x22, #1]
	buf += ret;
  407d18:	8b33c280 	add	x0, x20, w19, sxtw
		snprintf(buf, size, "] ");
  407d1c:	93407c21 	sxtw	x1, w1
	if (args_s_el->is_mandatory == false) {
  407d20:	350002e2 	cbnz	w2, 407d7c <cmd_gen_switch_syntax.constprop.0+0xe4>
  407d24:	d0000062 	adrp	x2, 415000 <__func__.2+0x30c>
  407d28:	9107a442 	add	x2, x2, #0x1e9
	} else {
		snprintf(buf, size, " ");
	}
}
  407d2c:	a94153f3 	ldp	x19, x20, [sp, #16]
  407d30:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407d34:	a8c37bfd 	ldp	x29, x30, [sp], #48
  407d38:	17ffe59a 	b	4013a0 <snprintf@plt>
  407d3c:	528008d5 	mov	w21, #0x46                  	// #70
  407d40:	17ffffe1 	b	407cc4 <cmd_gen_switch_syntax.constprop.0+0x2c>
		if (args_s_el->type != 'l') {
  407d44:	394062c0 	ldrb	w0, [x22, #24]
			ret = snprintf(buf, size, "-%s=<%s>",
  407d48:	f9400ac6 	ldr	x6, [x22, #16]
		if (args_s_el->type != 'l') {
  407d4c:	7101b01f 	cmp	w0, #0x6c
  407d50:	54000100 	b.eq	407d70 <cmd_gen_switch_syntax.constprop.0+0xd8>  // b.none
  407d54:	d0000064 	adrp	x4, 415000 <__func__.2+0x30c>
  407d58:	912d7c84 	add	x4, x4, #0xb5f
  407d5c:	aa1403e0 	mov	x0, x20
  407d60:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  407d64:	52800022 	mov	w2, #0x1                   	// #1
  407d68:	97ffe596 	bl	4013c0 <__snprintf_chk@plt>
  407d6c:	17ffffe0 	b	407cec <cmd_gen_switch_syntax.constprop.0+0x54>
  407d70:	d0000064 	adrp	x4, 415000 <__func__.2+0x30c>
  407d74:	912da084 	add	x4, x4, #0xb68
  407d78:	17fffff9 	b	407d5c <cmd_gen_switch_syntax.constprop.0+0xc4>
  407d7c:	d0000062 	adrp	x2, 415000 <__func__.2+0x30c>
  407d80:	91083c42 	add	x2, x2, #0x20f
  407d84:	17ffffea 	b	407d2c <cmd_gen_switch_syntax.constprop.0+0x94>
}
  407d88:	a94153f3 	ldp	x19, x20, [sp, #16]
  407d8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407d90:	a8c37bfd 	ldp	x29, x30, [sp], #48
  407d94:	d65f03c0 	ret

0000000000407d98 <cmd_is_option>:
{
  407d98:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  407d9c:	910003fd 	mov	x29, sp
  407da0:	a90153f3 	stp	x19, x20, [sp, #16]
  407da4:	aa0003f4 	mov	x20, x0
  407da8:	2a0203f3 	mov	w19, w2
	size_t to_match_len = strlen(option);
  407dac:	aa0103e0 	mov	x0, x1
{
  407db0:	a9025bf5 	stp	x21, x22, [sp, #32]
  407db4:	aa0103f5 	mov	x21, x1
  407db8:	f9001bf7 	str	x23, [sp, #48]
	size_t to_match_len = strlen(option);
  407dbc:	97ffe551 	bl	401300 <strlen@plt>
  407dc0:	aa0003f7 	mov	x23, x0
	if (arg[of] == '-') {
  407dc4:	39400280 	ldrb	w0, [x20]
  407dc8:	7100b41f 	cmp	w0, #0x2d
	if (arg[of] == '-') {
  407dcc:	9a9f17e0 	cset	x0, eq  // eq = none
	if (arg[of] == '-') {
  407dd0:	1a9f17f6 	cset	w22, eq  // eq = none
	if (arg[of] == '-') {
  407dd4:	38606a80 	ldrb	w0, [x20, x0]
		of++;
  407dd8:	7100b41f 	cmp	w0, #0x2d
  407ddc:	1a9616d6 	cinc	w22, w22, eq  // eq = none
	if (!with_value) {
  407de0:	93407ec2 	sxtw	x2, w22
  407de4:	34000293 	cbz	w19, 407e34 <cmd_is_option+0x9c>
		if (*option == 0) {
  407de8:	cb0202b5 	sub	x21, x21, x2
	while (!(arg[of] == 0 && *option == 0)) {
  407dec:	38626a80 	ldrb	w0, [x20, x2]
  407df0:	2a0203f3 	mov	w19, w2
		if (*option == 0) {
  407df4:	38626aa1 	ldrb	w1, [x21, x2]
	while (!(arg[of] == 0 && *option == 0)) {
  407df8:	2a010003 	orr	w3, w0, w1
  407dfc:	34000123 	cbz	w3, 407e20 <cmd_is_option+0x88>
		if (*option == 0) {
  407e00:	35000301 	cbnz	w1, 407e60 <cmd_is_option+0xc8>
			if ((arg[of] == ':') || (arg[of] == '=')) {
  407e04:	7100e81f 	cmp	w0, #0x3a
  407e08:	528007a1 	mov	w1, #0x3d                  	// #61
  407e0c:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  407e10:	540002e1 	b.ne	407e6c <cmd_is_option+0xd4>  // b.any
				of++;
  407e14:	11000673 	add	w19, w19, #0x1
	if (arg[of] == 0) { /* we need a value to follow */
  407e18:	3873ca80 	ldrb	w0, [x20, w19, sxtw]
  407e1c:	35000160 	cbnz	w0, 407e48 <cmd_is_option+0xb0>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
  407e20:	aa1403e1 	mov	x1, x20
  407e24:	d0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  407e28:	912f3400 	add	x0, x0, #0xbcd
  407e2c:	97ffff00 	bl	407a2c <posix_print_error_and_exit>
  407e30:	14000006 	b	407e48 <cmd_is_option+0xb0>
		if (strcmp(&arg[of], option) != 0) {
  407e34:	aa1503e1 	mov	x1, x21
  407e38:	8b020280 	add	x0, x20, x2
  407e3c:	97ffe5b9 	bl	401520 <strcmp@plt>
  407e40:	35000040 	cbnz	w0, 407e48 <cmd_is_option+0xb0>
			return of + to_match_len;
  407e44:	0b1702d3 	add	w19, w22, w23
}
  407e48:	2a1303e0 	mov	w0, w19
  407e4c:	a94153f3 	ldp	x19, x20, [sp, #16]
  407e50:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407e54:	f9401bf7 	ldr	x23, [sp, #48]
  407e58:	a8c47bfd 	ldp	x29, x30, [sp], #64
  407e5c:	d65f03c0 	ret
		if (arg[of] != *option) {
  407e60:	91000442 	add	x2, x2, #0x1
  407e64:	6b01001f 	cmp	w0, w1
  407e68:	54fffc20 	b.eq	407dec <cmd_is_option+0x54>  // b.none
			return 0;
  407e6c:	52800013 	mov	w19, #0x0                   	// #0
  407e70:	17fffff6 	b	407e48 <cmd_is_option+0xb0>

0000000000407e74 <cmd_is_help_option>:
{
  407e74:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  407e78:	910003fd 	mov	x29, sp
  407e7c:	f9000bf3 	str	x19, [sp, #16]
  407e80:	aa0003f3 	mov	x19, x0
	if (arg[0] == '-') {
  407e84:	39400000 	ldrb	w0, [x0]
  407e88:	7100b41f 	cmp	w0, #0x2d
  407e8c:	540000c1 	b.ne	407ea4 <cmd_is_help_option+0x30>  // b.any
	if (arg[0] == '-') {
  407e90:	aa1303e0 	mov	x0, x19
		arg++;
  407e94:	91000a73 	add	x19, x19, #0x2
	if (arg[0] == '-') {
  407e98:	38401c01 	ldrb	w1, [x0, #1]!
		arg++;
  407e9c:	7100b43f 	cmp	w1, #0x2d
  407ea0:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	if ((strcasecmp(arg, "?") == 0) ||
  407ea4:	d0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  407ea8:	aa1303e0 	mov	x0, x19
  407eac:	91309c21 	add	x1, x1, #0xc27
  407eb0:	97ffe574 	bl	401480 <strcasecmp@plt>
  407eb4:	340001e0 	cbz	w0, 407ef0 <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "h") == 0) ||
  407eb8:	f0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  407ebc:	aa1303e0 	mov	x0, x19
  407ec0:	913c2c21 	add	x1, x1, #0xf0b
  407ec4:	97ffe56f 	bl	401480 <strcasecmp@plt>
	if ((strcasecmp(arg, "?") == 0) ||
  407ec8:	34000140 	cbz	w0, 407ef0 <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "help") == 0)) {
  407ecc:	aa1303e0 	mov	x0, x19
  407ed0:	d0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  407ed4:	91330c21 	add	x1, x1, #0xcc3
  407ed8:	97ffe56a 	bl	401480 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
  407edc:	7100001f 	cmp	w0, #0x0
  407ee0:	1a9f17e0 	cset	w0, eq  // eq = none
}
  407ee4:	f9400bf3 	ldr	x19, [sp, #16]
  407ee8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  407eec:	d65f03c0 	ret
		return 1;
  407ef0:	52800020 	mov	w0, #0x1                   	// #1
  407ef4:	17fffffc 	b	407ee4 <cmd_is_help_option+0x70>

0000000000407ef8 <cmd_read_option_value>:
{
  407ef8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  407efc:	910003fd 	mov	x29, sp
  407f00:	a90153f3 	stp	x19, x20, [sp, #16]
  407f04:	aa0103f4 	mov	x20, x1
  407f08:	12001c41 	and	w1, w2, #0xff
  407f0c:	b0000122 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  407f10:	f90013f5 	str	x21, [sp, #32]
  407f14:	aa0303f5 	mov	x21, x3
  407f18:	aa0003f3 	mov	x19, x0
  407f1c:	f9478442 	ldr	x2, [x2, #3848]
  407f20:	f9400043 	ldr	x3, [x2]
  407f24:	f9001fe3 	str	x3, [sp, #56]
  407f28:	d2800003 	mov	x3, #0x0                   	// #0
	char *endptr = NULL;
  407f2c:	f9001bff 	str	xzr, [sp, #48]
	switch (type) {
  407f30:	7101903f 	cmp	w1, #0x64
  407f34:	54000b40 	b.eq	40809c <cmd_read_option_value+0x1a4>  // b.none
  407f38:	54000168 	b.hi	407f64 <cmd_read_option_value+0x6c>  // b.pmore
  407f3c:	7101543f 	cmp	w1, #0x55
  407f40:	540009c0 	b.eq	408078 <cmd_read_option_value+0x180>  // b.none
  407f44:	7101883f 	cmp	w1, #0x62
  407f48:	54000220 	b.eq	407f8c <cmd_read_option_value+0x94>  // b.none
  407f4c:	7101243f 	cmp	w1, #0x49
  407f50:	540009e0 	b.eq	40808c <cmd_read_option_value+0x194>  // b.none
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
  407f54:	d0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  407f58:	9131e000 	add	x0, x0, #0xc78
  407f5c:	97fffeb4 	bl	407a2c <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
  407f60:	14000012 	b	407fa8 <cmd_read_option_value+0xb0>
	switch (type) {
  407f64:	7101cc3f 	cmp	w1, #0x73
  407f68:	54000760 	b.eq	408054 <cmd_read_option_value+0x15c>  // b.none
  407f6c:	7101d43f 	cmp	w1, #0x75
  407f70:	540007a0 	b.eq	408064 <cmd_read_option_value+0x16c>  // b.none
  407f74:	7101a43f 	cmp	w1, #0x69
  407f78:	54fffee1 	b.ne	407f54 <cmd_read_option_value+0x5c>  // b.any
		*(int32_t *)dest = strtol(str, &endptr, 0);
  407f7c:	9100c3e1 	add	x1, sp, #0x30
  407f80:	52800002 	mov	w2, #0x0                   	// #0
  407f84:	97ffe573 	bl	401550 <strtol@plt>
  407f88:	1400003a 	b	408070 <cmd_read_option_value+0x178>
		if (strcasecmp(str, "false") == 0) {
  407f8c:	d0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  407f90:	9130a421 	add	x1, x1, #0xc29
  407f94:	97ffe53b 	bl	401480 <strcasecmp@plt>
  407f98:	35000120 	cbnz	w0, 407fbc <cmd_read_option_value+0xc4>
			endptr = (char *)str + 5;
  407f9c:	91001660 	add	x0, x19, #0x5
			*(bool *)dest = false;
  407fa0:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  407fa4:	f9001be0 	str	x0, [sp, #48]
	if (!error && endptr && *endptr != 0) {
  407fa8:	f9401be0 	ldr	x0, [sp, #48]
  407fac:	b40003e0 	cbz	x0, 408028 <cmd_read_option_value+0x130>
  407fb0:	39400000 	ldrb	w0, [x0]
  407fb4:	35000300 	cbnz	w0, 408014 <cmd_read_option_value+0x11c>
  407fb8:	1400001c 	b	408028 <cmd_read_option_value+0x130>
		} else if (strcmp(str, "0") == 0) {
  407fbc:	90000081 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  407fc0:	aa1303e0 	mov	x0, x19
  407fc4:	91055821 	add	x1, x1, #0x156
  407fc8:	97ffe556 	bl	401520 <strcmp@plt>
  407fcc:	35000080 	cbnz	w0, 407fdc <cmd_read_option_value+0xe4>
			*(bool *)dest = false;
  407fd0:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  407fd4:	91000660 	add	x0, x19, #0x1
  407fd8:	17fffff3 	b	407fa4 <cmd_read_option_value+0xac>
		} else if (strcasecmp(str, "true") == 0) {
  407fdc:	d0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  407fe0:	aa1303e0 	mov	x0, x19
  407fe4:	9130bc21 	add	x1, x1, #0xc2f
  407fe8:	97ffe526 	bl	401480 <strcasecmp@plt>
  407fec:	350000a0 	cbnz	w0, 408000 <cmd_read_option_value+0x108>
			*(bool *)dest = true;
  407ff0:	52800020 	mov	w0, #0x1                   	// #1
  407ff4:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 4;
  407ff8:	91001260 	add	x0, x19, #0x4
  407ffc:	17ffffea 	b	407fa4 <cmd_read_option_value+0xac>
		} else if (strcmp(str, "1") == 0) {
  408000:	b0000061 	adrp	x1, 415000 <__func__.2+0x30c>
  408004:	aa1303e0 	mov	x0, x19
  408008:	9130d021 	add	x1, x1, #0xc34
  40800c:	97ffe545 	bl	401520 <strcmp@plt>
  408010:	340001c0 	cbz	w0, 408048 <cmd_read_option_value+0x150>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
  408014:	b0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  408018:	aa1303e2 	mov	x2, x19
  40801c:	aa1503e1 	mov	x1, x21
  408020:	9130d800 	add	x0, x0, #0xc36
  408024:	97fffe82 	bl	407a2c <posix_print_error_and_exit>
}
  408028:	90000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40802c:	f9478400 	ldr	x0, [x0, #3848]
  408030:	f9401fe2 	ldr	x2, [sp, #56]
  408034:	f9400001 	ldr	x1, [x0]
  408038:	eb010042 	subs	x2, x2, x1
  40803c:	d2800001 	mov	x1, #0x0                   	// #0
  408040:	54000360 	b.eq	4080ac <cmd_read_option_value+0x1b4>  // b.none
  408044:	97ffe51b 	bl	4014b0 <__stack_chk_fail@plt>
			*(bool *)dest = true;
  408048:	52800020 	mov	w0, #0x1                   	// #1
  40804c:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 1;
  408050:	17ffffe1 	b	407fd4 <cmd_read_option_value+0xdc>
		*(char **)dest = (char *)str;
  408054:	f9000280 	str	x0, [x20]
		endptr = (char *)str + strlen(str);
  408058:	97ffe4aa 	bl	401300 <strlen@plt>
  40805c:	8b000260 	add	x0, x19, x0
  408060:	17ffffd1 	b	407fa4 <cmd_read_option_value+0xac>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
  408064:	9100c3e1 	add	x1, sp, #0x30
  408068:	52800002 	mov	w2, #0x0                   	// #0
  40806c:	97ffe4a1 	bl	4012f0 <strtoul@plt>
		*(int32_t *)dest = strtol(str, &endptr, 0);
  408070:	b9000280 	str	w0, [x20]
	if (!error && endptr && *endptr != 0) {
  408074:	17ffffcd 	b	407fa8 <cmd_read_option_value+0xb0>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
  408078:	9100c3e1 	add	x1, sp, #0x30
  40807c:	52800002 	mov	w2, #0x0                   	// #0
  408080:	97ffe548 	bl	4015a0 <strtoull@plt>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  408084:	f9000280 	str	x0, [x20]
	if (!error && endptr && *endptr != 0) {
  408088:	17ffffc8 	b	407fa8 <cmd_read_option_value+0xb0>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  40808c:	9100c3e1 	add	x1, sp, #0x30
  408090:	52800002 	mov	w2, #0x0                   	// #0
  408094:	97ffe4a7 	bl	401330 <strtoll@plt>
  408098:	17fffffb 	b	408084 <cmd_read_option_value+0x18c>
		*(double *)dest = strtod(str, &endptr);
  40809c:	9100c3e1 	add	x1, sp, #0x30
  4080a0:	97ffe4ac 	bl	401350 <strtod@plt>
  4080a4:	fd000280 	str	d0, [x20]
	if (!error && endptr && *endptr != 0) {
  4080a8:	17ffffc0 	b	407fa8 <cmd_read_option_value+0xb0>
}
  4080ac:	a94153f3 	ldp	x19, x20, [sp, #16]
  4080b0:	f94013f5 	ldr	x21, [sp, #32]
  4080b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4080b8:	d65f03c0 	ret

00000000004080bc <cmd_args_set_defaults>:
{
  4080bc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4080c0:	910003fd 	mov	x29, sp
  4080c4:	a90153f3 	stp	x19, x20, [sp, #16]
  4080c8:	91002013 	add	x19, x0, #0x8
			*(double *)args_struct[count].dest = (double)NAN;
  4080cc:	90000060 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  4080d0:	b0000074 	adrp	x20, 415000 <__func__.2+0x30c>
  4080d4:	9131e294 	add	x20, x20, #0xc78
{
  4080d8:	fd001be8 	str	d8, [sp, #48]
			*(double *)args_struct[count].dest = (double)NAN;
  4080dc:	fd43b408 	ldr	d8, [x0, #1896]
{
  4080e0:	a9025bf5 	stp	x21, x22, [sp, #32]
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  4080e4:	12800015 	mov	w21, #0xffffffff            	// #-1
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  4080e8:	12b00016 	mov	w22, #0x7fffffff            	// #2147483647
	while (args_struct[count].option != NULL) {
  4080ec:	f9400260 	ldr	x0, [x19]
  4080f0:	b50000c0 	cbnz	x0, 408108 <cmd_args_set_defaults+0x4c>
}
  4080f4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4080f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4080fc:	fd401be8 	ldr	d8, [sp, #48]
  408100:	a8c47bfd 	ldp	x29, x30, [sp], #64
  408104:	d65f03c0 	ret
		if (args_struct[count].dest == NULL) {
  408108:	f9400e62 	ldr	x2, [x19, #24]
  40810c:	b4000222 	cbz	x2, 408150 <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  408110:	39404261 	ldrb	w1, [x19, #16]
  408114:	7101903f 	cmp	w1, #0x64
  408118:	54000420 	b.eq	40819c <cmd_args_set_defaults+0xe0>  // b.none
  40811c:	540001e8 	b.hi	408158 <cmd_args_set_defaults+0x9c>  // b.pmore
  408120:	7101543f 	cmp	w1, #0x55
  408124:	54000320 	b.eq	408188 <cmd_args_set_defaults+0xcc>  // b.none
  408128:	540000e8 	b.hi	408144 <cmd_args_set_defaults+0x88>  // b.pmore
  40812c:	34000121 	cbz	w1, 408150 <cmd_args_set_defaults+0x94>
  408130:	7101243f 	cmp	w1, #0x49
  408134:	54000300 	b.eq	408194 <cmd_args_set_defaults+0xd8>  // b.none
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  408138:	aa1403e0 	mov	x0, x20
  40813c:	97fffe3c 	bl	407a2c <posix_print_error_and_exit>
			break;
  408140:	14000004 	b	408150 <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  408144:	7101883f 	cmp	w1, #0x62
  408148:	54ffff81 	b.ne	408138 <cmd_args_set_defaults+0x7c>  // b.any
			*(bool *)args_struct[count].dest = false;
  40814c:	3900005f 	strb	wzr, [x2]
			break;
  408150:	9100e273 	add	x19, x19, #0x38
  408154:	17ffffe6 	b	4080ec <cmd_args_set_defaults+0x30>
		switch (args_struct[count].type) {
  408158:	7101cc3f 	cmp	w1, #0x73
  40815c:	540000e0 	b.eq	408178 <cmd_args_set_defaults+0xbc>  // b.none
  408160:	7101d43f 	cmp	w1, #0x75
  408164:	540000e0 	b.eq	408180 <cmd_args_set_defaults+0xc4>  // b.none
  408168:	7101a43f 	cmp	w1, #0x69
  40816c:	54fffe61 	b.ne	408138 <cmd_args_set_defaults+0x7c>  // b.any
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  408170:	b9000056 	str	w22, [x2]
			break;
  408174:	17fffff7 	b	408150 <cmd_args_set_defaults+0x94>
			*(char **)args_struct[count].dest = NULL;
  408178:	f900005f 	str	xzr, [x2]
			break;
  40817c:	17fffff5 	b	408150 <cmd_args_set_defaults+0x94>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  408180:	b9000055 	str	w21, [x2]
			break;
  408184:	17fffff3 	b	408150 <cmd_args_set_defaults+0x94>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
  408188:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  40818c:	f9000040 	str	x0, [x2]
			break;
  408190:	17fffff0 	b	408150 <cmd_args_set_defaults+0x94>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  408194:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  408198:	17fffffd 	b	40818c <cmd_args_set_defaults+0xd0>
			*(double *)args_struct[count].dest = (double)NAN;
  40819c:	fd000048 	str	d8, [x2]
			break;
  4081a0:	17ffffec 	b	408150 <cmd_args_set_defaults+0x94>

00000000004081a4 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
  4081a4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  4081a8:	b0000063 	adrp	x3, 415000 <__func__.2+0x30c>
  4081ac:	d0000062 	adrp	x2, 416000 <__func__.0+0x57a>
  4081b0:	910003fd 	mov	x29, sp
  4081b4:	a90153f3 	stp	x19, x20, [sp, #16]
  4081b8:	aa0003f4 	mov	x20, x0
  4081bc:	90000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;

	fprintf(stdout, "%s ", _HELP_SWITCH);
  4081c0:	90000133 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
{
  4081c4:	a9025bf5 	stp	x21, x22, [sp, #32]
  4081c8:	91327463 	add	x3, x3, #0xc9d
  4081cc:	f9478400 	ldr	x0, [x0, #3848]
  4081d0:	a90363f7 	stp	x23, x24, [sp, #48]
  4081d4:	911ca442 	add	x2, x2, #0x729
  4081d8:	f9400001 	ldr	x1, [x0]
  4081dc:	f90047e1 	str	x1, [sp, #136]
  4081e0:	d2800001 	mov	x1, #0x0                   	// #0
  4081e4:	d0000077 	adrp	x23, 416000 <__func__.0+0x57a>
	fprintf(stdout, "%s ", _HELP_SWITCH);
  4081e8:	f9475a60 	ldr	x0, [x19, #3760]
  4081ec:	90000078 	adrp	x24, 414000 <sys_clock_tick_get+0x78>

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  4081f0:	910103f6 	add	x22, sp, #0x40
  4081f4:	912552f7 	add	x23, x23, #0x954
  4081f8:	9122b318 	add	x24, x24, #0x8ac
  4081fc:	52800021 	mov	w1, #0x1                   	// #1
  408200:	f9400000 	ldr	x0, [x0]
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
  408204:	52800335 	mov	w21, #0x19                  	// #25
  408208:	97ffe4c2 	bl	401510 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
  40820c:	f9400680 	ldr	x0, [x20, #8]
  408210:	b5000120 	cbnz	x0, 408234 <cmd_print_switches_help+0x90>
  408214:	90000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  408218:	f9478400 	ldr	x0, [x0, #3848]
  40821c:	f94047e2 	ldr	x2, [sp, #136]
  408220:	f9400001 	ldr	x1, [x0]
  408224:	eb010042 	subs	x2, x2, x1
  408228:	d2800001 	mov	x1, #0x0                   	// #0
  40822c:	54000360 	b.eq	408298 <cmd_print_switches_help+0xf4>  // b.none
  408230:	97ffe4a0 	bl	4014b0 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  408234:	aa1403e1 	mov	x1, x20
  408238:	aa1603e0 	mov	x0, x22
  40823c:	97fffe97 	bl	407c98 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
  408240:	aa1603e0 	mov	x0, x22
  408244:	97ffe42f 	bl	401300 <strlen@plt>
  408248:	8b35c000 	add	x0, x0, w21, sxtw
  40824c:	f101901f 	cmp	x0, #0x64
  408250:	540000e9 	b.ls	40826c <cmd_print_switches_help+0xc8>  // b.plast
			fprintf(stdout, "\n");
  408254:	f9475a60 	ldr	x0, [x19, #3760]
  408258:	aa1703e2 	mov	x2, x23
  40825c:	52800021 	mov	w1, #0x1                   	// #1
			printed_in_line = 0;
  408260:	52800015 	mov	w21, #0x0                   	// #0
  408264:	f9400000 	ldr	x0, [x0]
  408268:	97ffe4aa 	bl	401510 <__fprintf_chk@plt>
		}

		fprintf(stdout, "%s", stringy);
  40826c:	f9475a60 	ldr	x0, [x19, #3760]
  408270:	aa1603e3 	mov	x3, x22
  408274:	aa1803e2 	mov	x2, x24
  408278:	52800021 	mov	w1, #0x1                   	// #1
  40827c:	9100e294 	add	x20, x20, #0x38
  408280:	f9400000 	ldr	x0, [x0]
  408284:	97ffe4a3 	bl	401510 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
  408288:	aa1603e0 	mov	x0, x22
  40828c:	97ffe41d 	bl	401300 <strlen@plt>
  408290:	0b0002b5 	add	w21, w21, w0
		count++;
  408294:	17ffffde 	b	40820c <cmd_print_switches_help+0x68>
	}

	fprintf(stdout, "\n");
  408298:	f9475a73 	ldr	x19, [x19, #3760]
  40829c:	d0000062 	adrp	x2, 416000 <__func__.0+0x57a>
}
  4082a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4082a4:	91255042 	add	x2, x2, #0x954
  4082a8:	f9400260 	ldr	x0, [x19]
  4082ac:	52800021 	mov	w1, #0x1                   	// #1
  4082b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4082b4:	a94363f7 	ldp	x23, x24, [sp, #48]
  4082b8:	a8c97bfd 	ldp	x29, x30, [sp], #144
  4082bc:	17ffe495 	b	401510 <__fprintf_chk@plt>

00000000004082c0 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
  4082c0:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  4082c4:	90000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4082c8:	910003fd 	mov	x29, sp
  4082cc:	f9478421 	ldr	x1, [x1, #3848]
  4082d0:	a90153f3 	stp	x19, x20, [sp, #16]
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  4082d4:	90000134 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
{
  4082d8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4082dc:	aa0003f3 	mov	x19, x0
  4082e0:	a90363f7 	stp	x23, x24, [sp, #48]
  4082e4:	b0000077 	adrp	x23, 415000 <__func__.2+0x30c>
  4082e8:	d0000078 	adrp	x24, 416000 <__func__.0+0x57a>
  4082ec:	a9046bf9 	stp	x25, x26, [sp, #64]
  4082f0:	91334ef7 	add	x23, x23, #0xcd3
  4082f4:	911c7318 	add	x24, x24, #0x71c
  4082f8:	a90573fb 	stp	x27, x28, [sp, #80]
  4082fc:	f9400022 	ldr	x2, [x1]
  408300:	f90057e2 	str	x2, [sp, #168]
  408304:	d2800002 	mov	x2, #0x0                   	// #0
	cmd_print_switches_help(args_struct);
  408308:	97ffffa7 	bl	4081a4 <cmd_print_switches_help>
	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  40830c:	f9475a80 	ldr	x0, [x20, #3760]
  408310:	b0000065 	adrp	x5, 415000 <__func__.2+0x30c>
  408314:	b0000064 	adrp	x4, 415000 <__func__.2+0x30c>
  408318:	b0000062 	adrp	x2, 415000 <__func__.2+0x30c>
  40831c:	9132d8a5 	add	x5, x5, #0xcb6
  408320:	91327484 	add	x4, x4, #0xc9d
  408324:	f9400000 	ldr	x0, [x0]
  408328:	91332042 	add	x2, x2, #0xcc8
  40832c:	528003a3 	mov	w3, #0x1d                  	// #29
  408330:	52800021 	mov	w1, #0x1                   	// #1
  408334:	97ffe477 	bl	401510 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
  408338:	f9400660 	ldr	x0, [x19, #8]
  40833c:	b5000280 	cbnz	x0, 40838c <cmd_print_long_help+0xcc>
				      &toprint[printed_right]);
			printed_right += ret - 1;
		}
		count++;
	}
	fprintf(stdout, "\n");
  408340:	f9475a94 	ldr	x20, [x20, #3760]
  408344:	52800021 	mov	w1, #0x1                   	// #1
  408348:	d0000062 	adrp	x2, 416000 <__func__.0+0x57a>
  40834c:	91255042 	add	x2, x2, #0x954
  408350:	f9400280 	ldr	x0, [x20]
  408354:	97ffe46f 	bl	401510 <__fprintf_chk@plt>
  408358:	f9400280 	ldr	x0, [x20]
  40835c:	52800021 	mov	w1, #0x1                   	// #1
  408360:	b0000062 	adrp	x2, 415000 <__func__.2+0x30c>
  408364:	91339042 	add	x2, x2, #0xce4
  408368:	97ffe46a 	bl	401510 <__fprintf_chk@plt>
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
  40836c:	90000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  408370:	f9478400 	ldr	x0, [x0, #3848]
  408374:	f94057e2 	ldr	x2, [sp, #168]
  408378:	f9400001 	ldr	x1, [x0]
  40837c:	eb010042 	subs	x2, x2, x1
  408380:	d2800001 	mov	x1, #0x0                   	// #0
  408384:	54000600 	b.eq	408444 <cmd_print_long_help+0x184>  // b.none
  408388:	97ffe44a 	bl	4014b0 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  40838c:	910183f5 	add	x21, sp, #0x60
  408390:	aa1303e1 	mov	x1, x19
  408394:	aa1503e0 	mov	x0, x21
  408398:	97fffe40 	bl	407c98 <cmd_gen_switch_syntax.constprop.0>
		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
  40839c:	f9475a96 	ldr	x22, [x20, #3760]
  4083a0:	aa1503e4 	mov	x4, x21
  4083a4:	aa1703e2 	mov	x2, x23
  4083a8:	528003a3 	mov	w3, #0x1d                  	// #29
  4083ac:	52800021 	mov	w1, #0x1                   	// #1
  4083b0:	b000007b 	adrp	x27, 415000 <__func__.2+0x30c>
  4083b4:	f94002c0 	ldr	x0, [x22]
  4083b8:	b000007c 	adrp	x28, 415000 <__func__.2+0x30c>
  4083bc:	9133839c 	add	x28, x28, #0xce0
  4083c0:	97ffe454 	bl	401510 <__fprintf_chk@plt>
  4083c4:	2a0003f5 	mov	w21, w0
		toprint = args_struct[count].descript;
  4083c8:	f9401a7a 	ldr	x26, [x19, #48]
		total_to_print = strlen(toprint);
  4083cc:	aa1a03e0 	mov	x0, x26
  4083d0:	97ffe3cc 	bl	401300 <strlen@plt>
  4083d4:	2a0003f9 	mov	w25, w0
  4083d8:	aa1a03e4 	mov	x4, x26
  4083dc:	f94002c0 	ldr	x0, [x22]
  4083e0:	91336b62 	add	x2, x27, #0xcda
  4083e4:	52800c83 	mov	w3, #0x64                  	// #100
  4083e8:	52800021 	mov	w1, #0x1                   	// #1
  4083ec:	4b150063 	sub	w3, w3, w21
  4083f0:	97ffe448 	bl	401510 <__fprintf_chk@plt>
		printed_right += ret - 1;
  4083f4:	51000415 	sub	w21, w0, #0x1
		while (printed_right < total_to_print) {
  4083f8:	6b1902bf 	cmp	w21, w25
  4083fc:	5400006b 	b.lt	408408 <cmd_print_long_help+0x148>  // b.tstop
		count++;
  408400:	9100e273 	add	x19, x19, #0x38
  408404:	17ffffcd 	b	408338 <cmd_print_long_help+0x78>
  408408:	f94002c0 	ldr	x0, [x22]
  40840c:	aa1803e4 	mov	x4, x24
  408410:	aa1c03e2 	mov	x2, x28
  408414:	528003c3 	mov	w3, #0x1e                  	// #30
  408418:	52800021 	mov	w1, #0x1                   	// #1
  40841c:	97ffe43d 	bl	401510 <__fprintf_chk@plt>
  408420:	f94002c0 	ldr	x0, [x22]
  408424:	8b35c344 	add	x4, x26, w21, sxtw
  408428:	91336b62 	add	x2, x27, #0xcda
  40842c:	528008c3 	mov	w3, #0x46                  	// #70
  408430:	52800021 	mov	w1, #0x1                   	// #1
  408434:	97ffe437 	bl	401510 <__fprintf_chk@plt>
			printed_right += ret - 1;
  408438:	51000400 	sub	w0, w0, #0x1
  40843c:	0b0002b5 	add	w21, w21, w0
  408440:	17ffffee 	b	4083f8 <cmd_print_long_help+0x138>
}
  408444:	a94153f3 	ldp	x19, x20, [sp, #16]
  408448:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40844c:	a94363f7 	ldp	x23, x24, [sp, #48]
  408450:	a9446bf9 	ldp	x25, x26, [sp, #64]
  408454:	a94573fb 	ldp	x27, x28, [sp, #80]
  408458:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  40845c:	d65f03c0 	ret

0000000000408460 <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
  408460:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  408464:	910003fd 	mov	x29, sp
  408468:	a90153f3 	stp	x19, x20, [sp, #16]
  40846c:	aa0003f4 	mov	x20, x0
  408470:	aa0103f3 	mov	x19, x1
  408474:	f90013f5 	str	x21, [sp, #32]
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
  408478:	97fffe7f 	bl	407e74 <cmd_is_help_option>
  40847c:	340000a0 	cbz	w0, 408490 <cmd_parse_one_arg+0x30>
		cmd_print_long_help(args_struct);
  408480:	aa1303e0 	mov	x0, x19
  408484:	97ffff8f 	bl	4082c0 <cmd_print_long_help>
		posix_exit(0);
  408488:	52800000 	mov	w0, #0x0                   	// #0
  40848c:	97fffd12 	bl	4078d4 <posix_exit>
	}

	while (args_struct[count].option != NULL) {
  408490:	f9400661 	ldr	x1, [x19, #8]
  408494:	b50000c1 	cbnz	x1, 4084ac <cmd_parse_one_arg+0x4c>
						    &args_struct[count]);
			return true;
		}
		count++;
	}
	return false;
  408498:	52800000 	mov	w0, #0x0                   	// #0
}
  40849c:	a94153f3 	ldp	x19, x20, [sp, #16]
  4084a0:	f94013f5 	ldr	x21, [sp, #32]
  4084a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4084a8:	d65f03c0 	ret
		if (args_struct[count].manual) {
  4084ac:	39400260 	ldrb	w0, [x19]
  4084b0:	350003e0 	cbnz	w0, 40852c <cmd_parse_one_arg+0xcc>
				    !args_struct[count].is_switch);
  4084b4:	39400a62 	ldrb	w2, [x19, #2]
		ret = cmd_is_option(argv, args_struct[count].option,
  4084b8:	aa1403e0 	mov	x0, x20
  4084bc:	52000042 	eor	w2, w2, #0x1
  4084c0:	97fffe36 	bl	407d98 <cmd_is_option>
  4084c4:	2a0003f5 	mov	w21, w0
		if (ret) {
  4084c8:	34000320 	cbz	w0, 40852c <cmd_parse_one_arg+0xcc>
	if (arg_element->dest != NULL) {
  4084cc:	f9401261 	ldr	x1, [x19, #32]
  4084d0:	b4000101 	cbz	x1, 4084f0 <cmd_parse_one_arg+0x90>
		if (arg_element->is_switch) {
  4084d4:	39400a60 	ldrb	w0, [x19, #2]
			if (arg_element->type == 'b') {
  4084d8:	39406262 	ldrb	w2, [x19, #24]
		if (arg_element->is_switch) {
  4084dc:	34000200 	cbz	w0, 40851c <cmd_parse_one_arg+0xbc>
			if (arg_element->type == 'b') {
  4084e0:	7101885f 	cmp	w2, #0x62
  4084e4:	54000141 	b.ne	40850c <cmd_parse_one_arg+0xac>  // b.any
				*(bool *)arg_element->dest = true;
  4084e8:	52800020 	mov	w0, #0x1                   	// #1
  4084ec:	39000020 	strb	w0, [x1]
	if (arg_element->call_when_found) {
  4084f0:	f9401662 	ldr	x2, [x19, #40]
  4084f4:	b4000082 	cbz	x2, 408504 <cmd_parse_one_arg+0xa4>
		arg_element->call_when_found(argv, offset);
  4084f8:	2a1503e1 	mov	w1, w21
  4084fc:	aa1403e0 	mov	x0, x20
  408500:	d63f0040 	blr	x2
			return true;
  408504:	52800020 	mov	w0, #0x1                   	// #1
  408508:	17ffffe5 	b	40849c <cmd_parse_one_arg+0x3c>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
  40850c:	b0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  408510:	9134d000 	add	x0, x0, #0xd34
  408514:	97fffd46 	bl	407a2c <posix_print_error_and_exit>
  408518:	17fffff6 	b	4084f0 <cmd_parse_one_arg+0x90>
			cmd_read_option_value(&argv[offset],
  40851c:	f9400663 	ldr	x3, [x19, #8]
  408520:	8b35c280 	add	x0, x20, w21, sxtw
  408524:	97fffe75 	bl	407ef8 <cmd_read_option_value>
  408528:	17fffff2 	b	4084f0 <cmd_parse_one_arg+0x90>
  40852c:	9100e273 	add	x19, x19, #0x38
  408530:	17ffffd8 	b	408490 <cmd_parse_one_arg+0x30>

0000000000408534 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
  408534:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408538:	910003fd 	mov	x29, sp
  40853c:	f9000bf3 	str	x19, [sp, #16]
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
  408540:	d0000133 	adrp	x19, 42e000 <thingset_workq+0x8>
  408544:	f9471260 	ldr	x0, [x19, #3616]
  408548:	b4000060 	cbz	x0, 408554 <native_cleanup_cmd_line+0x20>
		free(args_struct);
  40854c:	97ffe405 	bl	401560 <free@plt>
		args_struct = NULL;
  408550:	f907127f 	str	xzr, [x19, #3616]
	}
}
  408554:	f9400bf3 	ldr	x19, [sp, #16]
  408558:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40855c:	d65f03c0 	ret

0000000000408560 <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
  408560:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  408564:	910003fd 	mov	x29, sp
  408568:	a9025bf5 	stp	x21, x22, [sp, #32]
  40856c:	aa0003f5 	mov	x21, x0
  408570:	91002000 	add	x0, x0, #0x8
  408574:	a90153f3 	stp	x19, x20, [sp, #16]
	int count = 0;
  408578:	52800013 	mov	w19, #0x0                   	// #0
{
  40857c:	a90363f7 	stp	x23, x24, [sp, #48]
  408580:	f90023f9 	str	x25, [sp, #64]

	while (args[count].option != NULL) {
  408584:	f8438401 	ldr	x1, [x0], #56
  408588:	2a1303f7 	mov	w23, w19
		count++;
  40858c:	11000673 	add	w19, w19, #0x1
	while (args[count].option != NULL) {
  408590:	b5ffffa1 	cbnz	x1, 408584 <native_add_command_line_opts+0x24>
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
  408594:	f0000136 	adrp	x22, 42f000 <can_loopback_dev_data_0+0xc0>
  408598:	f0000139 	adrp	x25, 42f000 <can_loopback_dev_data_0+0xc0>
  40859c:	d0000138 	adrp	x24, 42e000 <thingset_workq+0x8>
  4085a0:	b94d2ac0 	ldr	w0, [x22, #3368]
  4085a4:	b94d1f21 	ldr	w1, [x25, #3356]
  4085a8:	0b000260 	add	w0, w19, w0
  4085ac:	6b01001f 	cmp	w0, w1
  4085b0:	540001cb 	b.lt	4085e8 <native_add_command_line_opts+0x88>  // b.tstop
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
  4085b4:	7100527f 	cmp	w19, #0x14
  4085b8:	52800294 	mov	w20, #0x14                  	// #20
  4085bc:	1a94a274 	csel	w20, w19, w20, ge  // ge = tcont
  4085c0:	0b010294 	add	w20, w20, w1
		struct args_struct_t *new_args_struct = realloc(args_struct,
  4085c4:	52800701 	mov	w1, #0x38                  	// #56
  4085c8:	f9471300 	ldr	x0, [x24, #3616]
  4085cc:	9b217e81 	smull	x1, w20, w1
  4085d0:	97ffe3b0 	bl	401490 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
  4085d4:	b90d1f34 	str	w20, [x25, #3356]
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
  4085d8:	b5000260 	cbnz	x0, 408624 <native_add_command_line_opts+0xc4>
			posix_print_error_and_exit("Could not allocate memory");
  4085dc:	b0000060 	adrp	x0, 415000 <__func__.2+0x30c>
  4085e0:	9135fc00 	add	x0, x0, #0xd7f
  4085e4:	97fffd12 	bl	407a2c <posix_print_error_and_exit>
			args_struct = new_args_struct;
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
  4085e8:	b94d2ad4 	ldr	w20, [x22, #3368]
  4085ec:	52800700 	mov	w0, #0x38                  	// #56
  4085f0:	f9471303 	ldr	x3, [x24, #3616]
  return __builtin___memcpy_chk (__dest, __src, __len,
  4085f4:	9b207e62 	smull	x2, w19, w0
  4085f8:	aa1503e1 	mov	x1, x21
  4085fc:	9b200e80 	smaddl	x0, w20, w0, x3
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
  408600:	0b170294 	add	w20, w20, w23
  408604:	97ffe32f 	bl	4012c0 <memcpy@plt>
  408608:	b90d2ad4 	str	w20, [x22, #3368]
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
  40860c:	a94153f3 	ldp	x19, x20, [sp, #16]
  408610:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408614:	a94363f7 	ldp	x23, x24, [sp, #48]
  408618:	f94023f9 	ldr	x25, [sp, #64]
  40861c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  408620:	d65f03c0 	ret
			args_struct = new_args_struct;
  408624:	f9071300 	str	x0, [x24, #3616]
  408628:	17fffff0 	b	4085e8 <native_add_command_line_opts+0x88>

000000000040862c <native_add_testargs_option>:
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
  40862c:	b0000120 	adrp	x0, 42d000 <__dso_handle>
  408630:	911f8000 	add	x0, x0, #0x7e0
  408634:	17ffffcb 	b	408560 <native_add_command_line_opts>

0000000000408638 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
  408638:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40863c:	910003fd 	mov	x29, sp
  408640:	a90153f3 	stp	x19, x20, [sp, #16]
  408644:	aa0103f4 	mov	x20, x1
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
  408648:	d2800033 	mov	x19, #0x1                   	// #1
{
  40864c:	a9025bf5 	stp	x21, x22, [sp, #32]
  408650:	2a0003f5 	mov	w21, w0
  408654:	a90363f7 	stp	x23, x24, [sp, #48]
	cmd_args_set_defaults(args_struct);
  408658:	d0000138 	adrp	x24, 42e000 <thingset_workq+0x8>
{
  40865c:	a9046bf9 	stp	x25, x26, [sp, #64]
	native_add_tracing_options();
  408660:	97fffd8b 	bl	407c8c <native_add_tracing_options>
	native_add_testargs_option();
  408664:	97fffff2 	bl	40862c <native_add_testargs_option>
	s_argv = argv;
  408668:	d0000120 	adrp	x0, 42e000 <thingset_workq+0x8>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40866c:	b0000079 	adrp	x25, 415000 <__func__.2+0x30c>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  408670:	b000007a 	adrp	x26, 415000 <__func__.2+0x30c>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  408674:	91366739 	add	x25, x25, #0xd99
	s_argv = argv;
  408678:	f9071414 	str	x20, [x0, #3624]
	s_argc = argc;
  40867c:	f0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  408680:	91368b5a 	add	x26, x26, #0xda2
	s_argc = argc;
  408684:	b90d2015 	str	w21, [x0, #3360]
	cmd_args_set_defaults(args_struct);
  408688:	f9471300 	ldr	x0, [x24, #3616]
  40868c:	97fffe8c 	bl	4080bc <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
  408690:	2a1303f6 	mov	w22, w19
  408694:	6b1302bf 	cmp	w21, w19
  408698:	540001cd 	b.le	4086d0 <native_handle_cmd_line+0x98>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40869c:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  4086a0:	aa1903e1 	mov	x1, x25
  4086a4:	52800002 	mov	w2, #0x0                   	// #0
  4086a8:	91000677 	add	x23, x19, #0x1
  4086ac:	97fffdbb 	bl	407d98 <cmd_is_option>
  4086b0:	340001c0 	cbz	w0, 4086e8 <native_handle_cmd_line+0xb0>
			test_argc = argc - i - 1;
  4086b4:	f0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4086b8:	4b1602b6 	sub	w22, w21, w22
  4086bc:	510006d6 	sub	w22, w22, #0x1
			test_argv = &argv[i+1];
  4086c0:	8b170e97 	add	x23, x20, x23, lsl #3
			test_argc = argc - i - 1;
  4086c4:	b90d2416 	str	w22, [x0, #3364]
			test_argv = &argv[i+1];
  4086c8:	d0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  4086cc:	f9071817 	str	x23, [x0, #3632]
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
			cmd_print_switches_help(args_struct);
			print_invalid_opt_error(argv[i]);
		}
	}
}
  4086d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4086d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4086d8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4086dc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4086e0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4086e4:	d65f03c0 	ret
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
  4086e8:	f9471301 	ldr	x1, [x24, #3616]
  4086ec:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  4086f0:	97ffff5c 	bl	408460 <cmd_parse_one_arg>
  4086f4:	72001c1f 	tst	w0, #0xff
  4086f8:	540000c1 	b.ne	408710 <native_handle_cmd_line+0xd8>  // b.any
			cmd_print_switches_help(args_struct);
  4086fc:	f9471300 	ldr	x0, [x24, #3616]
  408700:	97fffea9 	bl	4081a4 <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  408704:	f8737a81 	ldr	x1, [x20, x19, lsl #3]
  408708:	aa1a03e0 	mov	x0, x26
  40870c:	97fffcc8 	bl	407a2c <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
  408710:	aa1703f3 	mov	x19, x23
  408714:	17ffffdf 	b	408690 <native_handle_cmd_line+0x58>

0000000000408718 <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
  408718:	90000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40871c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  408720:	f947dc21 	ldr	x1, [x1, #4024]
  408724:	f9000020 	str	x0, [x1]
	counter_target = NEVER;
  408728:	d0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  40872c:	f9072020 	str	x0, [x1, #3648]
	counter_value = 0;
  408730:	d0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  408734:	f907243f 	str	xzr, [x1, #3656]
	counter_running = false;
  408738:	f0000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  40873c:	393e343f 	strb	wzr, [x1, #3981]
	counter_period = NEVER;
  408740:	d0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  408744:	f9071c20 	str	x0, [x1, #3640]
}
  408748:	d65f03c0 	ret

000000000040874c <hw_counter_triggered>:

void hw_counter_triggered(void)
{
  40874c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!counter_running) {
  408750:	f0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
{
  408754:	910003fd 	mov	x29, sp
	if (!counter_running) {
  408758:	397e3400 	ldrb	w0, [x0, #3981]
{
  40875c:	f9000bf3 	str	x19, [sp, #16]
  408760:	90000133 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
	if (!counter_running) {
  408764:	350000e0 	cbnz	w0, 408780 <hw_counter_triggered+0x34>
		hw_counter_timer = NEVER;
  408768:	f947de73 	ldr	x19, [x19, #4024]
  40876c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  408770:	f9000260 	str	x0, [x19]
	counter_value = counter_value + 1;

	if (counter_value == counter_target) {
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
	}
}
  408774:	f9400bf3 	ldr	x19, [sp, #16]
  408778:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40877c:	d65f03c0 	ret
	hw_counter_timer = hwm_get_time() + counter_period;
  408780:	97fff9e7 	bl	406f1c <hwm_get_time>
  408784:	d0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  408788:	f947de73 	ldr	x19, [x19, #4024]
  40878c:	f9471c21 	ldr	x1, [x1, #3640]
  408790:	8b000021 	add	x1, x1, x0
  408794:	f9000261 	str	x1, [x19]
	counter_value = counter_value + 1;
  408798:	d0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  40879c:	f9472420 	ldr	x0, [x1, #3656]
  4087a0:	91000400 	add	x0, x0, #0x1
  4087a4:	f9072420 	str	x0, [x1, #3656]
	if (counter_value == counter_target) {
  4087a8:	d0000121 	adrp	x1, 42e000 <thingset_workq+0x8>
  4087ac:	f9472021 	ldr	x1, [x1, #3648]
  4087b0:	eb01001f 	cmp	x0, x1
  4087b4:	54fffe01 	b.ne	408774 <hw_counter_triggered+0x28>  // b.any
}
  4087b8:	f9400bf3 	ldr	x19, [sp, #16]
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  4087bc:	52800040 	mov	w0, #0x2                   	// #2
}
  4087c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  4087c4:	17fffc18 	b	407824 <hw_irq_ctrl_set_irq>

00000000004087c8 <receive_pool_free>:

/*
 * Wake every context that is waiting for a buffer
 */
static void receive_pool_free(struct net_buf *buf)
{
  4087c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4087cc:	910003fd 	mov	x29, sp
  4087d0:	f9000bf3 	str	x19, [sp, #16]
  4087d4:	aa0003f3 	mov	x19, x0
 *
 * @param buf Buffer to destroy.
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  4087d8:	39404800 	ldrb	w0, [x0, #18]
  4087dc:	940006e5 	bl	40a370 <net_buf_pool_get>

	k_lifo_put(&pool->free, buf);
  4087e0:	aa1303e1 	mov	x1, x19
  4087e4:	94001efe 	bl	4103dc <k_queue_prepend>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  4087e8:	d0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  4087ec:	f9472c13 	ldr	x19, [x0, #3672]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.alloc_list, ctx_node) {
  4087f0:	b5000093 	cbnz	x19, 408800 <receive_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  4087f4:	f9400bf3 	ldr	x19, [sp, #16]
  4087f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4087fc:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  408800:	91004260 	add	x0, x19, #0x10
  408804:	940021ef 	bl	410fc0 <k_work_submit>
	return node->next;
  408808:	f9400273 	ldr	x19, [x19]
  40880c:	17fffff9 	b	4087f0 <receive_pool_free+0x28>

0000000000408810 <free_send_ctx>:
	return ret;
}

#ifdef CONFIG_ISOTP_ENABLE_CONTEXT_BUFFERS
static inline void free_send_ctx(struct isotp_send_ctx **ctx)
{
  408810:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408814:	910003fd 	mov	x29, sp
  408818:	f9000bf3 	str	x19, [sp, #16]
  40881c:	aa0003f3 	mov	x19, x0
	if ((*ctx)->is_net_buf) {
  408820:	f9400000 	ldr	x0, [x0]
  408824:	39432801 	ldrb	w1, [x0, #202]
  408828:	362000a1 	tbz	w1, #4, 40883c <free_send_ctx+0x2c>
		net_buf_unref((*ctx)->buf);
  40882c:	f9400800 	ldr	x0, [x0, #16]
  408830:	94000706 	bl	40a448 <net_buf_unref>
		(*ctx)->buf = NULL;
  408834:	f9400260 	ldr	x0, [x19]
  408838:	f900081f 	str	xzr, [x0, #16]
	}

	if ((*ctx)->is_ctx_slab) {
  40883c:	f9400260 	ldr	x0, [x19]
  408840:	39432800 	ldrb	w0, [x0, #202]
  408844:	362800e0 	tbz	w0, #5, 408860 <free_send_ctx+0x50>
		k_mem_slab_free(&ctx_slab, (void **)ctx);
  408848:	aa1303e1 	mov	x1, x19
  40884c:	90000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
	}
}
  408850:	f9400bf3 	ldr	x19, [sp, #16]
  408854:	a8c27bfd 	ldp	x29, x30, [sp], #32
		k_mem_slab_free(&ctx_slab, (void **)ctx);
  408858:	f9473c00 	ldr	x0, [x0, #3704]
  40885c:	140019f2 	b	40f024 <k_mem_slab_free>
}
  408860:	f9400bf3 	ldr	x19, [sp, #16]
  408864:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408868:	d65f03c0 	ret

000000000040886c <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40886c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  408870:	90000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  408874:	12001c42 	and	w2, w2, #0xff
  408878:	910003fd 	mov	x29, sp
  40887c:	f9478400 	ldr	x0, [x0, #3848]
  408880:	3d8023e0 	str	q0, [sp, #128]
  408884:	3d8027e1 	str	q1, [sp, #144]
  408888:	3d802be2 	str	q2, [sp, #160]
  40888c:	3d802fe3 	str	q3, [sp, #176]
  408890:	3d8033e4 	str	q4, [sp, #192]
  408894:	3d8037e5 	str	q5, [sp, #208]
  408898:	3d803be6 	str	q6, [sp, #224]
  40889c:	3d803fe7 	str	q7, [sp, #240]
  4088a0:	f90087e7 	str	x7, [sp, #264]
  4088a4:	f9400003 	ldr	x3, [x0]
  4088a8:	f9003fe3 	str	x3, [sp, #120]
  4088ac:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(ap, fmt);
  4088b0:	910443e0 	add	x0, sp, #0x110
  4088b4:	a90383e0 	stp	x0, x0, [sp, #56]
  4088b8:	910403e0 	add	x0, sp, #0x100
  4088bc:	9100e3e3 	add	x3, sp, #0x38
  4088c0:	f90027e0 	str	x0, [sp, #72]
  4088c4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  4088c8:	b90053e0 	str	w0, [sp, #80]
  4088cc:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  4088d0:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  4088d4:	910163e0 	add	x0, sp, #0x58
  4088d8:	ad400460 	ldp	q0, q1, [x3]
  4088dc:	ad000400 	stp	q0, q1, [x0]
  4088e0:	ad400400 	ldp	q0, q1, [x0]
  4088e4:	910043e7 	add	x7, sp, #0x10
  4088e8:	52800000 	mov	w0, #0x0                   	// #0
  4088ec:	52800005 	mov	w5, #0x0                   	// #0
  4088f0:	d2800004 	mov	x4, #0x0                   	// #0
  4088f4:	d2800003 	mov	x3, #0x0                   	// #0
  4088f8:	ad0004e0 	stp	q0, q1, [x7]
  4088fc:	97fff410 	bl	40593c <z_impl_z_log_msg_runtime_vcreate>
}
  408900:	90000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  408904:	f9478400 	ldr	x0, [x0, #3848]
  408908:	f9403fe2 	ldr	x2, [sp, #120]
  40890c:	f9400001 	ldr	x1, [x0]
  408910:	eb010042 	subs	x2, x2, x1
  408914:	d2800001 	mov	x1, #0x0                   	// #0
  408918:	54000040 	b.eq	408920 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40891c:	97ffe2e5 	bl	4014b0 <__stack_chk_fail@plt>
  408920:	a8d17bfd 	ldp	x29, x30, [sp], #272
  408924:	d65f03c0 	ret

0000000000408928 <send_can_rx_cb>:
{
  408928:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40892c:	910003fd 	mov	x29, sp
  408930:	a90153f3 	stp	x19, x20, [sp, #16]
  408934:	aa0203f3 	mov	x19, x2
  408938:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (ctx->state == ISOTP_TX_WAIT_FC) {
  40893c:	39422840 	ldrb	w0, [x2, #138]
  408940:	71000c1f 	cmp	w0, #0x3
  408944:	54000c81 	b.ne	408ad4 <send_can_rx_cb+0x1ac>  // b.any
		z_abort_timeout(&ctx->timeout);
  408948:	91010055 	add	x21, x2, #0x40
  40894c:	aa0103f4 	mov	x20, x1
  408950:	aa1503e0 	mov	x0, x21
  408954:	94002cc7 	bl	413c70 <z_abort_timeout>
	if (ctx->rx_addr.use_ext_addr) {
  408958:	3942f661 	ldrb	w1, [x19, #189]
  40895c:	39402280 	ldrb	w0, [x20, #8]
  408960:	37080261 	tbnz	w1, #1, 4089ac <send_can_rx_cb+0x84>
	uint8_t *data = frame->data;
  408964:	91002296 	add	x22, x20, #0x8
	if ((*data & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_FC) {
  408968:	121c0c01 	and	w1, w0, #0xf0
  40896c:	7100c03f 	cmp	w1, #0x30
  408970:	540002a0 	b.eq	4089c4 <send_can_rx_cb+0x9c>  // b.none
		LOG_ERR("Got unexpected PDU expected FC");
  408974:	b0000066 	adrp	x6, 415000 <__func__.2+0x30c>
  408978:	913978c6 	add	x6, x6, #0xe5e
		LOG_ERR("Got unexpected PDU");
  40897c:	90000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  408980:	52800000 	mov	w0, #0x0                   	// #0
  408984:	52800005 	mov	w5, #0x0                   	// #0
  408988:	d2800004 	mov	x4, #0x0                   	// #0
  40898c:	f947c821 	ldr	x1, [x1, #3984]
  408990:	d2800003 	mov	x3, #0x0                   	// #0
  408994:	52800022 	mov	w2, #0x1                   	// #1
  408998:	97ffffb5 	bl	40886c <z_log_msg_runtime_create.constprop.0>
	ctx->state = ISOTP_TX_ERR;
  40899c:	52800100 	mov	w0, #0x8                   	// #8
  4089a0:	39022a60 	strb	w0, [x19, #138]
	ctx->error_nr = err;
  4089a4:	128000a0 	mov	w0, #0xfffffffa            	// #-6
  4089a8:	14000045 	b	408abc <send_can_rx_cb+0x194>
		if (ctx->rx_addr.ext_addr != *data++) {
  4089ac:	3942f261 	ldrb	w1, [x19, #188]
  4089b0:	6b00003f 	cmp	w1, w0
  4089b4:	54000281 	b.ne	408a04 <send_can_rx_cb+0xdc>  // b.any
  4089b8:	39402680 	ldrb	w0, [x20, #9]
  4089bc:	91002696 	add	x22, x20, #0x9
  4089c0:	17ffffea 	b	408968 <send_can_rx_cb+0x40>
	switch (*data++ & ISOTP_PCI_FS_MASK) {
  4089c4:	12000c00 	and	w0, w0, #0xf
  4089c8:	7100041f 	cmp	w0, #0x1
  4089cc:	54000260 	b.eq	408a18 <send_can_rx_cb+0xf0>  // b.none
  4089d0:	7100081f 	cmp	w0, #0x2
  4089d4:	540005a0 	b.eq	408a88 <send_can_rx_cb+0x160>  // b.none
  4089d8:	35000760 	cbnz	w0, 408ac4 <send_can_rx_cb+0x19c>
		ctx->state = ISOTP_TX_SEND_CF;
  4089dc:	52800080 	mov	w0, #0x4                   	// #4
  4089e0:	79011660 	strh	w0, [x19, #138]
		ctx->wft = 0;
  4089e4:	3903227f 	strb	wzr, [x19, #200]
	z_impl_k_sem_reset(sem);
  4089e8:	91024260 	add	x0, x19, #0x90
  4089ec:	94001f34 	bl	4106bc <z_impl_k_sem_reset>
		ctx->opts.bs = *data++;
  4089f0:	394006c0 	ldrb	w0, [x22, #1]
  4089f4:	39022260 	strb	w0, [x19, #136]
		ctx->opts.stmin = *data++;
  4089f8:	39400ac1 	ldrb	w1, [x22, #2]
  4089fc:	39022661 	strb	w1, [x19, #137]
		ctx->bs = ctx->opts.bs;
  408a00:	39032660 	strb	w0, [x19, #201]
	k_work_submit(&ctx->work);
  408a04:	91008260 	add	x0, x19, #0x20
}
  408a08:	a94153f3 	ldp	x19, x20, [sp, #16]
  408a0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408a10:	a8c37bfd 	ldp	x29, x30, [sp], #48
	k_work_submit(&ctx->work);
  408a14:	1400216b 	b	410fc0 <k_work_submit>
		z_abort_timeout(&ctx->timeout);
  408a18:	aa1503e0 	mov	x0, x21
  408a1c:	94002c95 	bl	413c70 <z_abort_timeout>
		z_add_timeout(&ctx->timeout, send_timeout_handler,
  408a20:	aa1503e0 	mov	x0, x21
  408a24:	d2800c82 	mov	x2, #0x64                  	// #100
  408a28:	90000001 	adrp	x1, 408000 <cmd_read_option_value+0x108>
  408a2c:	912b8021 	add	x1, x1, #0xae0
  408a30:	94002bfe 	bl	413a28 <z_add_timeout>
		if (ctx->wft >= CONFIG_ISOTP_WFTMAX) {
  408a34:	39432260 	ldrb	w0, [x19, #200]
  408a38:	7100241f 	cmp	w0, #0x9
  408a3c:	540001e9 	b.ls	408a78 <send_can_rx_cb+0x150>  // b.plast
			LOG_INF("Got to many wait frames");
  408a40:	90000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  408a44:	52800000 	mov	w0, #0x0                   	// #0
  408a48:	b0000066 	adrp	x6, 415000 <__func__.2+0x30c>
  408a4c:	52800005 	mov	w5, #0x0                   	// #0
  408a50:	f947c821 	ldr	x1, [x1, #3984]
  408a54:	9139f4c6 	add	x6, x6, #0xe7d
  408a58:	d2800004 	mov	x4, #0x0                   	// #0
  408a5c:	d2800003 	mov	x3, #0x0                   	// #0
  408a60:	52800062 	mov	w2, #0x3                   	// #3
  408a64:	97ffff82 	bl	40886c <z_log_msg_runtime_create.constprop.0>
	ctx->state = ISOTP_TX_ERR;
  408a68:	52800100 	mov	w0, #0x8                   	// #8
  408a6c:	39022a60 	strb	w0, [x19, #138]
	ctx->error_nr = err;
  408a70:	128000c0 	mov	w0, #0xfffffff9            	// #-7
  408a74:	b9000660 	str	w0, [x19, #4]
		ctx->wft++;
  408a78:	39432260 	ldrb	w0, [x19, #200]
  408a7c:	11000400 	add	w0, w0, #0x1
  408a80:	39032260 	strb	w0, [x19, #200]
		break;
  408a84:	17ffffe0 	b	408a04 <send_can_rx_cb+0xdc>
		LOG_ERR("Got overflow FC frame");
  408a88:	90000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  408a8c:	52800000 	mov	w0, #0x0                   	// #0
  408a90:	b0000066 	adrp	x6, 415000 <__func__.2+0x30c>
  408a94:	52800005 	mov	w5, #0x0                   	// #0
  408a98:	f947c821 	ldr	x1, [x1, #3984]
  408a9c:	913a54c6 	add	x6, x6, #0xe95
  408aa0:	d2800004 	mov	x4, #0x0                   	// #0
  408aa4:	d2800003 	mov	x3, #0x0                   	// #0
  408aa8:	52800022 	mov	w2, #0x1                   	// #1
  408aac:	97ffff70 	bl	40886c <z_log_msg_runtime_create.constprop.0>
	ctx->state = ISOTP_TX_ERR;
  408ab0:	52800100 	mov	w0, #0x8                   	// #8
  408ab4:	39022a60 	strb	w0, [x19, #138]
	ctx->error_nr = err;
  408ab8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  408abc:	b9000660 	str	w0, [x19, #4]
}
  408ac0:	17ffffd1 	b	408a04 <send_can_rx_cb+0xdc>
	ctx->state = ISOTP_TX_ERR;
  408ac4:	52800100 	mov	w0, #0x8                   	// #8
  408ac8:	39022a60 	strb	w0, [x19, #138]
	ctx->error_nr = err;
  408acc:	12800080 	mov	w0, #0xfffffffb            	// #-5
  408ad0:	17fffffb 	b	408abc <send_can_rx_cb+0x194>
		LOG_ERR("Got unexpected PDU");
  408ad4:	b0000066 	adrp	x6, 415000 <__func__.2+0x30c>
  408ad8:	913aacc6 	add	x6, x6, #0xeab
  408adc:	17ffffa8 	b	40897c <send_can_rx_cb+0x54>

0000000000408ae0 <send_timeout_handler>:
{
  408ae0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408ae4:	910003fd 	mov	x29, sp
  408ae8:	f9000bf3 	str	x19, [sp, #16]
  408aec:	aa0003f3 	mov	x19, x0
	if (ctx->state != ISOTP_TX_SEND_CF) {
  408af0:	39412801 	ldrb	w1, [x0, #74]
  408af4:	7100103f 	cmp	w1, #0x4
  408af8:	540001e0 	b.eq	408b34 <send_timeout_handler+0x54>  // b.none
	ctx->state = ISOTP_TX_ERR;
  408afc:	52800101 	mov	w1, #0x8                   	// #8
  408b00:	39012801 	strb	w1, [x0, #74]
	ctx->error_nr = err;
  408b04:	12800021 	mov	w1, #0xfffffffe            	// #-2
  408b08:	b81c4261 	stur	w1, [x19, #-60]
		LOG_ERR("Reception of next FC has timed out");
  408b0c:	90000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  408b10:	b0000066 	adrp	x6, 415000 <__func__.2+0x30c>
  408b14:	52800005 	mov	w5, #0x0                   	// #0
  408b18:	913af8c6 	add	x6, x6, #0xebe
  408b1c:	f947c821 	ldr	x1, [x1, #3984]
  408b20:	d2800004 	mov	x4, #0x0                   	// #0
  408b24:	d2800003 	mov	x3, #0x0                   	// #0
  408b28:	52800022 	mov	w2, #0x1                   	// #1
  408b2c:	52800000 	mov	w0, #0x0                   	// #0
  408b30:	97ffff4f 	bl	40886c <z_log_msg_runtime_create.constprop.0>
	k_work_submit(&ctx->work);
  408b34:	d1008260 	sub	x0, x19, #0x20
}
  408b38:	f9400bf3 	ldr	x19, [sp, #16]
  408b3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_work_submit(&ctx->work);
  408b40:	14002120 	b	410fc0 <k_work_submit>

0000000000408b44 <get_ctx_data_length>:
	return ctx->is_net_buf ? net_buf_frags_len(ctx->buf) : ctx->len;
  408b44:	39432801 	ldrb	w1, [x0, #202]
  408b48:	36200121 	tbz	w1, #4, 408b6c <get_ctx_data_length+0x28>
  408b4c:	f9400801 	ldr	x1, [x0, #16]
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
  408b50:	d2800000 	mov	x0, #0x0                   	// #0

	while (buf) {
  408b54:	b5000041 	cbnz	x1, 408b5c <get_ctx_data_length+0x18>
}
  408b58:	d65f03c0 	ret
		bytes += buf->len;
  408b5c:	79404022 	ldrh	w2, [x1, #32]
		buf = buf->frags;
  408b60:	f9400421 	ldr	x1, [x1, #8]
		bytes += buf->len;
  408b64:	8b020000 	add	x0, x0, x2
		buf = buf->frags;
  408b68:	17fffffb 	b	408b54 <get_ctx_data_length+0x10>
	return ctx->is_net_buf ? net_buf_frags_len(ctx->buf) : ctx->len;
  408b6c:	f9400c00 	ldr	x0, [x0, #24]
  408b70:	17fffffa 	b	408b58 <get_ctx_data_length+0x14>

0000000000408b74 <pull_data_ctx>:
	if (ctx->is_net_buf) {
  408b74:	39432804 	ldrb	w4, [x0, #202]
{
  408b78:	aa0103e2 	mov	x2, x1
		net_buf_pull_mem(ctx->buf, len);
  408b7c:	f9400803 	ldr	x3, [x0, #16]
	if (ctx->is_net_buf) {
  408b80:	36200064 	tbz	w4, #4, 408b8c <pull_data_ctx+0x18>
	return net_buf_simple_pull_mem(&buf->b, len);
  408b84:	91006060 	add	x0, x3, #0x18
  408b88:	1400066a 	b	40a530 <net_buf_simple_pull_mem>
		ctx->data += len;
  408b8c:	8b010063 	add	x3, x3, x1
		ctx->len -= len;
  408b90:	f9400c01 	ldr	x1, [x0, #24]
  408b94:	cb020021 	sub	x1, x1, x2
  408b98:	a9010403 	stp	x3, x1, [x0, #16]
}
  408b9c:	d65f03c0 	ret

0000000000408ba0 <send_can_tx_cb>:
{
  408ba0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408ba4:	910003fd 	mov	x29, sp
	ctx->tx_backlog--;
  408ba8:	39422c40 	ldrb	w0, [x2, #139]
{
  408bac:	f9000bf3 	str	x19, [sp, #16]
  408bb0:	aa0203f3 	mov	x19, x2
	ctx->tx_backlog--;
  408bb4:	51000400 	sub	w0, w0, #0x1
  408bb8:	39022c40 	strb	w0, [x2, #139]
	z_impl_k_sem_give(sem);
  408bbc:	91024040 	add	x0, x2, #0x90
  408bc0:	94001e17 	bl	41041c <z_impl_k_sem_give>
	if (ctx->state == ISOTP_TX_WAIT_BACKLOG) {
  408bc4:	39422a60 	ldrb	w0, [x19, #138]
  408bc8:	7100181f 	cmp	w0, #0x6
  408bcc:	540000a1 	b.ne	408be0 <send_can_tx_cb+0x40>  // b.any
		if (ctx->tx_backlog > 0) {
  408bd0:	39422e60 	ldrb	w0, [x19, #139]
  408bd4:	350000e0 	cbnz	w0, 408bf0 <send_can_tx_cb+0x50>
		ctx->state = ISOTP_TX_WAIT_FIN;
  408bd8:	528000e0 	mov	w0, #0x7                   	// #7
  408bdc:	39022a60 	strb	w0, [x19, #138]
	k_work_submit(&ctx->work);
  408be0:	91008260 	add	x0, x19, #0x20
}
  408be4:	f9400bf3 	ldr	x19, [sp, #16]
  408be8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_work_submit(&ctx->work);
  408bec:	140020f5 	b	410fc0 <k_work_submit>
}
  408bf0:	f9400bf3 	ldr	x19, [sp, #16]
  408bf4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  408bf8:	d65f03c0 	ret

0000000000408bfc <send_work_handler>:
		break;
	}
}

static void send_work_handler(struct k_work *item)
{
  408bfc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  408c00:	90000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  408c04:	910003fd 	mov	x29, sp
  408c08:	f9478421 	ldr	x1, [x1, #3848]
  408c0c:	a90153f3 	stp	x19, x20, [sp, #16]
	struct isotp_send_ctx *ctx = CONTAINER_OF(item, struct isotp_send_ctx,
  408c10:	d1008013 	sub	x19, x0, #0x20
{
  408c14:	a9025bf5 	stp	x21, x22, [sp, #32]
  408c18:	a90363f7 	stp	x23, x24, [sp, #48]
  408c1c:	a9046bf9 	stp	x25, x26, [sp, #64]
  408c20:	f9002bfb 	str	x27, [sp, #80]
  408c24:	f9400022 	ldr	x2, [x1]
  408c28:	f9003fe2 	str	x2, [sp, #120]
  408c2c:	d2800002 	mov	x2, #0x0                   	// #0
	switch (ctx->state) {
  408c30:	39422a61 	ldrb	w1, [x19, #138]
  408c34:	f90033f3 	str	x19, [sp, #96]
  408c38:	51000421 	sub	w1, w1, #0x1
  408c3c:	71001c3f 	cmp	w1, #0x7
  408c40:	54001688 	b.hi	408f10 <send_work_handler+0x314>  // b.pmore
  408c44:	90000062 	adrp	x2, 414000 <sys_clock_tick_get+0x78>
  408c48:	9120c042 	add	x2, x2, #0x830
  408c4c:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  408c50:	10000061 	adr	x1, 408c5c <send_work_handler+0x60>
  408c54:	8b22a822 	add	x2, x1, w2, sxth #2
  408c58:	d61f0040 	br	x2
		.id = ctx->tx_addr.ext_id,
  408c5c:	f9406261 	ldr	x1, [x19, #192]
	struct can_frame frame = {
  408c60:	52800000 	mov	w0, #0x0                   	// #0
		.flags = ctx->tx_addr.ide != 0 ? CAN_FRAME_IDE : 0,
  408c64:	39431663 	ldrb	w3, [x19, #197]
	struct can_frame frame = {
  408c68:	a906ffff 	stp	xzr, xzr, [sp, #104]
  408c6c:	33007020 	bfxil	w0, w1, #0, #29
  408c70:	b9006be0 	str	w0, [sp, #104]
  408c74:	52800100 	mov	w0, #0x8                   	// #8
  408c78:	3901b3e0 	strb	w0, [sp, #108]
		.flags = ctx->tx_addr.ide != 0 ? CAN_FRAME_IDE : 0,
  408c7c:	12000060 	and	w0, w3, #0x1
	struct can_frame frame = {
  408c80:	3901b7e0 	strb	w0, [sp, #109]
	size_t len = get_ctx_data_length(ctx);
  408c84:	aa1303e0 	mov	x0, x19
  408c88:	97ffffaf 	bl	408b44 <get_ctx_data_length>
	if (ctx->tx_addr.use_ext_addr) {
  408c8c:	360807c3 	tbz	w3, #1, 408d84 <send_work_handler+0x188>
		frame.data[index++] = ctx->tx_addr.ext_addr;
  408c90:	39431261 	ldrb	w1, [x19, #196]
  408c94:	3901c3e1 	strb	w1, [sp, #112]
  408c98:	52800021 	mov	w1, #0x1                   	// #1
		frame.data[index++] = ISOTP_PCI_TYPE_FF;
  408c9c:	11000423 	add	w3, w1, #0x1
		frame.data[index++] = (len >>   8) & 0xFF;
  408ca0:	53083c04 	ubfx	w4, w0, #8, #8
		frame.data[index++] = 0;
  408ca4:	11000834 	add	w20, w1, #0x2
		frame.data[index++] = len & 0xFF;
  408ca8:	12001c05 	and	w5, w0, #0xff
	if (len > 0xFFF) {
  408cac:	f13ffc1f 	cmp	x0, #0xfff
  408cb0:	93407c26 	sxtw	x6, w1
  408cb4:	9101c3e2 	add	x2, sp, #0x70
  408cb8:	93407c63 	sxtw	x3, w3
  408cbc:	54000689 	b.ls	408d8c <send_work_handler+0x190>  // b.plast
		frame.data[index++] = ISOTP_PCI_TYPE_FF;
  408cc0:	52800207 	mov	w7, #0x10                  	// #16
  408cc4:	38266847 	strb	w7, [x2, x6]
		frame.data[index++] = 0;
  408cc8:	3823685f 	strb	wzr, [x2, x3]
		frame.data[index++] = (len >> 3 * 8) & 0xFF;
  408ccc:	d358fc03 	lsr	x3, x0, #24
  408cd0:	3834c843 	strb	w3, [x2, w20, sxtw]
  408cd4:	11000c23 	add	w3, w1, #0x3
		frame.data[index++] = (len >> 2 * 8) & 0xFF;
  408cd8:	9ac72400 	lsr	x0, x0, x7
		frame.data[index++] = len & 0xFF;
  408cdc:	11001834 	add	w20, w1, #0x6
		frame.data[index++] = (len >> 2 * 8) & 0xFF;
  408ce0:	3823c840 	strb	w0, [x2, w3, sxtw]
  408ce4:	11001020 	add	w0, w1, #0x4
		frame.data[index++] = (len >>   8) & 0xFF;
  408ce8:	11001421 	add	w1, w1, #0x5
  408cec:	3820c844 	strb	w4, [x2, w0, sxtw]
		frame.data[index++] = len & 0xFF;
  408cf0:	3821c845 	strb	w5, [x2, w1, sxtw]
	ctx->sn = 1;
  408cf4:	39432a60 	ldrb	w0, [x19, #202]
  408cf8:	52800021 	mov	w1, #0x1                   	// #1
		return ctx->buf->data;
  408cfc:	f9400a76 	ldr	x22, [x19, #16]
	ctx->sn = 1;
  408d00:	33000c20 	bfxil	w0, w1, #0, #4
  408d04:	39032a60 	strb	w0, [x19, #202]
	if (ctx->is_net_buf) {
  408d08:	36200040 	tbz	w0, #4, 408d10 <send_work_handler+0x114>
		return ctx->buf->data;
  408d0c:	f9400ed6 	ldr	x22, [x22, #24]
	pull_data_ctx(ctx, ISOTP_CAN_DL - index);
  408d10:	52800115 	mov	w21, #0x8                   	// #8
  408d14:	4b1402b5 	sub	w21, w21, w20
  408d18:	aa1303e0 	mov	x0, x19
  408d1c:	93407eb5 	sxtw	x21, w21
  408d20:	aa1503e1 	mov	x1, x21
  408d24:	97ffff94 	bl	408b74 <pull_data_ctx>
	memcpy(&frame.data[index], data, ISOTP_CAN_DL - index);
  408d28:	9101a3e3 	add	x3, sp, #0x68
  408d2c:	11002280 	add	w0, w20, #0x8
  408d30:	aa1503e2 	mov	x2, x21
  408d34:	aa1603e1 	mov	x1, x22
  408d38:	aa0303f4 	mov	x20, x3
  408d3c:	8b20c060 	add	x0, x3, w0, sxtw
  408d40:	97ffe160 	bl	4012c0 <memcpy@plt>
	ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A),
  408d44:	f9400660 	ldr	x0, [x19, #8]
  408d48:	d2800c82 	mov	x2, #0x64                  	// #100
  408d4c:	aa1403e1 	mov	x1, x20
  408d50:	aa1303e4 	mov	x4, x19
  408d54:	90000003 	adrp	x3, 408000 <cmd_read_option_value+0x108>
  408d58:	912e8063 	add	x3, x3, #0xba0
  408d5c:	94000617 	bl	40a5b8 <z_impl_can_send>
		z_add_timeout(&ctx->timeout, send_timeout_handler,
  408d60:	f94033e0 	ldr	x0, [sp, #96]
  408d64:	90000001 	adrp	x1, 408000 <cmd_read_option_value+0x108>
  408d68:	912b8021 	add	x1, x1, #0xae0
  408d6c:	d2800c82 	mov	x2, #0x64                  	// #100
				z_add_timeout(&ctx->timeout,
  408d70:	91010000 	add	x0, x0, #0x40
  408d74:	94002b2d 	bl	413a28 <z_add_timeout>
				ctx->state = ISOTP_TX_WAIT_FC;
  408d78:	52800061 	mov	w1, #0x3                   	// #3
  408d7c:	f94033e0 	ldr	x0, [sp, #96]
  408d80:	1400004c 	b	408eb0 <send_work_handler+0x2b4>
	int index = 0;
  408d84:	52800001 	mov	w1, #0x0                   	// #0
  408d88:	17ffffc5 	b	408c9c <send_work_handler+0xa0>
		frame.data[index++] = ISOTP_PCI_TYPE_FF | (len >> 8);
  408d8c:	321c0084 	orr	w4, w4, #0x10
  408d90:	38266844 	strb	w4, [x2, x6]
		frame.data[index++] = len & 0xFF;
  408d94:	38236845 	strb	w5, [x2, x3]
  408d98:	17ffffd7 	b	408cf4 <send_work_handler+0xf8>
  408d9c:	90000016 	adrp	x22, 408000 <cmd_read_option_value+0x108>
	frame.data[index++] = ISOTP_PCI_TYPE_CF | ctx->sn;
  408da0:	9101c3f7 	add	x23, sp, #0x70
  408da4:	912e82d6 	add	x22, x22, #0xba0
	len = MIN(rem_len, ISOTP_CAN_DL - index);
  408da8:	52800118 	mov	w24, #0x8                   	// #8
		z_abort_timeout(&ctx->timeout);
  408dac:	91008000 	add	x0, x0, #0x20
  408db0:	94002bb0 	bl	413c70 <z_abort_timeout>
			ret = send_cf(ctx);
  408db4:	f94033f3 	ldr	x19, [sp, #96]
	struct can_frame frame = {
  408db8:	a906ffff 	stp	xzr, xzr, [sp, #104]
  408dbc:	b9406be0 	ldr	w0, [sp, #104]
		.id = ctx->tx_addr.ext_id,
  408dc0:	f9406261 	ldr	x1, [x19, #192]
	struct can_frame frame = {
  408dc4:	33007020 	bfxil	w0, w1, #0, #29
  408dc8:	b9006be0 	str	w0, [sp, #104]
		.flags = ctx->tx_addr.ide != 0 ? CAN_FRAME_IDE : 0,
  408dcc:	39431660 	ldrb	w0, [x19, #197]
  408dd0:	12000001 	and	w1, w0, #0x1
	struct can_frame frame = {
  408dd4:	3901b7e1 	strb	w1, [sp, #109]
	if (ctx->tx_addr.use_ext_addr) {
  408dd8:	36080700 	tbz	w0, #1, 408eb8 <send_work_handler+0x2bc>
		frame.data[index++] = ctx->tx_addr.ext_addr;
  408ddc:	39431260 	ldrb	w0, [x19, #196]
  408de0:	52800024 	mov	w4, #0x1                   	// #1
  408de4:	3901c3e0 	strb	w0, [sp, #112]
	frame.data[index++] = ISOTP_PCI_TYPE_CF | ctx->sn;
  408de8:	f9406660 	ldr	x0, [x19, #200]
  408dec:	11000494 	add	w20, w4, #0x1
	len = MIN(rem_len, ISOTP_CAN_DL - index);
  408df0:	4b140315 	sub	w21, w24, w20
	frame.data[index++] = ISOTP_PCI_TYPE_CF | ctx->sn;
  408df4:	d3504c00 	ubfx	x0, x0, #16, #4
  408df8:	321b0000 	orr	w0, w0, #0x20
  408dfc:	3824cae0 	strb	w0, [x23, w4, sxtw]
	rem_len = get_ctx_data_length(ctx);
  408e00:	aa1303e0 	mov	x0, x19
  408e04:	97ffff50 	bl	408b44 <get_ctx_data_length>
	len = MIN(rem_len, ISOTP_CAN_DL - index);
  408e08:	6b0002bf 	cmp	w21, w0
	rem_len = get_ctx_data_length(ctx);
  408e0c:	aa0003f9 	mov	x25, x0
	len = MIN(rem_len, ISOTP_CAN_DL - index);
  408e10:	1a80d2b5 	csel	w21, w21, w0, le
	if (ctx->is_net_buf) {
  408e14:	39432a60 	ldrb	w0, [x19, #202]
  408e18:	36200540 	tbz	w0, #4, 408ec0 <send_work_handler+0x2c4>
		return ctx->buf->data;
  408e1c:	f9400a60 	ldr	x0, [x19, #16]
  408e20:	f9400c01 	ldr	x1, [x0, #24]
	memcpy(&frame.data[index], data, len);
  408e24:	11002484 	add	w4, w4, #0x9
  408e28:	93407ebb 	sxtw	x27, w21
  408e2c:	9101a3fa 	add	x26, sp, #0x68
  408e30:	aa1b03e2 	mov	x2, x27
  408e34:	8b24c340 	add	x0, x26, w4, sxtw
	frame.dlc = len + index;
  408e38:	0b1402b4 	add	w20, w21, w20
  408e3c:	97ffe121 	bl	4012c0 <memcpy@plt>
  408e40:	3901b3f4 	strb	w20, [sp, #108]
	ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A),
  408e44:	f9400660 	ldr	x0, [x19, #8]
  408e48:	d2800c82 	mov	x2, #0x64                  	// #100
  408e4c:	aa1303e4 	mov	x4, x19
  408e50:	aa1603e3 	mov	x3, x22
  408e54:	aa1a03e1 	mov	x1, x26
  408e58:	940005d8 	bl	40a5b8 <z_impl_can_send>
  408e5c:	2a0003f4 	mov	w20, w0
	if (ret == 0) {
  408e60:	35000340 	cbnz	w0, 408ec8 <send_work_handler+0x2cc>
		ctx->sn++;
  408e64:	f9406660 	ldr	x0, [x19, #200]
	rem_len -= len;
  408e68:	4b150334 	sub	w20, w25, w21
		ctx->sn++;
  408e6c:	39432a61 	ldrb	w1, [x19, #202]
  408e70:	d3504c00 	ubfx	x0, x0, #16, #4
  408e74:	11000400 	add	w0, w0, #0x1
  408e78:	33000c01 	bfxil	w1, w0, #0, #4
  408e7c:	39032a61 	strb	w1, [x19, #202]
		pull_data_ctx(ctx, len);
  408e80:	aa1303e0 	mov	x0, x19
  408e84:	aa1b03e1 	mov	x1, x27
  408e88:	97ffff3b 	bl	408b74 <pull_data_ctx>
		ctx->bs--;
  408e8c:	39432660 	ldrb	w0, [x19, #201]
  408e90:	51000400 	sub	w0, w0, #0x1
  408e94:	39032660 	strb	w0, [x19, #201]
		ctx->tx_backlog++;
  408e98:	39422e60 	ldrb	w0, [x19, #139]
  408e9c:	11000400 	add	w0, w0, #0x1
  408ea0:	39022e60 	strb	w0, [x19, #139]
			if (!ret) {
  408ea4:	35000134 	cbnz	w20, 408ec8 <send_work_handler+0x2cc>
				ctx->state = ISOTP_TX_WAIT_BACKLOG;
  408ea8:	f94033e0 	ldr	x0, [sp, #96]
  408eac:	528000c1 	mov	w1, #0x6                   	// #6
		ctx->state = ISOTP_TX_SEND_CF;
  408eb0:	39022801 	strb	w1, [x0, #138]
		break;
  408eb4:	14000017 	b	408f10 <send_work_handler+0x314>
	int index = 0;
  408eb8:	52800004 	mov	w4, #0x0                   	// #0
  408ebc:	17ffffcb 	b	408de8 <send_work_handler+0x1ec>
		return ctx->data;
  408ec0:	f9400a61 	ldr	x1, [x19, #16]
  408ec4:	17ffffd8 	b	408e24 <send_work_handler+0x228>
			if (ret < 0) {
  408ec8:	36f80354 	tbz	w20, #31, 408f30 <send_work_handler+0x334>
				LOG_ERR("Failed to send CF");
  408ecc:	90000121 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  408ed0:	52800022 	mov	w2, #0x1                   	// #1
  408ed4:	52800000 	mov	w0, #0x0                   	// #0
  408ed8:	d0000066 	adrp	x6, 416000 <__func__.0+0x57a>
  408edc:	f947c821 	ldr	x1, [x1, #3984]
  408ee0:	910000c6 	add	x6, x6, #0x0
  408ee4:	52800005 	mov	w5, #0x0                   	// #0
  408ee8:	d2800004 	mov	x4, #0x0                   	// #0
  408eec:	d2800003 	mov	x3, #0x0                   	// #0
  408ef0:	97fffe5f 	bl	40886c <z_log_msg_runtime_create.constprop.0>
				send_report_error(ctx, ret == -EAGAIN ?
  408ef4:	f94033e1 	ldr	x1, [sp, #96]
  408ef8:	31002e9f 	cmn	w20, #0xb
  408efc:	12800100 	mov	w0, #0xfffffff7            	// #-9
	ctx->state = ISOTP_TX_ERR;
  408f00:	52800102 	mov	w2, #0x8                   	// #8
				send_report_error(ctx, ret == -EAGAIN ?
  408f04:	5a9f1000 	csinv	w0, w0, wzr, ne  // ne = any
	ctx->error_nr = err;
  408f08:	b9000420 	str	w0, [x1, #4]
	ctx->state = ISOTP_TX_ERR;
  408f0c:	39022822 	strb	w2, [x1, #138]
						  work);

	send_state_machine(ctx);
}
  408f10:	90000120 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  408f14:	f9478400 	ldr	x0, [x0, #3848]
  408f18:	f9403fe2 	ldr	x2, [sp, #120]
  408f1c:	f9400001 	ldr	x1, [x0]
  408f20:	eb010042 	subs	x2, x2, x1
  408f24:	d2800001 	mov	x1, #0x0                   	// #0
  408f28:	54000840 	b.eq	409030 <send_work_handler+0x434>  // b.none
  408f2c:	97ffe161 	bl	4014b0 <__stack_chk_fail@plt>
			if (ctx->opts.bs && !ctx->bs) {
  408f30:	f94033e0 	ldr	x0, [sp, #96]
  408f34:	39422001 	ldrb	w1, [x0, #136]
  408f38:	340000e1 	cbz	w1, 408f54 <send_work_handler+0x358>
  408f3c:	39432401 	ldrb	w1, [x0, #201]
  408f40:	350000a1 	cbnz	w1, 408f54 <send_work_handler+0x358>
				z_add_timeout(&ctx->timeout,
  408f44:	90000001 	adrp	x1, 408000 <cmd_read_option_value+0x108>
  408f48:	d2800c82 	mov	x2, #0x64                  	// #100
  408f4c:	912b8021 	add	x1, x1, #0xae0
  408f50:	17ffff88 	b	408d70 <send_work_handler+0x174>
			} else if (ctx->opts.stmin) {
  408f54:	39422401 	ldrb	w1, [x0, #137]
  408f58:	34000061 	cbz	w1, 408f64 <send_work_handler+0x368>
				ctx->state = ISOTP_TX_WAIT_ST;
  408f5c:	528000a1 	mov	w1, #0x5                   	// #5
  408f60:	17ffffd4 	b	408eb0 <send_work_handler+0x2b4>
	return z_impl_k_sem_take(sem, timeout);
  408f64:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  408f68:	91024000 	add	x0, x0, #0x90
  408f6c:	94001d63 	bl	4104f8 <z_impl_k_sem_take>
		} while (ret > 0);
  408f70:	17ffff91 	b	408db4 <send_work_handler+0x1b8>
		z_add_timeout(&ctx->timeout, send_timeout_handler,
  408f74:	39422662 	ldrb	w2, [x19, #137]
  408f78:	91008000 	add	x0, x0, #0x20
	    (stmin > ISOTP_STMIN_MS_MAX && stmin < ISOTP_STMIN_US_BEGIN)) {
  408f7c:	51020041 	sub	w1, w2, #0x80
	if (stmin > ISOTP_STMIN_MAX ||
  408f80:	12001c21 	and	w1, w1, #0xff
  408f84:	7101c03f 	cmp	w1, #0x70
  408f88:	52801f41 	mov	w1, #0xfa                  	// #250
  408f8c:	7a418042 	ccmp	w2, w1, #0x2, hi  // hi = pmore
  408f90:	540001a8 	b.hi	408fc4 <send_work_handler+0x3c8>  // b.pmore
	if (stmin >= ISOTP_STMIN_US_BEGIN) {
  408f94:	7103c05f 	cmp	w2, #0xf0
  408f98:	540001a8 	b.hi	408fcc <send_work_handler+0x3d0>  // b.pmore
		t += off;
  408f9c:	11002442 	add	w2, w2, #0x9
			return t / ((uint64_t)from_hz / to_hz);
  408fa0:	d2800141 	mov	x1, #0xa                   	// #10
		t += off;
  408fa4:	92401c42 	and	x2, x2, #0xff
			return t / ((uint64_t)from_hz / to_hz);
  408fa8:	9ac10842 	udiv	x2, x2, x1
		z_add_timeout(&ctx->timeout, send_timeout_handler,
  408fac:	90000001 	adrp	x1, 408000 <cmd_read_option_value+0x108>
  408fb0:	912b8021 	add	x1, x1, #0xae0
  408fb4:	94002a9d 	bl	413a28 <z_add_timeout>
		ctx->state = ISOTP_TX_SEND_CF;
  408fb8:	52800081 	mov	w1, #0x4                   	// #4
  408fbc:	f94033e0 	ldr	x0, [sp, #96]
  408fc0:	17ffffbc 	b	408eb0 <send_work_handler+0x2b4>
		return K_MSEC(ISOTP_STMIN_MS_MAX);
  408fc4:	d28001a2 	mov	x2, #0xd                   	// #13
  408fc8:	17fffff9 	b	408fac <send_work_handler+0x3b0>
		return K_USEC((stmin + 1 - ISOTP_STMIN_US_BEGIN) * 100U);
  408fcc:	d2800022 	mov	x2, #0x1                   	// #1
  408fd0:	17fffff7 	b	408fac <send_work_handler+0x3b0>
		if (ctx->filter_id >= 0) {
  408fd4:	b85e0001 	ldur	w1, [x0, #-32]
  408fd8:	37f800a1 	tbnz	w1, #31, 408fec <send_work_handler+0x3f0>
			can_remove_rx_filter(ctx->can_dev, ctx->filter_id);
  408fdc:	f9400660 	ldr	x0, [x19, #8]
	return api->remove_rx_filter(dev, filter_id);
  408fe0:	f9400802 	ldr	x2, [x0, #16]
  408fe4:	f9401c42 	ldr	x2, [x2, #56]
  408fe8:	d63f0040 	blr	x2
		z_abort_timeout(&ctx->timeout);
  408fec:	f94033e0 	ldr	x0, [sp, #96]
  408ff0:	91010000 	add	x0, x0, #0x40
  408ff4:	94002b1f 	bl	413c70 <z_abort_timeout>
		if (ctx->has_callback) {
  408ff8:	f94033e0 	ldr	x0, [sp, #96]
  408ffc:	39432801 	ldrb	w1, [x0, #202]
  409000:	36300121 	tbz	w1, #6, 409024 <send_work_handler+0x428>
			ctx->fin_cb.cb(ctx->error_nr, ctx->fin_cb.arg);
  409004:	a9460402 	ldp	x2, x1, [x0, #96]
  409008:	b9400400 	ldr	w0, [x0, #4]
  40900c:	d63f0040 	blr	x2
			free_send_ctx(&ctx);
  409010:	910183e0 	add	x0, sp, #0x60
  409014:	97fffdff 	bl	408810 <free_send_ctx>
		ctx->state = ISOTP_TX_STATE_RESET;
  409018:	f94033e0 	ldr	x0, [sp, #96]
  40901c:	3902281f 	strb	wzr, [x0, #138]
}
  409020:	17ffffbc 	b	408f10 <send_work_handler+0x314>
	z_impl_k_sem_give(sem);
  409024:	91018000 	add	x0, x0, #0x60
  409028:	94001cfd 	bl	41041c <z_impl_k_sem_give>
}
  40902c:	17fffffb 	b	409018 <send_work_handler+0x41c>
  409030:	a94153f3 	ldp	x19, x20, [sp, #16]
  409034:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409038:	a94363f7 	ldp	x23, x24, [sp, #48]
  40903c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  409040:	f9402bfb 	ldr	x27, [sp, #80]
  409044:	a8c87bfd 	ldp	x29, x30, [sp], #128
  409048:	d65f03c0 	ret

000000000040904c <receive_ff_sf_pool_free>:
{
  40904c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409050:	910003fd 	mov	x29, sp
  409054:	f9000bf3 	str	x19, [sp, #16]
  409058:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40905c:	39404800 	ldrb	w0, [x0, #18]
  409060:	940004c4 	bl	40a370 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  409064:	aa1303e1 	mov	x1, x19
  409068:	94001cdd 	bl	4103dc <k_queue_prepend>
	return list->head;
  40906c:	b0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  409070:	f9473413 	ldr	x19, [x0, #3688]
	SYS_SLIST_FOR_EACH_NODE(&global_ctx.ff_sf_alloc_list, ctx_node) {
  409074:	b5000093 	cbnz	x19, 409084 <receive_ff_sf_pool_free+0x38>
}
  409078:	f9400bf3 	ldr	x19, [sp, #16]
  40907c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  409080:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  409084:	91004260 	add	x0, x19, #0x10
  409088:	94001fce 	bl	410fc0 <k_work_submit>
	return node->next;
  40908c:	f9400273 	ldr	x19, [x19]
  409090:	17fffff9 	b	409074 <receive_ff_sf_pool_free+0x28>

0000000000409094 <send>:

static int send(struct isotp_send_ctx *ctx, const struct device *can_dev,
		const struct isotp_msg_id *tx_addr,
		const struct isotp_msg_id *rx_addr,
		isotp_tx_callback_t complete_cb, void *cb_arg)
{
  409094:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  409098:	910003fd 	mov	x29, sp
  40909c:	a9025bf5 	stp	x21, x22, [sp, #32]
  4090a0:	aa0103f6 	mov	x22, x1
  4090a4:	f0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4090a8:	a90153f3 	stp	x19, x20, [sp, #16]
  4090ac:	aa0203f4 	mov	x20, x2
  4090b0:	f9478421 	ldr	x1, [x1, #3848]
  4090b4:	a90363f7 	stp	x23, x24, [sp, #48]
  4090b8:	f90027e0 	str	x0, [sp, #72]
  4090bc:	f9400022 	ldr	x2, [x1]
  4090c0:	f9003fe2 	str	x2, [sp, #120]
  4090c4:	d2800002 	mov	x2, #0x0                   	// #0
	size_t len;
	int ret;

	__ASSERT_NO_MSG(ctx);
  4090c8:	b5000240 	cbnz	x0, 409110 <send+0x7c>
  4090cc:	90000073 	adrp	x19, 415000 <__func__.2+0x30c>
  4090d0:	913b8673 	add	x19, x19, #0xee1
  4090d4:	aa1303e2 	mov	x2, x19
  4090d8:	528090a3 	mov	w3, #0x485                 	// #1157
  4090dc:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  4090e0:	f0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4090e4:	91004821 	add	x1, x1, #0x12
  4090e8:	91353400 	add	x0, x0, #0xd4d
  4090ec:	97fff034 	bl	4051bc <assert_print>
  4090f0:	aa1303e0 	mov	x0, x19
  4090f4:	528090a1 	mov	w1, #0x485                 	// #1157
  4090f8:	97fff05b 	bl	405264 <assert_post_action>
  4090fc:	528090a2 	mov	w2, #0x485                 	// #1157
	__ASSERT_NO_MSG(can_dev);
  409100:	f0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  409104:	aa1303e1 	mov	x1, x19
  409108:	91362c00 	add	x0, x0, #0xd8b
  40910c:	97fffa48 	bl	407a2c <posix_print_error_and_exit>
  409110:	b50001f6 	cbnz	x22, 40914c <send+0xb8>
  409114:	90000073 	adrp	x19, 415000 <__func__.2+0x30c>
  409118:	913b8673 	add	x19, x19, #0xee1
  40911c:	aa1303e2 	mov	x2, x19
  409120:	528090c3 	mov	w3, #0x486                 	// #1158
  409124:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  409128:	f0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40912c:	91005821 	add	x1, x1, #0x16
  409130:	91353400 	add	x0, x0, #0xd4d
  409134:	97fff022 	bl	4051bc <assert_print>
  409138:	aa1303e0 	mov	x0, x19
  40913c:	528090c1 	mov	w1, #0x486                 	// #1158
  409140:	97fff049 	bl	405264 <assert_post_action>
  409144:	528090c2 	mov	w2, #0x486                 	// #1158
  409148:	17ffffee 	b	409100 <send+0x6c>
	__ASSERT_NO_MSG(rx_addr && tx_addr);
  40914c:	f100007f 	cmp	x3, #0x0
  409150:	aa0303f3 	mov	x19, x3
  409154:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
  409158:	540001e1 	b.ne	409194 <send+0x100>  // b.any
  40915c:	90000073 	adrp	x19, 415000 <__func__.2+0x30c>
  409160:	913b8673 	add	x19, x19, #0xee1
  409164:	aa1303e2 	mov	x2, x19
  409168:	528090e3 	mov	w3, #0x487                 	// #1159
  40916c:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  409170:	f0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  409174:	91007821 	add	x1, x1, #0x1e
  409178:	91353400 	add	x0, x0, #0xd4d
  40917c:	97fff010 	bl	4051bc <assert_print>
  409180:	aa1303e0 	mov	x0, x19
  409184:	528090e1 	mov	w1, #0x487                 	// #1159
  409188:	97fff037 	bl	405264 <assert_post_action>
  40918c:	528090e2 	mov	w2, #0x487                 	// #1159
  409190:	17ffffdc 	b	409100 <send+0x6c>
  409194:	aa0403f5 	mov	x21, x4

	if (complete_cb) {
  409198:	b40008a4 	cbz	x4, 4092ac <send+0x218>
		ctx->fin_cb.cb = complete_cb;
		ctx->fin_cb.arg = cb_arg;
		ctx->has_callback = 1;
  40919c:	39432801 	ldrb	w1, [x0, #202]
		ctx->fin_cb.arg = cb_arg;
  4091a0:	a9061404 	stp	x4, x5, [x0, #96]
		ctx->has_callback = 1;
  4091a4:	321a0021 	orr	w1, w1, #0x40
  4091a8:	39032801 	strb	w1, [x0, #202]
	} else {
		k_sem_init(&ctx->fin_sem, 0, 1);
		ctx->has_callback = 0;
	}

	k_sem_init(&ctx->tx_sem, 0, 1);
  4091ac:	f94027e0 	ldr	x0, [sp, #72]
  4091b0:	91024000 	add	x0, x0, #0x90
	return z_impl_k_sem_init(sem, initial_count, limit);
  4091b4:	52800022 	mov	w2, #0x1                   	// #1
  4091b8:	52800001 	mov	w1, #0x0                   	// #0
  4091bc:	94001c8d 	bl	4103f0 <z_impl_k_sem_init>
	ctx->can_dev = can_dev;
  4091c0:	f94027e0 	ldr	x0, [sp, #72]
  4091c4:	f9000416 	str	x22, [x0, #8]
	ctx->tx_addr = *tx_addr;
  4091c8:	f9400281 	ldr	x1, [x20]
  4091cc:	f9006001 	str	x1, [x0, #192]
	ctx->rx_addr = *rx_addr;
  4091d0:	f9400261 	ldr	x1, [x19]
	ctx->error_nr = ISOTP_N_OK;
  4091d4:	b900041f 	str	wzr, [x0, #4]
	ctx->rx_addr = *rx_addr;
  4091d8:	f9005c01 	str	x1, [x0, #184]
	ctx->wft = 0;
	k_work_init(&ctx->work, send_work_handler);
  4091dc:	f0ffffe1 	adrp	x1, 408000 <cmd_read_option_value+0x108>
	ctx->wft = 0;
  4091e0:	f94027e0 	ldr	x0, [sp, #72]
	k_work_init(&ctx->work, send_work_handler);
  4091e4:	912ff021 	add	x1, x1, #0xbfc
  4091e8:	91008000 	add	x0, x0, #0x20
	ctx->wft = 0;
  4091ec:	3902a01f 	strb	wzr, [x0, #168]
	k_work_init(&ctx->work, send_work_handler);
  4091f0:	94001ee7 	bl	410d8c <k_work_init>
	z_init_timeout(&ctx->timeout);
  4091f4:	f94027f3 	ldr	x19, [sp, #72]

	len = get_ctx_data_length(ctx);
  4091f8:	aa1303e0 	mov	x0, x19
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
  4091fc:	a9047e7f 	stp	xzr, xzr, [x19, #64]
  409200:	97fffe51 	bl	408b44 <get_ctx_data_length>
	LOG_DBG("Send %zu bytes to addr 0x%x and listen on 0x%x", len,
		ctx->tx_addr.ext_id, ctx->rx_addr.ext_id);
	if (len > ISOTP_CAN_DL - (tx_addr->use_ext_addr ? 2 : 1)) {
  409204:	39401681 	ldrb	w1, [x20, #5]
  409208:	f27f003f 	tst	x1, #0x2
  40920c:	9a9f17e1 	cset	x1, eq  // eq = none
  409210:	91001821 	add	x1, x1, #0x6
  409214:	eb01001f 	cmp	x0, x1
  409218:	540009c9 	b.ls	409350 <send+0x2bc>  // b.plast
		.id = ctx->rx_addr.ext_id,
  40921c:	f9405e60 	ldr	x0, [x19, #184]
	struct can_filter filter = {
  409220:	b90063ff 	str	wzr, [sp, #96]
	return api->add_rx_filter(dev, callback, user_data, filter);
  409224:	910163e3 	add	x3, sp, #0x58
  409228:	aa1303e2 	mov	x2, x19
  40922c:	92407000 	and	x0, x0, #0x1fffffff
  409230:	b2607000 	orr	x0, x0, #0x1fffffff00000000
  409234:	f9002fe0 	str	x0, [sp, #88]
		.flags = CAN_FILTER_DATA | ((ctx->rx_addr.ide != 0) ? CAN_FILTER_IDE : 0),
  409238:	3942f660 	ldrb	w0, [x19, #189]
  40923c:	12000000 	and	w0, w0, #0x1
  409240:	321e0000 	orr	w0, w0, #0x4
	struct can_filter filter = {
  409244:	390183e0 	strb	w0, [sp, #96]
	ctx->filter_id = can_add_rx_filter(ctx->can_dev, send_can_rx_cb, ctx,
  409248:	f9400660 	ldr	x0, [x19, #8]
  40924c:	f9400801 	ldr	x1, [x0, #16]
  409250:	f9401824 	ldr	x4, [x1, #48]
  409254:	f0ffffe1 	adrp	x1, 408000 <cmd_read_option_value+0x108>
  409258:	9124a021 	add	x1, x1, #0x928
  40925c:	d63f0080 	blr	x4
  409260:	b9000260 	str	w0, [x19]
  409264:	2a0003e7 	mov	w7, w0
	if (ctx->filter_id < 0) {
  409268:	37f80340 	tbnz	w0, #31, 4092d0 <send+0x23c>
			free_send_ctx(&ctx);
			return ret;
		}

		LOG_DBG("Starting work to send FF");
		ctx->state = ISOTP_TX_SEND_FF;
  40926c:	f94027e0 	ldr	x0, [sp, #72]
  409270:	52800041 	mov	w1, #0x2                   	// #2
		k_work_submit(&ctx->work);
  409274:	91008000 	add	x0, x0, #0x20
		ctx->state = ISOTP_TX_SEND_FF;
  409278:	3901a801 	strb	w1, [x0, #106]
		k_work_submit(&ctx->work);
  40927c:	94001f51 	bl	410fc0 <k_work_submit>
		ret = ctx->error_nr;
		free_send_ctx(&ctx);
		return ret;
	}

	return ISOTP_N_OK;
  409280:	52800013 	mov	w19, #0x0                   	// #0
	if (!complete_cb) {
  409284:	b5000575 	cbnz	x21, 409330 <send+0x29c>
		k_sem_take(&ctx->fin_sem, K_FOREVER);
  409288:	f94027e0 	ldr	x0, [sp, #72]
  40928c:	91018000 	add	x0, x0, #0x60
	return z_impl_k_sem_take(sem, timeout);
  409290:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  409294:	94001c99 	bl	4104f8 <z_impl_k_sem_take>
		ret = ctx->error_nr;
  409298:	f94027e0 	ldr	x0, [sp, #72]
  40929c:	b9400413 	ldr	w19, [x0, #4]
		free_send_ctx(&ctx);
  4092a0:	910123e0 	add	x0, sp, #0x48
  4092a4:	97fffd5b 	bl	408810 <free_send_ctx>
		return ret;
  4092a8:	14000022 	b	409330 <send+0x29c>
	return z_impl_k_sem_init(sem, initial_count, limit);
  4092ac:	52800001 	mov	w1, #0x0                   	// #0
  4092b0:	91018000 	add	x0, x0, #0x60
  4092b4:	52800022 	mov	w2, #0x1                   	// #1
  4092b8:	94001c4e 	bl	4103f0 <z_impl_k_sem_init>
		ctx->has_callback = 0;
  4092bc:	f94027e1 	ldr	x1, [sp, #72]
  4092c0:	39432820 	ldrb	w0, [x1, #202]
  4092c4:	12197800 	and	w0, w0, #0xffffffbf
  4092c8:	39032820 	strb	w0, [x1, #202]
  4092cc:	17ffffb8 	b	4091ac <send+0x118>
		LOG_ERR("Error attaching FC filter [%d]", ctx->filter_id);
  4092d0:	f0000113 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  4092d4:	52800005 	mov	w5, #0x0                   	// #0
  4092d8:	d2800004 	mov	x4, #0x0                   	// #0
  4092dc:	d2800003 	mov	x3, #0x0                   	// #0
  4092e0:	f947ca73 	ldr	x19, [x19, #3984]
  4092e4:	52800022 	mov	w2, #0x1                   	// #1
  4092e8:	52800000 	mov	w0, #0x0                   	// #0
  4092ec:	b0000066 	adrp	x6, 416000 <__func__.0+0x57a>
  4092f0:	aa1303e1 	mov	x1, x19
  4092f4:	9100c4c6 	add	x6, x6, #0x31
  4092f8:	97fffd5d 	bl	40886c <z_log_msg_runtime_create.constprop.0>
			LOG_ERR("Can't attach fc filter: %d", ret);
  4092fc:	aa1303e1 	mov	x1, x19
  409300:	b0000066 	adrp	x6, 416000 <__func__.0+0x57a>
  409304:	910140c6 	add	x6, x6, #0x50
  409308:	12800127 	mov	w7, #0xfffffff6            	// #-10
  40930c:	52800005 	mov	w5, #0x0                   	// #0
  409310:	d2800004 	mov	x4, #0x0                   	// #0
  409314:	d2800003 	mov	x3, #0x0                   	// #0
  409318:	52800022 	mov	w2, #0x1                   	// #1
		return ISOTP_NO_FREE_FILTER;
  40931c:	12800133 	mov	w19, #0xfffffff6            	// #-10
			LOG_ERR("Can't attach fc filter: %d", ret);
  409320:	52800000 	mov	w0, #0x0                   	// #0
  409324:	97fffd52 	bl	40886c <z_log_msg_runtime_create.constprop.0>
			free_send_ctx(&ctx);
  409328:	910123e0 	add	x0, sp, #0x48
  40932c:	97fffd39 	bl	408810 <free_send_ctx>
}
  409330:	f0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  409334:	f9478400 	ldr	x0, [x0, #3848]
  409338:	f9403fe2 	ldr	x2, [sp, #120]
  40933c:	f9400001 	ldr	x1, [x0]
  409340:	eb010042 	subs	x2, x2, x1
  409344:	d2800001 	mov	x1, #0x0                   	// #0
  409348:	540009c0 	b.eq	409480 <send+0x3ec>  // b.none
  40934c:	97ffe059 	bl	4014b0 <__stack_chk_fail@plt>
		ctx->filter_id = -1;
  409350:	12800000 	mov	w0, #0xffffffff            	// #-1
  409354:	b9000260 	str	w0, [x19]
	struct can_frame frame = {
  409358:	52800000 	mov	w0, #0x0                   	// #0
  40935c:	a906ffff 	stp	xzr, xzr, [sp, #104]
		ret = send_sf(ctx);
  409360:	f94027f3 	ldr	x19, [sp, #72]
		.id = ctx->tx_addr.ext_id
  409364:	f9406261 	ldr	x1, [x19, #192]
	struct can_frame frame = {
  409368:	33007020 	bfxil	w0, w1, #0, #29
  40936c:	b9006be0 	str	w0, [sp, #104]
		.flags = ctx->tx_addr.ide != 0 ? CAN_FRAME_IDE : 0,
  409370:	39431660 	ldrb	w0, [x19, #197]
  409374:	12000000 	and	w0, w0, #0x1
	struct can_frame frame = {
  409378:	3901b7e0 	strb	w0, [sp, #109]
	size_t len = get_ctx_data_length(ctx);
  40937c:	aa1303e0 	mov	x0, x19
  409380:	97fffdf1 	bl	408b44 <get_ctx_data_length>
  409384:	aa0003f4 	mov	x20, x0
	if (ctx->is_net_buf) {
  409388:	39432a60 	ldrb	w0, [x19, #202]
  40938c:	36200480 	tbz	w0, #4, 40941c <send+0x388>
		return ctx->buf->data;
  409390:	f9400a60 	ldr	x0, [x19, #16]
  409394:	f9400c18 	ldr	x24, [x0, #24]
	pull_data_ctx(ctx, len);
  409398:	aa1303e0 	mov	x0, x19
  40939c:	aa1403e1 	mov	x1, x20
  4093a0:	97fffdf5 	bl	408b74 <pull_data_ctx>
	if (ctx->tx_addr.use_ext_addr) {
  4093a4:	39431660 	ldrb	w0, [x19, #197]
  4093a8:	360803e0 	tbz	w0, #1, 409424 <send+0x390>
		frame.data[index++] = ctx->tx_addr.ext_addr;
  4093ac:	39431260 	ldrb	w0, [x19, #196]
  4093b0:	52800023 	mov	w3, #0x1                   	// #1
  4093b4:	3901c3e0 	strb	w0, [sp, #112]
	frame.data[index++] = ISOTP_PCI_TYPE_SF | len;
  4093b8:	9101c3e0 	add	x0, sp, #0x70
  4093bc:	11000477 	add	w23, w3, #0x1
  4093c0:	12001e96 	and	w22, w20, #0xff
  4093c4:	3823c816 	strb	w22, [x0, w3, sxtw]
	if (len > ISOTP_CAN_DL - index) {
  4093c8:	52800100 	mov	w0, #0x8                   	// #8
  4093cc:	4b170000 	sub	w0, w0, w23
  4093d0:	eb20c29f 	cmp	x20, w0, sxtw
  4093d4:	540002c9 	b.ls	40942c <send+0x398>  // b.plast
		LOG_ERR("SF len does not fit DL");
  4093d8:	f0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
		return -ENOSPC;
  4093dc:	12800373 	mov	w19, #0xffffffe4            	// #-28
		LOG_ERR("SF len does not fit DL");
  4093e0:	b0000066 	adrp	x6, 416000 <__func__.0+0x57a>
  4093e4:	52800005 	mov	w5, #0x0                   	// #0
  4093e8:	f947c821 	ldr	x1, [x1, #3984]
  4093ec:	9101acc6 	add	x6, x6, #0x6b
  4093f0:	d2800004 	mov	x4, #0x0                   	// #0
  4093f4:	d2800003 	mov	x3, #0x0                   	// #0
  4093f8:	52800022 	mov	w2, #0x1                   	// #1
  4093fc:	52800000 	mov	w0, #0x0                   	// #0
  409400:	97fffd1b 	bl	40886c <z_log_msg_runtime_create.constprop.0>
			free_send_ctx(&ctx);
  409404:	910123e0 	add	x0, sp, #0x48
  409408:	97fffd02 	bl	408810 <free_send_ctx>
			       ISOTP_N_TIMEOUT_A : ISOTP_N_ERROR;
  40940c:	31002e7f 	cmn	w19, #0xb
  409410:	12800113 	mov	w19, #0xfffffff7            	// #-9
  409414:	5a9f1273 	csinv	w19, w19, wzr, ne  // ne = any
  409418:	17ffffc6 	b	409330 <send+0x29c>
		return ctx->data;
  40941c:	f9400a78 	ldr	x24, [x19, #16]
  409420:	17ffffde 	b	409398 <send+0x304>
	int index = 0;
  409424:	52800003 	mov	w3, #0x0                   	// #0
  409428:	17ffffe4 	b	4093b8 <send+0x324>
	memcpy(&frame.data[index], data, len);
  40942c:	11002463 	add	w3, w3, #0x9
  409430:	9101a3e0 	add	x0, sp, #0x68
  409434:	aa1403e2 	mov	x2, x20
  409438:	aa1803e1 	mov	x1, x24
  40943c:	aa0003f4 	mov	x20, x0
  409440:	8b23c000 	add	x0, x0, w3, sxtw
  409444:	97ffdf9f 	bl	4012c0 <memcpy@plt>
	frame.dlc = len + index;
  409448:	0b1702d6 	add	w22, w22, w23
	ctx->state = ISOTP_TX_SEND_SF;
  40944c:	52800020 	mov	w0, #0x1                   	// #1
	frame.dlc = len + index;
  409450:	3901b3f6 	strb	w22, [sp, #108]
	ctx->state = ISOTP_TX_SEND_SF;
  409454:	39022a60 	strb	w0, [x19, #138]
	ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A),
  409458:	f9400660 	ldr	x0, [x19, #8]
  40945c:	f0ffffe3 	adrp	x3, 408000 <cmd_read_option_value+0x108>
  409460:	aa1303e4 	mov	x4, x19
  409464:	912e8063 	add	x3, x3, #0xba0
  409468:	aa1403e1 	mov	x1, x20
  40946c:	d2800c82 	mov	x2, #0x64                  	// #100
  409470:	94000452 	bl	40a5b8 <z_impl_can_send>
  409474:	2a0003f3 	mov	w19, w0
		if (ret) {
  409478:	34fff040 	cbz	w0, 409280 <send+0x1ec>
  40947c:	17ffffe2 	b	409404 <send+0x370>
}
  409480:	2a1303e0 	mov	w0, w19
  409484:	a94153f3 	ldp	x19, x20, [sp, #16]
  409488:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40948c:	a94363f7 	ldp	x23, x24, [sp, #48]
  409490:	a8c87bfd 	ldp	x29, x30, [sp], #128
  409494:	d65f03c0 	ret

0000000000409498 <isotp_send>:
int isotp_send(struct isotp_send_ctx *ctx, const struct device *can_dev,
	       const uint8_t *data, size_t len,
	       const struct isotp_msg_id *tx_addr,
	       const struct isotp_msg_id *rx_addr,
	       isotp_tx_callback_t complete_cb, void *cb_arg)
{
  409498:	aa0303e9 	mov	x9, x3
  40949c:	aa0203ea 	mov	x10, x2
	ctx->data = data;
	ctx->len = len;
  4094a0:	a901240a 	stp	x10, x9, [x0, #16]
{
  4094a4:	aa0403e2 	mov	x2, x4
	ctx->is_ctx_slab = 0;
	ctx->is_net_buf = 0;
  4094a8:	39432809 	ldrb	w9, [x0, #202]
{
  4094ac:	aa0503e3 	mov	x3, x5
  4094b0:	aa0603e4 	mov	x4, x6
	ctx->is_net_buf = 0;
  4094b4:	121a7529 	and	w9, w9, #0xffffffcf
  4094b8:	39032809 	strb	w9, [x0, #202]
{
  4094bc:	aa0703e5 	mov	x5, x7

	return send(ctx, can_dev, tx_addr, rx_addr, complete_cb, cb_arg);
  4094c0:	17fffef5 	b	409094 <send>

00000000004094c4 <z_impl_entropy_get_entropy.constprop.0>:

static inline int z_impl_entropy_get_entropy(const struct device *dev,
					     uint8_t *buffer,
					     uint16_t length)
{
	const struct entropy_driver_api *api =
  4094c4:	f0000103 	adrp	x3, 42c000 <__FRAME_END__+0xfbbc>
static inline int z_impl_entropy_get_entropy(const struct device *dev,
  4094c8:	aa0003e4 	mov	x4, x0
  4094cc:	12003c22 	and	w2, w1, #0xffff
	const struct entropy_driver_api *api =
  4094d0:	f9476860 	ldr	x0, [x3, #3792]
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
  4094d4:	f9400801 	ldr	x1, [x0, #16]
  4094d8:	f9400023 	ldr	x3, [x1]
  4094dc:	b5000303 	cbnz	x3, 40953c <z_impl_entropy_get_entropy.constprop.0+0x78>
static inline int z_impl_entropy_get_entropy(const struct device *dev,
  4094e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT(api->get_entropy != NULL,
  4094e4:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  4094e8:	9102f021 	add	x1, x1, #0xbc
static inline int z_impl_entropy_get_entropy(const struct device *dev,
  4094ec:	910003fd 	mov	x29, sp
  4094f0:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT(api->get_entropy != NULL,
  4094f4:	b0000073 	adrp	x19, 416000 <__func__.0+0x57a>
  4094f8:	91022273 	add	x19, x19, #0x88
  4094fc:	528009a3 	mov	w3, #0x4d                  	// #77
  409500:	aa1303e2 	mov	x2, x19
  409504:	f0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  409508:	91353400 	add	x0, x0, #0xd4d
  40950c:	97ffef2c 	bl	4051bc <assert_print>
  409510:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409514:	91037000 	add	x0, x0, #0xdc
  409518:	97ffef29 	bl	4051bc <assert_print>
  40951c:	aa1303e0 	mov	x0, x19
  409520:	528009a1 	mov	w1, #0x4d                  	// #77
  409524:	97ffef50 	bl	405264 <assert_post_action>
  409528:	f0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40952c:	aa1303e1 	mov	x1, x19
  409530:	91362c00 	add	x0, x0, #0xd8b
  409534:	528009a2 	mov	w2, #0x4d                  	// #77
  409538:	97fff93d 	bl	407a2c <posix_print_error_and_exit>
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
  40953c:	aa0403e1 	mov	x1, x4
  409540:	aa0303f0 	mov	x16, x3
  409544:	d61f0200 	br	x16

0000000000409548 <z_impl_sys_rand32_get>:
static const struct device *const entropy_dev =
	DEVICE_DT_GET(DT_CHOSEN(zephyr_entropy));

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
uint32_t z_impl_sys_rand32_get(void)
{
  409548:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40954c:	f0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  409550:	910003fd 	mov	x29, sp
  409554:	f9478400 	ldr	x0, [x0, #3848]
  409558:	a90153f3 	stp	x19, x20, [sp, #16]
  40955c:	f9400001 	ldr	x1, [x0]
  409560:	f90017e1 	str	x1, [sp, #40]
  409564:	d2800001 	mov	x1, #0x0                   	// #0
  409568:	f0000114 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  40956c:	f9476a94 	ldr	x20, [x20, #3792]
  409570:	aa1403e0 	mov	x0, x20
  409574:	94001480 	bl	40e774 <z_device_is_ready>
	uint32_t random_num;
	int ret;

	__ASSERT(device_is_ready(entropy_dev), "Entropy device %s not ready",
  409578:	72001c1f 	tst	w0, #0xff
  40957c:	540002c1 	b.ne	4095d4 <z_impl_sys_rand32_get+0x8c>  // b.any
  409580:	b0000073 	adrp	x19, 416000 <__func__.0+0x57a>
  409584:	91040a73 	add	x19, x19, #0x102
  409588:	aa1303e2 	mov	x2, x19
  40958c:	528002a3 	mov	w3, #0x15                  	// #21
  409590:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  409594:	f0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  409598:	9104ec21 	add	x1, x1, #0x13b
  40959c:	91353400 	add	x0, x0, #0xd4d
  4095a0:	97ffef07 	bl	4051bc <assert_print>
  4095a4:	f9400281 	ldr	x1, [x20]
  4095a8:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  4095ac:	91056000 	add	x0, x0, #0x158
  4095b0:	97ffef03 	bl	4051bc <assert_print>
  4095b4:	aa1303e0 	mov	x0, x19
  4095b8:	528002a1 	mov	w1, #0x15                  	// #21
  4095bc:	97ffef2a 	bl	405264 <assert_post_action>
  4095c0:	f0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4095c4:	aa1303e1 	mov	x1, x19
  4095c8:	91362c00 	add	x0, x0, #0xd8b
  4095cc:	528002a2 	mov	w2, #0x15                  	// #21
  4095d0:	97fff917 	bl	407a2c <posix_print_error_and_exit>
		union { uintptr_t x; uint16_t val; } parm2 = { .val = length };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_ENTROPY_GET_ENTROPY);
	}
#endif
	compiler_barrier();
	return z_impl_entropy_get_entropy(dev, buffer, length);
  4095d4:	52800081 	mov	w1, #0x4                   	// #4
  4095d8:	910093e0 	add	x0, sp, #0x24
  4095dc:	97ffffba 	bl	4094c4 <z_impl_entropy_get_entropy.constprop.0>
		 entropy_dev->name);

	ret = entropy_get_entropy(entropy_dev, (uint8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
  4095e0:	36f80060 	tbz	w0, #31, 4095ec <z_impl_sys_rand32_get+0xa4>
	return sys_clock_cycle_get_32();
  4095e4:	9400067a 	bl	40afcc <sys_clock_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
  4095e8:	b90027e0 	str	w0, [sp, #36]
	}

	return random_num;
}
  4095ec:	f0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
	return random_num;
  4095f0:	b94027e0 	ldr	w0, [sp, #36]
}
  4095f4:	f9478421 	ldr	x1, [x1, #3848]
  4095f8:	f94017e3 	ldr	x3, [sp, #40]
  4095fc:	f9400022 	ldr	x2, [x1]
  409600:	eb020063 	subs	x3, x3, x2
  409604:	d2800002 	mov	x2, #0x0                   	// #0
  409608:	54000040 	b.eq	409610 <z_impl_sys_rand32_get+0xc8>  // b.none
  40960c:	97ffdfa9 	bl	4014b0 <__stack_chk_fail@plt>
  409610:	a94153f3 	ldp	x19, x20, [sp, #16]
  409614:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409618:	d65f03c0 	ret

000000000040961c <get_friendly_phase_name>:
 * @param phase an enum ztest_phase value describing the desired test phase
 * @returns a string name for `phase`
 */
static inline const char *get_friendly_phase_name(enum ztest_phase phase)
{
	switch (phase) {
  40961c:	7100141f 	cmp	w0, #0x5
  409620:	540002c8 	b.hi	409678 <get_friendly_phase_name+0x5c>  // b.pmore
  409624:	f0000041 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  409628:	91210021 	add	x1, x1, #0x840
  40962c:	38604821 	ldrb	w1, [x1, w0, uxtw]
  409630:	10000060 	adr	x0, 40963c <get_friendly_phase_name+0x20>
  409634:	8b218801 	add	x1, x0, w1, sxtb #2
  409638:	d61f0020 	br	x1
  40963c:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409640:	9105f000 	add	x0, x0, #0x17c
	case TEST_PHASE_FRAMEWORK:
		return "framework";
	default:
		return "(unknown)";
	}
}
  409644:	d65f03c0 	ret
		return "test";
  409648:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  40964c:	910e6c00 	add	x0, x0, #0x39b
  409650:	17fffffd 	b	409644 <get_friendly_phase_name+0x28>
		return "after";
  409654:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409658:	91060c00 	add	x0, x0, #0x183
  40965c:	17fffffa 	b	409644 <get_friendly_phase_name+0x28>
		return "teardown";
  409660:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409664:	91062400 	add	x0, x0, #0x189
  409668:	17fffff7 	b	409644 <get_friendly_phase_name+0x28>
		return "framework";
  40966c:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409670:	91064800 	add	x0, x0, #0x192
  409674:	17fffff4 	b	409644 <get_friendly_phase_name+0x28>
		return "(unknown)";
  409678:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  40967c:	91067000 	add	x0, x0, #0x19c
  409680:	17fffff1 	b	409644 <get_friendly_phase_name+0x28>
		return "setup";
  409684:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409688:	9105d800 	add	x0, x0, #0x176
  40968c:	17ffffee 	b	409644 <get_friendly_phase_name+0x28>

0000000000409690 <ztest_find_test_suite>:
}

#endif /* !KERNEL */

static struct ztest_suite_node *ztest_find_test_suite(const char *name)
{
  409690:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409694:	910003fd 	mov	x29, sp
  409698:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_suite_node *node;

	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40969c:	f0000113 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  4096a0:	f0000114 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  4096a4:	f9472a73 	ldr	x19, [x19, #3664]
{
  4096a8:	f90013f5 	str	x21, [sp, #32]
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  4096ac:	f9474a94 	ldr	x20, [x20, #3728]
{
  4096b0:	aa0003f5 	mov	x21, x0
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  4096b4:	eb14027f 	cmp	x19, x20
  4096b8:	540000e3 	b.cc	4096d4 <ztest_find_test_suite+0x44>  // b.lo, b.ul, b.last
		if (strcmp(name, node->name) == 0) {
			return node;
		}
	}

	return NULL;
  4096bc:	d2800013 	mov	x19, #0x0                   	// #0
}
  4096c0:	aa1303e0 	mov	x0, x19
  4096c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4096c8:	f94013f5 	ldr	x21, [sp, #32]
  4096cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4096d0:	d65f03c0 	ret
		if (strcmp(name, node->name) == 0) {
  4096d4:	f9400261 	ldr	x1, [x19]
  4096d8:	aa1503e0 	mov	x0, x21
  4096dc:	97ffdf91 	bl	401520 <strcmp@plt>
  4096e0:	34ffff00 	cbz	w0, 4096c0 <ztest_find_test_suite+0x30>
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  4096e4:	9100e273 	add	x19, x19, #0x38
  4096e8:	17fffff3 	b	4096b4 <ztest_find_test_suite+0x24>

00000000004096ec <test_cb>:
{
  4096ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4096f0:	910003fd 	mov	x29, sp
  4096f4:	a90153f3 	stp	x19, x20, [sp, #16]
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  4096f8:	f0000113 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
{
  4096fc:	aa0203f4 	mov	x20, x2
  409700:	a90363f7 	stp	x23, x24, [sp, #48]
	     rule < _ztest_test_rule_list_end; ++rule) {
  409704:	f0000117 	adrp	x23, 42c000 <__FRAME_END__+0xfbbc>
	test_result = ZTEST_RESULT_PENDING;
  409708:	d0000138 	adrp	x24, 42f000 <can_loopback_dev_data_0+0xc0>
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40970c:	f9478a73 	ldr	x19, [x19, #3856]
{
  409710:	a9025bf5 	stp	x21, x22, [sp, #32]
  409714:	aa0003f6 	mov	x22, x0
	     rule < _ztest_test_rule_list_end; ++rule) {
  409718:	f947e2f7 	ldr	x23, [x23, #4032]
{
  40971c:	aa0103f5 	mov	x21, x1
	test_result = ZTEST_RESULT_PENDING;
  409720:	b90d371f 	str	wzr, [x24, #3380]
	     rule < _ztest_test_rule_list_end; ++rule) {
  409724:	eb17027f 	cmp	x19, x23
  409728:	54000263 	b.cc	409774 <test_cb+0x88>  // b.lo, b.ul, b.last
	if (suite->before) {
  40972c:	f9400ac1 	ldr	x1, [x22, #16]
  409730:	b4000061 	cbz	x1, 40973c <test_cb+0x50>
		suite->before(/*data=*/c);
  409734:	aa1403e0 	mov	x0, x20
  409738:	d63f0020 	blr	x1
	phase = TEST_PHASE_TEST;
  40973c:	f0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  409740:	52800042 	mov	w2, #0x2                   	// #2
  409744:	f9400aa1 	ldr	x1, [x21, #16]
  409748:	f947d800 	ldr	x0, [x0, #4016]
  40974c:	b9000002 	str	w2, [x0]
	test->test(data);
  409750:	aa1403e0 	mov	x0, x20
  409754:	d63f0020 	blr	x1
	test_result = ZTEST_RESULT_PASS;
  409758:	52800020 	mov	w0, #0x1                   	// #1
  40975c:	b90d3700 	str	w0, [x24, #3380]
}
  409760:	a94153f3 	ldp	x19, x20, [sp, #16]
  409764:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409768:	a94363f7 	ldp	x23, x24, [sp, #48]
  40976c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  409770:	d65f03c0 	ret
		if (is_before && rule->before_each) {
  409774:	f9400262 	ldr	x2, [x19]
  409778:	b4000082 	cbz	x2, 409788 <test_cb+0x9c>
			rule->before_each(test, data);
  40977c:	aa1403e1 	mov	x1, x20
  409780:	aa1503e0 	mov	x0, x21
  409784:	d63f0040 	blr	x2
	     rule < _ztest_test_rule_list_end; ++rule) {
  409788:	91004273 	add	x19, x19, #0x10
  40978c:	17ffffe6 	b	409724 <test_cb+0x38>

0000000000409790 <test_finalize>:
{
  409790:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409794:	910003fd 	mov	x29, sp
	z_impl_k_thread_abort(thread);
  409798:	b0000120 	adrp	x0, 42e000 <thingset_workq+0x8>
  40979c:	9139e000 	add	x0, x0, #0xe78
  4097a0:	97fff43a 	bl	406888 <z_impl_k_thread_abort>
	return z_impl_z_current_get();
  4097a4:	9400266e 	bl	41315c <z_impl_z_current_get>
}
  4097a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	z_impl_k_thread_abort(thread);
  4097ac:	17fff437 	b	406888 <z_impl_k_thread_abort>

00000000004097b0 <ztest_test_fail>:
	switch (phase) {
  4097b0:	f0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4097b4:	f947d800 	ldr	x0, [x0, #4016]
  4097b8:	b9400000 	ldr	w0, [x0]
  4097bc:	34000200 	cbz	w0, 4097fc <ztest_test_fail+0x4c>
  4097c0:	51000401 	sub	w1, w0, #0x1
  4097c4:	7100043f 	cmp	w1, #0x1
  4097c8:	54000229 	b.ls	40980c <ztest_test_fail+0x5c>  // b.plast
{
  4097cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4097d0:	910003fd 	mov	x29, sp
		PRINT(" ERROR: cannot fail in test phase '%s()', bailing\n",
  4097d4:	97ffff92 	bl	40961c <get_friendly_phase_name>
  4097d8:	aa0003e1 	mov	x1, x0
  4097dc:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  4097e0:	91069800 	add	x0, x0, #0x1a6
  4097e4:	97ffe93a 	bl	403ccc <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  4097e8:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4097ec:	52800041 	mov	w1, #0x2                   	// #2
}
  4097f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  4097f4:	b90d3801 	str	w1, [x0, #3384]
}
  4097f8:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SUITE_FAIL;
  4097fc:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  409800:	528000a1 	mov	w1, #0x5                   	// #5
  409804:	b90d3401 	str	w1, [x0, #3380]
		break;
  409808:	d65f03c0 	ret
		test_result = ZTEST_RESULT_FAIL;
  40980c:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  409810:	52800041 	mov	w1, #0x2                   	// #2
  409814:	b90d3401 	str	w1, [x0, #3380]
		test_finalize();
  409818:	17ffffde 	b	409790 <test_finalize>

000000000040981c <z_ztest_get_next_test>:

struct ztest_unit_test *z_ztest_get_next_test(const char *suite, struct ztest_unit_test *prev)
{
  40981c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  409820:	f100003f 	cmp	x1, #0x0
{
  409824:	910003fd 	mov	x29, sp
  409828:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40982c:	f0000113 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>

	for (; test < _ztest_unit_test_list_end; ++test) {
  409830:	f0000114 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  409834:	f946fe73 	ldr	x19, [x19, #3576]
{
  409838:	f90013f5 	str	x21, [sp, #32]
	for (; test < _ztest_unit_test_list_end; ++test) {
  40983c:	f9475294 	ldr	x20, [x20, #3744]
{
  409840:	aa0003f5 	mov	x21, x0
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  409844:	9100a020 	add	x0, x1, #0x28
  409848:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	for (; test < _ztest_unit_test_list_end; ++test) {
  40984c:	eb14027f 	cmp	x19, x20
  409850:	540000e3 	b.cc	40986c <z_ztest_get_next_test+0x50>  // b.lo, b.ul, b.last
		if (strcmp(suite, test->test_suite_name) == 0) {
			return test;
		}
	}
	return NULL;
  409854:	d2800013 	mov	x19, #0x0                   	// #0
}
  409858:	aa1303e0 	mov	x0, x19
  40985c:	a94153f3 	ldp	x19, x20, [sp, #16]
  409860:	f94013f5 	ldr	x21, [sp, #32]
  409864:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409868:	d65f03c0 	ret
		if (strcmp(suite, test->test_suite_name) == 0) {
  40986c:	f9400261 	ldr	x1, [x19]
  409870:	aa1503e0 	mov	x0, x21
  409874:	97ffdf2b 	bl	401520 <strcmp@plt>
  409878:	34ffff00 	cbz	w0, 409858 <z_ztest_get_next_test+0x3c>
	for (; test < _ztest_unit_test_list_end; ++test) {
  40987c:	9100a273 	add	x19, x19, #0x28
  409880:	17fffff3 	b	40984c <z_ztest_get_next_test+0x30>

0000000000409884 <z_ztest_run_test_suite_ptr>:
	}
}
#endif /* CONFIG_ZTEST_SHUFFLE */

static int z_ztest_run_test_suite_ptr(struct ztest_suite_node *suite)
{
  409884:	d10203ff 	sub	sp, sp, #0x80
  409888:	a9017bfd 	stp	x29, x30, [sp, #16]
  40988c:	910043fd 	add	x29, sp, #0x10
  409890:	a90253f3 	stp	x19, x20, [sp, #32]
  409894:	a9035bf5 	stp	x21, x22, [sp, #48]
  409898:	a90463f7 	stp	x23, x24, [sp, #64]
  40989c:	a9056bf9 	stp	x25, x26, [sp, #80]
  4098a0:	a90673fb 	stp	x27, x28, [sp, #96]

	if (test_status < 0) {
		return test_status;
	}

	if (suite == NULL) {
  4098a4:	b50001c0 	cbnz	x0, 4098dc <z_ztest_run_test_suite_ptr+0x58>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  4098a8:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  4098ac:	52800041 	mov	w1, #0x2                   	// #2
		return -1;
  4098b0:	12800016 	mov	w22, #0xffffffff            	// #-1
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  4098b4:	b90d3801 	str	w1, [x0, #3384]
	if (suite->teardown != NULL) {
		suite->teardown(data);
	}

	return fail;
}
  4098b8:	2a1603e0 	mov	w0, w22
  4098bc:	a9417bfd 	ldp	x29, x30, [sp, #16]
  4098c0:	a94253f3 	ldp	x19, x20, [sp, #32]
  4098c4:	a9435bf5 	ldp	x21, x22, [sp, #48]
  4098c8:	a94463f7 	ldp	x23, x24, [sp, #64]
  4098cc:	a9456bf9 	ldp	x25, x26, [sp, #80]
  4098d0:	a94673fb 	ldp	x27, x28, [sp, #96]
  4098d4:	910203ff 	add	sp, sp, #0x80
  4098d8:	d65f03c0 	ret
  4098dc:	aa0003f4 	mov	x20, x0
	TC_SUITE_START(suite->name);
  4098e0:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  4098e4:	9107a000 	add	x0, x0, #0x1e8
	phase = TEST_PHASE_SETUP;
  4098e8:	f0000115 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
	test_result = ZTEST_RESULT_PENDING;
  4098ec:	d0000138 	adrp	x24, 42f000 <can_loopback_dev_data_0+0xc0>
	TC_SUITE_START(suite->name);
  4098f0:	f9400281 	ldr	x1, [x20]
  4098f4:	97ffe8f6 	bl	403ccc <printk>
  4098f8:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  4098fc:	9107f800 	add	x0, x0, #0x1fe
  409900:	97ffe8f3 	bl	403ccc <printk>
	test_result = ZTEST_RESULT_PENDING;
  409904:	b90d371f 	str	wzr, [x24, #3380]
	current_test_failed_assumption = false;
  409908:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  40990c:	393e381f 	strb	wzr, [x0, #3982]
	phase = TEST_PHASE_SETUP;
  409910:	f947daa0 	ldr	x0, [x21, #4016]
  409914:	b900001f 	str	wzr, [x0]
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
  409918:	f9400680 	ldr	x0, [x20, #8]
  40991c:	b4000340 	cbz	x0, 409984 <z_ztest_run_test_suite_ptr+0x100>
		data = suite->setup();
  409920:	d63f0000 	blr	x0
  409924:	aa0003f7 	mov	x23, x0
			if (ztest_api.should_test_run(suite->name, test->name)) {
  409928:	f0000119 	adrp	x25, 42c000 <__FRAME_END__+0xfbbc>
	tc_start_time = k_cycle_get_32();
}

static inline void get_test_duration_ms(void)
{
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40992c:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
		fail = 0;
  409930:	52800016 	mov	w22, #0x0                   	// #0
  409934:	9134c000 	add	x0, x0, #0xd30
			if (ztest_api.should_test_run(suite->name, test->name)) {
  409938:	f947ab39 	ldr	x25, [x25, #3920]
	struct ztest_unit_test *test = NULL;
  40993c:	d2800013 	mov	x19, #0x0                   	// #0
  409940:	f9003fe0 	str	x0, [sp, #120]
		while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  409944:	f9400280 	ldr	x0, [x20]
  409948:	aa1303e1 	mov	x1, x19
  40994c:	97ffffb4 	bl	40981c <z_ztest_get_next_test>
  409950:	aa0003f3 	mov	x19, x0
  409954:	b50001c0 	cbnz	x0, 40998c <z_ztest_run_test_suite_ptr+0x108>
		if (test_status == ZTEST_STATUS_OK && fail != 0) {
  409958:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  40995c:	b94d3801 	ldr	w1, [x0, #3384]
  409960:	35001881 	cbnz	w1, 409c70 <z_ztest_run_test_suite_ptr+0x3ec>
  409964:	34001896 	cbz	w22, 409c74 <z_ztest_run_test_suite_ptr+0x3f0>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  409968:	52800021 	mov	w1, #0x1                   	// #1
  40996c:	b90d3801 	str	w1, [x0, #3384]
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  409970:	f9400281 	ldr	x1, [x20]
  409974:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409978:	910a1000 	add	x0, x0, #0x284
  40997c:	97ffe8d4 	bl	403ccc <printk>
  409980:	140000c2 	b	409c88 <z_ztest_run_test_suite_ptr+0x404>
	void *data = NULL;
  409984:	d2800017 	mov	x23, #0x0                   	// #0
  409988:	17ffffe8 	b	409928 <z_ztest_run_test_suite_ptr+0xa4>
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40998c:	f9400280 	ldr	x0, [x20]
  409990:	f9400661 	ldr	x1, [x19, #8]
  409994:	f9400b22 	ldr	x2, [x25, #16]
  409998:	d63f0040 	blr	x2
  40999c:	72001c1f 	tst	w0, #0xff
  4099a0:	54001600 	b.eq	409c60 <z_ztest_run_test_suite_ptr+0x3dc>  // b.none
				test->stats->run_count++;
  4099a4:	f9401261 	ldr	x1, [x19, #32]
  4099a8:	b9400020 	ldr	w0, [x1]
  4099ac:	11000400 	add	w0, w0, #0x1
  4099b0:	b9000020 	str	w0, [x1]
	TC_START(test->name);
  4099b4:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  4099b8:	91090c00 	add	x0, x0, #0x243
  4099bc:	f9400661 	ldr	x1, [x19, #8]
  4099c0:	97ffe8c3 	bl	403ccc <printk>
	phase = TEST_PHASE_BEFORE;
  4099c4:	f947daa0 	ldr	x0, [x21, #4016]
  4099c8:	52800021 	mov	w1, #0x1                   	// #1
  4099cc:	b9000001 	str	w1, [x0]
  4099d0:	9400057f 	bl	40afcc <sys_clock_cycle_get_32>
	tc_start_time = k_cycle_get_32();
  4099d4:	d0000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  4099d8:	92800007 	mov	x7, #0xffffffffffffffff    	// #-1
  4099dc:	b90d3020 	str	w0, [x1, #3376]
		k_thread_create(&ztest_thread, ztest_thread_stack,
  4099e0:	b9401a60 	ldr	w0, [x19, #24]
  4099e4:	321d0000 	orr	w0, w0, #0x8
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  4099e8:	f0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4099ec:	b90003e0 	str	w0, [sp]
  4099f0:	f90007e7 	str	x7, [sp, #8]
  4099f4:	b000013a 	adrp	x26, 42e000 <thingset_workq+0x8>
  4099f8:	f947f421 	ldr	x1, [x1, #4072]
  4099fc:	9139e35b 	add	x27, x26, #0xe78
  409a00:	aa1703e6 	mov	x6, x23
  409a04:	aa1303e5 	mov	x5, x19
  409a08:	aa1403e4 	mov	x4, x20
  409a0c:	aa1b03e0 	mov	x0, x27
  409a10:	d2808002 	mov	x2, #0x400                 	// #1024
  409a14:	90000003 	adrp	x3, 409000 <send_work_handler+0x404>
  409a18:	911bb063 	add	x3, x3, #0x6ec
  409a1c:	94001653 	bl	40f368 <z_impl_k_thread_create>
		if (test->name != NULL) {
  409a20:	f9400661 	ldr	x1, [x19, #8]
  409a24:	b4000061 	cbz	x1, 409a30 <z_ztest_run_test_suite_ptr+0x1ac>
	return z_impl_k_thread_name_set(thread, str);
  409a28:	aa1b03e0 	mov	x0, x27
  409a2c:	940015da 	bl	40f194 <z_impl_k_thread_name_set>
		if (test_result != ZTEST_RESULT_SUITE_SKIP &&
  409a30:	b94d3700 	ldr	w0, [x24, #3380]
  409a34:	51001000 	sub	w0, w0, #0x4
  409a38:	7100041f 	cmp	w0, #0x1
  409a3c:	540000e9 	b.ls	409a58 <z_ztest_run_test_suite_ptr+0x1d4>  // b.plast
	z_impl_k_thread_start(thread);
  409a40:	9139e35b 	add	x27, x26, #0xe78
  409a44:	aa1b03e0 	mov	x0, x27
  409a48:	940015e6 	bl	40f1e0 <z_impl_k_thread_start>
	return z_impl_k_thread_join(thread, timeout);
  409a4c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  409a50:	aa1b03e0 	mov	x0, x27
  409a54:	9400267c 	bl	413444 <z_impl_k_thread_join>
	phase = TEST_PHASE_AFTER;
  409a58:	f947daa0 	ldr	x0, [x21, #4016]
  409a5c:	52800061 	mov	w1, #0x3                   	// #3
  409a60:	b9000001 	str	w1, [x0]
	if (suite->after != NULL) {
  409a64:	f9400e81 	ldr	x1, [x20, #24]
  409a68:	b4000061 	cbz	x1, 409a74 <z_ztest_run_test_suite_ptr+0x1f0>
		suite->after(data);
  409a6c:	aa1703e0 	mov	x0, x23
  409a70:	d63f0020 	blr	x1
	void *data = NULL;
  409a74:	f0000102 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
	     rule < _ztest_test_rule_list_end; ++rule) {
  409a78:	f0000103 	adrp	x3, 42c000 <__FRAME_END__+0xfbbc>
	void *data = NULL;
  409a7c:	f947885c 	ldr	x28, [x2, #3856]
	     rule < _ztest_test_rule_list_end; ++rule) {
  409a80:	f947e07b 	ldr	x27, [x3, #4032]
  409a84:	14000007 	b	409aa0 <z_ztest_run_test_suite_ptr+0x21c>
		} else if (!is_before && rule->after_each) {
  409a88:	f9400784 	ldr	x4, [x28, #8]
  409a8c:	b4000084 	cbz	x4, 409a9c <z_ztest_run_test_suite_ptr+0x218>
			rule->after_each(test, data);
  409a90:	aa1703e1 	mov	x1, x23
  409a94:	aa1303e0 	mov	x0, x19
  409a98:	d63f0080 	blr	x4
	     rule < _ztest_test_rule_list_end; ++rule) {
  409a9c:	9100439c 	add	x28, x28, #0x10
  409aa0:	eb1b039f 	cmp	x28, x27
  409aa4:	54ffff23 	b.cc	409a88 <z_ztest_run_test_suite_ptr+0x204>  // b.lo, b.ul, b.last
  409aa8:	94000549 	bl	40afcc <sys_clock_cycle_get_32>
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  409aac:	f9403fe1 	ldr	x1, [sp, #120]
  409ab0:	b9400022 	ldr	w2, [x1]
  409ab4:	4b020001 	sub	w1, w0, w2
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_cyc_to_ms_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
  409ab8:	4b020000 	sub	w0, w0, w2
		t += off;
  409abc:	910f9c00 	add	x0, x0, #0x3e7
		if (result32 && (t < BIT64(32))) {
  409ac0:	b2407fe2 	mov	x2, #0xffffffff            	// #4294967295
  409ac4:	eb02001f 	cmp	x0, x2
  409ac8:	54000528 	b.hi	409b6c <z_ztest_run_test_suite_ptr+0x2e8>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
  409acc:	110f9c21 	add	w1, w1, #0x3e7
  409ad0:	52807d00 	mov	w0, #0x3e8                 	// #1000
  409ad4:	1ac00820 	udiv	w0, w1, w0

	tc_spend_time = k_cyc_to_ms_ceil32(spend_cycle);
  409ad8:	d0000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  409adc:	b90d2c20 	str	w0, [x1, #3372]
	if (tc_spend_time > test->stats->duration_worst_ms) {
  409ae0:	f9401261 	ldr	x1, [x19, #32]
  409ae4:	b9401022 	ldr	w2, [x1, #16]
  409ae8:	6b00005f 	cmp	w2, w0
  409aec:	54000042 	b.cs	409af4 <z_ztest_run_test_suite_ptr+0x270>  // b.hs, b.nlast
		test->stats->duration_worst_ms = tc_spend_time;
  409af0:	b9001020 	str	w0, [x1, #16]
	phase = TEST_PHASE_FRAMEWORK;
  409af4:	f947daa0 	ldr	x0, [x21, #4016]
  409af8:	528000a1 	mov	w1, #0x5                   	// #5
  409afc:	b9000001 	str	w1, [x0]
	if (test_result == ZTEST_RESULT_FAIL || test_result == ZTEST_RESULT_SUITE_FAIL ||
  409b00:	b94d3700 	ldr	w0, [x24, #3380]
  409b04:	7100081f 	cmp	w0, #0x2
  409b08:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  409b0c:	d0000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  409b10:	54000060 	b.eq	409b1c <z_ztest_run_test_suite_ptr+0x298>  // b.none
  409b14:	397e3c22 	ldrb	w2, [x1, #3983]
  409b18:	34000302 	cbz	w2, 409b78 <z_ztest_run_test_suite_ptr+0x2f4>
		failed_expectation = false;
  409b1c:	393e3c3f 	strb	wzr, [x1, #3983]
		ret = TC_FAIL;
  409b20:	5280003b 	mov	w27, #0x1                   	// #1
	z_impl_k_thread_abort(thread);
  409b24:	9139e340 	add	x0, x26, #0xe78
  409b28:	97fff358 	bl	406888 <z_impl_k_thread_abort>
	for (struct ztest_expected_result_entry *expectation =
  409b2c:	f0000103 	adrp	x3, 42c000 <__FRAME_END__+0xfbbc>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  409b30:	f0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  409b34:	f940067a 	ldr	x26, [x19, #8]
	for (struct ztest_expected_result_entry *expectation =
  409b38:	f947907c 	ldr	x28, [x3, #3872]
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  409b3c:	f9479c00 	ldr	x0, [x0, #3896]
  409b40:	f9003be0 	str	x0, [sp, #112]
  409b44:	f9403be0 	ldr	x0, [sp, #112]
  409b48:	eb00039f 	cmp	x28, x0
  409b4c:	54000203 	b.cc	409b8c <z_ztest_run_test_suite_ptr+0x308>  // b.lo, b.ul, b.last
	switch (result) {
  409b50:	7100077f 	cmp	w27, #0x1
  409b54:	54000440 	b.eq	409bdc <z_ztest_run_test_suite_ptr+0x358>  // b.none
  409b58:	71000b7f 	cmp	w27, #0x2
  409b5c:	54000760 	b.eq	409c48 <z_ztest_run_test_suite_ptr+0x3c4>  // b.none
	for (struct ztest_expected_result_entry *expectation =
  409b60:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  409b64:	91076421 	add	x1, x1, #0x1d9
  409b68:	1400001f 	b	409be4 <z_ztest_run_test_suite_ptr+0x360>
			return t / ((uint64_t)from_hz / to_hz);
  409b6c:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  409b70:	9ac10800 	udiv	x0, x0, x1
  409b74:	17ffffd9 	b	409ad8 <z_ztest_run_test_suite_ptr+0x254>
	} else if (test_result == ZTEST_RESULT_SKIP || test_result == ZTEST_RESULT_SUITE_SKIP) {
  409b78:	51000c00 	sub	w0, w0, #0x3
  409b7c:	7100041f 	cmp	w0, #0x1
  409b80:	1a9f87e5 	cset	w5, ls  // ls = plast
  409b84:	531f78bb 	lsl	w27, w5, #1
  409b88:	17ffffe7 	b	409b24 <z_ztest_run_test_suite_ptr+0x2a0>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  409b8c:	f9400780 	ldr	x0, [x28, #8]
  409b90:	aa1a03e1 	mov	x1, x26
  409b94:	97ffde63 	bl	401520 <strcmp@plt>
  409b98:	35000160 	cbnz	w0, 409bc4 <z_ztest_run_test_suite_ptr+0x340>
		    strcmp(expectation->test_suite_name, test->test_suite_name) == 0) {
  409b9c:	f9400261 	ldr	x1, [x19]
  409ba0:	f9400380 	ldr	x0, [x28]
  409ba4:	97ffde5f 	bl	401520 <strcmp@plt>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  409ba8:	350000e0 	cbnz	w0, 409bc4 <z_ztest_run_test_suite_ptr+0x340>
			expected_result = expectation->expected_result;
  409bac:	b9401380 	ldr	w0, [x28, #16]
	if (expected_result == ZTEST_EXPECTED_RESULT_FAIL) {
  409bb0:	340000e0 	cbz	w0, 409bcc <z_ztest_run_test_suite_ptr+0x348>
	if (expected_result == ZTEST_EXPECTED_RESULT_SKIP) {
  409bb4:	7100041f 	cmp	w0, #0x1
  409bb8:	54fffcc1 	b.ne	409b50 <z_ztest_run_test_suite_ptr+0x2cc>  // b.any
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  409bbc:	71000b7f 	cmp	w27, #0x2
  409bc0:	14000004 	b	409bd0 <z_ztest_run_test_suite_ptr+0x34c>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  409bc4:	9100639c 	add	x28, x28, #0x18
  409bc8:	17ffffdf 	b	409b44 <z_ztest_run_test_suite_ptr+0x2c0>
		return (ret == TC_FAIL) ? TC_PASS : TC_FAIL;
  409bcc:	7100077f 	cmp	w27, #0x1
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  409bd0:	1a9f07fb 	cset	w27, ne  // ne = any
  409bd4:	7100077f 	cmp	w27, #0x1
  409bd8:	54fffc41 	b.ne	409b60 <z_ztest_run_test_suite_ptr+0x2dc>  // b.any
		return TC_FAIL_STR;
  409bdc:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  409be0:	91077821 	add	x1, x1, #0x1de
	Z_TC_END_RESULT(ret, test->name);
  409be4:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  409be8:	aa1a03e2 	mov	x2, x26
  409bec:	b94d2c04 	ldr	w4, [x0, #3372]
  409bf0:	52807d00 	mov	w0, #0x3e8                 	// #1000
  409bf4:	1ac00883 	udiv	w3, w4, w0
  409bf8:	1b009064 	msub	w4, w3, w0, w4
  409bfc:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409c00:	91093c00 	add	x0, x0, #0x24f
  409c04:	97ffe832 	bl	403ccc <printk>
  409c08:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409c0c:	9107f800 	add	x0, x0, #0x1fe
  409c10:	97ffe82f 	bl	403ccc <printk>
	if (ret == TC_SKIP && current_test_failed_assumption) {
  409c14:	71000b7f 	cmp	w27, #0x2
  409c18:	f9401260 	ldr	x0, [x19, #32]
  409c1c:	54000461 	b.ne	409ca8 <z_ztest_run_test_suite_ptr+0x424>  // b.any
  409c20:	d0000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  409c24:	397e3821 	ldrb	w1, [x1, #3982]
  409c28:	34000081 	cbz	w1, 409c38 <z_ztest_run_test_suite_ptr+0x3b4>
		test_status = 1;
  409c2c:	d0000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  409c30:	52800022 	mov	w2, #0x1                   	// #1
  409c34:	b90d3822 	str	w2, [x1, #3384]
					test->stats->skip_count++;
  409c38:	b9400401 	ldr	w1, [x0, #4]
  409c3c:	11000421 	add	w1, w1, #0x1
  409c40:	b9000401 	str	w1, [x0, #4]
				if (tc_result == TC_FAIL) {
  409c44:	14000007 	b	409c60 <z_ztest_run_test_suite_ptr+0x3dc>
		return TC_SKIP_STR;
  409c48:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  409c4c:	91078c21 	add	x1, x1, #0x1e3
  409c50:	17ffffe5 	b	409be4 <z_ztest_run_test_suite_ptr+0x360>
					test->stats->pass_count++;
  409c54:	b9400c01 	ldr	w1, [x0, #12]
  409c58:	11000421 	add	w1, w1, #0x1
  409c5c:	b9000c01 	str	w1, [x0, #12]
			if ((fail && FAIL_FAST) || test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  409c60:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  409c64:	b94d3800 	ldr	w0, [x0, #3384]
  409c68:	7100081f 	cmp	w0, #0x2
  409c6c:	54ffe6c1 	b.ne	409944 <z_ztest_run_test_suite_ptr+0xc0>  // b.any
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  409c70:	35ffe816 	cbnz	w22, 409970 <z_ztest_run_test_suite_ptr+0xec>
  409c74:	f9400281 	ldr	x1, [x20]
  409c78:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
  409c7c:	52800016 	mov	w22, #0x0                   	// #0
  409c80:	9109b000 	add	x0, x0, #0x26c
  409c84:	97ffe812 	bl	403ccc <printk>
	phase = TEST_PHASE_TEARDOWN;
  409c88:	f947dab5 	ldr	x21, [x21, #4016]
  409c8c:	52800080 	mov	w0, #0x4                   	// #4
	if (suite->teardown != NULL) {
  409c90:	f9401281 	ldr	x1, [x20, #32]
	phase = TEST_PHASE_TEARDOWN;
  409c94:	b90002a0 	str	w0, [x21]
	if (suite->teardown != NULL) {
  409c98:	b4ffe101 	cbz	x1, 4098b8 <z_ztest_run_test_suite_ptr+0x34>
		suite->teardown(data);
  409c9c:	aa1703e0 	mov	x0, x23
  409ca0:	d63f0020 	blr	x1
  409ca4:	17ffff05 	b	4098b8 <z_ztest_run_test_suite_ptr+0x34>
				if (tc_result == TC_PASS) {
  409ca8:	34fffd7b 	cbz	w27, 409c54 <z_ztest_run_test_suite_ptr+0x3d0>
					test->stats->fail_count++;
  409cac:	b9400801 	ldr	w1, [x0, #8]
					fail++;
  409cb0:	110006d6 	add	w22, w22, #0x1
					test->stats->fail_count++;
  409cb4:	11000421 	add	w1, w1, #0x1
  409cb8:	b9000801 	str	w1, [x0, #8]
					fail++;
  409cbc:	17ffffe9 	b	409c60 <z_ztest_run_test_suite_ptr+0x3dc>

0000000000409cc0 <z_impl_ztest_run_test_suites>:

	return count;
}

int z_impl_ztest_run_test_suites(const void *state)
{
  409cc0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  409cc4:	910003fd 	mov	x29, sp
  409cc8:	f90023f9 	str	x25, [sp, #64]
	int count = 0;

	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  409ccc:	d0000139 	adrp	x25, 42f000 <can_loopback_dev_data_0+0xc0>
{
  409cd0:	a90363f7 	stp	x23, x24, [sp, #48]
  409cd4:	aa0003f7 	mov	x23, x0
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  409cd8:	b94d3b20 	ldr	w0, [x25, #3384]
{
  409cdc:	a90153f3 	stp	x19, x20, [sp, #16]
  409ce0:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  409ce4:	7100081f 	cmp	w0, #0x2
  409ce8:	540007a0 	b.eq	409ddc <z_impl_ztest_run_test_suites+0x11c>  // b.none
		    (test_status == ZTEST_STATUS_HAS_FAILURE && FAIL_FAST)) {
			break;
		}
	}
#else
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  409cec:	f0000113 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  409cf0:	f0000116 	adrp	x22, 42c000 <__FRAME_END__+0xfbbc>
		if (ztest_api.should_suite_run(state, ptr)) {
  409cf4:	f0000118 	adrp	x24, 42c000 <__FRAME_END__+0xfbbc>
	int count = 0;
  409cf8:	52800015 	mov	w21, #0x0                   	// #0
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  409cfc:	f9472a73 	ldr	x19, [x19, #3664]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  409d00:	f9474ad6 	ldr	x22, [x22, #3728]
		if (ztest_api.should_suite_run(state, ptr)) {
  409d04:	f947ab18 	ldr	x24, [x24, #3920]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  409d08:	eb16027f 	cmp	x19, x22
  409d0c:	54000103 	b.cc	409d2c <z_impl_ztest_run_test_suites+0x6c>  // b.lo, b.ul, b.last
		}
	}
#endif

	return count;
}
  409d10:	2a1503e0 	mov	w0, w21
  409d14:	a94153f3 	ldp	x19, x20, [sp, #16]
  409d18:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409d1c:	a94363f7 	ldp	x23, x24, [sp, #48]
  409d20:	f94023f9 	ldr	x25, [sp, #64]
  409d24:	a8c57bfd 	ldp	x29, x30, [sp], #80
  409d28:	d65f03c0 	ret
		if (ztest_api.should_suite_run(state, ptr)) {
  409d2c:	f9400702 	ldr	x2, [x24, #8]
  409d30:	aa1303e1 	mov	x1, x19
  409d34:	aa1703e0 	mov	x0, x23
	struct ztest_suite_stats *stats = ptr->stats;
  409d38:	f9401a74 	ldr	x20, [x19, #48]
		if (ztest_api.should_suite_run(state, ptr)) {
  409d3c:	d63f0040 	blr	x2
  409d40:	72001c1f 	tst	w0, #0xff
  409d44:	54000420 	b.eq	409dc8 <z_impl_ztest_run_test_suites+0x108>  // b.none
	struct ztest_unit_test *test = NULL;
  409d48:	d2800001 	mov	x1, #0x0                   	// #0
  409d4c:	1400000b 	b	409d78 <z_impl_ztest_run_test_suites+0xb8>
		test->stats->run_count = 0;
  409d50:	f9401020 	ldr	x0, [x1, #32]
  409d54:	b900001f 	str	wzr, [x0]
		test->stats->skip_count = 0;
  409d58:	f9401020 	ldr	x0, [x1, #32]
  409d5c:	b900041f 	str	wzr, [x0, #4]
		test->stats->fail_count = 0;
  409d60:	f9401020 	ldr	x0, [x1, #32]
  409d64:	b900081f 	str	wzr, [x0, #8]
		test->stats->pass_count = 0;
  409d68:	f9401020 	ldr	x0, [x1, #32]
  409d6c:	b9000c1f 	str	wzr, [x0, #12]
		test->stats->duration_worst_ms = 0;
  409d70:	f9401020 	ldr	x0, [x1, #32]
  409d74:	b900101f 	str	wzr, [x0, #16]
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  409d78:	f9400260 	ldr	x0, [x19]
  409d7c:	97fffea8 	bl	40981c <z_ztest_get_next_test>
  409d80:	aa0003e1 	mov	x1, x0
  409d84:	b5fffe60 	cbnz	x0, 409d50 <z_impl_ztest_run_test_suites+0x90>
			int fail = z_ztest_run_test_suite_ptr(ptr);
  409d88:	aa1303e0 	mov	x0, x19
  409d8c:	97fffebe 	bl	409884 <z_ztest_run_test_suite_ptr>
			stats->fail_count += (fail != 0) ? 1 : 0;
  409d90:	7100001f 	cmp	w0, #0x0
  409d94:	b9400a80 	ldr	w0, [x20, #8]
			stats->run_count++;
  409d98:	b9400281 	ldr	w1, [x20]
			stats->fail_count += (fail != 0) ? 1 : 0;
  409d9c:	1a800400 	cinc	w0, w0, ne  // ne = any
  409da0:	b9000a80 	str	w0, [x20, #8]
			stats->run_count++;
  409da4:	11000421 	add	w1, w1, #0x1
			count++;
  409da8:	52800020 	mov	w0, #0x1                   	// #1
			stats->run_count++;
  409dac:	b9000281 	str	w1, [x20]
		count += __ztest_run_test_suite(ptr, state);
  409db0:	0b0002b5 	add	w21, w21, w0
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
  409db4:	b94d3b20 	ldr	w0, [x25, #3384]
  409db8:	7100081f 	cmp	w0, #0x2
  409dbc:	54fffaa0 	b.eq	409d10 <z_impl_ztest_run_test_suites+0x50>  // b.none
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  409dc0:	9100e273 	add	x19, x19, #0x38
  409dc4:	17ffffd1 	b	409d08 <z_impl_ztest_run_test_suites+0x48>
			stats->skip_count++;
  409dc8:	b9400680 	ldr	w0, [x20, #4]
  409dcc:	11000400 	add	w0, w0, #0x1
  409dd0:	b9000680 	str	w0, [x20, #4]
	int count = 0;
  409dd4:	52800000 	mov	w0, #0x0                   	// #0
  409dd8:	17fffff6 	b	409db0 <z_impl_ztest_run_test_suites+0xf0>
		return count;
  409ddc:	52800015 	mov	w21, #0x0                   	// #0
  409de0:	17ffffcc 	b	409d10 <z_impl_ztest_run_test_suites+0x50>

0000000000409de4 <ztest_verify_all_test_suites_ran>:

void ztest_verify_all_test_suites_ran(void)
{
  409de4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  409de8:	910003fd 	mov	x29, sp
  409dec:	a90153f3 	stp	x19, x20, [sp, #16]
	bool all_tests_run = true;
	struct ztest_suite_node *suite;
	struct ztest_unit_test *test;

	if (IS_ENABLED(CONFIG_ZTEST_VERIFY_RUN_ALL)) {
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  409df0:	f0000113 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  409df4:	f0000114 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  409df8:	f9472a73 	ldr	x19, [x19, #3664]
{
  409dfc:	a9025bf5 	stp	x21, x22, [sp, #32]
		     ++suite) {
			if (suite->stats->run_count < 1) {
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  409e00:	b0000076 	adrp	x22, 416000 <__func__.0+0x57a>
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  409e04:	f9474a94 	ldr	x20, [x20, #3728]
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  409e08:	910a6ad6 	add	x22, x22, #0x29a
	bool all_tests_run = true;
  409e0c:	52800035 	mov	w21, #0x1                   	// #1
{
  409e10:	a90363f7 	stp	x23, x24, [sp, #48]
  409e14:	f90023f9 	str	x25, [sp, #64]
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  409e18:	eb14027f 	cmp	x19, x20
  409e1c:	54000383 	b.cc	409e8c <ztest_verify_all_test_suites_ran+0xa8>  // b.lo, b.ul, b.last
				all_tests_run = false;
			}
		}

		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  409e20:	f0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  409e24:	f0000113 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
			suite = ztest_find_test_suite(test->test_suite_name);
			if (suite == NULL) {
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  409e28:	b0000076 	adrp	x22, 416000 <__func__.0+0x57a>
  409e2c:	aa0003f8 	mov	x24, x0
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  409e30:	f946fe74 	ldr	x20, [x19, #3576]
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  409e34:	910afed6 	add	x22, x22, #0x2bf
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  409e38:	f9475019 	ldr	x25, [x0, #3744]
  409e3c:	eb19029f 	cmp	x20, x25
  409e40:	54000383 	b.cc	409eb0 <ztest_verify_all_test_suites_ran+0xcc>  // b.lo, b.ul, b.last
				      test->name, test->test_suite_name);
				all_tests_run = false;
			}
		}

		if (!all_tests_run) {
  409e44:	35000095 	cbnz	w21, 409e54 <ztest_verify_all_test_suites_ran+0x70>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  409e48:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  409e4c:	52800021 	mov	w1, #0x1                   	// #1
  409e50:	b90d3801 	str	w1, [x0, #3384]
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  409e54:	f946fe73 	ldr	x19, [x19, #3576]
	}

	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
		    test->stats->run_count) {
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  409e58:	b0000075 	adrp	x21, 416000 <__func__.0+0x57a>
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  409e5c:	f9475318 	ldr	x24, [x24, #3744]
			test_status = 1;
  409e60:	d0000136 	adrp	x22, 42f000 <can_loopback_dev_data_0+0xc0>
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  409e64:	910c06b5 	add	x21, x21, #0x301
			test_status = 1;
  409e68:	9134e2d6 	add	x22, x22, #0xd38
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  409e6c:	eb18027f 	cmp	x19, x24
  409e70:	54000363 	b.cc	409edc <ztest_verify_all_test_suites_ran+0xf8>  // b.lo, b.ul, b.last
		}
	}
}
  409e74:	a94153f3 	ldp	x19, x20, [sp, #16]
  409e78:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409e7c:	a94363f7 	ldp	x23, x24, [sp, #48]
  409e80:	f94023f9 	ldr	x25, [sp, #64]
  409e84:	a8c57bfd 	ldp	x29, x30, [sp], #80
  409e88:	d65f03c0 	ret
			if (suite->stats->run_count < 1) {
  409e8c:	f9401a60 	ldr	x0, [x19, #48]
  409e90:	b9400000 	ldr	w0, [x0]
  409e94:	350000a0 	cbnz	w0, 409ea8 <ztest_verify_all_test_suites_ran+0xc4>
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  409e98:	f9400261 	ldr	x1, [x19]
  409e9c:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  409ea0:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  409ea4:	97ffe78a 	bl	403ccc <printk>
		     ++suite) {
  409ea8:	9100e273 	add	x19, x19, #0x38
  409eac:	17ffffdb 	b	409e18 <ztest_verify_all_test_suites_ran+0x34>
			suite = ztest_find_test_suite(test->test_suite_name);
  409eb0:	f9400297 	ldr	x23, [x20]
  409eb4:	aa1703e0 	mov	x0, x23
  409eb8:	97fffdf6 	bl	409690 <ztest_find_test_suite>
			if (suite == NULL) {
  409ebc:	b50000c0 	cbnz	x0, 409ed4 <ztest_verify_all_test_suites_ran+0xf0>
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  409ec0:	f9400681 	ldr	x1, [x20, #8]
  409ec4:	aa1703e2 	mov	x2, x23
  409ec8:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  409ecc:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  409ed0:	97ffe77f 	bl	403ccc <printk>
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  409ed4:	9100a294 	add	x20, x20, #0x28
  409ed8:	17ffffd9 	b	409e3c <ztest_verify_all_test_suites_ran+0x58>
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
  409edc:	f9401262 	ldr	x2, [x19, #32]
  409ee0:	29410041 	ldp	w1, w0, [x2, #8]
  409ee4:	0b000021 	add	w1, w1, w0
  409ee8:	b9400440 	ldr	w0, [x2, #4]
  409eec:	0b000021 	add	w1, w1, w0
  409ef0:	b9400040 	ldr	w0, [x2]
  409ef4:	6b00003f 	cmp	w1, w0
  409ef8:	540000c0 	b.eq	409f10 <ztest_verify_all_test_suites_ran+0x12c>  // b.none
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  409efc:	a9400a61 	ldp	x1, x2, [x19]
  409f00:	aa1503e0 	mov	x0, x21
  409f04:	97ffe772 	bl	403ccc <printk>
			test_status = 1;
  409f08:	52800020 	mov	w0, #0x1                   	// #1
  409f0c:	b90002c0 	str	w0, [x22]
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  409f10:	9100a273 	add	x19, x19, #0x28
  409f14:	17ffffd6 	b	409e6c <ztest_verify_all_test_suites_ran+0x88>

0000000000409f18 <ztest_run_all>:

void ztest_run_all(const void *state) { ztest_api.run_all(state); }
  409f18:	f0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  409f1c:	f947a821 	ldr	x1, [x1, #3920]
  409f20:	f9400021 	ldr	x1, [x1]
  409f24:	aa0103f0 	mov	x16, x1
  409f28:	d61f0200 	br	x16

0000000000409f2c <test_main>:

void __weak test_main(void)
{
  409f2c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ztest_run_all(NULL);
  409f30:	d2800000 	mov	x0, #0x0                   	// #0
{
  409f34:	910003fd 	mov	x29, sp
	ztest_run_all(NULL);
  409f38:	97fffff8 	bl	409f18 <ztest_run_all>

	ztest_verify_all_test_suites_ran();
}
  409f3c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ztest_verify_all_test_suites_ran();
  409f40:	17ffffa9 	b	409de4 <ztest_verify_all_test_suites_ran>

0000000000409f44 <_posix_zephyr_main>:

	return test_status;
}
#else
int main(void)
{
  409f44:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409f48:	910003fd 	mov	x29, sp
  409f4c:	a90153f3 	stp	x19, x20, [sp, #16]
	k_mem_domain_add_partition(&k_mem_domain_default, &z_malloc_partition);
#endif
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
  409f50:	97fffff7 	bl	409f2c <test_main>
	if (test_status) {
  409f54:	d0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  409f58:	b0000074 	adrp	x20, 416000 <__func__.0+0x57a>
  409f5c:	b0000073 	adrp	x19, 416000 <__func__.0+0x57a>
  409f60:	b94d3801 	ldr	w1, [x0, #3384]
  409f64:	b0000060 	adrp	x0, 416000 <__func__.0+0x57a>
		TC_END_REPORT(TC_FAIL);
  409f68:	9107f800 	add	x0, x0, #0x1fe
	if (test_status) {
  409f6c:	34000261 	cbz	w1, 409fb8 <_posix_zephyr_main+0x74>
		TC_END_REPORT(TC_FAIL);
  409f70:	97ffe757 	bl	403ccc <printk>
  409f74:	910c5a80 	add	x0, x20, #0x316
  409f78:	97ffe755 	bl	403ccc <printk>
  409f7c:	910d1a60 	add	x0, x19, #0x346
  409f80:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  409f84:	910cfc21 	add	x1, x1, #0x33f
  409f88:	97ffe751 	bl	403ccc <printk>
		(void) arch_syscall_invoke0(K_SYSCALL_LOG_PANIC);
		return;
	}
#endif
	compiler_barrier();
	z_impl_log_panic();
  409f8c:	97ffed7d 	bl	405580 <z_impl_log_panic>
  409f90:	52800020 	mov	w0, #0x1                   	// #1
		TC_END_REPORT(TC_PASS);
  409f94:	97fff650 	bl	4078d4 <posix_exit>
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke0(K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process();
  409f98:	97ffedbf 	bl	405694 <z_impl_log_process>
		while (LOG_PROCESS()) {
  409f9c:	72001c1f 	tst	w0, #0xff
  409fa0:	54ffffc1 	b.ne	409f98 <_posix_zephyr_main+0x54>  // b.any
	z_impl_log_panic();
  409fa4:	97ffed77 	bl	405580 <z_impl_log_panic>
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
	return 0;
}
  409fa8:	52800000 	mov	w0, #0x0                   	// #0
  409fac:	a94153f3 	ldp	x19, x20, [sp, #16]
  409fb0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  409fb4:	d65f03c0 	ret
		TC_END_REPORT(TC_PASS);
  409fb8:	97ffe745 	bl	403ccc <printk>
  409fbc:	910c5a80 	add	x0, x20, #0x316
  409fc0:	97ffe743 	bl	403ccc <printk>
  409fc4:	910d1a60 	add	x0, x19, #0x346
  409fc8:	b0000061 	adrp	x1, 416000 <__func__.0+0x57a>
  409fcc:	910d7021 	add	x1, x1, #0x35c
  409fd0:	97ffe73f 	bl	403ccc <printk>
  409fd4:	97ffed6b 	bl	405580 <z_impl_log_panic>
  409fd8:	52800000 	mov	w0, #0x0                   	// #0
  409fdc:	17ffffee 	b	409f94 <_posix_zephyr_main+0x50>

0000000000409fe0 <add_test_filter_option>:
		  "\'suiteA::test1,suiteA::test2,suiteB::*\'. An * can be used "
		  "as a wildcard to run all tests within a suite." },
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(test_filter_s);
  409fe0:	90000120 	adrp	x0, 42d000 <__dso_handle>
  409fe4:	91214000 	add	x0, x0, #0x850
  409fe8:	17fff95e 	b	408560 <native_add_command_line_opts>

0000000000409fec <z_ztest_testargs_contains>:
 * @param test_name
 * @return true
 * @return false
 */
static bool z_ztest_testargs_contains(const char *suite_name, const char *test_name)
{
  409fec:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  409ff0:	910003fd 	mov	x29, sp
  409ff4:	a90363f7 	stp	x23, x24, [sp, #48]
  409ff8:	aa0003f7 	mov	x23, x0
  409ffc:	f0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40a000:	a90153f3 	stp	x19, x20, [sp, #16]
  40a004:	aa0103f4 	mov	x20, x1
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
		test_arg = strtok_r(NULL, ":", &last_arg);

		found = !strcmp(suite_arg, suite_name);
		if (test_name) {
			found &= !strcmp(test_arg, "*") ||
  40a008:	90000078 	adrp	x24, 416000 <__func__.0+0x57a>
{
  40a00c:	f9478400 	ldr	x0, [x0, #3848]
  40a010:	a9025bf5 	stp	x21, x22, [sp, #32]
			found &= !strcmp(test_arg, "*") ||
  40a014:	910d9f18 	add	x24, x24, #0x367
{
  40a018:	a9046bf9 	stp	x25, x26, [sp, #64]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40a01c:	f0000055 	adrp	x21, 415000 <__func__.2+0x30c>
  40a020:	913362b5 	add	x21, x21, #0xcd8
{
  40a024:	a90573fb 	stp	x27, x28, [sp, #80]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40a028:	9101c3fb 	add	x27, sp, #0x70
	bool found = false;
  40a02c:	52800013 	mov	w19, #0x0                   	// #0
{
  40a030:	f9400001 	ldr	x1, [x0]
  40a034:	f9003fe1 	str	x1, [sp, #120]
  40a038:	d2800001 	mov	x1, #0x0                   	// #0
	char *test_args_local = strdup(test_args);
  40a03c:	90000120 	adrp	x0, 42e000 <thingset_workq+0x8>
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40a040:	9101a3f9 	add	x25, sp, #0x68
  40a044:	9000007a 	adrp	x26, 416000 <__func__.0+0x57a>
	char *test_args_local = strdup(test_args);
  40a048:	f9479c00 	ldr	x0, [x0, #3896]
  40a04c:	97ffdd15 	bl	4014a0 <strdup@plt>
  40a050:	aa0003f6 	mov	x22, x0
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40a054:	aa1903e2 	mov	x2, x25
  40a058:	911c9b41 	add	x1, x26, #0x726
  40a05c:	97ffdcdd 	bl	4013d0 <strtok_r@plt>
	while (suite_test_pair && !found) {
  40a060:	f100001f 	cmp	x0, #0x0
  40a064:	52000261 	eor	w1, w19, #0x1
  40a068:	1a9f07e2 	cset	w2, ne  // ne = any
  40a06c:	6a01005f 	tst	w2, w1
  40a070:	54000161 	b.ne	40a09c <z_ztest_testargs_contains+0xb0>  // b.any
		}

		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
	}

	free(test_args_local);
  40a074:	aa1603e0 	mov	x0, x22
  40a078:	97ffdd3a 	bl	401560 <free@plt>
	return found;
}
  40a07c:	d0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40a080:	f9478400 	ldr	x0, [x0, #3848]
  40a084:	f9403fe2 	ldr	x2, [sp, #120]
  40a088:	f9400001 	ldr	x1, [x0]
  40a08c:	eb010042 	subs	x2, x2, x1
  40a090:	d2800001 	mov	x1, #0x0                   	// #0
  40a094:	54000440 	b.eq	40a11c <z_ztest_testargs_contains+0x130>  // b.none
  40a098:	97ffdd06 	bl	4014b0 <__stack_chk_fail@plt>
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40a09c:	aa1b03e2 	mov	x2, x27
  40a0a0:	aa1503e1 	mov	x1, x21
  40a0a4:	97ffdccb 	bl	4013d0 <strtok_r@plt>
  40a0a8:	aa0003f3 	mov	x19, x0
		test_arg = strtok_r(NULL, ":", &last_arg);
  40a0ac:	aa1b03e2 	mov	x2, x27
  40a0b0:	aa1503e1 	mov	x1, x21
  40a0b4:	d2800000 	mov	x0, #0x0                   	// #0
  40a0b8:	97ffdcc6 	bl	4013d0 <strtok_r@plt>
		found = !strcmp(suite_arg, suite_name);
  40a0bc:	aa1703e1 	mov	x1, x23
		test_arg = strtok_r(NULL, ":", &last_arg);
  40a0c0:	aa0003fc 	mov	x28, x0
		found = !strcmp(suite_arg, suite_name);
  40a0c4:	aa1303e0 	mov	x0, x19
  40a0c8:	97ffdd16 	bl	401520 <strcmp@plt>
  40a0cc:	7100001f 	cmp	w0, #0x0
  40a0d0:	1a9f17f3 	cset	w19, eq  // eq = none
		if (test_name) {
  40a0d4:	b4000174 	cbz	x20, 40a100 <z_ztest_testargs_contains+0x114>
			found &= !strcmp(test_arg, "*") ||
  40a0d8:	aa1803e1 	mov	x1, x24
  40a0dc:	aa1c03e0 	mov	x0, x28
  40a0e0:	97ffdd10 	bl	401520 <strcmp@plt>
  40a0e4:	34000180 	cbz	w0, 40a114 <z_ztest_testargs_contains+0x128>
				 !strcmp(test_arg, test_name);
  40a0e8:	aa1403e1 	mov	x1, x20
  40a0ec:	aa1c03e0 	mov	x0, x28
  40a0f0:	97ffdd0c 	bl	401520 <strcmp@plt>
			found &= !strcmp(test_arg, "*") ||
  40a0f4:	7100001f 	cmp	w0, #0x0
  40a0f8:	1a9f17e0 	cset	w0, eq  // eq = none
  40a0fc:	0a000273 	and	w19, w19, w0
		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
  40a100:	aa1903e2 	mov	x2, x25
  40a104:	911c9b41 	add	x1, x26, #0x726
  40a108:	d2800000 	mov	x0, #0x0                   	// #0
  40a10c:	97ffdcb1 	bl	4013d0 <strtok_r@plt>
  40a110:	17ffffd4 	b	40a060 <z_ztest_testargs_contains+0x74>
			found &= !strcmp(test_arg, "*") ||
  40a114:	52800020 	mov	w0, #0x1                   	// #1
  40a118:	17fffff9 	b	40a0fc <z_ztest_testargs_contains+0x110>
}
  40a11c:	2a1303e0 	mov	w0, w19
  40a120:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a124:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a128:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a12c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40a130:	a94573fb 	ldp	x27, x28, [sp, #80]
  40a134:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40a138:	d65f03c0 	ret

000000000040a13c <z_ztest_should_test_run>:
 */
bool z_ztest_should_test_run(const char *suite, const char *test)
{
	bool run_test = false;

	run_test = (test_args == NULL ||
  40a13c:	90000122 	adrp	x2, 42e000 <thingset_workq+0x8>
  40a140:	f9479c42 	ldr	x2, [x2, #3896]
  40a144:	b4000102 	cbz	x2, 40a164 <z_ztest_should_test_run+0x28>
{
  40a148:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a14c:	910003fd 	mov	x29, sp
		    z_ztest_testargs_contains(suite, test));
  40a150:	97ffffa7 	bl	409fec <z_ztest_testargs_contains>
  40a154:	12001c00 	and	w0, w0, #0xff

	return run_test;
}
  40a158:	12000000 	and	w0, w0, #0x1
  40a15c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a160:	d65f03c0 	ret
	run_test = (test_args == NULL ||
  40a164:	52800020 	mov	w0, #0x1                   	// #1
}
  40a168:	12000000 	and	w0, w0, #0x1
  40a16c:	d65f03c0 	ret

000000000040a170 <z_ztest_should_suite_run>:
 * @param suite Pointer to ztest_suite_node
 * @return true
 * @return false
 */
bool z_ztest_should_suite_run(const void *state, struct ztest_suite_node *suite)
{
  40a170:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a174:	910003fd 	mov	x29, sp
  40a178:	a90153f3 	stp	x19, x20, [sp, #16]
  40a17c:	aa0003f4 	mov	x20, x0
	bool run_suite = true;

	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40a180:	90000120 	adrp	x0, 42e000 <thingset_workq+0x8>
{
  40a184:	aa0103f3 	mov	x19, x1
	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40a188:	f9479c00 	ldr	x0, [x0, #3896]
  40a18c:	b40001a0 	cbz	x0, 40a1c0 <z_ztest_should_suite_run+0x50>
  40a190:	f9400260 	ldr	x0, [x19]
  40a194:	d2800001 	mov	x1, #0x0                   	// #0
  40a198:	97ffff95 	bl	409fec <z_ztest_testargs_contains>
  40a19c:	72001c00 	ands	w0, w0, #0xff
  40a1a0:	54000101 	b.ne	40a1c0 <z_ztest_should_suite_run+0x50>  // b.any
  40a1a4:	f9401a62 	ldr	x2, [x19, #48]
		run_suite = false;
		suite->stats->run_count++;
  40a1a8:	b9400041 	ldr	w1, [x2]
  40a1ac:	11000421 	add	w1, w1, #0x1
  40a1b0:	b9000041 	str	w1, [x2]
	} else if (suite->predicate != NULL) {
		run_suite = suite->predicate(state);
	}

	return run_suite;
}
  40a1b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a1b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a1bc:	d65f03c0 	ret
	} else if (suite->predicate != NULL) {
  40a1c0:	f9401661 	ldr	x1, [x19, #40]
  40a1c4:	b40000c1 	cbz	x1, 40a1dc <z_ztest_should_suite_run+0x6c>
		run_suite = suite->predicate(state);
  40a1c8:	aa1403e0 	mov	x0, x20
  40a1cc:	aa0103f0 	mov	x16, x1
}
  40a1d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a1d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
		run_suite = suite->predicate(state);
  40a1d8:	d61f0200 	br	x16
	bool run_suite = true;
  40a1dc:	52800020 	mov	w0, #0x1                   	// #1
  40a1e0:	17fffff5 	b	40a1b4 <z_ztest_should_suite_run+0x44>

000000000040a1e4 <ztest_relative_filename>:
{
  40a1e4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  40a1e8:	910003fd 	mov	x29, sp
  40a1ec:	a90153f3 	stp	x19, x20, [sp, #16]
  40a1f0:	aa0003f3 	mov	x19, x0
  40a1f4:	d0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40a1f8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a1fc:	f9478400 	ldr	x0, [x0, #3848]
  40a200:	f9400001 	ldr	x1, [x0]
  40a204:	f9007fe1 	str	x1, [sp, #248]
  40a208:	d2800001 	mov	x1, #0x0                   	// #0
		       "destination buffer");

__fortify_function __wur char *
__NTH (getcwd (char *__buf, size_t __size))
{
  return __glibc_fortify (getcwd, __size, sizeof (char),
  40a20c:	9100c3e0 	add	x0, sp, #0x30
  40a210:	d2801901 	mov	x1, #0xc8                  	// #200
  40a214:	97ffdc33 	bl	4012e0 <getcwd@plt>
	if (cwd && strlen(file) > strlen(cwd) && !strncmp(file, cwd, strlen(cwd))) {
  40a218:	b4000220 	cbz	x0, 40a25c <ztest_relative_filename+0x78>
  40a21c:	aa0003f5 	mov	x21, x0
  40a220:	aa1303e0 	mov	x0, x19
  40a224:	97ffdc37 	bl	401300 <strlen@plt>
  40a228:	aa0003f6 	mov	x22, x0
  40a22c:	aa1503e0 	mov	x0, x21
  40a230:	97ffdc34 	bl	401300 <strlen@plt>
  40a234:	aa0003f4 	mov	x20, x0
  40a238:	eb0002df 	cmp	x22, x0
  40a23c:	54000109 	b.ls	40a25c <ztest_relative_filename+0x78>  // b.plast
  40a240:	aa0003e2 	mov	x2, x0
  40a244:	aa1503e1 	mov	x1, x21
  40a248:	aa1303e0 	mov	x0, x19
  40a24c:	97ffdc71 	bl	401410 <strncmp@plt>
  40a250:	35000060 	cbnz	w0, 40a25c <ztest_relative_filename+0x78>
		return file + strlen(cwd) + 1; /* move past the trailing '/' */
  40a254:	91000694 	add	x20, x20, #0x1
  40a258:	8b140273 	add	x19, x19, x20
}
  40a25c:	d0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40a260:	f9478400 	ldr	x0, [x0, #3848]
  40a264:	f9407fe2 	ldr	x2, [sp, #248]
  40a268:	f9400001 	ldr	x1, [x0]
  40a26c:	eb010042 	subs	x2, x2, x1
  40a270:	d2800001 	mov	x1, #0x0                   	// #0
  40a274:	54000040 	b.eq	40a27c <ztest_relative_filename+0x98>  // b.none
  40a278:	97ffdc8e 	bl	4014b0 <__stack_chk_fail@plt>
  40a27c:	aa1303e0 	mov	x0, x19
  40a280:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a284:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a288:	a8d07bfd 	ldp	x29, x30, [sp], #256
  40a28c:	d65f03c0 	ret

000000000040a290 <z_ztest_get_list_test>:
}
  40a290:	b0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  40a294:	397e4000 	ldrb	w0, [x0, #3984]
  40a298:	d65f03c0 	ret

000000000040a29c <z_ztest_list_tests>:
{
  40a29c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40a2a0:	910003fd 	mov	x29, sp
  40a2a4:	a90363f7 	stp	x23, x24, [sp, #48]
	if (list_once) {
  40a2a8:	f0000118 	adrp	x24, 42d000 <__dso_handle>
  40a2ac:	396ba300 	ldrb	w0, [x24, #2792]
{
  40a2b0:	a90153f3 	stp	x19, x20, [sp, #16]
  40a2b4:	a9025bf5 	stp	x21, x22, [sp, #32]
	int test_count = 0;
  40a2b8:	52800015 	mov	w21, #0x0                   	// #0
	if (list_once) {
  40a2bc:	350002e0 	cbnz	w0, 40a318 <z_ztest_list_tests+0x7c>
}
  40a2c0:	2a1503e0 	mov	w0, w21
  40a2c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a2c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a2cc:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a2d0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40a2d4:	d65f03c0 	ret
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40a2d8:	a9400a61 	ldp	x1, x2, [x19]
  40a2dc:	aa1703e0 	mov	x0, x23
				test_count++;
  40a2e0:	110006b5 	add	w21, w21, #0x1
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40a2e4:	97ffe67a 	bl	403ccc <printk>
			while ((test = z_ztest_get_next_test(ptr->name, test)) != NULL) {
  40a2e8:	f9400280 	ldr	x0, [x20]
  40a2ec:	aa1303e1 	mov	x1, x19
  40a2f0:	97fffd4b 	bl	40981c <z_ztest_get_next_test>
  40a2f4:	aa0003f3 	mov	x19, x0
  40a2f8:	b5ffff00 	cbnz	x0, 40a2d8 <z_ztest_list_tests+0x3c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40a2fc:	9100e294 	add	x20, x20, #0x38
  40a300:	eb16029f 	cmp	x20, x22
  40a304:	54000063 	b.cc	40a310 <z_ztest_list_tests+0x74>  // b.lo, b.ul, b.last
		list_once = false;
  40a308:	392ba31f 	strb	wzr, [x24, #2792]
	return test_count;
  40a30c:	17ffffed 	b	40a2c0 <z_ztest_list_tests+0x24>
			test = NULL;
  40a310:	d2800013 	mov	x19, #0x0                   	// #0
  40a314:	17fffff5 	b	40a2e8 <z_ztest_list_tests+0x4c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40a318:	d0000114 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  40a31c:	d0000116 	adrp	x22, 42c000 <__FRAME_END__+0xfbbc>
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40a320:	90000077 	adrp	x23, 416000 <__func__.0+0x57a>
  40a324:	910da6f7 	add	x23, x23, #0x369
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40a328:	f9472a94 	ldr	x20, [x20, #3664]
  40a32c:	f9474ad6 	ldr	x22, [x22, #3728]
  40a330:	17fffff4 	b	40a300 <z_ztest_list_tests+0x64>

000000000040a334 <z_ztest_run_all>:
{
  40a334:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a338:	910003fd 	mov	x29, sp
  40a33c:	f9000bf3 	str	x19, [sp, #16]
  40a340:	aa0003f3 	mov	x19, x0
	if (z_ztest_get_list_test()) {
  40a344:	97ffffd3 	bl	40a290 <z_ztest_get_list_test>
  40a348:	72001c1f 	tst	w0, #0xff
  40a34c:	54000080 	b.eq	40a35c <z_ztest_run_all+0x28>  // b.none
}
  40a350:	f9400bf3 	ldr	x19, [sp, #16]
  40a354:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_ztest_list_tests();
  40a358:	17ffffd1 	b	40a29c <z_ztest_list_tests>
		union { uintptr_t x; const void * val; } parm0 = { .val = state };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_ZTEST_RUN_TEST_SUITES);
	}
#endif
	compiler_barrier();
	return z_impl_ztest_run_test_suites(state);
  40a35c:	aa1303e0 	mov	x0, x19
}
  40a360:	f9400bf3 	ldr	x19, [sp, #16]
  40a364:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a368:	17fffe56 	b	409cc0 <z_impl_ztest_run_test_suites>

000000000040a36c <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
  40a36c:	d65f03c0 	ret

000000000040a370 <net_buf_pool_get>:
}
  40a370:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40a374:	52800c02 	mov	w2, #0x60                  	// #96
  40a378:	f947b021 	ldr	x1, [x1, #3936]
  40a37c:	9b220400 	smaddl	x0, w0, w2, x1
  40a380:	d65f03c0 	ret

000000000040a384 <net_buf_destroy>:
{
  40a384:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a388:	910003fd 	mov	x29, sp
  40a38c:	f9000bf3 	str	x19, [sp, #16]
  40a390:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40a394:	39404800 	ldrb	w0, [x0, #18]
  40a398:	97fffff6 	bl	40a370 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40a39c:	aa1303e1 	mov	x1, x19
}
  40a3a0:	f9400bf3 	ldr	x19, [sp, #16]
  40a3a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_lifo_put(&pool->free, buf);
  40a3a8:	1400180d 	b	4103dc <k_queue_prepend>

000000000040a3ac <net_buf_id>:
{
  40a3ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a3b0:	910003fd 	mov	x29, sp
  40a3b4:	f9000bf3 	str	x19, [sp, #16]
  40a3b8:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40a3bc:	39404800 	ldrb	w0, [x0, #18]
  40a3c0:	97ffffec 	bl	40a370 <net_buf_pool_get>
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40a3c4:	f9402c01 	ldr	x1, [x0, #88]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40a3c8:	39411000 	ldrb	w0, [x0, #68]
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40a3cc:	cb010273 	sub	x19, x19, x1
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40a3d0:	9100dc00 	add	x0, x0, #0x37
  40a3d4:	927df000 	and	x0, x0, #0xfffffffffffffff8
}
  40a3d8:	9ac00a60 	udiv	x0, x19, x0
  40a3dc:	f9400bf3 	ldr	x19, [sp, #16]
  40a3e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a3e4:	d65f03c0 	ret

000000000040a3e8 <fixed_data_alloc>:
{
  40a3e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a3ec:	910003fd 	mov	x29, sp
  40a3f0:	a90153f3 	stp	x19, x20, [sp, #16]
  40a3f4:	aa0003f3 	mov	x19, x0
  40a3f8:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40a3fc:	39404800 	ldrb	w0, [x0, #18]
{
  40a400:	f90013f5 	str	x21, [sp, #32]
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40a404:	97ffffdb 	bl	40a370 <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40a408:	f9402800 	ldr	x0, [x0, #80]
  40a40c:	f9400401 	ldr	x1, [x0, #8]
	*size = MIN(fixed->data_size, *size);
  40a410:	f9400280 	ldr	x0, [x20]
  40a414:	f9400022 	ldr	x2, [x1]
  40a418:	eb02001f 	cmp	x0, x2
  40a41c:	9a829000 	csel	x0, x0, x2, ls  // ls = plast
  40a420:	f9000280 	str	x0, [x20]
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
  40a424:	aa1303e0 	mov	x0, x19
  40a428:	a9405035 	ldp	x21, x20, [x1]
  40a42c:	97ffffe0 	bl	40a3ac <net_buf_id>
  40a430:	93407c00 	sxtw	x0, w0
}
  40a434:	9b155000 	madd	x0, x0, x21, x20
  40a438:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a43c:	f94013f5 	ldr	x21, [sp, #32]
  40a440:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a444:	d65f03c0 	ret

000000000040a448 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
  40a448:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a44c:	910003fd 	mov	x29, sp
  40a450:	a90153f3 	stp	x19, x20, [sp, #16]
  40a454:	f90013f5 	str	x21, [sp, #32]
	__ASSERT_NO_MSG(buf);
  40a458:	b5000240 	cbnz	x0, 40a4a0 <net_buf_unref+0x58>
  40a45c:	90000073 	adrp	x19, 416000 <__func__.0+0x57a>
  40a460:	91110673 	add	x19, x19, #0x441
  40a464:	aa1303e2 	mov	x2, x19
  40a468:	52803ba3 	mov	w3, #0x1dd                 	// #477
  40a46c:	f0000041 	adrp	x1, 415000 <__func__.2+0x30c>
  40a470:	d0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40a474:	913c5421 	add	x1, x1, #0xf15
  40a478:	91353400 	add	x0, x0, #0xd4d
  40a47c:	97ffeb50 	bl	4051bc <assert_print>
  40a480:	aa1303e0 	mov	x0, x19
  40a484:	52803ba1 	mov	w1, #0x1dd                 	// #477
  40a488:	97ffeb77 	bl	405264 <assert_post_action>
  40a48c:	d0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40a490:	aa1303e1 	mov	x1, x19
  40a494:	91362c00 	add	x0, x0, #0xd8b
  40a498:	52803ba2 	mov	w2, #0x1dd                 	// #477
  40a49c:	97fff564 	bl	407a2c <posix_print_error_and_exit>
  40a4a0:	aa0003f4 	mov	x20, x0
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
  40a4a4:	39404280 	ldrb	w0, [x20, #16]
  40a4a8:	aa1403f3 	mov	x19, x20
		struct net_buf *frags = buf->frags;
  40a4ac:	f9400694 	ldr	x20, [x20, #8]
		if (--buf->ref > 0) {
  40a4b0:	51000400 	sub	w0, w0, #0x1
  40a4b4:	12001c00 	and	w0, w0, #0xff
  40a4b8:	39004260 	strb	w0, [x19, #16]
  40a4bc:	350002e0 	cbnz	w0, 40a518 <net_buf_unref+0xd0>
			return;
		}

		if (buf->__buf) {
  40a4c0:	f9401675 	ldr	x21, [x19, #40]
  40a4c4:	b4000195 	cbz	x21, 40a4f4 <net_buf_unref+0xac>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40a4c8:	39404a60 	ldrb	w0, [x19, #18]
  40a4cc:	97ffffa9 	bl	40a370 <net_buf_pool_get>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
  40a4d0:	39404661 	ldrb	w1, [x19, #17]
  40a4d4:	370000e1 	tbnz	w1, #0, 40a4f0 <net_buf_unref+0xa8>
	pool->alloc->cb->unref(buf, data);
  40a4d8:	f9402800 	ldr	x0, [x0, #80]
  40a4dc:	aa1503e1 	mov	x1, x21
  40a4e0:	f9400000 	ldr	x0, [x0]
  40a4e4:	f9400802 	ldr	x2, [x0, #16]
  40a4e8:	aa1303e0 	mov	x0, x19
  40a4ec:	d63f0040 	blr	x2
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
  40a4f0:	f900167f 	str	xzr, [x19, #40]
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
  40a4f4:	39404a60 	ldrb	w0, [x19, #18]
		buf->frags = NULL;
  40a4f8:	f900067f 	str	xzr, [x19, #8]
		buf->data = NULL;
  40a4fc:	f9000e7f 	str	xzr, [x19, #24]
		pool = net_buf_pool_get(buf->pool_id);
  40a500:	97ffff9c 	bl	40a370 <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
  40a504:	f9402401 	ldr	x1, [x0, #72]
			pool->destroy(buf);
  40a508:	aa1303e0 	mov	x0, x19
		if (pool->destroy) {
  40a50c:	b40000e1 	cbz	x1, 40a528 <net_buf_unref+0xe0>
			pool->destroy(buf);
  40a510:	d63f0020 	blr	x1
	while (buf) {
  40a514:	b5fffc94 	cbnz	x20, 40a4a4 <net_buf_unref+0x5c>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
  40a518:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a51c:	f94013f5 	ldr	x21, [sp, #32]
  40a520:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a524:	d65f03c0 	ret
			net_buf_destroy(buf);
  40a528:	97ffff97 	bl	40a384 <net_buf_destroy>
  40a52c:	17fffffa 	b	40a514 <net_buf_unref+0xcc>

000000000040a530 <net_buf_simple_pull_mem>:
{
	void *data = buf->data;

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);
  40a530:	79401004 	ldrh	w4, [x0, #8]
{
  40a534:	aa0003e2 	mov	x2, x0
	__ASSERT_NO_MSG(buf->len >= len);
  40a538:	79401003 	ldrh	w3, [x0, #8]
	void *data = buf->data;
  40a53c:	f9400000 	ldr	x0, [x0]
	__ASSERT_NO_MSG(buf->len >= len);
  40a540:	eb01009f 	cmp	x4, x1
  40a544:	540002a2 	b.cs	40a598 <net_buf_simple_pull_mem+0x68>  // b.hs, b.nlast
{
  40a548:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT_NO_MSG(buf->len >= len);
  40a54c:	52803323 	mov	w3, #0x199                 	// #409
  40a550:	90000061 	adrp	x1, 416000 <__func__.0+0x57a>
{
  40a554:	910003fd 	mov	x29, sp
  40a558:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(buf->len >= len);
  40a55c:	90000073 	adrp	x19, 416000 <__func__.0+0x57a>
  40a560:	91126273 	add	x19, x19, #0x498
  40a564:	91134821 	add	x1, x1, #0x4d2
  40a568:	aa1303e2 	mov	x2, x19
  40a56c:	d0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40a570:	91353400 	add	x0, x0, #0xd4d
  40a574:	97ffeb12 	bl	4051bc <assert_print>
  40a578:	aa1303e0 	mov	x0, x19
  40a57c:	52803321 	mov	w1, #0x199                 	// #409
  40a580:	97ffeb39 	bl	405264 <assert_post_action>
  40a584:	d0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40a588:	aa1303e1 	mov	x1, x19
  40a58c:	91362c00 	add	x0, x0, #0xd8b
  40a590:	52803322 	mov	w2, #0x199                 	// #409
  40a594:	97fff526 	bl	407a2c <posix_print_error_and_exit>

	buf->len -= len;
  40a598:	4b010063 	sub	w3, w3, w1
	buf->data += len;
  40a59c:	8b010001 	add	x1, x0, x1
  40a5a0:	f9000041 	str	x1, [x2]
	buf->len -= len;
  40a5a4:	79001043 	strh	w3, [x2, #8]

	return data;
}
  40a5a8:	d65f03c0 	ret

000000000040a5ac <can_tx_default_cb>:
	struct k_sem done;
	int status;
};

static void can_tx_default_cb(const struct device *dev, int error, void *user_data)
{
  40a5ac:	aa0203e0 	mov	x0, x2
	struct can_tx_default_cb_ctx *ctx = user_data;

	ctx->status = error;
  40a5b0:	b9002841 	str	w1, [x2, #40]
	z_impl_k_sem_give(sem);
  40a5b4:	1400179a 	b	41041c <z_impl_k_sem_give>

000000000040a5b8 <z_impl_can_send>:
}

int z_impl_can_send(const struct device *dev, const struct can_frame *frame,
		    k_timeout_t timeout, can_tx_callback_t callback,
		    void *user_data)
{
  40a5b8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40a5bc:	d0000105 	adrp	x5, 42c000 <__FRAME_END__+0xfbbc>
  40a5c0:	910003fd 	mov	x29, sp
  40a5c4:	f94784a5 	ldr	x5, [x5, #3848]
  40a5c8:	a90153f3 	stp	x19, x20, [sp, #16]
  40a5cc:	d0000113 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  40a5d0:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a5d4:	a90363f7 	stp	x23, x24, [sp, #48]
  40a5d8:	f94000a6 	ldr	x6, [x5]
  40a5dc:	f9003fe6 	str	x6, [sp, #120]
  40a5e0:	d2800006 	mov	x6, #0x0                   	// #0
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  40a5e4:	f9400818 	ldr	x24, [x0, #16]

	if (callback == NULL) {
  40a5e8:	b5000423 	cbnz	x3, 40a66c <z_impl_can_send+0xb4>
  40a5ec:	aa0003f4 	mov	x20, x0
  40a5f0:	aa0103f6 	mov	x22, x1
  40a5f4:	aa0203f7 	mov	x23, x2
	return z_impl_k_sem_init(sem, initial_count, limit);
  40a5f8:	910123f5 	add	x21, sp, #0x48
  40a5fc:	52800022 	mov	w2, #0x1                   	// #1
  40a600:	52800001 	mov	w1, #0x0                   	// #0
  40a604:	aa1503e0 	mov	x0, x21
  40a608:	9400177a 	bl	4103f0 <z_impl_k_sem_init>
		struct can_tx_default_cb_ctx ctx;
		int err;

		k_sem_init(&ctx.done, 0, 1);

		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
  40a60c:	f9401705 	ldr	x5, [x24, #40]
  40a610:	90000003 	adrp	x3, 40a000 <z_ztest_testargs_contains+0x14>
  40a614:	aa1503e4 	mov	x4, x21
  40a618:	9116b063 	add	x3, x3, #0x5ac
  40a61c:	aa1703e2 	mov	x2, x23
  40a620:	aa1603e1 	mov	x1, x22
  40a624:	aa1403e0 	mov	x0, x20
  40a628:	d63f00a0 	blr	x5
		if (err != 0) {
  40a62c:	350000a0 	cbnz	w0, 40a640 <z_impl_can_send+0x88>
	return z_impl_k_sem_take(sem, timeout);
  40a630:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40a634:	aa1503e0 	mov	x0, x21
  40a638:	940017b0 	bl	4104f8 <z_impl_k_sem_take>
			return err;
		}

		k_sem_take(&ctx.done, K_FOREVER);

		return ctx.status;
  40a63c:	b94073e0 	ldr	w0, [sp, #112]
	}

	return api->send(dev, frame, timeout, callback, user_data);
}
  40a640:	f9478673 	ldr	x19, [x19, #3848]
  40a644:	f9403fe1 	ldr	x1, [sp, #120]
  40a648:	f9400262 	ldr	x2, [x19]
  40a64c:	eb020021 	subs	x1, x1, x2
  40a650:	d2800002 	mov	x2, #0x0                   	// #0
  40a654:	54000181 	b.ne	40a684 <z_impl_can_send+0xcc>  // b.any
  40a658:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a65c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a660:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a664:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40a668:	d65f03c0 	ret
	return api->send(dev, frame, timeout, callback, user_data);
  40a66c:	f9478673 	ldr	x19, [x19, #3848]
  40a670:	f9403fe5 	ldr	x5, [sp, #120]
  40a674:	f9400266 	ldr	x6, [x19]
  40a678:	eb0600a5 	subs	x5, x5, x6
  40a67c:	d2800006 	mov	x6, #0x0                   	// #0
  40a680:	54000040 	b.eq	40a688 <z_impl_can_send+0xd0>  // b.none
}
  40a684:	97ffdb8b 	bl	4014b0 <__stack_chk_fail@plt>
  40a688:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a68c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	return api->send(dev, frame, timeout, callback, user_data);
  40a690:	f9401705 	ldr	x5, [x24, #40]
}
  40a694:	a94363f7 	ldp	x23, x24, [sp, #48]
	return api->send(dev, frame, timeout, callback, user_data);
  40a698:	aa0503f0 	mov	x16, x5
}
  40a69c:	a8c87bfd 	ldp	x29, x30, [sp], #128
	return api->send(dev, frame, timeout, callback, user_data);
  40a6a0:	d61f0200 	br	x16

000000000040a6a4 <can_loopback_get_capabilities>:

static int can_loopback_get_capabilities(const struct device *dev, can_mode_t *cap)
{
	ARG_UNUSED(dev);

	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK;
  40a6a4:	52800020 	mov	w0, #0x1                   	// #1
  40a6a8:	b9000020 	str	w0, [x1]
#if CONFIG_CAN_FD_MODE
	*cap |= CAN_MODE_FD;
#endif /* CONFIG_CAN_FD_MODE */

	return 0;
}
  40a6ac:	52800000 	mov	w0, #0x0                   	// #0
  40a6b0:	d65f03c0 	ret

000000000040a6b4 <can_loopback_start>:

static int can_loopback_start(const struct device *dev)
{
	struct can_loopback_data *data = dev->data;
  40a6b4:	f9401000 	ldr	x0, [x0, #32]

	if (data->started) {
  40a6b8:	39552001 	ldrb	w1, [x0, #1352]
  40a6bc:	350000a1 	cbnz	w1, 40a6d0 <can_loopback_start+0x1c>
		return -EALREADY;
	}

	data->started = true;
  40a6c0:	52800021 	mov	w1, #0x1                   	// #1
  40a6c4:	39152001 	strb	w1, [x0, #1352]

	return 0;
  40a6c8:	52800000 	mov	w0, #0x0                   	// #0
}
  40a6cc:	d65f03c0 	ret
		return -EALREADY;
  40a6d0:	12800e20 	mov	w0, #0xffffff8e            	// #-114
  40a6d4:	17fffffe 	b	40a6cc <can_loopback_start+0x18>

000000000040a6d8 <can_loopback_set_timing>:
{
	struct can_loopback_data *data = dev->data;

	ARG_UNUSED(timing);

	if (data->started) {
  40a6d8:	f9401000 	ldr	x0, [x0, #32]
  40a6dc:	39552000 	ldrb	w0, [x0, #1352]
		return -EBUSY;
  40a6e0:	7100001f 	cmp	w0, #0x0
	}

	return 0;
}
  40a6e4:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40a6e8:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40a6ec:	d65f03c0 	ret

000000000040a6f0 <can_loopback_get_state>:
static int can_loopback_get_state(const struct device *dev, enum can_state *state,
				  struct can_bus_err_cnt *err_cnt)
{
	struct can_loopback_data *data = dev->data;

	if (state != NULL) {
  40a6f0:	b40000e1 	cbz	x1, 40a70c <can_loopback_get_state+0x1c>
		if (data->started) {
  40a6f4:	f9401000 	ldr	x0, [x0, #32]
  40a6f8:	39552000 	ldrb	w0, [x0, #1352]
			*state = CAN_STATE_ERROR_ACTIVE;
  40a6fc:	7100001f 	cmp	w0, #0x0
  40a700:	52800080 	mov	w0, #0x4                   	// #4
  40a704:	1a8013e0 	csel	w0, wzr, w0, ne  // ne = any
  40a708:	b9000020 	str	w0, [x1]
		} else {
			*state = CAN_STATE_STOPPED;
		}
	}

	if (err_cnt) {
  40a70c:	b4000042 	cbz	x2, 40a714 <can_loopback_get_state+0x24>
		err_cnt->tx_err_cnt = 0;
  40a710:	7900005f 	strh	wzr, [x2]
		err_cnt->rx_err_cnt = 0;
	}

	return 0;
}
  40a714:	52800000 	mov	w0, #0x0                   	// #0
  40a718:	d65f03c0 	ret

000000000040a71c <can_loopback_set_state_change_callback>:
						   void *user_data)
{
	ARG_UNUSED(dev);
	ARG_UNUSED(cb);
	ARG_UNUSED(user_data);
}
  40a71c:	d65f03c0 	ret

000000000040a720 <can_loopback_get_core_clock>:

static int can_loopback_get_core_clock(const struct device *dev, uint32_t *rate)
{
	/* Return 16MHz as an realistic value for the testcases */
	*rate = 16000000;
  40a720:	52848000 	mov	w0, #0x2400                	// #9216
  40a724:	72a01e80 	movk	w0, #0xf4, lsl #16
  40a728:	b9000020 	str	w0, [x1]
	return 0;
}
  40a72c:	52800000 	mov	w0, #0x0                   	// #0
  40a730:	d65f03c0 	ret

000000000040a734 <can_loopback_get_max_filters>:
static int can_loopback_get_max_filters(const struct device *dev, bool ide)
{
	ARG_UNUSED(ide);

	return CONFIG_CAN_MAX_FILTER;
}
  40a734:	52800200 	mov	w0, #0x10                  	// #16
  40a738:	d65f03c0 	ret

000000000040a73c <can_loopback_stop>:
	struct can_loopback_data *data = dev->data;
  40a73c:	f9401000 	ldr	x0, [x0, #32]
	if (!data->started) {
  40a740:	39552001 	ldrb	w1, [x0, #1352]
  40a744:	34000121 	cbz	w1, 40a768 <can_loopback_stop+0x2c>
{
  40a748:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a74c:	910003fd 	mov	x29, sp
	data->started = false;
  40a750:	3915201f 	strb	wzr, [x0, #1352]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MSGQ_PURGE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_msgq_purge(msgq);
  40a754:	91088000 	add	x0, x0, #0x220
  40a758:	94001531 	bl	40fc1c <z_impl_k_msgq_purge>
	return 0;
  40a75c:	52800000 	mov	w0, #0x0                   	// #0
}
  40a760:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a764:	d65f03c0 	ret
		return -EALREADY;
  40a768:	12800e20 	mov	w0, #0xffffff8e            	// #-114
}
  40a76c:	d65f03c0 	ret

000000000040a770 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40a770:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40a774:	d0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40a778:	12001c42 	and	w2, w2, #0xff
  40a77c:	910003fd 	mov	x29, sp
  40a780:	f9478400 	ldr	x0, [x0, #3848]
  40a784:	3d8023e0 	str	q0, [sp, #128]
  40a788:	3d8027e1 	str	q1, [sp, #144]
  40a78c:	3d802be2 	str	q2, [sp, #160]
  40a790:	3d802fe3 	str	q3, [sp, #176]
  40a794:	3d8033e4 	str	q4, [sp, #192]
  40a798:	3d8037e5 	str	q5, [sp, #208]
  40a79c:	3d803be6 	str	q6, [sp, #224]
  40a7a0:	3d803fe7 	str	q7, [sp, #240]
  40a7a4:	f90087e7 	str	x7, [sp, #264]
  40a7a8:	f9400003 	ldr	x3, [x0]
  40a7ac:	f9003fe3 	str	x3, [sp, #120]
  40a7b0:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(ap, fmt);
  40a7b4:	910443e0 	add	x0, sp, #0x110
  40a7b8:	a90383e0 	stp	x0, x0, [sp, #56]
  40a7bc:	910403e0 	add	x0, sp, #0x100
  40a7c0:	9100e3e3 	add	x3, sp, #0x38
  40a7c4:	f90027e0 	str	x0, [sp, #72]
  40a7c8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40a7cc:	b90053e0 	str	w0, [sp, #80]
  40a7d0:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40a7d4:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40a7d8:	910163e0 	add	x0, sp, #0x58
  40a7dc:	ad400460 	ldp	q0, q1, [x3]
  40a7e0:	ad000400 	stp	q0, q1, [x0]
  40a7e4:	ad400400 	ldp	q0, q1, [x0]
  40a7e8:	910043e7 	add	x7, sp, #0x10
  40a7ec:	52800000 	mov	w0, #0x0                   	// #0
  40a7f0:	52800005 	mov	w5, #0x0                   	// #0
  40a7f4:	d2800004 	mov	x4, #0x0                   	// #0
  40a7f8:	d2800003 	mov	x3, #0x0                   	// #0
  40a7fc:	ad0004e0 	stp	q0, q1, [x7]
  40a800:	97ffec4f 	bl	40593c <z_impl_z_log_msg_runtime_vcreate>
}
  40a804:	d0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40a808:	f9478400 	ldr	x0, [x0, #3848]
  40a80c:	f9403fe2 	ldr	x2, [sp, #120]
  40a810:	f9400001 	ldr	x1, [x0]
  40a814:	eb010042 	subs	x2, x2, x1
  40a818:	d2800001 	mov	x1, #0x0                   	// #0
  40a81c:	54000040 	b.eq	40a824 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40a820:	97ffdb24 	bl	4014b0 <__stack_chk_fail@plt>
  40a824:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40a828:	d65f03c0 	ret

000000000040a82c <can_loopback_send>:
{
  40a82c:	d10183ff 	sub	sp, sp, #0x60
  40a830:	d0000105 	adrp	x5, 42c000 <__FRAME_END__+0xfbbc>
  40a834:	a9017bfd 	stp	x29, x30, [sp, #16]
  40a838:	910043fd 	add	x29, sp, #0x10
  40a83c:	f94784a5 	ldr	x5, [x5, #3848]
  40a840:	f90013f3 	str	x19, [sp, #32]
  40a844:	f94000a6 	ldr	x6, [x5]
  40a848:	f9002fe6 	str	x6, [sp, #88]
  40a84c:	d2800006 	mov	x6, #0x0                   	// #0
	struct can_loopback_data *data = dev->data;
  40a850:	f9401000 	ldr	x0, [x0, #32]
	__ASSERT_NO_MSG(callback != NULL);
  40a854:	b5000243 	cbnz	x3, 40a89c <can_loopback_send+0x70>
  40a858:	90000073 	adrp	x19, 416000 <__func__.0+0x57a>
  40a85c:	9113f273 	add	x19, x19, #0x4fc
  40a860:	aa1303e2 	mov	x2, x19
  40a864:	52800d83 	mov	w3, #0x6c                  	// #108
  40a868:	90000061 	adrp	x1, 416000 <__func__.0+0x57a>
  40a86c:	d0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40a870:	9114a821 	add	x1, x1, #0x52a
  40a874:	91353400 	add	x0, x0, #0xd4d
  40a878:	97ffea51 	bl	4051bc <assert_print>
  40a87c:	aa1303e0 	mov	x0, x19
  40a880:	52800d81 	mov	w1, #0x6c                  	// #108
  40a884:	97ffea78 	bl	405264 <assert_post_action>
  40a888:	d0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40a88c:	aa1303e1 	mov	x1, x19
  40a890:	91362c00 	add	x0, x0, #0xd8b
  40a894:	52800d82 	mov	w2, #0x6c                  	// #108
  40a898:	97fff465 	bl	407a2c <posix_print_error_and_exit>
	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0) {
  40a89c:	39401425 	ldrb	w5, [x1, #5]
  40a8a0:	39401427 	ldrb	w7, [x1, #5]
  40a8a4:	f27e14bf 	tst	x5, #0xfc
  40a8a8:	54000280 	b.eq	40a8f8 <can_loopback_send+0xcc>  // b.none
		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
  40a8ac:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40a8b0:	52800000 	mov	w0, #0x0                   	// #0
  40a8b4:	90000066 	adrp	x6, 416000 <__func__.0+0x57a>
  40a8b8:	52800005 	mov	w5, #0x0                   	// #0
  40a8bc:	f9476021 	ldr	x1, [x1, #3776]
  40a8c0:	911508c6 	add	x6, x6, #0x542
  40a8c4:	d2800004 	mov	x4, #0x0                   	// #0
  40a8c8:	d2800003 	mov	x3, #0x0                   	// #0
  40a8cc:	52800022 	mov	w2, #0x1                   	// #1
  40a8d0:	97ffffa8 	bl	40a770 <z_log_msg_runtime_create.constprop.0>
		return -ENOTSUP;
  40a8d4:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40a8d8:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40a8dc:	f9478421 	ldr	x1, [x1, #3848]
  40a8e0:	f9402fe3 	ldr	x3, [sp, #88]
  40a8e4:	f9400022 	ldr	x2, [x1]
  40a8e8:	eb020063 	subs	x3, x3, x2
  40a8ec:	d2800002 	mov	x2, #0x0                   	// #0
  40a8f0:	54000420 	b.eq	40a974 <can_loopback_send+0x148>  // b.none
  40a8f4:	97ffdaef 	bl	4014b0 <__stack_chk_fail@plt>
	if (frame->dlc > max_dlc) {
  40a8f8:	39401027 	ldrb	w7, [x1, #4]
  40a8fc:	710020ff 	cmp	w7, #0x8
  40a900:	540001e9 	b.ls	40a93c <can_loopback_send+0x110>  // b.plast
		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, max_dlc);
  40a904:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40a908:	52800100 	mov	w0, #0x8                   	// #8
  40a90c:	b90003e0 	str	w0, [sp]
  40a910:	90000066 	adrp	x6, 416000 <__func__.0+0x57a>
  40a914:	f9476021 	ldr	x1, [x1, #3776]
  40a918:	52800000 	mov	w0, #0x0                   	// #0
  40a91c:	911594c6 	add	x6, x6, #0x565
  40a920:	52800005 	mov	w5, #0x0                   	// #0
  40a924:	d2800004 	mov	x4, #0x0                   	// #0
  40a928:	d2800003 	mov	x3, #0x0                   	// #0
  40a92c:	52800022 	mov	w2, #0x1                   	// #1
  40a930:	97ffff90 	bl	40a770 <z_log_msg_runtime_create.constprop.0>
		return -EINVAL;
  40a934:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40a938:	17ffffe8 	b	40a8d8 <can_loopback_send+0xac>
	if (!data->started) {
  40a93c:	39552005 	ldrb	w5, [x0, #1352]
  40a940:	34000165 	cbz	w5, 40a96c <can_loopback_send+0x140>
	loopback_frame.frame = *frame;
  40a944:	a9401c26 	ldp	x6, x7, [x1]
  40a948:	a9039fe6 	stp	x6, x7, [sp, #56]
	loopback_frame.cb_arg = user_data;
  40a94c:	a90493e3 	stp	x3, x4, [sp, #72]
	return z_impl_k_msgq_put(msgq, data, timeout);
  40a950:	9100e3e1 	add	x1, sp, #0x38
  40a954:	91088000 	add	x0, x0, #0x220
  40a958:	9400135e 	bl	40f6d0 <z_impl_k_msgq_put>
		return -EAGAIN;
  40a95c:	7100001f 	cmp	w0, #0x0
  40a960:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40a964:	1a80a3e0 	csel	w0, wzr, w0, ge  // ge = tcont
  40a968:	17ffffdc 	b	40a8d8 <can_loopback_send+0xac>
		return -ENETDOWN;
  40a96c:	12800c60 	mov	w0, #0xffffff9c            	// #-100
  40a970:	17ffffda 	b	40a8d8 <can_loopback_send+0xac>
}
  40a974:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40a978:	f94013f3 	ldr	x19, [sp, #32]
  40a97c:	910183ff 	add	sp, sp, #0x60
  40a980:	d65f03c0 	ret

000000000040a984 <can_loopback_set_mode>:
	struct can_loopback_data *data = dev->data;
  40a984:	f9401000 	ldr	x0, [x0, #32]
{
  40a988:	2a0103e7 	mov	w7, w1
	if (data->started) {
  40a98c:	39552001 	ldrb	w1, [x0, #1352]
  40a990:	350002c1 	cbnz	w1, 40a9e8 <can_loopback_set_mode+0x64>
	if ((mode & ~(CAN_MODE_LOOPBACK)) != 0) {
  40a994:	f27f78ff 	tst	x7, #0xfffffffe
  40a998:	54000200 	b.eq	40a9d8 <can_loopback_set_mode+0x54>  // b.none
{
  40a99c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40a9a0:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40a9a4:	52800005 	mov	w5, #0x0                   	// #0
{
  40a9a8:	910003fd 	mov	x29, sp
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40a9ac:	f9476021 	ldr	x1, [x1, #3776]
  40a9b0:	d2800004 	mov	x4, #0x0                   	// #0
  40a9b4:	d2800003 	mov	x3, #0x0                   	// #0
  40a9b8:	52800022 	mov	w2, #0x1                   	// #1
  40a9bc:	52800000 	mov	w0, #0x0                   	// #0
  40a9c0:	90000066 	adrp	x6, 416000 <__func__.0+0x57a>
  40a9c4:	911610c6 	add	x6, x6, #0x584
  40a9c8:	97ffff6a 	bl	40a770 <z_log_msg_runtime_create.constprop.0>
  40a9cc:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40a9d0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40a9d4:	d65f03c0 	ret
	data->loopback = (mode & CAN_MODE_LOOPBACK) != 0;
  40a9d8:	120000e7 	and	w7, w7, #0x1
  40a9dc:	39152407 	strb	w7, [x0, #1353]
	return 0;
  40a9e0:	52800000 	mov	w0, #0x0                   	// #0
  40a9e4:	d65f03c0 	ret
		return -EBUSY;
  40a9e8:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
  40a9ec:	d65f03c0 	ret

000000000040a9f0 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
  40a9f0:	14001576 	b	40ffc8 <z_impl_k_mutex_unlock>

000000000040a9f4 <can_loopback_remove_rx_filter>:
{
  40a9f4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a9f8:	910003fd 	mov	x29, sp
  40a9fc:	a90153f3 	stp	x19, x20, [sp, #16]
  40aa00:	2a0103f3 	mov	w19, w1
  40aa04:	f90013f5 	str	x21, [sp, #32]
	struct can_loopback_data *data = dev->data;
  40aa08:	f9401015 	ldr	x21, [x0, #32]
	if (filter_id >= ARRAY_SIZE(data->filters)) {
  40aa0c:	71003c3f 	cmp	w1, #0xf
  40aa10:	540001e9 	b.ls	40aa4c <can_loopback_remove_rx_filter+0x58>  // b.plast
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40aa14:	2a0103e7 	mov	w7, w1
  40aa18:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
}
  40aa1c:	a94153f3 	ldp	x19, x20, [sp, #16]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40aa20:	90000066 	adrp	x6, 416000 <__func__.0+0x57a>
}
  40aa24:	f94013f5 	ldr	x21, [sp, #32]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40aa28:	911674c6 	add	x6, x6, #0x59d
}
  40aa2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40aa30:	52800005 	mov	w5, #0x0                   	// #0
  40aa34:	f9476021 	ldr	x1, [x1, #3776]
  40aa38:	d2800004 	mov	x4, #0x0                   	// #0
  40aa3c:	d2800003 	mov	x3, #0x0                   	// #0
  40aa40:	52800022 	mov	w2, #0x1                   	// #1
  40aa44:	52800000 	mov	w0, #0x0                   	// #0
  40aa48:	17ffff4a 	b	40a770 <z_log_msg_runtime_create.constprop.0>
	k_mutex_lock(&data->mtx, K_FOREVER);
  40aa4c:	910802b4 	add	x20, x21, #0x200
	data->filters[filter_id].rx_cb = NULL;
  40aa50:	937b7e73 	sbfiz	x19, x19, #5, #32
	return z_impl_k_mutex_lock(mutex, timeout);
  40aa54:	aa1403e0 	mov	x0, x20
  40aa58:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40aa5c:	940014af 	bl	40fd18 <z_impl_k_mutex_lock>
	k_mutex_unlock(&data->mtx);
  40aa60:	aa1403e0 	mov	x0, x20
	data->filters[filter_id].rx_cb = NULL;
  40aa64:	f8336abf 	str	xzr, [x21, x19]
}
  40aa68:	a94153f3 	ldp	x19, x20, [sp, #16]
  40aa6c:	f94013f5 	ldr	x21, [sp, #32]
  40aa70:	a8c37bfd 	ldp	x29, x30, [sp], #48
	k_mutex_unlock(&data->mtx);
  40aa74:	17ffffdf 	b	40a9f0 <k_mutex_unlock.isra.0>

000000000040aa78 <can_loopback_init>:
	},
#endif /* CONFIG_CAN_FD_MODE */
};

static int can_loopback_init(const struct device *dev)
{
  40aa78:	d10103ff 	sub	sp, sp, #0x40
  40aa7c:	a9017bfd 	stp	x29, x30, [sp, #16]
  40aa80:	910043fd 	add	x29, sp, #0x10
  40aa84:	a90253f3 	stp	x19, x20, [sp, #32]
  40aa88:	aa0003f4 	mov	x20, x0
	struct can_loopback_data *data = dev->data;
  40aa8c:	f9401013 	ldr	x19, [x0, #32]
{
  40aa90:	f9001bf5 	str	x21, [sp, #48]
	k_tid_t tx_tid;

	k_mutex_init(&data->mtx);
  40aa94:	91080275 	add	x21, x19, #0x200
	return z_impl_k_mutex_init(mutex);
  40aa98:	aa1503e0 	mov	x0, x21
  40aa9c:	9400149a 	bl	40fd04 <z_impl_k_mutex_init>

	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40aaa0:	aa1303e0 	mov	x0, x19
		data->filters[i].rx_cb = NULL;
  40aaa4:	f802041f 	str	xzr, [x0], #32
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40aaa8:	eb15001f 	cmp	x0, x21
  40aaac:	54ffffc1 	b.ne	40aaa4 <can_loopback_init+0x2c>  // b.any
	}

	k_msgq_init(&data->tx_msgq, data->msgq_buffer, sizeof(struct can_loopback_frame),
  40aab0:	910a2261 	add	x1, x19, #0x288
  40aab4:	91088260 	add	x0, x19, #0x220
  40aab8:	52800203 	mov	w3, #0x10                  	// #16
  40aabc:	d2800402 	mov	x2, #0x20                  	// #32
  40aac0:	940012f7 	bl	40f69c <k_msgq_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40aac4:	b90003ff 	str	wzr, [sp]
  40aac8:	91154261 	add	x1, x19, #0x550
  40aacc:	f90007ff 	str	xzr, [sp, #8]
  40aad0:	aa1403e4 	mov	x4, x20
  40aad4:	91122260 	add	x0, x19, #0x488
  40aad8:	52800047 	mov	w7, #0x2                   	// #2
  40aadc:	d2800006 	mov	x6, #0x0                   	// #0
  40aae0:	d2800005 	mov	x5, #0x0                   	// #0
  40aae4:	90000003 	adrp	x3, 40a000 <z_ztest_testargs_contains+0x14>
  40aae8:	d2802002 	mov	x2, #0x100                 	// #256
  40aaec:	912d9063 	add	x3, x3, #0xb64
  40aaf0:	9400121e 	bl	40f368 <z_impl_k_thread_create>
	tx_tid = k_thread_create(&data->tx_thread_data, data->tx_thread_stack,
				 K_KERNEL_STACK_SIZEOF(data->tx_thread_stack),
				 tx_thread, (void *)dev, NULL, NULL,
				 CONFIG_CAN_LOOPBACK_TX_THREAD_PRIORITY,
				 0, K_NO_WAIT);
	if (!tx_tid) {
  40aaf4:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40aaf8:	b50001e0 	cbnz	x0, 40ab34 <can_loopback_init+0xbc>
		LOG_ERR("ERROR spawning tx thread");
  40aafc:	f9476021 	ldr	x1, [x1, #3776]
  40ab00:	90000066 	adrp	x6, 416000 <__func__.0+0x57a>
  40ab04:	52800005 	mov	w5, #0x0                   	// #0
  40ab08:	9116e0c6 	add	x6, x6, #0x5b8
  40ab0c:	d2800004 	mov	x4, #0x0                   	// #0
  40ab10:	d2800003 	mov	x3, #0x0                   	// #0
  40ab14:	52800022 	mov	w2, #0x1                   	// #1
  40ab18:	97ffff16 	bl	40a770 <z_log_msg_runtime_create.constprop.0>
		return -1;
  40ab1c:	12800000 	mov	w0, #0xffffffff            	// #-1
	}

	LOG_INF("Init of %s done", dev->name);

	return 0;
}
  40ab20:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40ab24:	a94253f3 	ldp	x19, x20, [sp, #32]
  40ab28:	f9401bf5 	ldr	x21, [sp, #48]
  40ab2c:	910103ff 	add	sp, sp, #0x40
  40ab30:	d65f03c0 	ret
	LOG_INF("Init of %s done", dev->name);
  40ab34:	f9476021 	ldr	x1, [x1, #3776]
  40ab38:	52800000 	mov	w0, #0x0                   	// #0
  40ab3c:	f9400287 	ldr	x7, [x20]
  40ab40:	90000066 	adrp	x6, 416000 <__func__.0+0x57a>
  40ab44:	52800005 	mov	w5, #0x0                   	// #0
  40ab48:	911744c6 	add	x6, x6, #0x5d1
  40ab4c:	d2800004 	mov	x4, #0x0                   	// #0
  40ab50:	d2800003 	mov	x3, #0x0                   	// #0
  40ab54:	52800062 	mov	w2, #0x3                   	// #3
  40ab58:	97ffff06 	bl	40a770 <z_log_msg_runtime_create.constprop.0>
	return 0;
  40ab5c:	52800000 	mov	w0, #0x0                   	// #0
  40ab60:	17fffff0 	b	40ab20 <can_loopback_init+0xa8>

000000000040ab64 <tx_thread>:
{
  40ab64:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  40ab68:	910003fd 	mov	x29, sp
  40ab6c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ab70:	aa0003f5 	mov	x21, x0
  40ab74:	d0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40ab78:	a90153f3 	stp	x19, x20, [sp, #16]
  40ab7c:	a90363f7 	stp	x23, x24, [sp, #48]
	return z_impl_k_msgq_get(msgq, data, timeout);
  40ab80:	9101a3f7 	add	x23, sp, #0x68
  40ab84:	a9046bf9 	stp	x25, x26, [sp, #64]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40ab88:	910163f9 	add	x25, sp, #0x58
{
  40ab8c:	f9478400 	ldr	x0, [x0, #3848]
	struct can_loopback_data *data = dev->data;
  40ab90:	f94012b4 	ldr	x20, [x21, #32]
{
  40ab94:	f9400001 	ldr	x1, [x0]
  40ab98:	f90047e1 	str	x1, [sp, #136]
  40ab9c:	d2800001 	mov	x1, #0x0                   	// #0
		ret = k_msgq_get(&data->tx_msgq, &frame, K_FOREVER);
  40aba0:	91088298 	add	x24, x20, #0x220
  40aba4:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  40aba8:	aa1703e1 	mov	x1, x23
  40abac:	aa1803e0 	mov	x0, x24
  40abb0:	9400136e 	bl	40f968 <z_impl_k_msgq_get>
		if (ret < 0) {
  40abb4:	37ffff80 	tbnz	w0, #31, 40aba4 <tx_thread+0x40>
		frame.cb(dev, 0, frame.cb_arg);
  40abb8:	a9478be3 	ldp	x3, x2, [sp, #120]
  40abbc:	aa1503e0 	mov	x0, x21
  40abc0:	52800001 	mov	w1, #0x0                   	// #0
  40abc4:	d63f0060 	blr	x3
		if (!data->loopback) {
  40abc8:	39552680 	ldrb	w0, [x20, #1353]
  40abcc:	34fffec0 	cbz	w0, 40aba4 <tx_thread+0x40>
		k_mutex_lock(&data->mtx, K_FOREVER);
  40abd0:	9108029a 	add	x26, x20, #0x200
	return z_impl_k_mutex_lock(mutex, timeout);
  40abd4:	aa1403f3 	mov	x19, x20
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40abd8:	52800016 	mov	w22, #0x0                   	// #0
  40abdc:	aa1a03e0 	mov	x0, x26
  40abe0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40abe4:	9400144d 	bl	40fd18 <z_impl_k_mutex_lock>
			if (filter->rx_cb != NULL &&
  40abe8:	f9400260 	ldr	x0, [x19]
  40abec:	b40000c0 	cbz	x0, 40ac04 <tx_thread+0xa0>
 * @return true if the CAN frame matches the CAN filter, false otherwise
 */
static inline bool can_frame_matches_filter(const struct can_frame *frame,
					    const struct can_filter *filter)
{
	if ((frame->flags & CAN_FRAME_IDE) != 0 && (filter->flags & CAN_FILTER_IDE) == 0) {
  40abf0:	3941b7e0 	ldrb	w0, [sp, #109]
  40abf4:	39406261 	ldrb	w1, [x19, #24]
  40abf8:	12000022 	and	w2, w1, #0x1
  40abfc:	36000120 	tbz	w0, #0, 40ac20 <tx_thread+0xbc>
  40ac00:	35000122 	cbnz	w2, 40ac24 <tx_thread+0xc0>
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40ac04:	110006d6 	add	w22, w22, #0x1
  40ac08:	91008273 	add	x19, x19, #0x20
  40ac0c:	710042df 	cmp	w22, #0x10
  40ac10:	54fffec1 	b.ne	40abe8 <tx_thread+0x84>  // b.any
		k_mutex_unlock(&data->mtx);
  40ac14:	aa1a03e0 	mov	x0, x26
  40ac18:	97ffff76 	bl	40a9f0 <k_mutex_unlock.isra.0>
  40ac1c:	17ffffe2 	b	40aba4 <tx_thread+0x40>
		/* Extended (29-bit) ID frame, standard (11-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_IDE) == 0 && (filter->flags & CAN_FILTER_IDE) != 0) {
  40ac20:	35ffff22 	cbnz	w2, 40ac04 <tx_thread+0xa0>
		/* Standard (11-bit) ID frame, extended (29-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_RTR) == 0 && (filter->flags & CAN_FILTER_DATA) == 0) {
  40ac24:	37080280 	tbnz	w0, #1, 40ac74 <tx_thread+0x110>
  40ac28:	3617fee1 	tbz	w1, #2, 40ac04 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
		/* Remote transmission request (RTR) frame, non-RTR filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_FDF) != 0 && (filter->flags & CAN_FILTER_FDF) == 0) {
  40ac2c:	121d0021 	and	w1, w1, #0x8
  40ac30:	36100260 	tbz	w0, #2, 40ac7c <tx_thread+0x118>
  40ac34:	34fffe81 	cbz	w1, 40ac04 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
		/* Classic frame, CAN-FD format filter */
		return false;
	}

	if ((frame->id ^ filter->id) & filter->mask) {
  40ac38:	937b7ec0 	sbfiz	x0, x22, #5, #32
  40ac3c:	8b000280 	add	x0, x20, x0
  40ac40:	f94037e1 	ldr	x1, [sp, #104]
  40ac44:	f9400800 	ldr	x0, [x0, #16]
  40ac48:	4a010001 	eor	w1, w0, w1
  40ac4c:	d360f000 	ubfx	x0, x0, #32, #29
  40ac50:	6a00003f 	tst	w1, w0
  40ac54:	54fffd81 	b.ne	40ac04 <tx_thread+0xa0>  // b.any
	struct can_frame frame_tmp = *frame;
  40ac58:	a94687e0 	ldp	x0, x1, [sp, #104]
  40ac5c:	a90587e0 	stp	x0, x1, [sp, #88]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40ac60:	a9400a63 	ldp	x3, x2, [x19]
  40ac64:	aa1903e1 	mov	x1, x25
  40ac68:	aa1503e0 	mov	x0, x21
  40ac6c:	d63f0060 	blr	x3
}
  40ac70:	17ffffe5 	b	40ac04 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
  40ac74:	370ffdc1 	tbnz	w1, #1, 40ac2c <tx_thread+0xc8>
  40ac78:	17ffffe3 	b	40ac04 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
  40ac7c:	34fffde1 	cbz	w1, 40ac38 <tx_thread+0xd4>
  40ac80:	17ffffe1 	b	40ac04 <tx_thread+0xa0>

000000000040ac84 <can_loopback_add_rx_filter>:
{
  40ac84:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ac88:	910003fd 	mov	x29, sp
  40ac8c:	a90153f3 	stp	x19, x20, [sp, #16]
  40ac90:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ac94:	a90363f7 	stp	x23, x24, [sp, #48]
  40ac98:	f90023f9 	str	x25, [sp, #64]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA | CAN_FILTER_RTR)) != 0) {
  40ac9c:	39402073 	ldrb	w19, [x3, #8]
  40aca0:	39402067 	ldrb	w7, [x3, #8]
  40aca4:	f27df273 	ands	x19, x19, #0xfffffffffffffff8
	struct can_loopback_data *data = dev->data;
  40aca8:	f9401016 	ldr	x22, [x0, #32]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA | CAN_FILTER_RTR)) != 0) {
  40acac:	54000260 	b.eq	40acf8 <can_loopback_add_rx_filter+0x74>  // b.none
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40acb0:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
		return -ENOTSUP;
  40acb4:	12800bd5 	mov	w21, #0xffffffa1            	// #-95
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40acb8:	90000066 	adrp	x6, 416000 <__func__.0+0x57a>
  40acbc:	52800005 	mov	w5, #0x0                   	// #0
  40acc0:	f9476021 	ldr	x1, [x1, #3776]
  40acc4:	911784c6 	add	x6, x6, #0x5e1
  40acc8:	d2800004 	mov	x4, #0x0                   	// #0
  40accc:	d2800003 	mov	x3, #0x0                   	// #0
  40acd0:	52800022 	mov	w2, #0x1                   	// #1
  40acd4:	52800000 	mov	w0, #0x0                   	// #0
  40acd8:	97fffea6 	bl	40a770 <z_log_msg_runtime_create.constprop.0>
}
  40acdc:	2a1503e0 	mov	w0, w21
  40ace0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ace4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ace8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40acec:	f94023f9 	ldr	x25, [sp, #64]
  40acf0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40acf4:	d65f03c0 	ret
  40acf8:	aa0103f9 	mov	x25, x1
  40acfc:	aa0203f8 	mov	x24, x2
  40ad00:	aa0303f4 	mov	x20, x3
	k_mutex_lock(&data->mtx, K_FOREVER);
  40ad04:	910802d7 	add	x23, x22, #0x200
  40ad08:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40ad0c:	aa1703e0 	mov	x0, x23
  40ad10:	94001402 	bl	40fd18 <z_impl_k_mutex_lock>
		if (filters[i].rx_cb == NULL) {
  40ad14:	d37bea60 	lsl	x0, x19, #5
  40ad18:	2a1303f5 	mov	w21, w19
  40ad1c:	f8606ac0 	ldr	x0, [x22, x0]
  40ad20:	b4000240 	cbz	x0, 40ad68 <can_loopback_add_rx_filter+0xe4>
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40ad24:	91000673 	add	x19, x19, #0x1
  40ad28:	f100427f 	cmp	x19, #0x10
  40ad2c:	54ffff41 	b.ne	40ad14 <can_loopback_add_rx_filter+0x90>  // b.any
		LOG_ERR("No free filter left");
  40ad30:	d0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40ad34:	90000066 	adrp	x6, 416000 <__func__.0+0x57a>
  40ad38:	911814c6 	add	x6, x6, #0x605
  40ad3c:	52800005 	mov	w5, #0x0                   	// #0
  40ad40:	f9476021 	ldr	x1, [x1, #3776]
  40ad44:	d2800004 	mov	x4, #0x0                   	// #0
  40ad48:	d2800003 	mov	x3, #0x0                   	// #0
  40ad4c:	52800022 	mov	w2, #0x1                   	// #1
  40ad50:	52800000 	mov	w0, #0x0                   	// #0
	return -ENOSPC;
  40ad54:	12800375 	mov	w21, #0xffffffe4            	// #-28
		LOG_ERR("No free filter left");
  40ad58:	97fffe86 	bl	40a770 <z_log_msg_runtime_create.constprop.0>
		k_mutex_unlock(&data->mtx);
  40ad5c:	aa1703e0 	mov	x0, x23
  40ad60:	97ffff24 	bl	40a9f0 <k_mutex_unlock.isra.0>
		return filter_id;
  40ad64:	17ffffde 	b	40acdc <can_loopback_add_rx_filter+0x58>
	loopback_filter->rx_cb = cb;
  40ad68:	937b7e61 	sbfiz	x1, x19, #5, #32
  40ad6c:	8b0102c0 	add	x0, x22, x1
  40ad70:	f8216ad9 	str	x25, [x22, x1]
	loopback_filter->cb_arg = cb_arg;
  40ad74:	f9000418 	str	x24, [x0, #8]
	loopback_filter->filter = *filter;
  40ad78:	f9400281 	ldr	x1, [x20]
  40ad7c:	f9000801 	str	x1, [x0, #16]
  40ad80:	b9400a81 	ldr	w1, [x20, #8]
  40ad84:	b9001801 	str	w1, [x0, #24]
	k_mutex_unlock(&data->mtx);
  40ad88:	aa1703e0 	mov	x0, x23
  40ad8c:	97ffff19 	bl	40a9f0 <k_mutex_unlock.isra.0>
	return filter_id;
  40ad90:	17ffffd3 	b	40acdc <can_loopback_add_rx_filter+0x58>

000000000040ad94 <posix_arch_console_init>:
		stdout_buff[0] = 0;
	}
}

static int posix_arch_console_init(void)
{
  40ad94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#ifdef CONFIG_PRINTK
	extern void __printk_hook_install(int (*fn)(int));
	__printk_hook_install(print_char);
  40ad98:	90000000 	adrp	x0, 40a000 <z_ztest_testargs_contains+0x14>
  40ad9c:	9136d000 	add	x0, x0, #0xdb4
{
  40ada0:	910003fd 	mov	x29, sp
	__printk_hook_install(print_char);
  40ada4:	97ffe3bd 	bl	403c98 <__printk_hook_install>
#ifdef CONFIG_STDOUT_CONSOLE
	extern void __stdout_hook_install(int (*fn)(int));
	__stdout_hook_install(print_char);
#endif
	return 0;
}
  40ada8:	52800000 	mov	w0, #0x0                   	// #0
  40adac:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40adb0:	d65f03c0 	ret

000000000040adb4 <print_char>:
{
  40adb4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if ((c != '\n') && (c != '\r')) {
  40adb8:	7100281f 	cmp	w0, #0xa
  40adbc:	7a4d1804 	ccmp	w0, #0xd, #0x4, ne  // ne = any
{
  40adc0:	910003fd 	mov	x29, sp
  40adc4:	a90153f3 	stp	x19, x20, [sp, #16]
  40adc8:	2a0003f3 	mov	w19, w0
  40adcc:	b0000134 	adrp	x20, 42f000 <can_loopback_dev_data_0+0xc0>
  40add0:	f90013f5 	str	x21, [sp, #32]
	if ((c != '\n') && (c != '\r')) {
  40add4:	54000320 	b.eq	40ae38 <print_char+0x84>  // b.none
		stdout_buff[n_pend++] = c;
  40add8:	b94d3e82 	ldr	w2, [x20, #3388]
  40addc:	b0000120 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  40ade0:	913e4400 	add	x0, x0, #0xf91
  40ade4:	11000441 	add	w1, w2, #0x1
  40ade8:	b90d3e81 	str	w1, [x20, #3388]
  40adec:	3822c813 	strb	w19, [x0, w2, sxtw]
		stdout_buff[n_pend] = 0;
  40adf0:	3821c81f 	strb	wzr, [x0, w1, sxtw]
	int printnow = 0;
  40adf4:	52800000 	mov	w0, #0x0                   	// #0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  40adf8:	b94d3e81 	ldr	w1, [x20, #3388]
  40adfc:	7103f83f 	cmp	w1, #0xfe
  40ae00:	5400004c 	b.gt	40ae08 <print_char+0x54>
	if (printnow) {
  40ae04:	34000100 	cbz	w0, 40ae24 <print_char+0x70>
		posix_print_trace("%s\n", stdout_buff);
  40ae08:	b0000135 	adrp	x21, 42f000 <can_loopback_dev_data_0+0xc0>
  40ae0c:	90000060 	adrp	x0, 416000 <__func__.0+0x57a>
  40ae10:	913e46a1 	add	x1, x21, #0xf91
  40ae14:	91092c00 	add	x0, x0, #0x24b
  40ae18:	97fff36b 	bl	407bc4 <posix_print_trace>
		n_pend = 0;
  40ae1c:	b90d3e9f 	str	wzr, [x20, #3388]
		stdout_buff[0] = 0;
  40ae20:	393e46bf 	strb	wzr, [x21, #3985]
}
  40ae24:	2a1303e0 	mov	w0, w19
  40ae28:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ae2c:	f94013f5 	ldr	x21, [sp, #32]
  40ae30:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40ae34:	d65f03c0 	ret
		printnow = 1;
  40ae38:	52800020 	mov	w0, #0x1                   	// #1
  40ae3c:	17ffffef 	b	40adf8 <print_char+0x44>

000000000040ae40 <entropy_native_posix_get_entropy>:
static unsigned int seed = 0x5678;

static int entropy_native_posix_get_entropy(const struct device *dev,
					    uint8_t *buffer,
					    uint16_t length)
{
  40ae40:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ae44:	d0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40ae48:	910003fd 	mov	x29, sp
  40ae4c:	f9478400 	ldr	x0, [x0, #3848]
  40ae50:	a90153f3 	stp	x19, x20, [sp, #16]
  40ae54:	aa0103f4 	mov	x20, x1
  40ae58:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ae5c:	12003c53 	and	w19, w2, #0xffff
		 * Note that only 1 thread (Zephyr thread or HW models), runs at
		 * a time, therefore there is no need to use random_r()
		 */
		long int value = random();

		size_t to_copy = MIN(length, sizeof(long int));
  40ae60:	52800116 	mov	w22, #0x8                   	// #8
{
  40ae64:	a90363f7 	stp	x23, x24, [sp, #48]
  40ae68:	910103f7 	add	x23, sp, #0x40
  40ae6c:	f9400001 	ldr	x1, [x0]
  40ae70:	f90027e1 	str	x1, [sp, #72]
  40ae74:	d2800001 	mov	x1, #0x0                   	// #0
	while (length) {
  40ae78:	35000133 	cbnz	w19, 40ae9c <entropy_native_posix_get_entropy+0x5c>
		buffer += to_copy;
		length -= to_copy;
	}

	return 0;
}
  40ae7c:	d0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40ae80:	f9478400 	ldr	x0, [x0, #3848]
  40ae84:	f94027e2 	ldr	x2, [sp, #72]
  40ae88:	f9400001 	ldr	x1, [x0]
  40ae8c:	eb010042 	subs	x2, x2, x1
  40ae90:	d2800001 	mov	x1, #0x0                   	// #0
  40ae94:	54000200 	b.eq	40aed4 <entropy_native_posix_get_entropy+0x94>  // b.none
  40ae98:	97ffd986 	bl	4014b0 <__stack_chk_fail@plt>
		long int value = random();
  40ae9c:	97ffd969 	bl	401440 <random@plt>
  40aea0:	f90023e0 	str	x0, [sp, #64]
		size_t to_copy = MIN(length, sizeof(long int));
  40aea4:	7100227f 	cmp	w19, #0x8
  40aea8:	aa1403e0 	mov	x0, x20
  40aeac:	1a969275 	csel	w21, w19, w22, ls  // ls = plast
  40aeb0:	aa1703e1 	mov	x1, x23
  40aeb4:	12003eb8 	and	w24, w21, #0xffff
  40aeb8:	92403eb5 	and	x21, x21, #0xffff
		length -= to_copy;
  40aebc:	4b180273 	sub	w19, w19, w24
  40aec0:	aa1503e2 	mov	x2, x21
  40aec4:	12003e73 	and	w19, w19, #0xffff
		buffer += to_copy;
  40aec8:	8b150294 	add	x20, x20, x21
  40aecc:	97ffd8fd 	bl	4012c0 <memcpy@plt>
		length -= to_copy;
  40aed0:	17ffffea 	b	40ae78 <entropy_native_posix_get_entropy+0x38>
}
  40aed4:	52800000 	mov	w0, #0x0                   	// #0
  40aed8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40aedc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40aee0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40aee4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40aee8:	d65f03c0 	ret

000000000040aeec <entropy_native_posix_get_entropy_isr>:

	/*
	 * entropy_native_posix_get_entropy() is also safe for ISRs
	 * and always produces data.
	 */
	return entropy_native_posix_get_entropy(dev, buf, len);
  40aeec:	17ffffd5 	b	40ae40 <entropy_native_posix_get_entropy>

000000000040aef0 <entropy_native_posix_init>:
}

static int entropy_native_posix_init(const struct device *dev)
{
  40aef0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(dev);
	srandom(seed);
  40aef4:	f0000100 	adrp	x0, 42d000 <__dso_handle>
{
  40aef8:	910003fd 	mov	x29, sp
	srandom(seed);
  40aefc:	b94ad400 	ldr	w0, [x0, #2772]
  40af00:	97ffd9b4 	bl	4015d0 <srandom@plt>
	posix_print_warning("WARNING: "
  40af04:	90000060 	adrp	x0, 416000 <__func__.0+0x57a>
  40af08:	9118d000 	add	x0, x0, #0x634
  40af0c:	97fff2fc 	bl	407afc <posix_print_warning>
			    "Using a test - not safe - entropy source\n");
	return 0;
}
  40af10:	52800000 	mov	w0, #0x0                   	// #0
  40af14:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40af18:	d65f03c0 	ret

000000000040af1c <add_fake_entropy_option>:
		"A 32-bit integer seed value for the entropy device, such as "
		"97229 (decimal), 0x17BCD (hex), or 0275715 (octal)"},
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(entropy_options);
  40af1c:	f0000100 	adrp	x0, 42d000 <__dso_handle>
  40af20:	9123e000 	add	x0, x0, #0x8f8
  40af24:	17fff58f 	b	408560 <native_add_command_line_opts>

000000000040af28 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
  40af28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40af2c:	910003fd 	mov	x29, sp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
  40af30:	97ffeffb 	bl	406f1c <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40af34:	b0000122 	adrp	x2, 42f000 <can_loopback_dev_data_0+0xc0>
  40af38:	b0000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>

	last_tick_time += elapsed_ticks*tick_period;
	sys_clock_announce(elapsed_ticks);
}
  40af3c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40af40:	f942c843 	ldr	x3, [x2, #1424]
  40af44:	f942cc24 	ldr	x4, [x1, #1432]
  40af48:	cb030000 	sub	x0, x0, x3
  40af4c:	9ac40800 	udiv	x0, x0, x4
	last_tick_time += elapsed_ticks*tick_period;
  40af50:	93407c01 	sxtw	x1, w0
  40af54:	9b040c21 	madd	x1, x1, x4, x3
  40af58:	f902c841 	str	x1, [x2, #1424]
	sys_clock_announce(elapsed_ticks);
  40af5c:	1400238e 	b	413d94 <sys_clock_announce>

000000000040af60 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(void)
{
  40af60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40af64:	d284e200 	mov	x0, #0x2710                	// #10000
{
  40af68:	910003fd 	mov	x29, sp
  40af6c:	f9000bf3 	str	x19, [sp, #16]
	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40af70:	b0000133 	adrp	x19, 42f000 <can_loopback_dev_data_0+0xc0>
  40af74:	f902ce60 	str	x0, [x19, #1432]

	last_tick_time = hwm_get_time();
  40af78:	97ffefe9 	bl	406f1c <hwm_get_time>
  40af7c:	b0000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  40af80:	f902c820 	str	x0, [x1, #1424]
	hwtimer_enable(tick_period);
  40af84:	f942ce60 	ldr	x0, [x19, #1432]
  40af88:	97fff079 	bl	40716c <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
  40af8c:	d2800003 	mov	x3, #0x0                   	// #0
  40af90:	52800001 	mov	w1, #0x0                   	// #0
  40af94:	52800000 	mov	w0, #0x0                   	// #0
  40af98:	90000002 	adrp	x2, 40a000 <z_ztest_testargs_contains+0x14>
  40af9c:	913ca042 	add	x2, x2, #0xf28
  40afa0:	97fff193 	bl	4075ec <posix_isr_declare>
  40afa4:	52800002 	mov	w2, #0x0                   	// #0
  40afa8:	52800021 	mov	w1, #0x1                   	// #1
  40afac:	52800000 	mov	w0, #0x0                   	// #0
  40afb0:	97fff199 	bl	407614 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
  40afb4:	52800000 	mov	w0, #0x0                   	// #0
  40afb8:	97ffed05 	bl	4063cc <arch_irq_enable>

	return 0;
}
  40afbc:	52800000 	mov	w0, #0x0                   	// #0
  40afc0:	f9400bf3 	ldr	x19, [sp, #16]
  40afc4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40afc8:	d65f03c0 	ret

000000000040afcc <sys_clock_cycle_get_32>:
{
  40afcc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40afd0:	910003fd 	mov	x29, sp
	return hwm_get_time();
  40afd4:	97ffefd2 	bl	406f1c <hwm_get_time>
}
  40afd8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40afdc:	d65f03c0 	ret

000000000040afe0 <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
  40afe0:	3100041f 	cmn	w0, #0x1
  40afe4:	540000c0 	b.eq	40affc <sys_clock_set_timeout+0x1c>  // b.none
		silent_ticks = ticks - 1;
  40afe8:	51000401 	sub	w1, w0, #0x1
  40afec:	7100001f 	cmp	w0, #0x0
  40aff0:	93407c21 	sxtw	x1, w1
  40aff4:	9a9fc020 	csel	x0, x1, xzr, gt
	hwtimer_set_silent_ticks(silent_ticks);
  40aff8:	17fff0d1 	b	40733c <hwtimer_set_silent_ticks>
		silent_ticks = INT64_MAX;
  40affc:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  40b000:	17fffffe 	b	40aff8 <sys_clock_set_timeout+0x18>

000000000040b004 <sys_clock_elapsed>:
{
  40b004:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b008:	910003fd 	mov	x29, sp
	return (hwm_get_time() - last_tick_time)/tick_period;
  40b00c:	97ffefc4 	bl	406f1c <hwm_get_time>
  40b010:	90000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
}
  40b014:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return (hwm_get_time() - last_tick_time)/tick_period;
  40b018:	f942c821 	ldr	x1, [x1, #1424]
  40b01c:	cb010000 	sub	x0, x0, x1
  40b020:	90000121 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  40b024:	f942cc21 	ldr	x1, [x1, #1432]
}
  40b028:	9ac10800 	udiv	x0, x0, x1
  40b02c:	d65f03c0 	ret

000000000040b030 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40b030:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40b034:	b0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40b038:	910003fd 	mov	x29, sp
  40b03c:	f9478400 	ldr	x0, [x0, #3848]
  40b040:	3d8023e0 	str	q0, [sp, #128]
  40b044:	3d8027e1 	str	q1, [sp, #144]
  40b048:	3d802be2 	str	q2, [sp, #160]
  40b04c:	3d802fe3 	str	q3, [sp, #176]
  40b050:	3d8033e4 	str	q4, [sp, #192]
  40b054:	3d8037e5 	str	q5, [sp, #208]
  40b058:	3d803be6 	str	q6, [sp, #224]
  40b05c:	3d803fe7 	str	q7, [sp, #240]
  40b060:	f90087e7 	str	x7, [sp, #264]
  40b064:	f9400002 	ldr	x2, [x0]
  40b068:	f9003fe2 	str	x2, [sp, #120]
  40b06c:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40b070:	910443e0 	add	x0, sp, #0x110
  40b074:	a90383e0 	stp	x0, x0, [sp, #56]
  40b078:	910403e0 	add	x0, sp, #0x100
  40b07c:	9100e3e2 	add	x2, sp, #0x38
  40b080:	f90027e0 	str	x0, [sp, #72]
  40b084:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40b088:	b90053e0 	str	w0, [sp, #80]
  40b08c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40b090:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40b094:	910163e0 	add	x0, sp, #0x58
  40b098:	ad400440 	ldp	q0, q1, [x2]
  40b09c:	ad000400 	stp	q0, q1, [x0]
  40b0a0:	ad400400 	ldp	q0, q1, [x0]
  40b0a4:	910043e7 	add	x7, sp, #0x10
  40b0a8:	52800022 	mov	w2, #0x1                   	// #1
  40b0ac:	52800000 	mov	w0, #0x0                   	// #0
  40b0b0:	52800005 	mov	w5, #0x0                   	// #0
  40b0b4:	d2800004 	mov	x4, #0x0                   	// #0
  40b0b8:	d2800003 	mov	x3, #0x0                   	// #0
  40b0bc:	ad0004e0 	stp	q0, q1, [x7]
  40b0c0:	97ffea1f 	bl	40593c <z_impl_z_log_msg_runtime_vcreate>
}
  40b0c4:	b0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40b0c8:	f9478400 	ldr	x0, [x0, #3848]
  40b0cc:	f9403fe2 	ldr	x2, [sp, #120]
  40b0d0:	f9400001 	ldr	x1, [x0]
  40b0d4:	eb010042 	subs	x2, x2, x1
  40b0d8:	d2800001 	mov	x1, #0x0                   	// #0
  40b0dc:	54000040 	b.eq	40b0e4 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40b0e0:	97ffd8f4 	bl	4014b0 <__stack_chk_fail@plt>
  40b0e4:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40b0e8:	d65f03c0 	ret

000000000040b0ec <thingset_init_global>:

void thingset_init_global(struct thingset_context *ts)
{
    /* duplicates are checked at compile-time */

    ts->data_objects = TYPE_SECTION_START(thingset_data_object);
  40b0ec:	b0000102 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
    STRUCT_SECTION_COUNT(thingset_data_object, &ts->num_objects);
  40b0f0:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
    ts->data_objects = TYPE_SECTION_START(thingset_data_object);
  40b0f4:	f947e442 	ldr	x2, [x2, #4040]
    STRUCT_SECTION_COUNT(thingset_data_object, &ts->num_objects);
  40b0f8:	f947b821 	ldr	x1, [x1, #3952]
  40b0fc:	cb020021 	sub	x1, x1, x2
  40b100:	d345fc21 	lsr	x1, x1, #5
  40b104:	a9000402 	stp	x2, x1, [x0]
    ts->auth_flags = THINGSET_USR_MASK;
  40b108:	52800221 	mov	w1, #0x11                  	// #17
  40b10c:	390ea001 	strb	w1, [x0, #936]
	return z_impl_k_sem_init(sem, initial_count, limit);
  40b110:	52800022 	mov	w2, #0x1                   	// #1
  40b114:	91004000 	add	x0, x0, #0x10
  40b118:	2a0203e1 	mov	w1, w2
  40b11c:	140014b5 	b	4103f0 <z_impl_k_sem_init>

000000000040b120 <thingset_export_item>:
    return ret;
}

int thingset_export_item(struct thingset_context *ts, uint8_t *buf, size_t buf_size,
                         const struct thingset_data_object *obj, enum thingset_data_format format)
{
  40b120:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40b124:	910003fd 	mov	x29, sp
  40b128:	a90153f3 	stp	x19, x20, [sp, #16]
  40b12c:	aa0003f3 	mov	x19, x0
  40b130:	2a0403f4 	mov	w20, w4
  40b134:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b138:	aa0203f6 	mov	x22, x2
  40b13c:	aa0303f5 	mov	x21, x3
  40b140:	a90363f7 	stp	x23, x24, [sp, #48]
  40b144:	aa0103f7 	mov	x23, x1
    int ret;

    if (k_sem_take(&ts->lock, K_MSEC(THINGSET_CONTEXT_LOCK_TIMEOUT_MS)) != 0) {
  40b148:	91004018 	add	x24, x0, #0x10
	return z_impl_k_sem_take(sem, timeout);
  40b14c:	d2800c81 	mov	x1, #0x64                  	// #100
  40b150:	aa1803e0 	mov	x0, x24
  40b154:	940014e9 	bl	4104f8 <z_impl_k_sem_take>
  40b158:	34000240 	cbz	w0, 40b1a0 <thingset_export_item+0x80>
        LOG_ERR("ThingSet context lock timed out");
  40b15c:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
        return -THINGSET_ERR_INTERNAL_SERVER_ERR;
  40b160:	128017f4 	mov	w20, #0xffffff40            	// #-192
        LOG_ERR("ThingSet context lock timed out");
  40b164:	f0000046 	adrp	x6, 416000 <__func__.0+0x57a>
  40b168:	52800005 	mov	w5, #0x0                   	// #0
  40b16c:	f947cc21 	ldr	x1, [x1, #3992]
  40b170:	911b84c6 	add	x6, x6, #0x6e1
  40b174:	d2800004 	mov	x4, #0x0                   	// #0
  40b178:	d2800003 	mov	x3, #0x0                   	// #0
  40b17c:	52800022 	mov	w2, #0x1                   	// #1
  40b180:	52800000 	mov	w0, #0x0                   	// #0
  40b184:	97ffffab 	bl	40b030 <z_log_msg_runtime_create.constprop.0>

out:
    k_sem_give(&ts->lock);

    return ret;
}
  40b188:	2a1403e0 	mov	w0, w20
  40b18c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b190:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b194:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b198:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40b19c:	d65f03c0 	ret
    ts->rsp_size = buf_size;
  40b1a0:	a905da77 	stp	x23, x22, [x19, #88]
    ts->rsp_pos = 0;
  40b1a4:	f900367f 	str	xzr, [x19, #104]
    switch (format) {
  40b1a8:	71000a9f 	cmp	w20, #0x2
  40b1ac:	540000e0 	b.eq	40b1c8 <thingset_export_item+0xa8>  // b.none
  40b1b0:	71001a9f 	cmp	w20, #0x6
  40b1b4:	54000280 	b.eq	40b204 <thingset_export_item+0xe4>  // b.none
  40b1b8:	12801814 	mov	w20, #0xffffff3f            	// #-193
	z_impl_k_sem_give(sem);
  40b1bc:	aa1803e0 	mov	x0, x24
  40b1c0:	94001497 	bl	41041c <z_impl_k_sem_give>
}
  40b1c4:	17fffff1 	b	40b188 <thingset_export_item+0x68>
            thingset_txt_setup(ts);
  40b1c8:	aa1303e0 	mov	x0, x19
  40b1cc:	9400090b 	bl	40d5f8 <thingset_txt_setup>
    ret = ts->api->serialize_value(ts, obj);
  40b1d0:	f9403a60 	ldr	x0, [x19, #112]
  40b1d4:	aa1503e1 	mov	x1, x21
  40b1d8:	f9400802 	ldr	x2, [x0, #16]
  40b1dc:	aa1303e0 	mov	x0, x19
  40b1e0:	d63f0040 	blr	x2
  40b1e4:	2a0003f4 	mov	w20, w0
    ts->api->serialize_finish(ts);
  40b1e8:	f9403a60 	ldr	x0, [x19, #112]
  40b1ec:	f9402c01 	ldr	x1, [x0, #88]
  40b1f0:	aa1303e0 	mov	x0, x19
  40b1f4:	d63f0020 	blr	x1
    if (ret == 0) {
  40b1f8:	35fffe34 	cbnz	w20, 40b1bc <thingset_export_item+0x9c>
        ret = ts->rsp_pos;
  40b1fc:	b9406a74 	ldr	w20, [x19, #104]
  40b200:	17ffffef 	b	40b1bc <thingset_export_item+0x9c>
            ts->endpoint.use_ids = true;
  40b204:	52800020 	mov	w0, #0x1                   	// #1
  40b208:	390f1260 	strb	w0, [x19, #964]
            thingset_bin_setup(ts, 0);
  40b20c:	d2800001 	mov	x1, #0x0                   	// #0
  40b210:	aa1303e0 	mov	x0, x19
  40b214:	940003c5 	bl	40c128 <thingset_bin_setup>
            break;
  40b218:	17ffffee 	b	40b1d0 <thingset_export_item+0xb0>

000000000040b21c <thingset_iterate_subsets>:
{
    if (start_obj == NULL) {
        start_obj = ts->data_objects;
    }

    struct thingset_data_object *end_obj = ts->data_objects + ts->num_objects;
  40b21c:	a9400c04 	ldp	x4, x3, [x0]
        start_obj = ts->data_objects;
  40b220:	f100005f 	cmp	x2, #0x0
{
  40b224:	12003c21 	and	w1, w1, #0xffff
    struct thingset_data_object *end_obj = ts->data_objects + ts->num_objects;
  40b228:	8b031483 	add	x3, x4, x3, lsl #5
    for (struct thingset_data_object *obj = start_obj; obj < end_obj; obj++) {
  40b22c:	9a841040 	csel	x0, x2, x4, ne  // ne = any
  40b230:	eb03001f 	cmp	x0, x3
  40b234:	54000063 	b.cc	40b240 <thingset_iterate_subsets+0x24>  // b.lo, b.ul, b.last
        if (obj->subsets & subset) {
            return obj;
        }
    }

    return NULL;
  40b238:	d2800000 	mov	x0, #0x0                   	// #0
}
  40b23c:	d65f03c0 	ret
        if (obj->subsets & subset) {
  40b240:	f9400c02 	ldr	x2, [x0, #24]
  40b244:	6a42643f 	tst	w1, w2, lsr #25
  40b248:	54ffffa1 	b.ne	40b23c <thingset_iterate_subsets+0x20>  // b.any
    for (struct thingset_data_object *obj = start_obj; obj < end_obj; obj++) {
  40b24c:	91008000 	add	x0, x0, #0x20
  40b250:	17fffff8 	b	40b230 <thingset_iterate_subsets+0x14>

000000000040b254 <thingset_get_child_by_name>:
}

struct thingset_data_object *thingset_get_child_by_name(struct thingset_context *ts,
                                                        uint16_t parent_id, const char *name,
                                                        size_t len)
{
  40b254:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b258:	910003fd 	mov	x29, sp
  40b25c:	a90153f3 	stp	x19, x20, [sp, #16]
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40b260:	52800014 	mov	w20, #0x0                   	// #0
{
  40b264:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b268:	aa0003f5 	mov	x21, x0
  40b26c:	aa0303f6 	mov	x22, x3
  40b270:	a90363f7 	stp	x23, x24, [sp, #48]
  40b274:	aa0203f7 	mov	x23, x2
  40b278:	a9046bf9 	stp	x25, x26, [sp, #64]
  40b27c:	12003c3a 	and	w26, w1, #0xffff
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40b280:	f9400419 	ldr	x25, [x0, #8]
  40b284:	2a1403f3 	mov	w19, w20
  40b288:	eb34433f 	cmp	x25, w20, uxtw
  40b28c:	54000128 	b.hi	40b2b0 <thingset_get_child_by_name+0x5c>  // b.pmore
        {
            return &(ts->data_objects[i]);
        }
    }

    return NULL;
  40b290:	d2800013 	mov	x19, #0x0                   	// #0
}
  40b294:	aa1303e0 	mov	x0, x19
  40b298:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b29c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b2a0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b2a4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40b2a8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40b2ac:	d65f03c0 	ret
        if (ts->data_objects[i].parent_id == parent_id
  40b2b0:	f94002a0 	ldr	x0, [x21]
  40b2b4:	d37bea61 	lsl	x1, x19, #5
  40b2b8:	8b131413 	add	x19, x0, x19, lsl #5
  40b2bc:	78616800 	ldrh	w0, [x0, x1]
  40b2c0:	6b1a001f 	cmp	w0, w26
  40b2c4:	54000161 	b.ne	40b2f0 <thingset_get_child_by_name+0x9c>  // b.any
            && strncmp(ts->data_objects[i].name, name, len) == 0
  40b2c8:	f9400678 	ldr	x24, [x19, #8]
  40b2cc:	aa1603e2 	mov	x2, x22
  40b2d0:	aa1703e1 	mov	x1, x23
  40b2d4:	aa1803e0 	mov	x0, x24
  40b2d8:	97ffd84e 	bl	401410 <strncmp@plt>
  40b2dc:	350000a0 	cbnz	w0, 40b2f0 <thingset_get_child_by_name+0x9c>
            && strlen(ts->data_objects[i].name) == len)
  40b2e0:	aa1803e0 	mov	x0, x24
  40b2e4:	97ffd807 	bl	401300 <strlen@plt>
  40b2e8:	eb16001f 	cmp	x0, x22
  40b2ec:	54fffd40 	b.eq	40b294 <thingset_get_child_by_name+0x40>  // b.none
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40b2f0:	11000694 	add	w20, w20, #0x1
  40b2f4:	17ffffe4 	b	40b284 <thingset_get_child_by_name+0x30>

000000000040b2f8 <thingset_get_object_by_id>:

struct thingset_data_object *thingset_get_object_by_id(struct thingset_context *ts, uint16_t id)
{
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40b2f8:	f9400405 	ldr	x5, [x0, #8]
{
  40b2fc:	aa0003e4 	mov	x4, x0
  40b300:	12003c21 	and	w1, w1, #0xffff
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40b304:	52800003 	mov	w3, #0x0                   	// #0
  40b308:	2a0303e2 	mov	w2, w3
  40b30c:	eb2340bf 	cmp	x5, w3, uxtw
  40b310:	54000068 	b.hi	40b31c <thingset_get_object_by_id+0x24>  // b.pmore
        if (ts->data_objects[i].id == id) {
            return &(ts->data_objects[i]);
        }
    }

    return NULL;
  40b314:	d2800000 	mov	x0, #0x0                   	// #0
}
  40b318:	d65f03c0 	ret
        if (ts->data_objects[i].id == id) {
  40b31c:	f9400080 	ldr	x0, [x4]
  40b320:	8b021400 	add	x0, x0, x2, lsl #5
  40b324:	79400402 	ldrh	w2, [x0, #2]
  40b328:	6b01005f 	cmp	w2, w1
  40b32c:	54ffff60 	b.eq	40b318 <thingset_get_object_by_id+0x20>  // b.none
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40b330:	11000463 	add	w3, w3, #0x1
  40b334:	17fffff5 	b	40b308 <thingset_get_object_by_id+0x10>

000000000040b338 <thingset_get_path>:
    return -THINGSET_ERR_NOT_FOUND;
}

int thingset_get_path(struct thingset_context *ts, char *buf, size_t size,
                      const struct thingset_data_object *obj)
{
  40b338:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40b33c:	910003fd 	mov	x29, sp
  40b340:	a90153f3 	stp	x19, x20, [sp, #16]
  40b344:	aa0103f4 	mov	x20, x1
  40b348:	aa0203f3 	mov	x19, x2
  40b34c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b350:	aa0303f6 	mov	x22, x3
    int pos = 0;
    if (obj->parent_id != 0) {
  40b354:	79400061 	ldrh	w1, [x3]
  40b358:	34000361 	cbz	w1, 40b3c4 <thingset_get_path+0x8c>
  40b35c:	aa0003f5 	mov	x21, x0
        struct thingset_data_object *parent_obj = thingset_get_object_by_id(ts, obj->parent_id);
  40b360:	97ffffe6 	bl	40b2f8 <thingset_get_object_by_id>
  40b364:	aa0003e3 	mov	x3, x0
        if (parent_obj == NULL) {
  40b368:	b4000320 	cbz	x0, 40b3cc <thingset_get_path+0x94>

        /*
         * Recursive implementation acceptable because the depth is automatically limited by actual
         * data structure nesting depth.
         */
        pos = thingset_get_path(ts, buf, size, parent_obj);
  40b36c:	aa1303e2 	mov	x2, x19
  40b370:	aa1403e1 	mov	x1, x20
  40b374:	aa1503e0 	mov	x0, x21
  40b378:	97fffff0 	bl	40b338 <thingset_get_path>
        if (pos < 0) {
  40b37c:	37f801c0 	tbnz	w0, #31, 40b3b4 <thingset_get_path+0x7c>
            /* propagate errors back */
            return pos;
        }
        buf[pos++] = '/';
  40b380:	11000415 	add	w21, w0, #0x1
  40b384:	528005e1 	mov	w1, #0x2f                  	// #47
  40b388:	3820ca81 	strb	w1, [x20, w0, sxtw]
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40b38c:	f94006c3 	ldr	x3, [x22, #8]
  40b390:	cb35c261 	sub	x1, x19, w21, sxtw
  40b394:	8b35c280 	add	x0, x20, w21, sxtw
  40b398:	b0000042 	adrp	x2, 414000 <sys_clock_tick_get+0x78>
  40b39c:	9122b042 	add	x2, x2, #0x8ac
  40b3a0:	97ffd800 	bl	4013a0 <snprintf@plt>
    }

    pos += snprintf(buf + pos, size - pos, "%s", obj->name);
  40b3a4:	0b0002a0 	add	w0, w21, w0

    if (pos < size) {
        return pos;
    }
    else {
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b3a8:	12801c01 	mov	w1, #0xffffff1f            	// #-225
  40b3ac:	eb20c27f 	cmp	x19, w0, sxtw
  40b3b0:	1a818000 	csel	w0, w0, w1, hi  // hi = pmore
    }
}
  40b3b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b3b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b3bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b3c0:	d65f03c0 	ret
    int pos = 0;
  40b3c4:	52800015 	mov	w21, #0x0                   	// #0
  40b3c8:	17fffff1 	b	40b38c <thingset_get_path+0x54>
            return -THINGSET_ERR_NOT_FOUND;
  40b3cc:	12801460 	mov	w0, #0xffffff5c            	// #-164
  40b3d0:	17fffff9 	b	40b3b4 <thingset_get_path+0x7c>

000000000040b3d4 <bin_serialize_finish>:
    return zcbor_list_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
}

static void bin_serialize_finish(struct thingset_context *ts)
{
    ts->rsp_pos = ts->encoder->payload - ts->rsp;
  40b3d4:	f9402c02 	ldr	x2, [x0, #88]
  40b3d8:	f9403c01 	ldr	x1, [x0, #120]
  40b3dc:	cb020023 	sub	x3, x1, x2
  40b3e0:	f9003403 	str	x3, [x0, #104]
    if (ts->rsp_pos == 2 && ts->rsp[1] == 0xF6) {
  40b3e4:	f100087f 	cmp	x3, #0x2
  40b3e8:	54000101 	b.ne	40b408 <bin_serialize_finish+0x34>  // b.any
  40b3ec:	39400442 	ldrb	w2, [x2, #1]
  40b3f0:	7103d85f 	cmp	w2, #0xf6
  40b3f4:	540000a1 	b.ne	40b408 <bin_serialize_finish+0x34>  // b.any
        /* message with empty payload */
        ts->rsp[ts->rsp_pos++] = 0xF6;
  40b3f8:	d2800062 	mov	x2, #0x3                   	// #3
  40b3fc:	f9003402 	str	x2, [x0, #104]
  40b400:	12800120 	mov	w0, #0xfffffff6            	// #-10
  40b404:	39000020 	strb	w0, [x1]
    }
}
  40b408:	d65f03c0 	ret

000000000040b40c <bin_deserialize_finish>:
    return err;
}

static int bin_deserialize_finish(struct thingset_context *ts)
{
    return ts->decoder->payload_end == ts->decoder->payload ? 0 : -THINGSET_ERR_BAD_REQUEST;
  40b40c:	f940a801 	ldr	x1, [x0, #336]
  40b410:	f9409c00 	ldr	x0, [x0, #312]
  40b414:	eb00003f 	cmp	x1, x0
}
  40b418:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40b41c:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40b420:	d65f03c0 	ret

000000000040b424 <bin_serialize_response>:
{
  40b424:	a9aa7bfd 	stp	x29, x30, [sp, #-352]!
  40b428:	910003fd 	mov	x29, sp
  40b42c:	a90153f3 	stp	x19, x20, [sp, #16]
  40b430:	aa0003f3 	mov	x19, x0
  40b434:	b0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40b438:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b43c:	12001c34 	and	w20, w1, #0xff
  40b440:	aa0203f5 	mov	x21, x2
  40b444:	f9478400 	ldr	x0, [x0, #3848]
  40b448:	f9001bf7 	str	x23, [sp, #48]
  40b44c:	3d802fe0 	str	q0, [sp, #176]
    zcbor_update_state(ts->encoder, ts->rsp + 1, ts->rsp_size - 1);
  40b450:	9101e276 	add	x22, x19, #0x78
{
  40b454:	3d8033e1 	str	q1, [sp, #192]
  40b458:	3d8037e2 	str	q2, [sp, #208]
  40b45c:	3d803be3 	str	q3, [sp, #224]
  40b460:	3d803fe4 	str	q4, [sp, #240]
  40b464:	3d8043e5 	str	q5, [sp, #256]
  40b468:	3d8047e6 	str	q6, [sp, #272]
  40b46c:	3d804be7 	str	q7, [sp, #288]
  40b470:	a91393e3 	stp	x3, x4, [sp, #312]
  40b474:	a9149be5 	stp	x5, x6, [sp, #328]
  40b478:	f900afe7 	str	x7, [sp, #344]
  40b47c:	f9400001 	ldr	x1, [x0]
  40b480:	f90057e1 	str	x1, [sp, #168]
  40b484:	d2800001 	mov	x1, #0x0                   	// #0
    ts->rsp[0] = code;
  40b488:	f9402e60 	ldr	x0, [x19, #88]
  40b48c:	39000014 	strb	w20, [x0]
    zcbor_update_state(ts->encoder, ts->rsp + 1, ts->rsp_size - 1);
  40b490:	aa1603e0 	mov	x0, x22
  40b494:	a9458a61 	ldp	x1, x2, [x19, #88]
  40b498:	d1000442 	sub	x2, x2, #0x1
  40b49c:	91000421 	add	x1, x1, #0x1
  40b4a0:	940008da 	bl	40d808 <zcbor_update_state>
    zcbor_nil_put(ts->encoder, NULL);
  40b4a4:	aa1603e0 	mov	x0, x22
  40b4a8:	d2800001 	mov	x1, #0x0                   	// #0
  40b4ac:	94000c80 	bl	40e6ac <zcbor_nil_put>
    if (THINGSET_ERROR(code)) {
  40b4b0:	71027e9f 	cmp	w20, #0x9f
  40b4b4:	54000429 	b.ls	40b538 <bin_serialize_response+0x114>  // b.plast
        if (msg != NULL) {
  40b4b8:	b4000415 	cbz	x21, 40b538 <bin_serialize_response+0x114>
            va_start(vargs, msg);
  40b4bc:	910583e0 	add	x0, sp, #0x160
  40b4c0:	a90683e0 	stp	x0, x0, [sp, #104]
  40b4c4:	9104c3e0 	add	x0, sp, #0x130
  40b4c8:	f9003fe0 	str	x0, [sp, #120]
  40b4cc:	128004e0 	mov	w0, #0xffffffd8            	// #-40
  40b4d0:	b90083e0 	str	w0, [sp, #128]
  40b4d4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40b4d8:	b90087e0 	str	w0, [sp, #132]
  40b4dc:	9101a3e0 	add	x0, sp, #0x68
            uint8_t *msg_buf_start = ts->encoder->payload_mut + 2;
  40b4e0:	f9403e74 	ldr	x20, [x19, #120]
  40b4e4:	910223f7 	add	x23, sp, #0x88
  40b4e8:	ad400400 	ldp	q0, q1, [x0]
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40b4ec:	910103e5 	add	x5, sp, #0x40
            size_t msg_buf_size = ts->encoder->payload_end - msg_buf_start;
  40b4f0:	f9404a73 	ldr	x19, [x19, #144]
            uint8_t *msg_buf_start = ts->encoder->payload_mut + 2;
  40b4f4:	91000a94 	add	x20, x20, #0x2
            size_t msg_buf_size = ts->encoder->payload_end - msg_buf_start;
  40b4f8:	ad0006e0 	stp	q0, q1, [x23]
  40b4fc:	aa1503e4 	mov	x4, x21
  40b500:	cb140273 	sub	x19, x19, x20
  40b504:	aa1303e1 	mov	x1, x19
  40b508:	aa1403e0 	mov	x0, x20
  40b50c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40b510:	52800022 	mov	w2, #0x1                   	// #1
  40b514:	ad0004a0 	stp	q0, q1, [x5]
  40b518:	97ffd7b2 	bl	4013e0 <__vsnprintf_chk@plt>
            if (ret >= 0 && ret < msg_buf_size) {
  40b51c:	37f800e0 	tbnz	w0, #31, 40b538 <bin_serialize_response+0x114>
  40b520:	eb20c27f 	cmp	x19, w0, sxtw
  40b524:	540000a9 	b.ls	40b538 <bin_serialize_response+0x114>  // b.plast
}
static inline bool zcbor_tstr_encode_ptr(zcbor_state_t *state, const char *ptr, size_t len)
{
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };

	return zcbor_tstr_encode(state, &zs);
  40b528:	aa1703e1 	mov	x1, x23
  40b52c:	aa1603e0 	mov	x0, x22
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };
  40b530:	a908cff4 	stp	x20, x19, [sp, #136]
	return zcbor_tstr_encode(state, &zs);
  40b534:	94000c4b 	bl	40e660 <zcbor_tstr_encode>
}
  40b538:	b0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40b53c:	f9478400 	ldr	x0, [x0, #3848]
  40b540:	f94057e2 	ldr	x2, [sp, #168]
  40b544:	f9400001 	ldr	x1, [x0]
  40b548:	eb010042 	subs	x2, x2, x1
  40b54c:	d2800001 	mov	x1, #0x0                   	// #0
  40b550:	54000040 	b.eq	40b558 <bin_serialize_response+0x134>  // b.none
  40b554:	97ffd7d7 	bl	4014b0 <__stack_chk_fail@plt>
  40b558:	52800000 	mov	w0, #0x0                   	// #0
  40b55c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b560:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b564:	f9401bf7 	ldr	x23, [sp, #48]
  40b568:	a8d67bfd 	ldp	x29, x30, [sp], #352
  40b56c:	d65f03c0 	ret

000000000040b570 <bin_deserialize_payload_reset>:
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg_payload,
  40b570:	a9438c01 	ldp	x1, x3, [x0, #56]
  40b574:	d2800024 	mov	x4, #0x1                   	// #1
  40b578:	f9402802 	ldr	x2, [x0, #80]
  40b57c:	9104e000 	add	x0, x0, #0x138
                           ts->msg_len - (ts->msg_payload - ts->msg), 1);
  40b580:	cb010041 	sub	x1, x2, x1
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg_payload,
  40b584:	cb010063 	sub	x3, x3, x1
  40b588:	d2800081 	mov	x1, #0x4                   	// #4
  40b58c:	14000acf 	b	40e0c8 <zcbor_new_decode_state>

000000000040b590 <bin_deserialize_list_start>:
{
  40b590:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_list_start_decode(ts->decoder) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b594:	9104e000 	add	x0, x0, #0x138
{
  40b598:	910003fd 	mov	x29, sp
    return zcbor_list_start_decode(ts->decoder) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b59c:	94000a3d 	bl	40de90 <zcbor_list_start_decode>
  40b5a0:	72001c1f 	tst	w0, #0xff
}
  40b5a4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b5a8:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40b5ac:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40b5b0:	d65f03c0 	ret

000000000040b5b4 <bin_deserialize_string>:
{
  40b5b4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    if (zcbor_tstr_decode(ts->decoder, &str) == true) {
  40b5b8:	9104e000 	add	x0, x0, #0x138
{
  40b5bc:	910003fd 	mov	x29, sp
  40b5c0:	a90153f3 	stp	x19, x20, [sp, #16]
  40b5c4:	aa0103f4 	mov	x20, x1
  40b5c8:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40b5cc:	aa0203f3 	mov	x19, x2
  40b5d0:	f9478421 	ldr	x1, [x1, #3848]
  40b5d4:	f9400022 	ldr	x2, [x1]
  40b5d8:	f9001fe2 	str	x2, [sp, #56]
  40b5dc:	d2800002 	mov	x2, #0x0                   	// #0
    if (zcbor_tstr_decode(ts->decoder, &str) == true) {
  40b5e0:	9100a3e1 	add	x1, sp, #0x28
  40b5e4:	94000a29 	bl	40de88 <zcbor_tstr_decode>
  40b5e8:	72001c1f 	tst	w0, #0xff
  40b5ec:	540001c0 	b.eq	40b624 <bin_deserialize_string+0x70>  // b.none
        *str_start = str.value;
  40b5f0:	f94017e0 	ldr	x0, [sp, #40]
  40b5f4:	f9000280 	str	x0, [x20]
        *str_len = str.len;
  40b5f8:	f9401be0 	ldr	x0, [sp, #48]
  40b5fc:	f9000260 	str	x0, [x19]
        return 0;
  40b600:	52800000 	mov	w0, #0x0                   	// #0
}
  40b604:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40b608:	f9478421 	ldr	x1, [x1, #3848]
  40b60c:	f9401fe3 	ldr	x3, [sp, #56]
  40b610:	f9400022 	ldr	x2, [x1]
  40b614:	eb020063 	subs	x3, x3, x2
  40b618:	d2800002 	mov	x2, #0x0                   	// #0
  40b61c:	54000080 	b.eq	40b62c <bin_deserialize_string+0x78>  // b.none
  40b620:	97ffd7a4 	bl	4014b0 <__stack_chk_fail@plt>
        return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b624:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40b628:	17fffff7 	b	40b604 <bin_deserialize_string+0x50>
}
  40b62c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b630:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40b634:	d65f03c0 	ret

000000000040b638 <bin_deserialize_simple_value>:
{
  40b638:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b63c:	910003fd 	mov	x29, sp
  40b640:	a90153f3 	stp	x19, x20, [sp, #16]
  40b644:	aa0103f4 	mov	x20, x1
  40b648:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40b64c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b650:	2a0303f5 	mov	w21, w3
  40b654:	f9478421 	ldr	x1, [x1, #3848]
  40b658:	f9400023 	ldr	x3, [x1]
  40b65c:	f90027e3 	str	x3, [sp, #72]
  40b660:	d2800003 	mov	x3, #0x0                   	// #0
    if (ts->decoder->payload_end == ts->decoder->payload) {
  40b664:	f9409c01 	ldr	x1, [x0, #312]
  40b668:	f940a803 	ldr	x3, [x0, #336]
  40b66c:	eb01007f 	cmp	x3, x1
  40b670:	540009c0 	b.eq	40b7a8 <bin_deserialize_simple_value+0x170>  // b.none
    switch (type) {
  40b674:	71002c5f 	cmp	w2, #0xb
  40b678:	54000188 	b.hi	40b6a8 <bin_deserialize_simple_value+0x70>  // b.pmore
  40b67c:	b0000041 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  40b680:	91212021 	add	x1, x1, #0x848
  40b684:	38624821 	ldrb	w1, [x1, w2, uxtw]
  40b688:	10000062 	adr	x2, 40b694 <bin_deserialize_simple_value+0x5c>
  40b68c:	8b218841 	add	x1, x2, w1, sxtb #2
  40b690:	d61f0020 	br	x1
            success = zcbor_uint32_decode(ts->decoder, data.u32);
  40b694:	aa1403e1 	mov	x1, x20
  40b698:	9104e000 	add	x0, x0, #0x138
  40b69c:	940009f9 	bl	40de80 <zcbor_uint32_decode>
            success = zcbor_bool_decode(ts->decoder, data.b);
  40b6a0:	12001c00 	and	w0, w0, #0xff
    return success ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b6a4:	35000360 	cbnz	w0, 40b710 <bin_deserialize_simple_value+0xd8>
    switch (type) {
  40b6a8:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40b6ac:	1400001a 	b	40b714 <bin_deserialize_simple_value+0xdc>
            success = zcbor_int32_decode(ts->decoder, data.i32);
  40b6b0:	aa1403e1 	mov	x1, x20
  40b6b4:	9104e000 	add	x0, x0, #0x138
  40b6b8:	940009df 	bl	40de34 <zcbor_int32_decode>
  40b6bc:	17fffff9 	b	40b6a0 <bin_deserialize_simple_value+0x68>
            success = zcbor_uint_decode(ts->decoder, data.u16, 2);
  40b6c0:	d2800042 	mov	x2, #0x2                   	// #2
            success = zcbor_uint_decode(ts->decoder, data.u8, 1);
  40b6c4:	aa1403e1 	mov	x1, x20
  40b6c8:	9104e000 	add	x0, x0, #0x138
  40b6cc:	940009dc 	bl	40de3c <zcbor_uint_decode>
  40b6d0:	17fffff4 	b	40b6a0 <bin_deserialize_simple_value+0x68>
            success = zcbor_int_decode(ts->decoder, data.i16, 2);
  40b6d4:	d2800042 	mov	x2, #0x2                   	// #2
            success = zcbor_int_decode(ts->decoder, data.i8, 1);
  40b6d8:	aa1403e1 	mov	x1, x20
  40b6dc:	9104e000 	add	x0, x0, #0x138
  40b6e0:	940009a4 	bl	40dd70 <zcbor_int_decode>
  40b6e4:	17ffffef 	b	40b6a0 <bin_deserialize_simple_value+0x68>
            success = zcbor_uint_decode(ts->decoder, data.u8, 1);
  40b6e8:	d2800022 	mov	x2, #0x1                   	// #1
  40b6ec:	17fffff6 	b	40b6c4 <bin_deserialize_simple_value+0x8c>
            success = zcbor_int_decode(ts->decoder, data.i8, 1);
  40b6f0:	d2800022 	mov	x2, #0x1                   	// #1
  40b6f4:	17fffff9 	b	40b6d8 <bin_deserialize_simple_value+0xa0>
            success = zcbor_float32_decode(ts->decoder, data.f32);
  40b6f8:	9104e013 	add	x19, x0, #0x138
  40b6fc:	aa1403e1 	mov	x1, x20
  40b700:	aa1303e0 	mov	x0, x19
  40b704:	94000a61 	bl	40e088 <zcbor_float32_decode>
            if (!success) {
  40b708:	72001c1f 	tst	w0, #0xff
  40b70c:	54000140 	b.eq	40b734 <bin_deserialize_simple_value+0xfc>  // b.none
    return success ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b710:	52800000 	mov	w0, #0x0                   	// #0
}
  40b714:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40b718:	f9478421 	ldr	x1, [x1, #3848]
  40b71c:	f94027e3 	ldr	x3, [sp, #72]
  40b720:	f9400022 	ldr	x2, [x1]
  40b724:	eb020063 	subs	x3, x3, x2
  40b728:	d2800002 	mov	x2, #0x0                   	// #0
  40b72c:	54000420 	b.eq	40b7b0 <bin_deserialize_simple_value+0x178>  // b.none
  40b730:	97ffd760 	bl	4014b0 <__stack_chk_fail@plt>
                if (zcbor_int32_decode(ts->decoder, &tmp) == true) {
  40b734:	9100e3e1 	add	x1, sp, #0x38
  40b738:	aa1303e0 	mov	x0, x19
  40b73c:	940009be 	bl	40de34 <zcbor_int32_decode>
  40b740:	72001c1f 	tst	w0, #0xff
  40b744:	54fffb20 	b.eq	40b6a8 <bin_deserialize_simple_value+0x70>  // b.none
                    *data.f32 = tmp;
  40b748:	bd403be0 	ldr	s0, [sp, #56]
  40b74c:	5e21d800 	scvtf	s0, s0
  40b750:	bd000280 	str	s0, [x20]
  40b754:	17ffffef 	b	40b710 <bin_deserialize_simple_value+0xd8>
            success = zcbor_bool_decode(ts->decoder, data.b);
  40b758:	aa1403e1 	mov	x1, x20
  40b75c:	9104e000 	add	x0, x0, #0x138
  40b760:	94000a24 	bl	40dff0 <zcbor_bool_decode>
  40b764:	17ffffcf 	b	40b6a0 <bin_deserialize_simple_value+0x68>
  40b768:	12001c96 	and	w22, w4, #0xff
            success = zcbor_tstr_decode(ts->decoder, &str);
  40b76c:	9100e3e1 	add	x1, sp, #0x38
  40b770:	9104e000 	add	x0, x0, #0x138
  40b774:	940009c5 	bl	40de88 <zcbor_tstr_decode>
            if (success && str.len < detail) {
  40b778:	72001c1f 	tst	w0, #0xff
  40b77c:	54fff960 	b.eq	40b6a8 <bin_deserialize_simple_value+0x70>  // b.none
  40b780:	f94023f3 	ldr	x19, [sp, #64]
  40b784:	eb35c27f 	cmp	x19, w21, sxtw
  40b788:	54fff902 	b.cs	40b6a8 <bin_deserialize_simple_value+0x70>  // b.hs, b.nlast
                if (!check_only) {
  40b78c:	35fffc36 	cbnz	w22, 40b710 <bin_deserialize_simple_value+0xd8>

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len,
  40b790:	f9401fe1 	ldr	x1, [sp, #56]
  40b794:	aa1303e2 	mov	x2, x19
  40b798:	aa1403e0 	mov	x0, x20
  40b79c:	97ffd791 	bl	4015e0 <strncpy@plt>
                    data.str[str.len] = '\0';
  40b7a0:	38336a9f 	strb	wzr, [x20, x19]
    return success ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b7a4:	17ffffdb 	b	40b710 <bin_deserialize_simple_value+0xd8>
        return -THINGSET_ERR_DESERIALIZATION_FINISHED;
  40b7a8:	12801de0 	mov	w0, #0xffffff10            	// #-240
  40b7ac:	17ffffda 	b	40b714 <bin_deserialize_simple_value+0xdc>
}
  40b7b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b7b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b7b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40b7bc:	d65f03c0 	ret

000000000040b7c0 <bin_deserialize_child>:
{
  40b7c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40b7c4:	910003fd 	mov	x29, sp
  40b7c8:	a90153f3 	stp	x19, x20, [sp, #16]
  40b7cc:	aa0003f3 	mov	x19, x0
  40b7d0:	b0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40b7d4:	f90013f5 	str	x21, [sp, #32]
  40b7d8:	aa0103f4 	mov	x20, x1
  40b7dc:	f9478400 	ldr	x0, [x0, #3848]
  40b7e0:	f9400001 	ldr	x1, [x0]
  40b7e4:	f90027e1 	str	x1, [sp, #72]
  40b7e8:	d2800001 	mov	x1, #0x0                   	// #0
    if (ts->decoder->payload_end == ts->decoder->payload) {
  40b7ec:	f9409e60 	ldr	x0, [x19, #312]
  40b7f0:	f940aa61 	ldr	x1, [x19, #336]
  40b7f4:	eb00003f 	cmp	x1, x0
  40b7f8:	540005e0 	b.eq	40b8b4 <bin_deserialize_child+0xf4>  // b.none
    if (zcbor_tstr_decode(ts->decoder, &name) == true) {
  40b7fc:	9104e275 	add	x21, x19, #0x138
  40b800:	9100e3e1 	add	x1, sp, #0x38
  40b804:	aa1503e0 	mov	x0, x21
  40b808:	940009a0 	bl	40de88 <zcbor_tstr_decode>
  40b80c:	72001c1f 	tst	w0, #0xff
  40b810:	54000260 	b.eq	40b85c <bin_deserialize_child+0x9c>  // b.none
        *object = thingset_get_child_by_name(ts, ts->endpoint.object->id, name.value, name.len);
  40b814:	f941de60 	ldr	x0, [x19, #952]
  40b818:	a9438fe2 	ldp	x2, x3, [sp, #56]
  40b81c:	79400401 	ldrh	w1, [x0, #2]
  40b820:	aa1303e0 	mov	x0, x19
  40b824:	97fffe8c 	bl	40b254 <thingset_get_child_by_name>
  40b828:	f9000280 	str	x0, [x20]
        if (*object == NULL) {
  40b82c:	b4000140 	cbz	x0, 40b854 <bin_deserialize_child+0x94>
    return 0;
  40b830:	52800000 	mov	w0, #0x0                   	// #0
}
  40b834:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40b838:	f9478421 	ldr	x1, [x1, #3848]
  40b83c:	f94027e3 	ldr	x3, [sp, #72]
  40b840:	f9400022 	ldr	x2, [x1]
  40b844:	eb020063 	subs	x3, x3, x2
  40b848:	d2800002 	mov	x2, #0x0                   	// #0
  40b84c:	54000380 	b.eq	40b8bc <bin_deserialize_child+0xfc>  // b.none
  40b850:	97ffd718 	bl	4014b0 <__stack_chk_fail@plt>
            return -THINGSET_ERR_NOT_FOUND;
  40b854:	12801460 	mov	w0, #0xffffff5c            	// #-164
  40b858:	17fffff7 	b	40b834 <bin_deserialize_child+0x74>
    else if (zcbor_uint32_decode(ts->decoder, &id) == true && id <= UINT16_MAX) {
  40b85c:	9100d3e1 	add	x1, sp, #0x34
  40b860:	aa1503e0 	mov	x0, x21
  40b864:	94000987 	bl	40de80 <zcbor_uint32_decode>
  40b868:	72001c1f 	tst	w0, #0xff
  40b86c:	54000200 	b.eq	40b8ac <bin_deserialize_child+0xec>  // b.none
  40b870:	b94037e1 	ldr	w1, [sp, #52]
  40b874:	529fffe0 	mov	w0, #0xffff                	// #65535
  40b878:	6b00003f 	cmp	w1, w0
  40b87c:	54000188 	b.hi	40b8ac <bin_deserialize_child+0xec>  // b.pmore
        *object = thingset_get_object_by_id(ts, id);
  40b880:	aa1303e0 	mov	x0, x19
  40b884:	97fffe9d 	bl	40b2f8 <thingset_get_object_by_id>
  40b888:	f9000280 	str	x0, [x20]
        if (*object == NULL) {
  40b88c:	b4fffe40 	cbz	x0, 40b854 <bin_deserialize_child+0x94>
        else if (ts->endpoint.object->id != THINGSET_ID_PATHS
  40b890:	f941de61 	ldr	x1, [x19, #952]
  40b894:	79400421 	ldrh	w1, [x1, #2]
  40b898:	71005c3f 	cmp	w1, #0x17
  40b89c:	54fffca0 	b.eq	40b830 <bin_deserialize_child+0x70>  // b.none
                 && (*object)->parent_id != ts->endpoint.object->id)
  40b8a0:	79400000 	ldrh	w0, [x0]
  40b8a4:	6b01001f 	cmp	w0, w1
  40b8a8:	54fffc40 	b.eq	40b830 <bin_deserialize_child+0x70>  // b.none
            return -THINGSET_ERR_BAD_REQUEST;
  40b8ac:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40b8b0:	17ffffe1 	b	40b834 <bin_deserialize_child+0x74>
        return -THINGSET_ERR_DESERIALIZATION_FINISHED;
  40b8b4:	12801de0 	mov	w0, #0xffffff10            	// #-240
  40b8b8:	17ffffdf 	b	40b834 <bin_deserialize_child+0x74>
}
  40b8bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b8c0:	f94013f5 	ldr	x21, [sp, #32]
  40b8c4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40b8c8:	d65f03c0 	ret

000000000040b8cc <bin_deserialize_map_start>:
{
  40b8cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_map_start_decode(ts->decoder) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b8d0:	9104e000 	add	x0, x0, #0x138
{
  40b8d4:	910003fd 	mov	x29, sp
    return zcbor_map_start_decode(ts->decoder) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b8d8:	94000970 	bl	40de98 <zcbor_map_start_decode>
  40b8dc:	72001c1f 	tst	w0, #0xff
}
  40b8e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b8e4:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40b8e8:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40b8ec:	d65f03c0 	ret

000000000040b8f0 <bin_deserialize_null>:
{
  40b8f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_nil_expect(ts->decoder, NULL) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b8f4:	d2800001 	mov	x1, #0x0                   	// #0
  40b8f8:	9104e000 	add	x0, x0, #0x138
{
  40b8fc:	910003fd 	mov	x29, sp
    return zcbor_nil_expect(ts->decoder, NULL) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40b900:	940009ba 	bl	40dfe8 <zcbor_nil_expect>
  40b904:	72001c1f 	tst	w0, #0xff
}
  40b908:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b90c:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40b910:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40b914:	d65f03c0 	ret

000000000040b918 <bin_serialize_report_header>:
{
  40b918:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    ts->rsp[0] = THINGSET_BIN_REPORT;
  40b91c:	528003e2 	mov	w2, #0x1f                  	// #31
    if (zcbor_uint32_put(ts->encoder, ts->endpoint.object->id)) {
  40b920:	9101e000 	add	x0, x0, #0x78
{
  40b924:	910003fd 	mov	x29, sp
    ts->rsp[0] = THINGSET_BIN_REPORT;
  40b928:	f85e0001 	ldur	x1, [x0, #-32]
  40b92c:	39000022 	strb	w2, [x1]
    if (zcbor_uint32_put(ts->encoder, ts->endpoint.object->id)) {
  40b930:	f941a001 	ldr	x1, [x0, #832]
  40b934:	79400421 	ldrh	w1, [x1, #2]
  40b938:	94000b42 	bl	40e640 <zcbor_uint32_put>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b93c:	72001c1f 	tst	w0, #0xff
}
  40b940:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b944:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40b948:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40b94c:	d65f03c0 	ret

000000000040b950 <bin_serialize_map_start>:
{
  40b950:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_map_start_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b954:	d2801fe1 	mov	x1, #0xff                  	// #255
  40b958:	9101e000 	add	x0, x0, #0x78
{
  40b95c:	910003fd 	mov	x29, sp
    return zcbor_map_start_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b960:	94000b44 	bl	40e670 <zcbor_map_start_encode>
  40b964:	72001c1f 	tst	w0, #0xff
}
  40b968:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b96c:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40b970:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40b974:	d65f03c0 	ret

000000000040b978 <bin_serialize_map_end>:
{
  40b978:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_map_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b97c:	d2801fe1 	mov	x1, #0xff                  	// #255
  40b980:	9101e000 	add	x0, x0, #0x78
{
  40b984:	910003fd 	mov	x29, sp
    return zcbor_map_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b988:	94000b3e 	bl	40e680 <zcbor_map_end_encode>
  40b98c:	72001c1f 	tst	w0, #0xff
}
  40b990:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b994:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40b998:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40b99c:	d65f03c0 	ret

000000000040b9a0 <bin_serialize_list_end>:
{
  40b9a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_list_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b9a4:	d2801fe1 	mov	x1, #0xff                  	// #255
  40b9a8:	9101e000 	add	x0, x0, #0x78
{
  40b9ac:	910003fd 	mov	x29, sp
    return zcbor_list_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b9b0:	94000b32 	bl	40e678 <zcbor_list_end_encode>
  40b9b4:	72001c1f 	tst	w0, #0xff
}
  40b9b8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b9bc:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40b9c0:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40b9c4:	d65f03c0 	ret

000000000040b9c8 <bin_serialize_list_start>:
{
  40b9c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_list_start_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b9cc:	d2801fe1 	mov	x1, #0xff                  	// #255
  40b9d0:	9101e000 	add	x0, x0, #0x78
{
  40b9d4:	910003fd 	mov	x29, sp
    return zcbor_list_start_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40b9d8:	94000b24 	bl	40e668 <zcbor_list_start_encode>
  40b9dc:	72001c1f 	tst	w0, #0xff
}
  40b9e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b9e4:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40b9e8:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40b9ec:	d65f03c0 	ret

000000000040b9f0 <bin_serialize_key_value>:
{
  40b9f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b9f4:	910003fd 	mov	x29, sp
  40b9f8:	a90153f3 	stp	x19, x20, [sp, #16]
  40b9fc:	aa0003f3 	mov	x19, x0
  40ba00:	aa0103f4 	mov	x20, x1
    int err = ts->api->serialize_key(ts, object);
  40ba04:	f9403802 	ldr	x2, [x0, #112]
  40ba08:	f9400442 	ldr	x2, [x2, #8]
  40ba0c:	d63f0040 	blr	x2
    if (err != 0) {
  40ba10:	35000120 	cbnz	w0, 40ba34 <bin_serialize_key_value+0x44>
    return ts->api->serialize_value(ts, object);
  40ba14:	f9403a60 	ldr	x0, [x19, #112]
  40ba18:	aa1403e1 	mov	x1, x20
  40ba1c:	f9400802 	ldr	x2, [x0, #16]
  40ba20:	aa1303e0 	mov	x0, x19
}
  40ba24:	a94153f3 	ldp	x19, x20, [sp, #16]
    return ts->api->serialize_value(ts, object);
  40ba28:	aa0203f0 	mov	x16, x2
}
  40ba2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    return ts->api->serialize_value(ts, object);
  40ba30:	d61f0200 	br	x16
}
  40ba34:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ba38:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40ba3c:	d65f03c0 	ret

000000000040ba40 <bin_serialize_subsets>:
{
  40ba40:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40ba44:	910003fd 	mov	x29, sp
  40ba48:	a9025bf5 	stp	x21, x22, [sp, #32]
    success = zcbor_map_start_encode(ts->encoder, UINT8_MAX);
  40ba4c:	9101e016 	add	x22, x0, #0x78
{
  40ba50:	a90153f3 	stp	x19, x20, [sp, #16]
  40ba54:	aa0003f3 	mov	x19, x0
    success = zcbor_map_start_encode(ts->encoder, UINT8_MAX);
  40ba58:	aa1603e0 	mov	x0, x22
{
  40ba5c:	f9001bf7 	str	x23, [sp, #48]
  40ba60:	12003c37 	and	w23, w1, #0xffff
    success = zcbor_map_start_encode(ts->encoder, UINT8_MAX);
  40ba64:	d2801fe1 	mov	x1, #0xff                  	// #255
  40ba68:	94000b02 	bl	40e670 <zcbor_map_start_encode>
  40ba6c:	12001c15 	and	w21, w0, #0xff
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40ba70:	52800014 	mov	w20, #0x0                   	// #0
  40ba74:	f9400660 	ldr	x0, [x19, #8]
  40ba78:	2a1403e1 	mov	w1, w20
  40ba7c:	eb34401f 	cmp	x0, w20, uxtw
  40ba80:	54000108 	b.hi	40baa0 <bin_serialize_subsets+0x60>  // b.pmore
    success = success && zcbor_map_end_encode(ts->encoder, UINT8_MAX);
  40ba84:	35000215 	cbnz	w21, 40bac4 <bin_serialize_subsets+0x84>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40ba88:	12801c00 	mov	w0, #0xffffff1f            	// #-225
}
  40ba8c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ba90:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ba94:	f9401bf7 	ldr	x23, [sp, #48]
  40ba98:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40ba9c:	d65f03c0 	ret
        if (ts->data_objects[i].subsets & subsets) {
  40baa0:	f9400260 	ldr	x0, [x19]
  40baa4:	8b011401 	add	x1, x0, x1, lsl #5
  40baa8:	f9400c20 	ldr	x0, [x1, #24]
  40baac:	6a4066ff 	tst	w23, w0, lsr #25
  40bab0:	54000060 	b.eq	40babc <bin_serialize_subsets+0x7c>  // b.none
            bin_serialize_key_value(ts, &ts->data_objects[i]);
  40bab4:	aa1303e0 	mov	x0, x19
  40bab8:	97ffffce 	bl	40b9f0 <bin_serialize_key_value>
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40babc:	11000694 	add	w20, w20, #0x1
  40bac0:	17ffffed 	b	40ba74 <bin_serialize_subsets+0x34>
    success = success && zcbor_map_end_encode(ts->encoder, UINT8_MAX);
  40bac4:	aa1603e0 	mov	x0, x22
  40bac8:	d2801fe1 	mov	x1, #0xff                  	// #255
  40bacc:	94000aed 	bl	40e680 <zcbor_map_end_encode>
    if (success) {
  40bad0:	72001c1f 	tst	w0, #0xff
  40bad4:	54fffda0 	b.eq	40ba88 <bin_serialize_subsets+0x48>  // b.none
        return 0;
  40bad8:	52800000 	mov	w0, #0x0                   	// #0
  40badc:	17ffffec 	b	40ba8c <bin_serialize_subsets+0x4c>

000000000040bae0 <bin_deserialize_value>:
{
  40bae0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  40bae4:	910003fd 	mov	x29, sp
  40bae8:	a90153f3 	stp	x19, x20, [sp, #16]
  40baec:	aa0103f4 	mov	x20, x1
  40baf0:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40baf4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40baf8:	aa0003f6 	mov	x22, x0
  40bafc:	f9478421 	ldr	x1, [x1, #3848]
  40bb00:	a90363f7 	stp	x23, x24, [sp, #48]
  40bb04:	12001c57 	and	w23, w2, #0xff
  40bb08:	a9046bf9 	stp	x25, x26, [sp, #64]
        bin_deserialize_simple_value(ts, object->data, object->type, object->detail, check_only);
  40bb0c:	2a1703e4 	mov	w4, w23
{
  40bb10:	f9400022 	ldr	x2, [x1]
  40bb14:	f90037e2 	str	x2, [sp, #104]
  40bb18:	d2800002 	mov	x2, #0x0                   	// #0
        bin_deserialize_simple_value(ts, object->data, object->type, object->detail, check_only);
  40bb1c:	a9410a81 	ldp	x1, x2, [x20, #16]
  40bb20:	93454043 	sbfx	x3, x2, #5, #12
  40bb24:	12001042 	and	w2, w2, #0x1f
  40bb28:	13003c63 	sxth	w3, w3
  40bb2c:	97fffec3 	bl	40b638 <bin_deserialize_simple_value>
  40bb30:	2a0003f3 	mov	w19, w0
    if (err == -THINGSET_ERR_UNSUPPORTED_FORMAT && object->type == THINGSET_TYPE_ARRAY) {
  40bb34:	3102bc1f 	cmn	w0, #0xaf
  40bb38:	540005c1 	b.ne	40bbf0 <bin_deserialize_value+0x110>  // b.any
  40bb3c:	b9401a80 	ldr	w0, [x20, #24]
  40bb40:	12001000 	and	w0, w0, #0x1f
  40bb44:	7100341f 	cmp	w0, #0xd
  40bb48:	54000541 	b.ne	40bbf0 <bin_deserialize_value+0x110>  // b.any
        success = zcbor_list_start_decode(ts->decoder);
  40bb4c:	9104e2d9 	add	x25, x22, #0x138
  40bb50:	aa1903e0 	mov	x0, x25
  40bb54:	f9400a94 	ldr	x20, [x20, #16]
  40bb58:	940008ce 	bl	40de90 <zcbor_list_start_decode>
        if (!success) {
  40bb5c:	72001c1f 	tst	w0, #0xff
  40bb60:	54000480 	b.eq	40bbf0 <bin_deserialize_value+0x110>  // b.none
/**
 * Helper function to determine the size of above ThingSet types in bytes
 */
static inline size_t thingset_type_size(uint8_t type)
{
    uint8_t sizes[] = { sizeof(bool),    sizeof(uint8_t),  sizeof(int8_t),  sizeof(uint16_t),
  40bb64:	f0000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40bb68:	911c4421 	add	x1, x1, #0x711
        size_t type_size = thingset_type_size(array->element_type);
  40bb6c:	b9400a80 	ldr	w0, [x20, #8]
  40bb70:	910163e2 	add	x2, sp, #0x58
  40bb74:	f9400023 	ldr	x3, [x1]
  40bb78:	f9002fe3 	str	x3, [sp, #88]
  40bb7c:	b8407021 	ldur	w1, [x1, #7]
  40bb80:	b805f3e1 	stur	w1, [sp, #95]
                        sizeof(int16_t), sizeof(uint32_t), sizeof(int32_t), sizeof(uint64_t),
                        sizeof(int64_t), sizeof(float),    sizeof(int32_t) };
    return type < sizeof(sizes) ? sizes[type] : 0;
  40bb84:	12001c01 	and	w1, w0, #0xff
  40bb88:	7100283f 	cmp	w1, #0xa
  40bb8c:	54000428 	b.hi	40bc10 <bin_deserialize_value+0x130>  // b.pmore
  40bb90:	92401c00 	and	x0, x0, #0xff
  40bb94:	3860685a 	ldrb	w26, [x2, x0]
        int index = 0;
  40bb98:	d2800018 	mov	x24, #0x0                   	// #0
  40bb9c:	52800015 	mov	w21, #0x0                   	// #0
            err = bin_deserialize_simple_value(ts, data, array->element_type, array->decimals,
  40bba0:	79c01a83 	ldrsh	w3, [x20, #12]
  40bba4:	2a1703e4 	mov	w4, w23
  40bba8:	b9400a82 	ldr	w2, [x20, #8]
  40bbac:	aa1603e0 	mov	x0, x22
            union thingset_data_pointer data = { .u8 = array->elements.u8 + index * type_size };
  40bbb0:	f9400281 	ldr	x1, [x20]
            err = bin_deserialize_simple_value(ts, data, array->element_type, array->decimals,
  40bbb4:	8b180021 	add	x1, x1, x24
  40bbb8:	97fffea0 	bl	40b638 <bin_deserialize_simple_value>
  40bbbc:	2a0003f3 	mov	w19, w0
            if (err != 0) {
  40bbc0:	350000c0 	cbnz	w0, 40bbd8 <bin_deserialize_value+0xf8>
        } while (index < array->num_elements);
  40bbc4:	79402280 	ldrh	w0, [x20, #16]
            index++;
  40bbc8:	110006b5 	add	w21, w21, #0x1
        } while (index < array->num_elements);
  40bbcc:	8b1a0318 	add	x24, x24, x26
  40bbd0:	6b0002bf 	cmp	w21, w0
  40bbd4:	54fffe6b 	b.lt	40bba0 <bin_deserialize_value+0xc0>  // b.tstop
        if (!check_only) {
  40bbd8:	35000057 	cbnz	w23, 40bbe0 <bin_deserialize_value+0x100>
            array->num_elements = index;
  40bbdc:	79002295 	strh	w21, [x20, #16]
        success = zcbor_list_end_decode(ts->decoder);
  40bbe0:	aa1903e0 	mov	x0, x25
  40bbe4:	940008c8 	bl	40df04 <zcbor_list_end_decode>
            err = 0;
  40bbe8:	72001c1f 	tst	w0, #0xff
  40bbec:	1a9f0273 	csel	w19, w19, wzr, eq  // eq = none
}
  40bbf0:	b0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40bbf4:	f9478400 	ldr	x0, [x0, #3848]
  40bbf8:	f94037e2 	ldr	x2, [sp, #104]
  40bbfc:	f9400001 	ldr	x1, [x0]
  40bc00:	eb010042 	subs	x2, x2, x1
  40bc04:	d2800001 	mov	x1, #0x0                   	// #0
  40bc08:	54000080 	b.eq	40bc18 <bin_deserialize_value+0x138>  // b.none
  40bc0c:	97ffd629 	bl	4014b0 <__stack_chk_fail@plt>
  40bc10:	d280001a 	mov	x26, #0x0                   	// #0
  40bc14:	17ffffe1 	b	40bb98 <bin_deserialize_value+0xb8>
  40bc18:	2a1303e0 	mov	w0, w19
  40bc1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bc20:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40bc24:	a94363f7 	ldp	x23, x24, [sp, #48]
  40bc28:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40bc2c:	a8c77bfd 	ldp	x29, x30, [sp], #112
  40bc30:	d65f03c0 	ret

000000000040bc34 <bin_serialize_key>:
{
  40bc34:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40bc38:	b0000102 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  40bc3c:	910003fd 	mov	x29, sp
  40bc40:	f9478442 	ldr	x2, [x2, #3848]
  40bc44:	a90153f3 	stp	x19, x20, [sp, #16]
        if (zcbor_uint32_put(ts->encoder, object->id) == false) {
  40bc48:	9101e013 	add	x19, x0, #0x78
    if (ts->endpoint.use_ids) {
  40bc4c:	394f1000 	ldrb	w0, [x0, #964]
{
  40bc50:	f9400043 	ldr	x3, [x2]
  40bc54:	f9001fe3 	str	x3, [sp, #56]
  40bc58:	d2800003 	mov	x3, #0x0                   	// #0
    if (ts->endpoint.use_ids) {
  40bc5c:	34000220 	cbz	w0, 40bca0 <bin_serialize_key+0x6c>
        if (zcbor_uint32_put(ts->encoder, object->id) == false) {
  40bc60:	79400421 	ldrh	w1, [x1, #2]
  40bc64:	aa1303e0 	mov	x0, x19
  40bc68:	94000a76 	bl	40e640 <zcbor_uint32_put>
  40bc6c:	72001c1f 	tst	w0, #0xff
  40bc70:	54000141 	b.ne	40bc98 <bin_serialize_key+0x64>  // b.any
            return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40bc74:	12801c00 	mov	w0, #0xffffff1f            	// #-225
}
  40bc78:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40bc7c:	f9478421 	ldr	x1, [x1, #3848]
  40bc80:	f9401fe3 	ldr	x3, [sp, #56]
  40bc84:	f9400022 	ldr	x2, [x1]
  40bc88:	eb020063 	subs	x3, x3, x2
  40bc8c:	d2800002 	mov	x2, #0x0                   	// #0
  40bc90:	54000180 	b.eq	40bcc0 <bin_serialize_key+0x8c>  // b.none
  40bc94:	97ffd607 	bl	4014b0 <__stack_chk_fail@plt>
    return 0;
  40bc98:	52800000 	mov	w0, #0x0                   	// #0
  40bc9c:	17fffff7 	b	40bc78 <bin_serialize_key+0x44>
  40bca0:	f9400434 	ldr	x20, [x1, #8]
        if (zcbor_tstr_put_term(ts->encoder, object->name) == false) {
  40bca4:	aa1403e0 	mov	x0, x20
  40bca8:	97ffd596 	bl	401300 <strlen@plt>
  40bcac:	9100a3e1 	add	x1, sp, #0x28
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };
  40bcb0:	a90283f4 	stp	x20, x0, [sp, #40]
	return zcbor_tstr_encode(state, &zs);
  40bcb4:	aa1303e0 	mov	x0, x19
  40bcb8:	94000a6a 	bl	40e660 <zcbor_tstr_encode>
  40bcbc:	17ffffec 	b	40bc6c <bin_serialize_key+0x38>
}
  40bcc0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bcc4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40bcc8:	d65f03c0 	ret

000000000040bccc <bin_serialize_simple_value>:
{
  40bccc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40bcd0:	910003fd 	mov	x29, sp
  40bcd4:	a90153f3 	stp	x19, x20, [sp, #16]
  40bcd8:	aa0003f4 	mov	x20, x0
  40bcdc:	b0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40bce0:	aa0103f3 	mov	x19, x1
  40bce4:	f9478400 	ldr	x0, [x0, #3848]
  40bce8:	f9400001 	ldr	x1, [x0]
  40bcec:	f9001fe1 	str	x1, [sp, #56]
  40bcf0:	d2800001 	mov	x1, #0x0                   	// #0
    switch (type) {
  40bcf4:	71002c5f 	cmp	w2, #0xb
  40bcf8:	540006a8 	b.hi	40bdcc <bin_serialize_simple_value+0x100>  // b.pmore
  40bcfc:	b0000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40bd00:	91215000 	add	x0, x0, #0x854
  40bd04:	38624800 	ldrb	w0, [x0, w2, uxtw]
  40bd08:	10000062 	adr	x2, 40bd14 <bin_serialize_simple_value+0x48>
  40bd0c:	8b208840 	add	x0, x2, w0, sxtb #2
  40bd10:	d61f0000 	br	x0
            success = zcbor_uint32_put(encoder, *data.u32);
  40bd14:	b9400261 	ldr	w1, [x19]
            success = zcbor_uint32_put(encoder, *data.u8);
  40bd18:	aa1403e0 	mov	x0, x20
  40bd1c:	94000a49 	bl	40e640 <zcbor_uint32_put>
  40bd20:	12001c00 	and	w0, w0, #0xff
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40bd24:	7100001f 	cmp	w0, #0x0
  40bd28:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40bd2c:	1a8013e0 	csel	w0, wzr, w0, ne  // ne = any
}
  40bd30:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40bd34:	f9478421 	ldr	x1, [x1, #3848]
  40bd38:	f9401fe3 	ldr	x3, [sp, #56]
  40bd3c:	f9400022 	ldr	x2, [x1]
  40bd40:	eb020063 	subs	x3, x3, x2
  40bd44:	d2800002 	mov	x2, #0x0                   	// #0
  40bd48:	54000460 	b.eq	40bdd4 <bin_serialize_simple_value+0x108>  // b.none
  40bd4c:	97ffd5d9 	bl	4014b0 <__stack_chk_fail@plt>
            success = zcbor_int32_put(encoder, *data.i32);
  40bd50:	b9400261 	ldr	w1, [x19]
                success = zcbor_int32_put(encoder, lroundf(*data.f32));
  40bd54:	aa1403e0 	mov	x0, x20
  40bd58:	94000a32 	bl	40e620 <zcbor_int32_put>
  40bd5c:	17fffff1 	b	40bd20 <bin_serialize_simple_value+0x54>
            success = zcbor_uint32_put(encoder, *data.u16);
  40bd60:	79400261 	ldrh	w1, [x19]
  40bd64:	17ffffed 	b	40bd18 <bin_serialize_simple_value+0x4c>
            success = zcbor_int32_put(encoder, *data.i16);
  40bd68:	79c00261 	ldrsh	w1, [x19]
  40bd6c:	17fffffa 	b	40bd54 <bin_serialize_simple_value+0x88>
            success = zcbor_uint32_put(encoder, *data.u8);
  40bd70:	39400261 	ldrb	w1, [x19]
  40bd74:	17ffffe9 	b	40bd18 <bin_serialize_simple_value+0x4c>
            success = zcbor_int32_put(encoder, *data.i8);
  40bd78:	39c00261 	ldrsb	w1, [x19]
  40bd7c:	17fffff6 	b	40bd54 <bin_serialize_simple_value+0x88>
                success = zcbor_int32_put(encoder, lroundf(*data.f32));
  40bd80:	bd400260 	ldr	s0, [x19]
            if (detail == 0) { /* round to 0 decimals: use int */
  40bd84:	35000083 	cbnz	w3, 40bd94 <bin_serialize_simple_value+0xc8>
                success = zcbor_int32_put(encoder, lroundf(*data.f32));
  40bd88:	97ffd59a 	bl	4013f0 <lroundf@plt>
  40bd8c:	2a0003e1 	mov	w1, w0
  40bd90:	17fffff1 	b	40bd54 <bin_serialize_simple_value+0x88>
                success = zcbor_float32_put(encoder, *data.f32);
  40bd94:	aa1403e0 	mov	x0, x20
  40bd98:	94000a4e 	bl	40e6d0 <zcbor_float32_put>
  40bd9c:	17ffffe1 	b	40bd20 <bin_serialize_simple_value+0x54>
            success = zcbor_bool_put(encoder, *data.b);
  40bda0:	39400261 	ldrb	w1, [x19]
  40bda4:	aa1403e0 	mov	x0, x20
  40bda8:	94000a43 	bl	40e6b4 <zcbor_bool_put>
  40bdac:	17ffffdd 	b	40bd20 <bin_serialize_simple_value+0x54>
            success = zcbor_tstr_put_term(encoder, data.str);
  40bdb0:	aa1303e0 	mov	x0, x19
  40bdb4:	97ffd553 	bl	401300 <strlen@plt>
  40bdb8:	9100a3e1 	add	x1, sp, #0x28
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };
  40bdbc:	a90283f3 	stp	x19, x0, [sp, #40]
	return zcbor_tstr_encode(state, &zs);
  40bdc0:	aa1403e0 	mov	x0, x20
  40bdc4:	94000a27 	bl	40e660 <zcbor_tstr_encode>
  40bdc8:	17ffffd6 	b	40bd20 <bin_serialize_simple_value+0x54>
    switch (type) {
  40bdcc:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40bdd0:	17ffffd8 	b	40bd30 <bin_serialize_simple_value+0x64>
}
  40bdd4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bdd8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40bddc:	d65f03c0 	ret

000000000040bde0 <bin_serialize_path>:
{
  40bde0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40bde4:	b0000102 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  40bde8:	910003fd 	mov	x29, sp
  40bdec:	f9478442 	ldr	x2, [x2, #3848]
  40bdf0:	a90153f3 	stp	x19, x20, [sp, #16]
  40bdf4:	aa0003f3 	mov	x19, x0
    uint8_t *buf_path_start = ts->encoder->payload_mut + 2;
  40bdf8:	f9403c14 	ldr	x20, [x0, #120]
{
  40bdfc:	f9400043 	ldr	x3, [x2]
  40be00:	f9001fe3 	str	x3, [sp, #56]
  40be04:	d2800003 	mov	x3, #0x0                   	// #0
    size_t buf_path_size = ts->encoder->payload_end - buf_path_start;
  40be08:	f9404802 	ldr	x2, [x0, #144]
    uint8_t *buf_path_start = ts->encoder->payload_mut + 2;
  40be0c:	91000a94 	add	x20, x20, #0x2
    int path_len = thingset_get_path(ts, (char *)buf_path_start, buf_path_size, object);
  40be10:	aa0103e3 	mov	x3, x1
  40be14:	aa1403e1 	mov	x1, x20
  40be18:	cb140042 	sub	x2, x2, x20
  40be1c:	97fffd47 	bl	40b338 <thingset_get_path>
    if (path_len < 0) {
  40be20:	37f80140 	tbnz	w0, #31, 40be48 <bin_serialize_path+0x68>
    return zcbor_tstr_encode_ptr(ts->encoder, buf_path_start, path_len)
  40be24:	93407c00 	sxtw	x0, w0
  40be28:	9100a3e1 	add	x1, sp, #0x28
  40be2c:	a90283f4 	stp	x20, x0, [sp, #40]
  40be30:	9101e260 	add	x0, x19, #0x78
  40be34:	94000a0b 	bl	40e660 <zcbor_tstr_encode>
  40be38:	2a0003e1 	mov	w1, w0
               : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40be3c:	52800000 	mov	w0, #0x0                   	// #0
  40be40:	72001c3f 	tst	w1, #0xff
  40be44:	54000041 	b.ne	40be4c <bin_serialize_path+0x6c>  // b.any
  40be48:	12801c00 	mov	w0, #0xffffff1f            	// #-225
}
  40be4c:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40be50:	f9478421 	ldr	x1, [x1, #3848]
  40be54:	f9401fe3 	ldr	x3, [sp, #56]
  40be58:	f9400022 	ldr	x2, [x1]
  40be5c:	eb020063 	subs	x3, x3, x2
  40be60:	d2800002 	mov	x2, #0x0                   	// #0
  40be64:	54000040 	b.eq	40be6c <bin_serialize_path+0x8c>  // b.none
  40be68:	97ffd592 	bl	4014b0 <__stack_chk_fail@plt>
  40be6c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40be70:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40be74:	d65f03c0 	ret

000000000040be78 <bin_serialize_value>:
{
  40be78:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40be7c:	910003fd 	mov	x29, sp
  40be80:	a9025bf5 	stp	x21, x22, [sp, #32]
  40be84:	aa0003f5 	mov	x21, x0
  40be88:	b0000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40be8c:	a90153f3 	stp	x19, x20, [sp, #16]
  40be90:	aa0103f4 	mov	x20, x1
    err = bin_serialize_simple_value(ts->encoder, object->data, object->type, object->detail);
  40be94:	9101e2b3 	add	x19, x21, #0x78
{
  40be98:	f9478400 	ldr	x0, [x0, #3848]
  40be9c:	a90363f7 	stp	x23, x24, [sp, #48]
  40bea0:	f90023f9 	str	x25, [sp, #64]
  40bea4:	f9400001 	ldr	x1, [x0]
  40bea8:	f9003fe1 	str	x1, [sp, #120]
  40beac:	d2800001 	mov	x1, #0x0                   	// #0
    err = bin_serialize_simple_value(ts->encoder, object->data, object->type, object->detail);
  40beb0:	aa1303e0 	mov	x0, x19
  40beb4:	a9410a81 	ldp	x1, x2, [x20, #16]
  40beb8:	93454043 	sbfx	x3, x2, #5, #12
  40bebc:	12001042 	and	w2, w2, #0x1f
  40bec0:	13003c63 	sxth	w3, w3
  40bec4:	97ffff82 	bl	40bccc <bin_serialize_simple_value>
    if (err == 0) {
  40bec8:	35000140 	cbnz	w0, 40bef0 <bin_serialize_value+0x78>
        return 0;
  40becc:	52800000 	mov	w0, #0x0                   	// #0
}
  40bed0:	b0000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40bed4:	f9478421 	ldr	x1, [x1, #3848]
  40bed8:	f9403fe3 	ldr	x3, [sp, #120]
  40bedc:	f9400022 	ldr	x2, [x1]
  40bee0:	eb020063 	subs	x3, x3, x2
  40bee4:	d2800002 	mov	x2, #0x0                   	// #0
  40bee8:	54001140 	b.eq	40c110 <bin_serialize_value+0x298>  // b.none
  40beec:	97ffd571 	bl	4014b0 <__stack_chk_fail@plt>
    if (object->type == THINGSET_TYPE_GROUP) {
  40bef0:	b9401a80 	ldr	w0, [x20, #24]
  40bef4:	12001000 	and	w0, w0, #0x1f
  40bef8:	71003c1f 	cmp	w0, #0xf
  40befc:	54000101 	b.ne	40bf1c <bin_serialize_value+0xa4>  // b.any
        success = zcbor_nil_put(ts->encoder, NULL);
  40bf00:	aa1303e0 	mov	x0, x19
  40bf04:	d2800001 	mov	x1, #0x0                   	// #0
  40bf08:	940009e9 	bl	40e6ac <zcbor_nil_put>
        success = zcbor_uint32_put(ts->encoder, object->data.records->num_records);
  40bf0c:	12001c00 	and	w0, w0, #0xff
    if (success) {
  40bf10:	35fffde0 	cbnz	w0, 40becc <bin_serialize_value+0x54>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40bf14:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40bf18:	17ffffee 	b	40bed0 <bin_serialize_value+0x58>
    else if (object->type == THINGSET_TYPE_RECORDS) {
  40bf1c:	51003400 	sub	w0, w0, #0xd
  40bf20:	7100141f 	cmp	w0, #0x5
  40bf24:	54000f28 	b.hi	40c108 <bin_serialize_value+0x290>  // b.pmore
  40bf28:	b0000041 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  40bf2c:	91218021 	add	x1, x1, #0x860
  40bf30:	38604821 	ldrb	w1, [x1, w0, uxtw]
  40bf34:	10000060 	adr	x0, 40bf40 <bin_serialize_value+0xc8>
  40bf38:	8b218801 	add	x1, x0, w1, sxtb #2
  40bf3c:	d61f0020 	br	x1
        success = zcbor_uint32_put(ts->encoder, object->data.records->num_records);
  40bf40:	f9400a80 	ldr	x0, [x20, #16]
  40bf44:	79402401 	ldrh	w1, [x0, #18]
  40bf48:	aa1303e0 	mov	x0, x19
  40bf4c:	940009bd 	bl	40e640 <zcbor_uint32_put>
  40bf50:	17ffffef 	b	40bf0c <bin_serialize_value+0x94>
        success = zcbor_list_start_encode(ts->encoder, UINT8_MAX);
  40bf54:	aa1303e0 	mov	x0, x19
  40bf58:	d2801fe1 	mov	x1, #0xff                  	// #255
  40bf5c:	910163f9 	add	x25, sp, #0x58
  40bf60:	940009c2 	bl	40e668 <zcbor_list_start_encode>
  40bf64:	12001c17 	and	w23, w0, #0xff
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40bf68:	52800016 	mov	w22, #0x0                   	// #0
  40bf6c:	f94006a0 	ldr	x0, [x21, #8]
  40bf70:	2a1603e1 	mov	w1, w22
  40bf74:	eb36401f 	cmp	x0, w22, uxtw
  40bf78:	54000108 	b.hi	40bf98 <bin_serialize_value+0x120>  // b.pmore
        success = success && zcbor_list_end_encode(ts->encoder, UINT8_MAX);
  40bf7c:	34000437 	cbz	w23, 40c000 <bin_serialize_value+0x188>
        success = success && zcbor_list_end_encode(ts->encoder, UINT8_MAX);
  40bf80:	d2801fe1 	mov	x1, #0xff                  	// #255
        success = success && zcbor_list_end_encode(ts->encoder, array->num_elements);
  40bf84:	aa1303e0 	mov	x0, x19
  40bf88:	940009bc 	bl	40e678 <zcbor_list_end_encode>
  40bf8c:	12001c00 	and	w0, w0, #0xff
  40bf90:	12000000 	and	w0, w0, #0x1
  40bf94:	17ffffdf 	b	40bf10 <bin_serialize_value+0x98>
            if (ts->data_objects[i].parent_id == object->id) {
  40bf98:	f94002a0 	ldr	x0, [x21]
  40bf9c:	d37be822 	lsl	x2, x1, #5
  40bfa0:	8b011401 	add	x1, x0, x1, lsl #5
  40bfa4:	78626802 	ldrh	w2, [x0, x2]
  40bfa8:	79400680 	ldrh	w0, [x20, #2]
  40bfac:	6b00005f 	cmp	w2, w0
  40bfb0:	54000101 	b.ne	40bfd0 <bin_serialize_value+0x158>  // b.any
                zcbor_tstr_put_term(ts->encoder, ts->data_objects[i].name);
  40bfb4:	f9400438 	ldr	x24, [x1, #8]
  40bfb8:	aa1803e0 	mov	x0, x24
  40bfbc:	97ffd4d1 	bl	401300 <strlen@plt>
  40bfc0:	aa1903e1 	mov	x1, x25
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };
  40bfc4:	a90583f8 	stp	x24, x0, [sp, #88]
	return zcbor_tstr_encode(state, &zs);
  40bfc8:	aa1303e0 	mov	x0, x19
  40bfcc:	940009a5 	bl	40e660 <zcbor_tstr_encode>
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40bfd0:	110006d6 	add	w22, w22, #0x1
  40bfd4:	17ffffe6 	b	40bf6c <bin_serialize_value+0xf4>
        success = zcbor_list_start_encode(ts->encoder, UINT8_MAX);
  40bfd8:	aa1303e0 	mov	x0, x19
  40bfdc:	d2801fe1 	mov	x1, #0xff                  	// #255
  40bfe0:	940009a2 	bl	40e668 <zcbor_list_start_encode>
  40bfe4:	12001c02 	and	w2, w0, #0xff
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40bfe8:	52800016 	mov	w22, #0x0                   	// #0
  40bfec:	f94006a0 	ldr	x0, [x21, #8]
  40bff0:	2a1603e1 	mov	w1, w22
  40bff4:	eb36401f 	cmp	x0, w22, uxtw
  40bff8:	54000088 	b.hi	40c008 <bin_serialize_value+0x190>  // b.pmore
        success = success && zcbor_list_end_encode(ts->encoder, UINT8_MAX);
  40bffc:	35fffc22 	cbnz	w2, 40bf80 <bin_serialize_value+0x108>
        success = success && zcbor_list_end_encode(ts->encoder, array->num_elements);
  40c000:	52800000 	mov	w0, #0x0                   	// #0
  40c004:	17ffffe3 	b	40bf90 <bin_serialize_value+0x118>
            if (ts->data_objects[i].subsets & object->data.subset) {
  40c008:	f94002a0 	ldr	x0, [x21]
  40c00c:	8b011401 	add	x1, x0, x1, lsl #5
  40c010:	b9401280 	ldr	w0, [x20, #16]
  40c014:	f9400c23 	ldr	x3, [x1, #24]
  40c018:	6a43641f 	tst	w0, w3, lsr #25
  40c01c:	54000120 	b.eq	40c040 <bin_serialize_value+0x1c8>  // b.none
                if (ts->endpoint.use_ids) {
  40c020:	394f12a0 	ldrb	w0, [x21, #964]
  40c024:	34000160 	cbz	w0, 40c050 <bin_serialize_value+0x1d8>
                    success = success && zcbor_uint32_put(ts->encoder, ts->data_objects[i].id);
  40c028:	34000102 	cbz	w2, 40c048 <bin_serialize_value+0x1d0>
  40c02c:	79400421 	ldrh	w1, [x1, #2]
  40c030:	aa1303e0 	mov	x0, x19
  40c034:	94000983 	bl	40e640 <zcbor_uint32_put>
  40c038:	12001c02 	and	w2, w0, #0xff
  40c03c:	12000042 	and	w2, w2, #0x1
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40c040:	110006d6 	add	w22, w22, #0x1
  40c044:	17ffffea 	b	40bfec <bin_serialize_value+0x174>
                    success = success && zcbor_uint32_put(ts->encoder, ts->data_objects[i].id);
  40c048:	52800002 	mov	w2, #0x0                   	// #0
  40c04c:	17fffffc 	b	40c03c <bin_serialize_value+0x1c4>
                    success = success && (bin_serialize_path(ts, &ts->data_objects[i]) == 0);
  40c050:	340000c2 	cbz	w2, 40c068 <bin_serialize_value+0x1f0>
  40c054:	aa1503e0 	mov	x0, x21
  40c058:	97ffff62 	bl	40bde0 <bin_serialize_path>
  40c05c:	7100001f 	cmp	w0, #0x0
  40c060:	1a9f17e2 	cset	w2, eq  // eq = none
  40c064:	17fffff7 	b	40c040 <bin_serialize_value+0x1c8>
  40c068:	52800002 	mov	w2, #0x0                   	// #0
  40c06c:	17fffff5 	b	40c040 <bin_serialize_value+0x1c8>
        struct thingset_array *array = object->data.array;
  40c070:	f9400a94 	ldr	x20, [x20, #16]
        success = zcbor_list_start_encode(ts->encoder, array->num_elements);
  40c074:	aa1303e0 	mov	x0, x19
  40c078:	79402281 	ldrh	w1, [x20, #16]
  40c07c:	9400097b 	bl	40e668 <zcbor_list_start_encode>
  40c080:	12001c15 	and	w21, w0, #0xff
    uint8_t sizes[] = { sizeof(bool),    sizeof(uint8_t),  sizeof(int8_t),  sizeof(uint16_t),
  40c084:	d0000042 	adrp	x2, 416000 <__func__.0+0x57a>
  40c088:	911c4442 	add	x2, x2, #0x711
        size_t type_size = thingset_type_size(array->element_type);
  40c08c:	b9400a81 	ldr	w1, [x20, #8]
  40c090:	9101a3e0 	add	x0, sp, #0x68
  40c094:	f9400043 	ldr	x3, [x2]
  40c098:	f90037e3 	str	x3, [sp, #104]
  40c09c:	b8407042 	ldur	w2, [x2, #7]
  40c0a0:	b806f3e2 	stur	w2, [sp, #111]
    return type < sizeof(sizes) ? sizes[type] : 0;
  40c0a4:	12001c22 	and	w2, w1, #0xff
  40c0a8:	7100285f 	cmp	w2, #0xa
  40c0ac:	54000168 	b.hi	40c0d8 <bin_serialize_value+0x260>  // b.pmore
  40c0b0:	92401c21 	and	x1, x1, #0xff
  40c0b4:	38616818 	ldrb	w24, [x0, x1]
        for (int i = 0; i < array->num_elements; i++) {
  40c0b8:	d2800017 	mov	x23, #0x0                   	// #0
  40c0bc:	52800016 	mov	w22, #0x0                   	// #0
  40c0c0:	79402281 	ldrh	w1, [x20, #16]
  40c0c4:	6b16003f 	cmp	w1, w22
  40c0c8:	540000cc 	b.gt	40c0e0 <bin_serialize_value+0x268>
        success = success && zcbor_list_end_encode(ts->encoder, array->num_elements);
  40c0cc:	34fff9b5 	cbz	w21, 40c000 <bin_serialize_value+0x188>
  40c0d0:	92403c21 	and	x1, x1, #0xffff
  40c0d4:	17ffffac 	b	40bf84 <bin_serialize_value+0x10c>
  40c0d8:	d2800018 	mov	x24, #0x0                   	// #0
  40c0dc:	17fffff7 	b	40c0b8 <bin_serialize_value+0x240>
                bin_serialize_simple_value(ts->encoder, data, array->element_type, array->decimals);
  40c0e0:	79c01a83 	ldrsh	w3, [x20, #12]
  40c0e4:	aa1303e0 	mov	x0, x19
  40c0e8:	b9400a82 	ldr	w2, [x20, #8]
            union thingset_data_pointer data = { .u8 = array->elements.u8 + i * type_size };
  40c0ec:	f9400281 	ldr	x1, [x20]
                bin_serialize_simple_value(ts->encoder, data, array->element_type, array->decimals);
  40c0f0:	8b170021 	add	x1, x1, x23
            if (err != 0) {
  40c0f4:	8b1802f7 	add	x23, x23, x24
                bin_serialize_simple_value(ts->encoder, data, array->element_type, array->decimals);
  40c0f8:	97fffef5 	bl	40bccc <bin_serialize_simple_value>
            if (err != 0) {
  40c0fc:	35ffeea0 	cbnz	w0, 40bed0 <bin_serialize_value+0x58>
        for (int i = 0; i < array->num_elements; i++) {
  40c100:	110006d6 	add	w22, w22, #0x1
  40c104:	17ffffef 	b	40c0c0 <bin_serialize_value+0x248>
    if (object->type == THINGSET_TYPE_GROUP) {
  40c108:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40c10c:	17ffff71 	b	40bed0 <bin_serialize_value+0x58>
}
  40c110:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c114:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c118:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c11c:	f94023f9 	ldr	x25, [sp, #64]
  40c120:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40c124:	d65f03c0 	ret

000000000040c128 <thingset_bin_setup>:
    .deserialize_value = bin_deserialize_value,
    .deserialize_finish = bin_deserialize_finish,
};

inline void thingset_bin_setup(struct thingset_context *ts, size_t rsp_buf_offset)
{
  40c128:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    ts->api = &bin_api;

    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg + 1, ts->msg_len - 1,
  40c12c:	d2800024 	mov	x4, #0x1                   	// #1
{
  40c130:	910003fd 	mov	x29, sp
  40c134:	a90153f3 	stp	x19, x20, [sp, #16]
  40c138:	aa0003f3 	mov	x19, x0
    ts->api = &bin_api;
  40c13c:	b0000100 	adrp	x0, 42d000 <__dso_handle>
  40c140:	9125a000 	add	x0, x0, #0x968
{
  40c144:	aa0103f4 	mov	x20, x1
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg + 1, ts->msg_len - 1,
  40c148:	a9438e62 	ldp	x2, x3, [x19, #56]
    ts->api = &bin_api;
  40c14c:	f9003a60 	str	x0, [x19, #112]
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg + 1, ts->msg_len - 1,
  40c150:	d2800081 	mov	x1, #0x4                   	// #4
  40c154:	9104e260 	add	x0, x19, #0x138
  40c158:	8b040042 	add	x2, x2, x4
  40c15c:	d1000463 	sub	x3, x3, #0x1
  40c160:	940007da 	bl	40e0c8 <zcbor_new_decode_state>
                           1);

    zcbor_new_encode_state(ts->encoder, ZCBOR_ARRAY_SIZE(ts->encoder), ts->rsp + rsp_buf_offset,
  40c164:	a9458e62 	ldp	x2, x3, [x19, #88]
  40c168:	9101e260 	add	x0, x19, #0x78
  40c16c:	d2800024 	mov	x4, #0x1                   	// #1
  40c170:	d2800081 	mov	x1, #0x4                   	// #4
  40c174:	cb140063 	sub	x3, x3, x20
  40c178:	8b140042 	add	x2, x2, x20
                           ts->rsp_size - rsp_buf_offset, 1);
}
  40c17c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c180:	a8c27bfd 	ldp	x29, x30, [sp], #32
    zcbor_new_encode_state(ts->encoder, ZCBOR_ARRAY_SIZE(ts->encoder), ts->rsp + rsp_buf_offset,
  40c184:	1400095a 	b	40e6ec <zcbor_new_encode_state>

000000000040c188 <txt_serialize_path>:
                              const struct thingset_data_object *object)
{
    /* not used for text mode */

    return -THINGSET_ERR_INTERNAL_SERVER_ERR;
}
  40c188:	128017e0 	mov	w0, #0xffffff40            	// #-192
  40c18c:	d65f03c0 	ret

000000000040c190 <txt_serialize_end>:
    }
}

static inline int txt_serialize_end(struct thingset_context *ts, char c)
{
    if (ts->rsp_size > ts->rsp_pos + 3) {
  40c190:	a9460804 	ldp	x4, x2, [x0, #96]
{
  40c194:	12001c21 	and	w1, w1, #0xff
    if (ts->rsp_size > ts->rsp_pos + 3) {
  40c198:	91000c43 	add	x3, x2, #0x3
  40c19c:	eb03009f 	cmp	x4, x3
  40c1a0:	54000269 	b.ls	40c1ec <txt_serialize_end+0x5c>  // b.plast
        if (ts->rsp[ts->rsp_pos - 1] == ',') {
  40c1a4:	f9402c03 	ldr	x3, [x0, #88]
  40c1a8:	d1000442 	sub	x2, x2, #0x1
  40c1ac:	38626864 	ldrb	w4, [x3, x2]
  40c1b0:	7100b09f 	cmp	w4, #0x2c
  40c1b4:	54000041 	b.ne	40c1bc <txt_serialize_end+0x2c>  // b.any
            ts->rsp_pos--;
  40c1b8:	f9003402 	str	x2, [x0, #104]
        }
        ts->rsp[ts->rsp_pos++] = c;
  40c1bc:	f9403402 	ldr	x2, [x0, #104]
  40c1c0:	91000444 	add	x4, x2, #0x1
  40c1c4:	f9003404 	str	x4, [x0, #104]
  40c1c8:	38226861 	strb	w1, [x3, x2]
        ts->rsp[ts->rsp_pos++] = ',';
  40c1cc:	f9402c02 	ldr	x2, [x0, #88]
  40c1d0:	f9403401 	ldr	x1, [x0, #104]
  40c1d4:	91000423 	add	x3, x1, #0x1
  40c1d8:	f9003403 	str	x3, [x0, #104]
  40c1dc:	52800580 	mov	w0, #0x2c                  	// #44
  40c1e0:	38216840 	strb	w0, [x2, x1]
        return 0;
  40c1e4:	52800000 	mov	w0, #0x0                   	// #0
    }
    else {
        ts->rsp_pos = 0;
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
    }
}
  40c1e8:	d65f03c0 	ret
        ts->rsp_pos = 0;
  40c1ec:	f900341f 	str	xzr, [x0, #104]
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40c1f0:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40c1f4:	17fffffd 	b	40c1e8 <txt_serialize_end+0x58>

000000000040c1f8 <txt_serialize_map_start>:
    if (ts->rsp_size > ts->rsp_pos + 2) {
  40c1f8:	a9460403 	ldp	x3, x1, [x0, #96]
  40c1fc:	91000822 	add	x2, x1, #0x2
  40c200:	eb02007f 	cmp	x3, x2
  40c204:	54000109 	b.ls	40c224 <txt_serialize_map_start+0x2c>  // b.plast
        ts->rsp[ts->rsp_pos++] = c;
  40c208:	f9402c02 	ldr	x2, [x0, #88]
  40c20c:	91000423 	add	x3, x1, #0x1
  40c210:	f9003403 	str	x3, [x0, #104]
  40c214:	52800f60 	mov	w0, #0x7b                  	// #123
  40c218:	38216840 	strb	w0, [x2, x1]
        return 0;
  40c21c:	52800000 	mov	w0, #0x0                   	// #0

static int txt_serialize_map_start(struct thingset_context *ts)
{
    return txt_serialize_start(ts, '{');
}
  40c220:	d65f03c0 	ret
        ts->rsp_pos = 0;
  40c224:	f900341f 	str	xzr, [x0, #104]
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40c228:	12801c00 	mov	w0, #0xffffff1f            	// #-225
    return txt_serialize_start(ts, '{');
  40c22c:	17fffffd 	b	40c220 <txt_serialize_map_start+0x28>

000000000040c230 <txt_serialize_map_end>:

static int txt_serialize_map_end(struct thingset_context *ts)
{
    return txt_serialize_end(ts, '}');
  40c230:	52800fa1 	mov	w1, #0x7d                  	// #125
  40c234:	17ffffd7 	b	40c190 <txt_serialize_end>

000000000040c238 <txt_serialize_list_end>:
    return txt_serialize_start(ts, '[');
}

static int txt_serialize_list_end(struct thingset_context *ts)
{
    return txt_serialize_end(ts, ']');
  40c238:	52800ba1 	mov	w1, #0x5d                  	// #93
  40c23c:	17ffffd5 	b	40c190 <txt_serialize_end>

000000000040c240 <txt_serialize_finish>:
}

static void txt_serialize_finish(struct thingset_context *ts)
{
    /* remove the trailing comma or space (in case of no payload) and terminate string */
    ts->rsp_pos--;
  40c240:	f9403401 	ldr	x1, [x0, #104]
  40c244:	d1000421 	sub	x1, x1, #0x1
  40c248:	f9003401 	str	x1, [x0, #104]
    ts->rsp[ts->rsp_pos] = '\0';
  40c24c:	f9402c00 	ldr	x0, [x0, #88]
  40c250:	3821681f 	strb	wzr, [x0, x1]
}
  40c254:	d65f03c0 	ret

000000000040c258 <txt_deserialize_string>:
}

static int txt_deserialize_string(struct thingset_context *ts, const char **str_start,
                                  size_t *str_len)
{
    if (ts->tok_pos < ts->tok_count) {
  40c258:	f941cc04 	ldr	x4, [x0, #920]
  40c25c:	f941d003 	ldr	x3, [x0, #928]
  40c260:	eb04007f 	cmp	x3, x4
  40c264:	540002a2 	b.cs	40c2b8 <txt_deserialize_string+0x60>  // b.hs, b.nlast
        if (ts->tokens[ts->tok_pos].type == JSMN_STRING) {
  40c268:	8b031003 	add	x3, x0, x3, lsl #4
  40c26c:	b9407864 	ldr	w4, [x3, #120]
  40c270:	7100109f 	cmp	w4, #0x4
  40c274:	54000261 	b.ne	40c2c0 <txt_deserialize_string+0x68>  // b.any
            *str_start = ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40c278:	b9807c64 	ldrsw	x4, [x3, #124]
  40c27c:	f9402803 	ldr	x3, [x0, #80]
  40c280:	8b040063 	add	x3, x3, x4
  40c284:	f9000023 	str	x3, [x1]
            *str_len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40c288:	f941d003 	ldr	x3, [x0, #928]
  40c28c:	8b031003 	add	x3, x0, x3, lsl #4
  40c290:	b9408061 	ldr	w1, [x3, #128]
  40c294:	b9407c63 	ldr	w3, [x3, #124]
  40c298:	4b030021 	sub	w1, w1, w3
  40c29c:	93407c21 	sxtw	x1, w1
  40c2a0:	f9000041 	str	x1, [x2]
            ts->tok_pos++;
  40c2a4:	f941d001 	ldr	x1, [x0, #928]
  40c2a8:	91000421 	add	x1, x1, #0x1
  40c2ac:	f901d001 	str	x1, [x0, #928]
            return 0;
  40c2b0:	52800000 	mov	w0, #0x0                   	// #0
        }
    }
    else {
        return -THINGSET_ERR_BAD_REQUEST;
    }
}
  40c2b4:	d65f03c0 	ret
        return -THINGSET_ERR_BAD_REQUEST;
  40c2b8:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40c2bc:	17fffffe 	b	40c2b4 <txt_deserialize_string+0x5c>
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40c2c0:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40c2c4:	17fffffc 	b	40c2b4 <txt_deserialize_string+0x5c>

000000000040c2c8 <txt_deserialize_list_start>:
    }
}

static int txt_deserialize_list_start(struct thingset_context *ts)
{
    if (ts->tok_pos < ts->tok_count) {
  40c2c8:	f941cc02 	ldr	x2, [x0, #920]
  40c2cc:	f941d001 	ldr	x1, [x0, #928]
  40c2d0:	eb02003f 	cmp	x1, x2
  40c2d4:	54000122 	b.cs	40c2f8 <txt_deserialize_list_start+0x30>  // b.hs, b.nlast
        if (ts->tokens[ts->tok_pos].type == JSMN_ARRAY) {
  40c2d8:	8b011002 	add	x2, x0, x1, lsl #4
  40c2dc:	b9407842 	ldr	w2, [x2, #120]
  40c2e0:	7100085f 	cmp	w2, #0x2
  40c2e4:	540000e1 	b.ne	40c300 <txt_deserialize_list_start+0x38>  // b.any
            ts->tok_pos++;
  40c2e8:	91000421 	add	x1, x1, #0x1
  40c2ec:	f901d001 	str	x1, [x0, #928]
            return 0;
  40c2f0:	52800000 	mov	w0, #0x0                   	// #0
        }
    }
    else {
        return -THINGSET_ERR_BAD_REQUEST;
    }
}
  40c2f4:	d65f03c0 	ret
        return -THINGSET_ERR_BAD_REQUEST;
  40c2f8:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40c2fc:	17fffffe 	b	40c2f4 <txt_deserialize_list_start+0x2c>
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40c300:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40c304:	17fffffc 	b	40c2f4 <txt_deserialize_list_start+0x2c>

000000000040c308 <txt_deserialize_map_start>:

static int txt_deserialize_map_start(struct thingset_context *ts)
{
    if (ts->tok_pos < ts->tok_count) {
  40c308:	f941cc02 	ldr	x2, [x0, #920]
  40c30c:	f941d001 	ldr	x1, [x0, #928]
  40c310:	eb02003f 	cmp	x1, x2
  40c314:	54000122 	b.cs	40c338 <txt_deserialize_map_start+0x30>  // b.hs, b.nlast
        if (ts->tokens[ts->tok_pos].type == JSMN_OBJECT) {
  40c318:	8b011002 	add	x2, x0, x1, lsl #4
  40c31c:	b9407842 	ldr	w2, [x2, #120]
  40c320:	7100045f 	cmp	w2, #0x1
  40c324:	540000e1 	b.ne	40c340 <txt_deserialize_map_start+0x38>  // b.any
            ts->tok_pos++;
  40c328:	91000421 	add	x1, x1, #0x1
  40c32c:	f901d001 	str	x1, [x0, #928]
            return 0;
  40c330:	52800000 	mov	w0, #0x0                   	// #0
        }
    }
    else {
        return -THINGSET_ERR_BAD_REQUEST;
    }
}
  40c334:	d65f03c0 	ret
        return -THINGSET_ERR_BAD_REQUEST;
  40c338:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40c33c:	17fffffe 	b	40c334 <txt_deserialize_map_start+0x2c>
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40c340:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40c344:	17fffffc 	b	40c334 <txt_deserialize_map_start+0x2c>

000000000040c348 <txt_deserialize_finish>:

static int txt_deserialize_finish(struct thingset_context *ts)
{
    return ts->tok_count == ts->tok_pos ? 0 : -THINGSET_ERR_BAD_REQUEST;
  40c348:	f941cc01 	ldr	x1, [x0, #920]
  40c34c:	f941d000 	ldr	x0, [x0, #928]
  40c350:	eb00003f 	cmp	x1, x0
}
  40c354:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40c358:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40c35c:	d65f03c0 	ret

000000000040c360 <txt_deserialize_value>:
{
  40c360:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40c364:	910003fd 	mov	x29, sp
  40c368:	a90153f3 	stp	x19, x20, [sp, #16]
  40c36c:	aa0103f3 	mov	x19, x1
  40c370:	aa0003f4 	mov	x20, x0
  40c374:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c378:	a90363f7 	stp	x23, x24, [sp, #48]
  40c37c:	a9046bf9 	stp	x25, x26, [sp, #64]
    if (ts->tok_pos >= ts->tok_count) {
  40c380:	f941cc01 	ldr	x1, [x0, #920]
{
  40c384:	f9002bfb 	str	x27, [sp, #80]
    if (ts->tok_pos >= ts->tok_count) {
  40c388:	f941d000 	ldr	x0, [x0, #928]
  40c38c:	eb01001f 	cmp	x0, x1
  40c390:	54000ec2 	b.cs	40c568 <txt_deserialize_value+0x208>  // b.hs, b.nlast
    const char *buf = ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40c394:	8b001280 	add	x0, x20, x0, lsl #4
  40c398:	f9402a99 	ldr	x25, [x20, #80]
    size_t len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40c39c:	294fdc18 	ldp	w24, w23, [x0, #124]
    if (ts->tokens[ts->tok_pos].type != JSMN_PRIMITIVE
  40c3a0:	b9407800 	ldr	w0, [x0, #120]
        && ts->tokens[ts->tok_pos].type != JSMN_STRING)
  40c3a4:	7100201f 	cmp	w0, #0x8
    const char *buf = ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40c3a8:	93407f1b 	sxtw	x27, w24
    if (ts->tokens[ts->tok_pos].type != JSMN_PRIMITIVE
  40c3ac:	7a441804 	ccmp	w0, #0x4, #0x4, ne  // ne = any
    const char *buf = ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40c3b0:	8b38c335 	add	x21, x25, w24, sxtw
    if (ts->tokens[ts->tok_pos].type != JSMN_PRIMITIVE
  40c3b4:	54000060 	b.eq	40c3c0 <txt_deserialize_value+0x60>  // b.none
    switch (object->type) {
  40c3b8:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40c3bc:	1400005d 	b	40c530 <txt_deserialize_value+0x1d0>
  40c3c0:	12001c5a 	and	w26, w2, #0xff
    errno = 0;
  40c3c4:	97ffd493 	bl	401610 <__errno_location@plt>
  40c3c8:	b900001f 	str	wzr, [x0]
  40c3cc:	aa0003f6 	mov	x22, x0
    switch (object->type) {
  40c3d0:	f9400e61 	ldr	x1, [x19, #24]
  40c3d4:	12001023 	and	w3, w1, #0x1f
  40c3d8:	71002c7f 	cmp	w3, #0xb
  40c3dc:	54fffee8 	b.hi	40c3b8 <txt_deserialize_value+0x58>  // b.pmore
  40c3e0:	90000040 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40c3e4:	9121a000 	add	x0, x0, #0x868
  40c3e8:	38634800 	ldrb	w0, [x0, w3, uxtw]
  40c3ec:	10000063 	adr	x3, 40c3f8 <txt_deserialize_value+0x98>
  40c3f0:	8b208860 	add	x0, x3, w0, sxtb #2
  40c3f4:	d61f0000 	br	x0
            *object->data.f32 = strtod(buf, NULL);
  40c3f8:	aa1503e0 	mov	x0, x21
  40c3fc:	d2800001 	mov	x1, #0x0                   	// #0
  40c400:	97ffd3d4 	bl	401350 <strtod@plt>
  40c404:	1e624000 	fcvt	s0, d0
  40c408:	f9400a60 	ldr	x0, [x19, #16]
  40c40c:	bd000000 	str	s0, [x0]
    if (errno == ERANGE) {
  40c410:	b94002c0 	ldr	w0, [x22]
  40c414:	7100881f 	cmp	w0, #0x22
  40c418:	54000841 	b.ne	40c520 <txt_deserialize_value+0x1c0>  // b.any
  40c41c:	17ffffe7 	b	40c3b8 <txt_deserialize_value+0x58>
            *object->data.u32 = strtoul(buf, NULL, 0);
  40c420:	aa1503e0 	mov	x0, x21
  40c424:	52800002 	mov	w2, #0x0                   	// #0
  40c428:	d2800001 	mov	x1, #0x0                   	// #0
  40c42c:	97ffd3b1 	bl	4012f0 <strtoul@plt>
            *object->data.i32 = strtol(buf, NULL, 0);
  40c430:	f9400a61 	ldr	x1, [x19, #16]
  40c434:	b9000020 	str	w0, [x1]
            break;
  40c438:	17fffff6 	b	40c410 <txt_deserialize_value+0xb0>
            *object->data.i32 = strtol(buf, NULL, 0);
  40c43c:	aa1503e0 	mov	x0, x21
  40c440:	52800002 	mov	w2, #0x0                   	// #0
  40c444:	d2800001 	mov	x1, #0x0                   	// #0
  40c448:	97ffd442 	bl	401550 <strtol@plt>
  40c44c:	17fffff9 	b	40c430 <txt_deserialize_value+0xd0>
            *object->data.u16 = strtoul(buf, NULL, 0);
  40c450:	aa1503e0 	mov	x0, x21
  40c454:	52800002 	mov	w2, #0x0                   	// #0
  40c458:	d2800001 	mov	x1, #0x0                   	// #0
  40c45c:	97ffd3a5 	bl	4012f0 <strtoul@plt>
            *object->data.i16 = strtol(buf, NULL, 0);
  40c460:	f9400a61 	ldr	x1, [x19, #16]
  40c464:	79000020 	strh	w0, [x1]
            break;
  40c468:	17ffffea 	b	40c410 <txt_deserialize_value+0xb0>
            *object->data.i16 = strtol(buf, NULL, 0);
  40c46c:	aa1503e0 	mov	x0, x21
  40c470:	52800002 	mov	w2, #0x0                   	// #0
  40c474:	d2800001 	mov	x1, #0x0                   	// #0
  40c478:	97ffd436 	bl	401550 <strtol@plt>
  40c47c:	17fffff9 	b	40c460 <txt_deserialize_value+0x100>
            *object->data.u8 = strtoul(buf, NULL, 0);
  40c480:	aa1503e0 	mov	x0, x21
  40c484:	52800002 	mov	w2, #0x0                   	// #0
  40c488:	d2800001 	mov	x1, #0x0                   	// #0
  40c48c:	97ffd399 	bl	4012f0 <strtoul@plt>
            *object->data.i8 = strtol(buf, NULL, 0);
  40c490:	f9400a61 	ldr	x1, [x19, #16]
  40c494:	39000020 	strb	w0, [x1]
            break;
  40c498:	17ffffde 	b	40c410 <txt_deserialize_value+0xb0>
            *object->data.i8 = strtol(buf, NULL, 0);
  40c49c:	aa1503e0 	mov	x0, x21
  40c4a0:	52800002 	mov	w2, #0x0                   	// #0
  40c4a4:	d2800001 	mov	x1, #0x0                   	// #0
  40c4a8:	97ffd42a 	bl	401550 <strtol@plt>
  40c4ac:	17fffff9 	b	40c490 <txt_deserialize_value+0x130>
            if (buf[0] == 't' || buf[0] == '1') {
  40c4b0:	387b6b20 	ldrb	w0, [x25, x27]
  40c4b4:	52800621 	mov	w1, #0x31                  	// #49
  40c4b8:	7101d01f 	cmp	w0, #0x74
  40c4bc:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40c4c0:	540000a1 	b.ne	40c4d4 <txt_deserialize_value+0x174>  // b.any
                *object->data.b = true;
  40c4c4:	f9400a60 	ldr	x0, [x19, #16]
  40c4c8:	52800021 	mov	w1, #0x1                   	// #1
  40c4cc:	39000001 	strb	w1, [x0]
  40c4d0:	17ffffd0 	b	40c410 <txt_deserialize_value+0xb0>
            else if (buf[0] == 'f' || buf[0] == '0') {
  40c4d4:	7101981f 	cmp	w0, #0x66
  40c4d8:	52800601 	mov	w1, #0x30                  	// #48
  40c4dc:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40c4e0:	54fff6c1 	b.ne	40c3b8 <txt_deserialize_value+0x58>  // b.any
                *object->data.b = false;
  40c4e4:	f9400a60 	ldr	x0, [x19, #16]
  40c4e8:	3900001f 	strb	wzr, [x0]
  40c4ec:	17ffffc9 	b	40c410 <txt_deserialize_value+0xb0>
            if (ts->tokens[ts->tok_pos].type != JSMN_STRING || (unsigned int)object->detail <= len)
  40c4f0:	f941d280 	ldr	x0, [x20, #928]
  40c4f4:	8b001280 	add	x0, x20, x0, lsl #4
  40c4f8:	b9407800 	ldr	w0, [x0, #120]
  40c4fc:	7100101f 	cmp	w0, #0x4
  40c500:	54000381 	b.ne	40c570 <txt_deserialize_value+0x210>  // b.any
  40c504:	d371c021 	lsl	x1, x1, #15
    size_t len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40c508:	4b1802e0 	sub	w0, w23, w24
            if (ts->tokens[ts->tok_pos].type != JSMN_STRING || (unsigned int)object->detail <= len)
  40c50c:	13147c21 	asr	w1, w1, #20
    size_t len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40c510:	93407c17 	sxtw	x23, w0
            if (ts->tokens[ts->tok_pos].type != JSMN_STRING || (unsigned int)object->detail <= len)
  40c514:	eb20c03f 	cmp	x1, w0, sxtw
  40c518:	540002c9 	b.ls	40c570 <txt_deserialize_value+0x210>  // b.plast
            if (!check_only) {
  40c51c:	3400019a 	cbz	w26, 40c54c <txt_deserialize_value+0x1ec>
    ts->tok_pos++;
  40c520:	f941d280 	ldr	x0, [x20, #928]
  40c524:	91000400 	add	x0, x0, #0x1
  40c528:	f901d280 	str	x0, [x20, #928]
    return 0;
  40c52c:	52800000 	mov	w0, #0x0                   	// #0
}
  40c530:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c534:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c538:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c53c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40c540:	f9402bfb 	ldr	x27, [sp, #80]
  40c544:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40c548:	d65f03c0 	ret
  40c54c:	f9400a60 	ldr	x0, [x19, #16]
  40c550:	aa1703e2 	mov	x2, x23
  40c554:	aa1503e1 	mov	x1, x21
  40c558:	97ffd422 	bl	4015e0 <strncpy@plt>
                object->data.str[len] = '\0';
  40c55c:	f9400a60 	ldr	x0, [x19, #16]
  40c560:	3837681f 	strb	wzr, [x0, x23]
  40c564:	17ffffab 	b	40c410 <txt_deserialize_value+0xb0>
        return -THINGSET_ERR_DESERIALIZATION_FINISHED;
  40c568:	12801de0 	mov	w0, #0xffffff10            	// #-240
  40c56c:	17fffff1 	b	40c530 <txt_deserialize_value+0x1d0>
                return -THINGSET_ERR_REQUEST_TOO_LARGE;
  40c570:	12801580 	mov	w0, #0xffffff53            	// #-173
  40c574:	17ffffef 	b	40c530 <txt_deserialize_value+0x1d0>

000000000040c578 <txt_deserialize_child>:
{
  40c578:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c57c:	910003fd 	mov	x29, sp
  40c580:	a90153f3 	stp	x19, x20, [sp, #16]
  40c584:	aa0103f4 	mov	x20, x1
    if (ts->tok_pos >= ts->tok_count) {
  40c588:	f941cc01 	ldr	x1, [x0, #920]
  40c58c:	f941d003 	ldr	x3, [x0, #928]
  40c590:	eb01007f 	cmp	x3, x1
  40c594:	540002e2 	b.cs	40c5f0 <txt_deserialize_child+0x78>  // b.hs, b.nlast
  40c598:	8b031003 	add	x3, x0, x3, lsl #4
  40c59c:	aa0003f3 	mov	x19, x0
    if (ts->tokens[ts->tok_pos].type != JSMN_STRING) {
  40c5a0:	b9407861 	ldr	w1, [x3, #120]
  40c5a4:	7100103f 	cmp	w1, #0x4
  40c5a8:	54000281 	b.ne	40c5f8 <txt_deserialize_child+0x80>  // b.any
    size_t name_len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40c5ac:	294f8c61 	ldp	w1, w3, [x3, #124]
    const char *name = (char *)ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40c5b0:	f9402802 	ldr	x2, [x0, #80]
    size_t name_len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40c5b4:	4b010063 	sub	w3, w3, w1
    *object = thingset_get_child_by_name(ts, ts->endpoint.object->id, name, name_len);
  40c5b8:	f941dc04 	ldr	x4, [x0, #952]
  40c5bc:	93407c63 	sxtw	x3, w3
  40c5c0:	8b21c042 	add	x2, x2, w1, sxtw
  40c5c4:	79400481 	ldrh	w1, [x4, #2]
  40c5c8:	97fffb23 	bl	40b254 <thingset_get_child_by_name>
  40c5cc:	f9000280 	str	x0, [x20]
    if (*object == NULL) {
  40c5d0:	b4000180 	cbz	x0, 40c600 <txt_deserialize_child+0x88>
    ts->tok_pos++;
  40c5d4:	f941d260 	ldr	x0, [x19, #928]
  40c5d8:	91000400 	add	x0, x0, #0x1
  40c5dc:	f901d260 	str	x0, [x19, #928]
    return 0;
  40c5e0:	52800000 	mov	w0, #0x0                   	// #0
}
  40c5e4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c5e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c5ec:	d65f03c0 	ret
        return -THINGSET_ERR_DESERIALIZATION_FINISHED;
  40c5f0:	12801de0 	mov	w0, #0xffffff10            	// #-240
  40c5f4:	17fffffc 	b	40c5e4 <txt_deserialize_child+0x6c>
        return -THINGSET_ERR_BAD_REQUEST;
  40c5f8:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40c5fc:	17fffffa 	b	40c5e4 <txt_deserialize_child+0x6c>
        return -THINGSET_ERR_NOT_FOUND;
  40c600:	12801460 	mov	w0, #0xffffff5c            	// #-164
  40c604:	17fffff8 	b	40c5e4 <txt_deserialize_child+0x6c>

000000000040c608 <txt_deserialize_null>:
{
  40c608:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c60c:	910003fd 	mov	x29, sp
  40c610:	a90153f3 	stp	x19, x20, [sp, #16]
  40c614:	aa0003f3 	mov	x19, x0
    if (ts->tok_pos < ts->tok_count) {
  40c618:	f941d014 	ldr	x20, [x0, #928]
  40c61c:	f941cc00 	ldr	x0, [x0, #920]
  40c620:	eb00029f 	cmp	x20, x0
  40c624:	54000262 	b.cs	40c670 <txt_deserialize_null+0x68>  // b.hs, b.nlast
        if (token->type == JSMN_PRIMITIVE
  40c628:	8b141261 	add	x1, x19, x20, lsl #4
  40c62c:	b9407820 	ldr	w0, [x1, #120]
  40c630:	7100201f 	cmp	w0, #0x8
  40c634:	54000221 	b.ne	40c678 <txt_deserialize_null+0x70>  // b.any
            && strncmp(ts->msg_payload + token->start, "null", token->end - token->start) == 0)
  40c638:	294f8820 	ldp	w0, w2, [x1, #124]
  40c63c:	d0000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40c640:	f9402a63 	ldr	x3, [x19, #80]
  40c644:	4b000042 	sub	w2, w2, w0
  40c648:	911c7421 	add	x1, x1, #0x71d
  40c64c:	93407c42 	sxtw	x2, w2
  40c650:	8b20c060 	add	x0, x3, w0, sxtw
  40c654:	97ffd36f 	bl	401410 <strncmp@plt>
  40c658:	35000100 	cbnz	w0, 40c678 <txt_deserialize_null+0x70>
            ts->tok_pos++;
  40c65c:	91000694 	add	x20, x20, #0x1
  40c660:	f901d274 	str	x20, [x19, #928]
}
  40c664:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c668:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c66c:	d65f03c0 	ret
        return -THINGSET_ERR_BAD_REQUEST;
  40c670:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40c674:	17fffffc 	b	40c664 <txt_deserialize_null+0x5c>
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40c678:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40c67c:	17fffffa 	b	40c664 <txt_deserialize_null+0x5c>

000000000040c680 <txt_serialize_name>:
{
  40c680:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40c684:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40c688:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40c68c:	910003fd 	mov	x29, sp
  40c690:	f9000bf3 	str	x19, [sp, #16]
  40c694:	aa0003f3 	mov	x19, x0
  40c698:	911c8884 	add	x4, x4, #0x722
  40c69c:	52800022 	mov	w2, #0x1                   	// #1
  40c6a0:	f9400425 	ldr	x5, [x1, #8]
    int len = snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos, "\"%s\",", object->name);
  40c6a4:	a9459e66 	ldp	x6, x7, [x19, #88]
  40c6a8:	f9403400 	ldr	x0, [x0, #104]
  40c6ac:	cb0000e1 	sub	x1, x7, x0
  40c6b0:	8b0000c0 	add	x0, x6, x0
  40c6b4:	97ffd343 	bl	4013c0 <__snprintf_chk@plt>
    if (len >= 0 && len < ts->rsp_size - ts->rsp_pos) {
  40c6b8:	37f80180 	tbnz	w0, #31, 40c6e8 <txt_serialize_name+0x68>
  40c6bc:	a9460e62 	ldp	x2, x3, [x19, #96]
  40c6c0:	93407c01 	sxtw	x1, w0
  40c6c4:	cb030042 	sub	x2, x2, x3
  40c6c8:	eb20c05f 	cmp	x2, w0, sxtw
  40c6cc:	540000e9 	b.ls	40c6e8 <txt_serialize_name+0x68>  // b.plast
        ts->rsp_pos += len;
  40c6d0:	8b030021 	add	x1, x1, x3
        return 0;
  40c6d4:	52800000 	mov	w0, #0x0                   	// #0
  40c6d8:	f9003661 	str	x1, [x19, #104]
}
  40c6dc:	f9400bf3 	ldr	x19, [sp, #16]
  40c6e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c6e4:	d65f03c0 	ret
        ts->rsp_pos = 0;
  40c6e8:	d2800001 	mov	x1, #0x0                   	// #0
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40c6ec:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40c6f0:	17fffffa 	b	40c6d8 <txt_serialize_name+0x58>

000000000040c6f4 <txt_serialize_report_header>:
{
  40c6f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c6f8:	aa0103e5 	mov	x5, x1
  40c6fc:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40c700:	910003fd 	mov	x29, sp
  40c704:	f9000bf3 	str	x19, [sp, #16]
  40c708:	aa0003f3 	mov	x19, x0
  40c70c:	52800022 	mov	w2, #0x1                   	// #1
  40c710:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40c714:	a9458400 	ldp	x0, x1, [x0, #88]
  40c718:	911ca084 	add	x4, x4, #0x728
  40c71c:	97ffd329 	bl	4013c0 <__snprintf_chk@plt>
    ts->rsp_pos = snprintf(ts->rsp, ts->rsp_size, "#%s ", path);
  40c720:	93407c00 	sxtw	x0, w0
    if (ts->rsp_pos < 0 || ts->rsp_pos > ts->rsp_size) {
  40c724:	f9403261 	ldr	x1, [x19, #96]
    ts->rsp_pos = snprintf(ts->rsp, ts->rsp_size, "#%s ", path);
  40c728:	f9003660 	str	x0, [x19, #104]
        return 0;
  40c72c:	eb01001f 	cmp	x0, x1
}
  40c730:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40c734:	1a9f8000 	csel	w0, w0, wzr, hi  // hi = pmore
  40c738:	f9400bf3 	ldr	x19, [sp, #16]
  40c73c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c740:	d65f03c0 	ret

000000000040c744 <json_serialize_simple_value>:
    switch (type) {
  40c744:	71002c7f 	cmp	w3, #0xb
  40c748:	54000a28 	b.hi	40c88c <json_serialize_simple_value+0x148>  // b.pmore
{
  40c74c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40c750:	910003fd 	mov	x29, sp
  40c754:	f9000bf3 	str	x19, [sp, #16]
  40c758:	aa0103f3 	mov	x19, x1
    switch (type) {
  40c75c:	90000041 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  40c760:	9121d021 	add	x1, x1, #0x874
  40c764:	38634821 	ldrb	w1, [x1, w3, uxtw]
  40c768:	10000063 	adr	x3, 40c774 <json_serialize_simple_value+0x30>
  40c76c:	8b218861 	add	x1, x3, w1, sxtb #2
  40c770:	d61f0020 	br	x1
  40c774:	b9400045 	ldr	w5, [x2]
  40c778:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40c77c:	911cb484 	add	x4, x4, #0x72d
  40c780:	14000004 	b	40c790 <json_serialize_simple_value+0x4c>
  40c784:	b9400045 	ldr	w5, [x2]
  40c788:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40c78c:	911cc484 	add	x4, x4, #0x731
  40c790:	aa1303e1 	mov	x1, x19
  40c794:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40c798:	52800022 	mov	w2, #0x1                   	// #1
  40c79c:	97ffd309 	bl	4013c0 <__snprintf_chk@plt>
    if (pos >= 0 && pos < size) {
  40c7a0:	37f80720 	tbnz	w0, #31, 40c884 <json_serialize_simple_value+0x140>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40c7a4:	eb20c27f 	cmp	x19, w0, sxtw
  40c7a8:	12801c01 	mov	w1, #0xffffff1f            	// #-225
  40c7ac:	1a818000 	csel	w0, w0, w1, hi  // hi = pmore
}
  40c7b0:	f9400bf3 	ldr	x19, [sp, #16]
  40c7b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c7b8:	d65f03c0 	ret
  40c7bc:	79400045 	ldrh	w5, [x2]
  40c7c0:	17ffffee 	b	40c778 <json_serialize_simple_value+0x34>
  40c7c4:	79c00045 	ldrsh	w5, [x2]
  40c7c8:	17fffff0 	b	40c788 <json_serialize_simple_value+0x44>
  40c7cc:	39400045 	ldrb	w5, [x2]
  40c7d0:	17ffffea 	b	40c778 <json_serialize_simple_value+0x34>
  40c7d4:	39c00045 	ldrsb	w5, [x2]
  40c7d8:	17ffffec 	b	40c788 <json_serialize_simple_value+0x44>
            if (isnan(*data.f32) || isinf(*data.f32)) {
  40c7dc:	bd400040 	ldr	s0, [x2]
  40c7e0:	1e202000 	fcmp	s0, s0
  40c7e4:	540000c6 	b.vs	40c7fc <json_serialize_simple_value+0xb8>
  40c7e8:	1e20c001 	fabs	s1, s0
  40c7ec:	12b01001 	mov	w1, #0x7f7fffff            	// #2139095039
  40c7f0:	1e270022 	fmov	s2, w1
  40c7f4:	1e222020 	fcmp	s1, s2
  40c7f8:	540000cd 	b.le	40c810 <json_serialize_simple_value+0xcc>
  40c7fc:	aa1303e1 	mov	x1, x19
  40c800:	d0000042 	adrp	x2, 416000 <__func__.0+0x57a>
  40c804:	911cd442 	add	x2, x2, #0x735
  40c808:	97ffd2e6 	bl	4013a0 <snprintf@plt>
                break;
  40c80c:	17ffffe5 	b	40c7a0 <json_serialize_simple_value+0x5c>
  40c810:	1e22c000 	fcvt	d0, s0
  40c814:	2a0403e5 	mov	w5, w4
  40c818:	aa1303e1 	mov	x1, x19
  40c81c:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40c820:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40c824:	911cec84 	add	x4, x4, #0x73b
  40c828:	52800022 	mov	w2, #0x1                   	// #1
  40c82c:	97ffd2e5 	bl	4013c0 <__snprintf_chk@plt>
                break;
  40c830:	17ffffdc 	b	40c7a0 <json_serialize_simple_value+0x5c>
            pos = snprintf(buf, size, "%s,", *data.b == true ? "true" : "false");
  40c834:	39400042 	ldrb	w2, [x2]
  40c838:	b0000041 	adrp	x1, 415000 <__func__.2+0x30c>
  40c83c:	b0000045 	adrp	x5, 415000 <__func__.2+0x30c>
  40c840:	9130a421 	add	x1, x1, #0xc29
  40c844:	7100005f 	cmp	w2, #0x0
  40c848:	9130bca5 	add	x5, x5, #0xc2f
  40c84c:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40c850:	9a8110a5 	csel	x5, x5, x1, ne  // ne = any
  40c854:	911d0484 	add	x4, x4, #0x741
  40c858:	aa1303e1 	mov	x1, x19
  40c85c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40c860:	52800022 	mov	w2, #0x1                   	// #1
  40c864:	97ffd2d7 	bl	4013c0 <__snprintf_chk@plt>
            break;
  40c868:	17ffffce 	b	40c7a0 <json_serialize_simple_value+0x5c>
  40c86c:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40c870:	aa0203e5 	mov	x5, x2
  40c874:	911c8884 	add	x4, x4, #0x722
  40c878:	17fffff8 	b	40c858 <json_serialize_simple_value+0x114>
    switch (type) {
  40c87c:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40c880:	17ffffcc 	b	40c7b0 <json_serialize_simple_value+0x6c>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40c884:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40c888:	17ffffca 	b	40c7b0 <json_serialize_simple_value+0x6c>
    switch (type) {
  40c88c:	128015c0 	mov	w0, #0xffffff51            	// #-175
}
  40c890:	d65f03c0 	ret

000000000040c894 <txt_serialize_subsets>:
{
  40c894:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40c898:	910003fd 	mov	x29, sp
  40c89c:	a90153f3 	stp	x19, x20, [sp, #16]
  40c8a0:	aa0003f3 	mov	x19, x0
  40c8a4:	90000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40c8a8:	a9025bf5 	stp	x21, x22, [sp, #32]
            else if (depth > 0 && parent_id != ancestors[depth - 1]->id) {
  40c8ac:	9101a3f6 	add	x22, sp, #0x68
    int depth = 0;
  40c8b0:	52800014 	mov	w20, #0x0                   	// #0
{
  40c8b4:	f9478400 	ldr	x0, [x0, #3848]
  40c8b8:	a90363f7 	stp	x23, x24, [sp, #48]
  40c8bc:	d0000057 	adrp	x23, 416000 <__func__.0+0x57a>
  40c8c0:	a9046bf9 	stp	x25, x26, [sp, #64]
  40c8c4:	12003c39 	and	w25, w1, #0xffff
  40c8c8:	911d16f7 	add	x23, x23, #0x745
  40c8cc:	f9002bfb 	str	x27, [sp, #80]
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40c8d0:	52800018 	mov	w24, #0x0                   	// #0
{
  40c8d4:	f9400001 	ldr	x1, [x0]
  40c8d8:	f9003fe1 	str	x1, [sp, #120]
  40c8dc:	d2800001 	mov	x1, #0x0                   	// #0
    ts->rsp[ts->rsp_pos++] = '{';
  40c8e0:	f9402e61 	ldr	x1, [x19, #88]
  40c8e4:	f9403660 	ldr	x0, [x19, #104]
  40c8e8:	91000402 	add	x2, x0, #0x1
  40c8ec:	f9003662 	str	x2, [x19, #104]
  40c8f0:	52800f62 	mov	w2, #0x7b                  	// #123
  40c8f4:	38206822 	strb	w2, [x1, x0]
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40c8f8:	f9400661 	ldr	x1, [x19, #8]
  40c8fc:	2a1803e0 	mov	w0, w24
  40c900:	eb38403f 	cmp	x1, w24, uxtw
  40c904:	54000388 	b.hi	40c974 <txt_serialize_subsets+0xe0>  // b.pmore
    ts->rsp_pos--; /* overwrite internal comma */
  40c908:	f9403660 	ldr	x0, [x19, #104]
        ts->rsp[ts->rsp_pos++] = '}';
  40c90c:	52800fa2 	mov	w2, #0x7d                  	// #125
    ts->rsp_pos--; /* overwrite internal comma */
  40c910:	d1000400 	sub	x0, x0, #0x1
  40c914:	f9003660 	str	x0, [x19, #104]
        ts->rsp[ts->rsp_pos++] = '}';
  40c918:	f9402e61 	ldr	x1, [x19, #88]
        depth--;
  40c91c:	51000694 	sub	w20, w20, #0x1
        ts->rsp[ts->rsp_pos++] = '}';
  40c920:	f9403660 	ldr	x0, [x19, #104]
  40c924:	91000403 	add	x3, x0, #0x1
  40c928:	f9003663 	str	x3, [x19, #104]
  40c92c:	38206822 	strb	w2, [x1, x0]
    while (depth >= 0) {
  40c930:	3100069f 	cmn	w20, #0x1
  40c934:	54ffff21 	b.ne	40c918 <txt_serialize_subsets+0x84>  // b.any
    ts->rsp[ts->rsp_pos++] = ',';
  40c938:	f9402e61 	ldr	x1, [x19, #88]
  40c93c:	f9403660 	ldr	x0, [x19, #104]
  40c940:	91000402 	add	x2, x0, #0x1
  40c944:	f9003662 	str	x2, [x19, #104]
  40c948:	52800582 	mov	w2, #0x2c                  	// #44
  40c94c:	38206822 	strb	w2, [x1, x0]
    return 0;
  40c950:	52800000 	mov	w0, #0x0                   	// #0
}
  40c954:	90000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40c958:	f9478421 	ldr	x1, [x1, #3848]
  40c95c:	f9403fe3 	ldr	x3, [sp, #120]
  40c960:	f9400022 	ldr	x2, [x1]
  40c964:	eb020063 	subs	x3, x3, x2
  40c968:	d2800002 	mov	x2, #0x0                   	// #0
  40c96c:	54000f60 	b.eq	40cb58 <txt_serialize_subsets+0x2c4>  // b.none
  40c970:	97ffd2d0 	bl	4014b0 <__stack_chk_fail@plt>
        if (ts->data_objects[i].subsets & subsets) {
  40c974:	f9400261 	ldr	x1, [x19]
  40c978:	d37be81b 	lsl	x27, x0, #5
  40c97c:	8b001420 	add	x0, x1, x0, lsl #5
  40c980:	f9400c00 	ldr	x0, [x0, #24]
  40c984:	6a40673f 	tst	w25, w0, lsr #25
  40c988:	54000800 	b.eq	40ca88 <txt_serialize_subsets+0x1f4>  // b.none
            const uint16_t parent_id = ts->data_objects[i].parent_id;
  40c98c:	787b683a 	ldrh	w26, [x1, x27]
            if (depth > 0 && parent_id == ancestors[depth - 1]->id) {
  40c990:	340000d4 	cbz	w20, 40c9a8 <txt_serialize_subsets+0x114>
  40c994:	51000680 	sub	w0, w20, #0x1
  40c998:	f860dad5 	ldr	x21, [x22, w0, sxtw #3]
  40c99c:	794006a0 	ldrh	w0, [x21, #2]
  40c9a0:	6b1a001f 	cmp	w0, w26
  40c9a4:	540000e0 	b.eq	40c9c0 <txt_serialize_subsets+0x12c>  // b.none
            else if (parent_id != 0) {
  40c9a8:	340007fa 	cbz	w26, 40caa4 <txt_serialize_subsets+0x210>
                parent = thingset_get_object_by_id(ts, parent_id);
  40c9ac:	2a1a03e1 	mov	w1, w26
  40c9b0:	aa1303e0 	mov	x0, x19
  40c9b4:	97fffa51 	bl	40b2f8 <thingset_get_object_by_id>
  40c9b8:	aa0003f5 	mov	x21, x0
            if (depth > 0 && parent_id != ancestors[depth - 1]->id && parent != NULL
  40c9bc:	340002d4 	cbz	w20, 40ca14 <txt_serialize_subsets+0x180>
  40c9c0:	51000681 	sub	w1, w20, #0x1
  40c9c4:	f861dac0 	ldr	x0, [x22, w1, sxtw #3]
  40c9c8:	79400400 	ldrh	w0, [x0, #2]
  40c9cc:	6b1a001f 	cmp	w0, w26
  40c9d0:	54000220 	b.eq	40ca14 <txt_serialize_subsets+0x180>  // b.none
  40c9d4:	b4000215 	cbz	x21, 40ca14 <txt_serialize_subsets+0x180>
                && parent->parent_id != ancestors[depth - 1]->id)
  40c9d8:	794002a2 	ldrh	w2, [x21]
  40c9dc:	6b00005f 	cmp	w2, w0
  40c9e0:	540001a0 	b.eq	40ca14 <txt_serialize_subsets+0x180>  // b.none
                ts->rsp[ts->rsp_pos - 1] = '}'; /* overwrite comma */
  40c9e4:	f9402e60 	ldr	x0, [x19, #88]
                depth--;
  40c9e8:	2a0103f4 	mov	w20, w1
                ts->rsp[ts->rsp_pos - 1] = '}'; /* overwrite comma */
  40c9ec:	f9403662 	ldr	x2, [x19, #104]
  40c9f0:	8b020000 	add	x0, x0, x2
  40c9f4:	52800fa2 	mov	w2, #0x7d                  	// #125
  40c9f8:	381ff002 	sturb	w2, [x0, #-1]
                ts->rsp[ts->rsp_pos++] = ',';
  40c9fc:	f9402e62 	ldr	x2, [x19, #88]
  40ca00:	f9403660 	ldr	x0, [x19, #104]
  40ca04:	91000403 	add	x3, x0, #0x1
  40ca08:	f9003663 	str	x3, [x19, #104]
  40ca0c:	52800583 	mov	w3, #0x2c                  	// #44
  40ca10:	38206843 	strb	w3, [x2, x0]
            if (depth == 0 && parent != NULL) {
  40ca14:	7100029f 	cmp	w20, #0x0
  40ca18:	fa400aa4 	ccmp	x21, #0x0, #0x4, eq  // eq = none
  40ca1c:	540006e0 	b.eq	40caf8 <txt_serialize_subsets+0x264>  // b.none
                if (parent->parent_id != 0) {
  40ca20:	794002a1 	ldrh	w1, [x21]
  40ca24:	35000441 	cbnz	w1, 40caac <txt_serialize_subsets+0x218>
                depth--;
  40ca28:	5280001a 	mov	w26, #0x0                   	// #0
                ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40ca2c:	a9458666 	ldp	x6, x1, [x19, #88]
  40ca30:	aa1703e4 	mov	x4, x23
  40ca34:	f94006a5 	ldr	x5, [x21, #8]
  40ca38:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40ca3c:	f9403660 	ldr	x0, [x19, #104]
  40ca40:	52800022 	mov	w2, #0x1                   	// #1
                ancestors[depth++] = parent;
  40ca44:	11000754 	add	w20, w26, #0x1
  40ca48:	cb000021 	sub	x1, x1, x0
  40ca4c:	8b0000c0 	add	x0, x6, x0
  40ca50:	97ffd25c 	bl	4013c0 <__snprintf_chk@plt>
  40ca54:	f83adad5 	str	x21, [x22, w26, sxtw #3]
                ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40ca58:	f9403661 	ldr	x1, [x19, #104]
  40ca5c:	8b20c020 	add	x0, x1, w0, sxtw
  40ca60:	f9003660 	str	x0, [x19, #104]
            ts->rsp_pos += ts->api->serialize_key_value(ts, &ts->data_objects[i]);
  40ca64:	f9403a60 	ldr	x0, [x19, #112]
  40ca68:	f9400261 	ldr	x1, [x19]
  40ca6c:	f9401002 	ldr	x2, [x0, #32]
  40ca70:	8b1b0021 	add	x1, x1, x27
  40ca74:	aa1303e0 	mov	x0, x19
  40ca78:	d63f0040 	blr	x2
  40ca7c:	f9403661 	ldr	x1, [x19, #104]
  40ca80:	8b20c020 	add	x0, x1, w0, sxtw
  40ca84:	f9003660 	str	x0, [x19, #104]
        if (ts->rsp_pos >= ts->rsp_size - 1 - depth) {
  40ca88:	a9460660 	ldp	x0, x1, [x19, #96]
  40ca8c:	d1000400 	sub	x0, x0, #0x1
  40ca90:	cb34c000 	sub	x0, x0, w20, sxtw
  40ca94:	eb00003f 	cmp	x1, x0
  40ca98:	540005c2 	b.cs	40cb50 <txt_serialize_subsets+0x2bc>  // b.hs, b.nlast
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40ca9c:	11000718 	add	w24, w24, #0x1
  40caa0:	17ffff96 	b	40c8f8 <txt_serialize_subsets+0x64>
            struct thingset_data_object *parent = NULL;
  40caa4:	d2800015 	mov	x21, #0x0                   	// #0
  40caa8:	17ffffc5 	b	40c9bc <txt_serialize_subsets+0x128>
                        thingset_get_object_by_id(ts, parent->parent_id);
  40caac:	aa1303e0 	mov	x0, x19
  40cab0:	97fffa12 	bl	40b2f8 <thingset_get_object_by_id>
  40cab4:	aa0003f4 	mov	x20, x0
                    if (grandparent != NULL) {
  40cab8:	b4fffb80 	cbz	x0, 40ca28 <txt_serialize_subsets+0x194>
                        ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40cabc:	a9458666 	ldp	x6, x1, [x19, #88]
  40cac0:	aa1703e4 	mov	x4, x23
  40cac4:	f9400685 	ldr	x5, [x20, #8]
  40cac8:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40cacc:	f9403660 	ldr	x0, [x19, #104]
  40cad0:	52800022 	mov	w2, #0x1                   	// #1
                        ancestors[depth++] = grandparent;
  40cad4:	5280003a 	mov	w26, #0x1                   	// #1
  40cad8:	cb000021 	sub	x1, x1, x0
  40cadc:	8b0000c0 	add	x0, x6, x0
  40cae0:	97ffd238 	bl	4013c0 <__snprintf_chk@plt>
  40cae4:	f90037f4 	str	x20, [sp, #104]
                        ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40cae8:	f9403661 	ldr	x1, [x19, #104]
  40caec:	8b20c020 	add	x0, x1, w0, sxtw
  40caf0:	f9003660 	str	x0, [x19, #104]
                        ancestors[depth++] = grandparent;
  40caf4:	17ffffce 	b	40ca2c <txt_serialize_subsets+0x198>
            else if (depth > 0 && parent_id != ancestors[depth - 1]->id) {
  40caf8:	34fffb74 	cbz	w20, 40ca64 <txt_serialize_subsets+0x1d0>
  40cafc:	51000680 	sub	w0, w20, #0x1
  40cb00:	f860dac0 	ldr	x0, [x22, w0, sxtw #3]
  40cb04:	79400400 	ldrh	w0, [x0, #2]
  40cb08:	6b1a001f 	cmp	w0, w26
  40cb0c:	54fffac0 	b.eq	40ca64 <txt_serialize_subsets+0x1d0>  // b.none
                if (parent != NULL) {
  40cb10:	b4fffab5 	cbz	x21, 40ca64 <txt_serialize_subsets+0x1d0>
                    ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40cb14:	a9458666 	ldp	x6, x1, [x19, #88]
  40cb18:	aa1703e4 	mov	x4, x23
  40cb1c:	f94006a5 	ldr	x5, [x21, #8]
  40cb20:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40cb24:	f9403660 	ldr	x0, [x19, #104]
  40cb28:	52800022 	mov	w2, #0x1                   	// #1
  40cb2c:	cb000021 	sub	x1, x1, x0
  40cb30:	8b0000c0 	add	x0, x6, x0
  40cb34:	97ffd223 	bl	4013c0 <__snprintf_chk@plt>
                    ancestors[depth++] = parent;
  40cb38:	f834dad5 	str	x21, [x22, w20, sxtw #3]
                    ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40cb3c:	f9403661 	ldr	x1, [x19, #104]
                    ancestors[depth++] = parent;
  40cb40:	11000694 	add	w20, w20, #0x1
                    ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40cb44:	8b20c020 	add	x0, x1, w0, sxtw
  40cb48:	f9003660 	str	x0, [x19, #104]
                    ancestors[depth++] = parent;
  40cb4c:	17ffffc6 	b	40ca64 <txt_serialize_subsets+0x1d0>
            return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40cb50:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40cb54:	17ffff80 	b	40c954 <txt_serialize_subsets+0xc0>
}
  40cb58:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cb5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40cb60:	a94363f7 	ldp	x23, x24, [sp, #48]
  40cb64:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40cb68:	f9402bfb 	ldr	x27, [sp, #80]
  40cb6c:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40cb70:	d65f03c0 	ret

000000000040cb74 <txt_serialize_value>:
{
  40cb74:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40cb78:	910003fd 	mov	x29, sp
  40cb7c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40cb80:	aa0003f5 	mov	x21, x0
  40cb84:	90000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40cb88:	a90153f3 	stp	x19, x20, [sp, #16]
  40cb8c:	a90363f7 	stp	x23, x24, [sp, #48]
  40cb90:	aa0103f7 	mov	x23, x1
  40cb94:	a9046bf9 	stp	x25, x26, [sp, #64]
    size_t size = ts->rsp_size - ts->rsp_pos;
  40cb98:	a945d2b6 	ldp	x22, x20, [x21, #88]
{
  40cb9c:	f9002bfb 	str	x27, [sp, #80]
  40cba0:	f9478400 	ldr	x0, [x0, #3848]
    int pos = json_serialize_simple_value(buf, size, object->data, object->type, object->detail);
  40cba4:	a9410ee2 	ldp	x2, x3, [x23, #16]
{
  40cba8:	f9400001 	ldr	x1, [x0]
  40cbac:	f9003fe1 	str	x1, [sp, #120]
  40cbb0:	d2800001 	mov	x1, #0x0                   	// #0
    char *buf = ts->rsp + ts->rsp_pos;
  40cbb4:	f94036a0 	ldr	x0, [x21, #104]
    size_t size = ts->rsp_size - ts->rsp_pos;
  40cbb8:	cb000294 	sub	x20, x20, x0
    char *buf = ts->rsp + ts->rsp_pos;
  40cbbc:	8b0002d6 	add	x22, x22, x0
    int pos = json_serialize_simple_value(buf, size, object->data, object->type, object->detail);
  40cbc0:	93454064 	sbfx	x4, x3, #5, #12
  40cbc4:	aa1403e1 	mov	x1, x20
  40cbc8:	aa1603e0 	mov	x0, x22
  40cbcc:	12001063 	and	w3, w3, #0x1f
  40cbd0:	13003c84 	sxth	w4, w4
  40cbd4:	97fffedc 	bl	40c744 <json_serialize_simple_value>
    if (pos < 0) {
  40cbd8:	36f80160 	tbz	w0, #31, 40cc04 <txt_serialize_value+0x90>
        if (object->type == THINGSET_TYPE_GROUP) {
  40cbdc:	b9401ae0 	ldr	w0, [x23, #24]
  40cbe0:	12001000 	and	w0, w0, #0x1f
  40cbe4:	71003c1f 	cmp	w0, #0xf
  40cbe8:	540002c1 	b.ne	40cc40 <txt_serialize_value+0xcc>  // b.any
  40cbec:	d0000042 	adrp	x2, 416000 <__func__.0+0x57a>
  40cbf0:	aa1403e1 	mov	x1, x20
  40cbf4:	911cd442 	add	x2, x2, #0x735
  40cbf8:	aa1603e0 	mov	x0, x22
  40cbfc:	97ffd1e9 	bl	4013a0 <snprintf@plt>
    if (pos >= 0 && pos < size) {
  40cc00:	37f81300 	tbnz	w0, #31, 40ce60 <txt_serialize_value+0x2ec>
  40cc04:	93407c01 	sxtw	x1, w0
  40cc08:	eb20c29f 	cmp	x20, w0, sxtw
  40cc0c:	540012a9 	b.ls	40ce60 <txt_serialize_value+0x2ec>  // b.plast
        ts->rsp_pos += pos;
  40cc10:	f94036a0 	ldr	x0, [x21, #104]
  40cc14:	8b000021 	add	x1, x1, x0
        return 0;
  40cc18:	52800000 	mov	w0, #0x0                   	// #0
            ts->rsp_pos = 0;
  40cc1c:	f90036a1 	str	x1, [x21, #104]
}
  40cc20:	90000101 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40cc24:	f9478421 	ldr	x1, [x1, #3848]
  40cc28:	f9403fe3 	ldr	x3, [sp, #120]
  40cc2c:	f9400022 	ldr	x2, [x1]
  40cc30:	eb020063 	subs	x3, x3, x2
  40cc34:	d2800002 	mov	x2, #0x0                   	// #0
  40cc38:	54001200 	b.eq	40ce78 <txt_serialize_value+0x304>  // b.none
  40cc3c:	97ffd21d 	bl	4014b0 <__stack_chk_fail@plt>
        else if (object->type == THINGSET_TYPE_RECORDS) {
  40cc40:	51003400 	sub	w0, w0, #0xd
  40cc44:	7100141f 	cmp	w0, #0x5
  40cc48:	54001128 	b.hi	40ce6c <txt_serialize_value+0x2f8>  // b.pmore
  40cc4c:	90000041 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  40cc50:	91220021 	add	x1, x1, #0x880
  40cc54:	78605821 	ldrh	w1, [x1, w0, uxtw #1]
  40cc58:	10000060 	adr	x0, 40cc64 <txt_serialize_value+0xf0>
  40cc5c:	8b21a801 	add	x1, x0, w1, sxth #2
  40cc60:	d61f0020 	br	x1
            pos = snprintf(buf, size, "%d,", object->data.records->num_records);
  40cc64:	f9400ae0 	ldr	x0, [x23, #16]
  40cc68:	aa1403e1 	mov	x1, x20
  40cc6c:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40cc70:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40cc74:	911d3084 	add	x4, x4, #0x74c
  40cc78:	52800022 	mov	w2, #0x1                   	// #1
  40cc7c:	79402405 	ldrh	w5, [x0, #18]
  40cc80:	aa1603e0 	mov	x0, x22
  40cc84:	97ffd1cf 	bl	4013c0 <__snprintf_chk@plt>
  40cc88:	17ffffde 	b	40cc00 <txt_serialize_value+0x8c>
  40cc8c:	aa1403e1 	mov	x1, x20
  40cc90:	aa1603e0 	mov	x0, x22
  40cc94:	d0000042 	adrp	x2, 416000 <__func__.0+0x57a>
  40cc98:	d0000059 	adrp	x25, 416000 <__func__.0+0x57a>
  40cc9c:	911d4042 	add	x2, x2, #0x750
  40cca0:	911c8b39 	add	x25, x25, #0x722
  40cca4:	97ffd1bf 	bl	4013a0 <snprintf@plt>
  40cca8:	2a0003f3 	mov	w19, w0
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40ccac:	52800018 	mov	w24, #0x0                   	// #0
  40ccb0:	f94006a1 	ldr	x1, [x21, #8]
  40ccb4:	2a1803e0 	mov	w0, w24
  40ccb8:	eb38403f 	cmp	x1, w24, uxtw
  40ccbc:	54000168 	b.hi	40cce8 <txt_serialize_value+0x174>  // b.pmore
                pos--; /* remove trailing comma */
  40ccc0:	7100067f 	cmp	w19, #0x1
  40ccc4:	1a9fd7e0 	cset	w0, gt
                pos--; /* remove trailing comma */
  40ccc8:	4b000273 	sub	w19, w19, w0
  40cccc:	d0000042 	adrp	x2, 416000 <__func__.0+0x57a>
  40ccd0:	911d4842 	add	x2, x2, #0x752
  40ccd4:	cb33c281 	sub	x1, x20, w19, sxtw
  40ccd8:	8b33c2c0 	add	x0, x22, w19, sxtw
  40ccdc:	97ffd1b1 	bl	4013a0 <snprintf@plt>
            pos += snprintf(buf + pos, size - pos, "],");
  40cce0:	0b000260 	add	w0, w19, w0
        else if (object->type == THINGSET_TYPE_ARRAY && object->data.array != NULL) {
  40cce4:	17ffffc7 	b	40cc00 <txt_serialize_value+0x8c>
                if (ts->data_objects[i].parent_id == object->id) {
  40cce8:	f94002a1 	ldr	x1, [x21]
  40ccec:	d37be802 	lsl	x2, x0, #5
  40ccf0:	8b001420 	add	x0, x1, x0, lsl #5
  40ccf4:	78626822 	ldrh	w2, [x1, x2]
  40ccf8:	794006e1 	ldrh	w1, [x23, #2]
  40ccfc:	6b01005f 	cmp	w2, w1
  40cd00:	54000121 	b.ne	40cd24 <txt_serialize_value+0x1b0>  // b.any
  40cd04:	f9400405 	ldr	x5, [x0, #8]
  40cd08:	cb33c281 	sub	x1, x20, w19, sxtw
  40cd0c:	8b33c2c0 	add	x0, x22, w19, sxtw
  40cd10:	aa1903e4 	mov	x4, x25
  40cd14:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40cd18:	52800022 	mov	w2, #0x1                   	// #1
  40cd1c:	97ffd1a9 	bl	4013c0 <__snprintf_chk@plt>
                    pos += snprintf(buf + pos, size - pos, "\"%s\",", ts->data_objects[i].name);
  40cd20:	0b000273 	add	w19, w19, w0
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cd24:	11000718 	add	w24, w24, #0x1
  40cd28:	17ffffe2 	b	40ccb0 <txt_serialize_value+0x13c>
  40cd2c:	aa1403e1 	mov	x1, x20
  40cd30:	aa1603e0 	mov	x0, x22
  40cd34:	d0000042 	adrp	x2, 416000 <__func__.0+0x57a>
  40cd38:	911d4042 	add	x2, x2, #0x750
  40cd3c:	97ffd199 	bl	4013a0 <snprintf@plt>
  40cd40:	2a0003f3 	mov	w19, w0
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cd44:	52800019 	mov	w25, #0x0                   	// #0
                    buf[pos++] = '"';
  40cd48:	5280045a 	mov	w26, #0x22                  	// #34
                    buf[pos++] = ',';
  40cd4c:	5280059b 	mov	w27, #0x2c                  	// #44
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cd50:	f94006a1 	ldr	x1, [x21, #8]
  40cd54:	2a1903e0 	mov	w0, w25
  40cd58:	eb39403f 	cmp	x1, w25, uxtw
  40cd5c:	54fffb29 	b.ls	40ccc0 <txt_serialize_value+0x14c>  // b.plast
                if (ts->data_objects[i].subsets & object->data.subset) {
  40cd60:	f94002a2 	ldr	x2, [x21]
  40cd64:	d37be801 	lsl	x1, x0, #5
  40cd68:	8b001440 	add	x0, x2, x0, lsl #5
  40cd6c:	f9400c02 	ldr	x2, [x0, #24]
  40cd70:	b94012e0 	ldr	w0, [x23, #16]
  40cd74:	6a42641f 	tst	w0, w2, lsr #25
  40cd78:	540001c0 	b.eq	40cdb0 <txt_serialize_value+0x23c>  // b.none
                    buf[pos++] = '"';
  40cd7c:	3833cada 	strb	w26, [x22, w19, sxtw]
  40cd80:	11000678 	add	w24, w19, #0x1
                    pos += thingset_get_path(ts, buf + pos, size - pos, &ts->data_objects[i]);
  40cd84:	aa1503e0 	mov	x0, x21
  40cd88:	f94002a3 	ldr	x3, [x21]
  40cd8c:	cb38c282 	sub	x2, x20, w24, sxtw
  40cd90:	8b010063 	add	x3, x3, x1
  40cd94:	8b38c2c1 	add	x1, x22, w24, sxtw
  40cd98:	97fff968 	bl	40b338 <thingset_get_path>
  40cd9c:	0b000318 	add	w24, w24, w0
                    buf[pos++] = ',';
  40cda0:	11000b13 	add	w19, w24, #0x2
                    buf[pos++] = '"';
  40cda4:	3838cada 	strb	w26, [x22, w24, sxtw]
  40cda8:	11000718 	add	w24, w24, #0x1
                    buf[pos++] = ',';
  40cdac:	3838cadb 	strb	w27, [x22, w24, sxtw]
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cdb0:	11000739 	add	w25, w25, #0x1
  40cdb4:	17ffffe7 	b	40cd50 <txt_serialize_value+0x1dc>
        else if (object->type == THINGSET_TYPE_ARRAY && object->data.array != NULL) {
  40cdb8:	f9400af7 	ldr	x23, [x23, #16]
  40cdbc:	b4000597 	cbz	x23, 40ce6c <txt_serialize_value+0x2f8>
  40cdc0:	aa1403e1 	mov	x1, x20
  40cdc4:	aa1603e0 	mov	x0, x22
  40cdc8:	d0000042 	adrp	x2, 416000 <__func__.0+0x57a>
  40cdcc:	911d4042 	add	x2, x2, #0x750
  40cdd0:	97ffd174 	bl	4013a0 <snprintf@plt>
  40cdd4:	2a0003f3 	mov	w19, w0
    uint8_t sizes[] = { sizeof(bool),    sizeof(uint8_t),  sizeof(int8_t),  sizeof(uint16_t),
  40cdd8:	d0000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40cddc:	911c4421 	add	x1, x1, #0x711
            size_t type_size = thingset_type_size(array->element_type);
  40cde0:	b9400ae0 	ldr	w0, [x23, #8]
  40cde4:	9101a3e2 	add	x2, sp, #0x68
  40cde8:	f9400023 	ldr	x3, [x1]
  40cdec:	f90037e3 	str	x3, [sp, #104]
  40cdf0:	b8407021 	ldur	w1, [x1, #7]
  40cdf4:	b806f3e1 	stur	w1, [sp, #111]
    return type < sizeof(sizes) ? sizes[type] : 0;
  40cdf8:	12001c01 	and	w1, w0, #0xff
  40cdfc:	7100283f 	cmp	w1, #0xa
  40ce00:	54000168 	b.hi	40ce2c <txt_serialize_value+0x2b8>  // b.pmore
  40ce04:	92401c00 	and	x0, x0, #0xff
  40ce08:	3860685a 	ldrb	w26, [x2, x0]
            for (int i = 0; i < array->num_elements; i++) {
  40ce0c:	d2800019 	mov	x25, #0x0                   	// #0
  40ce10:	52800018 	mov	w24, #0x0                   	// #0
  40ce14:	794022e0 	ldrh	w0, [x23, #16]
  40ce18:	6b18001f 	cmp	w0, w24
  40ce1c:	540000cc 	b.gt	40ce34 <txt_serialize_value+0x2c0>
                pos--; /* remove trailing comma */
  40ce20:	7100001f 	cmp	w0, #0x0
  40ce24:	1a9f07e0 	cset	w0, ne  // ne = any
  40ce28:	17ffffa8 	b	40ccc8 <txt_serialize_value+0x154>
  40ce2c:	d280001a 	mov	x26, #0x0                   	// #0
  40ce30:	17fffff7 	b	40ce0c <txt_serialize_value+0x298>
                pos += json_serialize_simple_value(buf + pos, size - pos, data, array->element_type,
  40ce34:	79c01ae4 	ldrsh	w4, [x23, #12]
  40ce38:	cb33c281 	sub	x1, x20, w19, sxtw
  40ce3c:	b9400ae3 	ldr	w3, [x23, #8]
  40ce40:	8b33c2c0 	add	x0, x22, w19, sxtw
                union thingset_data_pointer data = { .u8 = array->elements.u8 + i * type_size };
  40ce44:	f94002e2 	ldr	x2, [x23]
            for (int i = 0; i < array->num_elements; i++) {
  40ce48:	11000718 	add	w24, w24, #0x1
                pos += json_serialize_simple_value(buf + pos, size - pos, data, array->element_type,
  40ce4c:	8b190042 	add	x2, x2, x25
  40ce50:	8b1a0339 	add	x25, x25, x26
  40ce54:	97fffe3c 	bl	40c744 <json_serialize_simple_value>
  40ce58:	0b000273 	add	w19, w19, w0
            for (int i = 0; i < array->num_elements; i++) {
  40ce5c:	17ffffee 	b	40ce14 <txt_serialize_value+0x2a0>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40ce60:	d2800001 	mov	x1, #0x0                   	// #0
  40ce64:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40ce68:	17ffff6d 	b	40cc1c <txt_serialize_value+0xa8>
  40ce6c:	d2800001 	mov	x1, #0x0                   	// #0
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40ce70:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40ce74:	17ffff6a 	b	40cc1c <txt_serialize_value+0xa8>
}
  40ce78:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ce7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ce80:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ce84:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40ce88:	f9402bfb 	ldr	x27, [sp, #80]
  40ce8c:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40ce90:	d65f03c0 	ret

000000000040ce94 <txt_serialize_response>:
{
  40ce94:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
  40ce98:	910003fd 	mov	x29, sp
  40ce9c:	a90153f3 	stp	x19, x20, [sp, #16]
  40cea0:	aa0003f3 	mov	x19, x0
  40cea4:	90000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40cea8:	f90013f5 	str	x21, [sp, #32]
  40ceac:	aa0203f4 	mov	x20, x2
  40ceb0:	f9478400 	ldr	x0, [x0, #3848]
  40ceb4:	3d802be0 	str	q0, [sp, #160]
  40ceb8:	3d802fe1 	str	q1, [sp, #176]
  40cebc:	3d8033e2 	str	q2, [sp, #192]
  40cec0:	3d8037e3 	str	q3, [sp, #208]
  40cec4:	3d803be4 	str	q4, [sp, #224]
  40cec8:	3d803fe5 	str	q5, [sp, #240]
  40cecc:	3d8043e6 	str	q6, [sp, #256]
  40ced0:	3d8047e7 	str	q7, [sp, #272]
  40ced4:	a91293e3 	stp	x3, x4, [sp, #296]
  40ced8:	d0000044 	adrp	x4, 416000 <__func__.0+0x57a>
  40cedc:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40cee0:	a9139be5 	stp	x5, x6, [sp, #312]
  40cee4:	12001c25 	and	w5, w1, #0xff
  40cee8:	911d5484 	add	x4, x4, #0x755
  40ceec:	f900a7e7 	str	x7, [sp, #328]
  40cef0:	f9400002 	ldr	x2, [x0]
  40cef4:	f9004fe2 	str	x2, [sp, #152]
  40cef8:	d2800002 	mov	x2, #0x0                   	// #0
  40cefc:	a9458660 	ldp	x0, x1, [x19, #88]
  40cf00:	52800022 	mov	w2, #0x1                   	// #1
  40cf04:	97ffd12f 	bl	4013c0 <__snprintf_chk@plt>
    ts->rsp_pos = snprintf((char *)ts->rsp, ts->rsp_size, ":%.2X ", code);
  40cf08:	93407c00 	sxtw	x0, w0
  40cf0c:	f9003660 	str	x0, [x19, #104]
    if (msg != NULL && ts->rsp_size > 7) {
  40cf10:	b40005b4 	cbz	x20, 40cfc4 <txt_serialize_response+0x130>
  40cf14:	f9403261 	ldr	x1, [x19, #96]
  40cf18:	f1001c3f 	cmp	x1, #0x7
  40cf1c:	54000549 	b.ls	40cfc4 <txt_serialize_response+0x130>  // b.plast
        ts->rsp[ts->rsp_pos++] = '"';
  40cf20:	f9402e61 	ldr	x1, [x19, #88]
  40cf24:	91000402 	add	x2, x0, #0x1
  40cf28:	f9003662 	str	x2, [x19, #104]
  40cf2c:	52800455 	mov	w21, #0x22                  	// #34
  40cf30:	910163e2 	add	x2, sp, #0x58
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40cf34:	9100c3e5 	add	x5, sp, #0x30
  40cf38:	38206835 	strb	w21, [x1, x0]
        va_start(vargs, msg);
  40cf3c:	910543e0 	add	x0, sp, #0x150
  40cf40:	a90583e0 	stp	x0, x0, [sp, #88]
  40cf44:	910483e0 	add	x0, sp, #0x120
  40cf48:	aa1403e4 	mov	x4, x20
  40cf4c:	f90037e0 	str	x0, [sp, #104]
  40cf50:	128004e0 	mov	w0, #0xffffffd8            	// #-40
  40cf54:	b90073e0 	str	w0, [sp, #112]
  40cf58:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40cf5c:	b90077e0 	str	w0, [sp, #116]
  40cf60:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
            vsnprintf((char *)ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos, msg, vargs);
  40cf64:	a9458666 	ldp	x6, x1, [x19, #88]
  40cf68:	ad400440 	ldp	q0, q1, [x2]
  40cf6c:	9101e3e2 	add	x2, sp, #0x78
  40cf70:	f9403660 	ldr	x0, [x19, #104]
  40cf74:	ad000440 	stp	q0, q1, [x2]
  40cf78:	52800022 	mov	w2, #0x1                   	// #1
  40cf7c:	cb000021 	sub	x1, x1, x0
  40cf80:	8b0000c0 	add	x0, x6, x0
  40cf84:	ad0004a0 	stp	q0, q1, [x5]
  40cf88:	97ffd116 	bl	4013e0 <__vsnprintf_chk@plt>
        ts->rsp_pos +=
  40cf8c:	a9460662 	ldp	x2, x1, [x19, #96]
  40cf90:	8b20c020 	add	x0, x1, w0, sxtw
        if (ts->rsp_pos + 1 < ts->rsp_size) {
  40cf94:	91000401 	add	x1, x0, #0x1
  40cf98:	eb02003f 	cmp	x1, x2
  40cf9c:	54000242 	b.cs	40cfe4 <txt_serialize_response+0x150>  // b.hs, b.nlast
            ts->rsp[ts->rsp_pos++] = '"';
  40cfa0:	f9402e62 	ldr	x2, [x19, #88]
  40cfa4:	f9003661 	str	x1, [x19, #104]
  40cfa8:	38206855 	strb	w21, [x2, x0]
        ts->rsp[ts->rsp_pos++] = ' ';
  40cfac:	f9402e61 	ldr	x1, [x19, #88]
  40cfb0:	f9403660 	ldr	x0, [x19, #104]
  40cfb4:	91000402 	add	x2, x0, #0x1
  40cfb8:	f9003662 	str	x2, [x19, #104]
  40cfbc:	52800402 	mov	w2, #0x20                  	// #32
  40cfc0:	38206822 	strb	w2, [x1, x0]
}
  40cfc4:	90000100 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40cfc8:	f9478400 	ldr	x0, [x0, #3848]
  40cfcc:	f9404fe2 	ldr	x2, [sp, #152]
  40cfd0:	f9400001 	ldr	x1, [x0]
  40cfd4:	eb010042 	subs	x2, x2, x1
  40cfd8:	d2800001 	mov	x1, #0x0                   	// #0
  40cfdc:	540000a0 	b.eq	40cff0 <txt_serialize_response+0x15c>  // b.none
  40cfe0:	97ffd134 	bl	4014b0 <__stack_chk_fail@plt>
            ts->rsp_pos = 3;
  40cfe4:	d2800060 	mov	x0, #0x3                   	// #3
  40cfe8:	f9003660 	str	x0, [x19, #104]
  40cfec:	17fffff0 	b	40cfac <txt_serialize_response+0x118>
}
  40cff0:	52800000 	mov	w0, #0x0                   	// #0
  40cff4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cff8:	f94013f5 	ldr	x21, [sp, #32]
  40cffc:	a8d57bfd 	ldp	x29, x30, [sp], #336
  40d000:	d65f03c0 	ret

000000000040d004 <txt_serialize_name_value>:
{
  40d004:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40d008:	910003fd 	mov	x29, sp
  40d00c:	a90153f3 	stp	x19, x20, [sp, #16]
  40d010:	aa0003f3 	mov	x19, x0
  40d014:	aa0103f4 	mov	x20, x1
    err = txt_serialize_name(ts, object);
  40d018:	97fffd9a 	bl	40c680 <txt_serialize_name>
    if (err != 0) {
  40d01c:	350001c0 	cbnz	w0, 40d054 <txt_serialize_name_value+0x50>
    ts->rsp[ts->rsp_pos - 1] = ':'; /* replace comma with colon */
  40d020:	f9402e60 	ldr	x0, [x19, #88]
  40d024:	f9403661 	ldr	x1, [x19, #104]
  40d028:	8b010000 	add	x0, x0, x1
  40d02c:	52800741 	mov	w1, #0x3a                  	// #58
  40d030:	381ff001 	sturb	w1, [x0, #-1]
    return ts->api->serialize_value(ts, object);
  40d034:	aa1403e1 	mov	x1, x20
  40d038:	f9403a60 	ldr	x0, [x19, #112]
  40d03c:	f9400802 	ldr	x2, [x0, #16]
  40d040:	aa1303e0 	mov	x0, x19
}
  40d044:	a94153f3 	ldp	x19, x20, [sp, #16]
    return ts->api->serialize_value(ts, object);
  40d048:	aa0203f0 	mov	x16, x2
}
  40d04c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    return ts->api->serialize_value(ts, object);
  40d050:	d61f0200 	br	x16
}
  40d054:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d058:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40d05c:	d65f03c0 	ret

000000000040d060 <txt_serialize_list_start>:
    if (ts->rsp_size > ts->rsp_pos + 2) {
  40d060:	a9460403 	ldp	x3, x1, [x0, #96]
  40d064:	91000822 	add	x2, x1, #0x2
  40d068:	eb02007f 	cmp	x3, x2
  40d06c:	54000109 	b.ls	40d08c <txt_serialize_list_start+0x2c>  // b.plast
        ts->rsp[ts->rsp_pos++] = c;
  40d070:	f9402c02 	ldr	x2, [x0, #88]
  40d074:	91000423 	add	x3, x1, #0x1
  40d078:	f9003403 	str	x3, [x0, #104]
  40d07c:	52800b60 	mov	w0, #0x5b                  	// #91
  40d080:	38216840 	strb	w0, [x2, x1]
        return 0;
  40d084:	52800000 	mov	w0, #0x0                   	// #0
}
  40d088:	d65f03c0 	ret
        ts->rsp_pos = 0;
  40d08c:	f900341f 	str	xzr, [x0, #104]
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d090:	12801c00 	mov	w0, #0xffffff1f            	// #-225
    return txt_serialize_start(ts, '[');
  40d094:	17fffffd 	b	40d088 <txt_serialize_list_start+0x28>

000000000040d098 <jsmn_parse>:

/**
 * Parse JSON string and fill tokens.
 */
JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
                        jsmntok_t *tokens, const unsigned int num_tokens) {
  40d098:	aa0003e5 	mov	x5, x0
    switch (js[parser->pos]) {
  40d09c:	d284c00a 	mov	x10, #0x2600                	// #9728
  int r;
  int i;
  jsmntok_t *token;
  int count = parser->toknext;
  40d0a0:	b9400400 	ldr	w0, [x0, #4]
    switch (js[parser->pos]) {
  40d0a4:	f2c2002a 	movk	x10, #0x1001, lsl #32
      switch (js[parser->pos]) {
  40d0a8:	d280882d 	mov	x13, #0x441                 	// #1089
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
    char c;
    jsmntype_t type;

    c = js[parser->pos];
    switch (c) {
  40d0ac:	d284c00f 	mov	x15, #0x2600                	// #9728
    switch (js[parser->pos]) {
  40d0b0:	f2e0800a 	movk	x10, #0x400, lsl #48
  tok->start = tok->end = -1;
  40d0b4:	92800009 	mov	x9, #0xffffffffffffffff    	// #-1
  token->type = type;
  40d0b8:	5280010b 	mov	w11, #0x8                   	// #8
      switch (js[parser->pos]) {
  40d0bc:	d280002c 	mov	x12, #0x1                   	// #1
  40d0c0:	f2a0288d 	movk	x13, #0x144, lsl #16
  token->type = type;
  40d0c4:	5280008e 	mov	w14, #0x4                   	// #4
    switch (c) {
  40d0c8:	f2c0002f 	movk	x15, #0x1, lsl #32
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40d0cc:	b94000a6 	ldr	w6, [x5]
  40d0d0:	2a0603e7 	mov	w7, w6
  40d0d4:	eb26405f 	cmp	x2, w6, uxtw
  40d0d8:	54000069 	b.ls	40d0e4 <jsmn_parse+0x4c>  // b.plast
  40d0dc:	38676827 	ldrb	w7, [x1, x7]
  40d0e0:	350000e7 	cbnz	w7, 40d0fc <jsmn_parse+0x64>
      return JSMN_ERROR_INVAL;
#endif
    }
  }

  if (tokens != NULL) {
  40d0e4:	b40000a3 	cbz	x3, 40d0f8 <jsmn_parse+0x60>
    for (i = parser->toknext - 1; i >= 0; i--) {
  40d0e8:	b94004a1 	ldr	w1, [x5, #4]
  40d0ec:	51000421 	sub	w1, w1, #0x1
  40d0f0:	8b21d063 	add	x3, x3, w1, sxtw #4
  40d0f4:	36f82001 	tbz	w1, #31, 40d4f4 <jsmn_parse+0x45c>
      }
    }
  }

  return count;
}
  40d0f8:	d65f03c0 	ret
    switch (c) {
  40d0fc:	7100e8ff 	cmp	w7, #0x3a
  40d100:	540009e0 	b.eq	40d23c <jsmn_parse+0x1a4>  // b.none
  40d104:	54000408 	b.hi	40d184 <jsmn_parse+0xec>  // b.pmore
  40d108:	710088ff 	cmp	w7, #0x22
  40d10c:	54000da0 	b.eq	40d2c0 <jsmn_parse+0x228>  // b.none
  40d110:	54000168 	b.hi	40d13c <jsmn_parse+0xa4>  // b.pmore
  40d114:	510024e8 	sub	w8, w7, #0x9
  40d118:	12001d08 	and	w8, w8, #0xff
  40d11c:	71005d1f 	cmp	w8, #0x17
  40d120:	54000128 	b.hi	40d144 <jsmn_parse+0xac>  // b.pmore
  40d124:	9ac725e7 	lsr	x7, x15, x7
  40d128:	360000e7 	tbz	w7, #0, 40d144 <jsmn_parse+0xac>
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40d12c:	b94000a6 	ldr	w6, [x5]
  40d130:	110004c6 	add	w6, w6, #0x1
  40d134:	b90000a6 	str	w6, [x5]
  40d138:	17ffffe5 	b	40d0cc <jsmn_parse+0x34>
    switch (c) {
  40d13c:	7100b0ff 	cmp	w7, #0x2c
  40d140:	54001760 	b.eq	40d42c <jsmn_parse+0x394>  // b.none
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40d144:	b94000a7 	ldr	w7, [x5]
  40d148:	2a0703e8 	mov	w8, w7
  40d14c:	eb27405f 	cmp	x2, w7, uxtw
  40d150:	54000129 	b.ls	40d174 <jsmn_parse+0xdc>  // b.plast
  40d154:	38686828 	ldrb	w8, [x1, x8]
  40d158:	340000e8 	cbz	w8, 40d174 <jsmn_parse+0xdc>
    switch (js[parser->pos]) {
  40d15c:	7100e91f 	cmp	w8, #0x3a
  40d160:	540019a8 	b.hi	40d494 <jsmn_parse+0x3fc>  // b.pmore
  40d164:	7100211f 	cmp	w8, #0x8
  40d168:	540019c9 	b.ls	40d4a0 <jsmn_parse+0x408>  // b.plast
  40d16c:	9ac82550 	lsr	x16, x10, x8
  40d170:	36001990 	tbz	w16, #0, 40d4a0 <jsmn_parse+0x408>
  if (tokens == NULL) {
  40d174:	b5001a43 	cbnz	x3, 40d4bc <jsmn_parse+0x424>
  parser->pos--;
  40d178:	510004e7 	sub	w7, w7, #0x1
    parser->pos--;
  40d17c:	b90000a7 	str	w7, [x5]
  40d180:	1400006d 	b	40d334 <jsmn_parse+0x29c>
    switch (c) {
  40d184:	7101ecff 	cmp	w7, #0x7b
  40d188:	540002a0 	b.eq	40d1dc <jsmn_parse+0x144>  // b.none
  40d18c:	54000108 	b.hi	40d1ac <jsmn_parse+0x114>  // b.pmore
  40d190:	71016cff 	cmp	w7, #0x5b
  40d194:	54000240 	b.eq	40d1dc <jsmn_parse+0x144>  // b.none
  40d198:	710174ff 	cmp	w7, #0x5d
  40d19c:	54fffd41 	b.ne	40d144 <jsmn_parse+0xac>  // b.any
      if (tokens == NULL) {
  40d1a0:	b4fffc63 	cbz	x3, 40d12c <jsmn_parse+0x94>
      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
  40d1a4:	52800050 	mov	w16, #0x2                   	// #2
  40d1a8:	14000005 	b	40d1bc <jsmn_parse+0x124>
    switch (c) {
  40d1ac:	7101f4ff 	cmp	w7, #0x7d
  40d1b0:	54fffca1 	b.ne	40d144 <jsmn_parse+0xac>  // b.any
      if (tokens == NULL) {
  40d1b4:	b4fffbc3 	cbz	x3, 40d12c <jsmn_parse+0x94>
      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
  40d1b8:	52800030 	mov	w16, #0x1                   	// #1
      for (i = parser->toknext - 1; i >= 0; i--) {
  40d1bc:	b94004a7 	ldr	w7, [x5, #4]
  40d1c0:	510004e7 	sub	w7, w7, #0x1
  40d1c4:	8b27d068 	add	x8, x3, w7, sxtw #4
  40d1c8:	36f80427 	tbz	w7, #31, 40d24c <jsmn_parse+0x1b4>
      if (i == -1) {
  40d1cc:	310004ff 	cmn	w7, #0x1
  40d1d0:	54fffae1 	b.ne	40d12c <jsmn_parse+0x94>  // b.any
            return JSMN_ERROR_INVAL;
  40d1d4:	12800020 	mov	w0, #0xfffffffe            	// #-2
  40d1d8:	17ffffc8 	b	40d0f8 <jsmn_parse+0x60>
      count++;
  40d1dc:	11000400 	add	w0, w0, #0x1
      if (tokens == NULL) {
  40d1e0:	b4fffa63 	cbz	x3, 40d12c <jsmn_parse+0x94>
  if (parser->toknext >= num_tokens) {
  40d1e4:	b94004a6 	ldr	w6, [x5, #4]
  40d1e8:	6b06009f 	cmp	w4, w6
  40d1ec:	540008e9 	b.ls	40d308 <jsmn_parse+0x270>  // b.plast
  tok = &tokens[parser->toknext++];
  40d1f0:	110004c8 	add	w8, w6, #0x1
  40d1f4:	d37c7cc6 	ubfiz	x6, x6, #4, #32
  40d1f8:	8b060070 	add	x16, x3, x6
  40d1fc:	b90004a8 	str	w8, [x5, #4]
  tok->start = tok->end = -1;
  40d200:	f8004209 	stur	x9, [x16, #4]
  tok->size = 0;
  40d204:	b9000e1f 	str	wzr, [x16, #12]
      if (parser->toksuper != -1) {
  40d208:	b94008a8 	ldr	w8, [x5, #8]
  40d20c:	3100051f 	cmn	w8, #0x1
  40d210:	540000a0 	b.eq	40d224 <jsmn_parse+0x18c>  // b.none
        jsmntok_t *t = &tokens[parser->toksuper];
  40d214:	8b28d068 	add	x8, x3, w8, sxtw #4
        t->size++;
  40d218:	b9400d11 	ldr	w17, [x8, #12]
  40d21c:	11000631 	add	w17, w17, #0x1
  40d220:	b9000d11 	str	w17, [x8, #12]
      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
  40d224:	7101ecff 	cmp	w7, #0x7b
  40d228:	1a9f07e7 	cset	w7, ne  // ne = any
  40d22c:	110004e7 	add	w7, w7, #0x1
  40d230:	b8266867 	str	w7, [x3, x6]
      token->start = parser->pos;
  40d234:	b94000a6 	ldr	w6, [x5]
  40d238:	b9000606 	str	w6, [x16, #4]
      parser->toksuper = parser->toknext - 1;
  40d23c:	b94004a6 	ldr	w6, [x5, #4]
  40d240:	510004c6 	sub	w6, w6, #0x1
              parser->toksuper = i;
  40d244:	b90008a6 	str	w6, [x5, #8]
              break;
  40d248:	17ffffb9 	b	40d12c <jsmn_parse+0x94>
        if (token->start != -1 && token->end == -1) {
  40d24c:	b9400511 	ldr	w17, [x8, #4]
  40d250:	3100063f 	cmn	w17, #0x1
  40d254:	54000260 	b.eq	40d2a0 <jsmn_parse+0x208>  // b.none
  40d258:	b9400911 	ldr	w17, [x8, #8]
  40d25c:	3100063f 	cmn	w17, #0x1
  40d260:	54000201 	b.ne	40d2a0 <jsmn_parse+0x208>  // b.any
          if (token->type != type) {
  40d264:	b9400112 	ldr	w18, [x8]
  40d268:	6b10025f 	cmp	w18, w16
  40d26c:	54fffb41 	b.ne	40d1d4 <jsmn_parse+0x13c>  // b.any
          token->end = parser->pos + 1;
  40d270:	110004c6 	add	w6, w6, #0x1
          parser->toksuper = -1;
  40d274:	b90008b1 	str	w17, [x5, #8]
          token->end = parser->pos + 1;
  40d278:	b9000906 	str	w6, [x8, #8]
      if (i == -1) {
  40d27c:	8b27d066 	add	x6, x3, w7, sxtw #4
        if (token->start != -1 && token->end == -1) {
  40d280:	b94004c8 	ldr	w8, [x6, #4]
  40d284:	3100051f 	cmn	w8, #0x1
  40d288:	54000120 	b.eq	40d2ac <jsmn_parse+0x214>  // b.none
  40d28c:	b94008c8 	ldr	w8, [x6, #8]
  40d290:	3100051f 	cmn	w8, #0x1
  40d294:	540000c1 	b.ne	40d2ac <jsmn_parse+0x214>  // b.any
          parser->toksuper = i;
  40d298:	b90008a7 	str	w7, [x5, #8]
          break;
  40d29c:	17ffffa4 	b	40d12c <jsmn_parse+0x94>
      for (i = parser->toknext - 1; i >= 0; i--) {
  40d2a0:	510004e7 	sub	w7, w7, #0x1
  40d2a4:	d1004108 	sub	x8, x8, #0x10
  40d2a8:	17ffffc8 	b	40d1c8 <jsmn_parse+0x130>
      for (; i >= 0; i--) {
  40d2ac:	510004e7 	sub	w7, w7, #0x1
  40d2b0:	d10040c6 	sub	x6, x6, #0x10
  40d2b4:	310004ff 	cmn	w7, #0x1
  40d2b8:	54fffe41 	b.ne	40d280 <jsmn_parse+0x1e8>  // b.any
  40d2bc:	17ffff9c 	b	40d12c <jsmn_parse+0x94>
  parser->pos++;
  40d2c0:	110004c7 	add	w7, w6, #0x1
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40d2c4:	2a0703f1 	mov	w17, w7
  parser->pos++;
  40d2c8:	b90000a7 	str	w7, [x5]
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40d2cc:	2a0703e8 	mov	w8, w7
  40d2d0:	eb27405f 	cmp	x2, w7, uxtw
  40d2d4:	54000069 	b.ls	40d2e0 <jsmn_parse+0x248>  // b.plast
  40d2d8:	38686828 	ldrb	w8, [x1, x8]
  40d2dc:	35000088 	cbnz	w8, 40d2ec <jsmn_parse+0x254>
  parser->pos = start;
  40d2e0:	b90000a6 	str	w6, [x5]
        return JSMN_ERROR_PART;
  40d2e4:	12800040 	mov	w0, #0xfffffffd            	// #-3
  40d2e8:	17ffff84 	b	40d0f8 <jsmn_parse+0x60>
    if (c == '\"') {
  40d2ec:	7100891f 	cmp	w8, #0x22
  40d2f0:	54000361 	b.ne	40d35c <jsmn_parse+0x2c4>  // b.any
      if (tokens == NULL) {
  40d2f4:	b4000203 	cbz	x3, 40d334 <jsmn_parse+0x29c>
  if (parser->toknext >= num_tokens) {
  40d2f8:	b94004a7 	ldr	w7, [x5, #4]
  40d2fc:	6b07009f 	cmp	w4, w7
  40d300:	54000088 	b.hi	40d310 <jsmn_parse+0x278>  // b.pmore
    parser->pos = start;
  40d304:	b90000a6 	str	w6, [x5]
        return JSMN_ERROR_NOMEM;
  40d308:	12800000 	mov	w0, #0xffffffff            	// #-1
  40d30c:	17ffff7b 	b	40d0f8 <jsmn_parse+0x60>
  tok = &tokens[parser->toknext++];
  40d310:	110004e6 	add	w6, w7, #0x1
  40d314:	d37c7ce7 	ubfiz	x7, x7, #4, #32
  40d318:	b90004a6 	str	w6, [x5, #4]
  40d31c:	8b070066 	add	x6, x3, x7
  tok->start = tok->end = -1;
  40d320:	f80040c9 	stur	x9, [x6, #4]
  tok->size = 0;
  40d324:	b9000cdf 	str	wzr, [x6, #12]
      jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);
  40d328:	b94000a8 	ldr	w8, [x5]
  token->type = type;
  40d32c:	b827686e 	str	w14, [x3, x7]
  token->end = end;
  40d330:	2900a0d1 	stp	w17, w8, [x6, #4]
      if (parser->toksuper != -1 && tokens != NULL) {
  40d334:	b94008a6 	ldr	w6, [x5, #8]
      count++;
  40d338:	11000400 	add	w0, w0, #0x1
      if (parser->toksuper != -1 && tokens != NULL) {
  40d33c:	310004df 	cmn	w6, #0x1
  40d340:	54ffef60 	b.eq	40d12c <jsmn_parse+0x94>  // b.none
  40d344:	b4ffef43 	cbz	x3, 40d12c <jsmn_parse+0x94>
        tokens[parser->toksuper].size++;
  40d348:	8b26d066 	add	x6, x3, w6, sxtw #4
  40d34c:	b9400cc7 	ldr	w7, [x6, #12]
  40d350:	110004e7 	add	w7, w7, #0x1
  40d354:	b9000cc7 	str	w7, [x6, #12]
  40d358:	17ffff75 	b	40d12c <jsmn_parse+0x94>
    if (c == '\\' && parser->pos + 1 < len) {
  40d35c:	7101711f 	cmp	w8, #0x5c
  40d360:	540001e1 	b.ne	40d39c <jsmn_parse+0x304>  // b.any
  40d364:	110004e8 	add	w8, w7, #0x1
  40d368:	110004f0 	add	w16, w7, #0x1
  40d36c:	eb02011f 	cmp	x8, x2
  40d370:	54000162 	b.cs	40d39c <jsmn_parse+0x304>  // b.hs, b.nlast
      parser->pos++;
  40d374:	b90000b0 	str	w16, [x5]
      switch (js[parser->pos]) {
  40d378:	38686828 	ldrb	w8, [x1, x8]
  40d37c:	7101d51f 	cmp	w8, #0x75
  40d380:	54000428 	b.hi	40d404 <jsmn_parse+0x36c>  // b.pmore
  40d384:	71016d1f 	cmp	w8, #0x5b
  40d388:	54000108 	b.hi	40d3a8 <jsmn_parse+0x310>  // b.pmore
  40d38c:	7100891f 	cmp	w8, #0x22
  40d390:	54000060 	b.eq	40d39c <jsmn_parse+0x304>  // b.none
  40d394:	7100bd1f 	cmp	w8, #0x2f
  40d398:	54000361 	b.ne	40d404 <jsmn_parse+0x36c>  // b.any
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40d39c:	b94000a7 	ldr	w7, [x5]
  40d3a0:	110004e7 	add	w7, w7, #0x1
  40d3a4:	17ffffc9 	b	40d2c8 <jsmn_parse+0x230>
      switch (js[parser->pos]) {
  40d3a8:	51017110 	sub	w16, w8, #0x5c
  40d3ac:	9ad02190 	lsl	x16, x12, x16
  40d3b0:	ea0d021f 	tst	x16, x13
  40d3b4:	54ffff41 	b.ne	40d39c <jsmn_parse+0x304>  // b.any
  40d3b8:	7101d51f 	cmp	w8, #0x75
  40d3bc:	54000241 	b.ne	40d404 <jsmn_parse+0x36c>  // b.any
        parser->pos++;
  40d3c0:	110008e7 	add	w7, w7, #0x2
  40d3c4:	52800092 	mov	w18, #0x4                   	// #4
  40d3c8:	b90000a7 	str	w7, [x5]
        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
  40d3cc:	b94000a8 	ldr	w8, [x5]
  40d3d0:	2a0803e7 	mov	w7, w8
  40d3d4:	eb28405f 	cmp	x2, w8, uxtw
  40d3d8:	54000229 	b.ls	40d41c <jsmn_parse+0x384>  // b.plast
  40d3dc:	38676827 	ldrb	w7, [x1, x7]
  40d3e0:	340001e7 	cbz	w7, 40d41c <jsmn_parse+0x384>
          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */
  40d3e4:	121a78f0 	and	w16, w7, #0xffffffdf
  40d3e8:	5100c0e7 	sub	w7, w7, #0x30
  40d3ec:	51010610 	sub	w16, w16, #0x41
  40d3f0:	12001ce7 	and	w7, w7, #0xff
  40d3f4:	12001e10 	and	w16, w16, #0xff
  40d3f8:	7100161f 	cmp	w16, #0x5
  40d3fc:	7a4988e0 	ccmp	w7, #0x9, #0x0, hi  // hi = pmore
  40d400:	54000069 	b.ls	40d40c <jsmn_parse+0x374>  // b.plast
      parser->pos = start;
  40d404:	b90000a6 	str	w6, [x5]
      if (r < 0) {
  40d408:	17ffff73 	b	40d1d4 <jsmn_parse+0x13c>
          parser->pos++;
  40d40c:	11000508 	add	w8, w8, #0x1
  40d410:	b90000a8 	str	w8, [x5]
        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
  40d414:	71000652 	subs	w18, w18, #0x1
  40d418:	54fffda1 	b.ne	40d3cc <jsmn_parse+0x334>  // b.any
        parser->pos--;
  40d41c:	b94000a7 	ldr	w7, [x5]
  40d420:	510004e7 	sub	w7, w7, #0x1
  40d424:	b90000a7 	str	w7, [x5]
        break;
  40d428:	17ffffdd 	b	40d39c <jsmn_parse+0x304>
      if (tokens != NULL && parser->toksuper != -1 &&
  40d42c:	b4ffe803 	cbz	x3, 40d12c <jsmn_parse+0x94>
  40d430:	b94008a6 	ldr	w6, [x5, #8]
  40d434:	310004df 	cmn	w6, #0x1
  40d438:	54ffe7a0 	b.eq	40d12c <jsmn_parse+0x94>  // b.none
          tokens[parser->toksuper].type != JSMN_ARRAY &&
  40d43c:	937c7cc6 	sbfiz	x6, x6, #4, #32
  40d440:	b8666866 	ldr	w6, [x3, x6]
  40d444:	510004c6 	sub	w6, w6, #0x1
  40d448:	710004df 	cmp	w6, #0x1
  40d44c:	54ffe709 	b.ls	40d12c <jsmn_parse+0x94>  // b.plast
        for (i = parser->toknext - 1; i >= 0; i--) {
  40d450:	b94004a6 	ldr	w6, [x5, #4]
  40d454:	510004c6 	sub	w6, w6, #0x1
  40d458:	8b26d067 	add	x7, x3, w6, sxtw #4
  40d45c:	37ffe686 	tbnz	w6, #31, 40d12c <jsmn_parse+0x94>
          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
  40d460:	b94000e8 	ldr	w8, [x7]
  40d464:	51000508 	sub	w8, w8, #0x1
  40d468:	7100051f 	cmp	w8, #0x1
  40d46c:	540000e8 	b.hi	40d488 <jsmn_parse+0x3f0>  // b.pmore
            if (tokens[i].start != -1 && tokens[i].end == -1) {
  40d470:	b94004e8 	ldr	w8, [x7, #4]
  40d474:	3100051f 	cmn	w8, #0x1
  40d478:	54000080 	b.eq	40d488 <jsmn_parse+0x3f0>  // b.none
  40d47c:	b94008e8 	ldr	w8, [x7, #8]
  40d480:	3100051f 	cmn	w8, #0x1
  40d484:	54ffee00 	b.eq	40d244 <jsmn_parse+0x1ac>  // b.none
        for (i = parser->toknext - 1; i >= 0; i--) {
  40d488:	510004c6 	sub	w6, w6, #0x1
  40d48c:	d10040e7 	sub	x7, x7, #0x10
  40d490:	17fffff3 	b	40d45c <jsmn_parse+0x3c4>
    switch (js[parser->pos]) {
  40d494:	121a7910 	and	w16, w8, #0xffffffdf
  40d498:	7101761f 	cmp	w16, #0x5d
  40d49c:	54ffe6c0 	b.eq	40d174 <jsmn_parse+0xdc>  // b.none
    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
  40d4a0:	51008108 	sub	w8, w8, #0x20
  40d4a4:	12001d08 	and	w8, w8, #0xff
  40d4a8:	7101791f 	cmp	w8, #0x5e
  40d4ac:	54fffac8 	b.hi	40d404 <jsmn_parse+0x36c>  // b.pmore
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40d4b0:	110004e7 	add	w7, w7, #0x1
  40d4b4:	b90000a7 	str	w7, [x5]
  40d4b8:	17ffff23 	b	40d144 <jsmn_parse+0xac>
  if (parser->toknext >= num_tokens) {
  40d4bc:	b94004a7 	ldr	w7, [x5, #4]
  40d4c0:	6b07009f 	cmp	w4, w7
  40d4c4:	54fff209 	b.ls	40d304 <jsmn_parse+0x26c>  // b.plast
  tok = &tokens[parser->toknext++];
  40d4c8:	110004e8 	add	w8, w7, #0x1
  40d4cc:	d37c7ce7 	ubfiz	x7, x7, #4, #32
  40d4d0:	b90004a8 	str	w8, [x5, #4]
  40d4d4:	8b070068 	add	x8, x3, x7
  tok->start = tok->end = -1;
  40d4d8:	f8004109 	stur	x9, [x8, #4]
  tok->size = 0;
  40d4dc:	b9000d1f 	str	wzr, [x8, #12]
  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
  40d4e0:	b94000b0 	ldr	w16, [x5]
  token->type = type;
  40d4e4:	b827686b 	str	w11, [x3, x7]
  token->end = end;
  40d4e8:	2900c106 	stp	w6, w16, [x8, #4]
  parser->pos--;
  40d4ec:	b94000a7 	ldr	w7, [x5]
  40d4f0:	17ffff22 	b	40d178 <jsmn_parse+0xe0>
      if (tokens[i].start != -1 && tokens[i].end == -1) {
  40d4f4:	b9400462 	ldr	w2, [x3, #4]
  40d4f8:	3100045f 	cmn	w2, #0x1
  40d4fc:	54000080 	b.eq	40d50c <jsmn_parse+0x474>  // b.none
  40d500:	b9400862 	ldr	w2, [x3, #8]
  40d504:	3100045f 	cmn	w2, #0x1
  40d508:	54ffeee0 	b.eq	40d2e4 <jsmn_parse+0x24c>  // b.none
    for (i = parser->toknext - 1; i >= 0; i--) {
  40d50c:	51000421 	sub	w1, w1, #0x1
  40d510:	d1004063 	sub	x3, x3, #0x10
  40d514:	17fffef8 	b	40d0f4 <jsmn_parse+0x5c>

000000000040d518 <jsmn_init>:
 * available.
 */
JSMN_API void jsmn_init(jsmn_parser *parser) {
  parser->pos = 0;
  parser->toknext = 0;
  parser->toksuper = -1;
  40d518:	12800001 	mov	w1, #0xffffffff            	// #-1
  parser->pos = 0;
  40d51c:	f900001f 	str	xzr, [x0]
  parser->toksuper = -1;
  40d520:	b9000801 	str	w1, [x0, #8]
}
  40d524:	d65f03c0 	ret

000000000040d528 <txt_parse_payload>:
{
  40d528:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40d52c:	910003fd 	mov	x29, sp
  40d530:	a90153f3 	stp	x19, x20, [sp, #16]
  40d534:	aa0003f3 	mov	x19, x0
  40d538:	f00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
    jsmn_init(&parser);
  40d53c:	9100a3f4 	add	x20, sp, #0x28
{
  40d540:	f9478400 	ldr	x0, [x0, #3848]
  40d544:	f9400001 	ldr	x1, [x0]
  40d548:	f9001fe1 	str	x1, [sp, #56]
  40d54c:	d2800001 	mov	x1, #0x0                   	// #0
    ts->tok_pos = 0;
  40d550:	f901d27f 	str	xzr, [x19, #928]
    ts->msg_payload = ts->msg + ts->msg_pos;
  40d554:	f9401e60 	ldr	x0, [x19, #56]
  40d558:	f9402661 	ldr	x1, [x19, #72]
  40d55c:	8b010000 	add	x0, x0, x1
  40d560:	f9002a60 	str	x0, [x19, #80]
    jsmn_init(&parser);
  40d564:	aa1403e0 	mov	x0, x20
  40d568:	97ffffec 	bl	40d518 <jsmn_init>
    ret = jsmn_parse(&parser, ts->msg_payload, ts->msg_len - ts->msg_pos, ts->tokens,
  40d56c:	a9440262 	ldp	x2, x0, [x19, #64]
  40d570:	9101e263 	add	x3, x19, #0x78
  40d574:	f9402a61 	ldr	x1, [x19, #80]
  40d578:	52806404 	mov	w4, #0x320                 	// #800
  40d57c:	cb000042 	sub	x2, x2, x0
  40d580:	aa1403e0 	mov	x0, x20
  40d584:	97fffec5 	bl	40d098 <jsmn_parse>
    if (ret == JSMN_ERROR_NOMEM) {
  40d588:	3100041f 	cmn	w0, #0x1
  40d58c:	54000161 	b.ne	40d5b8 <txt_parse_payload+0x90>  // b.any
        return -THINGSET_ERR_REQUEST_TOO_LARGE;
  40d590:	12801580 	mov	w0, #0xffffff53            	// #-173
        ts->rsp_pos = 0;
  40d594:	f900367f 	str	xzr, [x19, #104]
}
  40d598:	f00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40d59c:	f9478421 	ldr	x1, [x1, #3848]
  40d5a0:	f9401fe3 	ldr	x3, [sp, #56]
  40d5a4:	f9400022 	ldr	x2, [x1]
  40d5a8:	eb020063 	subs	x3, x3, x2
  40d5ac:	d2800002 	mov	x2, #0x0                   	// #0
  40d5b0:	54000140 	b.eq	40d5d8 <txt_parse_payload+0xb0>  // b.none
  40d5b4:	97ffcfbf 	bl	4014b0 <__stack_chk_fail@plt>
    else if (ret < 0) {
  40d5b8:	36f80080 	tbz	w0, #31, 40d5c8 <txt_parse_payload+0xa0>
        return -THINGSET_ERR_BAD_REQUEST;
  40d5bc:	128013e0 	mov	w0, #0xffffff60            	// #-160
        ts->rsp_pos = 0;
  40d5c0:	f900367f 	str	xzr, [x19, #104]
        return -THINGSET_ERR_BAD_REQUEST;
  40d5c4:	17fffff5 	b	40d598 <txt_parse_payload+0x70>
    ts->tok_count = ret;
  40d5c8:	93407c00 	sxtw	x0, w0
  40d5cc:	f901ce60 	str	x0, [x19, #920]
    return 0;
  40d5d0:	52800000 	mov	w0, #0x0                   	// #0
  40d5d4:	17fffff1 	b	40d598 <txt_parse_payload+0x70>
}
  40d5d8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d5dc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40d5e0:	d65f03c0 	ret

000000000040d5e4 <txt_deserialize_payload_reset>:
    ts->msg_pos = ts->msg_payload - ts->msg;
  40d5e4:	f9401c03 	ldr	x3, [x0, #56]
  40d5e8:	f9402802 	ldr	x2, [x0, #80]
  40d5ec:	cb030042 	sub	x2, x2, x3
  40d5f0:	f9002402 	str	x2, [x0, #72]
    txt_parse_payload(ts);
  40d5f4:	17ffffcd 	b	40d528 <txt_parse_payload>

000000000040d5f8 <thingset_txt_setup>:
    .deserialize_finish = txt_deserialize_finish,
};

inline void thingset_txt_setup(struct thingset_context *ts)
{
    ts->api = &txt_api;
  40d5f8:	90000101 	adrp	x1, 42d000 <__dso_handle>
  40d5fc:	91282021 	add	x1, x1, #0xa08
  40d600:	f9003801 	str	x1, [x0, #112]
}
  40d604:	d65f03c0 	ret

000000000040d608 <zcbor_check_error.isra.0>:
#ifdef ZCBOR_STOP_ON_ERROR
/** Check stored error and fail if present, but only if stop_on_error is true. */
static inline bool zcbor_check_error(const zcbor_state_t *state)
{
	struct zcbor_state_constant  *cs = state->constant_state;
	return !(cs && cs->stop_on_error && cs->error);
  40d608:	b40000e0 	cbz	x0, 40d624 <zcbor_check_error.isra.0+0x1c>
  40d60c:	39407001 	ldrb	w1, [x0, #28]
  40d610:	340000a1 	cbz	w1, 40d624 <zcbor_check_error.isra.0+0x1c>
  40d614:	b9401800 	ldr	w0, [x0, #24]
  40d618:	7100001f 	cmp	w0, #0x0
  40d61c:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40d620:	d65f03c0 	ret
	return !(cs && cs->stop_on_error && cs->error);
  40d624:	52800020 	mov	w0, #0x1                   	// #1
  40d628:	17fffffe 	b	40d620 <zcbor_check_error.isra.0+0x18>

000000000040d62c <zcbor_error>:
	}
}

/** Write the provided error to the error state. */
static inline void zcbor_error(zcbor_state_t *state, int err)
{
  40d62c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d630:	2a0103e3 	mov	w3, w1
  40d634:	910003fd 	mov	x29, sp
  40d638:	f9401402 	ldr	x2, [x0, #40]
#ifdef ZCBOR_STOP_ON_ERROR
	if (zcbor_check_error(state))
  40d63c:	aa0203e0 	mov	x0, x2
  40d640:	97fffff2 	bl	40d608 <zcbor_check_error.isra.0>
  40d644:	72001c1f 	tst	w0, #0xff
  40d648:	54000060 	b.eq	40d654 <zcbor_error+0x28>  // b.none
#endif
	{
		if (state->constant_state) {
  40d64c:	b4000042 	cbz	x2, 40d654 <zcbor_error+0x28>
			state->constant_state->error = err;
  40d650:	b9001843 	str	w3, [x2, #24]
		}
	}
}
  40d654:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d658:	d65f03c0 	ret

000000000040d65c <zcbor_new_backup>:

_Static_assert((sizeof(zcbor_state_t) >= sizeof(struct zcbor_state_constant)),
	"This code needs zcbor_state_t to be at least as large as zcbor_backups_t.");

bool zcbor_new_backup(zcbor_state_t *state, size_t new_elem_count)
{
  40d65c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d660:	aa0003e2 	mov	x2, x0
  40d664:	aa0103e4 	mov	x4, x1
  40d668:	910003fd 	mov	x29, sp
  40d66c:	f9401403 	ldr	x3, [x0, #40]
	ZCBOR_CHECK_ERROR();
  40d670:	aa0303e0 	mov	x0, x3
  40d674:	97ffffe5 	bl	40d608 <zcbor_check_error.isra.0>
  40d678:	72001c00 	ands	w0, w0, #0xff
  40d67c:	54000100 	b.eq	40d69c <zcbor_new_backup+0x40>  // b.none

	if ((state->constant_state->current_backup)
  40d680:	a9408465 	ldp	x5, x1, [x3, #8]
  40d684:	eb0100bf 	cmp	x5, x1
  40d688:	540000e3 	b.cc	40d6a4 <zcbor_new_backup+0x48>  // b.lo, b.ul, b.last
		>= state->constant_state->num_backups) {
		ZCBOR_ERR(ZCBOR_ERR_NO_BACKUP_MEM);
  40d68c:	aa0203e0 	mov	x0, x2
  40d690:	52800021 	mov	w1, #0x1                   	// #1
  40d694:	97ffffe6 	bl	40d62c <zcbor_error>
  40d698:	52800000 	mov	w0, #0x0                   	// #0
		sizeof(zcbor_state_t));

	state->elem_count = new_elem_count;

	return true;
}
  40d69c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d6a0:	d65f03c0 	ret
	state->payload_moved = false;
  40d6a4:	3900845f 	strb	wzr, [x2, #33]
	memcpy(&state->constant_state->backup_list[i], state,
  40d6a8:	d2800605 	mov	x5, #0x30                  	// #48
	(state->constant_state->current_backup)++;
  40d6ac:	f9400461 	ldr	x1, [x3, #8]
  40d6b0:	91000421 	add	x1, x1, #0x1
  40d6b4:	f9000461 	str	x1, [x3, #8]
	size_t i = (state->constant_state->current_backup) - 1;
  40d6b8:	f9401441 	ldr	x1, [x2, #40]
  return __builtin___memcpy_chk (__dest, __src, __len,
  40d6bc:	ad400440 	ldp	q0, q1, [x2]
  40d6c0:	f9400423 	ldr	x3, [x1, #8]
	memcpy(&state->constant_state->backup_list[i], state,
  40d6c4:	f9400021 	ldr	x1, [x1]
	size_t i = (state->constant_state->current_backup) - 1;
  40d6c8:	d1000463 	sub	x3, x3, #0x1
	memcpy(&state->constant_state->backup_list[i], state,
  40d6cc:	9b050463 	madd	x3, x3, x5, x1
  40d6d0:	ad000460 	stp	q0, q1, [x3]
  40d6d4:	3dc00840 	ldr	q0, [x2, #32]
  40d6d8:	3d800860 	str	q0, [x3, #32]
	state->elem_count = new_elem_count;
  40d6dc:	f9000844 	str	x4, [x2, #16]
	return true;
  40d6e0:	17ffffef 	b	40d69c <zcbor_new_backup+0x40>

000000000040d6e4 <zcbor_process_backup>:


bool zcbor_process_backup(zcbor_state_t *state, uint32_t flags,
		size_t max_elem_count)
{
  40d6e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d6e8:	aa0003e3 	mov	x3, x0
  40d6ec:	2a0103e5 	mov	w5, w1
  40d6f0:	910003fd 	mov	x29, sp
  40d6f4:	f9401406 	ldr	x6, [x0, #40]
	const uint8_t *payload = state->payload;
	const size_t elem_count = state->elem_count;

	ZCBOR_CHECK_ERROR();
  40d6f8:	aa0603e0 	mov	x0, x6
  40d6fc:	97ffffc3 	bl	40d608 <zcbor_check_error.isra.0>
  40d700:	72001c00 	ands	w0, w0, #0xff
  40d704:	54000420 	b.eq	40d788 <zcbor_process_backup+0xa4>  // b.none

	if (state->constant_state->current_backup == 0) {
  40d708:	f94004c4 	ldr	x4, [x6, #8]
	const uint8_t *payload = state->payload;
  40d70c:	f9400067 	ldr	x7, [x3]
	const size_t elem_count = state->elem_count;
  40d710:	f9400868 	ldr	x8, [x3, #16]
	if (state->constant_state->current_backup == 0) {
  40d714:	b50000c4 	cbnz	x4, 40d72c <zcbor_process_backup+0x48>
		zcbor_print("No backups available.\r\n");
		ZCBOR_ERR(ZCBOR_ERR_NO_BACKUP_ACTIVE);
  40d718:	52800041 	mov	w1, #0x2                   	// #2
	}

	if (elem_count > max_elem_count) {
		zcbor_print("elem_count: %" PRIuFAST32 " (expected max %" PRIuFAST32 ")\r\n",
			elem_count, max_elem_count);
		ZCBOR_ERR(ZCBOR_ERR_HIGH_ELEM_COUNT);
  40d71c:	aa0303e0 	mov	x0, x3
  40d720:	97ffffc3 	bl	40d62c <zcbor_error>
	ZCBOR_CHECK_ERROR();
  40d724:	52800000 	mov	w0, #0x0                   	// #0
  40d728:	14000018 	b	40d788 <zcbor_process_backup+0xa4>
	if (flags & ZCBOR_FLAG_RESTORE) {
  40d72c:	36000185 	tbz	w5, #0, 40d75c <zcbor_process_backup+0x78>
			if (state->constant_state->backup_list[i].payload_moved) {
  40d730:	f94000c1 	ldr	x1, [x6]
		size_t i = state->constant_state->current_backup - 1;
  40d734:	d1000484 	sub	x4, x4, #0x1
			if (state->constant_state->backup_list[i].payload_moved) {
  40d738:	d2800606 	mov	x6, #0x30                  	// #48
  40d73c:	9b060484 	madd	x4, x4, x6, x1
		if (!(flags & ZCBOR_FLAG_TRANSFER_PAYLOAD)) {
  40d740:	37100065 	tbnz	w5, #2, 40d74c <zcbor_process_backup+0x68>
			if (state->constant_state->backup_list[i].payload_moved) {
  40d744:	39408481 	ldrb	w1, [x4, #33]
  40d748:	35fffee1 	cbnz	w1, 40d724 <zcbor_process_backup+0x40>
  40d74c:	ad400480 	ldp	q0, q1, [x4]
  40d750:	ad000460 	stp	q0, q1, [x3]
  40d754:	3dc00880 	ldr	q0, [x4, #32]
  40d758:	3d800860 	str	q0, [x3, #32]
	if (flags & ZCBOR_FLAG_CONSUME) {
  40d75c:	360800a5 	tbz	w5, #1, 40d770 <zcbor_process_backup+0x8c>
		state->constant_state->current_backup--;
  40d760:	f9401464 	ldr	x4, [x3, #40]
  40d764:	f9400481 	ldr	x1, [x4, #8]
  40d768:	d1000421 	sub	x1, x1, #0x1
  40d76c:	f9000481 	str	x1, [x4, #8]
	if (elem_count > max_elem_count) {
  40d770:	eb02011f 	cmp	x8, x2
  40d774:	54000069 	b.ls	40d780 <zcbor_process_backup+0x9c>  // b.plast
		ZCBOR_ERR(ZCBOR_ERR_HIGH_ELEM_COUNT);
  40d778:	52800081 	mov	w1, #0x4                   	// #4
  40d77c:	17ffffe8 	b	40d71c <zcbor_process_backup+0x38>
	}

	if (flags & ZCBOR_FLAG_TRANSFER_PAYLOAD) {
  40d780:	36100045 	tbz	w5, #2, 40d788 <zcbor_process_backup+0xa4>
		state->payload = payload;
  40d784:	f9000067 	str	x7, [x3]
	}

	return true;
}
  40d788:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d78c:	d65f03c0 	ret

000000000040d790 <zcbor_new_state>:
}

void zcbor_new_state(zcbor_state_t *state_array, size_t n_states,
		const uint8_t *payload, size_t payload_len, size_t elem_count)
{
	state_array[0].payload = payload;
  40d790:	f9000002 	str	x2, [x0]
	state_array[0].payload_end = payload + payload_len;
  40d794:	8b030042 	add	x2, x2, x3
	state_array[0].elem_count = elem_count;
  40d798:	f9000804 	str	x4, [x0, #16]
	state_array[0].payload_end = payload + payload_len;
  40d79c:	f9000c02 	str	x2, [x0, #24]
	state_array[0].indefinite_length_array = false;
  40d7a0:	7900401f 	strh	wzr, [x0, #32]
	state_array[0].payload_moved = false;
	state_array[0].constant_state = NULL;

	if(n_states < 2) {
  40d7a4:	f100043f 	cmp	x1, #0x1
  40d7a8:	54000068 	b.hi	40d7b4 <zcbor_new_state+0x24>  // b.pmore
	state_array[0].constant_state = NULL;
  40d7ac:	f900141f 	str	xzr, [x0, #40]
	state_array[0].constant_state->stop_on_error = false;
#endif
	if (n_states > 2) {
		state_array[0].constant_state->backup_list = &state_array[1];
	}
}
  40d7b0:	d65f03c0 	ret
	state_array[0].constant_state = (struct zcbor_state_constant *)&state_array[n_states - 1];
  40d7b4:	d2800602 	mov	x2, #0x30                  	// #48
  40d7b8:	9b027c22 	mul	x2, x1, x2
  40d7bc:	d100c042 	sub	x2, x2, #0x30
  40d7c0:	8b020003 	add	x3, x0, x2
  40d7c4:	f9001403 	str	x3, [x0, #40]
	state_array[0].constant_state->num_backups = n_states - 2;
  40d7c8:	d1000823 	sub	x3, x1, #0x2
	state_array[0].constant_state->backup_list = NULL;
  40d7cc:	f822681f 	str	xzr, [x0, x2]
	state_array[0].constant_state->num_backups = n_states - 2;
  40d7d0:	f9401402 	ldr	x2, [x0, #40]
  40d7d4:	f9000843 	str	x3, [x2, #16]
	state_array[0].constant_state->current_backup = 0;
  40d7d8:	f9401402 	ldr	x2, [x0, #40]
  40d7dc:	f900045f 	str	xzr, [x2, #8]
	state_array[0].constant_state->error = ZCBOR_SUCCESS;
  40d7e0:	f9401402 	ldr	x2, [x0, #40]
  40d7e4:	b900185f 	str	wzr, [x2, #24]
	state_array[0].constant_state->stop_on_error = false;
  40d7e8:	f9401402 	ldr	x2, [x0, #40]
  40d7ec:	3900705f 	strb	wzr, [x2, #28]
	if (n_states > 2) {
  40d7f0:	f100083f 	cmp	x1, #0x2
  40d7f4:	54fffde0 	b.eq	40d7b0 <zcbor_new_state+0x20>  // b.none
		state_array[0].constant_state->backup_list = &state_array[1];
  40d7f8:	f9401401 	ldr	x1, [x0, #40]
  40d7fc:	9100c000 	add	x0, x0, #0x30
  40d800:	f9000020 	str	x0, [x1]
  40d804:	17ffffeb 	b	40d7b0 <zcbor_new_state+0x20>

000000000040d808 <zcbor_update_state>:

void zcbor_update_state(zcbor_state_t *state,
		const uint8_t *payload, size_t payload_len)
{
	state->payload = payload;
  40d808:	f9000001 	str	x1, [x0]
	state->payload_end = payload + payload_len;
  40d80c:	8b020021 	add	x1, x1, x2
	if (state->constant_state) {
  40d810:	f9401402 	ldr	x2, [x0, #40]
	state->payload_end = payload + payload_len;
  40d814:	f9000c01 	str	x1, [x0, #24]
	if (state->constant_state) {
  40d818:	b5000202 	cbnz	x2, 40d858 <zcbor_update_state+0x50>

	update_backups(state, state->payload_end);
}
  40d81c:	d65f03c0 	ret
			state->constant_state->backup_list[i].payload_end = new_payload_end;
  40d820:	f9400063 	ldr	x3, [x3]
  40d824:	9ba57c44 	umull	x4, w2, w5
		for (unsigned int i = 0; i < state->constant_state->current_backup; i++) {
  40d828:	11000442 	add	w2, w2, #0x1
			state->constant_state->backup_list[i].payload_end = new_payload_end;
  40d82c:	8b040063 	add	x3, x3, x4
  40d830:	f9000c61 	str	x1, [x3, #24]
			state->constant_state->backup_list[i].payload_moved = true;
  40d834:	f9401403 	ldr	x3, [x0, #40]
  40d838:	f9400063 	ldr	x3, [x3]
  40d83c:	8b040063 	add	x3, x3, x4
  40d840:	39008466 	strb	w6, [x3, #33]
		for (unsigned int i = 0; i < state->constant_state->current_backup; i++) {
  40d844:	f9401403 	ldr	x3, [x0, #40]
  40d848:	f9400464 	ldr	x4, [x3, #8]
  40d84c:	eb22409f 	cmp	x4, w2, uxtw
  40d850:	54fffe88 	b.hi	40d820 <zcbor_update_state+0x18>  // b.pmore
  40d854:	17fffff2 	b	40d81c <zcbor_update_state+0x14>
  40d858:	52800002 	mov	w2, #0x0                   	// #0
			state->constant_state->backup_list[i].payload_end = new_payload_end;
  40d85c:	52800605 	mov	w5, #0x30                  	// #48
			state->constant_state->backup_list[i].payload_moved = true;
  40d860:	52800026 	mov	w6, #0x1                   	// #1
  40d864:	17fffff8 	b	40d844 <zcbor_update_state+0x3c>

000000000040d868 <zcbor_check_error.isra.0>:
	return !(cs && cs->stop_on_error && cs->error);
  40d868:	b40000e0 	cbz	x0, 40d884 <zcbor_check_error.isra.0+0x1c>
  40d86c:	39407001 	ldrb	w1, [x0, #28]
  40d870:	340000a1 	cbz	w1, 40d884 <zcbor_check_error.isra.0+0x1c>
  40d874:	b9401800 	ldr	w0, [x0, #24]
  40d878:	7100001f 	cmp	w0, #0x0
  40d87c:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40d880:	d65f03c0 	ret
	return !(cs && cs->stop_on_error && cs->error);
  40d884:	52800020 	mov	w0, #0x1                   	// #1
  40d888:	17fffffe 	b	40d880 <zcbor_check_error.isra.0+0x18>

000000000040d88c <zcbor_error>:
{
  40d88c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d890:	2a0103e3 	mov	w3, w1
  40d894:	910003fd 	mov	x29, sp
  40d898:	f9401402 	ldr	x2, [x0, #40]
	if (zcbor_check_error(state))
  40d89c:	aa0203e0 	mov	x0, x2
  40d8a0:	97fffff2 	bl	40d868 <zcbor_check_error.isra.0>
  40d8a4:	72001c1f 	tst	w0, #0xff
  40d8a8:	54000060 	b.eq	40d8b4 <zcbor_error+0x28>  // b.none
		if (state->constant_state) {
  40d8ac:	b4000042 	cbz	x2, 40d8b4 <zcbor_error+0x28>
			state->constant_state->error = err;
  40d8b0:	b9001843 	str	w3, [x2, #24]
}
  40d8b4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d8b8:	d65f03c0 	ret

000000000040d8bc <initial_checks>:
	} \
} while(0)


static bool initial_checks(zcbor_state_t *state)
{
  40d8bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d8c0:	aa0003e2 	mov	x2, x0
  40d8c4:	910003fd 	mov	x29, sp
	ZCBOR_CHECK_ERROR();
  40d8c8:	f9401400 	ldr	x0, [x0, #40]
  40d8cc:	97ffffe7 	bl	40d868 <zcbor_check_error.isra.0>
  40d8d0:	72001c00 	ands	w0, w0, #0xff
  40d8d4:	54000120 	b.eq	40d8f8 <initial_checks+0x3c>  // b.none
	ZCBOR_CHECK_PAYLOAD();
  40d8d8:	f9400043 	ldr	x3, [x2]
  40d8dc:	f9400c41 	ldr	x1, [x2, #24]
  40d8e0:	eb01007f 	cmp	x3, x1
  40d8e4:	540000a3 	b.cc	40d8f8 <initial_checks+0x3c>  // b.lo, b.ul, b.last
  40d8e8:	aa0203e0 	mov	x0, x2
  40d8ec:	52800101 	mov	w1, #0x8                   	// #8
  40d8f0:	97ffffe7 	bl	40d88c <zcbor_error>
  40d8f4:	52800000 	mov	w0, #0x0                   	// #0
	return true;
}
  40d8f8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d8fc:	d65f03c0 	ret

000000000040d900 <type_check>:


static bool type_check(zcbor_state_t *state, zcbor_major_type_t exp_major_type)
{
  40d900:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40d904:	aa0003e4 	mov	x4, x0
  40d908:	2a0103e5 	mov	w5, w1
  40d90c:	910003fd 	mov	x29, sp
	if (!initial_checks(state)) {
  40d910:	97ffffeb 	bl	40d8bc <initial_checks>
  40d914:	72001c00 	ands	w0, w0, #0xff
  40d918:	54000120 	b.eq	40d93c <type_check+0x3c>  // b.none
		ZCBOR_FAIL();
	}
	zcbor_major_type_t major_type = MAJOR_TYPE(*state->payload);
  40d91c:	f9400081 	ldr	x1, [x4]
  40d920:	39400021 	ldrb	w1, [x1]

	if (major_type != exp_major_type) {
  40d924:	6b4114bf 	cmp	w5, w1, lsr #5
  40d928:	540000a0 	b.eq	40d93c <type_check+0x3c>  // b.none
		ZCBOR_ERR(ZCBOR_ERR_WRONG_TYPE);
  40d92c:	aa0403e0 	mov	x0, x4
  40d930:	52800141 	mov	w1, #0xa                   	// #10
  40d934:	97ffffd6 	bl	40d88c <zcbor_error>
  40d938:	52800000 	mov	w0, #0x0                   	// #0
	}
	return true;
}
  40d93c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d940:	d65f03c0 	ret

000000000040d944 <err_restore>:
	} \
} while(0)

static void err_restore(zcbor_state_t *state, int err)
{
	state->payload = state->payload_bak;
  40d944:	f9400403 	ldr	x3, [x0, #8]
  40d948:	f9000003 	str	x3, [x0]
	state->elem_count++;
  40d94c:	f9400803 	ldr	x3, [x0, #16]
  40d950:	91000463 	add	x3, x3, #0x1
  40d954:	f9000803 	str	x3, [x0, #16]
	zcbor_error(state, err);
  40d958:	17ffffcd 	b	40d88c <zcbor_error>

000000000040d95c <value_extract>:
 *          CBOR values are always big-endian, so this function converts from
 *          big to little-endian if necessary (@ref CONFIG_BIG_ENDIAN).
 */
static bool value_extract(zcbor_state_t *state,
		void *const result, size_t result_len)
{
  40d95c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40d960:	910003fd 	mov	x29, sp
  40d964:	a90153f3 	stp	x19, x20, [sp, #16]
  40d968:	aa0003f3 	mov	x19, x0
  40d96c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d970:	f9001bf7 	str	x23, [sp, #48]
	zcbor_trace();
	zcbor_assert_state(result_len != 0, "0-length result not supported.\r\n");
  40d974:	b5000162 	cbnz	x2, 40d9a0 <value_extract+0x44>
  40d978:	528001c1 	mov	w1, #0xe                   	// #14
	} else {
		size_t len = additional_len(additional);

		FAIL_AND_DECR_IF(len > result_len, ZCBOR_ERR_INT_SIZE);
		FAIL_AND_DECR_IF(len == 0, ZCBOR_ERR_ADDITIONAL_INVAL); // additional_len() did not recognize the additional value.
		FAIL_AND_DECR_IF((state->payload + len) > state->payload_end,
  40d97c:	52800014 	mov	w20, #0x0                   	// #0
  40d980:	aa1303e0 	mov	x0, x19
  40d984:	97ffffc2 	bl	40d88c <zcbor_error>
		(state->payload) += len;
	}

	(state->elem_count)--;
	return true;
}
  40d988:	2a1403e0 	mov	w0, w20
  40d98c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d990:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d994:	f9401bf7 	ldr	x23, [sp, #48]
  40d998:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40d99c:	d65f03c0 	ret
  40d9a0:	aa0103f6 	mov	x22, x1
	zcbor_assert_state(result != NULL, NULL);
  40d9a4:	b4fffea1 	cbz	x1, 40d978 <value_extract+0x1c>
  40d9a8:	aa0203f7 	mov	x23, x2
	INITIAL_CHECKS();
  40d9ac:	97ffffc4 	bl	40d8bc <initial_checks>
  40d9b0:	72001c14 	ands	w20, w0, #0xff
  40d9b4:	54fffea0 	b.eq	40d988 <value_extract+0x2c>  // b.none
	ZCBOR_ERR_IF((state->elem_count == 0), ZCBOR_ERR_LOW_ELEM_COUNT);
  40d9b8:	f9400a60 	ldr	x0, [x19, #16]
  40d9bc:	b5000060 	cbnz	x0, 40d9c8 <value_extract+0x6c>
  40d9c0:	52800061 	mov	w1, #0x3                   	// #3
  40d9c4:	17ffffee 	b	40d97c <value_extract+0x20>
	uint8_t additional = ADDITIONAL(*state->payload);
  40d9c8:	f9400260 	ldr	x0, [x19]
  return __builtin___memset_chk (__dest, __ch, __len,
  40d9cc:	aa1703e2 	mov	x2, x23
  40d9d0:	52800001 	mov	w1, #0x0                   	// #0
  40d9d4:	39400015 	ldrb	w21, [x0]
	state->payload_bak = state->payload;
  40d9d8:	f9000660 	str	x0, [x19, #8]
	(state->payload)++;
  40d9dc:	91000400 	add	x0, x0, #0x1
  40d9e0:	f9000260 	str	x0, [x19]
	uint8_t additional = ADDITIONAL(*state->payload);
  40d9e4:	120012b5 	and	w21, w21, #0x1f
  40d9e8:	aa1603e0 	mov	x0, x22
  40d9ec:	97ffce8d 	bl	401420 <memset@plt>
	if (additional <= ZCBOR_VALUE_IN_HEADER) {
  40d9f0:	71005ebf 	cmp	w21, #0x17
  40d9f4:	540000c8 	b.hi	40da0c <value_extract+0xb0>  // b.pmore
		u8_result[0] = additional;
  40d9f8:	390002d5 	strb	w21, [x22]
	(state->elem_count)--;
  40d9fc:	f9400a60 	ldr	x0, [x19, #16]
  40da00:	d1000400 	sub	x0, x0, #0x1
  40da04:	f9000a60 	str	x0, [x19, #16]
	return true;
  40da08:	17ffffe0 	b	40d988 <value_extract+0x2c>
	if (ZCBOR_VALUE_IS_1_BYTE <= additional && additional <= ZCBOR_VALUE_IS_8_BYTES) {
  40da0c:	510062b5 	sub	w21, w21, #0x18
  40da10:	12001ea0 	and	w0, w21, #0xff
		FAIL_AND_DECR_IF(len > result_len, ZCBOR_ERR_INT_SIZE);
  40da14:	f9400263 	ldr	x3, [x19]
	if (ZCBOR_VALUE_IS_1_BYTE <= additional && additional <= ZCBOR_VALUE_IS_8_BYTES) {
  40da18:	71000c1f 	cmp	w0, #0x3
  40da1c:	54000128 	b.hi	40da40 <value_extract+0xe4>  // b.pmore
		return 1U << (additional - ZCBOR_VALUE_IS_1_BYTE);
  40da20:	52800024 	mov	w4, #0x1                   	// #1
  40da24:	1ad52084 	lsl	w4, w4, w21
		FAIL_AND_DECR_IF(len > result_len, ZCBOR_ERR_INT_SIZE);
  40da28:	eb0402ff 	cmp	x23, x4
  40da2c:	54000122 	b.cs	40da50 <value_extract+0xf4>  // b.hs, b.nlast
  40da30:	d1000463 	sub	x3, x3, #0x1
  40da34:	528000a1 	mov	w1, #0x5                   	// #5
  40da38:	f9000263 	str	x3, [x19]
  40da3c:	17ffffd0 	b	40d97c <value_extract+0x20>
		FAIL_AND_DECR_IF(len == 0, ZCBOR_ERR_ADDITIONAL_INVAL); // additional_len() did not recognize the additional value.
  40da40:	d1000463 	sub	x3, x3, #0x1
  40da44:	528000e1 	mov	w1, #0x7                   	// #7
  40da48:	f9000263 	str	x3, [x19]
  40da4c:	17ffffcc 	b	40d97c <value_extract+0x20>
		FAIL_AND_DECR_IF((state->payload + len) > state->payload_end,
  40da50:	f9400e61 	ldr	x1, [x19, #24]
  40da54:	8b040060 	add	x0, x3, x4
  40da58:	eb00003f 	cmp	x1, x0
  40da5c:	540000a2 	b.cs	40da70 <value_extract+0x114>  // b.hs, b.nlast
  40da60:	d1000463 	sub	x3, x3, #0x1
  40da64:	52800101 	mov	w1, #0x8                   	// #8
  40da68:	f9000263 	str	x3, [x19]
  40da6c:	17ffffc4 	b	40d97c <value_extract+0x20>
			u8_result[i] = (state->payload)[len - i - 1];
  40da70:	d1000483 	sub	x3, x4, #0x1
		for (size_t i = 0; i < len; i++) {
  40da74:	d2800000 	mov	x0, #0x0                   	// #0
			u8_result[i] = (state->payload)[len - i - 1];
  40da78:	f9400262 	ldr	x2, [x19]
  40da7c:	cb000061 	sub	x1, x3, x0
  40da80:	38616841 	ldrb	w1, [x2, x1]
  40da84:	38206ac1 	strb	w1, [x22, x0]
		for (size_t i = 0; i < len; i++) {
  40da88:	91000400 	add	x0, x0, #0x1
  40da8c:	eb04001f 	cmp	x0, x4
  40da90:	54ffff43 	b.cc	40da78 <value_extract+0x11c>  // b.lo, b.ul, b.last
		(state->payload) += len;
  40da94:	f9400260 	ldr	x0, [x19]
  40da98:	8b040000 	add	x0, x0, x4
  40da9c:	f9000260 	str	x0, [x19]
  40daa0:	17ffffd7 	b	40d9fc <value_extract+0xa0>

000000000040daa4 <str_start_decode>:
#endif


static bool str_start_decode(zcbor_state_t *state,
		struct zcbor_string *result, zcbor_major_type_t exp_major_type)
{
  40daa4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40daa8:	910003fd 	mov	x29, sp
  40daac:	a90153f3 	stp	x19, x20, [sp, #16]
  40dab0:	aa0103f3 	mov	x19, x1
  40dab4:	aa0003f4 	mov	x20, x0
  40dab8:	2a0203e1 	mov	w1, w2
	INITIAL_CHECKS_WITH_TYPE(exp_major_type);
  40dabc:	97ffff91 	bl	40d900 <type_check>
  40dac0:	72001c1f 	tst	w0, #0xff
  40dac4:	540000a1 	b.ne	40dad8 <str_start_decode+0x34>  // b.any
  40dac8:	52800000 	mov	w0, #0x0                   	// #0
		ZCBOR_FAIL();
	}

	result->value = state->payload;
	return true;
}
  40dacc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dad0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40dad4:	d65f03c0 	ret
	if (!value_extract(state, &result->len, sizeof(result->len))) {
  40dad8:	d2800102 	mov	x2, #0x8                   	// #8
  40dadc:	aa1403e0 	mov	x0, x20
  40dae0:	8b020261 	add	x1, x19, x2
  40dae4:	97ffff9e 	bl	40d95c <value_extract>
  40dae8:	72001c00 	ands	w0, w0, #0xff
  40daec:	54fffee0 	b.eq	40dac8 <str_start_decode+0x24>  // b.none
	result->value = state->payload;
  40daf0:	f9400281 	ldr	x1, [x20]
  40daf4:	f9000261 	str	x1, [x19]
	return true;
  40daf8:	17fffff5 	b	40dacc <str_start_decode+0x28>

000000000040dafc <str_start_decode_with_overflow_check>:

static bool str_start_decode_with_overflow_check(zcbor_state_t *state,
		struct zcbor_string *result, zcbor_major_type_t exp_major_type)
{
  40dafc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40db00:	910003fd 	mov	x29, sp
  40db04:	a90153f3 	stp	x19, x20, [sp, #16]
  40db08:	aa0003f3 	mov	x19, x0
  40db0c:	aa0103f4 	mov	x20, x1
	bool res = str_start_decode(state, result, exp_major_type);
  40db10:	97ffffe5 	bl	40daa4 <str_start_decode>

	if (!res) {
  40db14:	72001c00 	ands	w0, w0, #0xff
  40db18:	54000160 	b.eq	40db44 <str_start_decode_with_overflow_check+0x48>  // b.none
		ZCBOR_FAIL();
	}

	/* Casting to size_t is safe since str_start_decode() checks that
	 * payload_end is bigger that payload. */
	if (result->len > (size_t)(state->payload_end - state->payload)) {
  40db1c:	f9400261 	ldr	x1, [x19]
  40db20:	f9400e62 	ldr	x2, [x19, #24]
  40db24:	cb010042 	sub	x2, x2, x1
  40db28:	f9400681 	ldr	x1, [x20, #8]
  40db2c:	eb02003f 	cmp	x1, x2
  40db30:	540000a9 	b.ls	40db44 <str_start_decode_with_overflow_check+0x48>  // b.plast
		zcbor_print("error: 0x%zu > 0x%zu\r\n",
			result->len,
			(state->payload_end - state->payload));
		ERR_RESTORE(ZCBOR_ERR_NO_PAYLOAD);
  40db34:	aa1303e0 	mov	x0, x19
  40db38:	52800101 	mov	w1, #0x8                   	// #8
  40db3c:	97ffff82 	bl	40d944 <err_restore>
  40db40:	52800000 	mov	w0, #0x0                   	// #0
	}

	return true;
}
  40db44:	a94153f3 	ldp	x19, x20, [sp, #16]
  40db48:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40db4c:	d65f03c0 	ret

000000000040db50 <str_decode>:
}


static bool str_decode(zcbor_state_t *state, struct zcbor_string *result,
		zcbor_major_type_t exp_major_type)
{
  40db50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40db54:	910003fd 	mov	x29, sp
  40db58:	a90153f3 	stp	x19, x20, [sp, #16]
  40db5c:	aa0003f3 	mov	x19, x0
  40db60:	aa0103f4 	mov	x20, x1
	if (!str_start_decode_with_overflow_check(state, result, exp_major_type)) {
  40db64:	97ffffe6 	bl	40dafc <str_start_decode_with_overflow_check>
  40db68:	72001c1f 	tst	w0, #0xff
  40db6c:	540000a0 	b.eq	40db80 <str_decode+0x30>  // b.none
		ZCBOR_FAIL();
	}

	state->payload += result->len;
  40db70:	f9400262 	ldr	x2, [x19]
  40db74:	f9400681 	ldr	x1, [x20, #8]
  40db78:	8b010041 	add	x1, x2, x1
  40db7c:	f9000261 	str	x1, [x19]
	return true;
}
  40db80:	a94153f3 	ldp	x19, x20, [sp, #16]
  40db84:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40db88:	d65f03c0 	ret

000000000040db8c <array_end_expect>:
	return ret;
}


static bool array_end_expect(zcbor_state_t *state)
{
  40db8c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40db90:	aa0003e4 	mov	x4, x0
  40db94:	910003fd 	mov	x29, sp
	INITIAL_CHECKS();
  40db98:	97ffff49 	bl	40d8bc <initial_checks>
  40db9c:	72001c00 	ands	w0, w0, #0xff
  40dba0:	54000120 	b.eq	40dbc4 <array_end_expect+0x38>  // b.none
	ZCBOR_ERR_IF(*state->payload != 0xFF, ZCBOR_ERR_WRONG_TYPE);
  40dba4:	f9400081 	ldr	x1, [x4]
  40dba8:	39400022 	ldrb	w2, [x1]
  40dbac:	7103fc5f 	cmp	w2, #0xff
  40dbb0:	540000e0 	b.eq	40dbcc <array_end_expect+0x40>  // b.none
  40dbb4:	aa0403e0 	mov	x0, x4
  40dbb8:	52800141 	mov	w1, #0xa                   	// #10
  40dbbc:	97ffff34 	bl	40d88c <zcbor_error>
  40dbc0:	52800000 	mov	w0, #0x0                   	// #0

	state->payload++;
	return true;
}
  40dbc4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40dbc8:	d65f03c0 	ret
	state->payload++;
  40dbcc:	91000421 	add	x1, x1, #0x1
  40dbd0:	f9000081 	str	x1, [x4]
	return true;
  40dbd4:	17fffffc 	b	40dbc4 <array_end_expect+0x38>

000000000040dbd8 <list_map_end_decode>:

static bool list_map_end_decode(zcbor_state_t *state)
{
	size_t max_elem_count = 0;

	if (state->indefinite_length_array) {
  40dbd8:	39408001 	ldrb	w1, [x0, #32]
{
  40dbdc:	aa0003e5 	mov	x5, x0
	if (state->indefinite_length_array) {
  40dbe0:	34000181 	cbz	w1, 40dc10 <list_map_end_decode+0x38>
{
  40dbe4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40dbe8:	910003fd 	mov	x29, sp
		if (!array_end_expect(state)) {
  40dbec:	97ffffe8 	bl	40db8c <array_end_expect>
  40dbf0:	72001c1f 	tst	w0, #0xff
  40dbf4:	54000140 	b.eq	40dc1c <list_map_end_decode+0x44>  // b.none
			ZCBOR_FAIL();
		}
		max_elem_count = ZCBOR_MAX_ELEM_COUNT;
		state->indefinite_length_array = false;
  40dbf8:	390080bf 	strb	wzr, [x5, #32]
		max_elem_count = ZCBOR_MAX_ELEM_COUNT;
  40dbfc:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
	}
	if (!zcbor_process_backup(state,
  40dc00:	528000e1 	mov	w1, #0x7                   	// #7
  40dc04:	aa0503e0 	mov	x0, x5
			max_elem_count)) {
		ZCBOR_FAIL();
	}

	return true;
}
  40dc08:	a8c17bfd 	ldp	x29, x30, [sp], #16
	if (!zcbor_process_backup(state,
  40dc0c:	17fffeb6 	b	40d6e4 <zcbor_process_backup>
	size_t max_elem_count = 0;
  40dc10:	d2800002 	mov	x2, #0x0                   	// #0
	if (!zcbor_process_backup(state,
  40dc14:	528000e1 	mov	w1, #0x7                   	// #7
  40dc18:	17fffffd 	b	40dc0c <list_map_end_decode+0x34>
}
  40dc1c:	52800000 	mov	w0, #0x0                   	// #0
  40dc20:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40dc24:	d65f03c0 	ret

000000000040dc28 <float_check>:
	return zcbor_simple_expect(state, (uint8_t)(!!result) + ZCBOR_BOOL_TO_SIMPLE);
}


static bool float_check(zcbor_state_t *state, uint8_t additional_val)
{
  40dc28:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40dc2c:	aa0003e6 	mov	x6, x0
  40dc30:	12001c27 	and	w7, w1, #0xff
  40dc34:	910003fd 	mov	x29, sp
	INITIAL_CHECKS_WITH_TYPE(ZCBOR_MAJOR_TYPE_SIMPLE);
  40dc38:	528000e1 	mov	w1, #0x7                   	// #7
  40dc3c:	97ffff31 	bl	40d900 <type_check>
  40dc40:	72001c00 	ands	w0, w0, #0xff
  40dc44:	54000140 	b.eq	40dc6c <float_check+0x44>  // b.none
	ZCBOR_ERR_IF(ADDITIONAL(*state->payload) != additional_val, ZCBOR_ERR_FLOAT_SIZE);
  40dc48:	f94000c1 	ldr	x1, [x6]
  40dc4c:	39400021 	ldrb	w1, [x1]
  40dc50:	12001021 	and	w1, w1, #0x1f
  40dc54:	6b0100ff 	cmp	w7, w1
  40dc58:	540000a0 	b.eq	40dc6c <float_check+0x44>  // b.none
  40dc5c:	aa0603e0 	mov	x0, x6
  40dc60:	528000c1 	mov	w1, #0x6                   	// #6
  40dc64:	97ffff0a 	bl	40d88c <zcbor_error>
  40dc68:	52800000 	mov	w0, #0x0                   	// #0
	return true;
}
  40dc6c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40dc70:	d65f03c0 	ret

000000000040dc74 <list_map_start_decode>:
{
  40dc74:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40dc78:	f00000e2 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  40dc7c:	910003fd 	mov	x29, sp
  40dc80:	f9478442 	ldr	x2, [x2, #3848]
  40dc84:	a90153f3 	stp	x19, x20, [sp, #16]
  40dc88:	aa0003f3 	mov	x19, x0
  40dc8c:	f9400043 	ldr	x3, [x2]
  40dc90:	f90017e3 	str	x3, [sp, #40]
  40dc94:	d2800003 	mov	x3, #0x0                   	// #0
	INITIAL_CHECKS_WITH_TYPE(exp_major_type);
  40dc98:	97ffff1a 	bl	40d900 <type_check>
  40dc9c:	72001c14 	ands	w20, w0, #0xff
  40dca0:	540001e0 	b.eq	40dcdc <list_map_start_decode+0x68>  // b.none
	if (ADDITIONAL(*state->payload) == ZCBOR_VALUE_IS_INDEFINITE_LENGTH) {
  40dca4:	f9400261 	ldr	x1, [x19]
  40dca8:	39400020 	ldrb	w0, [x1]
  40dcac:	12001000 	and	w0, w0, #0x1f
  40dcb0:	71007c1f 	cmp	w0, #0x1f
  40dcb4:	54000421 	b.ne	40dd38 <list_map_start_decode+0xc4>  // b.any
		new_elem_count = ZCBOR_LARGE_ELEM_COUNT;
  40dcb8:	92800200 	mov	x0, #0xffffffffffffffef    	// #-17
  40dcbc:	f90013e0 	str	x0, [sp, #32]
		ZCBOR_ERR_IF(state->elem_count == 0, ZCBOR_ERR_LOW_ELEM_COUNT);
  40dcc0:	f9400a60 	ldr	x0, [x19, #16]
  40dcc4:	b50001c0 	cbnz	x0, 40dcfc <list_map_start_decode+0x88>
  40dcc8:	aa1303e0 	mov	x0, x19
  40dccc:	52800061 	mov	w1, #0x3                   	// #3
  40dcd0:	97fffeef 	bl	40d88c <zcbor_error>
  40dcd4:	52800000 	mov	w0, #0x0                   	// #0
  40dcd8:	2a0003f4 	mov	w20, w0
}
  40dcdc:	f00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40dce0:	f9478400 	ldr	x0, [x0, #3848]
  40dce4:	f94017e2 	ldr	x2, [sp, #40]
  40dce8:	f9400001 	ldr	x1, [x0]
  40dcec:	eb010042 	subs	x2, x2, x1
  40dcf0:	d2800001 	mov	x1, #0x0                   	// #0
  40dcf4:	54000360 	b.eq	40dd60 <list_map_start_decode+0xec>  // b.none
  40dcf8:	97ffcdee 	bl	4014b0 <__stack_chk_fail@plt>
		state->payload++;
  40dcfc:	91000421 	add	x1, x1, #0x1
		state->elem_count--;
  40dd00:	d1000400 	sub	x0, x0, #0x1
		state->payload++;
  40dd04:	f9000261 	str	x1, [x19]
		state->elem_count--;
  40dd08:	f9000a60 	str	x0, [x19, #16]
	if (!zcbor_new_backup(state, new_elem_count)) {
  40dd0c:	f94013e1 	ldr	x1, [sp, #32]
  40dd10:	aa1303e0 	mov	x0, x19
  40dd14:	97fffe52 	bl	40d65c <zcbor_new_backup>
  40dd18:	72001c00 	ands	w0, w0, #0xff
  40dd1c:	540001e1 	b.ne	40dd58 <list_map_start_decode+0xe4>  // b.any
		FAIL_RESTORE();
  40dd20:	f9400661 	ldr	x1, [x19, #8]
  40dd24:	f9000261 	str	x1, [x19]
  40dd28:	f9400a61 	ldr	x1, [x19, #16]
  40dd2c:	91000421 	add	x1, x1, #0x1
  40dd30:	f9000a61 	str	x1, [x19, #16]
  40dd34:	17ffffe9 	b	40dcd8 <list_map_start_decode+0x64>
		if (!value_extract(state, &new_elem_count, sizeof(new_elem_count))) {
  40dd38:	910083e1 	add	x1, sp, #0x20
  40dd3c:	aa1303e0 	mov	x0, x19
  40dd40:	d2800102 	mov	x2, #0x8                   	// #8
  40dd44:	97ffff06 	bl	40d95c <value_extract>
  40dd48:	72001c00 	ands	w0, w0, #0xff
  40dd4c:	54fffc60 	b.eq	40dcd8 <list_map_start_decode+0x64>  // b.none
	bool indefinite_length_array = false;
  40dd50:	52800014 	mov	w20, #0x0                   	// #0
  40dd54:	17ffffee 	b	40dd0c <list_map_start_decode+0x98>
	state->indefinite_length_array = indefinite_length_array;
  40dd58:	39008274 	strb	w20, [x19, #32]
	return true;
  40dd5c:	17ffffdf 	b	40dcd8 <list_map_start_decode+0x64>
}
  40dd60:	2a1403e0 	mov	w0, w20
  40dd64:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dd68:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40dd6c:	d65f03c0 	ret

000000000040dd70 <zcbor_int_decode>:
{
  40dd70:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40dd74:	910003fd 	mov	x29, sp
  40dd78:	a90153f3 	stp	x19, x20, [sp, #16]
  40dd7c:	aa0003f4 	mov	x20, x0
  40dd80:	aa0103f3 	mov	x19, x1
  40dd84:	a9025bf5 	stp	x21, x22, [sp, #32]
  40dd88:	aa0203f5 	mov	x21, x2
	INITIAL_CHECKS();
  40dd8c:	97fffecc 	bl	40d8bc <initial_checks>
  40dd90:	72001c1f 	tst	w0, #0xff
  40dd94:	540000c1 	b.ne	40ddac <zcbor_int_decode+0x3c>  // b.any
		ERR_RESTORE(ZCBOR_ERR_INT_SIZE);
  40dd98:	52800000 	mov	w0, #0x0                   	// #0
}
  40dd9c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dda0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dda4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40dda8:	d65f03c0 	ret
	zcbor_major_type_t major_type = MAJOR_TYPE(*state->payload);
  40ddac:	f9400280 	ldr	x0, [x20]
  40ddb0:	39400000 	ldrb	w0, [x0]
  40ddb4:	53057c16 	lsr	w22, w0, #5
	if (major_type != ZCBOR_MAJOR_TYPE_PINT
  40ddb8:	7100fc1f 	cmp	w0, #0x3f
  40ddbc:	540000a9 	b.ls	40ddd0 <zcbor_int_decode+0x60>  // b.plast
		ZCBOR_ERR(ZCBOR_ERR_WRONG_TYPE);
  40ddc0:	aa1403e0 	mov	x0, x20
  40ddc4:	52800141 	mov	w1, #0xa                   	// #10
  40ddc8:	97fffeb1 	bl	40d88c <zcbor_error>
  40ddcc:	17fffff3 	b	40dd98 <zcbor_int_decode+0x28>
	if (!value_extract(state, result_int, int_size)) {
  40ddd0:	aa1503e2 	mov	x2, x21
  40ddd4:	aa1303e1 	mov	x1, x19
  40ddd8:	aa1403e0 	mov	x0, x20
  40dddc:	97fffee0 	bl	40d95c <value_extract>
  40dde0:	72001c00 	ands	w0, w0, #0xff
  40dde4:	54fffda0 	b.eq	40dd98 <zcbor_int_decode+0x28>  // b.none
	if (result_int8[int_size - 1] < 0) {
  40dde8:	8b150261 	add	x1, x19, x21
  40ddec:	38dff021 	ldursb	w1, [x1, #-1]
  40ddf0:	36f800a1 	tbz	w1, #31, 40de04 <zcbor_int_decode+0x94>
		ERR_RESTORE(ZCBOR_ERR_INT_SIZE);
  40ddf4:	aa1403e0 	mov	x0, x20
  40ddf8:	528000a1 	mov	w1, #0x5                   	// #5
  40ddfc:	97fffed2 	bl	40d944 <err_restore>
  40de00:	17ffffe6 	b	40dd98 <zcbor_int_decode+0x28>
	if (major_type == ZCBOR_MAJOR_TYPE_NINT) {
  40de04:	710006df 	cmp	w22, #0x1
  40de08:	54fffca1 	b.ne	40dd9c <zcbor_int_decode+0x2c>  // b.any
		for (unsigned int i = 0; i < int_size; i++) {
  40de0c:	52800001 	mov	w1, #0x0                   	// #0
  40de10:	14000005 	b	40de24 <zcbor_int_decode+0xb4>
			result_uint8[i] = (uint8_t)~result_uint8[i];
  40de14:	38636a62 	ldrb	w2, [x19, x3]
		for (unsigned int i = 0; i < int_size; i++) {
  40de18:	11000421 	add	w1, w1, #0x1
			result_uint8[i] = (uint8_t)~result_uint8[i];
  40de1c:	2a2203e2 	mvn	w2, w2
  40de20:	38236a62 	strb	w2, [x19, x3]
		for (unsigned int i = 0; i < int_size; i++) {
  40de24:	2a0103e3 	mov	w3, w1
  40de28:	eb2142bf 	cmp	x21, w1, uxtw
  40de2c:	54ffff48 	b.hi	40de14 <zcbor_int_decode+0xa4>  // b.pmore
  40de30:	17ffffdb 	b	40dd9c <zcbor_int_decode+0x2c>

000000000040de34 <zcbor_int32_decode>:
	return zcbor_int_decode(state, result, sizeof(*result));
  40de34:	d2800082 	mov	x2, #0x4                   	// #4
  40de38:	17ffffce 	b	40dd70 <zcbor_int_decode>

000000000040de3c <zcbor_uint_decode>:
{
  40de3c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40de40:	aa0103e7 	mov	x7, x1
  40de44:	aa0003e6 	mov	x6, x0
  40de48:	910003fd 	mov	x29, sp
  40de4c:	aa0203e8 	mov	x8, x2
	INITIAL_CHECKS_WITH_TYPE(ZCBOR_MAJOR_TYPE_PINT);
  40de50:	52800001 	mov	w1, #0x0                   	// #0
  40de54:	97fffeab 	bl	40d900 <type_check>
  40de58:	72001c1f 	tst	w0, #0xff
  40de5c:	540000c0 	b.eq	40de74 <zcbor_uint_decode+0x38>  // b.none
}
  40de60:	a8c17bfd 	ldp	x29, x30, [sp], #16
	if (!value_extract(state, result_uint, uint_size)) {
  40de64:	aa0803e2 	mov	x2, x8
  40de68:	aa0703e1 	mov	x1, x7
  40de6c:	aa0603e0 	mov	x0, x6
  40de70:	17fffebb 	b	40d95c <value_extract>
}
  40de74:	52800000 	mov	w0, #0x0                   	// #0
  40de78:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40de7c:	d65f03c0 	ret

000000000040de80 <zcbor_uint32_decode>:
	return zcbor_uint_decode(state, result, sizeof(*result));
  40de80:	d2800082 	mov	x2, #0x4                   	// #4
  40de84:	17ffffee 	b	40de3c <zcbor_uint_decode>

000000000040de88 <zcbor_tstr_decode>:
	return str_decode(state, result, ZCBOR_MAJOR_TYPE_TSTR);
  40de88:	52800062 	mov	w2, #0x3                   	// #3
  40de8c:	17ffff31 	b	40db50 <str_decode>

000000000040de90 <zcbor_list_start_decode>:
	return list_map_start_decode(state, ZCBOR_MAJOR_TYPE_LIST);
  40de90:	52800081 	mov	w1, #0x4                   	// #4
  40de94:	17ffff78 	b	40dc74 <list_map_start_decode>

000000000040de98 <zcbor_map_start_decode>:
{
  40de98:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	bool ret = list_map_start_decode(state, ZCBOR_MAJOR_TYPE_MAP);
  40de9c:	528000a1 	mov	w1, #0x5                   	// #5
{
  40dea0:	910003fd 	mov	x29, sp
  40dea4:	f9000bf3 	str	x19, [sp, #16]
  40dea8:	aa0003f3 	mov	x19, x0
	bool ret = list_map_start_decode(state, ZCBOR_MAJOR_TYPE_MAP);
  40deac:	97ffff72 	bl	40dc74 <list_map_start_decode>
	if (ret && !state->indefinite_length_array) {
  40deb0:	72001c00 	ands	w0, w0, #0xff
  40deb4:	54000240 	b.eq	40defc <zcbor_map_start_decode+0x64>  // b.none
  40deb8:	39408264 	ldrb	w4, [x19, #32]
  40debc:	35000104 	cbnz	w4, 40dedc <zcbor_map_start_decode+0x44>
		if (state->elem_count >= (ZCBOR_MAX_ELEM_COUNT / 2)) {
  40dec0:	f9400a61 	ldr	x1, [x19, #16]
  40dec4:	b27ff7e2 	mov	x2, #0x7ffffffffffffffe    	// #9223372036854775806
  40dec8:	eb02003f 	cmp	x1, x2
  40decc:	54000109 	b.ls	40deec <zcbor_map_start_decode+0x54>  // b.plast
			ERR_RESTORE(ZCBOR_ERR_INT_SIZE);
  40ded0:	aa1303e0 	mov	x0, x19
  40ded4:	528000a1 	mov	w1, #0x5                   	// #5
  40ded8:	97fffe9b 	bl	40d944 <err_restore>
}
  40dedc:	2a0403e0 	mov	w0, w4
  40dee0:	f9400bf3 	ldr	x19, [sp, #16]
  40dee4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40dee8:	d65f03c0 	ret
		state->elem_count *= 2;
  40deec:	d37ff821 	lsl	x1, x1, #1
  40def0:	2a0003e4 	mov	w4, w0
  40def4:	f9000a61 	str	x1, [x19, #16]
  40def8:	17fffff9 	b	40dedc <zcbor_map_start_decode+0x44>
  40defc:	52800004 	mov	w4, #0x0                   	// #0
  40df00:	17fffff7 	b	40dedc <zcbor_map_start_decode+0x44>

000000000040df04 <zcbor_list_end_decode>:
	return list_map_end_decode(state);
  40df04:	17ffff35 	b	40dbd8 <list_map_end_decode>

000000000040df08 <zcbor_simple_decode>:
{
  40df08:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40df0c:	aa0003e6 	mov	x6, x0
  40df10:	aa0103e7 	mov	x7, x1
  40df14:	910003fd 	mov	x29, sp
	INITIAL_CHECKS_WITH_TYPE(ZCBOR_MAJOR_TYPE_SIMPLE);
  40df18:	528000e1 	mov	w1, #0x7                   	// #7
  40df1c:	97fffe79 	bl	40d900 <type_check>
  40df20:	72001c00 	ands	w0, w0, #0xff
  40df24:	54000140 	b.eq	40df4c <zcbor_simple_decode+0x44>  // b.none
	ZCBOR_ERR_IF(ADDITIONAL(*state->payload) > 24, ZCBOR_ERR_WRONG_TYPE);
  40df28:	f94000c0 	ldr	x0, [x6]
  40df2c:	39400000 	ldrb	w0, [x0]
  40df30:	12001000 	and	w0, w0, #0x1f
  40df34:	7100601f 	cmp	w0, #0x18
  40df38:	540000e9 	b.ls	40df54 <zcbor_simple_decode+0x4c>  // b.plast
  40df3c:	aa0603e0 	mov	x0, x6
  40df40:	52800141 	mov	w1, #0xa                   	// #10
  40df44:	97fffe52 	bl	40d88c <zcbor_error>
  40df48:	52800000 	mov	w0, #0x0                   	// #0
}
  40df4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40df50:	d65f03c0 	ret
  40df54:	a8c17bfd 	ldp	x29, x30, [sp], #16
	if (!value_extract(state, result, sizeof(*result))) {
  40df58:	aa0703e1 	mov	x1, x7
  40df5c:	aa0603e0 	mov	x0, x6
  40df60:	d2800022 	mov	x2, #0x1                   	// #1
  40df64:	17fffe7e 	b	40d95c <value_extract>

000000000040df68 <zcbor_simple_expect>:
{
  40df68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40df6c:	910003fd 	mov	x29, sp
  40df70:	a90153f3 	stp	x19, x20, [sp, #16]
  40df74:	12001c34 	and	w20, w1, #0xff
  40df78:	f00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40df7c:	aa0003f3 	mov	x19, x0
  40df80:	f9478421 	ldr	x1, [x1, #3848]
  40df84:	f9400022 	ldr	x2, [x1]
  40df88:	f90017e2 	str	x2, [sp, #40]
  40df8c:	d2800002 	mov	x2, #0x0                   	// #0
	if (!zcbor_simple_decode(state, &value)) {
  40df90:	91009fe1 	add	x1, sp, #0x27
  40df94:	97ffffdd 	bl	40df08 <zcbor_simple_decode>
  40df98:	72001c00 	ands	w0, w0, #0xff
  40df9c:	54000100 	b.eq	40dfbc <zcbor_simple_expect+0x54>  // b.none
	if (value != result) {
  40dfa0:	39409fe1 	ldrb	w1, [sp, #39]
  40dfa4:	6b14003f 	cmp	w1, w20
  40dfa8:	540000a0 	b.eq	40dfbc <zcbor_simple_expect+0x54>  // b.none
		ERR_RESTORE(ZCBOR_ERR_WRONG_VALUE);
  40dfac:	aa1303e0 	mov	x0, x19
  40dfb0:	52800161 	mov	w1, #0xb                   	// #11
  40dfb4:	97fffe64 	bl	40d944 <err_restore>
  40dfb8:	52800000 	mov	w0, #0x0                   	// #0
}
  40dfbc:	f00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40dfc0:	f9478421 	ldr	x1, [x1, #3848]
  40dfc4:	f94017e3 	ldr	x3, [sp, #40]
  40dfc8:	f9400022 	ldr	x2, [x1]
  40dfcc:	eb020063 	subs	x3, x3, x2
  40dfd0:	d2800002 	mov	x2, #0x0                   	// #0
  40dfd4:	54000040 	b.eq	40dfdc <zcbor_simple_expect+0x74>  // b.none
  40dfd8:	97ffcd36 	bl	4014b0 <__stack_chk_fail@plt>
  40dfdc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dfe0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40dfe4:	d65f03c0 	ret

000000000040dfe8 <zcbor_nil_expect>:
	return zcbor_simple_expect(state, 22);
  40dfe8:	528002c1 	mov	w1, #0x16                  	// #22
  40dfec:	17ffffdf 	b	40df68 <zcbor_simple_expect>

000000000040dff0 <zcbor_bool_decode>:
{
  40dff0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40dff4:	910003fd 	mov	x29, sp
  40dff8:	a90153f3 	stp	x19, x20, [sp, #16]
  40dffc:	aa0103f3 	mov	x19, x1
  40e000:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40e004:	aa0003f4 	mov	x20, x0
  40e008:	f9478421 	ldr	x1, [x1, #3848]
  40e00c:	f9400022 	ldr	x2, [x1]
  40e010:	f90017e2 	str	x2, [sp, #40]
  40e014:	d2800002 	mov	x2, #0x0                   	// #0
	if (!zcbor_simple_decode(state, &value)) {
  40e018:	91009fe1 	add	x1, sp, #0x27
  40e01c:	97ffffbb 	bl	40df08 <zcbor_simple_decode>
  40e020:	72001c00 	ands	w0, w0, #0xff
  40e024:	54000160 	b.eq	40e050 <zcbor_bool_decode+0x60>  // b.none
	value -= ZCBOR_BOOL_TO_SIMPLE;
  40e028:	39409fe2 	ldrb	w2, [sp, #39]
  40e02c:	51005042 	sub	w2, w2, #0x14
  40e030:	12001c42 	and	w2, w2, #0xff
  40e034:	39009fe2 	strb	w2, [sp, #39]
	if (value > 1) {
  40e038:	7100045f 	cmp	w2, #0x1
  40e03c:	540001a9 	b.ls	40e070 <zcbor_bool_decode+0x80>  // b.plast
		ERR_RESTORE(ZCBOR_ERR_WRONG_TYPE);
  40e040:	aa1403e0 	mov	x0, x20
  40e044:	52800141 	mov	w1, #0xa                   	// #10
  40e048:	97fffe3f 	bl	40d944 <err_restore>
  40e04c:	52800000 	mov	w0, #0x0                   	// #0
}
  40e050:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40e054:	f9478421 	ldr	x1, [x1, #3848]
  40e058:	f94017e3 	ldr	x3, [sp, #40]
  40e05c:	f9400022 	ldr	x2, [x1]
  40e060:	eb020063 	subs	x3, x3, x2
  40e064:	d2800002 	mov	x2, #0x0                   	// #0
  40e068:	540000a0 	b.eq	40e07c <zcbor_bool_decode+0x8c>  // b.none
  40e06c:	97ffcd11 	bl	4014b0 <__stack_chk_fail@plt>
	*result = value;
  40e070:	12000042 	and	w2, w2, #0x1
  40e074:	39000262 	strb	w2, [x19]
	return true;
  40e078:	17fffff6 	b	40e050 <zcbor_bool_decode+0x60>
}
  40e07c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e080:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40e084:	d65f03c0 	ret

000000000040e088 <zcbor_float32_decode>:
	return true;
}


bool zcbor_float32_decode(zcbor_state_t *state, float *result)
{
  40e088:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40e08c:	aa0103e9 	mov	x9, x1
  40e090:	aa0003e8 	mov	x8, x0
  40e094:	910003fd 	mov	x29, sp
	ZCBOR_FAIL_IF(!float_check(state, ZCBOR_VALUE_IS_4_BYTES));
  40e098:	52800341 	mov	w1, #0x1a                  	// #26
  40e09c:	97fffee3 	bl	40dc28 <float_check>
  40e0a0:	72001c1f 	tst	w0, #0xff
  40e0a4:	540000c0 	b.eq	40e0bc <zcbor_float32_decode+0x34>  // b.none
	if (!value_extract(state, result, sizeof(*result))) {
		ZCBOR_FAIL();
	}

	return true;
}
  40e0a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	if (!value_extract(state, result, sizeof(*result))) {
  40e0ac:	aa0903e1 	mov	x1, x9
  40e0b0:	aa0803e0 	mov	x0, x8
  40e0b4:	d2800082 	mov	x2, #0x4                   	// #4
  40e0b8:	17fffe29 	b	40d95c <value_extract>
}
  40e0bc:	52800000 	mov	w0, #0x0                   	// #0
  40e0c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40e0c4:	d65f03c0 	ret

000000000040e0c8 <zcbor_new_decode_state>:


void zcbor_new_decode_state(zcbor_state_t *state_array, size_t n_states,
		const uint8_t *payload, size_t payload_len, size_t elem_count)
{
	zcbor_new_state(state_array, n_states, payload, payload_len, elem_count);
  40e0c8:	17fffdb2 	b	40d790 <zcbor_new_state>

000000000040e0cc <get_result_len>:
	return true;
}


static size_t get_result_len(const void *const input, size_t max_result_len)
{
  40e0cc:	aa0003e2 	mov	x2, x0
	uint8_t *u8_result  = (uint8_t *)input;
	size_t len = max_result_len;

	for (; len > 0; len--) {
  40e0d0:	aa0103e0 	mov	x0, x1
  40e0d4:	b5000041 	cbnz	x1, 40e0dc <get_result_len+0x10>
		}
	}

	/* Round up to nearest power of 2. */
	return len <= 2 ? len : (uint8_t)(1 << log2ceil(len));
}
  40e0d8:	d65f03c0 	ret
		if (u8_result[len - 1] != 0) {
  40e0dc:	d1000401 	sub	x1, x0, #0x1
  40e0e0:	38616843 	ldrb	w3, [x2, x1]
  40e0e4:	34ffff63 	cbz	w3, 40e0d0 <get_result_len+0x4>
	return len <= 2 ? len : (uint8_t)(1 << log2ceil(len));
  40e0e8:	f100081f 	cmp	x0, #0x2
  40e0ec:	54ffff69 	b.ls	40e0d8 <get_result_len+0xc>  // b.plast
	switch(val) {
  40e0f0:	d1000800 	sub	x0, x0, #0x2
  40e0f4:	f100181f 	cmp	x0, #0x6
  40e0f8:	54000108 	b.hi	40e118 <get_result_len+0x4c>  // b.pmore
  40e0fc:	90000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40e100:	911d7021 	add	x1, x1, #0x75c
  40e104:	38606821 	ldrb	w1, [x1, x0]
	return len <= 2 ? len : (uint8_t)(1 << log2ceil(len));
  40e108:	52800020 	mov	w0, #0x1                   	// #1
  40e10c:	1ac12000 	lsl	w0, w0, w1
  40e110:	93407c00 	sxtw	x0, w0
  40e114:	17fffff1 	b	40e0d8 <get_result_len+0xc>
  40e118:	52800001 	mov	w1, #0x0                   	// #0
  40e11c:	17fffffb 	b	40e108 <get_result_len+0x3c>

000000000040e120 <zcbor_check_error.isra.0>:
	return !(cs && cs->stop_on_error && cs->error);
  40e120:	b40000e0 	cbz	x0, 40e13c <zcbor_check_error.isra.0+0x1c>
  40e124:	39407001 	ldrb	w1, [x0, #28]
  40e128:	340000a1 	cbz	w1, 40e13c <zcbor_check_error.isra.0+0x1c>
  40e12c:	b9401800 	ldr	w0, [x0, #24]
  40e130:	7100001f 	cmp	w0, #0x0
  40e134:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40e138:	d65f03c0 	ret
	return !(cs && cs->stop_on_error && cs->error);
  40e13c:	52800020 	mov	w0, #0x1                   	// #1
  40e140:	17fffffe 	b	40e138 <zcbor_check_error.isra.0+0x18>

000000000040e144 <zcbor_error>:
{
  40e144:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40e148:	2a0103e3 	mov	w3, w1
  40e14c:	910003fd 	mov	x29, sp
  40e150:	f9401402 	ldr	x2, [x0, #40]
	if (zcbor_check_error(state))
  40e154:	aa0203e0 	mov	x0, x2
  40e158:	97fffff2 	bl	40e120 <zcbor_check_error.isra.0>
  40e15c:	72001c1f 	tst	w0, #0xff
  40e160:	54000060 	b.eq	40e16c <zcbor_error+0x28>  // b.none
		if (state->constant_state) {
  40e164:	b4000042 	cbz	x2, 40e16c <zcbor_error+0x28>
			state->constant_state->error = err;
  40e168:	b9001843 	str	w3, [x2, #24]
}
  40e16c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40e170:	d65f03c0 	ret

000000000040e174 <value_encode_len>:
{
  40e174:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40e178:	aa0003e4 	mov	x4, x0
  40e17c:	2a0103e6 	mov	w6, w1
  40e180:	910003fd 	mov	x29, sp

static size_t get_encoded_len(const void *const result, size_t result_len)
{
	const uint8_t *u8_result  = (const uint8_t *)result;

	if ((result_len == 1) && (u8_result[0] <= ZCBOR_VALUE_IN_HEADER)) {
  40e184:	f100047f 	cmp	x3, #0x1
  40e188:	54000081 	b.ne	40e198 <value_encode_len+0x24>  // b.any
  40e18c:	39400040 	ldrb	w0, [x2]
  40e190:	71005c1f 	cmp	w0, #0x17
  40e194:	9a9f97e3 	cset	x3, hi  // hi = pmore
	if ((state->payload + 1 + encoded_len) > state->payload_end) {
  40e198:	f9400087 	ldr	x7, [x4]
  40e19c:	91000460 	add	x0, x3, #0x1
  40e1a0:	f9400c88 	ldr	x8, [x4, #24]
  40e1a4:	8b0000e0 	add	x0, x7, x0
  40e1a8:	eb00011f 	cmp	x8, x0
  40e1ac:	540000e2 	b.cs	40e1c8 <value_encode_len+0x54>  // b.hs, b.nlast
		ZCBOR_ERR(ZCBOR_ERR_NO_PAYLOAD);
  40e1b0:	52800101 	mov	w1, #0x8                   	// #8
	zcbor_assert_state(additional < 32, NULL);
  40e1b4:	aa0403e0 	mov	x0, x4
  40e1b8:	97ffffe3 	bl	40e144 <zcbor_error>
		ZCBOR_FAIL();
  40e1bc:	52800000 	mov	w0, #0x0                   	// #0
}
  40e1c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40e1c4:	d65f03c0 	ret
	if (!encode_header_byte(state, major_type,
  40e1c8:	39400045 	ldrb	w5, [x2]
	return len == 0 ? value0 : (uint8_t)(24 + log2ceil(len));
  40e1cc:	b4000123 	cbz	x3, 40e1f0 <value_encode_len+0x7c>
	switch(val) {
  40e1d0:	d1000861 	sub	x1, x3, #0x2
  40e1d4:	f100183f 	cmp	x1, #0x6
  40e1d8:	54000208 	b.hi	40e218 <value_encode_len+0xa4>  // b.pmore
  40e1dc:	90000040 	adrp	x0, 416000 <__func__.0+0x57a>
  40e1e0:	911d7000 	add	x0, x0, #0x75c
  40e1e4:	38616805 	ldrb	w5, [x0, x1]
	return len == 0 ? value0 : (uint8_t)(24 + log2ceil(len));
  40e1e8:	110060a5 	add	w5, w5, #0x18
  40e1ec:	12001ca5 	and	w5, w5, #0xff
	ZCBOR_CHECK_ERROR();
  40e1f0:	f9401480 	ldr	x0, [x4, #40]
  40e1f4:	97ffffcb 	bl	40e120 <zcbor_check_error.isra.0>
  40e1f8:	72001c00 	ands	w0, w0, #0xff
  40e1fc:	54fffe20 	b.eq	40e1c0 <value_encode_len+0x4c>  // b.none
	ZCBOR_CHECK_PAYLOAD();
  40e200:	eb0800ff 	cmp	x7, x8
  40e204:	54fffd62 	b.cs	40e1b0 <value_encode_len+0x3c>  // b.hs, b.nlast
	zcbor_assert_state(additional < 32, NULL);
  40e208:	71007cbf 	cmp	w5, #0x1f
  40e20c:	540000a9 	b.ls	40e220 <value_encode_len+0xac>  // b.plast
  40e210:	528001c1 	mov	w1, #0xe                   	// #14
  40e214:	17ffffe8 	b	40e1b4 <value_encode_len+0x40>
	return len == 0 ? value0 : (uint8_t)(24 + log2ceil(len));
  40e218:	52800005 	mov	w5, #0x0                   	// #0
  40e21c:	17fffff3 	b	40e1e8 <value_encode_len+0x74>
	*(state->payload_mut++) = (uint8_t)((major_type << 5) | (additional & 0x1F));
  40e220:	910004e1 	add	x1, x7, #0x1
  40e224:	f9000081 	str	x1, [x4]
  40e228:	2a0614a6 	orr	w6, w5, w6, lsl #5
  40e22c:	390000e6 	strb	w6, [x7]
	for (; encoded_len > 0; encoded_len--) {
  40e230:	b50000a3 	cbnz	x3, 40e244 <value_encode_len+0xd0>
	state->elem_count++;
  40e234:	f9400881 	ldr	x1, [x4, #16]
  40e238:	91000421 	add	x1, x1, #0x1
  40e23c:	f9000881 	str	x1, [x4, #16]
	return true;
  40e240:	17ffffe0 	b	40e1c0 <value_encode_len+0x4c>
		*(state->payload_mut++) = u8_result[encoded_len - 1];
  40e244:	f9400081 	ldr	x1, [x4]
  40e248:	d1000463 	sub	x3, x3, #0x1
  40e24c:	91000425 	add	x5, x1, #0x1
  40e250:	f9000085 	str	x5, [x4]
  40e254:	38636845 	ldrb	w5, [x2, x3]
  40e258:	39000025 	strb	w5, [x1]
	for (; encoded_len > 0; encoded_len--) {
  40e25c:	17fffff5 	b	40e230 <value_encode_len+0xbc>

000000000040e260 <value_encode.part.0>:
	}
	return result_len;
}


static bool value_encode(zcbor_state_t *state, zcbor_major_type_t major_type,
  40e260:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40e264:	aa0003e5 	mov	x5, x0
  40e268:	2a0103e6 	mov	w6, w1
  40e26c:	910003fd 	mov	x29, sp
  40e270:	aa0203e4 	mov	x4, x2
  40e274:	aa0303e1 	mov	x1, x3
		const void *const input, size_t max_result_len)
{
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");

	size_t result_len = get_result_len(input, max_result_len);
  40e278:	aa0203e0 	mov	x0, x2
  40e27c:	97ffff94 	bl	40e0cc <get_result_len>
	const void *const result = get_result(input, max_result_len, result_len);

	return value_encode_len(state, major_type, result, result_len);
}
  40e280:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return value_encode_len(state, major_type, result, result_len);
  40e284:	aa0003e3 	mov	x3, x0
  40e288:	aa0403e2 	mov	x2, x4
  40e28c:	2a0603e1 	mov	w1, w6
  40e290:	aa0503e0 	mov	x0, x5
  40e294:	17ffffb8 	b	40e174 <value_encode_len>

000000000040e298 <str_encode>:
}


static bool str_encode(zcbor_state_t *state,
		const struct zcbor_string *input, zcbor_major_type_t major_type)
{
  40e298:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40e29c:	910003fd 	mov	x29, sp
  40e2a0:	a90153f3 	stp	x19, x20, [sp, #16]
  40e2a4:	aa0003f3 	mov	x19, x0
  40e2a8:	f90013f5 	str	x21, [sp, #32]
	ZCBOR_CHECK_PAYLOAD(); /* To make the size_t cast below safe. */
  40e2ac:	f9400004 	ldr	x4, [x0]
  40e2b0:	f9400c07 	ldr	x7, [x0, #24]
  40e2b4:	eb07009f 	cmp	x4, x7
  40e2b8:	54000143 	b.cc	40e2e0 <str_encode+0x48>  // b.lo, b.ul, b.last
  40e2bc:	52800015 	mov	w21, #0x0                   	// #0
  40e2c0:	aa1303e0 	mov	x0, x19
  40e2c4:	52800101 	mov	w1, #0x8                   	// #8
  40e2c8:	97ffff9f 	bl	40e144 <zcbor_error>
		 * because of bstrx_cbor_start_encode/bstrx_cbor_end_encode. */
		memmove(state->payload_mut, input->value, input->len);
	}
	state->payload += input->len;
	return true;
}
  40e2cc:	2a1503e0 	mov	w0, w21
  40e2d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e2d4:	f94013f5 	ldr	x21, [sp, #32]
  40e2d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40e2dc:	d65f03c0 	ret
  40e2e0:	aa0103f4 	mov	x20, x1
	if (input->len > (size_t)(state->payload_end - state->payload)) {
  40e2e4:	cb0400e1 	sub	x1, x7, x4
  40e2e8:	f9400680 	ldr	x0, [x20, #8]
  40e2ec:	91000408 	add	x8, x0, #0x1
  40e2f0:	eb01001f 	cmp	x0, x1
  40e2f4:	54fffe48 	b.hi	40e2bc <str_encode+0x24>  // b.pmore
	if (input->value && ((get_result_len(&input->len, sizeof(input->len))
  40e2f8:	aa1403e5 	mov	x5, x20
  40e2fc:	2a0203e6 	mov	w6, w2
  40e300:	f84084a0 	ldr	x0, [x5], #8
  40e304:	b4000100 	cbz	x0, 40e324 <str_encode+0x8c>
  40e308:	aa0503e0 	mov	x0, x5
  40e30c:	d2800101 	mov	x1, #0x8                   	// #8
  40e310:	97ffff6f 	bl	40e0cc <get_result_len>
			+ 1 + input->len + (size_t)state->payload)
  40e314:	8b000084 	add	x4, x4, x0
  40e318:	8b080084 	add	x4, x4, x8
	if (input->value && ((get_result_len(&input->len, sizeof(input->len))
  40e31c:	eb0400ff 	cmp	x7, x4
  40e320:	54fffce3 	b.cc	40e2bc <str_encode+0x24>  // b.lo, b.ul, b.last
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e324:	aa0503e2 	mov	x2, x5
  40e328:	2a0603e1 	mov	w1, w6
  40e32c:	aa1303e0 	mov	x0, x19
  40e330:	d2800103 	mov	x3, #0x8                   	// #8
  40e334:	97ffffcb 	bl	40e260 <value_encode.part.0>
	if (!value_encode(state, major_type, &input->len, sizeof(input->len))) {
  40e338:	72001c15 	ands	w21, w0, #0xff
  40e33c:	54fffc80 	b.eq	40e2cc <str_encode+0x34>  // b.none
	if (state->payload_mut != input->value) {
  40e340:	f9400260 	ldr	x0, [x19]
  40e344:	f9400281 	ldr	x1, [x20]
  40e348:	eb01001f 	cmp	x0, x1
  40e34c:	54000060 	b.eq	40e358 <str_encode+0xc0>  // b.none
  return __builtin___memmove_chk (__dest, __src, __len,
  40e350:	f9400682 	ldr	x2, [x20, #8]
  40e354:	97ffcbdf 	bl	4012d0 <memmove@plt>
	state->payload += input->len;
  40e358:	f9400260 	ldr	x0, [x19]
  40e35c:	f9400681 	ldr	x1, [x20, #8]
  40e360:	8b010000 	add	x0, x0, x1
  40e364:	f9000260 	str	x0, [x19]
	return true;
  40e368:	17ffffd9 	b	40e2cc <str_encode+0x34>

000000000040e36c <list_map_start_encode>:
}


static bool list_map_start_encode(zcbor_state_t *state, size_t max_num,
		zcbor_major_type_t major_type)
{
  40e36c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40e370:	910003fd 	mov	x29, sp
  40e374:	a90153f3 	stp	x19, x20, [sp, #16]
  40e378:	aa0003f3 	mov	x19, x0
  40e37c:	2a0203f4 	mov	w20, w2
  40e380:	f90017e1 	str	x1, [sp, #40]
#ifdef ZCBOR_CANONICAL
	if (!zcbor_new_backup(state, 0)) {
  40e384:	d2800001 	mov	x1, #0x0                   	// #0
  40e388:	97fffcb5 	bl	40d65c <zcbor_new_backup>
  40e38c:	72001c1f 	tst	w0, #0xff
  40e390:	540000a1 	b.ne	40e3a4 <list_map_start_encode+0x38>  // b.any
		ZCBOR_FAIL();
  40e394:	52800000 	mov	w0, #0x0                   	// #0
	if (!encode_header_byte(state, major_type, ZCBOR_VALUE_IS_INDEFINITE_LENGTH)) {
		ZCBOR_FAIL();
	}
#endif
	return true;
}
  40e398:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e39c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40e3a0:	d65f03c0 	ret
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e3a4:	9100a3e2 	add	x2, sp, #0x28
  40e3a8:	2a1403e1 	mov	w1, w20
  40e3ac:	aa1303e0 	mov	x0, x19
  40e3b0:	d2800103 	mov	x3, #0x8                   	// #8
  40e3b4:	97ffffab 	bl	40e260 <value_encode.part.0>
	if (!value_encode(state, major_type, &max_num, sizeof(max_num))) {
  40e3b8:	72001c00 	ands	w0, w0, #0xff
  40e3bc:	54fffec0 	b.eq	40e394 <list_map_start_encode+0x28>  // b.none
	state->elem_count--; /* Because of dummy header. */
  40e3c0:	f9400a61 	ldr	x1, [x19, #16]
  40e3c4:	d1000421 	sub	x1, x1, #0x1
  40e3c8:	f9000a61 	str	x1, [x19, #16]
	return true;
  40e3cc:	17fffff3 	b	40e398 <list_map_start_encode+0x2c>

000000000040e3d0 <list_map_end_encode>:
#endif


static bool list_map_end_encode(zcbor_state_t *state, size_t max_num,
			zcbor_major_type_t major_type)
{
  40e3d0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40e3d4:	910003fd 	mov	x29, sp
  40e3d8:	a90153f3 	stp	x19, x20, [sp, #16]
  40e3dc:	aa0003f4 	mov	x20, x0
  40e3e0:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40e3e4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e3e8:	2a0203f6 	mov	w22, w2
  40e3ec:	f9478400 	ldr	x0, [x0, #3848]
  40e3f0:	a90363f7 	stp	x23, x24, [sp, #48]
  40e3f4:	f90027e1 	str	x1, [sp, #72]
#ifdef ZCBOR_CANONICAL
	size_t list_count = ((major_type == ZCBOR_MAJOR_TYPE_LIST) ?
					state->elem_count
					: (state->elem_count / 2));
  40e3f8:	f9400a84 	ldr	x4, [x20, #16]
{
  40e3fc:	f9400001 	ldr	x1, [x0]
  40e400:	f9002fe1 	str	x1, [sp, #88]
  40e404:	d2800001 	mov	x1, #0x0                   	// #0
					: (state->elem_count / 2));
  40e408:	7100105f 	cmp	w2, #0x4
  40e40c:	54000040 	b.eq	40e414 <list_map_end_encode+0x44>  // b.none
  40e410:	d341fc84 	lsr	x4, x4, #1
	size_t result_len = get_result_len(input, max_result_len);
  40e414:	910123e0 	add	x0, sp, #0x48
  40e418:	d2800081 	mov	x1, #0x4                   	// #4
	size_t list_count = ((major_type == ZCBOR_MAJOR_TYPE_LIST) ?
  40e41c:	f9002be4 	str	x4, [sp, #80]
	size_t result_len = get_result_len(input, max_result_len);
  40e420:	97ffff2b 	bl	40e0cc <get_result_len>
  40e424:	aa0003f3 	mov	x19, x0

	const uint8_t *payload = state->payload;
  40e428:	f9400297 	ldr	x23, [x20]
	if ((result_len == 1) && (u8_result[0] <= ZCBOR_VALUE_IN_HEADER)) {
  40e42c:	f100041f 	cmp	x0, #0x1
  40e430:	54000081 	b.ne	40e440 <list_map_end_encode+0x70>  // b.any
  40e434:	394123e0 	ldrb	w0, [sp, #72]
  40e438:	71005c1f 	cmp	w0, #0x17
  40e43c:	9a9f97f3 	cset	x19, hi  // hi = pmore
	size_t result_len = get_result_len(input, max_result_len);
  40e440:	910143f8 	add	x24, sp, #0x50
  40e444:	d2800081 	mov	x1, #0x4                   	// #4
  40e448:	aa1803e0 	mov	x0, x24
  40e44c:	97ffff20 	bl	40e0cc <get_result_len>
  40e450:	aa0003f5 	mov	x21, x0
	if ((result_len == 1) && (u8_result[0] <= ZCBOR_VALUE_IN_HEADER)) {
  40e454:	f100041f 	cmp	x0, #0x1
  40e458:	54000081 	b.ne	40e468 <list_map_end_encode+0x98>  // b.any
  40e45c:	12001c84 	and	w4, w4, #0xff
  40e460:	71005c9f 	cmp	w4, #0x17
  40e464:	9a9f97f5 	cset	x21, hi  // hi = pmore

	size_t max_header_len = get_encoded_len2(&max_num, 4);
	size_t header_len = get_encoded_len2(&list_count, 4);

	if (!zcbor_process_backup(state, ZCBOR_FLAG_RESTORE | ZCBOR_FLAG_CONSUME, 0xFFFFFFFF)) {
  40e468:	aa1403e0 	mov	x0, x20
  40e46c:	b2407fe2 	mov	x2, #0xffffffff            	// #4294967295
  40e470:	52800061 	mov	w1, #0x3                   	// #3
  40e474:	97fffc9c 	bl	40d6e4 <zcbor_process_backup>
  40e478:	72001c1f 	tst	w0, #0xff
  40e47c:	54000141 	b.ne	40e4a4 <list_map_end_encode+0xd4>  // b.any
	/** If max_num is smaller than the actual number of encoded elements,
	  * the value_encode() below will corrupt the data if the encoded
	  * header is larger than the previously encoded header. */
	if (header_len > max_header_len) {
		zcbor_print("max_num too small.\r\n");
		ZCBOR_ERR(ZCBOR_ERR_HIGH_ELEM_COUNT);
  40e480:	52800016 	mov	w22, #0x0                   	// #0
	if (!encode_header_byte(state, ZCBOR_MAJOR_TYPE_SIMPLE, ZCBOR_VALUE_IS_INDEFINITE_LENGTH)) {
		ZCBOR_FAIL();
	}
#endif
	return true;
}
  40e484:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40e488:	f9478400 	ldr	x0, [x0, #3848]
  40e48c:	f9402fe2 	ldr	x2, [sp, #88]
  40e490:	f9400001 	ldr	x1, [x0]
  40e494:	eb010042 	subs	x2, x2, x1
  40e498:	d2800001 	mov	x1, #0x0                   	// #0
  40e49c:	540003a0 	b.eq	40e510 <list_map_end_encode+0x140>  // b.none
  40e4a0:	97ffcc04 	bl	4014b0 <__stack_chk_fail@plt>
	if (header_len > max_header_len) {
  40e4a4:	eb15027f 	cmp	x19, x21
  40e4a8:	540000a2 	b.cs	40e4bc <list_map_end_encode+0xec>  // b.hs, b.nlast
		ZCBOR_ERR(ZCBOR_ERR_HIGH_ELEM_COUNT);
  40e4ac:	aa1403e0 	mov	x0, x20
  40e4b0:	52800081 	mov	w1, #0x4                   	// #4
  40e4b4:	97ffff24 	bl	40e144 <zcbor_error>
  40e4b8:	17fffff2 	b	40e480 <list_map_end_encode+0xb0>
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e4bc:	2a1603e1 	mov	w1, w22
  40e4c0:	aa1803e2 	mov	x2, x24
  40e4c4:	aa1403e0 	mov	x0, x20
  40e4c8:	d2800103 	mov	x3, #0x8                   	// #8
  40e4cc:	97ffff65 	bl	40e260 <value_encode.part.0>
	if (!(value_encode(state, major_type, &list_count, sizeof(list_count)))) {
  40e4d0:	72001c16 	ands	w22, w0, #0xff
  40e4d4:	54fffd60 	b.eq	40e480 <list_map_end_encode+0xb0>  // b.none
	if (max_header_len != header_len) {
  40e4d8:	eb15027f 	cmp	x19, x21
  40e4dc:	54000160 	b.eq	40e508 <list_map_end_encode+0x138>  // b.none
		const uint8_t *start = state->payload + max_header_len - header_len;
  40e4e0:	f9400280 	ldr	x0, [x20]
  40e4e4:	cb150261 	sub	x1, x19, x21
  40e4e8:	8b010001 	add	x1, x0, x1
		size_t body_size = (size_t)payload - (size_t)start;
  40e4ec:	cb0102f7 	sub	x23, x23, x1
  40e4f0:	aa1703e2 	mov	x2, x23
  40e4f4:	97ffcb77 	bl	4012d0 <memmove@plt>
		state->payload += body_size;
  40e4f8:	f9400280 	ldr	x0, [x20]
  40e4fc:	8b170000 	add	x0, x0, x23
  40e500:	f9000280 	str	x0, [x20]
  40e504:	17ffffe0 	b	40e484 <list_map_end_encode+0xb4>
		state->payload = payload;
  40e508:	f9000297 	str	x23, [x20]
  40e50c:	17ffffde 	b	40e484 <list_map_end_encode+0xb4>
}
  40e510:	2a1603e0 	mov	w0, w22
  40e514:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e518:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e51c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e520:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40e524:	d65f03c0 	ret

000000000040e528 <zcbor_int_encode>:
{
  40e528:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e52c:	aa0103e4 	mov	x4, x1
  40e530:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40e534:	910003fd 	mov	x29, sp
  40e538:	f9478421 	ldr	x1, [x1, #3848]
  40e53c:	aa0203e3 	mov	x3, x2
  40e540:	f9400022 	ldr	x2, [x1]
  40e544:	f9000fe2 	str	x2, [sp, #24]
  40e548:	d2800002 	mov	x2, #0x0                   	// #0
	if (int_size > sizeof(int64_t)) {
  40e54c:	f100207f 	cmp	x3, #0x8
  40e550:	54000189 	b.ls	40e580 <zcbor_int_encode+0x58>  // b.plast
		ZCBOR_ERR(ZCBOR_ERR_INT_SIZE);
  40e554:	528000a1 	mov	w1, #0x5                   	// #5
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e558:	97fffefb 	bl	40e144 <zcbor_error>
		ZCBOR_FAIL();
  40e55c:	52800000 	mov	w0, #0x0                   	// #0
}
  40e560:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40e564:	f9478421 	ldr	x1, [x1, #3848]
  40e568:	f9400fe3 	ldr	x3, [sp, #24]
  40e56c:	f9400022 	ldr	x2, [x1]
  40e570:	eb020063 	subs	x3, x3, x2
  40e574:	d2800002 	mov	x2, #0x0                   	// #0
  40e578:	54000380 	b.eq	40e5e8 <zcbor_int_encode+0xc0>  // b.none
  40e57c:	97ffcbcd 	bl	4014b0 <__stack_chk_fail@plt>
  40e580:	aa0003e5 	mov	x5, x0
	if (input_int8[int_size - 1] < 0) {
  40e584:	8b030080 	add	x0, x4, x3
  40e588:	38dff000 	ldursb	w0, [x0, #-1]
  40e58c:	37f801e0 	tbnz	w0, #31, 40e5c8 <zcbor_int_encode+0xa0>
		major_type = ZCBOR_MAJOR_TYPE_PINT;
  40e590:	52800001 	mov	w1, #0x0                   	// #0
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e594:	b5000203 	cbnz	x3, 40e5d4 <zcbor_int_encode+0xac>
  40e598:	aa0503e0 	mov	x0, x5
  40e59c:	528001c1 	mov	w1, #0xe                   	// #14
  40e5a0:	17ffffee 	b	40e558 <zcbor_int_encode+0x30>
			input_buf[i] = (uint8_t)~input_uint8[i];
  40e5a4:	38616880 	ldrb	w0, [x4, x1]
  40e5a8:	2a2003e0 	mvn	w0, w0
  40e5ac:	38216840 	strb	w0, [x2, x1]
		for (unsigned int i = 0; i < int_size; i++) {
  40e5b0:	91000421 	add	x1, x1, #0x1
  40e5b4:	eb01007f 	cmp	x3, x1
  40e5b8:	54ffff61 	b.ne	40e5a4 <zcbor_int_encode+0x7c>  // b.any
		input = input_buf;
  40e5bc:	aa0203e4 	mov	x4, x2
		major_type = ZCBOR_MAJOR_TYPE_NINT;
  40e5c0:	52800021 	mov	w1, #0x1                   	// #1
  40e5c4:	17fffff4 	b	40e594 <zcbor_int_encode+0x6c>
  40e5c8:	910043e2 	add	x2, sp, #0x10
  40e5cc:	d2800001 	mov	x1, #0x0                   	// #0
  40e5d0:	17fffff9 	b	40e5b4 <zcbor_int_encode+0x8c>
  40e5d4:	aa0403e2 	mov	x2, x4
  40e5d8:	aa0503e0 	mov	x0, x5
  40e5dc:	97ffff21 	bl	40e260 <value_encode.part.0>
  40e5e0:	12001c00 	and	w0, w0, #0xff
  40e5e4:	17ffffdf 	b	40e560 <zcbor_int_encode+0x38>
}
  40e5e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e5ec:	d65f03c0 	ret

000000000040e5f0 <zcbor_uint_encode>:
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e5f0:	b40000a2 	cbz	x2, 40e604 <zcbor_uint_encode+0x14>
  40e5f4:	aa0203e3 	mov	x3, x2
  40e5f8:	aa0103e2 	mov	x2, x1
  40e5fc:	52800001 	mov	w1, #0x0                   	// #0
  40e600:	17ffff18 	b	40e260 <value_encode.part.0>
{
  40e604:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e608:	528001c1 	mov	w1, #0xe                   	// #14
{
  40e60c:	910003fd 	mov	x29, sp
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e610:	97fffecd 	bl	40e144 <zcbor_error>
}
  40e614:	52800000 	mov	w0, #0x0                   	// #0
  40e618:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40e61c:	d65f03c0 	ret

000000000040e620 <zcbor_int32_put>:
{
  40e620:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return zcbor_int_encode(state, &input, sizeof(input));
  40e624:	d2800082 	mov	x2, #0x4                   	// #4
{
  40e628:	910003fd 	mov	x29, sp
  40e62c:	b9001fe1 	str	w1, [sp, #28]
	return zcbor_int_encode(state, &input, sizeof(input));
  40e630:	910073e1 	add	x1, sp, #0x1c
  40e634:	97ffffbd 	bl	40e528 <zcbor_int_encode>
}
  40e638:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e63c:	d65f03c0 	ret

000000000040e640 <zcbor_uint32_put>:
{
  40e640:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return zcbor_uint_encode(state, &input, sizeof(input));
  40e644:	d2800082 	mov	x2, #0x4                   	// #4
{
  40e648:	910003fd 	mov	x29, sp
  40e64c:	b9001fe1 	str	w1, [sp, #28]
	return zcbor_uint_encode(state, &input, sizeof(input));
  40e650:	910073e1 	add	x1, sp, #0x1c
  40e654:	97ffffe7 	bl	40e5f0 <zcbor_uint_encode>
}
  40e658:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e65c:	d65f03c0 	ret

000000000040e660 <zcbor_tstr_encode>:
	return str_encode(state, input, ZCBOR_MAJOR_TYPE_TSTR);
  40e660:	52800062 	mov	w2, #0x3                   	// #3
  40e664:	17ffff0d 	b	40e298 <str_encode>

000000000040e668 <zcbor_list_start_encode>:
	return list_map_start_encode(state, max_num, ZCBOR_MAJOR_TYPE_LIST);
  40e668:	52800082 	mov	w2, #0x4                   	// #4
  40e66c:	17ffff40 	b	40e36c <list_map_start_encode>

000000000040e670 <zcbor_map_start_encode>:
	return list_map_start_encode(state, max_num, ZCBOR_MAJOR_TYPE_MAP);
  40e670:	528000a2 	mov	w2, #0x5                   	// #5
  40e674:	17ffff3e 	b	40e36c <list_map_start_encode>

000000000040e678 <zcbor_list_end_encode>:


bool zcbor_list_end_encode(zcbor_state_t *state, size_t max_num)
{
	return list_map_end_encode(state, max_num, ZCBOR_MAJOR_TYPE_LIST);
  40e678:	52800082 	mov	w2, #0x4                   	// #4
  40e67c:	17ffff55 	b	40e3d0 <list_map_end_encode>

000000000040e680 <zcbor_map_end_encode>:
}


bool zcbor_map_end_encode(zcbor_state_t *state, size_t max_num)
{
	return list_map_end_encode(state, max_num, ZCBOR_MAJOR_TYPE_MAP);
  40e680:	528000a2 	mov	w2, #0x5                   	// #5
  40e684:	17ffff53 	b	40e3d0 <list_map_end_encode>

000000000040e688 <zcbor_simple_put>:
	return true;
}


bool zcbor_simple_put(zcbor_state_t *state, uint8_t input)
{
  40e688:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  40e68c:	d2800023 	mov	x3, #0x1                   	// #1
{
  40e690:	910003fd 	mov	x29, sp
  40e694:	91007fe2 	add	x2, sp, #0x1f
  40e698:	39007fe1 	strb	w1, [sp, #31]
  40e69c:	528000e1 	mov	w1, #0x7                   	// #7
  40e6a0:	97fffef0 	bl	40e260 <value_encode.part.0>
	return value_encode(state, ZCBOR_MAJOR_TYPE_SIMPLE, &input, sizeof(input));
}
  40e6a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e6a8:	d65f03c0 	ret

000000000040e6ac <zcbor_nil_put>:


bool zcbor_nil_put(zcbor_state_t *state, const void *unused)
{
	(void)unused;
	return zcbor_simple_put(state, 22);
  40e6ac:	528002c1 	mov	w1, #0x16                  	// #22
  40e6b0:	17fffff6 	b	40e688 <zcbor_simple_put>

000000000040e6b4 <zcbor_bool_put>:
	return zcbor_bool_put(state, *input);
}


bool zcbor_bool_put(zcbor_state_t *state, bool input)
{
  40e6b4:	12001c21 	and	w1, w1, #0xff
	return zcbor_simple_put(state, (!!input + ZCBOR_BOOL_TO_SIMPLE));
  40e6b8:	11005021 	add	w1, w1, #0x14
  40e6bc:	17fffff3 	b	40e688 <zcbor_simple_put>

000000000040e6c0 <zcbor_float32_encode>:
}


bool zcbor_float32_encode(zcbor_state_t *state, const float *input)
{
	if (!value_encode_len(state, ZCBOR_MAJOR_TYPE_SIMPLE, input,
  40e6c0:	aa0103e2 	mov	x2, x1
  40e6c4:	d2800083 	mov	x3, #0x4                   	// #4
  40e6c8:	528000e1 	mov	w1, #0x7                   	// #7
  40e6cc:	17fffeaa 	b	40e174 <value_encode_len>

000000000040e6d0 <zcbor_float32_put>:
	return true;
}


bool zcbor_float32_put(zcbor_state_t *state, float input)
{
  40e6d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e6d4:	910003fd 	mov	x29, sp
	return zcbor_float32_encode(state, &input);
  40e6d8:	910073e1 	add	x1, sp, #0x1c
{
  40e6dc:	bd001fe0 	str	s0, [sp, #28]
	return zcbor_float32_encode(state, &input);
  40e6e0:	97fffff8 	bl	40e6c0 <zcbor_float32_encode>
}
  40e6e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e6e8:	d65f03c0 	ret

000000000040e6ec <zcbor_new_encode_state>:


void zcbor_new_encode_state(zcbor_state_t *state_array, size_t n_states,
		uint8_t *payload, size_t payload_len, size_t elem_count)
{
	zcbor_new_state(state_array, n_states, payload, payload_len, elem_count);
  40e6ec:	17fffc29 	b	40d790 <zcbor_new_state>

000000000040e6f0 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	STRUCT_SECTION_FOREACH(device, dev) {
  40e6f0:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40e6f4:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40e6f8:	f9477800 	ldr	x0, [x0, #3824]
  40e6fc:	f947a021 	ldr	x1, [x1, #3904]
  40e700:	eb01001f 	cmp	x0, x1
  40e704:	54000349 	b.ls	40e76c <z_device_state_init+0x7c>  // b.plast
{
  40e708:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	STRUCT_SECTION_FOREACH(device, dev) {
  40e70c:	90000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40e710:	911e1821 	add	x1, x1, #0x786
{
  40e714:	910003fd 	mov	x29, sp
  40e718:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(device, dev) {
  40e71c:	90000053 	adrp	x19, 416000 <__func__.0+0x57a>
  40e720:	911d8e73 	add	x19, x19, #0x763
  40e724:	528002e3 	mov	w3, #0x17                  	// #23
  40e728:	aa1303e2 	mov	x2, x19
  40e72c:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40e730:	91353400 	add	x0, x0, #0xd4d
  40e734:	97ffdaa2 	bl	4051bc <assert_print>
  40e738:	f0000020 	adrp	x0, 415000 <__func__.2+0x30c>
  40e73c:	91023800 	add	x0, x0, #0x8e
  40e740:	97ffda9f 	bl	4051bc <assert_print>
  40e744:	aa1303e0 	mov	x0, x19
  40e748:	528002e1 	mov	w1, #0x17                  	// #23
  40e74c:	97ffdac6 	bl	405264 <assert_post_action>
  40e750:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40e754:	aa1303e1 	mov	x1, x19
  40e758:	91362c00 	add	x0, x0, #0xd8b
  40e75c:	528002e2 	mov	w2, #0x17                  	// #23
  40e760:	97ffe4b3 	bl	407a2c <posix_print_error_and_exit>
  40e764:	9100c000 	add	x0, x0, #0x30
  40e768:	17ffffe6 	b	40e700 <z_device_state_init+0x10>
  40e76c:	54ffffc3 	b.cc	40e764 <z_device_state_init+0x74>  // b.lo, b.ul, b.last
  40e770:	d65f03c0 	ret

000000000040e774 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
  40e774:	b4000100 	cbz	x0, 40e794 <z_device_is_ready+0x20>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
  40e778:	f9400c00 	ldr	x0, [x0, #24]
  40e77c:	39400401 	ldrb	w1, [x0, #1]
  40e780:	360000a1 	tbz	w1, #0, 40e794 <z_device_is_ready+0x20>
  40e784:	39400000 	ldrb	w0, [x0]
  40e788:	7100001f 	cmp	w0, #0x0
  40e78c:	1a9f17e0 	cset	w0, eq  // eq = none
}
  40e790:	d65f03c0 	ret
		return false;
  40e794:	52800000 	mov	w0, #0x0                   	// #0
  40e798:	17fffffe 	b	40e790 <z_device_is_ready+0x1c>

000000000040e79c <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40e79c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40e7a0:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40e7a4:	910003fd 	mov	x29, sp
  40e7a8:	f9478400 	ldr	x0, [x0, #3848]
  40e7ac:	3d8023e0 	str	q0, [sp, #128]
  40e7b0:	3d8027e1 	str	q1, [sp, #144]
  40e7b4:	3d802be2 	str	q2, [sp, #160]
  40e7b8:	3d802fe3 	str	q3, [sp, #176]
  40e7bc:	3d8033e4 	str	q4, [sp, #192]
  40e7c0:	3d8037e5 	str	q5, [sp, #208]
  40e7c4:	3d803be6 	str	q6, [sp, #224]
  40e7c8:	3d803fe7 	str	q7, [sp, #240]
  40e7cc:	f90087e7 	str	x7, [sp, #264]
  40e7d0:	f9400002 	ldr	x2, [x0]
  40e7d4:	f9003fe2 	str	x2, [sp, #120]
  40e7d8:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40e7dc:	910443e0 	add	x0, sp, #0x110
  40e7e0:	a90383e0 	stp	x0, x0, [sp, #56]
  40e7e4:	910403e0 	add	x0, sp, #0x100
  40e7e8:	9100e3e2 	add	x2, sp, #0x38
  40e7ec:	f90027e0 	str	x0, [sp, #72]
  40e7f0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40e7f4:	b90053e0 	str	w0, [sp, #80]
  40e7f8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40e7fc:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40e800:	910163e0 	add	x0, sp, #0x58
  40e804:	ad400440 	ldp	q0, q1, [x2]
  40e808:	ad000400 	stp	q0, q1, [x0]
  40e80c:	ad400400 	ldp	q0, q1, [x0]
  40e810:	910043e7 	add	x7, sp, #0x10
  40e814:	52800022 	mov	w2, #0x1                   	// #1
  40e818:	52800000 	mov	w0, #0x0                   	// #0
  40e81c:	52800005 	mov	w5, #0x0                   	// #0
  40e820:	d2800004 	mov	x4, #0x0                   	// #0
  40e824:	d2800003 	mov	x3, #0x0                   	// #0
  40e828:	ad0004e0 	stp	q0, q1, [x7]
  40e82c:	97ffdc44 	bl	40593c <z_impl_z_log_msg_runtime_vcreate>
}
  40e830:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40e834:	f9478400 	ldr	x0, [x0, #3848]
  40e838:	f9403fe2 	ldr	x2, [sp, #120]
  40e83c:	f9400001 	ldr	x1, [x0]
  40e840:	eb010042 	subs	x2, x2, x1
  40e844:	d2800001 	mov	x1, #0x0                   	// #0
  40e848:	54000040 	b.eq	40e850 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40e84c:	97ffcb19 	bl	4014b0 <__stack_chk_fail@plt>
  40e850:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40e854:	d65f03c0 	ret

000000000040e858 <coredump>:
#else

void coredump(unsigned int reason, const z_arch_esf_t *esf,
	      struct k_thread *thread)
{
}
  40e858:	d65f03c0 	ret

000000000040e85c <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  40e85c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40e860:	910003fd 	mov	x29, sp
  40e864:	f9000bf3 	str	x19, [sp, #16]
  40e868:	2a0003f3 	mov	w19, w0
  40e86c:	97ffdb45 	bl	405580 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
  40e870:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40e874:	90000046 	adrp	x6, 416000 <__func__.0+0x57a>
  40e878:	911e78c6 	add	x6, x6, #0x79e
  40e87c:	52800005 	mov	w5, #0x0                   	// #0
  40e880:	f9471421 	ldr	x1, [x1, #3624]
  40e884:	d2800004 	mov	x4, #0x0                   	// #0
  40e888:	d2800003 	mov	x3, #0x0                   	// #0
  40e88c:	52800022 	mov	w2, #0x1                   	// #1
  40e890:	52800000 	mov	w0, #0x0                   	// #0
  40e894:	97ffffc2 	bl	40e79c <z_log_msg_runtime_create.constprop.0>
	arch_system_halt(reason);
  40e898:	2a1303e0 	mov	w0, w19
  40e89c:	97ffdec1 	bl	4063a0 <arch_system_halt>

000000000040e8a0 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  40e8a0:	d10143ff 	sub	sp, sp, #0x50
  40e8a4:	a9017bfd 	stp	x29, x30, [sp, #16]
  40e8a8:	910043fd 	add	x29, sp, #0x10
  40e8ac:	a90253f3 	stp	x19, x20, [sp, #32]
  40e8b0:	2a0003f3 	mov	w19, w0
  40e8b4:	aa0103f4 	mov	x20, x1
  40e8b8:	a9035bf5 	stp	x21, x22, [sp, #48]
  40e8bc:	f90023f7 	str	x23, [sp, #64]
	return posix_irq_lock();
  40e8c0:	97ffe345 	bl	4075d4 <posix_irq_lock>
  40e8c4:	2a0003f5 	mov	w21, w0
	return z_impl_z_current_get();
  40e8c8:	94001225 	bl	41315c <z_impl_z_current_get>
  40e8cc:	aa0003f6 	mov	x22, x0
	switch (reason) {
  40e8d0:	7100127f 	cmp	w19, #0x4
  40e8d4:	54000848 	b.hi	40e9dc <z_fatal_error+0x13c>  // b.pmore
  40e8d8:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40e8dc:	91223000 	add	x0, x0, #0x88c
  40e8e0:	38734800 	ldrb	w0, [x0, w19, uxtw]
  40e8e4:	10000061 	adr	x1, 40e8f0 <z_fatal_error+0x50>
  40e8e8:	8b208820 	add	x0, x1, w0, sxtb #2
  40e8ec:	d61f0000 	br	x0
		return "Unhandled interrupt";
  40e8f0:	90000043 	adrp	x3, 416000 <__func__.0+0x57a>
  40e8f4:	911eec63 	add	x3, x3, #0x7bb
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  40e8f8:	d00000f7 	adrp	x23, 42c000 <__FRAME_END__+0xfbbc>
  40e8fc:	f90003e3 	str	x3, [sp]
  40e900:	b9000bff 	str	wzr, [sp, #8]
  40e904:	90000046 	adrp	x6, 416000 <__func__.0+0x57a>
  40e908:	f94716e1 	ldr	x1, [x23, #3624]
  40e90c:	2a1303e7 	mov	w7, w19
  40e910:	912034c6 	add	x6, x6, #0x80d
  40e914:	52800005 	mov	w5, #0x0                   	// #0
  40e918:	d2800004 	mov	x4, #0x0                   	// #0
  40e91c:	52800022 	mov	w2, #0x1                   	// #1
  40e920:	52800000 	mov	w0, #0x0                   	// #0
  40e924:	d2800003 	mov	x3, #0x0                   	// #0
  40e928:	97ffff9d 	bl	40e79c <z_log_msg_runtime_create.constprop.0>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
  40e92c:	b40000d6 	cbz	x22, 40e944 <z_fatal_error+0xa4>
  40e930:	aa1603e0 	mov	x0, x22
  40e934:	94000229 	bl	40f1d8 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
  40e938:	b4000060 	cbz	x0, 40e944 <z_fatal_error+0xa4>
  40e93c:	39400001 	ldrb	w1, [x0]
  40e940:	35000061 	cbnz	w1, 40e94c <z_fatal_error+0xac>
		thread_name = "unknown";
  40e944:	90000043 	adrp	x3, 416000 <__func__.0+0x57a>
  40e948:	91201460 	add	x0, x3, #0x805
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  40e94c:	f94716e1 	ldr	x1, [x23, #3624]
  40e950:	aa1603e7 	mov	x7, x22
  40e954:	90000046 	adrp	x6, 416000 <__func__.0+0x57a>
  40e958:	9120d4c6 	add	x6, x6, #0x835
  40e95c:	f90003e0 	str	x0, [sp]
  40e960:	52800005 	mov	w5, #0x0                   	// #0
  40e964:	d2800004 	mov	x4, #0x0                   	// #0
  40e968:	d2800003 	mov	x3, #0x0                   	// #0
  40e96c:	52800022 	mov	w2, #0x1                   	// #1
  40e970:	52800000 	mov	w0, #0x0                   	// #0
  40e974:	97ffff8a 	bl	40e79c <z_log_msg_runtime_create.constprop.0>
		thread_name_get(thread));

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
  40e978:	aa1603e2 	mov	x2, x22
  40e97c:	aa1403e1 	mov	x1, x20
  40e980:	2a1303e0 	mov	w0, w19
  40e984:	97ffffb5 	bl	40e858 <coredump>
#endif

	k_sys_fatal_error_handler(reason, esf);
  40e988:	aa1403e1 	mov	x1, x20
  40e98c:	2a1303e0 	mov	w0, w19
  40e990:	97ffffb3 	bl	40e85c <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
  40e994:	2a1503e0 	mov	w0, w21
  40e998:	97ffe311 	bl	4075dc <posix_irq_unlock>
	z_impl_k_thread_abort(thread);
  40e99c:	aa1603e0 	mov	x0, x22
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
  40e9a0:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40e9a4:	a94253f3 	ldp	x19, x20, [sp, #32]
  40e9a8:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40e9ac:	f94023f7 	ldr	x23, [sp, #64]
  40e9b0:	910143ff 	add	sp, sp, #0x50
  40e9b4:	17ffdfb5 	b	406888 <z_impl_k_thread_abort>
		return "Stack overflow";
  40e9b8:	90000043 	adrp	x3, 416000 <__func__.0+0x57a>
  40e9bc:	911f3c63 	add	x3, x3, #0x7cf
  40e9c0:	17ffffce 	b	40e8f8 <z_fatal_error+0x58>
		return "Kernel oops";
  40e9c4:	90000043 	adrp	x3, 416000 <__func__.0+0x57a>
  40e9c8:	911f7863 	add	x3, x3, #0x7de
  40e9cc:	17ffffcb 	b	40e8f8 <z_fatal_error+0x58>
		return "Kernel panic";
  40e9d0:	90000043 	adrp	x3, 416000 <__func__.0+0x57a>
  40e9d4:	911fa863 	add	x3, x3, #0x7ea
  40e9d8:	17ffffc8 	b	40e8f8 <z_fatal_error+0x58>
		return "Unknown error";
  40e9dc:	90000043 	adrp	x3, 416000 <__func__.0+0x57a>
  40e9e0:	911fdc63 	add	x3, x3, #0x7f7
  40e9e4:	17ffffc5 	b	40e8f8 <z_fatal_error+0x58>
	switch (reason) {
  40e9e8:	90000043 	adrp	x3, 416000 <__func__.0+0x57a>
  40e9ec:	911eb463 	add	x3, x3, #0x7ad
  40e9f0:	17ffffc2 	b	40e8f8 <z_fatal_error+0x58>

000000000040e9f4 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
  40e9f4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40e9f8:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40e9fc:	91272021 	add	x1, x1, #0x9c8
{
  40ea00:	910003fd 	mov	x29, sp
  40ea04:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40ea08:	f8605833 	ldr	x19, [x1, w0, uxtw #3]
  40ea0c:	11000400 	add	w0, w0, #0x1
{
  40ea10:	a9025bf5 	stp	x21, x22, [sp, #32]
						rc = -rc;
					}
					if (rc > UINT8_MAX) {
						rc = UINT8_MAX;
					}
					dev->state->init_res = rc;
  40ea14:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40ea18:	f8607835 	ldr	x21, [x1, x0, lsl #3]
  40ea1c:	eb1302bf 	cmp	x21, x19
  40ea20:	540000a8 	b.hi	40ea34 <z_sys_init_run_level+0x40>  // b.pmore
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
  40ea24:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ea28:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ea2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40ea30:	d65f03c0 	ret
		const struct device *dev = entry->dev;
  40ea34:	a9405261 	ldp	x1, x20, [x19]
		if (dev != NULL) {
  40ea38:	b4000234 	cbz	x20, 40ea7c <z_sys_init_run_level+0x88>
			if (entry->init_fn.dev != NULL) {
  40ea3c:	b4000141 	cbz	x1, 40ea64 <z_sys_init_run_level+0x70>
				rc = entry->init_fn.dev(dev);
  40ea40:	aa1403e0 	mov	x0, x20
  40ea44:	d63f0020 	blr	x1
				if (rc != 0) {
  40ea48:	7100001f 	cmp	w0, #0x0
  40ea4c:	340000c0 	cbz	w0, 40ea64 <z_sys_init_run_level+0x70>
					dev->state->init_res = rc;
  40ea50:	f9400e81 	ldr	x1, [x20, #24]
  40ea54:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
  40ea58:	7103fc1f 	cmp	w0, #0xff
  40ea5c:	1a96d000 	csel	w0, w0, w22, le
  40ea60:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
  40ea64:	f9400e81 	ldr	x1, [x20, #24]
  40ea68:	39400420 	ldrb	w0, [x1, #1]
  40ea6c:	32000000 	orr	w0, w0, #0x1
  40ea70:	39000420 	strb	w0, [x1, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  40ea74:	91004273 	add	x19, x19, #0x10
  40ea78:	17ffffe9 	b	40ea1c <z_sys_init_run_level+0x28>
			(void)entry->init_fn.sys();
  40ea7c:	d63f0020 	blr	x1
  40ea80:	17fffffd 	b	40ea74 <z_sys_init_run_level+0x80>

000000000040ea84 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
  40ea84:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
  40ea88:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40ea8c:	52800021 	mov	w1, #0x1                   	// #1
{
  40ea90:	910003fd 	mov	x29, sp
	z_sys_post_kernel = true;
  40ea94:	f9470400 	ldr	x0, [x0, #3592]
  40ea98:	39000001 	strb	w1, [x0]

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
  40ea9c:	52800060 	mov	w0, #0x3                   	// #3
  40eaa0:	97ffffd5 	bl	40e9f4 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
  40eaa4:	94001705 	bl	4146b8 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
  40eaa8:	52800080 	mov	w0, #0x4                   	// #4
  40eaac:	97ffffd2 	bl	40e9f4 <z_sys_init_run_level>

	z_init_static_threads();
  40eab0:	94000260 	bl	40f430 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
  40eab4:	97ffed24 	bl	409f44 <_posix_zephyr_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  40eab8:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40eabc:	f947f000 	ldr	x0, [x0, #4064]
  40eac0:	39406001 	ldrb	w1, [x0, #24]
  40eac4:	121f7821 	and	w1, w1, #0xfffffffe
  40eac8:	39006001 	strb	w1, [x0, #24]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  40eacc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40ead0:	d65f03c0 	ret

000000000040ead4 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
  40ead4:	d10143ff 	sub	sp, sp, #0x50
	z_setup_new_thread(thread, stack,
  40ead8:	52800504 	mov	w4, #0x28                  	// #40
  40eadc:	d00000e3 	adrp	x3, 42c000 <__FRAME_END__+0xfbbc>
  40eae0:	528001e7 	mov	w7, #0xf                   	// #15
  40eae4:	d2800006 	mov	x6, #0x0                   	// #0
  40eae8:	d2800005 	mov	x5, #0x0                   	// #0
{
  40eaec:	a9017bfd 	stp	x29, x30, [sp, #16]
  40eaf0:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(thread, stack,
  40eaf4:	d2802002 	mov	x2, #0x100                 	// #256
  40eaf8:	f9476463 	ldr	x3, [x3, #3784]
{
  40eafc:	a9035bf5 	stp	x21, x22, [sp, #48]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  40eb00:	d00000f6 	adrp	x22, 42c000 <__FRAME_END__+0xfbbc>
{
  40eb04:	f90023f7 	str	x23, [sp, #64]
	struct k_thread *thread = &z_idle_threads[i];
  40eb08:	d00000f7 	adrp	x23, 42c000 <__FRAME_END__+0xfbbc>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  40eb0c:	f94742d6 	ldr	x22, [x22, #3712]
{
  40eb10:	a90253f3 	stp	x19, x20, [sp, #32]
  40eb14:	93407c13 	sxtw	x19, w0
	struct k_thread *thread = &z_idle_threads[i];
  40eb18:	f94712f7 	ldr	x23, [x23, #3616]
  40eb1c:	52801815 	mov	w21, #0xc0                  	// #192
	z_setup_new_thread(thread, stack,
  40eb20:	9b245a64 	smaddl	x4, w19, w4, x22
  40eb24:	90000040 	adrp	x0, 416000 <__func__.0+0x57a>
  40eb28:	91213400 	add	x0, x0, #0x84d
  40eb2c:	f90007e0 	str	x0, [sp, #8]
	struct k_thread *thread = &z_idle_threads[i];
  40eb30:	9b355e75 	smaddl	x21, w19, w21, x23
	z_setup_new_thread(thread, stack,
  40eb34:	52800020 	mov	w0, #0x1                   	// #1
  40eb38:	b90003e0 	str	w0, [sp]
	k_thread_stack_t *stack = z_idle_stacks[i];
  40eb3c:	93787e61 	sbfiz	x1, x19, #8, #32
	z_setup_new_thread(thread, stack,
  40eb40:	f0000100 	adrp	x0, 431000 <_k_thread_stack_thingset_can+0x768>
  40eb44:	91326000 	add	x0, x0, #0xc98
  40eb48:	8b010001 	add	x1, x0, x1
  40eb4c:	aa1503e0 	mov	x0, x21
  40eb50:	940001ac 	bl	40f200 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  40eb54:	d2801800 	mov	x0, #0xc0                  	// #192
  40eb58:	9b005e60 	madd	x0, x19, x0, x23
  40eb5c:	39406401 	ldrb	w1, [x0, #25]
  40eb60:	121d7821 	and	w1, w1, #0xfffffffb
  40eb64:	39006401 	strb	w1, [x0, #25]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40eb68:	d2800501 	mov	x1, #0x28                  	// #40
	_kernel.cpus[id].id = id;
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40eb6c:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40eb70:	9b015a61 	madd	x1, x19, x1, x22
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40eb74:	f9470c00 	ldr	x0, [x0, #3608]
	_kernel.cpus[id].id = id;
  40eb78:	39008033 	strb	w19, [x1, #32]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40eb7c:	91000673 	add	x19, x19, #0x1
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  40eb80:	f9000c35 	str	x21, [x1, #24]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  40eb84:	8b132c13 	add	x19, x0, x19, lsl #11
	_kernel.cpus[id].irq_stack =
  40eb88:	f9000433 	str	x19, [x1, #8]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  40eb8c:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40eb90:	d2800020 	mov	x0, #0x1                   	// #1
  40eb94:	f9478c21 	ldr	x1, [x1, #3864]
  40eb98:	97ffcb0e 	bl	4017d0 <__aarch64_ldadd8_acq_rel>
	/*
	 * Increment number of CPUs active. The pm subsystem
	 * will keep track of this from here.
	 */
	atomic_inc(&_cpus_active);
}
  40eb9c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40eba0:	a94253f3 	ldp	x19, x20, [sp, #32]
  40eba4:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40eba8:	f94023f7 	ldr	x23, [sp, #64]
  40ebac:	910143ff 	add	sp, sp, #0x50
  40ebb0:	d65f03c0 	ret

000000000040ebb4 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
  40ebb4:	d10403ff 	sub	sp, sp, #0x100
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  40ebb8:	52800000 	mov	w0, #0x0                   	// #0
{
  40ebbc:	a9017bfd 	stp	x29, x30, [sp, #16]
  40ebc0:	910043fd 	add	x29, sp, #0x10
  40ebc4:	a90253f3 	stp	x19, x20, [sp, #32]

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
  40ebc8:	d00000f4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
	_kernel.ready_q.cache = &z_main_thread;
  40ebcc:	d00000f3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
{
  40ebd0:	f9001bf5 	str	x21, [sp, #48]
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  40ebd4:	97ffff88 	bl	40e9f4 <z_sys_init_run_level>

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
  40ebd8:	97ffda5f 	bl	405554 <log_core_init>
	dummy_thread->resource_pool = NULL;
  40ebdc:	f9007bff 	str	xzr, [sp, #240]
	_current_cpu->current = dummy_thread;
  40ebe0:	f9474294 	ldr	x20, [x20, #3712]
	dummy_thread->base.user_options = K_ESSENTIAL;
  40ebe4:	52802020 	mov	w0, #0x101                 	// #257
  40ebe8:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
  40ebec:	910103e0 	add	x0, sp, #0x40
  40ebf0:	f9000a80 	str	x0, [x20, #16]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
  40ebf4:	97fffebf 	bl	40e6f0 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
  40ebf8:	52800020 	mov	w0, #0x1                   	// #1
  40ebfc:	97ffff7e 	bl	40e9f4 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
  40ec00:	52800040 	mov	w0, #0x2                   	// #2
  40ec04:	97ffff7c 	bl	40e9f4 <z_sys_init_run_level>
	z_sched_init();
  40ec08:	94001012 	bl	412c50 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40ec0c:	d00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40ec10:	90000040 	adrp	x0, 416000 <__func__.0+0x57a>
	_kernel.ready_q.cache = &z_main_thread;
  40ec14:	f947f273 	ldr	x19, [x19, #4064]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40ec18:	91214800 	add	x0, x0, #0x852
  40ec1c:	f9479421 	ldr	x1, [x1, #3880]
	_kernel.ready_q.cache = &z_main_thread;
  40ec20:	f9001693 	str	x19, [x20, #40]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  40ec24:	f90007e0 	str	x0, [sp, #8]
  40ec28:	52800020 	mov	w0, #0x1                   	// #1
  40ec2c:	b90003e0 	str	w0, [sp]
  40ec30:	90000014 	adrp	x20, 40e000 <zcbor_bool_decode+0x10>
  40ec34:	912a1294 	add	x20, x20, #0xa84
  40ec38:	52800007 	mov	w7, #0x0                   	// #0
  40ec3c:	aa1403e3 	mov	x3, x20
  40ec40:	d2800006 	mov	x6, #0x0                   	// #0
  40ec44:	d2800005 	mov	x5, #0x0                   	// #0
  40ec48:	d2800004 	mov	x4, #0x0                   	// #0
  40ec4c:	d2804002 	mov	x2, #0x200                 	// #512
  40ec50:	aa1303e0 	mov	x0, x19
  40ec54:	9400016b 	bl	40f200 <z_setup_new_thread>
  40ec58:	aa0003f5 	mov	x21, x0
  40ec5c:	39406660 	ldrb	w0, [x19, #25]
  40ec60:	121d7800 	and	w0, w0, #0xfffffffb
  40ec64:	39006660 	strb	w0, [x19, #25]
	z_ready_thread(&z_main_thread);
  40ec68:	aa1303e0 	mov	x0, x19
  40ec6c:	94000ca3 	bl	411ef8 <z_ready_thread>
	z_init_cpu(0);
  40ec70:	52800000 	mov	w0, #0x0                   	// #0
  40ec74:	97ffff98 	bl	40ead4 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  40ec78:	aa1403e2 	mov	x2, x20
  40ec7c:	aa1503e1 	mov	x1, x21
  40ec80:	aa1303e0 	mov	x0, x19
  40ec84:	97ffdf42 	bl	40698c <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  40ec88:	90000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40ec8c:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40ec90:	91215c21 	add	x1, x1, #0x857
  40ec94:	91362c00 	add	x0, x0, #0xd8b
  40ec98:	52803a82 	mov	w2, #0x1d4                 	// #468
  40ec9c:	97ffe364 	bl	407a2c <posix_print_error_and_exit>

000000000040eca0 <k_heap_init>:
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
  40eca0:	91006004 	add	x4, x0, #0x18
	list->tail = (sys_dnode_t *)list;
  40eca4:	a9019004 	stp	x4, x4, [x0, #24]
#include <zephyr/sys/iterable_sections.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
  40eca8:	17ffd55c 	b	404218 <sys_heap_init>

000000000040ecac <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
  40ecac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40ecb0:	910003fd 	mov	x29, sp
  40ecb4:	a90153f3 	stp	x19, x20, [sp, #16]
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40ecb8:	d00000f3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  40ecbc:	d00000f4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  40ecc0:	f9475e73 	ldr	x19, [x19, #3768]
  40ecc4:	f9474694 	ldr	x20, [x20, #3720]
  40ecc8:	eb14027f 	cmp	x19, x20
  40eccc:	54000349 	b.ls	40ed34 <statics_init+0x88>  // b.plast
  40ecd0:	90000053 	adrp	x19, 416000 <__func__.0+0x57a>
  40ecd4:	9121ee73 	add	x19, x19, #0x87b
  40ecd8:	aa1303e2 	mov	x2, x19
  40ecdc:	90000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40ece0:	91227421 	add	x1, x1, #0x89d
  40ece4:	52800303 	mov	w3, #0x18                  	// #24
  40ece8:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40ecec:	91353400 	add	x0, x0, #0xd4d
  40ecf0:	97ffd933 	bl	4051bc <assert_print>
  40ecf4:	f0000020 	adrp	x0, 415000 <__func__.2+0x30c>
  40ecf8:	91023800 	add	x0, x0, #0x8e
  40ecfc:	97ffd930 	bl	4051bc <assert_print>
  40ed00:	aa1303e0 	mov	x0, x19
  40ed04:	52800301 	mov	w1, #0x18                  	// #24
  40ed08:	97ffd957 	bl	405264 <assert_post_action>
  40ed0c:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40ed10:	aa1303e1 	mov	x1, x19
  40ed14:	91362c00 	add	x0, x0, #0xd8b
  40ed18:	52800302 	mov	w2, #0x18                  	// #24
  40ed1c:	97ffe344 	bl	407a2c <posix_print_error_and_exit>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  40ed20:	a9408a61 	ldp	x1, x2, [x19, #8]
  40ed24:	aa1303e0 	mov	x0, x19
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40ed28:	9100c273 	add	x19, x19, #0x30
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  40ed2c:	97ffffdd 	bl	40eca0 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
  40ed30:	17ffffe6 	b	40ecc8 <statics_init+0x1c>
  40ed34:	54ffff63 	b.cc	40ed20 <statics_init+0x74>  // b.lo, b.ul, b.last
		}
	}
	return 0;
}
  40ed38:	52800000 	mov	w0, #0x0                   	// #0
  40ed3c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ed40:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40ed44:	d65f03c0 	ret

000000000040ed48 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
  40ed48:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ed4c:	910003fd 	mov	x29, sp
  40ed50:	a90153f3 	stp	x19, x20, [sp, #16]
  40ed54:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ed58:	aa0303f6 	mov	x22, x3
  40ed5c:	aa0003f5 	mov	x21, x0
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  40ed60:	aa0303e0 	mov	x0, x3
{
  40ed64:	a90363f7 	stp	x23, x24, [sp, #48]
  40ed68:	aa0103f7 	mov	x23, x1
  40ed6c:	aa0203f8 	mov	x24, x2
  40ed70:	a9046bf9 	stp	x25, x26, [sp, #64]
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  40ed74:	940014cf 	bl	4140b0 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  40ed78:	b10006df 	cmn	x22, #0x1
  40ed7c:	92f00001 	mov	x1, #0x7fffffffffffffff    	// #9223372036854775807

	k_spinlock_key_t key = k_spin_lock(&h->lock);
  40ed80:	9100a2b3 	add	x19, x21, #0x28
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  40ed84:	9a811019 	csel	x25, x0, x1, ne  // ne = any
	return posix_irq_lock();
  40ed88:	97ffe213 	bl	4075d4 <posix_irq_lock>
  40ed8c:	2a0003f4 	mov	w20, w0
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ed90:	aa1303e0 	mov	x0, x19
  40ed94:	94000207 	bl	40f5b0 <z_spin_lock_valid>
  40ed98:	72001c1f 	tst	w0, #0xff
  40ed9c:	54000281 	b.ne	40edec <k_heap_aligned_alloc+0xa4>  // b.any
  40eda0:	90000054 	adrp	x20, 416000 <__func__.0+0x57a>
  40eda4:	9122ce94 	add	x20, x20, #0x8b3
  40eda8:	aa1403e2 	mov	x2, x20
  40edac:	52801283 	mov	w3, #0x94                  	// #148
  40edb0:	90000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40edb4:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40edb8:	91238021 	add	x1, x1, #0x8e0
  40edbc:	91353400 	add	x0, x0, #0xd4d
  40edc0:	97ffd8ff 	bl	4051bc <assert_print>
  40edc4:	aa1303e1 	mov	x1, x19
  40edc8:	90000040 	adrp	x0, 416000 <__func__.0+0x57a>
  40edcc:	9123d400 	add	x0, x0, #0x8f5
  40edd0:	97ffd8fb 	bl	4051bc <assert_print>
  40edd4:	aa1403e0 	mov	x0, x20
  40edd8:	52801281 	mov	w1, #0x94                  	// #148
  40eddc:	97ffd922 	bl	405264 <assert_post_action>
  40ede0:	52801282 	mov	w2, #0x94                  	// #148
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40ede4:	aa1403e1 	mov	x1, x20
  40ede8:	14000019 	b	40ee4c <k_heap_aligned_alloc+0x104>
	z_spin_lock_set_owner(l);
  40edec:	aa1303e0 	mov	x0, x19
  40edf0:	94000208 	bl	40f610 <z_spin_lock_set_owner>
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
  40edf4:	d00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40edf8:	f9474000 	ldr	x0, [x0, #3712]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40edfc:	b9400000 	ldr	w0, [x0]
  40ee00:	34000860 	cbz	w0, 40ef0c <k_heap_aligned_alloc+0x1c4>
  40ee04:	b4000856 	cbz	x22, 40ef0c <k_heap_aligned_alloc+0x1c4>
  40ee08:	90000053 	adrp	x19, 416000 <__func__.0+0x57a>
  40ee0c:	9121ee73 	add	x19, x19, #0x87b
  40ee10:	aa1303e2 	mov	x2, x19
  40ee14:	90000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40ee18:	91243421 	add	x1, x1, #0x90d
  40ee1c:	52800983 	mov	w3, #0x4c                  	// #76
  40ee20:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40ee24:	91353400 	add	x0, x0, #0xd4d
  40ee28:	97ffd8e5 	bl	4051bc <assert_print>
  40ee2c:	90000040 	adrp	x0, 416000 <__func__.0+0x57a>
  40ee30:	91254c00 	add	x0, x0, #0x953
  40ee34:	97ffd8e2 	bl	4051bc <assert_print>
  40ee38:	52800981 	mov	w1, #0x4c                  	// #76
  40ee3c:	aa1303e0 	mov	x0, x19
  40ee40:	97ffd909 	bl	405264 <assert_post_action>
  40ee44:	aa1303e1 	mov	x1, x19
  40ee48:	52800982 	mov	w2, #0x4c                  	// #76
  40ee4c:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40ee50:	91362c00 	add	x0, x0, #0xd8b
  40ee54:	97ffe2f6 	bl	407a2c <posix_print_error_and_exit>
	while (ret == NULL) {
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);

		now = sys_clock_tick_get();
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
		    (ret != NULL) || ((end - now) <= 0)) {
  40ee58:	cb030323 	sub	x3, x25, x3
  40ee5c:	f100007f 	cmp	x3, #0x0
  40ee60:	540002ad 	b.le	40eeb4 <k_heap_aligned_alloc+0x16c>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  40ee64:	2a1403e1 	mov	w1, w20
  40ee68:	aa1a03e2 	mov	x2, x26
  40ee6c:	aa1303e0 	mov	x0, x19
  40ee70:	94000d6b 	bl	41241c <z_pend_curr>
  40ee74:	97ffe1d8 	bl	4075d4 <posix_irq_lock>
  40ee78:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ee7c:	aa1303e0 	mov	x0, x19
  40ee80:	940001cc 	bl	40f5b0 <z_spin_lock_valid>
  40ee84:	72001c1f 	tst	w0, #0xff
  40ee88:	54fff8c0 	b.eq	40eda0 <k_heap_aligned_alloc+0x58>  // b.none
	z_spin_lock_set_owner(l);
  40ee8c:	aa1303e0 	mov	x0, x19
  40ee90:	940001e0 	bl	40f610 <z_spin_lock_set_owner>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
  40ee94:	aa1803e2 	mov	x2, x24
  40ee98:	aa1703e1 	mov	x1, x23
  40ee9c:	aa1503e0 	mov	x0, x21
  40eea0:	97ffd475 	bl	404074 <sys_heap_aligned_alloc>
  40eea4:	aa0003f6 	mov	x22, x0
		now = sys_clock_tick_get();
  40eea8:	94001438 	bl	413f88 <sys_clock_tick_get>
  40eeac:	aa0003e3 	mov	x3, x0
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
  40eeb0:	b4fffd56 	cbz	x22, 40ee58 <k_heap_aligned_alloc+0x110>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40eeb4:	aa1303e0 	mov	x0, x19
  40eeb8:	940001c9 	bl	40f5dc <z_spin_unlock_valid>
  40eebc:	72001c1f 	tst	w0, #0xff
  40eec0:	540002a1 	b.ne	40ef14 <k_heap_aligned_alloc+0x1cc>  // b.any
  40eec4:	90000054 	adrp	x20, 416000 <__func__.0+0x57a>
  40eec8:	9122ce94 	add	x20, x20, #0x8b3
  40eecc:	aa1403e2 	mov	x2, x20
  40eed0:	52801863 	mov	w3, #0xc3                  	// #195
  40eed4:	90000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40eed8:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40eedc:	91255821 	add	x1, x1, #0x956
  40eee0:	91353400 	add	x0, x0, #0xd4d
  40eee4:	97ffd8b6 	bl	4051bc <assert_print>
  40eee8:	aa1303e1 	mov	x1, x19
  40eeec:	90000040 	adrp	x0, 416000 <__func__.0+0x57a>
  40eef0:	9125b400 	add	x0, x0, #0x96d
  40eef4:	97ffd8b2 	bl	4051bc <assert_print>
  40eef8:	aa1403e0 	mov	x0, x20
  40eefc:	52801861 	mov	w1, #0xc3                  	// #195
  40ef00:	97ffd8d9 	bl	405264 <assert_post_action>
  40ef04:	52801862 	mov	w2, #0xc3                  	// #195
  40ef08:	17ffffb7 	b	40ede4 <k_heap_aligned_alloc+0x9c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  40ef0c:	910062ba 	add	x26, x21, #0x18
  40ef10:	17ffffe1 	b	40ee94 <k_heap_aligned_alloc+0x14c>
	posix_irq_unlock(key);
  40ef14:	2a1403e0 	mov	w0, w20
  40ef18:	97ffe1b1 	bl	4075dc <posix_irq_unlock>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
  40ef1c:	aa1603e0 	mov	x0, x22
  40ef20:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ef24:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ef28:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ef2c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40ef30:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40ef34:	d65f03c0 	ret

000000000040ef38 <create_free_list>:
{
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  40ef38:	a9420402 	ldp	x2, x1, [x0, #32]
  40ef3c:	aa020022 	orr	x2, x1, x2
  40ef40:	f240085f 	tst	x2, #0x7
  40ef44:	540001e1 	b.ne	40ef80 <create_free_list+0x48>  // b.any
	}

	slab->free_list = NULL;
	p = slab->buffer;

	for (j = 0U; j < slab->num_blocks; j++) {
  40ef48:	52800002 	mov	w2, #0x0                   	// #0
	slab->free_list = NULL;
  40ef4c:	f900181f 	str	xzr, [x0, #48]
	for (j = 0U; j < slab->num_blocks; j++) {
  40ef50:	b9401803 	ldr	w3, [x0, #24]
  40ef54:	6b02007f 	cmp	w3, w2
  40ef58:	54000068 	b.hi	40ef64 <create_free_list+0x2c>  // b.pmore
		*(char **)p = slab->free_list;
		slab->free_list = p;
		p += slab->block_size;
	}
	return 0;
  40ef5c:	52800000 	mov	w0, #0x0                   	// #0
}
  40ef60:	d65f03c0 	ret
		*(char **)p = slab->free_list;
  40ef64:	f9401803 	ldr	x3, [x0, #48]
  40ef68:	f9000023 	str	x3, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
  40ef6c:	11000442 	add	w2, w2, #0x1
		slab->free_list = p;
  40ef70:	f9001801 	str	x1, [x0, #48]
		p += slab->block_size;
  40ef74:	f9401003 	ldr	x3, [x0, #32]
  40ef78:	8b030021 	add	x1, x1, x3
	for (j = 0U; j < slab->num_blocks; j++) {
  40ef7c:	17fffff5 	b	40ef50 <create_free_list+0x18>
		return -EINVAL;
  40ef80:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40ef84:	17fffff7 	b	40ef60 <create_free_list+0x28>

000000000040ef88 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
  40ef88:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int rc = 0;

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40ef8c:	d00000e4 	adrp	x4, 42c000 <__FRAME_END__+0xfbbc>
  40ef90:	d00000e5 	adrp	x5, 42c000 <__FRAME_END__+0xfbbc>
{
  40ef94:	910003fd 	mov	x29, sp
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40ef98:	f947ec84 	ldr	x4, [x4, #4056]
	int rc = 0;
  40ef9c:	52800000 	mov	w0, #0x0                   	// #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40efa0:	f94708a5 	ldr	x5, [x5, #3600]
{
  40efa4:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40efa8:	eb05009f 	cmp	x4, x5
  40efac:	54000349 	b.ls	40f014 <init_mem_slab_module+0x8c>  // b.plast
  40efb0:	90000053 	adrp	x19, 416000 <__func__.0+0x57a>
  40efb4:	91260a73 	add	x19, x19, #0x982
  40efb8:	aa1303e2 	mov	x2, x19
  40efbc:	90000041 	adrp	x1, 416000 <__func__.0+0x57a>
  40efc0:	91269c21 	add	x1, x1, #0x9a7
  40efc4:	528007a3 	mov	w3, #0x3d                  	// #61
  40efc8:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40efcc:	91353400 	add	x0, x0, #0xd4d
  40efd0:	97ffd87b 	bl	4051bc <assert_print>
  40efd4:	f0000020 	adrp	x0, 415000 <__func__.2+0x30c>
  40efd8:	91023800 	add	x0, x0, #0x8e
  40efdc:	97ffd878 	bl	4051bc <assert_print>
  40efe0:	aa1303e0 	mov	x0, x19
  40efe4:	528007a1 	mov	w1, #0x3d                  	// #61
  40efe8:	97ffd89f 	bl	405264 <assert_post_action>
  40efec:	d0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40eff0:	aa1303e1 	mov	x1, x19
  40eff4:	91362c00 	add	x0, x0, #0xd8b
  40eff8:	528007a2 	mov	w2, #0x3d                  	// #61
  40effc:	97ffe28c 	bl	407a2c <posix_print_error_and_exit>
		rc = create_free_list(slab);
  40f000:	aa0403e0 	mov	x0, x4
  40f004:	97ffffcd 	bl	40ef38 <create_free_list>
		if (rc < 0) {
  40f008:	37f80080 	tbnz	w0, #31, 40f018 <init_mem_slab_module+0x90>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  40f00c:	91010084 	add	x4, x4, #0x40
  40f010:	17ffffe6 	b	40efa8 <init_mem_slab_module+0x20>
  40f014:	54ffff63 	b.cc	40f000 <init_mem_slab_module+0x78>  // b.lo, b.ul, b.last
		z_object_init(slab);
	}

out:
	return rc;
}
  40f018:	f9400bf3 	ldr	x19, [sp, #16]
  40f01c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f020:	d65f03c0 	ret

000000000040f024 <k_mem_slab_free>:

	return result;
}

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
  40f024:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40f028:	910003fd 	mov	x29, sp
  40f02c:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  40f030:	91004014 	add	x20, x0, #0x10
{
  40f034:	aa0003f3 	mov	x19, x0
  40f038:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f03c:	aa0103f5 	mov	x21, x1
	return posix_irq_lock();
  40f040:	97ffe165 	bl	4075d4 <posix_irq_lock>
  40f044:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f048:	aa1403e0 	mov	x0, x20
  40f04c:	94000159 	bl	40f5b0 <z_spin_lock_valid>
  40f050:	72001c1f 	tst	w0, #0xff
  40f054:	540002c1 	b.ne	40f0ac <k_mem_slab_free+0x88>  // b.any
  40f058:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f05c:	9122ce73 	add	x19, x19, #0x8b3
  40f060:	aa1303e2 	mov	x2, x19
  40f064:	52801283 	mov	w3, #0x94                  	// #148
  40f068:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f06c:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f070:	91238021 	add	x1, x1, #0x8e0
  40f074:	91353400 	add	x0, x0, #0xd4d
  40f078:	97ffd851 	bl	4051bc <assert_print>
  40f07c:	aa1403e1 	mov	x1, x20
  40f080:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40f084:	9123d400 	add	x0, x0, #0x8f5
  40f088:	97ffd84d 	bl	4051bc <assert_print>
  40f08c:	aa1303e0 	mov	x0, x19
  40f090:	52801281 	mov	w1, #0x94                  	// #148
  40f094:	97ffd874 	bl	405264 <assert_post_action>
  40f098:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f09c:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f0a0:	aa1303e1 	mov	x1, x19
  40f0a4:	91362c00 	add	x0, x0, #0xd8b
  40f0a8:	97ffe261 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  40f0ac:	aa1403e0 	mov	x0, x20
  40f0b0:	94000158 	bl	40f610 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
  40f0b4:	f9401a60 	ldr	x0, [x19, #48]
  40f0b8:	b50001c0 	cbnz	x0, 40f0f0 <k_mem_slab_free+0xcc>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
  40f0bc:	aa1303e0 	mov	x0, x19
  40f0c0:	94000e97 	bl	412b1c <z_unpend_first_thread>

		if (pending_thread != NULL) {
  40f0c4:	b4000160 	cbz	x0, 40f0f0 <k_mem_slab_free+0xcc>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
  40f0c8:	f94002a1 	ldr	x1, [x21]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
  40f0cc:	f9001001 	str	x1, [x0, #32]
	thread->callee_saved.retval = value;
  40f0d0:	b9004c1f 	str	wzr, [x0, #76]
			z_ready_thread(pending_thread);
  40f0d4:	94000b89 	bl	411ef8 <z_ready_thread>
			z_reschedule(&slab->lock, key);
  40f0d8:	2a1603e1 	mov	w1, w22
  40f0dc:	aa1403e0 	mov	x0, x20
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
  40f0e0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f0e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f0e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
			z_reschedule(&slab->lock, key);
  40f0ec:	14000928 	b	41158c <z_reschedule>
	**(char ***) mem = slab->free_list;
  40f0f0:	f94002a0 	ldr	x0, [x21]
  40f0f4:	f9401a61 	ldr	x1, [x19, #48]
  40f0f8:	f9000001 	str	x1, [x0]
	slab->free_list = *(char **) mem;
  40f0fc:	f94002a0 	ldr	x0, [x21]
  40f100:	f9001a60 	str	x0, [x19, #48]
	slab->num_used--;
  40f104:	b9403a60 	ldr	w0, [x19, #56]
  40f108:	51000400 	sub	w0, w0, #0x1
  40f10c:	b9003a60 	str	w0, [x19, #56]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f110:	aa1403e0 	mov	x0, x20
  40f114:	94000132 	bl	40f5dc <z_spin_unlock_valid>
  40f118:	72001c1f 	tst	w0, #0xff
  40f11c:	54000261 	b.ne	40f168 <k_mem_slab_free+0x144>  // b.any
  40f120:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f124:	9122ce73 	add	x19, x19, #0x8b3
  40f128:	aa1303e2 	mov	x2, x19
  40f12c:	52801863 	mov	w3, #0xc3                  	// #195
  40f130:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f134:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f138:	91255821 	add	x1, x1, #0x956
  40f13c:	91353400 	add	x0, x0, #0xd4d
  40f140:	97ffd81f 	bl	4051bc <assert_print>
  40f144:	aa1403e1 	mov	x1, x20
  40f148:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40f14c:	9125b400 	add	x0, x0, #0x96d
  40f150:	97ffd81b 	bl	4051bc <assert_print>
  40f154:	aa1303e0 	mov	x0, x19
  40f158:	52801861 	mov	w1, #0xc3                  	// #195
  40f15c:	97ffd842 	bl	405264 <assert_post_action>
  40f160:	52801862 	mov	w2, #0xc3                  	// #195
  40f164:	17ffffce 	b	40f09c <k_mem_slab_free+0x78>
	posix_irq_unlock(key);
  40f168:	2a1603e0 	mov	w0, w22
}
  40f16c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f170:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f174:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40f178:	17ffe119 	b	4075dc <posix_irq_unlock>

000000000040f17c <k_is_in_isr>:
	return _kernel.cpus[0].nested != 0U;
  40f17c:	b00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40f180:	f9474000 	ldr	x0, [x0, #3712]
  40f184:	b9400000 	ldr	w0, [x0]
  40f188:	7100001f 	cmp	w0, #0x0
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
  40f18c:	1a9f07e0 	cset	w0, ne  // ne = any
  40f190:	d65f03c0 	ret

000000000040f194 <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
  40f194:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40f198:	910003fd 	mov	x29, sp
  40f19c:	f9000bf3 	str	x19, [sp, #16]
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
  40f1a0:	b5000180 	cbnz	x0, 40f1d0 <z_impl_k_thread_name_set+0x3c>
		thread = _current;
  40f1a4:	b00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40f1a8:	f9474000 	ldr	x0, [x0, #3712]
  40f1ac:	f9400813 	ldr	x19, [x0, #16]
  return __builtin___strncpy_chk (__dest, __src, __len,
  40f1b0:	91022660 	add	x0, x19, #0x89
  40f1b4:	d28003e2 	mov	x2, #0x1f                  	// #31
  40f1b8:	97ffc90a 	bl	4015e0 <strncpy@plt>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  40f1bc:	3902a27f 	strb	wzr, [x19, #168]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
  40f1c0:	52800000 	mov	w0, #0x0                   	// #0
  40f1c4:	f9400bf3 	ldr	x19, [sp, #16]
  40f1c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f1cc:	d65f03c0 	ret
  40f1d0:	aa0003f3 	mov	x19, x0
  40f1d4:	17fffff7 	b	40f1b0 <z_impl_k_thread_name_set+0x1c>

000000000040f1d8 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
  40f1d8:	91022400 	add	x0, x0, #0x89
  40f1dc:	d65f03c0 	ret

000000000040f1e0 <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
  40f1e0:	14000b87 	b	411ffc <z_sched_start>

000000000040f1e4 <z_init_thread_base>:

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
  40f1e4:	f900081f 	str	xzr, [x0, #16]
	thread_base->user_options = (uint8_t)options;
  40f1e8:	39006003 	strb	w3, [x0, #24]
	thread_base->thread_state = (uint8_t)initial_state;
  40f1ec:	39006402 	strb	w2, [x0, #25]

	thread_base->prio = priority;
  40f1f0:	39006801 	strb	w1, [x0, #26]

	thread_base->sched_locked = 0U;
  40f1f4:	39006c1f 	strb	wzr, [x0, #27]
	node->prev = NULL;
  40f1f8:	a902fc1f 	stp	xzr, xzr, [x0, #40]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
  40f1fc:	d65f03c0 	ret

000000000040f200 <z_setup_new_thread>:
{
  40f200:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40f204:	910003fd 	mov	x29, sp
  40f208:	a90153f3 	stp	x19, x20, [sp, #16]
  40f20c:	aa0003f3 	mov	x19, x0
  40f210:	aa0203f4 	mov	x20, x2
  40f214:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f218:	aa0103f6 	mov	x22, x1
  40f21c:	2a0703f5 	mov	w21, w7
  40f220:	a90363f7 	stp	x23, x24, [sp, #48]
  40f224:	aa0303f7 	mov	x23, x3
  40f228:	aa0403f8 	mov	x24, x4
  40f22c:	a9046bf9 	stp	x25, x26, [sp, #64]
  40f230:	aa0503fa 	mov	x26, x5
  40f234:	f9002bfb 	str	x27, [sp, #80]
  40f238:	aa0603fb 	mov	x27, x6
  40f23c:	f94037f9 	ldr	x25, [sp, #104]
	Z_ASSERT_VALID_PRIO(prio, entry);
  40f240:	71003cff 	cmp	w7, #0xf
  40f244:	540005a1 	b.ne	40f2f8 <z_setup_new_thread+0xf8>  // b.any
  40f248:	b00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40f24c:	f9476400 	ldr	x0, [x0, #3784]
  40f250:	eb00007f 	cmp	x3, x0
  40f254:	54000581 	b.ne	40f304 <z_setup_new_thread+0x104>  // b.any
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40f258:	b94063e3 	ldr	w3, [sp, #96]
  40f25c:	91018260 	add	x0, x19, #0x60
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  40f260:	91001e94 	add	x20, x20, #0x7
	list->tail = (sys_dnode_t *)list;
  40f264:	a9060260 	stp	x0, x0, [x19, #96]
  40f268:	927df294 	and	x20, x20, #0xfffffffffffffff8
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40f26c:	2a1503e1 	mov	w1, w21
  40f270:	aa1303e0 	mov	x0, x19
  40f274:	52800082 	mov	w2, #0x4                   	// #4
	stack_ptr = (char *)stack + stack_obj_size;
  40f278:	8b1402d4 	add	x20, x22, x20
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  40f27c:	97ffffda 	bl	40f1e4 <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  40f280:	aa1b03e6 	mov	x6, x27
  40f284:	aa1a03e5 	mov	x5, x26
  40f288:	aa1803e4 	mov	x4, x24
  40f28c:	aa1703e3 	mov	x3, x23
  40f290:	aa1403e2 	mov	x2, x20
  40f294:	aa1603e1 	mov	x1, x22
  40f298:	aa1303e0 	mov	x0, x19
  40f29c:	97ffddc3 	bl	4069a8 <arch_new_thread>
	new_thread->init_data = NULL;
  40f2a0:	f9002e7f 	str	xzr, [x19, #88]
	new_thread->no_wake_on_timeout = false;
  40f2a4:	3902227f 	strb	wzr, [x19, #136]
	if (name != NULL) {
  40f2a8:	b40005d9 	cbz	x25, 40f360 <z_setup_new_thread+0x160>
  40f2ac:	aa1903e1 	mov	x1, x25
  40f2b0:	91022660 	add	x0, x19, #0x89
  40f2b4:	d28003e2 	mov	x2, #0x1f                  	// #31
  40f2b8:	97ffc8ca 	bl	4015e0 <strncpy@plt>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  40f2bc:	3902a27f 	strb	wzr, [x19, #168]
	if (!_current) {
  40f2c0:	b00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40f2c4:	f9474000 	ldr	x0, [x0, #3712]
  40f2c8:	f9400800 	ldr	x0, [x0, #16]
  40f2cc:	b4000040 	cbz	x0, 40f2d4 <z_setup_new_thread+0xd4>
	new_thread->resource_pool = _current->resource_pool;
  40f2d0:	f9405800 	ldr	x0, [x0, #176]
	return stack_ptr;
  40f2d4:	f9005a60 	str	x0, [x19, #176]
}
  40f2d8:	aa1403e0 	mov	x0, x20
  40f2dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f2e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f2e4:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f2e8:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40f2ec:	f9402bfb 	ldr	x27, [sp, #80]
  40f2f0:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40f2f4:	d65f03c0 	ret
	Z_ASSERT_VALID_PRIO(prio, entry);
  40f2f8:	110040e0 	add	w0, w7, #0x10
  40f2fc:	7100781f 	cmp	w0, #0x1e
  40f300:	54fffac9 	b.ls	40f258 <z_setup_new_thread+0x58>  // b.plast
  40f304:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f308:	91271273 	add	x19, x19, #0x9c4
  40f30c:	aa1303e2 	mov	x2, x19
  40f310:	52804343 	mov	w3, #0x21a                 	// #538
  40f314:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f318:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f31c:	91279c21 	add	x1, x1, #0x9e7
  40f320:	91353400 	add	x0, x0, #0xd4d
  40f324:	97ffd7a6 	bl	4051bc <assert_print>
  40f328:	528001c2 	mov	w2, #0xe                   	// #14
  40f32c:	128001e3 	mov	w3, #0xfffffff0            	// #-16
  40f330:	2a1503e1 	mov	w1, w21
  40f334:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40f338:	91299c00 	add	x0, x0, #0xa67
  40f33c:	97ffd7a0 	bl	4051bc <assert_print>
  40f340:	aa1303e0 	mov	x0, x19
  40f344:	52804341 	mov	w1, #0x21a                 	// #538
  40f348:	97ffd7c7 	bl	405264 <assert_post_action>
  40f34c:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f350:	aa1303e1 	mov	x1, x19
  40f354:	91362c00 	add	x0, x0, #0xd8b
  40f358:	52804342 	mov	w2, #0x21a                 	// #538
  40f35c:	97ffe1b4 	bl	407a2c <posix_print_error_and_exit>
		new_thread->name[0] = '\0';
  40f360:	3902267f 	strb	wzr, [x19, #137]
  40f364:	17ffffd7 	b	40f2c0 <z_setup_new_thread+0xc0>

000000000040f368 <z_impl_k_thread_create>:
{
  40f368:	d100c3ff 	sub	sp, sp, #0x30
  40f36c:	b00000e8 	adrp	x8, 42c000 <__FRAME_END__+0xfbbc>
  40f370:	a9017bfd 	stp	x29, x30, [sp, #16]
  40f374:	910043fd 	add	x29, sp, #0x10
  40f378:	f9474108 	ldr	x8, [x8, #3712]
  40f37c:	a90253f3 	stp	x19, x20, [sp, #32]
  40f380:	f9401ff4 	ldr	x20, [sp, #56]
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
  40f384:	b9400108 	ldr	w8, [x8]
  40f388:	340002a8 	cbz	w8, 40f3dc <z_impl_k_thread_create+0x74>
  40f38c:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f390:	91271273 	add	x19, x19, #0x9c4
  40f394:	aa1303e2 	mov	x2, x19
  40f398:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f39c:	912a6021 	add	x1, x1, #0xa98
  40f3a0:	52805183 	mov	w3, #0x28c                 	// #652
  40f3a4:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f3a8:	91353400 	add	x0, x0, #0xd4d
  40f3ac:	97ffd784 	bl	4051bc <assert_print>
  40f3b0:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40f3b4:	912aa800 	add	x0, x0, #0xaaa
  40f3b8:	97ffd781 	bl	4051bc <assert_print>
  40f3bc:	aa1303e0 	mov	x0, x19
  40f3c0:	52805181 	mov	w1, #0x28c                 	// #652
  40f3c4:	97ffd7a8 	bl	405264 <assert_post_action>
  40f3c8:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f3cc:	aa1303e1 	mov	x1, x19
  40f3d0:	91362c00 	add	x0, x0, #0xd8b
  40f3d4:	52805182 	mov	w2, #0x28c                 	// #652
  40f3d8:	97ffe195 	bl	407a2c <posix_print_error_and_exit>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  40f3dc:	b94033e8 	ldr	w8, [sp, #48]
  40f3e0:	aa0003f3 	mov	x19, x0
  40f3e4:	b90003e8 	str	w8, [sp]
  40f3e8:	f90007ff 	str	xzr, [sp, #8]
  40f3ec:	97ffff85 	bl	40f200 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  40f3f0:	b100069f 	cmn	x20, #0x1
  40f3f4:	54000080 	b.eq	40f404 <z_impl_k_thread_create+0x9c>  // b.none
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  40f3f8:	b5000114 	cbnz	x20, 40f418 <z_impl_k_thread_create+0xb0>
	z_impl_k_thread_start(thread);
  40f3fc:	aa1303e0 	mov	x0, x19
  40f400:	97ffff78 	bl	40f1e0 <z_impl_k_thread_start>
}
  40f404:	aa1303e0 	mov	x0, x19
  40f408:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40f40c:	a94253f3 	ldp	x19, x20, [sp, #32]
  40f410:	9100c3ff 	add	sp, sp, #0x30
  40f414:	d65f03c0 	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  40f418:	b00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40f41c:	aa1403e2 	mov	x2, x20
  40f420:	9100a260 	add	x0, x19, #0x28
  40f424:	f9473021 	ldr	x1, [x1, #3680]
  40f428:	94001180 	bl	413a28 <z_add_timeout>
  40f42c:	17fffff6 	b	40f404 <z_impl_k_thread_create+0x9c>

000000000040f430 <z_init_static_threads>:
{
  40f430:	d10103ff 	sub	sp, sp, #0x40
	_FOREACH_STATIC_THREAD(thread_data) {
  40f434:	b00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
{
  40f438:	a9017bfd 	stp	x29, x30, [sp, #16]
  40f43c:	910043fd 	add	x29, sp, #0x10
  40f440:	a90253f3 	stp	x19, x20, [sp, #32]
  40f444:	aa0003f4 	mov	x20, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  40f448:	f947b413 	ldr	x19, [x0, #3944]
  40f44c:	b00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
{
  40f450:	a9035bf5 	stp	x21, x22, [sp, #48]
  40f454:	aa0003f5 	mov	x21, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  40f458:	f9471c16 	ldr	x22, [x0, #3640]
  40f45c:	eb16027f 	cmp	x19, x22
  40f460:	54000469 	b.ls	40f4ec <z_init_static_threads+0xbc>  // b.plast
  40f464:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f468:	91271273 	add	x19, x19, #0x9c4
  40f46c:	aa1303e2 	mov	x2, x19
  40f470:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f474:	912b3c21 	add	x1, x1, #0xacf
  40f478:	52805e63 	mov	w3, #0x2f3                 	// #755
  40f47c:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f480:	91353400 	add	x0, x0, #0xd4d
  40f484:	97ffd74e 	bl	4051bc <assert_print>
  40f488:	d0000020 	adrp	x0, 415000 <__func__.2+0x30c>
  40f48c:	91023800 	add	x0, x0, #0x8e
  40f490:	97ffd74b 	bl	4051bc <assert_print>
  40f494:	aa1303e0 	mov	x0, x19
  40f498:	52805e61 	mov	w1, #0x2f3                 	// #755
  40f49c:	97ffd772 	bl	405264 <assert_post_action>
  40f4a0:	52805e62 	mov	w2, #0x2f3                 	// #755
	_FOREACH_STATIC_THREAD(thread_data) {
  40f4a4:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f4a8:	aa1303e1 	mov	x1, x19
  40f4ac:	91362c00 	add	x0, x0, #0xd8b
  40f4b0:	97ffe15f 	bl	407a2c <posix_print_error_and_exit>
		z_setup_new_thread(
  40f4b4:	f9402660 	ldr	x0, [x19, #72]
  40f4b8:	b9401262 	ldr	w2, [x19, #16]
  40f4bc:	f90007e0 	str	x0, [sp, #8]
  40f4c0:	b9403e60 	ldr	w0, [x19, #60]
  40f4c4:	b90003e0 	str	w0, [sp]
  40f4c8:	a9400660 	ldp	x0, x1, [x19]
  40f4cc:	a9419263 	ldp	x3, x4, [x19, #24]
  40f4d0:	a9429a65 	ldp	x5, x6, [x19, #40]
  40f4d4:	b9403a67 	ldr	w7, [x19, #56]
  40f4d8:	97ffff4a 	bl	40f200 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  40f4dc:	f9400260 	ldr	x0, [x19]
  40f4e0:	f9002c13 	str	x19, [x0, #88]
	_FOREACH_STATIC_THREAD(thread_data) {
  40f4e4:	91014273 	add	x19, x19, #0x50
  40f4e8:	17ffffdd 	b	40f45c <z_init_static_threads+0x2c>
  40f4ec:	54fffe43 	b.cc	40f4b4 <z_init_static_threads+0x84>  // b.lo, b.ul, b.last
	k_sched_lock();
  40f4f0:	94000878 	bl	4116d0 <k_sched_lock>
  40f4f4:	d2800156 	mov	x22, #0xa                   	// #10
	_FOREACH_STATIC_THREAD(thread_data) {
  40f4f8:	f947b693 	ldr	x19, [x20, #3944]
  40f4fc:	f9471eb4 	ldr	x20, [x21, #3640]
  40f500:	b00000f5 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
  40f504:	f94732b5 	ldr	x21, [x21, #3680]
  40f508:	eb14027f 	cmp	x19, x20
  40f50c:	54000469 	b.ls	40f598 <z_init_static_threads+0x168>  // b.plast
  40f510:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f514:	91271273 	add	x19, x19, #0x9c4
  40f518:	aa1303e2 	mov	x2, x19
  40f51c:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f520:	912b3c21 	add	x1, x1, #0xacf
  40f524:	52806243 	mov	w3, #0x312                 	// #786
  40f528:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f52c:	91353400 	add	x0, x0, #0xd4d
  40f530:	97ffd723 	bl	4051bc <assert_print>
  40f534:	d0000020 	adrp	x0, 415000 <__func__.2+0x30c>
  40f538:	91023800 	add	x0, x0, #0x8e
  40f53c:	97ffd720 	bl	4051bc <assert_print>
  40f540:	aa1303e0 	mov	x0, x19
  40f544:	52806241 	mov	w1, #0x312                 	// #786
  40f548:	97ffd747 	bl	405264 <assert_post_action>
  40f54c:	52806242 	mov	w2, #0x312                 	// #786
  40f550:	17ffffd5 	b	40f4a4 <z_init_static_threads+0x74>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
  40f554:	b9404262 	ldr	w2, [x19, #64]
  40f558:	3100045f 	cmn	w2, #0x1
  40f55c:	54000100 	b.eq	40f57c <z_init_static_threads+0x14c>  // b.none
					    K_MSEC(thread_data->init_delay));
  40f560:	7100005f 	cmp	w2, #0x0
  40f564:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
  40f568:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
  40f56c:	93407c43 	sxtw	x3, w2
		t += off;
  40f570:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  40f574:	b5000083 	cbnz	x3, 40f584 <z_init_static_threads+0x154>
  40f578:	97ffff1a 	bl	40f1e0 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
  40f57c:	91014273 	add	x19, x19, #0x50
  40f580:	17ffffe2 	b	40f508 <z_init_static_threads+0xd8>
  40f584:	9ad60842 	udiv	x2, x2, x22
  40f588:	aa1503e1 	mov	x1, x21
  40f58c:	9100a000 	add	x0, x0, #0x28
  40f590:	94001126 	bl	413a28 <z_add_timeout>
  40f594:	17fffffa 	b	40f57c <z_init_static_threads+0x14c>
  40f598:	54fffde3 	b.cc	40f554 <z_init_static_threads+0x124>  // b.lo, b.ul, b.last
}
  40f59c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40f5a0:	a94253f3 	ldp	x19, x20, [sp, #32]
  40f5a4:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40f5a8:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
  40f5ac:	14000cf1 	b	412970 <k_sched_unlock>

000000000040f5b0 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
  40f5b0:	f9400000 	ldr	x0, [x0]

	if (thread_cpu != 0U) {
  40f5b4:	b4000100 	cbz	x0, 40f5d4 <z_spin_lock_valid+0x24>
		if ((thread_cpu & 3U) == _current_cpu->id) {
  40f5b8:	b00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40f5bc:	92400400 	and	x0, x0, #0x3
  40f5c0:	f9474021 	ldr	x1, [x1, #3712]
  40f5c4:	39408021 	ldrb	w1, [x1, #32]
  40f5c8:	eb01001f 	cmp	x0, x1
  40f5cc:	1a9f07e0 	cset	w0, ne  // ne = any
			return false;
		}
	}
	return true;
}
  40f5d0:	d65f03c0 	ret
	return true;
  40f5d4:	52800020 	mov	w0, #0x1                   	// #1
  40f5d8:	17fffffe 	b	40f5d0 <z_spin_lock_valid+0x20>

000000000040f5dc <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
  40f5dc:	b00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40f5e0:	f9474021 	ldr	x1, [x1, #3712]
  40f5e4:	39408022 	ldrb	w2, [x1, #32]
  40f5e8:	f9400821 	ldr	x1, [x1, #16]
  40f5ec:	aa020021 	orr	x1, x1, x2
  40f5f0:	f9400002 	ldr	x2, [x0]
  40f5f4:	eb01005f 	cmp	x2, x1
  40f5f8:	54000081 	b.ne	40f608 <z_spin_unlock_valid+0x2c>  // b.any
		return false;
	}
	l->thread_cpu = 0;
  40f5fc:	f900001f 	str	xzr, [x0]
	return true;
  40f600:	52800020 	mov	w0, #0x1                   	// #1
}
  40f604:	d65f03c0 	ret
		return false;
  40f608:	52800000 	mov	w0, #0x0                   	// #0
  40f60c:	17fffffe 	b	40f604 <z_spin_unlock_valid+0x28>

000000000040f610 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
  40f610:	b00000e1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  40f614:	f9474021 	ldr	x1, [x1, #3712]
  40f618:	39408022 	ldrb	w2, [x1, #32]
  40f61c:	f9400821 	ldr	x1, [x1, #16]
  40f620:	aa020021 	orr	x1, x1, x2
  40f624:	f9000001 	str	x1, [x0]
}
  40f628:	d65f03c0 	ret

000000000040f62c <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
  40f62c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40f630:	b00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
{
  40f634:	910003fd 	mov	x29, sp
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40f638:	f9474000 	ldr	x0, [x0, #3712]
{
  40f63c:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  40f640:	f9400800 	ldr	x0, [x0, #16]
  40f644:	39c06800 	ldrsb	w0, [x0, #26]
  40f648:	36f80240 	tbz	w0, #31, 40f690 <idle+0x64>
  40f64c:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f650:	912bf273 	add	x19, x19, #0xafc
  40f654:	aa1303e2 	mov	x2, x19
  40f658:	52800523 	mov	w3, #0x29                  	// #41
  40f65c:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f660:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f664:	912c7421 	add	x1, x1, #0xb1d
  40f668:	91353400 	add	x0, x0, #0xd4d
  40f66c:	97ffd6d4 	bl	4051bc <assert_print>
  40f670:	aa1303e0 	mov	x0, x19
  40f674:	52800521 	mov	w1, #0x29                  	// #41
  40f678:	97ffd6fb 	bl	405264 <assert_post_action>
  40f67c:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f680:	aa1303e1 	mov	x1, x19
  40f684:	91362c00 	add	x0, x0, #0xd8b
  40f688:	52800522 	mov	w2, #0x29                  	// #41
  40f68c:	97ffe0e8 	bl	407a2c <posix_print_error_and_exit>
	return posix_irq_lock();
  40f690:	97ffdfd1 	bl	4075d4 <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
  40f694:	97ffdb3d 	bl	406388 <arch_cpu_idle>
  40f698:	17fffffe 	b	40f690 <idle+0x64>

000000000040f69c <k_msgq_init>:

void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
		 uint32_t max_msgs)
{
	msgq->msg_size = msg_size;
	msgq->max_msgs = max_msgs;
  40f69c:	b9002003 	str	w3, [x0, #32]
	msgq->buffer_start = buffer;
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40f6a0:	2a0303e3 	mov	w3, w3
	msgq->msg_size = msg_size;
  40f6a4:	a901081f 	stp	xzr, x2, [x0, #16]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40f6a8:	9b020462 	madd	x2, x3, x2, x1
  40f6ac:	a9000000 	stp	x0, x0, [x0]
	msgq->buffer_start = buffer;
  40f6b0:	f9001401 	str	x1, [x0, #40]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  40f6b4:	f9001802 	str	x2, [x0, #48]
	msgq->read_ptr = buffer;
	msgq->write_ptr = buffer;
  40f6b8:	a9038401 	stp	x1, x1, [x0, #56]
	msgq->used_msgs = 0;
	msgq->flags = 0;
	z_waitq_init(&msgq->wait_q);
	msgq->lock = (struct k_spinlock) {};
#ifdef CONFIG_POLL
	sys_dlist_init(&msgq->poll_events);
  40f6bc:	91014001 	add	x1, x0, #0x50
	msgq->used_msgs = 0;
  40f6c0:	b900481f 	str	wzr, [x0, #72]
  40f6c4:	a9050401 	stp	x1, x1, [x0, #80]
	msgq->flags = 0;
  40f6c8:	3901801f 	strb	wzr, [x0, #96]
#endif	/* CONFIG_POLL */

	SYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);

	z_object_init(msgq);
}
  40f6cc:	d65f03c0 	ret

000000000040f6d0 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
  40f6d0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40f6d4:	910003fd 	mov	x29, sp
  40f6d8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f6dc:	aa0203f5 	mov	x21, x2
  40f6e0:	b00000e2 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  40f6e4:	a90153f3 	stp	x19, x20, [sp, #16]
  40f6e8:	aa0003f3 	mov	x19, x0
  40f6ec:	f9474040 	ldr	x0, [x2, #3712]
  40f6f0:	a90363f7 	stp	x23, x24, [sp, #48]
  40f6f4:	aa0103f7 	mov	x23, x1
  40f6f8:	aa0203f8 	mov	x24, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40f6fc:	b9400000 	ldr	w0, [x0]
  40f700:	340002c0 	cbz	w0, 40f758 <z_impl_k_msgq_put+0x88>
  40f704:	b40002b5 	cbz	x21, 40f758 <z_impl_k_msgq_put+0x88>
  40f708:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f70c:	912d1673 	add	x19, x19, #0xb45
  40f710:	aa1303e2 	mov	x2, x19
  40f714:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f718:	91243421 	add	x1, x1, #0x90d
  40f71c:	52800ec3 	mov	w3, #0x76                  	// #118
  40f720:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f724:	91353400 	add	x0, x0, #0xd4d
  40f728:	97ffd6a5 	bl	4051bc <assert_print>
  40f72c:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40f730:	91254c00 	add	x0, x0, #0x953
  40f734:	97ffd6a2 	bl	4051bc <assert_print>
  40f738:	aa1303e0 	mov	x0, x19
  40f73c:	52800ec1 	mov	w1, #0x76                  	// #118
  40f740:	97ffd6c9 	bl	405264 <assert_post_action>
  40f744:	52800ec2 	mov	w2, #0x76                  	// #118
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f748:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f74c:	aa1303e1 	mov	x1, x19
  40f750:	91362c00 	add	x0, x0, #0xd8b
  40f754:	97ffe0b6 	bl	407a2c <posix_print_error_and_exit>
  40f758:	97ffdf9f 	bl	4075d4 <posix_irq_lock>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
  40f75c:	91004274 	add	x20, x19, #0x10
  40f760:	2a0003f6 	mov	w22, w0
  40f764:	aa1403e0 	mov	x0, x20
  40f768:	97ffff92 	bl	40f5b0 <z_spin_lock_valid>
  40f76c:	72001c1f 	tst	w0, #0xff
  40f770:	54000261 	b.ne	40f7bc <z_impl_k_msgq_put+0xec>  // b.any
  40f774:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f778:	9122ce73 	add	x19, x19, #0x8b3
  40f77c:	aa1303e2 	mov	x2, x19
  40f780:	52801283 	mov	w3, #0x94                  	// #148
  40f784:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f788:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f78c:	91238021 	add	x1, x1, #0x8e0
  40f790:	91353400 	add	x0, x0, #0xd4d
  40f794:	97ffd68a 	bl	4051bc <assert_print>
  40f798:	aa1403e1 	mov	x1, x20
  40f79c:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40f7a0:	9123d400 	add	x0, x0, #0x8f5
  40f7a4:	97ffd686 	bl	4051bc <assert_print>
  40f7a8:	aa1303e0 	mov	x0, x19
  40f7ac:	52801281 	mov	w1, #0x94                  	// #148
  40f7b0:	97ffd6ad 	bl	405264 <assert_post_action>
  40f7b4:	52801282 	mov	w2, #0x94                  	// #148
  40f7b8:	17ffffe4 	b	40f748 <z_impl_k_msgq_put+0x78>
	z_spin_lock_set_owner(l);
  40f7bc:	aa1403e0 	mov	x0, x20
  40f7c0:	97ffff94 	bl	40f610 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
  40f7c4:	b9402260 	ldr	w0, [x19, #32]
  40f7c8:	b9404a61 	ldr	w1, [x19, #72]
  40f7cc:	6b00003f 	cmp	w1, w0
  40f7d0:	54000a82 	b.cs	40f920 <z_impl_k_msgq_put+0x250>  // b.hs, b.nlast
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  40f7d4:	aa1303e0 	mov	x0, x19
  40f7d8:	94000cd1 	bl	412b1c <z_unpend_first_thread>
  40f7dc:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  40f7e0:	b4000240 	cbz	x0, 40f828 <z_impl_k_msgq_put+0x158>
  return __builtin___memcpy_chk (__dest, __src, __len,
  40f7e4:	f9400e62 	ldr	x2, [x19, #24]
  40f7e8:	aa1703e1 	mov	x1, x23
  40f7ec:	f9401000 	ldr	x0, [x0, #32]
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
  40f7f0:	52800013 	mov	w19, #0x0                   	// #0
  40f7f4:	97ffc6b3 	bl	4012c0 <memcpy@plt>
	thread->callee_saved.retval = value;
  40f7f8:	b9004ebf 	str	wzr, [x21, #76]
			z_ready_thread(pending_thread);
  40f7fc:	aa1503e0 	mov	x0, x21
  40f800:	940009be 	bl	411ef8 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  40f804:	2a1603e1 	mov	w1, w22
  40f808:	aa1403e0 	mov	x0, x20
  40f80c:	94000760 	bl	41158c <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  40f810:	2a1303e0 	mov	w0, w19
  40f814:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f818:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f81c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f820:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40f824:	d65f03c0 	ret
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  40f828:	f9401661 	ldr	x1, [x19, #40]
  40f82c:	f9402260 	ldr	x0, [x19, #64]
  40f830:	eb01001f 	cmp	x0, x1
  40f834:	54000083 	b.cc	40f844 <z_impl_k_msgq_put+0x174>  // b.lo, b.ul, b.last
  40f838:	f9401a61 	ldr	x1, [x19, #48]
  40f83c:	eb01001f 	cmp	x0, x1
  40f840:	540001e3 	b.cc	40f87c <z_impl_k_msgq_put+0x1ac>  // b.lo, b.ul, b.last
  40f844:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f848:	912d1673 	add	x19, x19, #0xb45
  40f84c:	aa1303e2 	mov	x2, x19
  40f850:	52801203 	mov	w3, #0x90                  	// #144
  40f854:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f858:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f85c:	912d9c21 	add	x1, x1, #0xb67
  40f860:	91353400 	add	x0, x0, #0xd4d
  40f864:	97ffd656 	bl	4051bc <assert_print>
  40f868:	aa1303e0 	mov	x0, x19
  40f86c:	52801201 	mov	w1, #0x90                  	// #144
  40f870:	97ffd67d 	bl	405264 <assert_post_action>
  40f874:	52801202 	mov	w2, #0x90                  	// #144
  40f878:	17ffffb4 	b	40f748 <z_impl_k_msgq_put+0x78>
  40f87c:	f9400e62 	ldr	x2, [x19, #24]
  40f880:	aa1703e1 	mov	x1, x23
  40f884:	97ffc68f 	bl	4012c0 <memcpy@plt>
			msgq->write_ptr += msgq->msg_size;
  40f888:	f9400e60 	ldr	x0, [x19, #24]
  40f88c:	f9402262 	ldr	x2, [x19, #64]
  40f890:	8b000042 	add	x2, x2, x0
  40f894:	f9002262 	str	x2, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  40f898:	f9401a60 	ldr	x0, [x19, #48]
  40f89c:	eb00005f 	cmp	x2, x0
  40f8a0:	54000061 	b.ne	40f8ac <z_impl_k_msgq_put+0x1dc>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  40f8a4:	f9401660 	ldr	x0, [x19, #40]
  40f8a8:	f9002260 	str	x0, [x19, #64]
			msgq->used_msgs++;
  40f8ac:	b9404a60 	ldr	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40f8b0:	52800201 	mov	w1, #0x10                  	// #16
			msgq->used_msgs++;
  40f8b4:	11000400 	add	w0, w0, #0x1
  40f8b8:	b9004a60 	str	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40f8bc:	91014260 	add	x0, x19, #0x50
		result = 0;
  40f8c0:	52800013 	mov	w19, #0x0                   	// #0
	z_handle_obj_poll_events(&msgq->poll_events, state);
  40f8c4:	9400124e 	bl	4141fc <z_handle_obj_poll_events>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40f8c8:	aa1403e0 	mov	x0, x20
  40f8cc:	97ffff44 	bl	40f5dc <z_spin_unlock_valid>
  40f8d0:	72001c1f 	tst	w0, #0xff
  40f8d4:	54000441 	b.ne	40f95c <z_impl_k_msgq_put+0x28c>  // b.any
  40f8d8:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f8dc:	9122ce73 	add	x19, x19, #0x8b3
  40f8e0:	aa1303e2 	mov	x2, x19
  40f8e4:	52801863 	mov	w3, #0xc3                  	// #195
  40f8e8:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f8ec:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f8f0:	91255821 	add	x1, x1, #0x956
  40f8f4:	91353400 	add	x0, x0, #0xd4d
  40f8f8:	97ffd631 	bl	4051bc <assert_print>
  40f8fc:	aa1403e1 	mov	x1, x20
  40f900:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40f904:	9125b400 	add	x0, x0, #0x96d
  40f908:	97ffd62d 	bl	4051bc <assert_print>
  40f90c:	aa1303e0 	mov	x0, x19
  40f910:	52801861 	mov	w1, #0xc3                  	// #195
  40f914:	97ffd654 	bl	405264 <assert_post_action>
  40f918:	52801862 	mov	w2, #0xc3                  	// #195
  40f91c:	17ffff8b 	b	40f748 <z_impl_k_msgq_put+0x78>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40f920:	b40001b5 	cbz	x21, 40f954 <z_impl_k_msgq_put+0x284>
		_current->base.swap_data = (void *) data;
  40f924:	f9474302 	ldr	x2, [x24, #3712]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40f928:	aa1503e3 	mov	x3, x21
  40f92c:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = (void *) data;
  40f930:	f9400840 	ldr	x0, [x2, #16]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40f934:	aa1303e2 	mov	x2, x19
		_current->base.swap_data = (void *) data;
  40f938:	f9001017 	str	x23, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40f93c:	aa1403e0 	mov	x0, x20
}
  40f940:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f944:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f948:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f94c:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40f950:	14000ab3 	b	41241c <z_pend_curr>
		result = -ENOMSG;
  40f954:	12800533 	mov	w19, #0xffffffd6            	// #-42
  40f958:	17ffffdc 	b	40f8c8 <z_impl_k_msgq_put+0x1f8>
	posix_irq_unlock(key);
  40f95c:	2a1603e0 	mov	w0, w22
  40f960:	97ffdf1f 	bl	4075dc <posix_irq_unlock>
	return result;
  40f964:	17ffffab 	b	40f810 <z_impl_k_msgq_put+0x140>

000000000040f968 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
  40f968:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	return _kernel.cpus[0].nested != 0U;
  40f96c:	b00000e4 	adrp	x4, 42c000 <__FRAME_END__+0xfbbc>
  40f970:	910003fd 	mov	x29, sp
  40f974:	a90153f3 	stp	x19, x20, [sp, #16]
  40f978:	aa0003f3 	mov	x19, x0
  40f97c:	f9474080 	ldr	x0, [x4, #3712]
  40f980:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f984:	aa0403f5 	mov	x21, x4
  40f988:	a90363f7 	stp	x23, x24, [sp, #48]
  40f98c:	aa0103f8 	mov	x24, x1
  40f990:	aa0203f7 	mov	x23, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  40f994:	b9400000 	ldr	w0, [x0]
  40f998:	340002c0 	cbz	w0, 40f9f0 <z_impl_k_msgq_get+0x88>
  40f99c:	b40002a2 	cbz	x2, 40f9f0 <z_impl_k_msgq_get+0x88>
  40f9a0:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40f9a4:	912d1673 	add	x19, x19, #0xb45
  40f9a8:	aa1303e2 	mov	x2, x19
  40f9ac:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40f9b0:	91243421 	add	x1, x1, #0x90d
  40f9b4:	52801a43 	mov	w3, #0xd2                  	// #210
  40f9b8:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f9bc:	91353400 	add	x0, x0, #0xd4d
  40f9c0:	97ffd5ff 	bl	4051bc <assert_print>
  40f9c4:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40f9c8:	91254c00 	add	x0, x0, #0x953
  40f9cc:	97ffd5fc 	bl	4051bc <assert_print>
  40f9d0:	aa1303e0 	mov	x0, x19
  40f9d4:	52801a41 	mov	w1, #0xd2                  	// #210
  40f9d8:	97ffd623 	bl	405264 <assert_post_action>
  40f9dc:	52801a42 	mov	w2, #0xd2                  	// #210
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40f9e0:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40f9e4:	aa1303e1 	mov	x1, x19
  40f9e8:	91362c00 	add	x0, x0, #0xd8b
  40f9ec:	97ffe010 	bl	407a2c <posix_print_error_and_exit>
	return posix_irq_lock();
  40f9f0:	97ffdef9 	bl	4075d4 <posix_irq_lock>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
  40f9f4:	91004274 	add	x20, x19, #0x10
  40f9f8:	2a0003f6 	mov	w22, w0
  40f9fc:	aa1403e0 	mov	x0, x20
  40fa00:	97fffeec 	bl	40f5b0 <z_spin_lock_valid>
  40fa04:	72001c1f 	tst	w0, #0xff
  40fa08:	54000261 	b.ne	40fa54 <z_impl_k_msgq_get+0xec>  // b.any
  40fa0c:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40fa10:	9122ce73 	add	x19, x19, #0x8b3
  40fa14:	aa1303e2 	mov	x2, x19
  40fa18:	52801283 	mov	w3, #0x94                  	// #148
  40fa1c:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40fa20:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fa24:	91238021 	add	x1, x1, #0x8e0
  40fa28:	91353400 	add	x0, x0, #0xd4d
  40fa2c:	97ffd5e4 	bl	4051bc <assert_print>
  40fa30:	aa1403e1 	mov	x1, x20
  40fa34:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40fa38:	9123d400 	add	x0, x0, #0x8f5
  40fa3c:	97ffd5e0 	bl	4051bc <assert_print>
  40fa40:	aa1303e0 	mov	x0, x19
  40fa44:	52801281 	mov	w1, #0x94                  	// #148
  40fa48:	97ffd607 	bl	405264 <assert_post_action>
  40fa4c:	52801282 	mov	w2, #0x94                  	// #148
  40fa50:	17ffffe4 	b	40f9e0 <z_impl_k_msgq_get+0x78>
	z_spin_lock_set_owner(l);
  40fa54:	aa1403e0 	mov	x0, x20
  40fa58:	97fffeee 	bl	40f610 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
  40fa5c:	b9404a60 	ldr	w0, [x19, #72]
  40fa60:	340008c0 	cbz	w0, 40fb78 <z_impl_k_msgq_get+0x210>
  40fa64:	f9400e62 	ldr	x2, [x19, #24]
  40fa68:	aa1803e0 	mov	x0, x24
  40fa6c:	f9401e61 	ldr	x1, [x19, #56]
  40fa70:	97ffc614 	bl	4012c0 <memcpy@plt>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
  40fa74:	f9400e61 	ldr	x1, [x19, #24]
  40fa78:	f9401e60 	ldr	x0, [x19, #56]
  40fa7c:	8b010000 	add	x0, x0, x1
  40fa80:	f9001e60 	str	x0, [x19, #56]
		if (msgq->read_ptr == msgq->buffer_end) {
  40fa84:	f9401a61 	ldr	x1, [x19, #48]
  40fa88:	eb01001f 	cmp	x0, x1
  40fa8c:	54000061 	b.ne	40fa98 <z_impl_k_msgq_get+0x130>  // b.any
			msgq->read_ptr = msgq->buffer_start;
  40fa90:	f9401660 	ldr	x0, [x19, #40]
  40fa94:	f9001e60 	str	x0, [x19, #56]
		}
		msgq->used_msgs--;
  40fa98:	b9404a60 	ldr	w0, [x19, #72]
  40fa9c:	51000400 	sub	w0, w0, #0x1
  40faa0:	b9004a60 	str	w0, [x19, #72]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  40faa4:	aa1303e0 	mov	x0, x19
  40faa8:	94000c1d 	bl	412b1c <z_unpend_first_thread>
  40faac:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  40fab0:	b40007e0 	cbz	x0, 40fbac <z_impl_k_msgq_get+0x244>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  40fab4:	f9401661 	ldr	x1, [x19, #40]
  40fab8:	f9402260 	ldr	x0, [x19, #64]
  40fabc:	eb01001f 	cmp	x0, x1
  40fac0:	54000083 	b.cc	40fad0 <z_impl_k_msgq_get+0x168>  // b.lo, b.ul, b.last
  40fac4:	f9401a61 	ldr	x1, [x19, #48]
  40fac8:	eb01001f 	cmp	x0, x1
  40facc:	540001e3 	b.cc	40fb08 <z_impl_k_msgq_get+0x1a0>  // b.lo, b.ul, b.last
  40fad0:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40fad4:	912d1673 	add	x19, x19, #0xb45
  40fad8:	aa1303e2 	mov	x2, x19
  40fadc:	52801d63 	mov	w3, #0xeb                  	// #235
  40fae0:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40fae4:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fae8:	912d9c21 	add	x1, x1, #0xb67
  40faec:	91353400 	add	x0, x0, #0xd4d
  40faf0:	97ffd5b3 	bl	4051bc <assert_print>
  40faf4:	aa1303e0 	mov	x0, x19
  40faf8:	52801d61 	mov	w1, #0xeb                  	// #235
  40fafc:	97ffd5da 	bl	405264 <assert_post_action>
  40fb00:	52801d62 	mov	w2, #0xeb                  	// #235
  40fb04:	17ffffb7 	b	40f9e0 <z_impl_k_msgq_get+0x78>
  40fb08:	f9400e62 	ldr	x2, [x19, #24]
  40fb0c:	f94012a1 	ldr	x1, [x21, #32]
  40fb10:	97ffc5ec 	bl	4012c0 <memcpy@plt>
					msgq->write_ptr < msgq->buffer_end);
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
  40fb14:	f9400e61 	ldr	x1, [x19, #24]
  40fb18:	f9402260 	ldr	x0, [x19, #64]
  40fb1c:	8b010000 	add	x0, x0, x1
  40fb20:	f9002260 	str	x0, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  40fb24:	f9401a61 	ldr	x1, [x19, #48]
  40fb28:	eb01001f 	cmp	x0, x1
  40fb2c:	54000061 	b.ne	40fb38 <z_impl_k_msgq_get+0x1d0>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  40fb30:	f9401660 	ldr	x0, [x19, #40]
  40fb34:	f9002260 	str	x0, [x19, #64]
			}
			msgq->used_msgs++;
  40fb38:	b9404a60 	ldr	w0, [x19, #72]
  40fb3c:	11000400 	add	w0, w0, #0x1
  40fb40:	b9004a60 	str	w0, [x19, #72]
	thread->callee_saved.retval = value;
  40fb44:	b9004ebf 	str	wzr, [x21, #76]

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
  40fb48:	aa1503e0 	mov	x0, x21
			z_reschedule(&msgq->lock, key);

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
  40fb4c:	52800013 	mov	w19, #0x0                   	// #0
			z_ready_thread(pending_thread);
  40fb50:	940008ea 	bl	411ef8 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  40fb54:	2a1603e1 	mov	w1, w22
  40fb58:	aa1403e0 	mov	x0, x20
  40fb5c:	9400068c 	bl	41158c <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  40fb60:	2a1303e0 	mov	w0, w19
  40fb64:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fb68:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fb6c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40fb70:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40fb74:	d65f03c0 	ret
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  40fb78:	b4000497 	cbz	x23, 40fc08 <z_impl_k_msgq_get+0x2a0>
		_current->base.swap_data = data;
  40fb7c:	f94742a4 	ldr	x4, [x21, #3712]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40fb80:	aa1703e3 	mov	x3, x23
  40fb84:	aa1303e2 	mov	x2, x19
  40fb88:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = data;
  40fb8c:	f9400880 	ldr	x0, [x4, #16]
  40fb90:	f9001018 	str	x24, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40fb94:	aa1403e0 	mov	x0, x20
}
  40fb98:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fb9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fba0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40fba4:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  40fba8:	14000a1d 	b	41241c <z_pend_curr>
		result = 0;
  40fbac:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fbb0:	aa1403e0 	mov	x0, x20
  40fbb4:	97fffe8a 	bl	40f5dc <z_spin_unlock_valid>
  40fbb8:	72001c1f 	tst	w0, #0xff
  40fbbc:	540002a1 	b.ne	40fc10 <z_impl_k_msgq_get+0x2a8>  // b.any
  40fbc0:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40fbc4:	9122ce73 	add	x19, x19, #0x8b3
  40fbc8:	aa1303e2 	mov	x2, x19
  40fbcc:	52801863 	mov	w3, #0xc3                  	// #195
  40fbd0:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40fbd4:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fbd8:	91255821 	add	x1, x1, #0x956
  40fbdc:	91353400 	add	x0, x0, #0xd4d
  40fbe0:	97ffd577 	bl	4051bc <assert_print>
  40fbe4:	aa1403e1 	mov	x1, x20
  40fbe8:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40fbec:	9125b400 	add	x0, x0, #0x96d
  40fbf0:	97ffd573 	bl	4051bc <assert_print>
  40fbf4:	aa1303e0 	mov	x0, x19
  40fbf8:	52801861 	mov	w1, #0xc3                  	// #195
  40fbfc:	97ffd59a 	bl	405264 <assert_post_action>
  40fc00:	52801862 	mov	w2, #0xc3                  	// #195
  40fc04:	17ffff77 	b	40f9e0 <z_impl_k_msgq_get+0x78>
		result = -ENOMSG;
  40fc08:	12800533 	mov	w19, #0xffffffd6            	// #-42
  40fc0c:	17ffffe9 	b	40fbb0 <z_impl_k_msgq_get+0x248>
	posix_irq_unlock(key);
  40fc10:	2a1603e0 	mov	w0, w22
  40fc14:	97ffde72 	bl	4075dc <posix_irq_unlock>
	return result;
  40fc18:	17ffffd2 	b	40fb60 <z_impl_k_msgq_get+0x1f8>

000000000040fc1c <z_impl_k_msgq_purge>:
}
#include <syscalls/k_msgq_peek_at_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
  40fc1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40fc20:	910003fd 	mov	x29, sp
  40fc24:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
  40fc28:	91004014 	add	x20, x0, #0x10
{
  40fc2c:	aa0003f3 	mov	x19, x0
  40fc30:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  40fc34:	97ffde68 	bl	4075d4 <posix_irq_lock>
  40fc38:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fc3c:	aa1403e0 	mov	x0, x20
  40fc40:	97fffe5c 	bl	40f5b0 <z_spin_lock_valid>
  40fc44:	72001c1f 	tst	w0, #0xff
  40fc48:	540002c1 	b.ne	40fca0 <z_impl_k_msgq_purge+0x84>  // b.any
  40fc4c:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40fc50:	9122ce73 	add	x19, x19, #0x8b3
  40fc54:	aa1303e2 	mov	x2, x19
  40fc58:	52801283 	mov	w3, #0x94                  	// #148
  40fc5c:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40fc60:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fc64:	91238021 	add	x1, x1, #0x8e0
  40fc68:	91353400 	add	x0, x0, #0xd4d
  40fc6c:	97ffd554 	bl	4051bc <assert_print>
  40fc70:	aa1403e1 	mov	x1, x20
  40fc74:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40fc78:	9123d400 	add	x0, x0, #0x8f5
  40fc7c:	97ffd550 	bl	4051bc <assert_print>
  40fc80:	aa1303e0 	mov	x0, x19
  40fc84:	52801281 	mov	w1, #0x94                  	// #148
  40fc88:	97ffd577 	bl	405264 <assert_post_action>
  40fc8c:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fc90:	aa1303e1 	mov	x1, x19
  40fc94:	91362c00 	add	x0, x0, #0xd8b
  40fc98:	52801282 	mov	w2, #0x94                  	// #148
  40fc9c:	97ffdf64 	bl	407a2c <posix_print_error_and_exit>
  40fca0:	12800536 	mov	w22, #0xffffffd6            	// #-42
	z_spin_lock_set_owner(l);
  40fca4:	aa1403e0 	mov	x0, x20
  40fca8:	97fffe5a 	bl	40f610 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
  40fcac:	aa1303e0 	mov	x0, x19
  40fcb0:	94000b9b 	bl	412b1c <z_unpend_first_thread>
  40fcb4:	aa0003e2 	mov	x2, x0
  40fcb8:	b5000140 	cbnz	x0, 40fce0 <z_impl_k_msgq_purge+0xc4>
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
	}

	msgq->used_msgs = 0;
	msgq->read_ptr = msgq->write_ptr;
  40fcbc:	f9402260 	ldr	x0, [x19, #64]
  40fcc0:	f9001e60 	str	x0, [x19, #56]
	msgq->used_msgs = 0;
  40fcc4:	b9004a7f 	str	wzr, [x19, #72]

	z_reschedule(&msgq->lock, key);
  40fcc8:	2a1503e1 	mov	w1, w21
  40fccc:	aa1403e0 	mov	x0, x20
}
  40fcd0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fcd4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fcd8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&msgq->lock, key);
  40fcdc:	1400062c 	b	41158c <z_reschedule>
  40fce0:	b9004c56 	str	w22, [x2, #76]
		z_ready_thread(pending_thread);
  40fce4:	94000885 	bl	411ef8 <z_ready_thread>
  40fce8:	17fffff1 	b	40fcac <z_impl_k_msgq_purge+0x90>

000000000040fcec <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
  40fcec:	39c06802 	ldrsb	w2, [x0, #26]
  40fcf0:	6b01005f 	cmp	w2, w1
  40fcf4:	54000040 	b.eq	40fcfc <adjust_owner_prio.isra.0+0x10>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
  40fcf8:	14000a39 	b	4125dc <z_set_prio>
	}
	return false;
}
  40fcfc:	52800000 	mov	w0, #0x0                   	// #0
  40fd00:	d65f03c0 	ret

000000000040fd04 <z_impl_k_mutex_init>:
  40fd04:	a9000000 	stp	x0, x0, [x0]
	mutex->owner = NULL;
  40fd08:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
  40fd0c:	b900181f 	str	wzr, [x0, #24]
}
  40fd10:	52800000 	mov	w0, #0x0                   	// #0
  40fd14:	d65f03c0 	ret

000000000040fd18 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
  40fd18:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40fd1c:	910003fd 	mov	x29, sp
  40fd20:	a9025bf5 	stp	x21, x22, [sp, #32]
	return _kernel.cpus[0].nested != 0U;
  40fd24:	b00000f5 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
  40fd28:	f90023f9 	str	x25, [sp, #64]
  40fd2c:	f94742b9 	ldr	x25, [x21, #3712]
  40fd30:	a90153f3 	stp	x19, x20, [sp, #16]
  40fd34:	aa0003f3 	mov	x19, x0
  40fd38:	a90363f7 	stp	x23, x24, [sp, #48]
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  40fd3c:	b9400320 	ldr	w0, [x25]
  40fd40:	340002a0 	cbz	w0, 40fd94 <z_impl_k_mutex_lock+0x7c>
  40fd44:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40fd48:	912ece73 	add	x19, x19, #0xbb3
  40fd4c:	aa1303e2 	mov	x2, x19
  40fd50:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40fd54:	912a6021 	add	x1, x1, #0xa98
  40fd58:	52800ca3 	mov	w3, #0x65                  	// #101
  40fd5c:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fd60:	91353400 	add	x0, x0, #0xd4d
  40fd64:	97ffd516 	bl	4051bc <assert_print>
  40fd68:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40fd6c:	912f5400 	add	x0, x0, #0xbd5
  40fd70:	97ffd513 	bl	4051bc <assert_print>
  40fd74:	aa1303e0 	mov	x0, x19
  40fd78:	52800ca1 	mov	w1, #0x65                  	// #101
  40fd7c:	97ffd53a 	bl	405264 <assert_post_action>
  40fd80:	52800ca2 	mov	w2, #0x65                  	// #101
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40fd84:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fd88:	aa1303e1 	mov	x1, x19
  40fd8c:	91362c00 	add	x0, x0, #0xd8b
  40fd90:	97ffdf27 	bl	407a2c <posix_print_error_and_exit>
  40fd94:	aa0103f8 	mov	x24, x1
  40fd98:	90000114 	adrp	x20, 42f000 <can_loopback_dev_data_0+0xc0>
  40fd9c:	97ffde0e 	bl	4075d4 <posix_irq_lock>
  40fda0:	911da297 	add	x23, x20, #0x768
  40fda4:	2a0003f6 	mov	w22, w0
  40fda8:	aa1703e0 	mov	x0, x23
  40fdac:	97fffe01 	bl	40f5b0 <z_spin_lock_valid>
  40fdb0:	72001c1f 	tst	w0, #0xff
  40fdb4:	54000261 	b.ne	40fe00 <z_impl_k_mutex_lock+0xe8>  // b.any
  40fdb8:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40fdbc:	9122ce73 	add	x19, x19, #0x8b3
  40fdc0:	aa1303e2 	mov	x2, x19
  40fdc4:	52801283 	mov	w3, #0x94                  	// #148
  40fdc8:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40fdcc:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fdd0:	91238021 	add	x1, x1, #0x8e0
  40fdd4:	91353400 	add	x0, x0, #0xd4d
  40fdd8:	97ffd4f9 	bl	4051bc <assert_print>
  40fddc:	911da281 	add	x1, x20, #0x768
  40fde0:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40fde4:	9123d400 	add	x0, x0, #0x8f5
  40fde8:	97ffd4f5 	bl	4051bc <assert_print>
  40fdec:	aa1303e0 	mov	x0, x19
  40fdf0:	52801281 	mov	w1, #0x94                  	// #148
  40fdf4:	97ffd51c 	bl	405264 <assert_post_action>
  40fdf8:	52801282 	mov	w2, #0x94                  	// #148
  40fdfc:	17ffffe2 	b	40fd84 <z_impl_k_mutex_lock+0x6c>
	z_spin_lock_set_owner(l);
  40fe00:	aa1703e0 	mov	x0, x23
  40fe04:	97fffe03 	bl	40f610 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  40fe08:	b9401a61 	ldr	w1, [x19, #24]
  40fe0c:	340001c1 	cbz	w1, 40fe44 <z_impl_k_mutex_lock+0x12c>
  40fe10:	f9400a60 	ldr	x0, [x19, #16]
  40fe14:	f9400b22 	ldr	x2, [x25, #16]
  40fe18:	eb02001f 	cmp	x0, x2
  40fe1c:	540004e0 	b.eq	40feb8 <z_impl_k_mutex_lock+0x1a0>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
  40fe20:	b5000638 	cbnz	x24, 40fee4 <z_impl_k_mutex_lock+0x1cc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40fe24:	aa1703e0 	mov	x0, x23
  40fe28:	97fffded 	bl	40f5dc <z_spin_unlock_valid>
  40fe2c:	72001c1f 	tst	w0, #0xff
  40fe30:	54000200 	b.eq	40fe70 <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  40fe34:	2a1603e0 	mov	w0, w22
  40fe38:	97ffdde9 	bl	4075dc <posix_irq_unlock>
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
  40fe3c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40fe40:	14000023 	b	40fecc <z_impl_k_mutex_lock+0x1b4>
					_current->base.prio :
  40fe44:	f9400b20 	ldr	x0, [x25, #16]
  40fe48:	39c06800 	ldrsb	w0, [x0, #26]
		mutex->owner = _current;
  40fe4c:	f94742b5 	ldr	x21, [x21, #3712]
		mutex->lock_count++;
  40fe50:	11000421 	add	w1, w1, #0x1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  40fe54:	29030261 	stp	w1, w0, [x19, #24]
		mutex->owner = _current;
  40fe58:	f9400aa0 	ldr	x0, [x21, #16]
  40fe5c:	f9000a60 	str	x0, [x19, #16]
  40fe60:	911da280 	add	x0, x20, #0x768
  40fe64:	97fffdde 	bl	40f5dc <z_spin_unlock_valid>
  40fe68:	72001c1f 	tst	w0, #0xff
  40fe6c:	540002a1 	b.ne	40fec0 <z_impl_k_mutex_lock+0x1a8>  // b.any
  40fe70:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40fe74:	9122ce73 	add	x19, x19, #0x8b3
  40fe78:	aa1303e2 	mov	x2, x19
  40fe7c:	52801863 	mov	w3, #0xc3                  	// #195
  40fe80:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40fe84:	b0000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  40fe88:	91255821 	add	x1, x1, #0x956
  40fe8c:	91353400 	add	x0, x0, #0xd4d
  40fe90:	97ffd4cb 	bl	4051bc <assert_print>
  40fe94:	911da281 	add	x1, x20, #0x768
  40fe98:	f0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  40fe9c:	9125b400 	add	x0, x0, #0x96d
  40fea0:	97ffd4c7 	bl	4051bc <assert_print>
  40fea4:	aa1303e0 	mov	x0, x19
  40fea8:	52801861 	mov	w1, #0xc3                  	// #195
  40feac:	97ffd4ee 	bl	405264 <assert_post_action>
  40feb0:	52801862 	mov	w2, #0xc3                  	// #195
  40feb4:	17ffffb4 	b	40fd84 <z_impl_k_mutex_lock+0x6c>
					_current->base.prio :
  40feb8:	b9401e60 	ldr	w0, [x19, #28]
  40febc:	17ffffe4 	b	40fe4c <z_impl_k_mutex_lock+0x134>
  40fec0:	2a1603e0 	mov	w0, w22
  40fec4:	97ffddc6 	bl	4075dc <posix_irq_unlock>
		return 0;
  40fec8:	52800000 	mov	w0, #0x0                   	// #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
  40fecc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fed0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40fed4:	a94363f7 	ldp	x23, x24, [sp, #48]
  40fed8:	f94023f9 	ldr	x25, [sp, #64]
  40fedc:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40fee0:	d65f03c0 	ret
	new_prio = new_prio_for_inheritance(_current->base.prio,
  40fee4:	39c06842 	ldrsb	w2, [x2, #26]
  40fee8:	39c06803 	ldrsb	w3, [x0, #26]
  40feec:	6b03005f 	cmp	w2, w3
  40fef0:	1a83d041 	csel	w1, w2, w3, le
  40fef4:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  40fef8:	3101fc3f 	cmn	w1, #0x7f
  40fefc:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  40ff00:	6b01007f 	cmp	w3, w1
  40ff04:	5400050d 	b.le	40ffa4 <z_impl_k_mutex_lock+0x28c>
		resched = adjust_owner_prio(mutex, new_prio);
  40ff08:	97ffff79 	bl	40fcec <adjust_owner_prio.isra.0>
  40ff0c:	12001c17 	and	w23, w0, #0xff
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  40ff10:	911da299 	add	x25, x20, #0x768
  40ff14:	aa1803e3 	mov	x3, x24
  40ff18:	aa1303e2 	mov	x2, x19
  40ff1c:	2a1603e1 	mov	w1, w22
  40ff20:	aa1903e0 	mov	x0, x25
  40ff24:	9400093e 	bl	41241c <z_pend_curr>
	if (got_mutex == 0) {
  40ff28:	34fffd20 	cbz	w0, 40fecc <z_impl_k_mutex_lock+0x1b4>
	return posix_irq_lock();
  40ff2c:	97ffddaa 	bl	4075d4 <posix_irq_lock>
  40ff30:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40ff34:	aa1903e0 	mov	x0, x25
  40ff38:	97fffd9e 	bl	40f5b0 <z_spin_lock_valid>
  40ff3c:	72001c1f 	tst	w0, #0xff
  40ff40:	54fff3c0 	b.eq	40fdb8 <z_impl_k_mutex_lock+0xa0>  // b.none
	z_spin_lock_set_owner(l);
  40ff44:	aa1903e0 	mov	x0, x25
  40ff48:	97fffdb2 	bl	40f610 <z_spin_lock_set_owner>
	if (likely(mutex->owner != NULL)) {
  40ff4c:	f9400a60 	ldr	x0, [x19, #16]
  40ff50:	b40001e0 	cbz	x0, 40ff8c <z_impl_k_mutex_lock+0x274>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  40ff54:	f9400262 	ldr	x2, [x19]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  40ff58:	b9401e61 	ldr	w1, [x19, #28]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  40ff5c:	eb02027f 	cmp	x19, x2
  40ff60:	54000100 	b.eq	40ff80 <z_impl_k_mutex_lock+0x268>  // b.none
  40ff64:	b40000e2 	cbz	x2, 40ff80 <z_impl_k_mutex_lock+0x268>
  40ff68:	39c06842 	ldrsb	w2, [x2, #26]
  40ff6c:	6b02003f 	cmp	w1, w2
  40ff70:	1a82d021 	csel	w1, w1, w2, le
  40ff74:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  40ff78:	3101fc3f 	cmn	w1, #0x7f
  40ff7c:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
		resched = adjust_owner_prio(mutex, new_prio) || resched;
  40ff80:	97ffff5b 	bl	40fcec <adjust_owner_prio.isra.0>
  40ff84:	72001c1f 	tst	w0, #0xff
  40ff88:	54000041 	b.ne	40ff90 <z_impl_k_mutex_lock+0x278>  // b.any
	if (resched) {
  40ff8c:	34000117 	cbz	w23, 40ffac <z_impl_k_mutex_lock+0x294>
		z_reschedule(&lock, key);
  40ff90:	2a1503e1 	mov	w1, w21
  40ff94:	911da280 	add	x0, x20, #0x768
  40ff98:	9400057d 	bl	41158c <z_reschedule>
	return -EAGAIN;
  40ff9c:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40ffa0:	17ffffcb 	b	40fecc <z_impl_k_mutex_lock+0x1b4>
	bool resched = false;
  40ffa4:	52800017 	mov	w23, #0x0                   	// #0
  40ffa8:	17ffffda 	b	40ff10 <z_impl_k_mutex_lock+0x1f8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40ffac:	911da280 	add	x0, x20, #0x768
  40ffb0:	97fffd8b 	bl	40f5dc <z_spin_unlock_valid>
  40ffb4:	72001c1f 	tst	w0, #0xff
  40ffb8:	54fff5c0 	b.eq	40fe70 <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  40ffbc:	2a1503e0 	mov	w0, w21
  40ffc0:	97ffdd87 	bl	4075dc <posix_irq_unlock>
  40ffc4:	17fffff6 	b	40ff9c <z_impl_k_mutex_lock+0x284>

000000000040ffc8 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  40ffc8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ffcc:	910003fd 	mov	x29, sp
  40ffd0:	a90153f3 	stp	x19, x20, [sp, #16]
  40ffd4:	aa0003f3 	mov	x19, x0
  40ffd8:	b00000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  40ffdc:	f90013f5 	str	x21, [sp, #32]
  40ffe0:	f9474000 	ldr	x0, [x0, #3712]
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  40ffe4:	b9400001 	ldr	w1, [x0]
  40ffe8:	340002a1 	cbz	w1, 41003c <z_impl_k_mutex_unlock+0x74>
  40ffec:	f0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  40fff0:	912ece73 	add	x19, x19, #0xbb3
  40fff4:	aa1303e2 	mov	x2, x19
  40fff8:	f0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  40fffc:	912a6021 	add	x1, x1, #0xa98
  410000:	528019a3 	mov	w3, #0xcd                  	// #205
  410004:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410008:	91353400 	add	x0, x0, #0xd4d
  41000c:	97ffd46c 	bl	4051bc <assert_print>
  410010:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410014:	912f5400 	add	x0, x0, #0xbd5
  410018:	97ffd469 	bl	4051bc <assert_print>
  41001c:	aa1303e0 	mov	x0, x19
  410020:	528019a1 	mov	w1, #0xcd                  	// #205
  410024:	97ffd490 	bl	405264 <assert_post_action>
  410028:	528019a2 	mov	w2, #0xcd                  	// #205
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  41002c:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410030:	aa1303e1 	mov	x1, x19
  410034:	91362c00 	add	x0, x0, #0xd8b
  410038:	97ffde7d 	bl	407a2c <posix_print_error_and_exit>
	CHECKIF(mutex->owner == NULL) {
  41003c:	f9400a61 	ldr	x1, [x19, #16]
  410040:	b4000c41 	cbz	x1, 4101c8 <z_impl_k_mutex_unlock+0x200>
	CHECKIF(mutex->owner != _current) {
  410044:	f9400800 	ldr	x0, [x0, #16]
  410048:	eb00003f 	cmp	x1, x0
  41004c:	54000c21 	b.ne	4101d0 <z_impl_k_mutex_unlock+0x208>  // b.any
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  410050:	b9401a60 	ldr	w0, [x19, #24]
  410054:	350001e0 	cbnz	w0, 410090 <z_impl_k_mutex_unlock+0xc8>
  410058:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  41005c:	912ece73 	add	x19, x19, #0xbb3
  410060:	aa1303e2 	mov	x2, x19
  410064:	52801ca3 	mov	w3, #0xe5                  	// #229
  410068:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  41006c:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410070:	912fe821 	add	x1, x1, #0xbfa
  410074:	91353400 	add	x0, x0, #0xd4d
  410078:	97ffd451 	bl	4051bc <assert_print>
  41007c:	aa1303e0 	mov	x0, x19
  410080:	52801ca1 	mov	w1, #0xe5                  	// #229
  410084:	97ffd478 	bl	405264 <assert_post_action>
  410088:	52801ca2 	mov	w2, #0xe5                  	// #229
  41008c:	17ffffe8 	b	41002c <z_impl_k_mutex_unlock+0x64>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
  410090:	7100041f 	cmp	w0, #0x1
  410094:	54000100 	b.eq	4100b4 <z_impl_k_mutex_unlock+0xec>  // b.none
		mutex->lock_count--;
  410098:	51000400 	sub	w0, w0, #0x1
  41009c:	b9001a60 	str	w0, [x19, #24]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
  4100a0:	52800000 	mov	w0, #0x0                   	// #0
}
  4100a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4100a8:	f94013f5 	ldr	x21, [sp, #32]
  4100ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4100b0:	d65f03c0 	ret
	return posix_irq_lock();
  4100b4:	97ffdd48 	bl	4075d4 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4100b8:	f00000f4 	adrp	x20, 42f000 <can_loopback_dev_data_0+0xc0>
  4100bc:	911da294 	add	x20, x20, #0x768
  4100c0:	2a0003f5 	mov	w21, w0
  4100c4:	aa1403e0 	mov	x0, x20
  4100c8:	97fffd3a 	bl	40f5b0 <z_spin_lock_valid>
  4100cc:	72001c1f 	tst	w0, #0xff
  4100d0:	54000261 	b.ne	41011c <z_impl_k_mutex_unlock+0x154>  // b.any
  4100d4:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4100d8:	9122ce73 	add	x19, x19, #0x8b3
  4100dc:	aa1303e2 	mov	x2, x19
  4100e0:	52801283 	mov	w3, #0x94                  	// #148
  4100e4:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4100e8:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4100ec:	91238021 	add	x1, x1, #0x8e0
  4100f0:	91353400 	add	x0, x0, #0xd4d
  4100f4:	97ffd432 	bl	4051bc <assert_print>
  4100f8:	aa1403e1 	mov	x1, x20
  4100fc:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410100:	9123d400 	add	x0, x0, #0x8f5
  410104:	97ffd42e 	bl	4051bc <assert_print>
  410108:	aa1303e0 	mov	x0, x19
  41010c:	52801281 	mov	w1, #0x94                  	// #148
  410110:	97ffd455 	bl	405264 <assert_post_action>
  410114:	52801282 	mov	w2, #0x94                  	// #148
  410118:	17ffffc5 	b	41002c <z_impl_k_mutex_unlock+0x64>
	z_spin_lock_set_owner(l);
  41011c:	aa1403e0 	mov	x0, x20
  410120:	97fffd3c 	bl	40f610 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  410124:	b9401e61 	ldr	w1, [x19, #28]
  410128:	f9400a60 	ldr	x0, [x19, #16]
  41012c:	97fffef0 	bl	40fcec <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  410130:	aa1303e0 	mov	x0, x19
  410134:	94000a7a 	bl	412b1c <z_unpend_first_thread>
	mutex->owner = new_owner;
  410138:	f9000a60 	str	x0, [x19, #16]
	if (new_owner != NULL) {
  41013c:	b4000120 	cbz	x0, 410160 <z_impl_k_mutex_unlock+0x198>
		mutex->owner_orig_prio = new_owner->base.prio;
  410140:	39c06801 	ldrsb	w1, [x0, #26]
  410144:	b9001e61 	str	w1, [x19, #28]
	thread->callee_saved.retval = value;
  410148:	b9004c1f 	str	wzr, [x0, #76]
		z_ready_thread(new_owner);
  41014c:	9400076b 	bl	411ef8 <z_ready_thread>
		z_reschedule(&lock, key);
  410150:	2a1503e1 	mov	w1, w21
  410154:	aa1403e0 	mov	x0, x20
  410158:	9400050d 	bl	41158c <z_reschedule>
  41015c:	17ffffd1 	b	4100a0 <z_impl_k_mutex_unlock+0xd8>
		mutex->lock_count = 0U;
  410160:	b9001a7f 	str	wzr, [x19, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410164:	aa1403e0 	mov	x0, x20
  410168:	97fffd1d 	bl	40f5dc <z_spin_unlock_valid>
  41016c:	72001c1f 	tst	w0, #0xff
  410170:	54000261 	b.ne	4101bc <z_impl_k_mutex_unlock+0x1f4>  // b.any
  410174:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410178:	9122ce73 	add	x19, x19, #0x8b3
  41017c:	aa1303e2 	mov	x2, x19
  410180:	52801863 	mov	w3, #0xc3                  	// #195
  410184:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410188:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41018c:	91255821 	add	x1, x1, #0x956
  410190:	91353400 	add	x0, x0, #0xd4d
  410194:	97ffd40a 	bl	4051bc <assert_print>
  410198:	aa1403e1 	mov	x1, x20
  41019c:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4101a0:	9125b400 	add	x0, x0, #0x96d
  4101a4:	97ffd406 	bl	4051bc <assert_print>
  4101a8:	aa1303e0 	mov	x0, x19
  4101ac:	52801861 	mov	w1, #0xc3                  	// #195
  4101b0:	97ffd42d 	bl	405264 <assert_post_action>
  4101b4:	52801862 	mov	w2, #0xc3                  	// #195
  4101b8:	17ffff9d 	b	41002c <z_impl_k_mutex_unlock+0x64>
	posix_irq_unlock(key);
  4101bc:	2a1503e0 	mov	w0, w21
  4101c0:	97ffdd07 	bl	4075dc <posix_irq_unlock>
  4101c4:	17ffffb7 	b	4100a0 <z_impl_k_mutex_unlock+0xd8>
		return -EINVAL;
  4101c8:	128002a0 	mov	w0, #0xffffffea            	// #-22
  4101cc:	17ffffb6 	b	4100a4 <z_impl_k_mutex_unlock+0xdc>
		return -EPERM;
  4101d0:	12800000 	mov	w0, #0xffffffff            	// #-1
  4101d4:	17ffffb4 	b	4100a4 <z_impl_k_mutex_unlock+0xdc>

00000000004101d8 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
  4101d8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4101dc:	910003fd 	mov	x29, sp
  4101e0:	a90153f3 	stp	x19, x20, [sp, #16]
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  4101e4:	91004014 	add	x20, x0, #0x10
{
  4101e8:	aa0003f3 	mov	x19, x0
  4101ec:	a9025bf5 	stp	x21, x22, [sp, #32]
  4101f0:	aa0103f5 	mov	x21, x1
  4101f4:	a90363f7 	stp	x23, x24, [sp, #48]
  4101f8:	aa0203f7 	mov	x23, x2
  4101fc:	12001c78 	and	w24, w3, #0xff
  410200:	f90023f9 	str	x25, [sp, #64]
  410204:	12001c99 	and	w25, w4, #0xff
	return posix_irq_lock();
  410208:	97ffdcf3 	bl	4075d4 <posix_irq_lock>
  41020c:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410210:	aa1403e0 	mov	x0, x20
  410214:	97fffce7 	bl	40f5b0 <z_spin_lock_valid>
  410218:	72001c1f 	tst	w0, #0xff
  41021c:	540002c1 	b.ne	410274 <queue_insert+0x9c>  // b.any
  410220:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410224:	9122ce73 	add	x19, x19, #0x8b3
  410228:	aa1303e2 	mov	x2, x19
  41022c:	52801283 	mov	w3, #0x94                  	// #148
  410230:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410234:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410238:	91238021 	add	x1, x1, #0x8e0
  41023c:	91353400 	add	x0, x0, #0xd4d
  410240:	97ffd3df 	bl	4051bc <assert_print>
  410244:	aa1403e1 	mov	x1, x20
  410248:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  41024c:	9123d400 	add	x0, x0, #0x8f5
  410250:	97ffd3db 	bl	4051bc <assert_print>
  410254:	aa1303e0 	mov	x0, x19
  410258:	52801281 	mov	w1, #0x94                  	// #148
  41025c:	97ffd402 	bl	405264 <assert_post_action>
  410260:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410264:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410268:	aa1303e1 	mov	x1, x19
  41026c:	91362c00 	add	x0, x0, #0xd8b
  410270:	97ffddef 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410274:	aa1403e0 	mov	x0, x20
  410278:	97fffce6 	bl	40f610 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
  41027c:	34000059 	cbz	w25, 410284 <queue_insert+0xac>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
  410280:	f9400675 	ldr	x21, [x19, #8]
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  410284:	91006260 	add	x0, x19, #0x18
  410288:	94000a25 	bl	412b1c <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
  41028c:	b4000120 	cbz	x0, 4102b0 <queue_insert+0xd8>
  410290:	f9001017 	str	x23, [x0, #32]
  410294:	b9004c1f 	str	wzr, [x0, #76]
	z_ready_thread(thread);
  410298:	94000718 	bl	411ef8 <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
  41029c:	aa1403e0 	mov	x0, x20
  4102a0:	2a1603e1 	mov	w1, w22
  4102a4:	940004ba 	bl	41158c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
  4102a8:	52800000 	mov	w0, #0x0                   	// #0
  4102ac:	1400001f 	b	410328 <queue_insert+0x150>
	if (alloc) {
  4102b0:	34000638 	cbz	w24, 410374 <queue_insert+0x19c>
	return z_thread_aligned_alloc(0, size);
  4102b4:	d2800201 	mov	x1, #0x10                  	// #16
  4102b8:	940010c9 	bl	4145dc <z_thread_aligned_alloc>
  4102bc:	aa0003e3 	mov	x3, x0
		if (anode == NULL) {
  4102c0:	b5000400 	cbnz	x0, 410340 <queue_insert+0x168>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4102c4:	aa1403e0 	mov	x0, x20
  4102c8:	97fffcc5 	bl	40f5dc <z_spin_unlock_valid>
  4102cc:	72001c1f 	tst	w0, #0xff
  4102d0:	54000261 	b.ne	41031c <queue_insert+0x144>  // b.any
  4102d4:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4102d8:	9122ce73 	add	x19, x19, #0x8b3
  4102dc:	aa1303e2 	mov	x2, x19
  4102e0:	52801863 	mov	w3, #0xc3                  	// #195
  4102e4:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4102e8:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4102ec:	91255821 	add	x1, x1, #0x956
  4102f0:	91353400 	add	x0, x0, #0xd4d
  4102f4:	97ffd3b2 	bl	4051bc <assert_print>
  4102f8:	aa1403e1 	mov	x1, x20
  4102fc:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410300:	9125b400 	add	x0, x0, #0x96d
  410304:	97ffd3ae 	bl	4051bc <assert_print>
  410308:	aa1303e0 	mov	x0, x19
  41030c:	52801861 	mov	w1, #0xc3                  	// #195
  410310:	97ffd3d5 	bl	405264 <assert_post_action>
  410314:	52801862 	mov	w2, #0xc3                  	// #195
  410318:	17ffffd3 	b	410264 <queue_insert+0x8c>
	posix_irq_unlock(key);
  41031c:	2a1603e0 	mov	w0, w22
  410320:	97ffdcaf 	bl	4075dc <posix_irq_unlock>
			return -ENOMEM;
  410324:	12800160 	mov	w0, #0xfffffff4            	// #-12
}
  410328:	a94153f3 	ldp	x19, x20, [sp, #16]
  41032c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410330:	a94363f7 	ldp	x23, x24, [sp, #48]
  410334:	f94023f9 	ldr	x25, [sp, #64]
  410338:	a8c57bfd 	ldp	x29, x30, [sp], #80
  41033c:	d65f03c0 	ret
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
  410340:	d2800020 	mov	x0, #0x1                   	// #1
		anode->data = data;
  410344:	a9005c60 	stp	x0, x23, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  410348:	f9400060 	ldr	x0, [x3]
	parent->next_and_flags = cur_flags | (unative_t)child;
  41034c:	92400400 	and	x0, x0, #0x3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
  410350:	b5000195 	cbnz	x21, 410380 <queue_insert+0x1a8>
	parent->next_and_flags = cur_flags | (unative_t)child;
  410354:	f9400261 	ldr	x1, [x19]
  410358:	aa000020 	orr	x0, x1, x0
  41035c:	f9000060 	str	x0, [x3]
	list->head = node;
  410360:	f9000263 	str	x3, [x19]
Z_GENLIST_PREPEND(sflist, sfnode)
  410364:	f9400660 	ldr	x0, [x19, #8]
  410368:	b50001a0 	cbnz	x0, 41039c <queue_insert+0x1c4>
	list->tail = node;
  41036c:	f9000663 	str	x3, [x19, #8]
}
  410370:	1400000b 	b	41039c <queue_insert+0x1c4>
}
  410374:	aa1703e3 	mov	x3, x23
	node->next_and_flags = flags;
  410378:	f90002ff 	str	xzr, [x23]
}
  41037c:	17fffff3 	b	410348 <queue_insert+0x170>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  410380:	f94002a2 	ldr	x2, [x21]
Z_GENLIST_INSERT(sflist, sfnode)
  410384:	f27ef442 	ands	x2, x2, #0xfffffffffffffffc
  410388:	540001c1 	b.ne	4103c0 <queue_insert+0x1e8>  // b.any
	parent->next_and_flags = cur_flags | (unative_t)child;
  41038c:	f9000060 	str	x0, [x3]
	return list->tail;
  410390:	f9400661 	ldr	x1, [x19, #8]
Z_GENLIST_APPEND(sflist, sfnode)
  410394:	b50000c1 	cbnz	x1, 4103ac <queue_insert+0x1d4>
	list->tail = node;
  410398:	a9000e63 	stp	x3, x3, [x19]
	z_handle_obj_poll_events(&queue->poll_events, state);
  41039c:	9100a260 	add	x0, x19, #0x28
  4103a0:	52800081 	mov	w1, #0x4                   	// #4
  4103a4:	94000f96 	bl	4141fc <z_handle_obj_poll_events>
  4103a8:	17ffffbd 	b	41029c <queue_insert+0xc4>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  4103ac:	f9400020 	ldr	x0, [x1]
	parent->next_and_flags = cur_flags | (unative_t)child;
  4103b0:	92400400 	and	x0, x0, #0x3
  4103b4:	aa000060 	orr	x0, x3, x0
  4103b8:	f9000020 	str	x0, [x1]
  4103bc:	17ffffec 	b	41036c <queue_insert+0x194>
  4103c0:	aa000042 	orr	x2, x2, x0
  4103c4:	f9000062 	str	x2, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  4103c8:	f94002a0 	ldr	x0, [x21]
	parent->next_and_flags = cur_flags | (unative_t)child;
  4103cc:	92400400 	and	x0, x0, #0x3
  4103d0:	aa000063 	orr	x3, x3, x0
  4103d4:	f90002a3 	str	x3, [x21]
}
  4103d8:	17fffff1 	b	41039c <queue_insert+0x1c4>

00000000004103dc <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
  4103dc:	aa0103e2 	mov	x2, x1
  4103e0:	52800004 	mov	w4, #0x0                   	// #0
  4103e4:	52800003 	mov	w3, #0x0                   	// #0
  4103e8:	d2800001 	mov	x1, #0x0                   	// #0
  4103ec:	17ffff7b 	b	4101d8 <queue_insert>

00000000004103f0 <z_impl_k_sem_init>:
		      unsigned int limit)
{
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
  4103f0:	7100005f 	cmp	w2, #0x0
  4103f4:	7a411040 	ccmp	w2, w1, #0x0, ne  // ne = any
  4103f8:	540000e3 	b.cc	410414 <z_impl_k_sem_init+0x24>  // b.lo, b.ul, b.last
	list->tail = (sys_dnode_t *)list;
  4103fc:	a9000000 	stp	x0, x0, [x0]

		return -EINVAL;
	}

	sem->count = initial_count;
	sem->limit = limit;
  410400:	29020801 	stp	w1, w2, [x0, #16]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
  410404:	91006001 	add	x1, x0, #0x18
  410408:	a9018401 	stp	x1, x1, [x0, #24]
#endif
	z_object_init(sem);

	return 0;
  41040c:	52800000 	mov	w0, #0x0                   	// #0
}
  410410:	d65f03c0 	ret
		return -EINVAL;
  410414:	128002a0 	mov	w0, #0xffffffea            	// #-22
  410418:	17fffffe 	b	410410 <z_impl_k_sem_init+0x20>

000000000041041c <z_impl_k_sem_give>:
	return false;
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  41041c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410420:	910003fd 	mov	x29, sp
  410424:	a90153f3 	stp	x19, x20, [sp, #16]
  410428:	aa0003f3 	mov	x19, x0
  41042c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  410430:	97ffdc69 	bl	4075d4 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410434:	f00000f6 	adrp	x22, 42f000 <can_loopback_dev_data_0+0xc0>
  410438:	911dc2d5 	add	x21, x22, #0x770
  41043c:	2a0003f4 	mov	w20, w0
  410440:	aa1503e0 	mov	x0, x21
  410444:	97fffc5b 	bl	40f5b0 <z_spin_lock_valid>
  410448:	72001c1f 	tst	w0, #0xff
  41044c:	540002c1 	b.ne	4104a4 <z_impl_k_sem_give+0x88>  // b.any
  410450:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410454:	9122ce73 	add	x19, x19, #0x8b3
  410458:	aa1303e2 	mov	x2, x19
  41045c:	52801283 	mov	w3, #0x94                  	// #148
  410460:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410464:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410468:	91238021 	add	x1, x1, #0x8e0
  41046c:	91353400 	add	x0, x0, #0xd4d
  410470:	97ffd353 	bl	4051bc <assert_print>
  410474:	aa1503e1 	mov	x1, x21
  410478:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  41047c:	9123d400 	add	x0, x0, #0x8f5
  410480:	97ffd34f 	bl	4051bc <assert_print>
  410484:	aa1303e0 	mov	x0, x19
  410488:	52801281 	mov	w1, #0x94                  	// #148
  41048c:	97ffd376 	bl	405264 <assert_post_action>
  410490:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410494:	aa1303e1 	mov	x1, x19
  410498:	91362c00 	add	x0, x0, #0xd8b
  41049c:	52801282 	mov	w2, #0x94                  	// #148
  4104a0:	97ffdd63 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4104a4:	aa1503e0 	mov	x0, x21
  4104a8:	97fffc5a 	bl	40f610 <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool resched = true;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
  4104ac:	aa1303e0 	mov	x0, x19
  4104b0:	9400099b 	bl	412b1c <z_unpend_first_thread>

	if (thread != NULL) {
  4104b4:	b4000120 	cbz	x0, 4104d8 <z_impl_k_sem_give+0xbc>
  4104b8:	b9004c1f 	str	wzr, [x0, #76]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
  4104bc:	9400068f 	bl	411ef8 <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		resched = handle_poll_events(sem);
	}

	if (resched) {
		z_reschedule(&lock, key);
  4104c0:	2a1403e1 	mov	w1, w20
  4104c4:	911dc2c0 	add	x0, x22, #0x770
	} else {
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
  4104c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4104cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4104d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&lock, key);
  4104d4:	1400042e 	b	41158c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  4104d8:	29420262 	ldp	w2, w0, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  4104dc:	52800041 	mov	w1, #0x2                   	// #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  4104e0:	6b02001f 	cmp	w0, w2
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  4104e4:	91006260 	add	x0, x19, #0x18
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  4104e8:	1a820442 	cinc	w2, w2, ne  // ne = any
  4104ec:	b9001262 	str	w2, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  4104f0:	94000f43 	bl	4141fc <z_handle_obj_poll_events>
	return true;
  4104f4:	17fffff3 	b	4104c0 <z_impl_k_sem_give+0xa4>

00000000004104f8 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
  4104f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4104fc:	910003fd 	mov	x29, sp
  410500:	a9025bf5 	stp	x21, x22, [sp, #32]
  410504:	aa0003f5 	mov	x21, x0
	return _kernel.cpus[0].nested != 0U;
  410508:	900000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  41050c:	a90153f3 	stp	x19, x20, [sp, #16]
  410510:	aa0103f6 	mov	x22, x1
  410514:	f9474000 	ldr	x0, [x0, #3712]
  410518:	f9001bf7 	str	x23, [sp, #48]
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
  41051c:	b9400000 	ldr	w0, [x0]
  410520:	34000280 	cbz	w0, 410570 <z_impl_k_sem_take+0x78>
  410524:	b4000261 	cbz	x1, 410570 <z_impl_k_sem_take+0x78>
  410528:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  41052c:	91304673 	add	x19, x19, #0xc11
  410530:	aa1303e2 	mov	x2, x19
  410534:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410538:	9130c421 	add	x1, x1, #0xc31
  41053c:	52801003 	mov	w3, #0x80                  	// #128
  410540:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410544:	91353400 	add	x0, x0, #0xd4d
  410548:	97ffd31d 	bl	4051bc <assert_print>
  41054c:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410550:	91254c00 	add	x0, x0, #0x953
  410554:	97ffd31a 	bl	4051bc <assert_print>
  410558:	aa1303e0 	mov	x0, x19
  41055c:	52801001 	mov	w1, #0x80                  	// #128
  410560:	97ffd341 	bl	405264 <assert_post_action>
  410564:	52801002 	mov	w2, #0x80                  	// #128
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410568:	aa1303e1 	mov	x1, x19
  41056c:	1400001b 	b	4105d8 <z_impl_k_sem_take+0xe0>
  410570:	97ffdc19 	bl	4075d4 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410574:	f00000f7 	adrp	x23, 42f000 <can_loopback_dev_data_0+0xc0>
  410578:	911dc2f3 	add	x19, x23, #0x770
  41057c:	2a0003f4 	mov	w20, w0
  410580:	aa1303e0 	mov	x0, x19
  410584:	97fffc0b 	bl	40f5b0 <z_spin_lock_valid>
  410588:	72001c1f 	tst	w0, #0xff
  41058c:	540002c1 	b.ne	4105e4 <z_impl_k_sem_take+0xec>  // b.any
  410590:	d0000034 	adrp	x20, 416000 <__func__.0+0x57a>
  410594:	9122ce94 	add	x20, x20, #0x8b3
  410598:	aa1403e2 	mov	x2, x20
  41059c:	52801283 	mov	w3, #0x94                  	// #148
  4105a0:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4105a4:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4105a8:	91238021 	add	x1, x1, #0x8e0
  4105ac:	91353400 	add	x0, x0, #0xd4d
  4105b0:	97ffd303 	bl	4051bc <assert_print>
  4105b4:	aa1303e1 	mov	x1, x19
  4105b8:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4105bc:	9123d400 	add	x0, x0, #0x8f5
  4105c0:	97ffd2ff 	bl	4051bc <assert_print>
  4105c4:	52801281 	mov	w1, #0x94                  	// #148
  4105c8:	aa1403e0 	mov	x0, x20
  4105cc:	97ffd326 	bl	405264 <assert_post_action>
  4105d0:	aa1403e1 	mov	x1, x20
  4105d4:	52801282 	mov	w2, #0x94                  	// #148
  4105d8:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4105dc:	91362c00 	add	x0, x0, #0xd8b
  4105e0:	97ffdd13 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4105e4:	aa1303e0 	mov	x0, x19
  4105e8:	97fffc0a 	bl	40f610 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
  4105ec:	b94012a0 	ldr	w0, [x21, #16]
  4105f0:	34000420 	cbz	w0, 410674 <z_impl_k_sem_take+0x17c>
		sem->count--;
  4105f4:	51000400 	sub	w0, w0, #0x1
  4105f8:	b90012a0 	str	w0, [x21, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4105fc:	aa1303e0 	mov	x0, x19
  410600:	97fffbf7 	bl	40f5dc <z_spin_unlock_valid>
  410604:	72001c1f 	tst	w0, #0xff
  410608:	54000261 	b.ne	410654 <z_impl_k_sem_take+0x15c>  // b.any
  41060c:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410610:	9122ce73 	add	x19, x19, #0x8b3
  410614:	aa1303e2 	mov	x2, x19
  410618:	52801863 	mov	w3, #0xc3                  	// #195
  41061c:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410620:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410624:	91255821 	add	x1, x1, #0x956
  410628:	91353400 	add	x0, x0, #0xd4d
  41062c:	97ffd2e4 	bl	4051bc <assert_print>
  410630:	911dc2e1 	add	x1, x23, #0x770
  410634:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410638:	9125b400 	add	x0, x0, #0x96d
  41063c:	97ffd2e0 	bl	4051bc <assert_print>
  410640:	aa1303e0 	mov	x0, x19
  410644:	52801861 	mov	w1, #0xc3                  	// #195
  410648:	97ffd307 	bl	405264 <assert_post_action>
  41064c:	52801862 	mov	w2, #0xc3                  	// #195
  410650:	17ffffc6 	b	410568 <z_impl_k_sem_take+0x70>
	posix_irq_unlock(key);
  410654:	2a1403e0 	mov	w0, w20
  410658:	97ffdbe1 	bl	4075dc <posix_irq_unlock>
		k_spin_unlock(&lock, key);
		ret = 0;
  41065c:	52800000 	mov	w0, #0x0                   	// #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
  410660:	a94153f3 	ldp	x19, x20, [sp, #16]
  410664:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410668:	f9401bf7 	ldr	x23, [sp, #48]
  41066c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  410670:	d65f03c0 	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  410674:	b5000136 	cbnz	x22, 410698 <z_impl_k_sem_take+0x1a0>
  410678:	aa1303e0 	mov	x0, x19
  41067c:	97fffbd8 	bl	40f5dc <z_spin_unlock_valid>
  410680:	72001c1f 	tst	w0, #0xff
  410684:	54fffc40 	b.eq	41060c <z_impl_k_sem_take+0x114>  // b.none
  410688:	2a1403e0 	mov	w0, w20
  41068c:	97ffdbd4 	bl	4075dc <posix_irq_unlock>
		ret = -EBUSY;
  410690:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  410694:	17fffff3 	b	410660 <z_impl_k_sem_take+0x168>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  410698:	aa1603e3 	mov	x3, x22
  41069c:	aa1503e2 	mov	x2, x21
  4106a0:	2a1403e1 	mov	w1, w20
  4106a4:	aa1303e0 	mov	x0, x19
}
  4106a8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4106ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4106b0:	f9401bf7 	ldr	x23, [sp, #48]
  4106b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  4106b8:	14000759 	b	41241c <z_pend_curr>

00000000004106bc <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
  4106bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4106c0:	910003fd 	mov	x29, sp
  4106c4:	a90153f3 	stp	x19, x20, [sp, #16]
  4106c8:	aa0003f3 	mov	x19, x0
  4106cc:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  4106d0:	97ffdbc1 	bl	4075d4 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4106d4:	f00000f6 	adrp	x22, 42f000 <can_loopback_dev_data_0+0xc0>
  4106d8:	911dc2d5 	add	x21, x22, #0x770
  4106dc:	2a0003f4 	mov	w20, w0
  4106e0:	aa1503e0 	mov	x0, x21
  4106e4:	97fffbb3 	bl	40f5b0 <z_spin_lock_valid>
  4106e8:	72001c1f 	tst	w0, #0xff
  4106ec:	540002c1 	b.ne	410744 <z_impl_k_sem_reset+0x88>  // b.any
  4106f0:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4106f4:	9122ce73 	add	x19, x19, #0x8b3
  4106f8:	aa1303e2 	mov	x2, x19
  4106fc:	52801283 	mov	w3, #0x94                  	// #148
  410700:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410704:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410708:	91238021 	add	x1, x1, #0x8e0
  41070c:	91353400 	add	x0, x0, #0xd4d
  410710:	97ffd2ab 	bl	4051bc <assert_print>
  410714:	aa1503e1 	mov	x1, x21
  410718:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  41071c:	9123d400 	add	x0, x0, #0x8f5
  410720:	97ffd2a7 	bl	4051bc <assert_print>
  410724:	aa1303e0 	mov	x0, x19
  410728:	52801281 	mov	w1, #0x94                  	// #148
  41072c:	97ffd2ce 	bl	405264 <assert_post_action>
  410730:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410734:	aa1303e1 	mov	x1, x19
  410738:	91362c00 	add	x0, x0, #0xd8b
  41073c:	52801282 	mov	w2, #0x94                  	// #148
  410740:	97ffdcbb 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410744:	aa1503e0 	mov	x0, x21
	thread->callee_saved.retval = value;
  410748:	12800155 	mov	w21, #0xfffffff5            	// #-11
  41074c:	97fffbb1 	bl	40f610 <z_spin_lock_set_owner>
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
  410750:	aa1303e0 	mov	x0, x19
  410754:	940008f2 	bl	412b1c <z_unpend_first_thread>
		if (thread == NULL) {
  410758:	b4000080 	cbz	x0, 410768 <z_impl_k_sem_reset+0xac>
  41075c:	b9004c15 	str	w21, [x0, #76]
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
  410760:	940005e6 	bl	411ef8 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
  410764:	17fffffb 	b	410750 <z_impl_k_sem_reset+0x94>
	}
	sem->count = 0;
  410768:	b900127f 	str	wzr, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  41076c:	91006260 	add	x0, x19, #0x18
  410770:	52800041 	mov	w1, #0x2                   	// #2
  410774:	94000ea2 	bl	4141fc <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
  410778:	2a1403e1 	mov	w1, w20
  41077c:	911dc2c0 	add	x0, x22, #0x770
}
  410780:	a94153f3 	ldp	x19, x20, [sp, #16]
  410784:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410788:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&lock, key);
  41078c:	14000380 	b	41158c <z_reschedule>

0000000000410790 <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
  410790:	b9400002 	ldr	w2, [x0]
	*flagp &= ~BIT(bit);
  410794:	d2800023 	mov	x3, #0x1                   	// #1
  410798:	9ac12063 	lsl	x3, x3, x1
  41079c:	0a230043 	bic	w3, w2, w3
  4107a0:	b9000003 	str	w3, [x0]
	return (*flagp & BIT(bit)) != 0U;
  4107a4:	2a0203e0 	mov	w0, w2
  4107a8:	9ac12400 	lsr	x0, x0, x1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
  4107ac:	12000000 	and	w0, w0, #0x1
  4107b0:	d65f03c0 	ret

00000000004107b4 <unschedule_locked>:
 *
 * @return true if and only if work had been delayed so the timeout
 * was cancelled.
 */
static inline bool unschedule_locked(struct k_work_delayable *dwork)
{
  4107b4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4107b8:	aa0003e4 	mov	x4, x0
	/* If scheduled, try to cancel.  If it fails, that means the
	 * callback has been dequeued and will inevitably run (or has
	 * already run), so treat that as "undelayed" and return
	 * false.
	 */
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
  4107bc:	52800061 	mov	w1, #0x3                   	// #3
{
  4107c0:	910003fd 	mov	x29, sp
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
  4107c4:	91006000 	add	x0, x0, #0x18
  4107c8:	97fffff2 	bl	410790 <flag_test_and_clear>
  4107cc:	72001c00 	ands	w0, w0, #0xff
  4107d0:	540000a0 	b.eq	4107e4 <unschedule_locked+0x30>  // b.none
		ret = z_abort_timeout(&dwork->timeout) == 0;
  4107d4:	91008080 	add	x0, x4, #0x20
  4107d8:	94000d26 	bl	413c70 <z_abort_timeout>
  4107dc:	7100001f 	cmp	w0, #0x0
  4107e0:	1a9f17e0 	cset	w0, eq  // eq = none
	}

	return ret;
}
  4107e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4107e8:	d65f03c0 	ret

00000000004107ec <notify_queue_locked.isra.0>:
	if (queue != NULL) {
  4107ec:	b40000a0 	cbz	x0, 410800 <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
  4107f0:	91034000 	add	x0, x0, #0xd0
  4107f4:	d2800002 	mov	x2, #0x0                   	// #0
  4107f8:	52800001 	mov	w1, #0x0                   	// #0
  4107fc:	14000ba3 	b	413688 <z_sched_wake>
}
  410800:	d65f03c0 	ret

0000000000410804 <work_queue_main>:
{
  410804:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  410808:	910003fd 	mov	x29, sp
  41080c:	a90153f3 	stp	x19, x20, [sp, #16]
  410810:	aa0003f3 	mov	x19, x0
  410814:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410818:	f00000f5 	adrp	x21, 42f000 <can_loopback_dev_data_0+0xc0>
  41081c:	a90363f7 	stp	x23, x24, [sp, #48]
	return list->head;
  410820:	f00000f8 	adrp	x24, 42f000 <can_loopback_dev_data_0+0xc0>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
  410824:	911e0316 	add	x22, x24, #0x780
  410828:	a9046bf9 	stp	x25, x26, [sp, #64]
  41082c:	97ffdb6a 	bl	4075d4 <posix_irq_lock>
  410830:	911de2b4 	add	x20, x21, #0x778
  410834:	2a0003f7 	mov	w23, w0
  410838:	aa1403e0 	mov	x0, x20
  41083c:	97fffb5d 	bl	40f5b0 <z_spin_lock_valid>
  410840:	72001c1f 	tst	w0, #0xff
  410844:	540002c1 	b.ne	41089c <work_queue_main+0x98>  // b.any
  410848:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  41084c:	9122ce73 	add	x19, x19, #0x8b3
  410850:	aa1303e2 	mov	x2, x19
  410854:	52801283 	mov	w3, #0x94                  	// #148
  410858:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  41085c:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410860:	91238021 	add	x1, x1, #0x8e0
  410864:	91353400 	add	x0, x0, #0xd4d
  410868:	97ffd255 	bl	4051bc <assert_print>
  41086c:	911de2a1 	add	x1, x21, #0x778
  410870:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410874:	9123d400 	add	x0, x0, #0x8f5
  410878:	97ffd251 	bl	4051bc <assert_print>
  41087c:	aa1303e0 	mov	x0, x19
  410880:	52801281 	mov	w1, #0x94                  	// #148
  410884:	97ffd278 	bl	405264 <assert_post_action>
  410888:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41088c:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410890:	aa1303e1 	mov	x1, x19
  410894:	91362c00 	add	x0, x0, #0xd8b
  410898:	97ffdc65 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  41089c:	aa1403e0 	mov	x0, x20
  4108a0:	97fffb5c 	bl	40f610 <z_spin_lock_set_owner>
	return list->head;
  4108a4:	f9406274 	ldr	x20, [x19, #192]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
  4108a8:	b50001b4 	cbnz	x20, 4108dc <work_queue_main+0xd8>
		} else if (flag_test_and_clear(&queue->flags,
  4108ac:	9103c260 	add	x0, x19, #0xf0
  4108b0:	52800041 	mov	w1, #0x2                   	// #2
  4108b4:	97ffffb7 	bl	410790 <flag_test_and_clear>
  4108b8:	72001c1f 	tst	w0, #0xff
  4108bc:	54000581 	b.ne	41096c <work_queue_main+0x168>  // b.any
			(void)z_sched_wait(&lock, key, &queue->notifyq,
  4108c0:	91034262 	add	x2, x19, #0xd0
  4108c4:	2a1703e1 	mov	w1, w23
  4108c8:	911de2a0 	add	x0, x21, #0x778
  4108cc:	d2800004 	mov	x4, #0x0                   	// #0
  4108d0:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  4108d4:	94000bc3 	bl	4137e0 <z_sched_wait>
			continue;
  4108d8:	17ffffd5 	b	41082c <work_queue_main+0x28>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  4108dc:	f9406661 	ldr	x1, [x19, #200]
	return node->next;
  4108e0:	f9400280 	ldr	x0, [x20]
	list->head = node;
  4108e4:	f9006260 	str	x0, [x19, #192]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  4108e8:	eb01029f 	cmp	x20, x1
  4108ec:	54000041 	b.ne	4108f4 <work_queue_main+0xf0>  // b.any
	list->tail = node;
  4108f0:	f9006660 	str	x0, [x19, #200]
	*flagp |= BIT(bit);
  4108f4:	b940f260 	ldr	w0, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4108f8:	911de2b9 	add	x25, x21, #0x778
  4108fc:	321f0000 	orr	w0, w0, #0x2
  410900:	b900f260 	str	w0, [x19, #240]
  410904:	aa1903e0 	mov	x0, x25
	*flagp &= ~BIT(bit);
  410908:	b9401a82 	ldr	w2, [x20, #24]
			handler = work->handler;
  41090c:	f940069a 	ldr	x26, [x20, #8]
	*flagp &= ~BIT(bit);
  410910:	121d7842 	and	w2, w2, #0xfffffffb
  410914:	32000042 	orr	w2, w2, #0x1
  410918:	b9001a82 	str	w2, [x20, #24]
  41091c:	97fffb30 	bl	40f5dc <z_spin_unlock_valid>
  410920:	72001c1f 	tst	w0, #0xff
  410924:	54000600 	b.eq	4109e4 <work_queue_main+0x1e0>  // b.none
	posix_irq_unlock(key);
  410928:	2a1703e0 	mov	w0, w23
  41092c:	97ffdb2c 	bl	4075dc <posix_irq_unlock>
		__ASSERT_NO_MSG(handler != NULL);
  410930:	b50002fa 	cbnz	x26, 41098c <work_queue_main+0x188>
  410934:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410938:	9131fe73 	add	x19, x19, #0xc7f
  41093c:	aa1303e2 	mov	x2, x19
  410940:	52805363 	mov	w3, #0x29b                 	// #667
  410944:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410948:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41094c:	91328021 	add	x1, x1, #0xca0
  410950:	91353400 	add	x0, x0, #0xd4d
  410954:	97ffd21a 	bl	4051bc <assert_print>
  410958:	aa1303e0 	mov	x0, x19
  41095c:	52805361 	mov	w1, #0x29b                 	// #667
  410960:	97ffd241 	bl	405264 <assert_post_action>
  410964:	52805362 	mov	w2, #0x29b                 	// #667
  410968:	17ffffc9 	b	41088c <work_queue_main+0x88>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
  41096c:	91038274 	add	x20, x19, #0xe0
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
  410970:	aa1403e0 	mov	x0, x20
  410974:	d2800002 	mov	x2, #0x0                   	// #0
  410978:	52800021 	mov	w1, #0x1                   	// #1
  41097c:	94000b43 	bl	413688 <z_sched_wake>
  410980:	72001c1f 	tst	w0, #0xff
  410984:	54ffff61 	b.ne	410970 <work_queue_main+0x16c>  // b.any
  410988:	17ffffce 	b	4108c0 <work_queue_main+0xbc>
		handler(work);
  41098c:	aa1403e0 	mov	x0, x20
  410990:	d63f0340 	blr	x26
	return posix_irq_lock();
  410994:	97ffdb10 	bl	4075d4 <posix_irq_lock>
  410998:	2a0003f7 	mov	w23, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41099c:	aa1903e0 	mov	x0, x25
  4109a0:	97fffb04 	bl	40f5b0 <z_spin_lock_valid>
  4109a4:	72001c1f 	tst	w0, #0xff
  4109a8:	54fff500 	b.eq	410848 <work_queue_main+0x44>  // b.none
	z_spin_lock_set_owner(l);
  4109ac:	aa1903e0 	mov	x0, x25
  4109b0:	97fffb18 	bl	40f610 <z_spin_lock_set_owner>
	*flagp &= ~BIT(bit);
  4109b4:	b9401a80 	ldr	w0, [x20, #24]
  4109b8:	121f7801 	and	w1, w0, #0xfffffffe
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  4109bc:	37080380 	tbnz	w0, #1, 410a2c <work_queue_main+0x228>
	*flagp &= ~BIT(bit);
  4109c0:	b9001a81 	str	w1, [x20, #24]
  4109c4:	b940f261 	ldr	w1, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4109c8:	911de2a0 	add	x0, x21, #0x778
  4109cc:	121e7821 	and	w1, w1, #0xfffffffd
  4109d0:	b900f261 	str	w1, [x19, #240]
	return (*flagp & BIT(bit)) != 0U;
  4109d4:	d3482034 	ubfx	x20, x1, #8, #1
  4109d8:	97fffb01 	bl	40f5dc <z_spin_unlock_valid>
  4109dc:	72001c1f 	tst	w0, #0xff
  4109e0:	54000641 	b.ne	410aa8 <work_queue_main+0x2a4>  // b.any
  4109e4:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4109e8:	9122ce73 	add	x19, x19, #0x8b3
  4109ec:	aa1303e2 	mov	x2, x19
  4109f0:	52801863 	mov	w3, #0xc3                  	// #195
  4109f4:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4109f8:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4109fc:	91255821 	add	x1, x1, #0x956
  410a00:	91353400 	add	x0, x0, #0xd4d
  410a04:	97ffd1ee 	bl	4051bc <assert_print>
  410a08:	911de2a1 	add	x1, x21, #0x778
  410a0c:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410a10:	9125b400 	add	x0, x0, #0x96d
  410a14:	97ffd1ea 	bl	4051bc <assert_print>
  410a18:	aa1303e0 	mov	x0, x19
  410a1c:	52801861 	mov	w1, #0xc3                  	// #195
  410a20:	97ffd211 	bl	405264 <assert_post_action>
  410a24:	52801862 	mov	w2, #0xc3                  	// #195
  410a28:	17ffff99 	b	41088c <work_queue_main+0x88>
	*flagp &= ~BIT(bit);
  410a2c:	121e7400 	and	w0, w0, #0xfffffffc
  410a30:	b9001a80 	str	w0, [x20, #24]
	return list->head;
  410a34:	f943c300 	ldr	x0, [x24, #1920]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  410a38:	b4fffc60 	cbz	x0, 4109c4 <work_queue_main+0x1c0>
	return node->next;
  410a3c:	f940001a 	ldr	x26, [x0]
  410a40:	d2800019 	mov	x25, #0x0                   	// #0
		if (wc->work == work) {
  410a44:	f9400402 	ldr	x2, [x0, #8]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
  410a48:	aa0003e1 	mov	x1, x0
		if (wc->work == work) {
  410a4c:	eb02029f 	cmp	x20, x2
  410a50:	54000161 	b.ne	410a7c <work_queue_main+0x278>  // b.any
  410a54:	f9400001 	ldr	x1, [x0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
  410a58:	b50001d9 	cbnz	x25, 410a90 <work_queue_main+0x28c>
  410a5c:	f94006c2 	ldr	x2, [x22, #8]
	list->head = node;
  410a60:	f90002c1 	str	x1, [x22]
Z_GENLIST_REMOVE(slist, snode)
  410a64:	eb00005f 	cmp	x2, x0
  410a68:	54000041 	b.ne	410a70 <work_queue_main+0x26c>  // b.any
	list->tail = node;
  410a6c:	f90006c1 	str	x1, [x22, #8]
	parent->next = child;
  410a70:	f801041f 	str	xzr, [x0], #16
	z_impl_k_sem_give(sem);
  410a74:	97fffe6a 	bl	41041c <z_impl_k_sem_give>
}
  410a78:	aa1903e1 	mov	x1, x25
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  410a7c:	b4fffa5a 	cbz	x26, 4109c4 <work_queue_main+0x1c0>
	return node->next;
  410a80:	aa1a03e0 	mov	x0, x26
  410a84:	aa0103f9 	mov	x25, x1
  410a88:	f940035a 	ldr	x26, [x26]
  410a8c:	17ffffee 	b	410a44 <work_queue_main+0x240>
	parent->next = child;
  410a90:	f9000321 	str	x1, [x25]
Z_GENLIST_REMOVE(slist, snode)
  410a94:	f94006c1 	ldr	x1, [x22, #8]
  410a98:	eb00003f 	cmp	x1, x0
  410a9c:	54fffea1 	b.ne	410a70 <work_queue_main+0x26c>  // b.any
	list->tail = node;
  410aa0:	f90006d9 	str	x25, [x22, #8]
}
  410aa4:	17fffff3 	b	410a70 <work_queue_main+0x26c>
	posix_irq_unlock(key);
  410aa8:	2a1703e0 	mov	w0, w23
  410aac:	97ffdacc 	bl	4075dc <posix_irq_unlock>
		if (yield) {
  410ab0:	35ffebf4 	cbnz	w20, 41082c <work_queue_main+0x28>
	z_impl_k_yield();
  410ab4:	9400086b 	bl	412c60 <z_impl_k_yield>
}
  410ab8:	17ffff5d 	b	41082c <work_queue_main+0x28>

0000000000410abc <submit_to_queue_locked>:
{
  410abc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410ac0:	910003fd 	mov	x29, sp
  410ac4:	a90153f3 	stp	x19, x20, [sp, #16]
  410ac8:	aa0003f3 	mov	x19, x0
  410acc:	aa0103f4 	mov	x20, x1
  410ad0:	a9025bf5 	stp	x21, x22, [sp, #32]
	return (*flagp & BIT(bit)) != 0U;
  410ad4:	b9401800 	ldr	w0, [x0, #24]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  410ad8:	721f001f 	tst	w0, #0x2
  410adc:	54000941 	b.ne	410c04 <submit_to_queue_locked+0x148>  // b.any
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
  410ae0:	721e001f 	tst	w0, #0x4
  410ae4:	54000961 	b.ne	410c10 <submit_to_queue_locked+0x154>  // b.any
		if (*queuep == NULL) {
  410ae8:	f9400020 	ldr	x0, [x1]
  410aec:	b5000060 	cbnz	x0, 410af8 <submit_to_queue_locked+0x3c>
			*queuep = work->queue;
  410af0:	f9400a60 	ldr	x0, [x19, #16]
  410af4:	f9000020 	str	x0, [x1]
	return (*flagp & BIT(bit)) != 0U;
  410af8:	b9401a60 	ldr	w0, [x19, #24]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
  410afc:	36000760 	tbz	w0, #0, 410be8 <submit_to_queue_locked+0x12c>
			__ASSERT_NO_MSG(work->queue != NULL);
  410b00:	f9400a60 	ldr	x0, [x19, #16]
  410b04:	b5000240 	cbnz	x0, 410b4c <submit_to_queue_locked+0x90>
  410b08:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410b0c:	9131fe73 	add	x19, x19, #0xc7f
  410b10:	aa1303e2 	mov	x2, x19
  410b14:	528029c3 	mov	w3, #0x14e                 	// #334
  410b18:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410b1c:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410b20:	9132dc21 	add	x1, x1, #0xcb7
  410b24:	91353400 	add	x0, x0, #0xd4d
  410b28:	97ffd1a5 	bl	4051bc <assert_print>
  410b2c:	aa1303e0 	mov	x0, x19
  410b30:	528029c1 	mov	w1, #0x14e                 	// #334
  410b34:	97ffd1cc 	bl	405264 <assert_post_action>
  410b38:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410b3c:	aa1303e1 	mov	x1, x19
  410b40:	91362c00 	add	x0, x0, #0xd8b
  410b44:	528029c2 	mov	w2, #0x14e                 	// #334
  410b48:	97ffdbb9 	bl	407a2c <posix_print_error_and_exit>
			ret = 2;
  410b4c:	52800056 	mov	w22, #0x2                   	// #2
			*queuep = work->queue;
  410b50:	f9000280 	str	x0, [x20]
		int rc = queue_submit_locked(*queuep, work);
  410b54:	f9400295 	ldr	x21, [x20]
	if (queue == NULL) {
  410b58:	b4000615 	cbz	x21, 410c18 <submit_to_queue_locked+0x15c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  410b5c:	900000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  410b60:	f9474000 	ldr	x0, [x0, #3712]
  410b64:	f9400800 	ldr	x0, [x0, #16]
  410b68:	eb15001f 	cmp	x0, x21
  410b6c:	54000421 	b.ne	410bf0 <submit_to_queue_locked+0x134>  // b.any
  410b70:	97fff983 	bl	40f17c <k_is_in_isr>
  410b74:	12001c00 	and	w0, w0, #0xff
  410b78:	52000000 	eor	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  410b7c:	b940f2a2 	ldr	w2, [x21, #240]
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  410b80:	12000000 	and	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  410b84:	d3420841 	ubfx	x1, x2, #2, #1
  410b88:	d3430c43 	ubfx	x3, x2, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
  410b8c:	360004a2 	tbz	w2, #0, 410c20 <submit_to_queue_locked+0x164>
	} else if (draining && !chained) {
  410b90:	52000000 	eor	w0, w0, #0x1
  410b94:	6a00003f 	tst	w1, w0
  410b98:	54000361 	b.ne	410c04 <submit_to_queue_locked+0x148>  // b.any
	} else if (plugged && !draining) {
  410b9c:	52000021 	eor	w1, w1, #0x1
  410ba0:	6a01007f 	tst	w3, w1
  410ba4:	54000301 	b.ne	410c04 <submit_to_queue_locked+0x148>  // b.any
	parent->next = child;
  410ba8:	f900027f 	str	xzr, [x19]
	return list->tail;
  410bac:	f94066a0 	ldr	x0, [x21, #200]
Z_GENLIST_APPEND(slist, snode)
  410bb0:	b5000240 	cbnz	x0, 410bf8 <submit_to_queue_locked+0x13c>
	list->tail = node;
  410bb4:	a90c4eb3 	stp	x19, x19, [x21, #192]
		(void)notify_queue_locked(queue);
  410bb8:	aa1503e0 	mov	x0, x21
  410bbc:	97ffff0c 	bl	4107ec <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
  410bc0:	b9401a60 	ldr	w0, [x19, #24]
  410bc4:	321e0000 	orr	w0, w0, #0x4
  410bc8:	b9001a60 	str	w0, [x19, #24]
			work->queue = *queuep;
  410bcc:	f9400280 	ldr	x0, [x20]
  410bd0:	f9000a60 	str	x0, [x19, #16]
}
  410bd4:	2a1603e0 	mov	w0, w22
  410bd8:	a94153f3 	ldp	x19, x20, [sp, #16]
  410bdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410be0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410be4:	d65f03c0 	ret
		ret = 1;
  410be8:	52800036 	mov	w22, #0x1                   	// #1
  410bec:	17ffffda 	b	410b54 <submit_to_queue_locked+0x98>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  410bf0:	52800000 	mov	w0, #0x0                   	// #0
  410bf4:	17ffffe2 	b	410b7c <submit_to_queue_locked+0xc0>
	parent->next = child;
  410bf8:	f9000013 	str	x19, [x0]
	list->tail = node;
  410bfc:	f90066b3 	str	x19, [x21, #200]
}
  410c00:	17ffffee 	b	410bb8 <submit_to_queue_locked+0xfc>
		ret = -EBUSY;
  410c04:	128001f6 	mov	w22, #0xfffffff0            	// #-16
		*queuep = NULL;
  410c08:	f900029f 	str	xzr, [x20]
	return ret;
  410c0c:	17fffff2 	b	410bd4 <submit_to_queue_locked+0x118>
	int ret = 0;
  410c10:	52800016 	mov	w22, #0x0                   	// #0
  410c14:	17fffffd 	b	410c08 <submit_to_queue_locked+0x14c>
		return -EINVAL;
  410c18:	128002b6 	mov	w22, #0xffffffea            	// #-22
  410c1c:	17fffffb 	b	410c08 <submit_to_queue_locked+0x14c>
		ret = -ENODEV;
  410c20:	12800256 	mov	w22, #0xffffffed            	// #-19
  410c24:	17fffff9 	b	410c08 <submit_to_queue_locked+0x14c>

0000000000410c28 <work_timeout>:
{
  410c28:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  410c2c:	910003fd 	mov	x29, sp
  410c30:	a90153f3 	stp	x19, x20, [sp, #16]
  410c34:	aa0003f4 	mov	x20, x0
  410c38:	900000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  410c3c:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410c40:	f00000f3 	adrp	x19, 42f000 <can_loopback_dev_data_0+0xc0>
  410c44:	911de276 	add	x22, x19, #0x778
  410c48:	f9478400 	ldr	x0, [x0, #3848]
  410c4c:	f9400001 	ldr	x1, [x0]
  410c50:	f9001fe1 	str	x1, [sp, #56]
  410c54:	d2800001 	mov	x1, #0x0                   	// #0
	return posix_irq_lock();
  410c58:	97ffda5f 	bl	4075d4 <posix_irq_lock>
  410c5c:	2a0003f5 	mov	w21, w0
  410c60:	aa1603e0 	mov	x0, x22
  410c64:	97fffa53 	bl	40f5b0 <z_spin_lock_valid>
  410c68:	72001c1f 	tst	w0, #0xff
  410c6c:	540002c1 	b.ne	410cc4 <work_timeout+0x9c>  // b.any
  410c70:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410c74:	9122ce73 	add	x19, x19, #0x8b3
  410c78:	aa1303e2 	mov	x2, x19
  410c7c:	52801283 	mov	w3, #0x94                  	// #148
  410c80:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410c84:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410c88:	91238021 	add	x1, x1, #0x8e0
  410c8c:	91353400 	add	x0, x0, #0xd4d
  410c90:	97ffd14b 	bl	4051bc <assert_print>
  410c94:	aa1603e1 	mov	x1, x22
  410c98:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410c9c:	9123d400 	add	x0, x0, #0x8f5
  410ca0:	97ffd147 	bl	4051bc <assert_print>
  410ca4:	aa1303e0 	mov	x0, x19
  410ca8:	52801281 	mov	w1, #0x94                  	// #148
  410cac:	97ffd16e 	bl	405264 <assert_post_action>
  410cb0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410cb4:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410cb8:	aa1303e1 	mov	x1, x19
  410cbc:	91362c00 	add	x0, x0, #0xd8b
  410cc0:	97ffdb5b 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  410cc4:	aa1603e0 	mov	x0, x22
  410cc8:	97fffa52 	bl	40f610 <z_spin_lock_set_owner>
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
  410ccc:	d1008284 	sub	x4, x20, #0x20
  410cd0:	d1002280 	sub	x0, x20, #0x8
  410cd4:	52800061 	mov	w1, #0x3                   	// #3
	struct k_work_q *queue = NULL;
  410cd8:	f9001bff 	str	xzr, [sp, #48]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
  410cdc:	97fffead 	bl	410790 <flag_test_and_clear>
  410ce0:	72001c1f 	tst	w0, #0xff
  410ce4:	540000c0 	b.eq	410cfc <work_timeout+0xd4>  // b.none
		queue = dw->queue;
  410ce8:	f9401280 	ldr	x0, [x20, #32]
		(void)submit_to_queue_locked(wp, &queue);
  410cec:	9100c3e1 	add	x1, sp, #0x30
		queue = dw->queue;
  410cf0:	f9001be0 	str	x0, [sp, #48]
		(void)submit_to_queue_locked(wp, &queue);
  410cf4:	aa0403e0 	mov	x0, x4
  410cf8:	97ffff71 	bl	410abc <submit_to_queue_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410cfc:	911de274 	add	x20, x19, #0x778
  410d00:	aa1403e0 	mov	x0, x20
  410d04:	97fffa36 	bl	40f5dc <z_spin_unlock_valid>
  410d08:	72001c1f 	tst	w0, #0xff
  410d0c:	54000261 	b.ne	410d58 <work_timeout+0x130>  // b.any
  410d10:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410d14:	9122ce73 	add	x19, x19, #0x8b3
  410d18:	aa1303e2 	mov	x2, x19
  410d1c:	52801863 	mov	w3, #0xc3                  	// #195
  410d20:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410d24:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410d28:	91255821 	add	x1, x1, #0x956
  410d2c:	91353400 	add	x0, x0, #0xd4d
  410d30:	97ffd123 	bl	4051bc <assert_print>
  410d34:	aa1403e1 	mov	x1, x20
  410d38:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410d3c:	9125b400 	add	x0, x0, #0x96d
  410d40:	97ffd11f 	bl	4051bc <assert_print>
  410d44:	aa1303e0 	mov	x0, x19
  410d48:	52801861 	mov	w1, #0xc3                  	// #195
  410d4c:	97ffd146 	bl	405264 <assert_post_action>
  410d50:	52801862 	mov	w2, #0xc3                  	// #195
  410d54:	17ffffd8 	b	410cb4 <work_timeout+0x8c>
	posix_irq_unlock(key);
  410d58:	900000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  410d5c:	f9478400 	ldr	x0, [x0, #3848]
  410d60:	f9401fe2 	ldr	x2, [sp, #56]
  410d64:	f9400001 	ldr	x1, [x0]
  410d68:	eb010042 	subs	x2, x2, x1
  410d6c:	d2800001 	mov	x1, #0x0                   	// #0
  410d70:	54000040 	b.eq	410d78 <work_timeout+0x150>  // b.none
  410d74:	97ffc1cf 	bl	4014b0 <__stack_chk_fail@plt>
  410d78:	2a1503e0 	mov	w0, w21
}
  410d7c:	a94153f3 	ldp	x19, x20, [sp, #16]
  410d80:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410d84:	a8c47bfd 	ldp	x29, x30, [sp], #64
  410d88:	17ffda15 	b	4075dc <posix_irq_unlock>

0000000000410d8c <k_work_init>:
{
  410d8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410d90:	910003fd 	mov	x29, sp
  410d94:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(work != NULL);
  410d98:	b5000240 	cbnz	x0, 410de0 <k_work_init+0x54>
  410d9c:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410da0:	9131fe73 	add	x19, x19, #0xc7f
  410da4:	aa1303e2 	mov	x2, x19
  410da8:	52801123 	mov	w3, #0x89                  	// #137
  410dac:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410db0:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410db4:	91344c21 	add	x1, x1, #0xd13
  410db8:	91353400 	add	x0, x0, #0xd4d
  410dbc:	97ffd100 	bl	4051bc <assert_print>
  410dc0:	aa1303e0 	mov	x0, x19
  410dc4:	52801121 	mov	w1, #0x89                  	// #137
  410dc8:	97ffd127 	bl	405264 <assert_post_action>
  410dcc:	52801122 	mov	w2, #0x89                  	// #137
	__ASSERT_NO_MSG(handler != NULL);
  410dd0:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410dd4:	aa1303e1 	mov	x1, x19
  410dd8:	91362c00 	add	x0, x0, #0xd8b
  410ddc:	97ffdb14 	bl	407a2c <posix_print_error_and_exit>
  410de0:	b50001e1 	cbnz	x1, 410e1c <k_work_init+0x90>
  410de4:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410de8:	9131fe73 	add	x19, x19, #0xc7f
  410dec:	aa1303e2 	mov	x2, x19
  410df0:	52801143 	mov	w3, #0x8a                  	// #138
  410df4:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410df8:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410dfc:	91328021 	add	x1, x1, #0xca0
  410e00:	91353400 	add	x0, x0, #0xd4d
  410e04:	97ffd0ee 	bl	4051bc <assert_print>
  410e08:	aa1303e0 	mov	x0, x19
  410e0c:	52801141 	mov	w1, #0x8a                  	// #138
  410e10:	97ffd115 	bl	405264 <assert_post_action>
  410e14:	52801142 	mov	w2, #0x8a                  	// #138
  410e18:	17ffffee 	b	410dd0 <k_work_init+0x44>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  410e1c:	a9007c1f 	stp	xzr, xzr, [x0]
  410e20:	f9000401 	str	x1, [x0, #8]
  410e24:	a9017c1f 	stp	xzr, xzr, [x0, #16]
}
  410e28:	f9400bf3 	ldr	x19, [sp, #16]
  410e2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410e30:	d65f03c0 	ret

0000000000410e34 <z_work_submit_to_queue>:
{
  410e34:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  410e38:	910003fd 	mov	x29, sp
  410e3c:	a90153f3 	stp	x19, x20, [sp, #16]
  410e40:	f90013f5 	str	x21, [sp, #32]
  410e44:	f9001fe0 	str	x0, [sp, #56]
	__ASSERT_NO_MSG(work != NULL);
  410e48:	b5000241 	cbnz	x1, 410e90 <z_work_submit_to_queue+0x5c>
  410e4c:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410e50:	9131fe73 	add	x19, x19, #0xc7f
  410e54:	aa1303e2 	mov	x2, x19
  410e58:	52802e83 	mov	w3, #0x174                 	// #372
  410e5c:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410e60:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410e64:	91344c21 	add	x1, x1, #0xd13
  410e68:	91353400 	add	x0, x0, #0xd4d
  410e6c:	97ffd0d4 	bl	4051bc <assert_print>
  410e70:	52802e81 	mov	w1, #0x174                 	// #372
  410e74:	aa1303e0 	mov	x0, x19
  410e78:	97ffd0fb 	bl	405264 <assert_post_action>
  410e7c:	aa1303e1 	mov	x1, x19
  410e80:	52802e82 	mov	w2, #0x174                 	// #372
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  410e84:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410e88:	91362c00 	add	x0, x0, #0xd8b
  410e8c:	97ffdae8 	bl	407a2c <posix_print_error_and_exit>
  410e90:	aa0103f4 	mov	x20, x1
  410e94:	f00000f3 	adrp	x19, 42f000 <can_loopback_dev_data_0+0xc0>
	return posix_irq_lock();
  410e98:	97ffd9cf 	bl	4075d4 <posix_irq_lock>
  410e9c:	911de273 	add	x19, x19, #0x778
  410ea0:	2a0003f5 	mov	w21, w0
  410ea4:	aa1303e0 	mov	x0, x19
  410ea8:	97fff9c2 	bl	40f5b0 <z_spin_lock_valid>
  410eac:	72001c1f 	tst	w0, #0xff
  410eb0:	54000281 	b.ne	410f00 <z_work_submit_to_queue+0xcc>  // b.any
  410eb4:	d0000034 	adrp	x20, 416000 <__func__.0+0x57a>
  410eb8:	9122ce94 	add	x20, x20, #0x8b3
  410ebc:	aa1403e2 	mov	x2, x20
  410ec0:	52801283 	mov	w3, #0x94                  	// #148
  410ec4:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410ec8:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410ecc:	91238021 	add	x1, x1, #0x8e0
  410ed0:	91353400 	add	x0, x0, #0xd4d
  410ed4:	97ffd0ba 	bl	4051bc <assert_print>
  410ed8:	aa1303e1 	mov	x1, x19
  410edc:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410ee0:	9123d400 	add	x0, x0, #0x8f5
  410ee4:	97ffd0b6 	bl	4051bc <assert_print>
  410ee8:	aa1403e0 	mov	x0, x20
  410eec:	52801281 	mov	w1, #0x94                  	// #148
  410ef0:	97ffd0dd 	bl	405264 <assert_post_action>
  410ef4:	52801282 	mov	w2, #0x94                  	// #148
  410ef8:	aa1403e1 	mov	x1, x20
  410efc:	17ffffe2 	b	410e84 <z_work_submit_to_queue+0x50>
	z_spin_lock_set_owner(l);
  410f00:	aa1303e0 	mov	x0, x19
  410f04:	97fff9c3 	bl	40f610 <z_spin_lock_set_owner>
	int ret = submit_to_queue_locked(work, &queue);
  410f08:	9100e3e1 	add	x1, sp, #0x38
  410f0c:	aa1403e0 	mov	x0, x20
  410f10:	97fffeeb 	bl	410abc <submit_to_queue_locked>
  410f14:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  410f18:	aa1303e0 	mov	x0, x19
  410f1c:	97fff9b0 	bl	40f5dc <z_spin_unlock_valid>
  410f20:	72001c1f 	tst	w0, #0xff
  410f24:	54000261 	b.ne	410f70 <z_work_submit_to_queue+0x13c>  // b.any
  410f28:	d0000034 	adrp	x20, 416000 <__func__.0+0x57a>
  410f2c:	9122ce94 	add	x20, x20, #0x8b3
  410f30:	aa1403e2 	mov	x2, x20
  410f34:	52801863 	mov	w3, #0xc3                  	// #195
  410f38:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410f3c:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410f40:	91255821 	add	x1, x1, #0x956
  410f44:	91353400 	add	x0, x0, #0xd4d
  410f48:	97ffd09d 	bl	4051bc <assert_print>
  410f4c:	aa1303e1 	mov	x1, x19
  410f50:	d0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  410f54:	9125b400 	add	x0, x0, #0x96d
  410f58:	97ffd099 	bl	4051bc <assert_print>
  410f5c:	aa1403e0 	mov	x0, x20
  410f60:	52801861 	mov	w1, #0xc3                  	// #195
  410f64:	97ffd0c0 	bl	405264 <assert_post_action>
  410f68:	52801862 	mov	w2, #0xc3                  	// #195
  410f6c:	17ffffe3 	b	410ef8 <z_work_submit_to_queue+0xc4>
	posix_irq_unlock(key);
  410f70:	2a1503e0 	mov	w0, w21
  410f74:	97ffd99a 	bl	4075dc <posix_irq_unlock>
}
  410f78:	2a1403e0 	mov	w0, w20
  410f7c:	a94153f3 	ldp	x19, x20, [sp, #16]
  410f80:	f94013f5 	ldr	x21, [sp, #32]
  410f84:	a8c47bfd 	ldp	x29, x30, [sp], #64
  410f88:	d65f03c0 	ret

0000000000410f8c <k_work_submit_to_queue>:
{
  410f8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410f90:	910003fd 	mov	x29, sp
  410f94:	f9000bf3 	str	x19, [sp, #16]
	int ret = z_work_submit_to_queue(queue, work);
  410f98:	97ffffa7 	bl	410e34 <z_work_submit_to_queue>
  410f9c:	2a0003f3 	mov	w19, w0
	if (ret > 0) {
  410fa0:	7100001f 	cmp	w0, #0x0
  410fa4:	5400006d 	b.le	410fb0 <k_work_submit_to_queue+0x24>
	return posix_irq_lock();
  410fa8:	97ffd98b 	bl	4075d4 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
  410fac:	940001bc 	bl	41169c <z_reschedule_irqlock>
}
  410fb0:	2a1303e0 	mov	w0, w19
  410fb4:	f9400bf3 	ldr	x19, [sp, #16]
  410fb8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410fbc:	d65f03c0 	ret

0000000000410fc0 <k_work_submit>:
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
  410fc0:	aa0003e1 	mov	x1, x0
  410fc4:	900000e0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  410fc8:	f947f800 	ldr	x0, [x0, #4080]
  410fcc:	17fffff0 	b	410f8c <k_work_submit_to_queue>

0000000000410fd0 <k_work_queue_init>:
{
  410fd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410fd4:	910003fd 	mov	x29, sp
  410fd8:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(queue != NULL);
  410fdc:	b5000240 	cbnz	x0, 411024 <k_work_queue_init+0x54>
  410fe0:	d0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  410fe4:	9131fe73 	add	x19, x19, #0xc7f
  410fe8:	aa1303e2 	mov	x2, x19
  410fec:	52805723 	mov	w3, #0x2b9                 	// #697
  410ff0:	d0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  410ff4:	90000020 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  410ff8:	9132f421 	add	x1, x1, #0xcbd
  410ffc:	91353400 	add	x0, x0, #0xd4d
  411000:	97ffd06f 	bl	4051bc <assert_print>
  411004:	aa1303e0 	mov	x0, x19
  411008:	52805721 	mov	w1, #0x2b9                 	// #697
  41100c:	97ffd096 	bl	405264 <assert_post_action>
  411010:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411014:	aa1303e1 	mov	x1, x19
  411018:	91362c00 	add	x0, x0, #0xd8b
  41101c:	52805722 	mov	w2, #0x2b9                 	// #697
  411020:	97ffda83 	bl	407a2c <posix_print_error_and_exit>
	*queue = (struct k_work_q) {
  411024:	d2801f02 	mov	x2, #0xf8                  	// #248
  411028:	52800001 	mov	w1, #0x0                   	// #0
  41102c:	97ffc0fd 	bl	401420 <memset@plt>
}
  411030:	f9400bf3 	ldr	x19, [sp, #16]
  411034:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411038:	d65f03c0 	ret

000000000041103c <k_work_queue_start>:
{
  41103c:	d100c3ff 	sub	sp, sp, #0x30
  411040:	a9017bfd 	stp	x29, x30, [sp, #16]
  411044:	910043fd 	add	x29, sp, #0x10
  411048:	a90253f3 	stp	x19, x20, [sp, #32]
	__ASSERT_NO_MSG(queue);
  41104c:	b5000240 	cbnz	x0, 411094 <k_work_queue_start+0x58>
  411050:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411054:	9131fe73 	add	x19, x19, #0xc7f
  411058:	aa1303e2 	mov	x2, x19
  41105c:	52805903 	mov	w3, #0x2c8                 	// #712
  411060:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411064:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411068:	91334821 	add	x1, x1, #0xcd2
  41106c:	91353400 	add	x0, x0, #0xd4d
  411070:	97ffd053 	bl	4051bc <assert_print>
  411074:	aa1303e0 	mov	x0, x19
  411078:	52805901 	mov	w1, #0x2c8                 	// #712
  41107c:	97ffd07a 	bl	405264 <assert_post_action>
  411080:	52805902 	mov	w2, #0x2c8                 	// #712
	__ASSERT_NO_MSG(stack);
  411084:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411088:	aa1303e1 	mov	x1, x19
  41108c:	91362c00 	add	x0, x0, #0xd8b
  411090:	97ffda67 	bl	407a2c <posix_print_error_and_exit>
  411094:	b50001e1 	cbnz	x1, 4110d0 <k_work_queue_start+0x94>
  411098:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  41109c:	9131fe73 	add	x19, x19, #0xc7f
  4110a0:	aa1303e2 	mov	x2, x19
  4110a4:	52805923 	mov	w3, #0x2c9                 	// #713
  4110a8:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4110ac:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4110b0:	91336021 	add	x1, x1, #0xcd8
  4110b4:	91353400 	add	x0, x0, #0xd4d
  4110b8:	97ffd041 	bl	4051bc <assert_print>
  4110bc:	aa1303e0 	mov	x0, x19
  4110c0:	52805921 	mov	w1, #0x2c9                 	// #713
  4110c4:	97ffd068 	bl	405264 <assert_post_action>
  4110c8:	52805922 	mov	w2, #0x2c9                 	// #713
  4110cc:	17ffffee 	b	411084 <k_work_queue_start+0x48>
  4110d0:	aa0003f3 	mov	x19, x0
	return (*flagp & BIT(bit)) != 0U;
  4110d4:	b940f000 	ldr	w0, [x0, #240]
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
  4110d8:	360001e0 	tbz	w0, #0, 411114 <k_work_queue_start+0xd8>
  4110dc:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4110e0:	9131fe73 	add	x19, x19, #0xc7f
  4110e4:	aa1303e2 	mov	x2, x19
  4110e8:	52805943 	mov	w3, #0x2ca                 	// #714
  4110ec:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4110f0:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4110f4:	91337821 	add	x1, x1, #0xcde
  4110f8:	91353400 	add	x0, x0, #0xd4d
  4110fc:	97ffd030 	bl	4051bc <assert_print>
  411100:	aa1303e0 	mov	x0, x19
  411104:	52805941 	mov	w1, #0x2ca                 	// #714
  411108:	97ffd057 	bl	405264 <assert_post_action>
  41110c:	52805942 	mov	w2, #0x2ca                 	// #714
  411110:	17ffffdd 	b	411084 <k_work_queue_start+0x48>
  411114:	91034260 	add	x0, x19, #0xd0
	list->tail = NULL;
  411118:	a90c7e7f 	stp	xzr, xzr, [x19, #192]
  41111c:	2a0303e7 	mov	w7, w3
  411120:	a90d0260 	stp	x0, x0, [x19, #208]
  411124:	91038260 	add	x0, x19, #0xe0
  411128:	aa0403f4 	mov	x20, x4
  41112c:	a90e0260 	stp	x0, x0, [x19, #224]
	if ((cfg != NULL) && cfg->no_yield) {
  411130:	b4000344 	cbz	x4, 411198 <k_work_queue_start+0x15c>
  411134:	39402080 	ldrb	w0, [x4, #8]
		flags |= K_WORK_QUEUE_NO_YIELD;
  411138:	7100001f 	cmp	w0, #0x0
  41113c:	52802020 	mov	w0, #0x101                 	// #257
  411140:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
	*flagp = flags;
  411144:	b900f260 	str	w0, [x19, #240]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  411148:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  41114c:	b90003ff 	str	wzr, [sp]
  411150:	f90007e0 	str	x0, [sp, #8]
  411154:	f0ffffe3 	adrp	x3, 410000 <z_impl_k_mutex_unlock+0x38>
  411158:	aa1303e4 	mov	x4, x19
  41115c:	91201063 	add	x3, x3, #0x804
  411160:	aa1303e0 	mov	x0, x19
  411164:	d2800006 	mov	x6, #0x0                   	// #0
  411168:	d2800005 	mov	x5, #0x0                   	// #0
  41116c:	97fff87f 	bl	40f368 <z_impl_k_thread_create>
	if ((cfg != NULL) && (cfg->name != NULL)) {
  411170:	b40000b4 	cbz	x20, 411184 <k_work_queue_start+0x148>
  411174:	f9400281 	ldr	x1, [x20]
  411178:	b4000061 	cbz	x1, 411184 <k_work_queue_start+0x148>
	return z_impl_k_thread_name_set(thread, str);
  41117c:	aa1303e0 	mov	x0, x19
  411180:	97fff805 	bl	40f194 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
  411184:	aa1303e0 	mov	x0, x19
}
  411188:	a9417bfd 	ldp	x29, x30, [sp, #16]
  41118c:	a94253f3 	ldp	x19, x20, [sp, #32]
  411190:	9100c3ff 	add	sp, sp, #0x30
  411194:	17fff813 	b	40f1e0 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
  411198:	52800020 	mov	w0, #0x1                   	// #1
  41119c:	17ffffea 	b	411144 <k_work_queue_start+0x108>

00000000004111a0 <k_work_init_delayable>:
{
  4111a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4111a4:	910003fd 	mov	x29, sp
  4111a8:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(dwork != NULL);
  4111ac:	b5000240 	cbnz	x0, 4111f4 <k_work_init_delayable+0x54>
  4111b0:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4111b4:	9131fe73 	add	x19, x19, #0xc7f
  4111b8:	aa1303e2 	mov	x2, x19
  4111bc:	52806803 	mov	w3, #0x340                 	// #832
  4111c0:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4111c4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4111c8:	91344821 	add	x1, x1, #0xd12
  4111cc:	91353400 	add	x0, x0, #0xd4d
  4111d0:	97ffcffb 	bl	4051bc <assert_print>
  4111d4:	aa1303e0 	mov	x0, x19
  4111d8:	52806801 	mov	w1, #0x340                 	// #832
  4111dc:	97ffd022 	bl	405264 <assert_post_action>
  4111e0:	52806802 	mov	w2, #0x340                 	// #832
	__ASSERT_NO_MSG(handler != NULL);
  4111e4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4111e8:	aa1303e1 	mov	x1, x19
  4111ec:	91362c00 	add	x0, x0, #0xd8b
  4111f0:	97ffda0f 	bl	407a2c <posix_print_error_and_exit>
  4111f4:	b50001e1 	cbnz	x1, 411230 <k_work_init_delayable+0x90>
  4111f8:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4111fc:	9131fe73 	add	x19, x19, #0xc7f
  411200:	aa1303e2 	mov	x2, x19
  411204:	52806823 	mov	w3, #0x341                 	// #833
  411208:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  41120c:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411210:	91328021 	add	x1, x1, #0xca0
  411214:	91353400 	add	x0, x0, #0xd4d
  411218:	97ffcfe9 	bl	4051bc <assert_print>
  41121c:	aa1303e0 	mov	x0, x19
  411220:	52806821 	mov	w1, #0x341                 	// #833
  411224:	97ffd010 	bl	405264 <assert_post_action>
  411228:	52806822 	mov	w2, #0x341                 	// #833
  41122c:	17ffffee 	b	4111e4 <k_work_init_delayable+0x44>
	*dwork = (struct k_work_delayable){
  411230:	4f000400 	movi	v0.4s, #0x0
  411234:	f900201f 	str	xzr, [x0, #64]
  411238:	ad000000 	stp	q0, q0, [x0]
  41123c:	f9000401 	str	x1, [x0, #8]
  411240:	52802001 	mov	w1, #0x100                 	// #256
  411244:	b9001801 	str	w1, [x0, #24]
  411248:	ad010000 	stp	q0, q0, [x0, #32]
}
  41124c:	f9400bf3 	ldr	x19, [sp, #16]
  411250:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411254:	d65f03c0 	ret

0000000000411258 <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
  411258:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  41125c:	910003fd 	mov	x29, sp
  411260:	a90153f3 	stp	x19, x20, [sp, #16]
  411264:	a9025bf5 	stp	x21, x22, [sp, #32]
  411268:	f9001bf7 	str	x23, [sp, #48]
  41126c:	f90027e0 	str	x0, [sp, #72]
	__ASSERT_NO_MSG(dwork != NULL);
  411270:	b5000241 	cbnz	x1, 4112b8 <k_work_reschedule_for_queue+0x60>
  411274:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411278:	9131fe73 	add	x19, x19, #0xc7f
  41127c:	aa1303e2 	mov	x2, x19
  411280:	52807bc3 	mov	w3, #0x3de                 	// #990
  411284:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411288:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41128c:	91344821 	add	x1, x1, #0xd12
  411290:	91353400 	add	x0, x0, #0xd4d
  411294:	97ffcfca 	bl	4051bc <assert_print>
  411298:	aa1303e0 	mov	x0, x19
  41129c:	52807bc1 	mov	w1, #0x3de                 	// #990
  4112a0:	97ffcff1 	bl	405264 <assert_post_action>
  4112a4:	52807bc2 	mov	w2, #0x3de                 	// #990
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4112a8:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4112ac:	aa1303e1 	mov	x1, x19
  4112b0:	91362c00 	add	x0, x0, #0xd8b
  4112b4:	97ffd9de 	bl	407a2c <posix_print_error_and_exit>
  4112b8:	aa0103f3 	mov	x19, x1
  4112bc:	aa0203f5 	mov	x21, x2
  4112c0:	d00000f4 	adrp	x20, 42f000 <can_loopback_dev_data_0+0xc0>
  4112c4:	97ffd8c4 	bl	4075d4 <posix_irq_lock>
  4112c8:	911de297 	add	x23, x20, #0x778
  4112cc:	2a0003f6 	mov	w22, w0
  4112d0:	aa1703e0 	mov	x0, x23
  4112d4:	97fff8b7 	bl	40f5b0 <z_spin_lock_valid>
  4112d8:	72001c1f 	tst	w0, #0xff
  4112dc:	54000261 	b.ne	411328 <k_work_reschedule_for_queue+0xd0>  // b.any
  4112e0:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4112e4:	9122ce73 	add	x19, x19, #0x8b3
  4112e8:	aa1303e2 	mov	x2, x19
  4112ec:	52801283 	mov	w3, #0x94                  	// #148
  4112f0:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4112f4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4112f8:	91238021 	add	x1, x1, #0x8e0
  4112fc:	91353400 	add	x0, x0, #0xd4d
  411300:	97ffcfaf 	bl	4051bc <assert_print>
  411304:	aa1703e1 	mov	x1, x23
  411308:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  41130c:	9123d400 	add	x0, x0, #0x8f5
  411310:	97ffcfab 	bl	4051bc <assert_print>
  411314:	aa1303e0 	mov	x0, x19
  411318:	52801281 	mov	w1, #0x94                  	// #148
  41131c:	97ffcfd2 	bl	405264 <assert_post_action>
  411320:	52801282 	mov	w2, #0x94                  	// #148
  411324:	17ffffe1 	b	4112a8 <k_work_reschedule_for_queue+0x50>
	z_spin_lock_set_owner(l);
  411328:	aa1703e0 	mov	x0, x23
  41132c:	97fff8b9 	bl	40f610 <z_spin_lock_set_owner>

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
  411330:	aa1303e0 	mov	x0, x19
  411334:	97fffd20 	bl	4107b4 <unschedule_locked>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  411338:	b5000395 	cbnz	x21, 4113a8 <k_work_reschedule_for_queue+0x150>
		return submit_to_queue_locked(work, queuep);
  41133c:	aa1303e0 	mov	x0, x19
  411340:	910123e1 	add	x1, sp, #0x48
  411344:	97fffdde 	bl	410abc <submit_to_queue_locked>
  411348:	2a0003f3 	mov	w19, w0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41134c:	911de294 	add	x20, x20, #0x778
  411350:	aa1403e0 	mov	x0, x20
  411354:	97fff8a2 	bl	40f5dc <z_spin_unlock_valid>
  411358:	72001c1f 	tst	w0, #0xff
  41135c:	540003e1 	b.ne	4113d8 <k_work_reschedule_for_queue+0x180>  // b.any
  411360:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411364:	9122ce73 	add	x19, x19, #0x8b3
  411368:	aa1303e2 	mov	x2, x19
  41136c:	52801863 	mov	w3, #0xc3                  	// #195
  411370:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411374:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411378:	91255821 	add	x1, x1, #0x956
  41137c:	91353400 	add	x0, x0, #0xd4d
  411380:	97ffcf8f 	bl	4051bc <assert_print>
  411384:	aa1403e1 	mov	x1, x20
  411388:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  41138c:	9125b400 	add	x0, x0, #0x96d
  411390:	97ffcf8b 	bl	4051bc <assert_print>
  411394:	aa1303e0 	mov	x0, x19
  411398:	52801861 	mov	w1, #0xc3                  	// #195
  41139c:	97ffcfb2 	bl	405264 <assert_post_action>
  4113a0:	52801862 	mov	w2, #0xc3                  	// #195
  4113a4:	17ffffc1 	b	4112a8 <k_work_reschedule_for_queue+0x50>
	*flagp |= BIT(bit);
  4113a8:	b9401a60 	ldr	w0, [x19, #24]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
  4113ac:	aa1503e2 	mov	x2, x21
  4113b0:	f0ffffe1 	adrp	x1, 410000 <z_impl_k_mutex_unlock+0x38>
  4113b4:	9130a021 	add	x1, x1, #0xc28
	*flagp |= BIT(bit);
  4113b8:	321d0000 	orr	w0, w0, #0x8
  4113bc:	b9001a60 	str	w0, [x19, #24]
	dwork->queue = *queuep;
  4113c0:	f94027e0 	ldr	x0, [sp, #72]
  4113c4:	f9002260 	str	x0, [x19, #64]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
  4113c8:	91008260 	add	x0, x19, #0x20
	return ret;
  4113cc:	52800033 	mov	w19, #0x1                   	// #1
	z_add_timeout(&dwork->timeout, work_timeout, delay);
  4113d0:	94000996 	bl	413a28 <z_add_timeout>
	return ret;
  4113d4:	17ffffde 	b	41134c <k_work_reschedule_for_queue+0xf4>
	posix_irq_unlock(key);
  4113d8:	2a1603e0 	mov	w0, w22
  4113dc:	97ffd880 	bl	4075dc <posix_irq_unlock>
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
  4113e0:	2a1303e0 	mov	w0, w19
  4113e4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4113e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4113ec:	f9401bf7 	ldr	x23, [sp, #48]
  4113f0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4113f4:	d65f03c0 	ret

00000000004113f8 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
  4113f8:	79403401 	ldrh	w1, [x0, #26]
  4113fc:	7101fc3f 	cmp	w1, #0x7f
  411400:	54000248 	b.hi	411448 <sliceable+0x50>  // b.pmore
	int ret = slice_ticks;
  411404:	d00000e1 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  411408:	b94d4421 	ldr	w1, [x1, #3396]
		&& slice_time(thread) != 0
  41140c:	340001a1 	cbz	w1, 411440 <sliceable+0x48>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
  411410:	d00000e1 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  411414:	39c06802 	ldrsb	w2, [x0, #26]
  411418:	b94d4021 	ldr	w1, [x1, #3392]
  41141c:	6b01005f 	cmp	w2, w1
  411420:	5400014b 	b.lt	411448 <sliceable+0x50>  // b.tstop
		&& !z_is_thread_prevented_from_running(thread)
  411424:	39406401 	ldrb	w1, [x0, #25]
  411428:	f240103f 	tst	x1, #0x1f
  41142c:	540000e1 	b.ne	411448 <sliceable+0x50>  // b.any
		&& !z_is_idle_thread_object(thread);
  411430:	f00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  411434:	f9471021 	ldr	x1, [x1, #3616]
  411438:	eb01001f 	cmp	x0, x1
  41143c:	1a9f07e1 	cset	w1, ne  // ne = any
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
  411440:	12000020 	and	w0, w1, #0x1
  411444:	d65f03c0 	ret
		&& !z_is_idle_thread_object(thread);
  411448:	52800001 	mov	w1, #0x0                   	// #0
  41144c:	17fffffd 	b	411440 <sliceable+0x48>

0000000000411450 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  411450:	b4000160 	cbz	x0, 41147c <slice_timeout+0x2c>
  411454:	d00000e1 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  411458:	911e6021 	add	x1, x1, #0x798
  41145c:	eb01001f 	cmp	x0, x1
  411460:	540000e3 	b.cc	41147c <slice_timeout+0x2c>  // b.lo, b.ul, b.last
  411464:	91008022 	add	x2, x1, #0x20
  411468:	eb02001f 	cmp	x0, x2
  41146c:	54000082 	b.cs	41147c <slice_timeout+0x2c>  // b.hs, b.nlast
  411470:	cb010000 	sub	x0, x0, x1
  411474:	f240101f 	tst	x0, #0x1f
  411478:	540002a0 	b.eq	4114cc <slice_timeout+0x7c>  // b.none
{
  41147c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  411480:	528038e3 	mov	w3, #0x1c7                 	// #455
  411484:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
{
  411488:	910003fd 	mov	x29, sp
  41148c:	f9000bf3 	str	x19, [sp, #16]
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  411490:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411494:	91349e73 	add	x19, x19, #0xd27
  411498:	91352421 	add	x1, x1, #0xd49
  41149c:	aa1303e2 	mov	x2, x19
  4114a0:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4114a4:	91353400 	add	x0, x0, #0xd4d
  4114a8:	97ffcf45 	bl	4051bc <assert_print>
  4114ac:	aa1303e0 	mov	x0, x19
  4114b0:	528038e1 	mov	w1, #0x1c7                 	// #455
  4114b4:	97ffcf6c 	bl	405264 <assert_post_action>
  4114b8:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4114bc:	aa1303e1 	mov	x1, x19
  4114c0:	91362c00 	add	x0, x0, #0xd8b
  4114c4:	528038e2 	mov	w2, #0x1c7                 	// #455
  4114c8:	97ffd959 	bl	407a2c <posix_print_error_and_exit>

	slice_expired[cpu] = true;
  4114cc:	93459000 	sbfx	x0, x0, #5, #32
  4114d0:	f00000e1 	adrp	x1, 430000 <stdout_buff+0x6f>
  4114d4:	91024821 	add	x1, x1, #0x92
  4114d8:	52800022 	mov	w2, #0x1                   	// #1
  4114dc:	38206822 	strb	w2, [x1, x0]
  4114e0:	d65f03c0 	ret

00000000004114e4 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
  4114e4:	39c06802 	ldrsb	w2, [x0, #26]
	int32_t b2 = thread_2->base.prio;
  4114e8:	39c06821 	ldrsb	w1, [x1, #26]
		return b2 - b1;
  4114ec:	4b020020 	sub	w0, w1, w2
  4114f0:	6b01005f 	cmp	w2, w1
}
  4114f4:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  4114f8:	d65f03c0 	ret

00000000004114fc <z_reset_time_slice>:
		flag_ipi();
	}
}

void z_reset_time_slice(struct k_thread *curr)
{
  4114fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int cpu = _current_cpu->id;
  411500:	f00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
{
  411504:	910003fd 	mov	x29, sp
	int cpu = _current_cpu->id;
  411508:	f9474021 	ldr	x1, [x1, #3712]
{
  41150c:	a90153f3 	stp	x19, x20, [sp, #16]
  411510:	aa0003f4 	mov	x20, x0
  411514:	f90013f5 	str	x21, [sp, #32]

	z_abort_timeout(&slice_timeouts[cpu]);
  411518:	d00000e0 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  41151c:	911e6000 	add	x0, x0, #0x798
  411520:	39408033 	ldrb	w19, [x1, #32]
	int cpu = _current_cpu->id;
  411524:	39408035 	ldrb	w21, [x1, #32]
	z_abort_timeout(&slice_timeouts[cpu]);
  411528:	8b131413 	add	x19, x0, x19, lsl #5
  41152c:	aa1303e0 	mov	x0, x19
  411530:	940009d0 	bl	413c70 <z_abort_timeout>
	slice_expired[cpu] = false;
  411534:	f00000e0 	adrp	x0, 430000 <stdout_buff+0x6f>
  411538:	91024800 	add	x0, x0, #0x92
  41153c:	3835c81f 	strb	wzr, [x0, w21, sxtw]
	if (sliceable(curr)) {
  411540:	aa1403e0 	mov	x0, x20
  411544:	97ffffad 	bl	4113f8 <sliceable>
  411548:	72001c1f 	tst	w0, #0xff
  41154c:	54000180 	b.eq	41157c <z_reset_time_slice+0x80>  // b.none
	int ret = slice_ticks;
  411550:	d00000e0 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  411554:	90000001 	adrp	x1, 411000 <k_work_queue_init+0x30>
			      K_TICKS(slice_time(curr) - 1));
	}
}
  411558:	f94013f5 	ldr	x21, [sp, #32]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  41155c:	91114021 	add	x1, x1, #0x450
			      K_TICKS(slice_time(curr) - 1));
  411560:	b94d4402 	ldr	w2, [x0, #3396]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  411564:	aa1303e0 	mov	x0, x19
}
  411568:	a94153f3 	ldp	x19, x20, [sp, #16]
			      K_TICKS(slice_time(curr) - 1));
  41156c:	51000442 	sub	w2, w2, #0x1
}
  411570:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  411574:	93407c42 	sxtw	x2, w2
  411578:	1400092c 	b	413a28 <z_add_timeout>
}
  41157c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411580:	f94013f5 	ldr	x21, [sp, #32]
  411584:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411588:	d65f03c0 	ret

000000000041158c <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
  41158c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return _kernel.cpus[0].nested != 0U;
  411590:	f00000c2 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  411594:	910003fd 	mov	x29, sp
  411598:	f9474042 	ldr	x2, [x2, #3712]
  41159c:	a90153f3 	stp	x19, x20, [sp, #16]
  4115a0:	2a0103f3 	mov	w19, w1
  4115a4:	aa0003f4 	mov	x20, x0
	if (resched(key.key) && need_swap()) {
  4115a8:	b9400041 	ldr	w1, [x2]
  4115ac:	2a010261 	orr	w1, w19, w1
  4115b0:	35000421 	cbnz	w1, 411634 <z_reschedule+0xa8>
  4115b4:	f9400841 	ldr	x1, [x2, #16]
  4115b8:	f9401443 	ldr	x3, [x2, #40]
  4115bc:	eb01007f 	cmp	x3, x1
  4115c0:	540003a0 	b.eq	411634 <z_reschedule+0xa8>  // b.none
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4115c4:	97fff806 	bl	40f5dc <z_spin_unlock_valid>
  4115c8:	72001c1f 	tst	w0, #0xff
  4115cc:	540002c1 	b.ne	411624 <z_reschedule+0x98>  // b.any
  4115d0:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4115d4:	9122ce73 	add	x19, x19, #0x8b3
  4115d8:	aa1303e2 	mov	x2, x19
  4115dc:	52801c43 	mov	w3, #0xe2                  	// #226
  4115e0:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4115e4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4115e8:	91255821 	add	x1, x1, #0x956
  4115ec:	91353400 	add	x0, x0, #0xd4d
  4115f0:	97ffcef3 	bl	4051bc <assert_print>
  4115f4:	aa1403e1 	mov	x1, x20
  4115f8:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4115fc:	9125b400 	add	x0, x0, #0x96d
  411600:	97ffceef 	bl	4051bc <assert_print>
  411604:	aa1303e0 	mov	x0, x19
  411608:	52801c41 	mov	w1, #0xe2                  	// #226
  41160c:	97ffcf16 	bl	405264 <assert_post_action>
  411610:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411614:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411618:	aa1303e1 	mov	x1, x19
  41161c:	91362c00 	add	x0, x0, #0xd8b
  411620:	97ffd903 	bl	407a2c <posix_print_error_and_exit>
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
  411624:	a94153f3 	ldp	x19, x20, [sp, #16]
	ret = arch_swap(key);
  411628:	52800000 	mov	w0, #0x0                   	// #0
  41162c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411630:	17ffd4bf 	b	40692c <arch_swap>
  411634:	aa1403e0 	mov	x0, x20
  411638:	97fff7e9 	bl	40f5dc <z_spin_unlock_valid>
  41163c:	72001c1f 	tst	w0, #0xff
  411640:	54000261 	b.ne	41168c <z_reschedule+0x100>  // b.any
  411644:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411648:	9122ce73 	add	x19, x19, #0x8b3
  41164c:	aa1303e2 	mov	x2, x19
  411650:	52801863 	mov	w3, #0xc3                  	// #195
  411654:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411658:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41165c:	91255821 	add	x1, x1, #0x956
  411660:	91353400 	add	x0, x0, #0xd4d
  411664:	97ffced6 	bl	4051bc <assert_print>
  411668:	aa1403e1 	mov	x1, x20
  41166c:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411670:	9125b400 	add	x0, x0, #0x96d
  411674:	97ffced2 	bl	4051bc <assert_print>
  411678:	aa1303e0 	mov	x0, x19
  41167c:	52801861 	mov	w1, #0xc3                  	// #195
  411680:	97ffcef9 	bl	405264 <assert_post_action>
  411684:	52801862 	mov	w2, #0xc3                  	// #195
  411688:	17ffffe3 	b	411614 <z_reschedule+0x88>
  41168c:	2a1303e0 	mov	w0, w19
  411690:	a94153f3 	ldp	x19, x20, [sp, #16]
  411694:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411698:	17ffd7d1 	b	4075dc <posix_irq_unlock>

000000000041169c <z_reschedule_irqlock>:
  41169c:	f00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4116a0:	f9474021 	ldr	x1, [x1, #3712]

void z_reschedule_irqlock(uint32_t key)
{
	if (resched(key)) {
  4116a4:	b9400021 	ldr	w1, [x1]
  4116a8:	2a010001 	orr	w1, w0, w1
  4116ac:	35000061 	cbnz	w1, 4116b8 <z_reschedule_irqlock+0x1c>
  4116b0:	52800000 	mov	w0, #0x0                   	// #0
  4116b4:	17ffd49e 	b	40692c <arch_swap>
  4116b8:	17ffd7c9 	b	4075dc <posix_irq_unlock>

00000000004116bc <z_reschedule_unlocked>:
{
  4116bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4116c0:	910003fd 	mov	x29, sp
	return posix_irq_lock();
  4116c4:	97ffd7c4 	bl	4075d4 <posix_irq_lock>
}
  4116c8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	(void) z_reschedule_irqlock(arch_irq_lock());
  4116cc:	17fffff4 	b	41169c <z_reschedule_irqlock>

00000000004116d0 <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
  4116d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4116d4:	910003fd 	mov	x29, sp
  4116d8:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4116dc:	f00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  4116e0:	97ffd7bd 	bl	4075d4 <posix_irq_lock>
  4116e4:	f947d673 	ldr	x19, [x19, #4008]
  4116e8:	2a0003f4 	mov	w20, w0
  4116ec:	aa1303e0 	mov	x0, x19
  4116f0:	97fff7b0 	bl	40f5b0 <z_spin_lock_valid>
  4116f4:	72001c1f 	tst	w0, #0xff
  4116f8:	54000281 	b.ne	411748 <k_sched_lock+0x78>  // b.any
  4116fc:	b0000034 	adrp	x20, 416000 <__func__.0+0x57a>
  411700:	9122ce94 	add	x20, x20, #0x8b3
  411704:	aa1403e2 	mov	x2, x20
  411708:	52801283 	mov	w3, #0x94                  	// #148
  41170c:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411710:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411714:	91238021 	add	x1, x1, #0x8e0
  411718:	91353400 	add	x0, x0, #0xd4d
  41171c:	97ffcea8 	bl	4051bc <assert_print>
  411720:	aa1303e1 	mov	x1, x19
  411724:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411728:	9123d400 	add	x0, x0, #0x8f5
  41172c:	97ffcea4 	bl	4051bc <assert_print>
  411730:	aa1403e0 	mov	x0, x20
  411734:	52801281 	mov	w1, #0x94                  	// #148
  411738:	97ffcecb 	bl	405264 <assert_post_action>
  41173c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411740:	aa1403e1 	mov	x1, x20
  411744:	14000018 	b	4117a4 <k_sched_lock+0xd4>
	z_spin_lock_set_owner(l);
  411748:	aa1303e0 	mov	x0, x19
  41174c:	97fff7b1 	bl	40f610 <z_spin_lock_set_owner>
  411750:	f00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  411754:	f9474021 	ldr	x1, [x1, #3712]
	__ASSERT(!arch_is_in_isr(), "");
  411758:	b9400020 	ldr	w0, [x1]
  41175c:	340002a0 	cbz	w0, 4117b0 <k_sched_lock+0xe0>
  411760:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411764:	913b8a73 	add	x19, x19, #0xee2
  411768:	aa1303e2 	mov	x2, x19
  41176c:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411770:	912a6021 	add	x1, x1, #0xa98
  411774:	52801fa3 	mov	w3, #0xfd                  	// #253
  411778:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41177c:	91353400 	add	x0, x0, #0xd4d
  411780:	97ffce8f 	bl	4051bc <assert_print>
  411784:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411788:	91254c00 	add	x0, x0, #0x953
  41178c:	97ffce8c 	bl	4051bc <assert_print>
  411790:	aa1303e0 	mov	x0, x19
  411794:	52801fa1 	mov	w1, #0xfd                  	// #253
  411798:	97ffceb3 	bl	405264 <assert_post_action>
  41179c:	52801fa2 	mov	w2, #0xfd                  	// #253
  4117a0:	aa1303e1 	mov	x1, x19
  4117a4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4117a8:	91362c00 	add	x0, x0, #0xd8b
  4117ac:	97ffd8a0 	bl	407a2c <posix_print_error_and_exit>
	__ASSERT(_current->base.sched_locked != 1U, "");
  4117b0:	f9400820 	ldr	x0, [x1, #16]
  4117b4:	39406c01 	ldrb	w1, [x0, #27]
  4117b8:	7100043f 	cmp	w1, #0x1
  4117bc:	54000241 	b.ne	411804 <k_sched_lock+0x134>  // b.any
  4117c0:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4117c4:	913b8a73 	add	x19, x19, #0xee2
  4117c8:	aa1303e2 	mov	x2, x19
  4117cc:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4117d0:	913c3421 	add	x1, x1, #0xf0d
  4117d4:	52801fc3 	mov	w3, #0xfe                  	// #254
  4117d8:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4117dc:	91353400 	add	x0, x0, #0xd4d
  4117e0:	97ffce77 	bl	4051bc <assert_print>
  4117e4:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4117e8:	91254c00 	add	x0, x0, #0x953
  4117ec:	97ffce74 	bl	4051bc <assert_print>
  4117f0:	aa1303e0 	mov	x0, x19
  4117f4:	52801fc1 	mov	w1, #0xfe                  	// #254
  4117f8:	97ffce9b 	bl	405264 <assert_post_action>
  4117fc:	52801fc2 	mov	w2, #0xfe                  	// #254
  411800:	17ffffe8 	b	4117a0 <k_sched_lock+0xd0>
	--_current->base.sched_locked;
  411804:	51000421 	sub	w1, w1, #0x1
  411808:	39006c01 	strb	w1, [x0, #27]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41180c:	aa1303e0 	mov	x0, x19
  411810:	97fff773 	bl	40f5dc <z_spin_unlock_valid>
  411814:	72001c1f 	tst	w0, #0xff
  411818:	54000261 	b.ne	411864 <k_sched_lock+0x194>  // b.any
  41181c:	b0000034 	adrp	x20, 416000 <__func__.0+0x57a>
  411820:	9122ce94 	add	x20, x20, #0x8b3
  411824:	aa1403e2 	mov	x2, x20
  411828:	52801863 	mov	w3, #0xc3                  	// #195
  41182c:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411830:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411834:	91255821 	add	x1, x1, #0x956
  411838:	91353400 	add	x0, x0, #0xd4d
  41183c:	97ffce60 	bl	4051bc <assert_print>
  411840:	aa1303e1 	mov	x1, x19
  411844:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411848:	9125b400 	add	x0, x0, #0x96d
  41184c:	97ffce5c 	bl	4051bc <assert_print>
  411850:	aa1403e0 	mov	x0, x20
  411854:	52801861 	mov	w1, #0xc3                  	// #195
  411858:	97ffce83 	bl	405264 <assert_post_action>
  41185c:	52801862 	mov	w2, #0xc3                  	// #195
  411860:	17ffffb8 	b	411740 <k_sched_lock+0x70>
	posix_irq_unlock(key);
  411864:	2a1403e0 	mov	w0, w20
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
  411868:	a94153f3 	ldp	x19, x20, [sp, #16]
  41186c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411870:	17ffd75b 	b	4075dc <posix_irq_unlock>

0000000000411874 <z_priq_dumb_remove>:
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411874:	f00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  411878:	f9471000 	ldr	x0, [x0, #3616]
  41187c:	eb00003f 	cmp	x1, x0
  411880:	540002a1 	b.ne	4118d4 <z_priq_dumb_remove+0x60>  // b.any
{
  411884:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411888:	52808f63 	mov	w3, #0x47b                 	// #1147
  41188c:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
{
  411890:	910003fd 	mov	x29, sp
  411894:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411898:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  41189c:	91349e73 	add	x19, x19, #0xd27
  4118a0:	913cf821 	add	x1, x1, #0xf3e
  4118a4:	aa1303e2 	mov	x2, x19
  4118a8:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4118ac:	91353400 	add	x0, x0, #0xd4d
  4118b0:	97ffce43 	bl	4051bc <assert_print>
  4118b4:	aa1303e0 	mov	x0, x19
  4118b8:	52808f61 	mov	w1, #0x47b                 	// #1147
  4118bc:	97ffce6a 	bl	405264 <assert_post_action>
  4118c0:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4118c4:	aa1303e1 	mov	x1, x19
  4118c8:	91362c00 	add	x0, x0, #0xd8b
  4118cc:	52808f62 	mov	w2, #0x47b                 	// #1147
  4118d0:	97ffd857 	bl	407a2c <posix_print_error_and_exit>
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
  4118d4:	a9400820 	ldp	x0, x2, [x1]
	sys_dnode_t *const next = node->next;

	prev->next = next;
  4118d8:	f9000040 	str	x0, [x2]
	next->prev = prev;
  4118dc:	f9000402 	str	x2, [x0, #8]
	node->prev = NULL;
  4118e0:	a9007c3f 	stp	xzr, xzr, [x1]
  4118e4:	d65f03c0 	ret

00000000004118e8 <unpend_thread_no_timeout>:
{
  4118e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4118ec:	910003fd 	mov	x29, sp
  4118f0:	f9000bf3 	str	x19, [sp, #16]
  4118f4:	aa0003f3 	mov	x19, x0
  4118f8:	f9400800 	ldr	x0, [x0, #16]
	__ASSERT_NO_MSG(thread->base.pended_on);
  4118fc:	b5000240 	cbnz	x0, 411944 <unpend_thread_no_timeout+0x5c>
  411900:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411904:	91349e73 	add	x19, x19, #0xd27
  411908:	aa1303e2 	mov	x2, x19
  41190c:	528058a3 	mov	w3, #0x2c5                 	// #709
  411910:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411914:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411918:	913d7c21 	add	x1, x1, #0xf5f
  41191c:	91353400 	add	x0, x0, #0xd4d
  411920:	97ffce27 	bl	4051bc <assert_print>
  411924:	aa1303e0 	mov	x0, x19
  411928:	528058a1 	mov	w1, #0x2c5                 	// #709
  41192c:	97ffce4e 	bl	405264 <assert_post_action>
  411930:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411934:	aa1303e1 	mov	x1, x19
  411938:	91362c00 	add	x0, x0, #0xd8b
  41193c:	528058a2 	mov	w2, #0x2c5                 	// #709
  411940:	97ffd83b 	bl	407a2c <posix_print_error_and_exit>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
  411944:	aa1303e1 	mov	x1, x19
  411948:	97ffffcb 	bl	411874 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  41194c:	39406660 	ldrb	w0, [x19, #25]
	thread->base.pended_on = NULL;
  411950:	f9000a7f 	str	xzr, [x19, #16]
  411954:	121e7800 	and	w0, w0, #0xfffffffd
  411958:	39006660 	strb	w0, [x19, #25]
}
  41195c:	f9400bf3 	ldr	x19, [sp, #16]
  411960:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411964:	d65f03c0 	ret

0000000000411968 <z_unpend_thread>:
{
  411968:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  41196c:	910003fd 	mov	x29, sp
  411970:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411974:	f00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  411978:	aa0003f4 	mov	x20, x0
  41197c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  411980:	97ffd715 	bl	4075d4 <posix_irq_lock>
  411984:	2a0003f5 	mov	w21, w0
  411988:	f947d676 	ldr	x22, [x19, #4008]
  41198c:	aa1603e0 	mov	x0, x22
  411990:	97fff708 	bl	40f5b0 <z_spin_lock_valid>
  411994:	72001c1f 	tst	w0, #0xff
  411998:	540002c1 	b.ne	4119f0 <z_unpend_thread+0x88>  // b.any
  41199c:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4119a0:	9122ce73 	add	x19, x19, #0x8b3
  4119a4:	aa1303e2 	mov	x2, x19
  4119a8:	52801283 	mov	w3, #0x94                  	// #148
  4119ac:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4119b0:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4119b4:	91238021 	add	x1, x1, #0x8e0
  4119b8:	91353400 	add	x0, x0, #0xd4d
  4119bc:	97ffce00 	bl	4051bc <assert_print>
  4119c0:	aa1603e1 	mov	x1, x22
  4119c4:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4119c8:	9123d400 	add	x0, x0, #0x8f5
  4119cc:	97ffcdfc 	bl	4051bc <assert_print>
  4119d0:	52801281 	mov	w1, #0x94                  	// #148
  4119d4:	aa1303e0 	mov	x0, x19
  4119d8:	97ffce23 	bl	405264 <assert_post_action>
  4119dc:	aa1303e1 	mov	x1, x19
  4119e0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4119e4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4119e8:	91362c00 	add	x0, x0, #0xd8b
  4119ec:	97ffd810 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4119f0:	aa1603e0 	mov	x0, x22
  4119f4:	97fff707 	bl	40f610 <z_spin_lock_set_owner>
		if (thread->base.pended_on != NULL) {
  4119f8:	f9400a80 	ldr	x0, [x20, #16]
  4119fc:	b4000060 	cbz	x0, 411a08 <z_unpend_thread+0xa0>
			unpend_thread_no_timeout(thread);
  411a00:	aa1403e0 	mov	x0, x20
  411a04:	97ffffb9 	bl	4118e8 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411a08:	f947d673 	ldr	x19, [x19, #4008]
  411a0c:	aa1303e0 	mov	x0, x19
  411a10:	97fff6f3 	bl	40f5dc <z_spin_unlock_valid>
  411a14:	72001c1f 	tst	w0, #0xff
  411a18:	54000281 	b.ne	411a68 <z_unpend_thread+0x100>  // b.any
  411a1c:	b0000034 	adrp	x20, 416000 <__func__.0+0x57a>
  411a20:	9122ce94 	add	x20, x20, #0x8b3
  411a24:	aa1403e2 	mov	x2, x20
  411a28:	52801863 	mov	w3, #0xc3                  	// #195
  411a2c:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411a30:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411a34:	91255821 	add	x1, x1, #0x956
  411a38:	91353400 	add	x0, x0, #0xd4d
  411a3c:	97ffcde0 	bl	4051bc <assert_print>
  411a40:	aa1303e1 	mov	x1, x19
  411a44:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411a48:	9125b400 	add	x0, x0, #0x96d
  411a4c:	97ffcddc 	bl	4051bc <assert_print>
  411a50:	52801861 	mov	w1, #0xc3                  	// #195
  411a54:	aa1403e0 	mov	x0, x20
  411a58:	97ffce03 	bl	405264 <assert_post_action>
  411a5c:	aa1403e1 	mov	x1, x20
  411a60:	52801862 	mov	w2, #0xc3                  	// #195
  411a64:	17ffffe0 	b	4119e4 <z_unpend_thread+0x7c>
	posix_irq_unlock(key);
  411a68:	2a1503e0 	mov	w0, w21
  411a6c:	97ffd6dc 	bl	4075dc <posix_irq_unlock>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  411a70:	9100a280 	add	x0, x20, #0x28
}
  411a74:	a94153f3 	ldp	x19, x20, [sp, #16]
  411a78:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411a7c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411a80:	1400087c 	b	413c70 <z_abort_timeout>

0000000000411a84 <z_priq_dumb_best>:
	return list->head == list;
  411a84:	f9400001 	ldr	x1, [x0]
	sys_dlist_remove(&thread->base.qnode_dlist);
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
  411a88:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
  411a8c:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
  411a90:	d65f03c0 	ret

0000000000411a94 <update_cache>:
{
  411a94:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411a98:	910003fd 	mov	x29, sp
  411a9c:	a90153f3 	stp	x19, x20, [sp, #16]
	return _priq_run_best(curr_cpu_runq());
  411aa0:	f00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
{
  411aa4:	a9025bf5 	stp	x21, x22, [sp, #32]
  411aa8:	2a0003f5 	mov	w21, w0
	return _priq_run_best(curr_cpu_runq());
  411aac:	f9474276 	ldr	x22, [x19, #3712]
  411ab0:	9100c2c0 	add	x0, x22, #0x30
  411ab4:	97fffff4 	bl	411a84 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
  411ab8:	b5000340 	cbnz	x0, 411b20 <update_cache+0x8c>
  411abc:	f9400ed4 	ldr	x20, [x22, #24]
	__ASSERT(_current != NULL, "");
  411ac0:	f9474260 	ldr	x0, [x19, #3712]
  411ac4:	f9400801 	ldr	x1, [x0, #16]
	if (preempt_ok != 0) {
  411ac8:	350003d5 	cbnz	w21, 411b40 <update_cache+0xac>
	__ASSERT(_current != NULL, "");
  411acc:	b50002e1 	cbnz	x1, 411b28 <update_cache+0x94>
  411ad0:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411ad4:	91349e73 	add	x19, x19, #0xd27
  411ad8:	aa1303e2 	mov	x2, x19
  411adc:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411ae0:	913dd821 	add	x1, x1, #0xf76
  411ae4:	52801143 	mov	w3, #0x8a                  	// #138
  411ae8:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411aec:	91353400 	add	x0, x0, #0xd4d
  411af0:	97ffcdb3 	bl	4051bc <assert_print>
  411af4:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411af8:	91254c00 	add	x0, x0, #0x953
  411afc:	97ffcdb0 	bl	4051bc <assert_print>
  411b00:	aa1303e0 	mov	x0, x19
  411b04:	52801141 	mov	w1, #0x8a                  	// #138
  411b08:	97ffcdd7 	bl	405264 <assert_post_action>
  411b0c:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411b10:	aa1303e1 	mov	x1, x19
  411b14:	91362c00 	add	x0, x0, #0xd8b
  411b18:	52801142 	mov	w2, #0x8a                  	// #138
  411b1c:	97ffd7c4 	bl	407a2c <posix_print_error_and_exit>
  411b20:	aa0003f4 	mov	x20, x0
  411b24:	17ffffe7 	b	411ac0 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
  411b28:	39406420 	ldrb	w0, [x1, #25]
  411b2c:	f240101f 	tst	x0, #0x1f
  411b30:	54000081 	b.ne	411b40 <update_cache+0xac>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
  411b34:	79403420 	ldrh	w0, [x1, #26]
  411b38:	7101fc1f 	cmp	w0, #0x7f
  411b3c:	540000c8 	b.hi	411b54 <update_cache+0xc0>  // b.pmore
		if (thread != _current) {
  411b40:	eb01029f 	cmp	x20, x1
  411b44:	54000060 	b.eq	411b50 <update_cache+0xbc>  // b.none
			z_reset_time_slice(thread);
  411b48:	aa1403e0 	mov	x0, x20
  411b4c:	97fffe6c 	bl	4114fc <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
  411b50:	aa1403e1 	mov	x1, x20
  411b54:	f9474273 	ldr	x19, [x19, #3712]
  411b58:	f9001661 	str	x1, [x19, #40]
}
  411b5c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411b60:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411b64:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411b68:	d65f03c0 	ret

0000000000411b6c <move_thread_to_end_of_prio_q>:
{
  411b6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411b70:	910003fd 	mov	x29, sp
  411b74:	a90153f3 	stp	x19, x20, [sp, #16]
  411b78:	aa0003f3 	mov	x19, x0
  411b7c:	a9025bf5 	stp	x21, x22, [sp, #32]
  411b80:	f00000d5 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
	if (z_is_thread_queued(thread)) {
  411b84:	39c06661 	ldrsb	w1, [x19, #25]
	return (thread->base.thread_state & state) != 0U;
  411b88:	39406400 	ldrb	w0, [x0, #25]
  411b8c:	36f800e1 	tbz	w1, #31, 411ba8 <move_thread_to_end_of_prio_q+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  411b90:	12001800 	and	w0, w0, #0x7f
  411b94:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  411b98:	f94742a0 	ldr	x0, [x21, #3712]
  411b9c:	aa1303e1 	mov	x1, x19
  411ba0:	9100c000 	add	x0, x0, #0x30
  411ba4:	97ffff34 	bl	411874 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  411ba8:	39406660 	ldrb	w0, [x19, #25]
  411bac:	32196000 	orr	w0, w0, #0xffffff80
  411bb0:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411bb4:	f00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  411bb8:	f9471000 	ldr	x0, [x0, #3616]
  411bbc:	eb00027f 	cmp	x19, x0
  411bc0:	54000241 	b.ne	411c08 <move_thread_to_end_of_prio_q+0x9c>  // b.any
  411bc4:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411bc8:	91349e73 	add	x19, x19, #0xd27
  411bcc:	aa1303e2 	mov	x2, x19
  411bd0:	52801783 	mov	w3, #0xbc                  	// #188
  411bd4:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411bd8:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411bdc:	913cf821 	add	x1, x1, #0xf3e
  411be0:	91353400 	add	x0, x0, #0xd4d
  411be4:	97ffcd76 	bl	4051bc <assert_print>
  411be8:	aa1303e0 	mov	x0, x19
  411bec:	52801781 	mov	w1, #0xbc                  	// #188
  411bf0:	97ffcd9d 	bl	405264 <assert_post_action>
  411bf4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411bf8:	aa1303e1 	mov	x1, x19
  411bfc:	91362c00 	add	x0, x0, #0xd8b
  411c00:	52801782 	mov	w2, #0xbc                  	// #188
  411c04:	97ffd78a 	bl	407a2c <posix_print_error_and_exit>
  411c08:	f94742b6 	ldr	x22, [x21, #3712]
  411c0c:	aa1603e0 	mov	x0, x22
  411c10:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411c14:	eb00029f 	cmp	x20, x0
  411c18:	54000261 	b.ne	411c64 <move_thread_to_end_of_prio_q+0xf8>  // b.any
	sys_dnode_t *const tail = list->tail;
  411c1c:	f94742a0 	ldr	x0, [x21, #3712]
	node->next = list;
  411c20:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  411c24:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  411c28:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  411c2c:	f9000033 	str	x19, [x1]
	list->tail = node;
  411c30:	f9001c13 	str	x19, [x0, #56]
	update_cache(thread == _current);
  411c34:	f94742b5 	ldr	x21, [x21, #3712]
  411c38:	f9400aa0 	ldr	x0, [x21, #16]
}
  411c3c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	update_cache(thread == _current);
  411c40:	eb13001f 	cmp	x0, x19
}
  411c44:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  411c48:	1a9f17e0 	cset	w0, eq  // eq = none
}
  411c4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	update_cache(thread == _current);
  411c50:	17ffff91 	b	411a94 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  411c54:	f9401ec0 	ldr	x0, [x22, #56]
  411c58:	eb14001f 	cmp	x0, x20
  411c5c:	54fffe00 	b.eq	411c1c <move_thread_to_end_of_prio_q+0xb0>  // b.none
  411c60:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  411c64:	b4fffdd4 	cbz	x20, 411c1c <move_thread_to_end_of_prio_q+0xb0>
		if (z_sched_prio_cmp(thread, t) > 0) {
  411c68:	aa1403e1 	mov	x1, x20
  411c6c:	aa1303e0 	mov	x0, x19
  411c70:	97fffe1d 	bl	4114e4 <z_sched_prio_cmp>
  411c74:	7100001f 	cmp	w0, #0x0
  411c78:	54fffeed 	b.le	411c54 <move_thread_to_end_of_prio_q+0xe8>
	sys_dnode_t *const prev = successor->prev;
  411c7c:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  411c80:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  411c84:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411c88:	f9000693 	str	x19, [x20, #8]
}
  411c8c:	17ffffea 	b	411c34 <move_thread_to_end_of_prio_q+0xc8>

0000000000411c90 <z_time_slice>:
{
  411c90:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411c94:	910003fd 	mov	x29, sp
  411c98:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411c9c:	f00000d4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  411ca0:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  411ca4:	97ffd64c 	bl	4075d4 <posix_irq_lock>
  411ca8:	2a0003f6 	mov	w22, w0
  411cac:	f947d695 	ldr	x21, [x20, #4008]
  411cb0:	aa1503e0 	mov	x0, x21
  411cb4:	97fff63f 	bl	40f5b0 <z_spin_lock_valid>
  411cb8:	72001c1f 	tst	w0, #0xff
  411cbc:	540002c1 	b.ne	411d14 <z_time_slice+0x84>  // b.any
  411cc0:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411cc4:	9122ce73 	add	x19, x19, #0x8b3
  411cc8:	aa1303e2 	mov	x2, x19
  411ccc:	52801283 	mov	w3, #0x94                  	// #148
  411cd0:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411cd4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411cd8:	91238021 	add	x1, x1, #0x8e0
  411cdc:	91353400 	add	x0, x0, #0xd4d
  411ce0:	97ffcd37 	bl	4051bc <assert_print>
  411ce4:	aa1503e1 	mov	x1, x21
  411ce8:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411cec:	9123d400 	add	x0, x0, #0x8f5
  411cf0:	97ffcd33 	bl	4051bc <assert_print>
  411cf4:	aa1303e0 	mov	x0, x19
  411cf8:	52801281 	mov	w1, #0x94                  	// #148
  411cfc:	97ffcd5a 	bl	405264 <assert_post_action>
  411d00:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411d04:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411d08:	aa1303e1 	mov	x1, x19
  411d0c:	91362c00 	add	x0, x0, #0xd8b
  411d10:	97ffd747 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411d14:	aa1503e0 	mov	x0, x21
  411d18:	97fff63e 	bl	40f610 <z_spin_lock_set_owner>
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  411d1c:	f00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  411d20:	f00000e2 	adrp	x2, 430000 <stdout_buff+0x6f>
  411d24:	91024842 	add	x2, x2, #0x92
  411d28:	f9474021 	ldr	x1, [x1, #3712]
  411d2c:	39408020 	ldrb	w0, [x1, #32]
  411d30:	38606840 	ldrb	w0, [x2, x0]
  411d34:	340001a0 	cbz	w0, 411d68 <z_time_slice+0xd8>
	struct k_thread *curr = _current;
  411d38:	f9400833 	ldr	x19, [x1, #16]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  411d3c:	aa1303e0 	mov	x0, x19
  411d40:	97fffdae 	bl	4113f8 <sliceable>
  411d44:	72001c1f 	tst	w0, #0xff
  411d48:	54000100 	b.eq	411d68 <z_time_slice+0xd8>  // b.none
		if (!z_is_thread_prevented_from_running(curr)) {
  411d4c:	39406660 	ldrb	w0, [x19, #25]
  411d50:	f240101f 	tst	x0, #0x1f
  411d54:	54000061 	b.ne	411d60 <z_time_slice+0xd0>  // b.any
			move_thread_to_end_of_prio_q(curr);
  411d58:	aa1303e0 	mov	x0, x19
  411d5c:	97ffff84 	bl	411b6c <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
  411d60:	aa1303e0 	mov	x0, x19
  411d64:	97fffde6 	bl	4114fc <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411d68:	f947d694 	ldr	x20, [x20, #4008]
  411d6c:	aa1403e0 	mov	x0, x20
  411d70:	97fff61b 	bl	40f5dc <z_spin_unlock_valid>
  411d74:	72001c1f 	tst	w0, #0xff
  411d78:	54000261 	b.ne	411dc4 <z_time_slice+0x134>  // b.any
  411d7c:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411d80:	9122ce73 	add	x19, x19, #0x8b3
  411d84:	aa1303e2 	mov	x2, x19
  411d88:	52801863 	mov	w3, #0xc3                  	// #195
  411d8c:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411d90:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411d94:	91255821 	add	x1, x1, #0x956
  411d98:	91353400 	add	x0, x0, #0xd4d
  411d9c:	97ffcd08 	bl	4051bc <assert_print>
  411da0:	aa1403e1 	mov	x1, x20
  411da4:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411da8:	9125b400 	add	x0, x0, #0x96d
  411dac:	97ffcd04 	bl	4051bc <assert_print>
  411db0:	aa1303e0 	mov	x0, x19
  411db4:	52801861 	mov	w1, #0xc3                  	// #195
  411db8:	97ffcd2b 	bl	405264 <assert_post_action>
  411dbc:	52801862 	mov	w2, #0xc3                  	// #195
  411dc0:	17ffffd1 	b	411d04 <z_time_slice+0x74>
	posix_irq_unlock(key);
  411dc4:	2a1603e0 	mov	w0, w22
}
  411dc8:	a94153f3 	ldp	x19, x20, [sp, #16]
  411dcc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411dd0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411dd4:	17ffd602 	b	4075dc <posix_irq_unlock>

0000000000411dd8 <ready_thread>:
{
  411dd8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411ddc:	910003fd 	mov	x29, sp
  411de0:	a90153f3 	stp	x19, x20, [sp, #16]
  411de4:	aa0003f3 	mov	x19, x0
  411de8:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  411dec:	39c06661 	ldrsb	w1, [x19, #25]
  411df0:	39406400 	ldrb	w0, [x0, #25]
  411df4:	37f807a1 	tbnz	w1, #31, 411ee8 <ready_thread+0x110>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  411df8:	f240101f 	tst	x0, #0x1f
  411dfc:	54000761 	b.ne	411ee8 <ready_thread+0x110>  // b.any
  411e00:	f9401661 	ldr	x1, [x19, #40]
  411e04:	b5000721 	cbnz	x1, 411ee8 <ready_thread+0x110>
	thread->base.thread_state |= _THREAD_QUEUED;
  411e08:	32196000 	orr	w0, w0, #0xffffff80
  411e0c:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  411e10:	f00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  411e14:	f9471000 	ldr	x0, [x0, #3616]
  411e18:	eb00027f 	cmp	x19, x0
  411e1c:	54000241 	b.ne	411e64 <ready_thread+0x8c>  // b.any
  411e20:	b0000033 	adrp	x19, 416000 <__func__.0+0x57a>
  411e24:	91349e73 	add	x19, x19, #0xd27
  411e28:	aa1303e2 	mov	x2, x19
  411e2c:	52801783 	mov	w3, #0xbc                  	// #188
  411e30:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411e34:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411e38:	913cf821 	add	x1, x1, #0xf3e
  411e3c:	91353400 	add	x0, x0, #0xd4d
  411e40:	97ffccdf 	bl	4051bc <assert_print>
  411e44:	aa1303e0 	mov	x0, x19
  411e48:	52801781 	mov	w1, #0xbc                  	// #188
  411e4c:	97ffcd06 	bl	405264 <assert_post_action>
  411e50:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411e54:	aa1303e1 	mov	x1, x19
  411e58:	91362c00 	add	x0, x0, #0xd8b
  411e5c:	52801782 	mov	w2, #0xbc                  	// #188
  411e60:	97ffd6f3 	bl	407a2c <posix_print_error_and_exit>
	return list->head == list;
  411e64:	f00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  411e68:	aa0003f5 	mov	x21, x0
  411e6c:	f9474016 	ldr	x22, [x0, #3712]
  411e70:	aa1603e1 	mov	x1, x22
  411e74:	f8430c34 	ldr	x20, [x1, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  411e78:	eb01029f 	cmp	x20, x1
  411e7c:	54000201 	b.ne	411ebc <ready_thread+0xe4>  // b.any
	sys_dnode_t *const tail = list->tail;
  411e80:	f94742a0 	ldr	x0, [x21, #3712]
	node->next = list;
  411e84:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  411e88:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  411e8c:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  411e90:	f9000033 	str	x19, [x1]
	list->tail = node;
  411e94:	f9001c13 	str	x19, [x0, #56]
}
  411e98:	a94153f3 	ldp	x19, x20, [sp, #16]
		update_cache(0);
  411e9c:	52800000 	mov	w0, #0x0                   	// #0
}
  411ea0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411ea4:	a8c37bfd 	ldp	x29, x30, [sp], #48
		update_cache(0);
  411ea8:	17fffefb 	b	411a94 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  411eac:	f9401ec0 	ldr	x0, [x22, #56]
  411eb0:	eb14001f 	cmp	x0, x20
  411eb4:	54fffe60 	b.eq	411e80 <ready_thread+0xa8>  // b.none
  411eb8:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  411ebc:	b4fffe34 	cbz	x20, 411e80 <ready_thread+0xa8>
		if (z_sched_prio_cmp(thread, t) > 0) {
  411ec0:	aa1403e1 	mov	x1, x20
  411ec4:	aa1303e0 	mov	x0, x19
  411ec8:	97fffd87 	bl	4114e4 <z_sched_prio_cmp>
  411ecc:	7100001f 	cmp	w0, #0x0
  411ed0:	54fffeed 	b.le	411eac <ready_thread+0xd4>
	sys_dnode_t *const prev = successor->prev;
  411ed4:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  411ed8:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  411edc:	f9000013 	str	x19, [x0]
	successor->prev = node;
  411ee0:	f9000693 	str	x19, [x20, #8]
}
  411ee4:	17ffffed 	b	411e98 <ready_thread+0xc0>
}
  411ee8:	a94153f3 	ldp	x19, x20, [sp, #16]
  411eec:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411ef0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411ef4:	d65f03c0 	ret

0000000000411ef8 <z_ready_thread>:
{
  411ef8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411efc:	910003fd 	mov	x29, sp
  411f00:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411f04:	f00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  411f08:	f90013f5 	str	x21, [sp, #32]
  411f0c:	aa0003f5 	mov	x21, x0
	return posix_irq_lock();
  411f10:	97ffd5b1 	bl	4075d4 <posix_irq_lock>
  411f14:	2a0003f4 	mov	w20, w0
  411f18:	f947d673 	ldr	x19, [x19, #4008]
  411f1c:	aa1303e0 	mov	x0, x19
  411f20:	97fff5a4 	bl	40f5b0 <z_spin_lock_valid>
  411f24:	72001c1f 	tst	w0, #0xff
  411f28:	540002c1 	b.ne	411f80 <z_ready_thread+0x88>  // b.any
  411f2c:	b0000034 	adrp	x20, 416000 <__func__.0+0x57a>
  411f30:	9122ce94 	add	x20, x20, #0x8b3
  411f34:	aa1403e2 	mov	x2, x20
  411f38:	52801283 	mov	w3, #0x94                  	// #148
  411f3c:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411f40:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411f44:	91238021 	add	x1, x1, #0x8e0
  411f48:	91353400 	add	x0, x0, #0xd4d
  411f4c:	97ffcc9c 	bl	4051bc <assert_print>
  411f50:	aa1303e1 	mov	x1, x19
  411f54:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411f58:	9123d400 	add	x0, x0, #0x8f5
  411f5c:	97ffcc98 	bl	4051bc <assert_print>
  411f60:	aa1403e0 	mov	x0, x20
  411f64:	52801281 	mov	w1, #0x94                  	// #148
  411f68:	97ffccbf 	bl	405264 <assert_post_action>
  411f6c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411f70:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411f74:	aa1403e1 	mov	x1, x20
  411f78:	91362c00 	add	x0, x0, #0xd8b
  411f7c:	97ffd6ac 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411f80:	aa1303e0 	mov	x0, x19
  411f84:	97fff5a3 	bl	40f610 <z_spin_lock_set_owner>
			ready_thread(thread);
  411f88:	aa1503e0 	mov	x0, x21
  411f8c:	97ffff93 	bl	411dd8 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411f90:	aa1303e0 	mov	x0, x19
  411f94:	97fff592 	bl	40f5dc <z_spin_unlock_valid>
  411f98:	72001c1f 	tst	w0, #0xff
  411f9c:	54000261 	b.ne	411fe8 <z_ready_thread+0xf0>  // b.any
  411fa0:	b0000034 	adrp	x20, 416000 <__func__.0+0x57a>
  411fa4:	9122ce94 	add	x20, x20, #0x8b3
  411fa8:	aa1403e2 	mov	x2, x20
  411fac:	52801863 	mov	w3, #0xc3                  	// #195
  411fb0:	b0000021 	adrp	x1, 416000 <__func__.0+0x57a>
  411fb4:	f0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  411fb8:	91255821 	add	x1, x1, #0x956
  411fbc:	91353400 	add	x0, x0, #0xd4d
  411fc0:	97ffcc7f 	bl	4051bc <assert_print>
  411fc4:	aa1303e1 	mov	x1, x19
  411fc8:	b0000020 	adrp	x0, 416000 <__func__.0+0x57a>
  411fcc:	9125b400 	add	x0, x0, #0x96d
  411fd0:	97ffcc7b 	bl	4051bc <assert_print>
  411fd4:	aa1403e0 	mov	x0, x20
  411fd8:	52801861 	mov	w1, #0xc3                  	// #195
  411fdc:	97ffcca2 	bl	405264 <assert_post_action>
  411fe0:	52801862 	mov	w2, #0xc3                  	// #195
  411fe4:	17ffffe3 	b	411f70 <z_ready_thread+0x78>
	posix_irq_unlock(key);
  411fe8:	2a1403e0 	mov	w0, w20
}
  411fec:	a94153f3 	ldp	x19, x20, [sp, #16]
  411ff0:	f94013f5 	ldr	x21, [sp, #32]
  411ff4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411ff8:	17ffd579 	b	4075dc <posix_irq_unlock>

0000000000411ffc <z_sched_start>:
{
  411ffc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412000:	910003fd 	mov	x29, sp
  412004:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412008:	d00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  41200c:	aa0003f4 	mov	x20, x0
  412010:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  412014:	97ffd570 	bl	4075d4 <posix_irq_lock>
  412018:	f947d673 	ldr	x19, [x19, #4008]
  41201c:	2a0003f5 	mov	w21, w0
  412020:	aa1303e0 	mov	x0, x19
  412024:	97fff563 	bl	40f5b0 <z_spin_lock_valid>
  412028:	72001c1f 	tst	w0, #0xff
  41202c:	540002c1 	b.ne	412084 <z_sched_start+0x88>  // b.any
  412030:	90000034 	adrp	x20, 416000 <__func__.0+0x57a>
  412034:	9122ce94 	add	x20, x20, #0x8b3
  412038:	aa1403e2 	mov	x2, x20
  41203c:	52801283 	mov	w3, #0x94                  	// #148
  412040:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412044:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412048:	91238021 	add	x1, x1, #0x8e0
  41204c:	91353400 	add	x0, x0, #0xd4d
  412050:	97ffcc5b 	bl	4051bc <assert_print>
  412054:	aa1303e1 	mov	x1, x19
  412058:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  41205c:	9123d400 	add	x0, x0, #0x8f5
  412060:	97ffcc57 	bl	4051bc <assert_print>
  412064:	aa1403e0 	mov	x0, x20
  412068:	52801281 	mov	w1, #0x94                  	// #148
  41206c:	97ffcc7e 	bl	405264 <assert_post_action>
  412070:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412074:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412078:	aa1403e1 	mov	x1, x20
  41207c:	91362c00 	add	x0, x0, #0xd8b
  412080:	97ffd66b 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412084:	aa1303e0 	mov	x0, x19
  412088:	97fff562 	bl	40f610 <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
  41208c:	39406680 	ldrb	w0, [x20, #25]
	if (z_has_thread_started(thread)) {
  412090:	37100380 	tbnz	w0, #2, 412100 <z_sched_start+0x104>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412094:	aa1303e0 	mov	x0, x19
  412098:	97fff551 	bl	40f5dc <z_spin_unlock_valid>
  41209c:	72001c1f 	tst	w0, #0xff
  4120a0:	54000261 	b.ne	4120ec <z_sched_start+0xf0>  // b.any
  4120a4:	90000034 	adrp	x20, 416000 <__func__.0+0x57a>
  4120a8:	9122ce94 	add	x20, x20, #0x8b3
  4120ac:	aa1403e2 	mov	x2, x20
  4120b0:	52801863 	mov	w3, #0xc3                  	// #195
  4120b4:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4120b8:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4120bc:	91255821 	add	x1, x1, #0x956
  4120c0:	91353400 	add	x0, x0, #0xd4d
  4120c4:	97ffcc3e 	bl	4051bc <assert_print>
  4120c8:	aa1303e1 	mov	x1, x19
  4120cc:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4120d0:	9125b400 	add	x0, x0, #0x96d
  4120d4:	97ffcc3a 	bl	4051bc <assert_print>
  4120d8:	aa1403e0 	mov	x0, x20
  4120dc:	52801861 	mov	w1, #0xc3                  	// #195
  4120e0:	97ffcc61 	bl	405264 <assert_post_action>
  4120e4:	52801862 	mov	w2, #0xc3                  	// #195
  4120e8:	17ffffe3 	b	412074 <z_sched_start+0x78>
	posix_irq_unlock(key);
  4120ec:	2a1503e0 	mov	w0, w21
}
  4120f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4120f4:	f94013f5 	ldr	x21, [sp, #32]
  4120f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4120fc:	17ffd538 	b	4075dc <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
  412100:	121d7800 	and	w0, w0, #0xfffffffb
  412104:	39006680 	strb	w0, [x20, #25]
	ready_thread(thread);
  412108:	aa1403e0 	mov	x0, x20
  41210c:	97ffff33 	bl	411dd8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  412110:	2a1503e1 	mov	w1, w21
  412114:	aa1303e0 	mov	x0, x19
}
  412118:	a94153f3 	ldp	x19, x20, [sp, #16]
  41211c:	f94013f5 	ldr	x21, [sp, #32]
  412120:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&sched_spinlock, key);
  412124:	17fffd1a 	b	41158c <z_reschedule>

0000000000412128 <z_sched_wake_thread>:
{
  412128:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  41212c:	910003fd 	mov	x29, sp
  412130:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412134:	d00000d4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  412138:	aa0003f3 	mov	x19, x0
  41213c:	a9025bf5 	stp	x21, x22, [sp, #32]
  412140:	f9001bf7 	str	x23, [sp, #48]
  412144:	12001c37 	and	w23, w1, #0xff
	return posix_irq_lock();
  412148:	97ffd523 	bl	4075d4 <posix_irq_lock>
  41214c:	2a0003f6 	mov	w22, w0
  412150:	f947d695 	ldr	x21, [x20, #4008]
  412154:	aa1503e0 	mov	x0, x21
  412158:	97fff516 	bl	40f5b0 <z_spin_lock_valid>
  41215c:	72001c1f 	tst	w0, #0xff
  412160:	540002c1 	b.ne	4121b8 <z_sched_wake_thread+0x90>  // b.any
  412164:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412168:	9122ce73 	add	x19, x19, #0x8b3
  41216c:	aa1303e2 	mov	x2, x19
  412170:	52801283 	mov	w3, #0x94                  	// #148
  412174:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412178:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41217c:	91238021 	add	x1, x1, #0x8e0
  412180:	91353400 	add	x0, x0, #0xd4d
  412184:	97ffcc0e 	bl	4051bc <assert_print>
  412188:	aa1503e1 	mov	x1, x21
  41218c:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412190:	9123d400 	add	x0, x0, #0x8f5
  412194:	97ffcc0a 	bl	4051bc <assert_print>
  412198:	aa1303e0 	mov	x0, x19
  41219c:	52801281 	mov	w1, #0x94                  	// #148
  4121a0:	97ffcc31 	bl	405264 <assert_post_action>
  4121a4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4121a8:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4121ac:	aa1303e1 	mov	x1, x19
  4121b0:	91362c00 	add	x0, x0, #0xd8b
  4121b4:	97ffd61e 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4121b8:	aa1503e0 	mov	x0, x21
  4121bc:	97fff515 	bl	40f610 <z_spin_lock_set_owner>
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  4121c0:	39422260 	ldrb	w0, [x19, #136]
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
  4121c4:	39406661 	ldrb	w1, [x19, #25]
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  4121c8:	34000060 	cbz	w0, 4121d4 <z_sched_wake_thread+0xac>
		thread->no_wake_on_timeout = false;
  4121cc:	3902227f 	strb	wzr, [x19, #136]
		if (do_nothing) {
  4121d0:	35000237 	cbnz	w23, 412214 <z_sched_wake_thread+0xec>
		if (!killed) {
  4121d4:	52800500 	mov	w0, #0x28                  	// #40
  4121d8:	6a00003f 	tst	w1, w0
  4121dc:	540001c1 	b.ne	412214 <z_sched_wake_thread+0xec>  // b.any
			if (thread->base.pended_on != NULL) {
  4121e0:	f9400a60 	ldr	x0, [x19, #16]
  4121e4:	b4000060 	cbz	x0, 4121f0 <z_sched_wake_thread+0xc8>
				unpend_thread_no_timeout(thread);
  4121e8:	aa1303e0 	mov	x0, x19
  4121ec:	97fffdbf 	bl	4118e8 <unpend_thread_no_timeout>
  4121f0:	39406662 	ldrb	w2, [x19, #25]
  4121f4:	710002ff 	cmp	w23, #0x0
  4121f8:	12800281 	mov	w1, #0xffffffeb            	// #-21
			ready_thread(thread);
  4121fc:	aa1303e0 	mov	x0, x19
  412200:	0a010041 	and	w1, w2, w1
  412204:	121d7842 	and	w2, w2, #0xfffffffb
  412208:	1a810042 	csel	w2, w2, w1, eq  // eq = none
  41220c:	39006662 	strb	w2, [x19, #25]
  412210:	97fffef2 	bl	411dd8 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412214:	f947d694 	ldr	x20, [x20, #4008]
  412218:	aa1403e0 	mov	x0, x20
  41221c:	97fff4f0 	bl	40f5dc <z_spin_unlock_valid>
  412220:	72001c1f 	tst	w0, #0xff
  412224:	54000261 	b.ne	412270 <z_sched_wake_thread+0x148>  // b.any
  412228:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  41222c:	9122ce73 	add	x19, x19, #0x8b3
  412230:	aa1303e2 	mov	x2, x19
  412234:	52801863 	mov	w3, #0xc3                  	// #195
  412238:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  41223c:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412240:	91255821 	add	x1, x1, #0x956
  412244:	91353400 	add	x0, x0, #0xd4d
  412248:	97ffcbdd 	bl	4051bc <assert_print>
  41224c:	aa1403e1 	mov	x1, x20
  412250:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412254:	9125b400 	add	x0, x0, #0x96d
  412258:	97ffcbd9 	bl	4051bc <assert_print>
  41225c:	aa1303e0 	mov	x0, x19
  412260:	52801861 	mov	w1, #0xc3                  	// #195
  412264:	97ffcc00 	bl	405264 <assert_post_action>
  412268:	52801862 	mov	w2, #0xc3                  	// #195
  41226c:	17ffffcf 	b	4121a8 <z_sched_wake_thread+0x80>
	posix_irq_unlock(key);
  412270:	2a1603e0 	mov	w0, w22
}
  412274:	a94153f3 	ldp	x19, x20, [sp, #16]
  412278:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41227c:	f9401bf7 	ldr	x23, [sp, #48]
  412280:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412284:	17ffd4d6 	b	4075dc <posix_irq_unlock>

0000000000412288 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
  412288:	d100a000 	sub	x0, x0, #0x28
  41228c:	52800021 	mov	w1, #0x1                   	// #1
  412290:	17ffffa6 	b	412128 <z_sched_wake_thread>

0000000000412294 <unready_thread>:
{
  412294:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  412298:	910003fd 	mov	x29, sp
  41229c:	a90153f3 	stp	x19, x20, [sp, #16]
  4122a0:	aa0003f3 	mov	x19, x0
	return (thread->base.thread_state & state) != 0U;
  4122a4:	d00000d4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  4122a8:	39406400 	ldrb	w0, [x0, #25]
	if (z_is_thread_queued(thread)) {
  4122ac:	39c06661 	ldrsb	w1, [x19, #25]
  4122b0:	36f800e1 	tbz	w1, #31, 4122cc <unready_thread+0x38>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4122b4:	12001800 	and	w0, w0, #0x7f
  4122b8:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4122bc:	f9474280 	ldr	x0, [x20, #3712]
  4122c0:	aa1303e1 	mov	x1, x19
  4122c4:	9100c000 	add	x0, x0, #0x30
  4122c8:	97fffd6b 	bl	411874 <z_priq_dumb_remove>
	update_cache(thread == _current);
  4122cc:	f9474294 	ldr	x20, [x20, #3712]
  4122d0:	f9400a80 	ldr	x0, [x20, #16]
  4122d4:	eb13001f 	cmp	x0, x19
}
  4122d8:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  4122dc:	1a9f17e0 	cset	w0, eq  // eq = none
}
  4122e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	update_cache(thread == _current);
  4122e4:	17fffdec 	b	411a94 <update_cache>

00000000004122e8 <add_to_waitq_locked>:
{
  4122e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4122ec:	910003fd 	mov	x29, sp
  4122f0:	a90153f3 	stp	x19, x20, [sp, #16]
  4122f4:	aa0003f3 	mov	x19, x0
  4122f8:	aa0103f4 	mov	x20, x1
  4122fc:	f90013f5 	str	x21, [sp, #32]
	unready_thread(thread);
  412300:	97ffffe5 	bl	412294 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
  412304:	39406660 	ldrb	w0, [x19, #25]
  412308:	321f0000 	orr	w0, w0, #0x2
  41230c:	39006660 	strb	w0, [x19, #25]
	if (wait_q != NULL) {
  412310:	b40003d4 	cbz	x20, 412388 <add_to_waitq_locked+0xa0>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  412314:	d00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
		thread->base.pended_on = wait_q;
  412318:	f9000a74 	str	x20, [x19, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  41231c:	f9471000 	ldr	x0, [x0, #3616]
  412320:	eb00027f 	cmp	x19, x0
  412324:	54000241 	b.ne	41236c <add_to_waitq_locked+0x84>  // b.any
  412328:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  41232c:	91349e73 	add	x19, x19, #0xd27
  412330:	aa1303e2 	mov	x2, x19
  412334:	52801783 	mov	w3, #0xbc                  	// #188
  412338:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  41233c:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412340:	913cf821 	add	x1, x1, #0xf3e
  412344:	91353400 	add	x0, x0, #0xd4d
  412348:	97ffcb9d 	bl	4051bc <assert_print>
  41234c:	aa1303e0 	mov	x0, x19
  412350:	52801781 	mov	w1, #0xbc                  	// #188
  412354:	97ffcbc4 	bl	405264 <assert_post_action>
  412358:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41235c:	aa1303e1 	mov	x1, x19
  412360:	91362c00 	add	x0, x0, #0xd8b
  412364:	52801782 	mov	w2, #0xbc                  	// #188
  412368:	97ffd5b1 	bl	407a2c <posix_print_error_and_exit>
	return list->head == list;
  41236c:	f9400295 	ldr	x21, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412370:	eb15029f 	cmp	x20, x21
  412374:	540001a1 	b.ne	4123a8 <add_to_waitq_locked+0xc0>  // b.any
	sys_dnode_t *const tail = list->tail;
  412378:	f9400680 	ldr	x0, [x20, #8]
	node->prev = tail;
  41237c:	a9000274 	stp	x20, x0, [x19]
	tail->next = node;
  412380:	f9000013 	str	x19, [x0]
	list->tail = node;
  412384:	f9000693 	str	x19, [x20, #8]
}
  412388:	a94153f3 	ldp	x19, x20, [sp, #16]
  41238c:	f94013f5 	ldr	x21, [sp, #32]
  412390:	a8c37bfd 	ldp	x29, x30, [sp], #48
  412394:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
  412398:	f9400680 	ldr	x0, [x20, #8]
  41239c:	eb15001f 	cmp	x0, x21
  4123a0:	54fffec0 	b.eq	412378 <add_to_waitq_locked+0x90>  // b.none
  4123a4:	f94002b5 	ldr	x21, [x21]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  4123a8:	b4fffe95 	cbz	x21, 412378 <add_to_waitq_locked+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
  4123ac:	aa1503e1 	mov	x1, x21
  4123b0:	aa1303e0 	mov	x0, x19
  4123b4:	97fffc4c 	bl	4114e4 <z_sched_prio_cmp>
  4123b8:	7100001f 	cmp	w0, #0x0
  4123bc:	54fffeed 	b.le	412398 <add_to_waitq_locked+0xb0>
	sys_dnode_t *const prev = successor->prev;
  4123c0:	f94006a0 	ldr	x0, [x21, #8]
	node->prev = prev;
  4123c4:	a9000275 	stp	x21, x0, [x19]
	prev->next = node;
  4123c8:	f9000013 	str	x19, [x0]
	successor->prev = node;
  4123cc:	f90006b3 	str	x19, [x21, #8]
}
  4123d0:	17ffffee 	b	412388 <add_to_waitq_locked+0xa0>

00000000004123d4 <pend_locked>:
{
  4123d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4123d8:	910003fd 	mov	x29, sp
  4123dc:	a90153f3 	stp	x19, x20, [sp, #16]
  4123e0:	aa0203f3 	mov	x19, x2
  4123e4:	aa0003f4 	mov	x20, x0
	add_to_waitq_locked(thread, wait_q);
  4123e8:	97ffffc0 	bl	4122e8 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4123ec:	b100067f 	cmn	x19, #0x1
  4123f0:	54000100 	b.eq	412410 <pend_locked+0x3c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  4123f4:	aa1303e2 	mov	x2, x19
  4123f8:	9100a280 	add	x0, x20, #0x28
  4123fc:	d00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
}
  412400:	a94153f3 	ldp	x19, x20, [sp, #16]
  412404:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412408:	f9473021 	ldr	x1, [x1, #3680]
  41240c:	14000587 	b	413a28 <z_add_timeout>
  412410:	a94153f3 	ldp	x19, x20, [sp, #16]
  412414:	a8c27bfd 	ldp	x29, x30, [sp], #32
  412418:	d65f03c0 	ret

000000000041241c <z_pend_curr>:
{
  41241c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412420:	910003fd 	mov	x29, sp
  412424:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  412428:	d00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  41242c:	f947d673 	ldr	x19, [x19, #4008]
{
  412430:	a9025bf5 	stp	x21, x22, [sp, #32]
  412434:	f9001bf7 	str	x23, [sp, #48]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  412438:	eb13001f 	cmp	x0, x19
  41243c:	54000201 	b.ne	41247c <z_pend_curr+0x60>  // b.any
  412440:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412444:	91349e73 	add	x19, x19, #0xd27
  412448:	aa1303e2 	mov	x2, x19
  41244c:	52806a43 	mov	w3, #0x352                 	// #850
  412450:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412454:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412458:	913e7421 	add	x1, x1, #0xf9d
  41245c:	91353400 	add	x0, x0, #0xd4d
  412460:	97ffcb57 	bl	4051bc <assert_print>
  412464:	aa1303e0 	mov	x0, x19
  412468:	52806a41 	mov	w1, #0x352                 	// #850
  41246c:	97ffcb7e 	bl	405264 <assert_post_action>
  412470:	52806a42 	mov	w2, #0x352                 	// #850
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412474:	aa1303e1 	mov	x1, x19
  412478:	1400001c 	b	4124e8 <z_pend_curr+0xcc>
  41247c:	aa0003f4 	mov	x20, x0
  412480:	2a0103f5 	mov	w21, w1
  412484:	aa0203f6 	mov	x22, x2
  412488:	aa0303f7 	mov	x23, x3
	return posix_irq_lock();
  41248c:	97ffd452 	bl	4075d4 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412490:	aa1303e0 	mov	x0, x19
  412494:	97fff447 	bl	40f5b0 <z_spin_lock_valid>
  412498:	72001c1f 	tst	w0, #0xff
  41249c:	540002c1 	b.ne	4124f4 <z_pend_curr+0xd8>  // b.any
  4124a0:	90000034 	adrp	x20, 416000 <__func__.0+0x57a>
  4124a4:	9122ce94 	add	x20, x20, #0x8b3
  4124a8:	aa1403e2 	mov	x2, x20
  4124ac:	52801283 	mov	w3, #0x94                  	// #148
  4124b0:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4124b4:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4124b8:	91238021 	add	x1, x1, #0x8e0
  4124bc:	91353400 	add	x0, x0, #0xd4d
  4124c0:	97ffcb3f 	bl	4051bc <assert_print>
  4124c4:	aa1303e1 	mov	x1, x19
  4124c8:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4124cc:	9123d400 	add	x0, x0, #0x8f5
  4124d0:	97ffcb3b 	bl	4051bc <assert_print>
  4124d4:	aa1403e0 	mov	x0, x20
  4124d8:	52801281 	mov	w1, #0x94                  	// #148
  4124dc:	97ffcb62 	bl	405264 <assert_post_action>
  4124e0:	52801282 	mov	w2, #0x94                  	// #148
  4124e4:	aa1403e1 	mov	x1, x20
  4124e8:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4124ec:	91362c00 	add	x0, x0, #0xd8b
  4124f0:	97ffd54f 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4124f4:	aa1303e0 	mov	x0, x19
  4124f8:	97fff446 	bl	40f610 <z_spin_lock_set_owner>
	pend_locked(_current, wait_q, timeout);
  4124fc:	d00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  412500:	aa1703e2 	mov	x2, x23
  412504:	aa1603e1 	mov	x1, x22
  412508:	f9474000 	ldr	x0, [x0, #3712]
  41250c:	f9400800 	ldr	x0, [x0, #16]
  412510:	97ffffb1 	bl	4123d4 <pend_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412514:	aa1403e0 	mov	x0, x20
  412518:	97fff431 	bl	40f5dc <z_spin_unlock_valid>
  41251c:	72001c1f 	tst	w0, #0xff
  412520:	54000261 	b.ne	41256c <z_pend_curr+0x150>  // b.any
  412524:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412528:	9122ce73 	add	x19, x19, #0x8b3
  41252c:	aa1303e2 	mov	x2, x19
  412530:	52801c43 	mov	w3, #0xe2                  	// #226
  412534:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412538:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41253c:	91255821 	add	x1, x1, #0x956
  412540:	91353400 	add	x0, x0, #0xd4d
  412544:	97ffcb1e 	bl	4051bc <assert_print>
  412548:	aa1403e1 	mov	x1, x20
  41254c:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412550:	9125b400 	add	x0, x0, #0x96d
  412554:	97ffcb1a 	bl	4051bc <assert_print>
  412558:	aa1303e0 	mov	x0, x19
  41255c:	52801c41 	mov	w1, #0xe2                  	// #226
  412560:	97ffcb41 	bl	405264 <assert_post_action>
  412564:	52801c42 	mov	w2, #0xe2                  	// #226
  412568:	17ffffc3 	b	412474 <z_pend_curr+0x58>
  41256c:	aa1303e0 	mov	x0, x19
  412570:	97fff41b 	bl	40f5dc <z_spin_unlock_valid>
  412574:	72001c1f 	tst	w0, #0xff
  412578:	54000261 	b.ne	4125c4 <z_pend_curr+0x1a8>  // b.any
  41257c:	90000034 	adrp	x20, 416000 <__func__.0+0x57a>
  412580:	9122ce94 	add	x20, x20, #0x8b3
  412584:	aa1403e2 	mov	x2, x20
  412588:	52801c43 	mov	w3, #0xe2                  	// #226
  41258c:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412590:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412594:	91255821 	add	x1, x1, #0x956
  412598:	91353400 	add	x0, x0, #0xd4d
  41259c:	97ffcb08 	bl	4051bc <assert_print>
  4125a0:	aa1303e1 	mov	x1, x19
  4125a4:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4125a8:	9125b400 	add	x0, x0, #0x96d
  4125ac:	97ffcb04 	bl	4051bc <assert_print>
  4125b0:	aa1403e0 	mov	x0, x20
  4125b4:	52801c41 	mov	w1, #0xe2                  	// #226
  4125b8:	97ffcb2b 	bl	405264 <assert_post_action>
  4125bc:	52801c42 	mov	w2, #0xe2                  	// #226
  4125c0:	17ffffc9 	b	4124e4 <z_pend_curr+0xc8>
  4125c4:	2a1503e0 	mov	w0, w21
}
  4125c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4125cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4125d0:	f9401bf7 	ldr	x23, [sp, #48]
  4125d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4125d8:	17ffd0d5 	b	40692c <arch_swap>

00000000004125dc <z_set_prio>:
{
  4125dc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4125e0:	910003fd 	mov	x29, sp
  4125e4:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4125e8:	d00000d8 	adrp	x24, 42c000 <__FRAME_END__+0xfbbc>
  4125ec:	a90153f3 	stp	x19, x20, [sp, #16]
  4125f0:	aa0003f3 	mov	x19, x0
  4125f4:	a9025bf5 	stp	x21, x22, [sp, #32]
  4125f8:	2a0103f5 	mov	w21, w1
  4125fc:	f90023f9 	str	x25, [sp, #64]
  412600:	97ffd3f5 	bl	4075d4 <posix_irq_lock>
  412604:	f947d719 	ldr	x25, [x24, #4008]
  412608:	2a0003f7 	mov	w23, w0
  41260c:	aa1903e0 	mov	x0, x25
  412610:	97fff3e8 	bl	40f5b0 <z_spin_lock_valid>
  412614:	72001c16 	ands	w22, w0, #0xff
  412618:	540002c1 	b.ne	412670 <z_set_prio+0x94>  // b.any
  41261c:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412620:	9122ce73 	add	x19, x19, #0x8b3
  412624:	aa1303e2 	mov	x2, x19
  412628:	52801283 	mov	w3, #0x94                  	// #148
  41262c:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412630:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412634:	91238021 	add	x1, x1, #0x8e0
  412638:	91353400 	add	x0, x0, #0xd4d
  41263c:	97ffcae0 	bl	4051bc <assert_print>
  412640:	aa1903e1 	mov	x1, x25
  412644:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412648:	9123d400 	add	x0, x0, #0x8f5
  41264c:	97ffcadc 	bl	4051bc <assert_print>
  412650:	aa1303e0 	mov	x0, x19
  412654:	52801281 	mov	w1, #0x94                  	// #148
  412658:	97ffcb03 	bl	405264 <assert_post_action>
  41265c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  412660:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412664:	aa1303e1 	mov	x1, x19
  412668:	91362c00 	add	x0, x0, #0xd8b
  41266c:	97ffd4f0 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412670:	aa1903e0 	mov	x0, x25
  412674:	97fff3e7 	bl	40f610 <z_spin_lock_set_owner>
	uint8_t state = thread->base.thread_state;
  412678:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  41267c:	13001eb5 	sxtb	w21, w21
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  412680:	f240101f 	tst	x0, #0x1f
  412684:	54000a61 	b.ne	4127d0 <z_set_prio+0x1f4>  // b.any
		if (need_sched) {
  412688:	f9401661 	ldr	x1, [x19, #40]
  41268c:	b5000a21 	cbnz	x1, 4127d0 <z_set_prio+0x1f4>
	_priq_run_remove(thread_runq(thread), thread);
  412690:	d00000d4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  412694:	12001800 	and	w0, w0, #0x7f
  412698:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  41269c:	aa1303e1 	mov	x1, x19
  4126a0:	f9474299 	ldr	x25, [x20, #3712]
  4126a4:	9100c320 	add	x0, x25, #0x30
  4126a8:	97fffc73 	bl	411874 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  4126ac:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  4126b0:	39006a75 	strb	w21, [x19, #26]
	thread->base.thread_state |= _THREAD_QUEUED;
  4126b4:	aa1403f5 	mov	x21, x20
  4126b8:	32196000 	orr	w0, w0, #0xffffff80
  4126bc:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4126c0:	d00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4126c4:	f9471000 	ldr	x0, [x0, #3616]
  4126c8:	eb00027f 	cmp	x19, x0
  4126cc:	540001e1 	b.ne	412708 <z_set_prio+0x12c>  // b.any
  4126d0:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4126d4:	91349e73 	add	x19, x19, #0xd27
  4126d8:	aa1303e2 	mov	x2, x19
  4126dc:	52801783 	mov	w3, #0xbc                  	// #188
  4126e0:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4126e4:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4126e8:	913cf821 	add	x1, x1, #0xf3e
  4126ec:	91353400 	add	x0, x0, #0xd4d
  4126f0:	97ffcab3 	bl	4051bc <assert_print>
  4126f4:	aa1303e0 	mov	x0, x19
  4126f8:	52801781 	mov	w1, #0xbc                  	// #188
  4126fc:	97ffcada 	bl	405264 <assert_post_action>
  412700:	52801782 	mov	w2, #0xbc                  	// #188
  412704:	17ffffd7 	b	412660 <z_set_prio+0x84>
	return list->head == list;
  412708:	aa1903e0 	mov	x0, x25
  41270c:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412710:	eb00029f 	cmp	x20, x0
  412714:	54000481 	b.ne	4127a4 <z_set_prio+0x1c8>  // b.any
	sys_dnode_t *const tail = list->tail;
  412718:	f94742a2 	ldr	x2, [x21, #3712]
	node->next = list;
  41271c:	9100c041 	add	x1, x2, #0x30
	sys_dnode_t *const tail = list->tail;
  412720:	f9401c40 	ldr	x0, [x2, #56]
	node->prev = tail;
  412724:	a9000261 	stp	x1, x0, [x19]
	tail->next = node;
  412728:	f9000013 	str	x19, [x0]
	list->tail = node;
  41272c:	f9001c53 	str	x19, [x2, #56]
			update_cache(1);
  412730:	52800020 	mov	w0, #0x1                   	// #1
  412734:	97fffcd8 	bl	411a94 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412738:	f947d718 	ldr	x24, [x24, #4008]
  41273c:	aa1803e0 	mov	x0, x24
  412740:	97fff3a7 	bl	40f5dc <z_spin_unlock_valid>
  412744:	72001c1f 	tst	w0, #0xff
  412748:	540004a1 	b.ne	4127dc <z_set_prio+0x200>  // b.any
  41274c:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412750:	9122ce73 	add	x19, x19, #0x8b3
  412754:	aa1303e2 	mov	x2, x19
  412758:	52801863 	mov	w3, #0xc3                  	// #195
  41275c:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412760:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412764:	91255821 	add	x1, x1, #0x956
  412768:	91353400 	add	x0, x0, #0xd4d
  41276c:	97ffca94 	bl	4051bc <assert_print>
  412770:	aa1803e1 	mov	x1, x24
  412774:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412778:	9125b400 	add	x0, x0, #0x96d
  41277c:	97ffca90 	bl	4051bc <assert_print>
  412780:	aa1303e0 	mov	x0, x19
  412784:	52801861 	mov	w1, #0xc3                  	// #195
  412788:	97ffcab7 	bl	405264 <assert_post_action>
  41278c:	52801862 	mov	w2, #0xc3                  	// #195
  412790:	17ffffb4 	b	412660 <z_set_prio+0x84>
	return (node == list->tail) ? NULL : node->next;
  412794:	f9401f20 	ldr	x0, [x25, #56]
  412798:	eb00029f 	cmp	x20, x0
  41279c:	54fffbe0 	b.eq	412718 <z_set_prio+0x13c>  // b.none
  4127a0:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  4127a4:	b4fffbb4 	cbz	x20, 412718 <z_set_prio+0x13c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  4127a8:	aa1403e1 	mov	x1, x20
  4127ac:	aa1303e0 	mov	x0, x19
  4127b0:	97fffb4d 	bl	4114e4 <z_sched_prio_cmp>
  4127b4:	7100001f 	cmp	w0, #0x0
  4127b8:	54fffeed 	b.le	412794 <z_set_prio+0x1b8>
	sys_dnode_t *const prev = successor->prev;
  4127bc:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  4127c0:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  4127c4:	f9000013 	str	x19, [x0]
	successor->prev = node;
  4127c8:	f9000693 	str	x19, [x20, #8]
}
  4127cc:	17ffffd9 	b	412730 <z_set_prio+0x154>
			thread->base.prio = prio;
  4127d0:	52800016 	mov	w22, #0x0                   	// #0
  4127d4:	39006a75 	strb	w21, [x19, #26]
  4127d8:	17ffffd8 	b	412738 <z_set_prio+0x15c>
	posix_irq_unlock(key);
  4127dc:	2a1703e0 	mov	w0, w23
  4127e0:	97ffd37f 	bl	4075dc <posix_irq_unlock>
}
  4127e4:	2a1603e0 	mov	w0, w22
  4127e8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4127ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4127f0:	a94363f7 	ldp	x23, x24, [sp, #48]
  4127f4:	f94023f9 	ldr	x25, [sp, #64]
  4127f8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4127fc:	d65f03c0 	ret

0000000000412800 <z_impl_k_thread_suspend>:
{
  412800:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412804:	910003fd 	mov	x29, sp
  412808:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41280c:	d00000d5 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
  412810:	a90153f3 	stp	x19, x20, [sp, #16]
  412814:	aa0003f3 	mov	x19, x0
	return z_abort_timeout(&thread->base.timeout);
  412818:	9100a000 	add	x0, x0, #0x28
  41281c:	94000515 	bl	413c70 <z_abort_timeout>
	return posix_irq_lock();
  412820:	97ffd36d 	bl	4075d4 <posix_irq_lock>
  412824:	2a0003f6 	mov	w22, w0
  412828:	f947d6b4 	ldr	x20, [x21, #4008]
  41282c:	aa1403e0 	mov	x0, x20
  412830:	97fff360 	bl	40f5b0 <z_spin_lock_valid>
  412834:	72001c1f 	tst	w0, #0xff
  412838:	540002c1 	b.ne	412890 <z_impl_k_thread_suspend+0x90>  // b.any
  41283c:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412840:	9122ce73 	add	x19, x19, #0x8b3
  412844:	aa1303e2 	mov	x2, x19
  412848:	52801283 	mov	w3, #0x94                  	// #148
  41284c:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412850:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412854:	91238021 	add	x1, x1, #0x8e0
  412858:	91353400 	add	x0, x0, #0xd4d
  41285c:	97ffca58 	bl	4051bc <assert_print>
  412860:	aa1403e1 	mov	x1, x20
  412864:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412868:	9123d400 	add	x0, x0, #0x8f5
  41286c:	97ffca54 	bl	4051bc <assert_print>
  412870:	aa1303e0 	mov	x0, x19
  412874:	52801281 	mov	w1, #0x94                  	// #148
  412878:	97ffca7b 	bl	405264 <assert_post_action>
  41287c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412880:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412884:	aa1303e1 	mov	x1, x19
  412888:	91362c00 	add	x0, x0, #0xd8b
  41288c:	97ffd468 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412890:	aa1403e0 	mov	x0, x20
  412894:	97fff35f 	bl	40f610 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
  412898:	39c06661 	ldrsb	w1, [x19, #25]
  41289c:	d00000d4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
	return (thread->base.thread_state & state) != 0U;
  4128a0:	39406660 	ldrb	w0, [x19, #25]
  4128a4:	36f800e1 	tbz	w1, #31, 4128c0 <z_impl_k_thread_suspend+0xc0>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4128a8:	12001800 	and	w0, w0, #0x7f
  4128ac:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4128b0:	f9474280 	ldr	x0, [x20, #3712]
  4128b4:	aa1303e1 	mov	x1, x19
  4128b8:	9100c000 	add	x0, x0, #0x30
  4128bc:	97fffbee 	bl	411874 <z_priq_dumb_remove>
		update_cache(thread == _current);
  4128c0:	f9474294 	ldr	x20, [x20, #3712]
	thread->base.thread_state |= _THREAD_SUSPENDED;
  4128c4:	39406660 	ldrb	w0, [x19, #25]
  4128c8:	321c0000 	orr	w0, w0, #0x10
  4128cc:	39006660 	strb	w0, [x19, #25]
  4128d0:	f9400a80 	ldr	x0, [x20, #16]
  4128d4:	eb13001f 	cmp	x0, x19
  4128d8:	1a9f17e0 	cset	w0, eq  // eq = none
  4128dc:	97fffc6e 	bl	411a94 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4128e0:	f947d6b5 	ldr	x21, [x21, #4008]
  4128e4:	aa1503e0 	mov	x0, x21
  4128e8:	97fff33d 	bl	40f5dc <z_spin_unlock_valid>
  4128ec:	72001c1f 	tst	w0, #0xff
  4128f0:	54000261 	b.ne	41293c <z_impl_k_thread_suspend+0x13c>  // b.any
  4128f4:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  4128f8:	9122ce73 	add	x19, x19, #0x8b3
  4128fc:	aa1303e2 	mov	x2, x19
  412900:	52801863 	mov	w3, #0xc3                  	// #195
  412904:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412908:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41290c:	91255821 	add	x1, x1, #0x956
  412910:	91353400 	add	x0, x0, #0xd4d
  412914:	97ffca2a 	bl	4051bc <assert_print>
  412918:	aa1503e1 	mov	x1, x21
  41291c:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412920:	9125b400 	add	x0, x0, #0x96d
  412924:	97ffca26 	bl	4051bc <assert_print>
  412928:	aa1303e0 	mov	x0, x19
  41292c:	52801861 	mov	w1, #0xc3                  	// #195
  412930:	97ffca4d 	bl	405264 <assert_post_action>
  412934:	52801862 	mov	w2, #0xc3                  	// #195
  412938:	17ffffd2 	b	412880 <z_impl_k_thread_suspend+0x80>
	posix_irq_unlock(key);
  41293c:	2a1603e0 	mov	w0, w22
  412940:	97ffd327 	bl	4075dc <posix_irq_unlock>
	if (thread == _current) {
  412944:	f9400a80 	ldr	x0, [x20, #16]
  412948:	eb13001f 	cmp	x0, x19
  41294c:	540000a1 	b.ne	412960 <z_impl_k_thread_suspend+0x160>  // b.any
}
  412950:	a94153f3 	ldp	x19, x20, [sp, #16]
  412954:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412958:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule_unlocked();
  41295c:	17fffb58 	b	4116bc <z_reschedule_unlocked>
}
  412960:	a94153f3 	ldp	x19, x20, [sp, #16]
  412964:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412968:	a8c37bfd 	ldp	x29, x30, [sp], #48
  41296c:	d65f03c0 	ret

0000000000412970 <k_sched_unlock>:
{
  412970:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  412974:	910003fd 	mov	x29, sp
  412978:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41297c:	d00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
	return posix_irq_lock();
  412980:	97ffd315 	bl	4075d4 <posix_irq_lock>
  412984:	f947d673 	ldr	x19, [x19, #4008]
  412988:	2a0003f4 	mov	w20, w0
  41298c:	aa1303e0 	mov	x0, x19
  412990:	97fff308 	bl	40f5b0 <z_spin_lock_valid>
  412994:	72001c1f 	tst	w0, #0xff
  412998:	54000281 	b.ne	4129e8 <k_sched_unlock+0x78>  // b.any
  41299c:	90000034 	adrp	x20, 416000 <__func__.0+0x57a>
  4129a0:	9122ce94 	add	x20, x20, #0x8b3
  4129a4:	aa1403e2 	mov	x2, x20
  4129a8:	52801283 	mov	w3, #0x94                  	// #148
  4129ac:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  4129b0:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4129b4:	91238021 	add	x1, x1, #0x8e0
  4129b8:	91353400 	add	x0, x0, #0xd4d
  4129bc:	97ffca00 	bl	4051bc <assert_print>
  4129c0:	aa1303e1 	mov	x1, x19
  4129c4:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  4129c8:	9123d400 	add	x0, x0, #0x8f5
  4129cc:	97ffc9fc 	bl	4051bc <assert_print>
  4129d0:	aa1403e0 	mov	x0, x20
  4129d4:	52801281 	mov	w1, #0x94                  	// #148
  4129d8:	97ffca23 	bl	405264 <assert_post_action>
  4129dc:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4129e0:	aa1403e1 	mov	x1, x20
  4129e4:	14000019 	b	412a48 <k_sched_unlock+0xd8>
	z_spin_lock_set_owner(l);
  4129e8:	aa1303e0 	mov	x0, x19
  4129ec:	97fff309 	bl	40f610 <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0U, "");
  4129f0:	d00000c2 	adrp	x2, 42c000 <__FRAME_END__+0xfbbc>
  4129f4:	f9474042 	ldr	x2, [x2, #3712]
  4129f8:	f9400840 	ldr	x0, [x2, #16]
  4129fc:	39406c01 	ldrb	w1, [x0, #27]
  412a00:	350002a1 	cbnz	w1, 412a54 <k_sched_unlock+0xe4>
  412a04:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412a08:	91349e73 	add	x19, x19, #0xd27
  412a0c:	aa1303e2 	mov	x2, x19
  412a10:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412a14:	913f5021 	add	x1, x1, #0xfd4
  412a18:	52807d63 	mov	w3, #0x3eb                 	// #1003
  412a1c:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412a20:	91353400 	add	x0, x0, #0xd4d
  412a24:	97ffc9e6 	bl	4051bc <assert_print>
  412a28:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412a2c:	91254c00 	add	x0, x0, #0x953
  412a30:	97ffc9e3 	bl	4051bc <assert_print>
  412a34:	aa1303e0 	mov	x0, x19
  412a38:	52807d61 	mov	w1, #0x3eb                 	// #1003
  412a3c:	97ffca0a 	bl	405264 <assert_post_action>
  412a40:	52807d62 	mov	w2, #0x3eb                 	// #1003
  412a44:	aa1303e1 	mov	x1, x19
  412a48:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412a4c:	91362c00 	add	x0, x0, #0xd8b
  412a50:	97ffd3f7 	bl	407a2c <posix_print_error_and_exit>
		__ASSERT(!arch_is_in_isr(), "");
  412a54:	b9400042 	ldr	w2, [x2]
  412a58:	34000242 	cbz	w2, 412aa0 <k_sched_unlock+0x130>
  412a5c:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412a60:	91349e73 	add	x19, x19, #0xd27
  412a64:	aa1303e2 	mov	x2, x19
  412a68:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412a6c:	912a6021 	add	x1, x1, #0xa98
  412a70:	52807d83 	mov	w3, #0x3ec                 	// #1004
  412a74:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412a78:	91353400 	add	x0, x0, #0xd4d
  412a7c:	97ffc9d0 	bl	4051bc <assert_print>
  412a80:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412a84:	91254c00 	add	x0, x0, #0x953
  412a88:	97ffc9cd 	bl	4051bc <assert_print>
  412a8c:	aa1303e0 	mov	x0, x19
  412a90:	52807d81 	mov	w1, #0x3ec                 	// #1004
  412a94:	97ffc9f4 	bl	405264 <assert_post_action>
  412a98:	52807d82 	mov	w2, #0x3ec                 	// #1004
  412a9c:	17ffffea 	b	412a44 <k_sched_unlock+0xd4>
		++_current->base.sched_locked;
  412aa0:	11000421 	add	w1, w1, #0x1
  412aa4:	39006c01 	strb	w1, [x0, #27]
		update_cache(0);
  412aa8:	52800000 	mov	w0, #0x0                   	// #0
  412aac:	97fffbfa 	bl	411a94 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412ab0:	aa1303e0 	mov	x0, x19
  412ab4:	97fff2ca 	bl	40f5dc <z_spin_unlock_valid>
  412ab8:	72001c1f 	tst	w0, #0xff
  412abc:	54000261 	b.ne	412b08 <k_sched_unlock+0x198>  // b.any
  412ac0:	90000034 	adrp	x20, 416000 <__func__.0+0x57a>
  412ac4:	9122ce94 	add	x20, x20, #0x8b3
  412ac8:	aa1403e2 	mov	x2, x20
  412acc:	52801863 	mov	w3, #0xc3                  	// #195
  412ad0:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412ad4:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412ad8:	91255821 	add	x1, x1, #0x956
  412adc:	91353400 	add	x0, x0, #0xd4d
  412ae0:	97ffc9b7 	bl	4051bc <assert_print>
  412ae4:	aa1303e1 	mov	x1, x19
  412ae8:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412aec:	9125b400 	add	x0, x0, #0x96d
  412af0:	97ffc9b3 	bl	4051bc <assert_print>
  412af4:	aa1403e0 	mov	x0, x20
  412af8:	52801861 	mov	w1, #0xc3                  	// #195
  412afc:	97ffc9da 	bl	405264 <assert_post_action>
  412b00:	52801862 	mov	w2, #0xc3                  	// #195
  412b04:	17ffffb7 	b	4129e0 <k_sched_unlock+0x70>
	posix_irq_unlock(key);
  412b08:	2a1403e0 	mov	w0, w20
  412b0c:	97ffd2b4 	bl	4075dc <posix_irq_unlock>
}
  412b10:	a94153f3 	ldp	x19, x20, [sp, #16]
  412b14:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
  412b18:	17fffae9 	b	4116bc <z_reschedule_unlocked>

0000000000412b1c <z_unpend_first_thread>:
{
  412b1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412b20:	910003fd 	mov	x29, sp
  412b24:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412b28:	d00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  412b2c:	aa0003f4 	mov	x20, x0
  412b30:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  412b34:	97ffd2a8 	bl	4075d4 <posix_irq_lock>
  412b38:	2a0003f5 	mov	w21, w0
  412b3c:	f947d676 	ldr	x22, [x19, #4008]
  412b40:	aa1603e0 	mov	x0, x22
  412b44:	97fff29b 	bl	40f5b0 <z_spin_lock_valid>
  412b48:	72001c1f 	tst	w0, #0xff
  412b4c:	540002c1 	b.ne	412ba4 <z_unpend_first_thread+0x88>  // b.any
  412b50:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412b54:	9122ce73 	add	x19, x19, #0x8b3
  412b58:	aa1303e2 	mov	x2, x19
  412b5c:	52801283 	mov	w3, #0x94                  	// #148
  412b60:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412b64:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412b68:	91238021 	add	x1, x1, #0x8e0
  412b6c:	91353400 	add	x0, x0, #0xd4d
  412b70:	97ffc993 	bl	4051bc <assert_print>
  412b74:	aa1603e1 	mov	x1, x22
  412b78:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412b7c:	9123d400 	add	x0, x0, #0x8f5
  412b80:	97ffc98f 	bl	4051bc <assert_print>
  412b84:	52801281 	mov	w1, #0x94                  	// #148
  412b88:	aa1303e0 	mov	x0, x19
  412b8c:	97ffc9b6 	bl	405264 <assert_post_action>
  412b90:	aa1303e1 	mov	x1, x19
  412b94:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412b98:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412b9c:	91362c00 	add	x0, x0, #0xd8b
  412ba0:	97ffd3a3 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  412ba4:	aa1603e0 	mov	x0, x22
  412ba8:	97fff29a 	bl	40f610 <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  412bac:	aa1403e0 	mov	x0, x20
  412bb0:	97fffbb5 	bl	411a84 <z_priq_dumb_best>
  412bb4:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  412bb8:	b4000080 	cbz	x0, 412bc8 <z_unpend_first_thread+0xac>
			unpend_thread_no_timeout(thread);
  412bbc:	97fffb4b 	bl	4118e8 <unpend_thread_no_timeout>
  412bc0:	9100a280 	add	x0, x20, #0x28
  412bc4:	9400042b 	bl	413c70 <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412bc8:	f947d673 	ldr	x19, [x19, #4008]
  412bcc:	aa1303e0 	mov	x0, x19
  412bd0:	97fff283 	bl	40f5dc <z_spin_unlock_valid>
  412bd4:	72001c1f 	tst	w0, #0xff
  412bd8:	54000281 	b.ne	412c28 <z_unpend_first_thread+0x10c>  // b.any
  412bdc:	90000034 	adrp	x20, 416000 <__func__.0+0x57a>
  412be0:	9122ce94 	add	x20, x20, #0x8b3
  412be4:	aa1403e2 	mov	x2, x20
  412be8:	52801863 	mov	w3, #0xc3                  	// #195
  412bec:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412bf0:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412bf4:	91255821 	add	x1, x1, #0x956
  412bf8:	91353400 	add	x0, x0, #0xd4d
  412bfc:	97ffc970 	bl	4051bc <assert_print>
  412c00:	aa1303e1 	mov	x1, x19
  412c04:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412c08:	9125b400 	add	x0, x0, #0x96d
  412c0c:	97ffc96c 	bl	4051bc <assert_print>
  412c10:	52801861 	mov	w1, #0xc3                  	// #195
  412c14:	aa1403e0 	mov	x0, x20
  412c18:	97ffc993 	bl	405264 <assert_post_action>
  412c1c:	aa1403e1 	mov	x1, x20
  412c20:	52801862 	mov	w2, #0xc3                  	// #195
  412c24:	17ffffdd 	b	412b98 <z_unpend_first_thread+0x7c>
	posix_irq_unlock(key);
  412c28:	2a1503e0 	mov	w0, w21
  412c2c:	97ffd26c 	bl	4075dc <posix_irq_unlock>
}
  412c30:	aa1403e0 	mov	x0, x20
  412c34:	a94153f3 	ldp	x19, x20, [sp, #16]
  412c38:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412c3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  412c40:	d65f03c0 	ret

0000000000412c44 <init_ready_q>:
#elif defined(CONFIG_SCHED_MULTIQ)
	for (int i = 0; i < ARRAY_SIZE(_kernel.ready_q.runq.queues); i++) {
		sys_dlist_init(&rq->runq.queues[i]);
	}
#else
	sys_dlist_init(&rq->runq);
  412c44:	91002001 	add	x1, x0, #0x8
	list->tail = (sys_dnode_t *)list;
  412c48:	a9008401 	stp	x1, x1, [x0, #8]
#endif
}
  412c4c:	d65f03c0 	ret

0000000000412c50 <z_sched_init>:
#ifdef CONFIG_SCHED_CPU_MASK_PIN_ONLY
	for (int i = 0; i < CONFIG_MP_MAX_NUM_CPUS; i++) {
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
  412c50:	d00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  412c54:	f9474000 	ldr	x0, [x0, #3712]
  412c58:	9100a000 	add	x0, x0, #0x28
  412c5c:	17fffffa 	b	412c44 <init_ready_q>

0000000000412c60 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
  412c60:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  412c64:	d00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  412c68:	910003fd 	mov	x29, sp
  412c6c:	a9025bf5 	stp	x21, x22, [sp, #32]
  412c70:	f9474035 	ldr	x21, [x1, #3712]
  412c74:	a90153f3 	stp	x19, x20, [sp, #16]
  412c78:	a90363f7 	stp	x23, x24, [sp, #48]
  412c7c:	f90023f9 	str	x25, [sp, #64]
	__ASSERT(!arch_is_in_isr(), "");
  412c80:	b94002a0 	ldr	w0, [x21]
  412c84:	340002a0 	cbz	w0, 412cd8 <z_impl_k_yield+0x78>
  412c88:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412c8c:	91349e73 	add	x19, x19, #0xd27
  412c90:	aa1303e2 	mov	x2, x19
  412c94:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412c98:	912a6021 	add	x1, x1, #0xa98
  412c9c:	5280ae23 	mov	w3, #0x571                 	// #1393
  412ca0:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412ca4:	91353400 	add	x0, x0, #0xd4d
  412ca8:	97ffc945 	bl	4051bc <assert_print>
  412cac:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412cb0:	91254c00 	add	x0, x0, #0x953
  412cb4:	97ffc942 	bl	4051bc <assert_print>
  412cb8:	aa1303e0 	mov	x0, x19
  412cbc:	5280ae21 	mov	w1, #0x571                 	// #1393
  412cc0:	97ffc969 	bl	405264 <assert_post_action>
  412cc4:	5280ae22 	mov	w2, #0x571                 	// #1393
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412cc8:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412ccc:	aa1303e1 	mov	x1, x19
  412cd0:	91362c00 	add	x0, x0, #0xd8b
  412cd4:	97ffd356 	bl	407a2c <posix_print_error_and_exit>
  412cd8:	d00000d7 	adrp	x23, 42c000 <__FRAME_END__+0xfbbc>
  412cdc:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  412ce0:	97ffd23d 	bl	4075d4 <posix_irq_lock>
  412ce4:	2a0003f8 	mov	w24, w0
  412ce8:	f947d6f9 	ldr	x25, [x23, #4008]
  412cec:	aa1903e0 	mov	x0, x25
  412cf0:	97fff230 	bl	40f5b0 <z_spin_lock_valid>
  412cf4:	72001c1f 	tst	w0, #0xff
  412cf8:	54000261 	b.ne	412d44 <z_impl_k_yield+0xe4>  // b.any
  412cfc:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412d00:	9122ce73 	add	x19, x19, #0x8b3
  412d04:	aa1303e2 	mov	x2, x19
  412d08:	52801283 	mov	w3, #0x94                  	// #148
  412d0c:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412d10:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412d14:	91238021 	add	x1, x1, #0x8e0
  412d18:	91353400 	add	x0, x0, #0xd4d
  412d1c:	97ffc928 	bl	4051bc <assert_print>
  412d20:	aa1903e1 	mov	x1, x25
  412d24:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412d28:	9123d400 	add	x0, x0, #0x8f5
  412d2c:	97ffc924 	bl	4051bc <assert_print>
  412d30:	aa1303e0 	mov	x0, x19
  412d34:	52801281 	mov	w1, #0x94                  	// #148
  412d38:	97ffc94b 	bl	405264 <assert_post_action>
  412d3c:	52801282 	mov	w2, #0x94                  	// #148
  412d40:	17ffffe2 	b	412cc8 <z_impl_k_yield+0x68>
	z_spin_lock_set_owner(l);
  412d44:	aa1903e0 	mov	x0, x25
  412d48:	97fff232 	bl	40f610 <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
  412d4c:	f9400aa1 	ldr	x1, [x21, #16]
	thread->base.thread_state &= ~_THREAD_QUEUED;
  412d50:	39406420 	ldrb	w0, [x1, #25]
  412d54:	12001800 	and	w0, w0, #0x7f
  412d58:	39006420 	strb	w0, [x1, #25]
	_priq_run_remove(thread_runq(thread), thread);
  412d5c:	9100c2a0 	add	x0, x21, #0x30
  412d60:	97fffac5 	bl	411874 <z_priq_dumb_remove>
	}
	queue_thread(_current);
  412d64:	f9400ab3 	ldr	x19, [x21, #16]
	thread->base.thread_state |= _THREAD_QUEUED;
  412d68:	39406660 	ldrb	w0, [x19, #25]
  412d6c:	32196000 	orr	w0, w0, #0xffffff80
  412d70:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  412d74:	d00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  412d78:	f9471000 	ldr	x0, [x0, #3616]
  412d7c:	eb00027f 	cmp	x19, x0
  412d80:	540001e1 	b.ne	412dbc <z_impl_k_yield+0x15c>  // b.any
  412d84:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412d88:	91349e73 	add	x19, x19, #0xd27
  412d8c:	aa1303e2 	mov	x2, x19
  412d90:	52801783 	mov	w3, #0xbc                  	// #188
  412d94:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412d98:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412d9c:	913cf821 	add	x1, x1, #0xf3e
  412da0:	91353400 	add	x0, x0, #0xd4d
  412da4:	97ffc906 	bl	4051bc <assert_print>
  412da8:	aa1303e0 	mov	x0, x19
  412dac:	52801781 	mov	w1, #0xbc                  	// #188
  412db0:	97ffc92d 	bl	405264 <assert_post_action>
  412db4:	52801782 	mov	w2, #0xbc                  	// #188
  412db8:	17ffffc4 	b	412cc8 <z_impl_k_yield+0x68>
	return list->head == list;
  412dbc:	aa1503e0 	mov	x0, x21
  412dc0:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412dc4:	eb00029f 	cmp	x20, x0
  412dc8:	54000481 	b.ne	412e58 <z_impl_k_yield+0x1f8>  // b.any
	sys_dnode_t *const tail = list->tail;
  412dcc:	f94742c1 	ldr	x1, [x22, #3712]
	node->next = list;
  412dd0:	9100c022 	add	x2, x1, #0x30
	sys_dnode_t *const tail = list->tail;
  412dd4:	f9401c20 	ldr	x0, [x1, #56]
	node->prev = tail;
  412dd8:	a9000262 	stp	x2, x0, [x19]
	tail->next = node;
  412ddc:	f9000013 	str	x19, [x0]
	list->tail = node;
  412de0:	f9001c33 	str	x19, [x1, #56]
	update_cache(1);
  412de4:	52800020 	mov	w0, #0x1                   	// #1
  412de8:	97fffb2b 	bl	411a94 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412dec:	f947d6f7 	ldr	x23, [x23, #4008]
  412df0:	aa1703e0 	mov	x0, x23
  412df4:	97fff1fa 	bl	40f5dc <z_spin_unlock_valid>
  412df8:	72001c1f 	tst	w0, #0xff
  412dfc:	54000441 	b.ne	412e84 <z_impl_k_yield+0x224>  // b.any
  412e00:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412e04:	9122ce73 	add	x19, x19, #0x8b3
  412e08:	aa1303e2 	mov	x2, x19
  412e0c:	52801c43 	mov	w3, #0xe2                  	// #226
  412e10:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412e14:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412e18:	91255821 	add	x1, x1, #0x956
  412e1c:	91353400 	add	x0, x0, #0xd4d
  412e20:	97ffc8e7 	bl	4051bc <assert_print>
  412e24:	aa1703e1 	mov	x1, x23
  412e28:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412e2c:	9125b400 	add	x0, x0, #0x96d
  412e30:	97ffc8e3 	bl	4051bc <assert_print>
  412e34:	aa1303e0 	mov	x0, x19
  412e38:	52801c41 	mov	w1, #0xe2                  	// #226
  412e3c:	97ffc90a 	bl	405264 <assert_post_action>
  412e40:	52801c42 	mov	w2, #0xe2                  	// #226
  412e44:	17ffffa1 	b	412cc8 <z_impl_k_yield+0x68>
	return (node == list->tail) ? NULL : node->next;
  412e48:	f9401ea0 	ldr	x0, [x21, #56]
  412e4c:	eb14001f 	cmp	x0, x20
  412e50:	54fffbe0 	b.eq	412dcc <z_impl_k_yield+0x16c>  // b.none
  412e54:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  412e58:	b4fffbb4 	cbz	x20, 412dcc <z_impl_k_yield+0x16c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  412e5c:	aa1403e1 	mov	x1, x20
  412e60:	aa1303e0 	mov	x0, x19
  412e64:	97fff9a0 	bl	4114e4 <z_sched_prio_cmp>
  412e68:	7100001f 	cmp	w0, #0x0
  412e6c:	54fffeed 	b.le	412e48 <z_impl_k_yield+0x1e8>
	sys_dnode_t *const prev = successor->prev;
  412e70:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  412e74:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  412e78:	f9000013 	str	x19, [x0]
	successor->prev = node;
  412e7c:	f9000693 	str	x19, [x20, #8]
}
  412e80:	17ffffd9 	b	412de4 <z_impl_k_yield+0x184>
  412e84:	2a1803e0 	mov	w0, w24
	z_swap(&sched_spinlock, key);
}
  412e88:	a94153f3 	ldp	x19, x20, [sp, #16]
  412e8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412e90:	a94363f7 	ldp	x23, x24, [sp, #48]
  412e94:	f94023f9 	ldr	x25, [sp, #64]
  412e98:	a8c57bfd 	ldp	x29, x30, [sp], #80
  412e9c:	17ffcea4 	b	40692c <arch_swap>

0000000000412ea0 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
  412ea0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412ea4:	910003fd 	mov	x29, sp
  412ea8:	a90153f3 	stp	x19, x20, [sp, #16]
  412eac:	d00000d4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  412eb0:	a9025bf5 	stp	x21, x22, [sp, #32]
  412eb4:	aa0003f6 	mov	x22, x0
  412eb8:	f9474280 	ldr	x0, [x20, #3712]
  412ebc:	f9001bf7 	str	x23, [sp, #48]
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
  412ec0:	b9400000 	ldr	w0, [x0]
  412ec4:	340002a0 	cbz	w0, 412f18 <z_tick_sleep+0x78>
  412ec8:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412ecc:	91349e73 	add	x19, x19, #0xd27
  412ed0:	aa1303e2 	mov	x2, x19
  412ed4:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412ed8:	912a6021 	add	x1, x1, #0xa98
  412edc:	5280b1a3 	mov	w3, #0x58d                 	// #1421
  412ee0:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412ee4:	91353400 	add	x0, x0, #0xd4d
  412ee8:	97ffc8b5 	bl	4051bc <assert_print>
  412eec:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412ef0:	91254c00 	add	x0, x0, #0x953
  412ef4:	97ffc8b2 	bl	4051bc <assert_print>
  412ef8:	aa1303e0 	mov	x0, x19
  412efc:	5280b1a1 	mov	w1, #0x58d                 	// #1421
  412f00:	97ffc8d9 	bl	405264 <assert_post_action>
  412f04:	5280b1a2 	mov	w2, #0x58d                 	// #1421
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412f08:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412f0c:	aa1303e1 	mov	x1, x19
  412f10:	91362c00 	add	x0, x0, #0xd8b
  412f14:	97ffd2c6 	bl	407a2c <posix_print_error_and_exit>

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
  412f18:	b5000116 	cbnz	x22, 412f38 <z_tick_sleep+0x98>
	z_impl_k_yield();
  412f1c:	97ffff51 	bl	412c60 <z_impl_k_yield>
		k_yield();
		return 0;
  412f20:	52800000 	mov	w0, #0x0                   	// #0
		return ticks;
	}
#endif

	return 0;
}
  412f24:	a94153f3 	ldp	x19, x20, [sp, #16]
  412f28:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412f2c:	f9401bf7 	ldr	x23, [sp, #48]
  412f30:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412f34:	d65f03c0 	ret
	if (Z_TICK_ABS(ticks) <= 0) {
  412f38:	b1000adf 	cmn	x22, #0x2
  412f3c:	540003ab 	b.lt	412fb0 <z_tick_sleep+0x110>  // b.tstop
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
  412f40:	94000456 	bl	414098 <sys_clock_tick_get_32>
  412f44:	0b160013 	add	w19, w0, w22
  412f48:	d00000d5 	adrp	x21, 42c000 <__FRAME_END__+0xfbbc>
  412f4c:	97ffd1a2 	bl	4075d4 <posix_irq_lock>
  412f50:	2a0003f7 	mov	w23, w0
  412f54:	f947d6b5 	ldr	x21, [x21, #4008]
  412f58:	aa1503e0 	mov	x0, x21
  412f5c:	97fff195 	bl	40f5b0 <z_spin_lock_valid>
  412f60:	72001c1f 	tst	w0, #0xff
  412f64:	540002c1 	b.ne	412fbc <z_tick_sleep+0x11c>  // b.any
  412f68:	90000033 	adrp	x19, 416000 <__func__.0+0x57a>
  412f6c:	9122ce73 	add	x19, x19, #0x8b3
  412f70:	aa1303e2 	mov	x2, x19
  412f74:	52801283 	mov	w3, #0x94                  	// #148
  412f78:	90000021 	adrp	x1, 416000 <__func__.0+0x57a>
  412f7c:	d0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  412f80:	91238021 	add	x1, x1, #0x8e0
  412f84:	91353400 	add	x0, x0, #0xd4d
  412f88:	97ffc88d 	bl	4051bc <assert_print>
  412f8c:	aa1503e1 	mov	x1, x21
  412f90:	90000020 	adrp	x0, 416000 <__func__.0+0x57a>
  412f94:	9123d400 	add	x0, x0, #0x8f5
  412f98:	97ffc889 	bl	4051bc <assert_print>
  412f9c:	aa1303e0 	mov	x0, x19
  412fa0:	52801281 	mov	w1, #0x94                  	// #148
  412fa4:	97ffc8b0 	bl	405264 <assert_post_action>
  412fa8:	52801282 	mov	w2, #0x94                  	// #148
  412fac:	17ffffd7 	b	412f08 <z_tick_sleep+0x68>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
  412fb0:	12800033 	mov	w19, #0xfffffffe            	// #-2
  412fb4:	4b160273 	sub	w19, w19, w22
  412fb8:	17ffffe4 	b	412f48 <z_tick_sleep+0xa8>
	z_spin_lock_set_owner(l);
  412fbc:	aa1503e0 	mov	x0, x21
  412fc0:	97fff194 	bl	40f610 <z_spin_lock_set_owner>
	unready_thread(_current);
  412fc4:	f9474294 	ldr	x20, [x20, #3712]
  412fc8:	f9400a80 	ldr	x0, [x20, #16]
  412fcc:	97fffcb2 	bl	412294 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  412fd0:	d00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  412fd4:	aa1603e2 	mov	x2, x22
	z_add_thread_timeout(_current, timeout);
  412fd8:	f9400a80 	ldr	x0, [x20, #16]
  412fdc:	f9473021 	ldr	x1, [x1, #3680]
  412fe0:	9100a000 	add	x0, x0, #0x28
  412fe4:	94000291 	bl	413a28 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
  412fe8:	f9400a82 	ldr	x2, [x20, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412fec:	aa1503e0 	mov	x0, x21
  412ff0:	39406441 	ldrb	w1, [x2, #25]
  412ff4:	321c0021 	orr	w1, w1, #0x10
  412ff8:	39006441 	strb	w1, [x2, #25]
  412ffc:	97fff178 	bl	40f5dc <z_spin_unlock_valid>
  413000:	72001c1f 	tst	w0, #0xff
  413004:	54000261 	b.ne	413050 <z_tick_sleep+0x1b0>  // b.any
  413008:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  41300c:	9122ce73 	add	x19, x19, #0x8b3
  413010:	aa1303e2 	mov	x2, x19
  413014:	52801c43 	mov	w3, #0xe2                  	// #226
  413018:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  41301c:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413020:	91255821 	add	x1, x1, #0x956
  413024:	91353400 	add	x0, x0, #0xd4d
  413028:	97ffc865 	bl	4051bc <assert_print>
  41302c:	aa1503e1 	mov	x1, x21
  413030:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413034:	9125b400 	add	x0, x0, #0x96d
  413038:	97ffc861 	bl	4051bc <assert_print>
  41303c:	aa1303e0 	mov	x0, x19
  413040:	52801c41 	mov	w1, #0xe2                  	// #226
  413044:	97ffc888 	bl	405264 <assert_post_action>
  413048:	52801c42 	mov	w2, #0xe2                  	// #226
  41304c:	17ffffaf 	b	412f08 <z_tick_sleep+0x68>
  413050:	2a1703e0 	mov	w0, w23
  413054:	97ffce36 	bl	40692c <arch_swap>
	return (thread->base.thread_state & state) != 0U;
  413058:	f9400a80 	ldr	x0, [x20, #16]
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
  41305c:	39406400 	ldrb	w0, [x0, #25]
  413060:	36200240 	tbz	w0, #4, 4130a8 <z_tick_sleep+0x208>
  413064:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413068:	91349e73 	add	x19, x19, #0xd27
  41306c:	aa1303e2 	mov	x2, x19
  413070:	90000021 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  413074:	91001421 	add	x1, x1, #0x5
  413078:	5280b523 	mov	w3, #0x5a9                 	// #1449
  41307c:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413080:	91353400 	add	x0, x0, #0xd4d
  413084:	97ffc84e 	bl	4051bc <assert_print>
  413088:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  41308c:	91254c00 	add	x0, x0, #0x953
  413090:	97ffc84b 	bl	4051bc <assert_print>
  413094:	aa1303e0 	mov	x0, x19
  413098:	5280b521 	mov	w1, #0x5a9                 	// #1449
  41309c:	97ffc872 	bl	405264 <assert_post_action>
  4130a0:	5280b522 	mov	w2, #0x5a9                 	// #1449
  4130a4:	17ffff99 	b	412f08 <z_tick_sleep+0x68>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
  4130a8:	940003fc 	bl	414098 <sys_clock_tick_get_32>
  4130ac:	cb204260 	sub	x0, x19, w0, uxtw
		return ticks;
  4130b0:	f100001f 	cmp	x0, #0x0
  4130b4:	1a9fc000 	csel	w0, w0, wzr, gt
  4130b8:	17ffff9b 	b	412f24 <z_tick_sleep+0x84>

00000000004130bc <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
  4130bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4130c0:	b00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4130c4:	910003fd 	mov	x29, sp
  4130c8:	f9474021 	ldr	x1, [x1, #3712]
  4130cc:	f9000bf3 	str	x19, [sp, #16]
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
  4130d0:	b9400022 	ldr	w2, [x1]
  4130d4:	340002a2 	cbz	w2, 413128 <z_impl_k_sleep+0x6c>
  4130d8:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  4130dc:	91349e73 	add	x19, x19, #0xd27
  4130e0:	aa1303e2 	mov	x2, x19
  4130e4:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  4130e8:	912a6021 	add	x1, x1, #0xa98
  4130ec:	5280b703 	mov	w3, #0x5b8                 	// #1464
  4130f0:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4130f4:	91353400 	add	x0, x0, #0xd4d
  4130f8:	97ffc831 	bl	4051bc <assert_print>
  4130fc:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413100:	91254c00 	add	x0, x0, #0x953
  413104:	97ffc82e 	bl	4051bc <assert_print>
  413108:	aa1303e0 	mov	x0, x19
  41310c:	5280b701 	mov	w1, #0x5b8                 	// #1464
  413110:	97ffc855 	bl	405264 <assert_post_action>
  413114:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413118:	aa1303e1 	mov	x1, x19
  41311c:	91362c00 	add	x0, x0, #0xd8b
  413120:	5280b702 	mov	w2, #0x5b8                 	// #1464
  413124:	97ffd242 	bl	407a2c <posix_print_error_and_exit>
  413128:	aa0003f3 	mov	x19, x0

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  41312c:	b100041f 	cmn	x0, #0x1
  413130:	540000e1 	b.ne	41314c <z_impl_k_sleep+0x90>  // b.any
		k_thread_suspend(_current);
  413134:	f9400820 	ldr	x0, [x1, #16]
	z_impl_k_thread_suspend(thread);
  413138:	97fffdb2 	bl	412800 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
  41313c:	2a1303e0 	mov	w0, w19
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
  413140:	f9400bf3 	ldr	x19, [sp, #16]
  413144:	a8c27bfd 	ldp	x29, x30, [sp], #32
  413148:	d65f03c0 	ret
	ticks = z_tick_sleep(ticks);
  41314c:	97ffff55 	bl	412ea0 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
  413150:	52800141 	mov	w1, #0xa                   	// #10
  413154:	1b017c00 	mul	w0, w0, w1
	return ret;
  413158:	17fffffa 	b	413140 <z_impl_k_sleep+0x84>

000000000041315c <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
  41315c:	b00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  413160:	f9474000 	ldr	x0, [x0, #3712]
  413164:	f9400800 	ldr	x0, [x0, #16]
  413168:	d65f03c0 	ret

000000000041316c <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
  41316c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  413170:	910003fd 	mov	x29, sp
  413174:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413178:	b00000d4 	adrp	x20, 42c000 <__FRAME_END__+0xfbbc>
  41317c:	aa0003f3 	mov	x19, x0
  413180:	a9025bf5 	stp	x21, x22, [sp, #32]
  413184:	f9001bf7 	str	x23, [sp, #48]
  413188:	97ffd113 	bl	4075d4 <posix_irq_lock>
  41318c:	f947d696 	ldr	x22, [x20, #4008]
  413190:	2a0003f5 	mov	w21, w0
  413194:	aa1603e0 	mov	x0, x22
  413198:	97fff106 	bl	40f5b0 <z_spin_lock_valid>
  41319c:	72001c1f 	tst	w0, #0xff
  4131a0:	540002c1 	b.ne	4131f8 <z_thread_abort+0x8c>  // b.any
  4131a4:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  4131a8:	9122ce73 	add	x19, x19, #0x8b3
  4131ac:	aa1303e2 	mov	x2, x19
  4131b0:	52801283 	mov	w3, #0x94                  	// #148
  4131b4:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  4131b8:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4131bc:	91238021 	add	x1, x1, #0x8e0
  4131c0:	91353400 	add	x0, x0, #0xd4d
  4131c4:	97ffc7fe 	bl	4051bc <assert_print>
  4131c8:	aa1603e1 	mov	x1, x22
  4131cc:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  4131d0:	9123d400 	add	x0, x0, #0x8f5
  4131d4:	97ffc7fa 	bl	4051bc <assert_print>
  4131d8:	aa1303e0 	mov	x0, x19
  4131dc:	52801281 	mov	w1, #0x94                  	// #148
  4131e0:	97ffc821 	bl	405264 <assert_post_action>
  4131e4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4131e8:	aa1303e1 	mov	x1, x19
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
  4131ec:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4131f0:	91362c00 	add	x0, x0, #0xd8b
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
  4131f4:	97ffd20e 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4131f8:	aa1603e0 	mov	x0, x22
  4131fc:	97fff105 	bl	40f610 <z_spin_lock_set_owner>
	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
  413200:	39406260 	ldrb	w0, [x19, #24]
  413204:	36000580 	tbz	w0, #0, 4132b4 <z_thread_abort+0x148>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413208:	aa1603e0 	mov	x0, x22
  41320c:	97fff0f4 	bl	40f5dc <z_spin_unlock_valid>
  413210:	72001c1f 	tst	w0, #0xff
  413214:	54000261 	b.ne	413260 <z_thread_abort+0xf4>  // b.any
  413218:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  41321c:	9122ce73 	add	x19, x19, #0x8b3
  413220:	aa1303e2 	mov	x2, x19
  413224:	52801863 	mov	w3, #0xc3                  	// #195
  413228:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  41322c:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413230:	91255821 	add	x1, x1, #0x956
  413234:	91353400 	add	x0, x0, #0xd4d
  413238:	97ffc7e1 	bl	4051bc <assert_print>
  41323c:	f947d681 	ldr	x1, [x20, #4008]
  413240:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413244:	9125b400 	add	x0, x0, #0x96d
  413248:	97ffc7dd 	bl	4051bc <assert_print>
  41324c:	aa1303e0 	mov	x0, x19
  413250:	52801861 	mov	w1, #0xc3                  	// #195
  413254:	97ffc804 	bl	405264 <assert_post_action>
  413258:	52801862 	mov	w2, #0xc3                  	// #195
  41325c:	17ffffe3 	b	4131e8 <z_thread_abort+0x7c>
	posix_irq_unlock(key);
  413260:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborting essential thread %p", thread);
  413264:	f0000014 	adrp	x20, 416000 <__func__.0+0x57a>
  413268:	97ffd0dd 	bl	4075dc <posix_irq_unlock>
  41326c:	91349e94 	add	x20, x20, #0xd27
  413270:	aa1403e2 	mov	x2, x20
  413274:	5280d9c3 	mov	w3, #0x6ce                 	// #1742
  413278:	90000021 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  41327c:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413280:	91055821 	add	x1, x1, #0x156
  413284:	91353400 	add	x0, x0, #0xd4d
  413288:	97ffc7cd 	bl	4051bc <assert_print>
  41328c:	aa1303e1 	mov	x1, x19
  413290:	90000020 	adrp	x0, 417000 <CSWTCH.25+0x8a4>
  413294:	91011400 	add	x0, x0, #0x45
  413298:	97ffc7c9 	bl	4051bc <assert_print>
  41329c:	5280d9c1 	mov	w1, #0x6ce                 	// #1742
  4132a0:	aa1403e0 	mov	x0, x20
  4132a4:	97ffc7f0 	bl	405264 <assert_post_action>
  4132a8:	aa1403e1 	mov	x1, x20
  4132ac:	5280d9c2 	mov	w2, #0x6ce                 	// #1742
  4132b0:	17ffffcf 	b	4131ec <z_thread_abort+0x80>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  4132b4:	39406661 	ldrb	w1, [x19, #25]
  4132b8:	36180161 	tbz	w1, #3, 4132e4 <z_thread_abort+0x178>
  4132bc:	aa1603e0 	mov	x0, x22
  4132c0:	97fff0c7 	bl	40f5dc <z_spin_unlock_valid>
  4132c4:	72001c1f 	tst	w0, #0xff
  4132c8:	54fffa80 	b.eq	413218 <z_thread_abort+0xac>  // b.none
  4132cc:	2a1503e0 	mov	w0, w21
	}
	k_spin_unlock(&sched_spinlock, key);
}
  4132d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4132d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4132d8:	f9401bf7 	ldr	x23, [sp, #48]
  4132dc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4132e0:	17ffd0bf 	b	4075dc <posix_irq_unlock>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  4132e4:	121a7820 	and	w0, w1, #0xffffffdf
  4132e8:	321d0002 	orr	w2, w0, #0x8
		if (z_is_thread_queued(thread)) {
  4132ec:	37380600 	tbnz	w0, #7, 4133ac <z_thread_abort+0x240>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  4132f0:	39006662 	strb	w2, [x19, #25]
		if (thread->base.pended_on != NULL) {
  4132f4:	f9400a60 	ldr	x0, [x19, #16]
  4132f8:	b4000060 	cbz	x0, 413304 <z_thread_abort+0x198>
			unpend_thread_no_timeout(thread);
  4132fc:	aa1303e0 	mov	x0, x19
  413300:	97fff97a 	bl	4118e8 <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  413304:	91018277 	add	x23, x19, #0x60
	return z_abort_timeout(&thread->base.timeout);
  413308:	9100a260 	add	x0, x19, #0x28
  41330c:	94000259 	bl	413c70 <z_abort_timeout>
	return list->head == list;
  413310:	f9403276 	ldr	x22, [x19, #96]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  413314:	eb1702df 	cmp	x22, x23
  413318:	54000040 	b.eq	413320 <z_thread_abort+0x1b4>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  41331c:	b50005d6 	cbnz	x22, 4133d4 <z_thread_abort+0x268>
		update_cache(1);
  413320:	52800020 	mov	w0, #0x1                   	// #1
  413324:	97fff9dc 	bl	411a94 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
  413328:	b00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  41332c:	f9474000 	ldr	x0, [x0, #3712]
  413330:	f9400801 	ldr	x1, [x0, #16]
  413334:	eb13003f 	cmp	x1, x19
  413338:	54000821 	b.ne	41343c <z_thread_abort+0x2d0>  // b.any
  41333c:	b9400000 	ldr	w0, [x0]
  413340:	350007e0 	cbnz	w0, 41343c <z_thread_abort+0x2d0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413344:	f947d694 	ldr	x20, [x20, #4008]
  413348:	b0000017 	adrp	x23, 414000 <sys_clock_tick_get+0x78>
  41334c:	b0000016 	adrp	x22, 414000 <sys_clock_tick_get+0x78>
  413350:	aa1403e0 	mov	x0, x20
  413354:	97fff0a2 	bl	40f5dc <z_spin_unlock_valid>
  413358:	72001c1f 	tst	w0, #0xff
  41335c:	540004c1 	b.ne	4133f4 <z_thread_abort+0x288>  // b.any
  413360:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413364:	9122ce73 	add	x19, x19, #0x8b3
  413368:	aa1303e2 	mov	x2, x19
  41336c:	52801c43 	mov	w3, #0xe2                  	// #226
  413370:	913536e0 	add	x0, x23, #0xd4d
  413374:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413378:	91255821 	add	x1, x1, #0x956
  41337c:	97ffc790 	bl	4051bc <assert_print>
  413380:	aa1403e1 	mov	x1, x20
  413384:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413388:	9125b400 	add	x0, x0, #0x96d
  41338c:	97ffc78c 	bl	4051bc <assert_print>
  413390:	aa1303e0 	mov	x0, x19
  413394:	52801c41 	mov	w1, #0xe2                  	// #226
  413398:	97ffc7b3 	bl	405264 <assert_post_action>
  41339c:	52801c42 	mov	w2, #0xe2                  	// #226
		__ASSERT(false, "aborted _current back from dead");
  4133a0:	aa1303e1 	mov	x1, x19
  4133a4:	91362ec0 	add	x0, x22, #0xd8b
  4133a8:	17ffff93 	b	4131f4 <z_thread_abort+0x88>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4133ac:	52800be0 	mov	w0, #0x5f                  	// #95
  4133b0:	0a000021 	and	w1, w1, w0
	_priq_run_remove(thread_runq(thread), thread);
  4133b4:	b00000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4133b8:	321d0021 	orr	w1, w1, #0x8
  4133bc:	39006661 	strb	w1, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4133c0:	aa1303e1 	mov	x1, x19
  4133c4:	f9474000 	ldr	x0, [x0, #3712]
  4133c8:	9100c000 	add	x0, x0, #0x30
  4133cc:	97fff92a 	bl	411874 <z_priq_dumb_remove>
}
  4133d0:	17ffffc9 	b	4132f4 <z_thread_abort+0x188>
		unpend_thread_no_timeout(thread);
  4133d4:	aa1603e0 	mov	x0, x22
  4133d8:	97fff944 	bl	4118e8 <unpend_thread_no_timeout>
  4133dc:	9100a2c0 	add	x0, x22, #0x28
  4133e0:	94000224 	bl	413c70 <z_abort_timeout>
	thread->callee_saved.retval = value;
  4133e4:	b9004edf 	str	wzr, [x22, #76]
		ready_thread(thread);
  4133e8:	aa1603e0 	mov	x0, x22
  4133ec:	97fffa7b 	bl	411dd8 <ready_thread>
  4133f0:	17ffffc8 	b	413310 <z_thread_abort+0x1a4>
  4133f4:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborted _current back from dead");
  4133f8:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  4133fc:	97ffcd4c 	bl	40692c <arch_swap>
  413400:	91349e73 	add	x19, x19, #0xd27
  413404:	aa1303e2 	mov	x2, x19
  413408:	90000021 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  41340c:	91055821 	add	x1, x1, #0x156
  413410:	5280e083 	mov	w3, #0x704                 	// #1796
  413414:	913536e0 	add	x0, x23, #0xd4d
  413418:	97ffc769 	bl	4051bc <assert_print>
  41341c:	90000020 	adrp	x0, 417000 <CSWTCH.25+0x8a4>
  413420:	91019000 	add	x0, x0, #0x64
  413424:	97ffc766 	bl	4051bc <assert_print>
  413428:	aa1303e0 	mov	x0, x19
  41342c:	5280e081 	mov	w1, #0x704                 	// #1796
  413430:	97ffc78d 	bl	405264 <assert_post_action>
  413434:	5280e082 	mov	w2, #0x704                 	// #1796
  413438:	17ffffda 	b	4133a0 <z_thread_abort+0x234>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41343c:	f947d680 	ldr	x0, [x20, #4008]
  413440:	17ffffa0 	b	4132c0 <z_thread_abort+0x154>

0000000000413444 <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
  413444:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  413448:	910003fd 	mov	x29, sp
  41344c:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413450:	b00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  413454:	aa0003f4 	mov	x20, x0
  413458:	a9025bf5 	stp	x21, x22, [sp, #32]
  41345c:	aa0103f5 	mov	x21, x1
  413460:	f9001bf7 	str	x23, [sp, #48]
	return posix_irq_lock();
  413464:	97ffd05c 	bl	4075d4 <posix_irq_lock>
  413468:	f947d676 	ldr	x22, [x19, #4008]
  41346c:	2a0003f7 	mov	w23, w0
  413470:	aa1603e0 	mov	x0, x22
  413474:	97fff04f 	bl	40f5b0 <z_spin_lock_valid>
  413478:	72001c1f 	tst	w0, #0xff
  41347c:	540002c1 	b.ne	4134d4 <z_impl_k_thread_join+0x90>  // b.any
  413480:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413484:	9122ce73 	add	x19, x19, #0x8b3
  413488:	aa1303e2 	mov	x2, x19
  41348c:	52801283 	mov	w3, #0x94                  	// #148
  413490:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413494:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413498:	91238021 	add	x1, x1, #0x8e0
  41349c:	91353400 	add	x0, x0, #0xd4d
  4134a0:	97ffc747 	bl	4051bc <assert_print>
  4134a4:	aa1603e1 	mov	x1, x22
  4134a8:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  4134ac:	9123d400 	add	x0, x0, #0x8f5
  4134b0:	97ffc743 	bl	4051bc <assert_print>
  4134b4:	aa1303e0 	mov	x0, x19
  4134b8:	52801281 	mov	w1, #0x94                  	// #148
  4134bc:	97ffc76a 	bl	405264 <assert_post_action>
  4134c0:	52801282 	mov	w2, #0x94                  	// #148
		ret = -EBUSY;
	} else if ((thread == _current) ||
		   (thread->base.pended_on == &_current->join_queue)) {
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  4134c4:	aa1303e1 	mov	x1, x19
  4134c8:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4134cc:	91362c00 	add	x0, x0, #0xd8b
  4134d0:	97ffd157 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4134d4:	aa1603e0 	mov	x0, x22
  4134d8:	97fff04e 	bl	40f610 <z_spin_lock_set_owner>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  4134dc:	39406680 	ldrb	w0, [x20, #25]
  4134e0:	371808c0 	tbnz	w0, #3, 4135f8 <z_impl_k_thread_join+0x1b4>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  4134e4:	b4000bb5 	cbz	x21, 413658 <z_impl_k_thread_join+0x214>
	} else if ((thread == _current) ||
  4134e8:	b00000d6 	adrp	x22, 42c000 <__FRAME_END__+0xfbbc>
  4134ec:	f94742d6 	ldr	x22, [x22, #3712]
  4134f0:	f9400ac0 	ldr	x0, [x22, #16]
  4134f4:	eb14001f 	cmp	x0, x20
  4134f8:	54000b40 	b.eq	413660 <z_impl_k_thread_join+0x21c>  // b.none
  4134fc:	f9400a82 	ldr	x2, [x20, #16]
		   (thread->base.pended_on == &_current->join_queue)) {
  413500:	91018001 	add	x1, x0, #0x60
	} else if ((thread == _current) ||
  413504:	eb01005f 	cmp	x2, x1
  413508:	54000ac0 	b.eq	413660 <z_impl_k_thread_join+0x21c>  // b.none
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  41350c:	b94002c1 	ldr	w1, [x22]
  413510:	34000241 	cbz	w1, 413558 <z_impl_k_thread_join+0x114>
  413514:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413518:	91349e73 	add	x19, x19, #0xd27
  41351c:	aa1303e2 	mov	x2, x19
  413520:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413524:	912a6021 	add	x1, x1, #0xa98
  413528:	5280e483 	mov	w3, #0x724                 	// #1828
  41352c:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413530:	91353400 	add	x0, x0, #0xd4d
  413534:	97ffc722 	bl	4051bc <assert_print>
  413538:	90000020 	adrp	x0, 417000 <CSWTCH.25+0x8a4>
  41353c:	91021800 	add	x0, x0, #0x86
  413540:	97ffc71f 	bl	4051bc <assert_print>
  413544:	aa1303e0 	mov	x0, x19
  413548:	5280e481 	mov	w1, #0x724                 	// #1828
  41354c:	97ffc746 	bl	405264 <assert_post_action>
  413550:	5280e482 	mov	w2, #0x724                 	// #1828
  413554:	17ffffdc 	b	4134c4 <z_impl_k_thread_join+0x80>
		add_to_waitq_locked(_current, &thread->join_queue);
  413558:	91018281 	add	x1, x20, #0x60
  41355c:	97fffb63 	bl	4122e8 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  413560:	b10006bf 	cmn	x21, #0x1
  413564:	540000e0 	b.eq	413580 <z_impl_k_thread_join+0x13c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  413568:	b00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  41356c:	aa1503e2 	mov	x2, x21
		add_thread_timeout(_current, timeout);
  413570:	f9400ac0 	ldr	x0, [x22, #16]
  413574:	f9473021 	ldr	x1, [x1, #3680]
  413578:	9100a000 	add	x0, x0, #0x28
  41357c:	9400012b 	bl	413a28 <z_add_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413580:	f947d673 	ldr	x19, [x19, #4008]
  413584:	aa1303e0 	mov	x0, x19
  413588:	97fff015 	bl	40f5dc <z_spin_unlock_valid>
  41358c:	72001c1f 	tst	w0, #0xff
  413590:	54000281 	b.ne	4135e0 <z_impl_k_thread_join+0x19c>  // b.any
  413594:	f0000014 	adrp	x20, 416000 <__func__.0+0x57a>
  413598:	9122ce94 	add	x20, x20, #0x8b3
  41359c:	aa1403e2 	mov	x2, x20
  4135a0:	52801c43 	mov	w3, #0xe2                  	// #226
  4135a4:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  4135a8:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4135ac:	91255821 	add	x1, x1, #0x956
  4135b0:	91353400 	add	x0, x0, #0xd4d
  4135b4:	97ffc702 	bl	4051bc <assert_print>
  4135b8:	aa1303e1 	mov	x1, x19
  4135bc:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  4135c0:	9125b400 	add	x0, x0, #0x96d
  4135c4:	97ffc6fe 	bl	4051bc <assert_print>
  4135c8:	aa1403e0 	mov	x0, x20
  4135cc:	52801c41 	mov	w1, #0xe2                  	// #226
  4135d0:	97ffc725 	bl	405264 <assert_post_action>
  4135d4:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4135d8:	aa1403e1 	mov	x1, x20
  4135dc:	17ffffbb 	b	4134c8 <z_impl_k_thread_join+0x84>
  4135e0:	2a1703e0 	mov	w0, w23

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
  4135e4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4135e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4135ec:	f9401bf7 	ldr	x23, [sp, #48]
  4135f0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4135f4:	17ffccce 	b	40692c <arch_swap>
		ret = 0;
  4135f8:	52800014 	mov	w20, #0x0                   	// #0
  4135fc:	f947d673 	ldr	x19, [x19, #4008]
  413600:	aa1303e0 	mov	x0, x19
  413604:	97ffeff6 	bl	40f5dc <z_spin_unlock_valid>
  413608:	72001c1f 	tst	w0, #0xff
  41360c:	540002e1 	b.ne	413668 <z_impl_k_thread_join+0x224>  // b.any
  413610:	f0000014 	adrp	x20, 416000 <__func__.0+0x57a>
  413614:	9122ce94 	add	x20, x20, #0x8b3
  413618:	aa1403e2 	mov	x2, x20
  41361c:	52801863 	mov	w3, #0xc3                  	// #195
  413620:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413624:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413628:	91255821 	add	x1, x1, #0x956
  41362c:	91353400 	add	x0, x0, #0xd4d
  413630:	97ffc6e3 	bl	4051bc <assert_print>
  413634:	aa1303e1 	mov	x1, x19
  413638:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  41363c:	9125b400 	add	x0, x0, #0x96d
  413640:	97ffc6df 	bl	4051bc <assert_print>
  413644:	aa1403e0 	mov	x0, x20
  413648:	52801861 	mov	w1, #0xc3                  	// #195
  41364c:	97ffc706 	bl	405264 <assert_post_action>
  413650:	52801862 	mov	w2, #0xc3                  	// #195
  413654:	17ffffe1 	b	4135d8 <z_impl_k_thread_join+0x194>
		ret = -EBUSY;
  413658:	128001f4 	mov	w20, #0xfffffff0            	// #-16
  41365c:	17ffffe8 	b	4135fc <z_impl_k_thread_join+0x1b8>
		ret = -EDEADLK;
  413660:	12800454 	mov	w20, #0xffffffdd            	// #-35
  413664:	17ffffe6 	b	4135fc <z_impl_k_thread_join+0x1b8>
	posix_irq_unlock(key);
  413668:	2a1703e0 	mov	w0, w23
  41366c:	97ffcfdc 	bl	4075dc <posix_irq_unlock>
}
  413670:	2a1403e0 	mov	w0, w20
  413674:	a94153f3 	ldp	x19, x20, [sp, #16]
  413678:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41367c:	f9401bf7 	ldr	x23, [sp, #48]
  413680:	a8c47bfd 	ldp	x29, x30, [sp], #64
  413684:	d65f03c0 	ret

0000000000413688 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
  413688:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  41368c:	910003fd 	mov	x29, sp
  413690:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413694:	b00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  413698:	aa0003f4 	mov	x20, x0
  41369c:	a9025bf5 	stp	x21, x22, [sp, #32]
  4136a0:	a90363f7 	stp	x23, x24, [sp, #48]
  4136a4:	2a0103f8 	mov	w24, w1
  4136a8:	aa0203f7 	mov	x23, x2
  4136ac:	f90023f9 	str	x25, [sp, #64]
	return posix_irq_lock();
  4136b0:	97ffcfc9 	bl	4075d4 <posix_irq_lock>
  4136b4:	f947d679 	ldr	x25, [x19, #4008]
  4136b8:	2a0003f6 	mov	w22, w0
  4136bc:	aa1903e0 	mov	x0, x25
  4136c0:	97ffefbc 	bl	40f5b0 <z_spin_lock_valid>
  4136c4:	72001c15 	ands	w21, w0, #0xff
  4136c8:	540002c1 	b.ne	413720 <z_sched_wake+0x98>  // b.any
  4136cc:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  4136d0:	9122ce73 	add	x19, x19, #0x8b3
  4136d4:	aa1303e2 	mov	x2, x19
  4136d8:	52801283 	mov	w3, #0x94                  	// #148
  4136dc:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  4136e0:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4136e4:	91238021 	add	x1, x1, #0x8e0
  4136e8:	91353400 	add	x0, x0, #0xd4d
  4136ec:	97ffc6b4 	bl	4051bc <assert_print>
  4136f0:	aa1903e1 	mov	x1, x25
  4136f4:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  4136f8:	9123d400 	add	x0, x0, #0x8f5
  4136fc:	97ffc6b0 	bl	4051bc <assert_print>
  413700:	52801281 	mov	w1, #0x94                  	// #148
  413704:	aa1303e0 	mov	x0, x19
  413708:	97ffc6d7 	bl	405264 <assert_post_action>
  41370c:	aa1303e1 	mov	x1, x19
  413710:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413714:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413718:	91362c00 	add	x0, x0, #0xd8b
  41371c:	97ffd0c4 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413720:	aa1903e0 	mov	x0, x25
  413724:	97ffefbb 	bl	40f610 <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
  413728:	aa1403e0 	mov	x0, x20
  41372c:	97fff8d6 	bl	411a84 <z_priq_dumb_best>
  413730:	aa0003f4 	mov	x20, x0

		if (thread != NULL) {
  413734:	b4000400 	cbz	x0, 4137b4 <z_sched_wake+0x12c>
	thread->base.swap_data = data;
  413738:	f9001017 	str	x23, [x0, #32]
  41373c:	b9004c18 	str	w24, [x0, #76]
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
  413740:	97fff86a 	bl	4118e8 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
  413744:	9100a280 	add	x0, x20, #0x28
  413748:	9400014a 	bl	413c70 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
  41374c:	aa1403e0 	mov	x0, x20
  413750:	97fff9a2 	bl	411dd8 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413754:	f947d673 	ldr	x19, [x19, #4008]
  413758:	aa1303e0 	mov	x0, x19
  41375c:	97ffefa0 	bl	40f5dc <z_spin_unlock_valid>
  413760:	72001c1f 	tst	w0, #0xff
  413764:	540002c1 	b.ne	4137bc <z_sched_wake+0x134>  // b.any
  413768:	f0000014 	adrp	x20, 416000 <__func__.0+0x57a>
  41376c:	9122ce94 	add	x20, x20, #0x8b3
  413770:	aa1403e2 	mov	x2, x20
  413774:	52801863 	mov	w3, #0xc3                  	// #195
  413778:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  41377c:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413780:	91255821 	add	x1, x1, #0x956
  413784:	91353400 	add	x0, x0, #0xd4d
  413788:	97ffc68d 	bl	4051bc <assert_print>
  41378c:	aa1303e1 	mov	x1, x19
  413790:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413794:	9125b400 	add	x0, x0, #0x96d
  413798:	97ffc689 	bl	4051bc <assert_print>
  41379c:	52801861 	mov	w1, #0xc3                  	// #195
  4137a0:	aa1403e0 	mov	x0, x20
  4137a4:	97ffc6b0 	bl	405264 <assert_post_action>
  4137a8:	aa1403e1 	mov	x1, x20
  4137ac:	52801862 	mov	w2, #0xc3                  	// #195
  4137b0:	17ffffd9 	b	413714 <z_sched_wake+0x8c>
	bool ret = false;
  4137b4:	52800015 	mov	w21, #0x0                   	// #0
  4137b8:	17ffffe7 	b	413754 <z_sched_wake+0xcc>
	posix_irq_unlock(key);
  4137bc:	2a1603e0 	mov	w0, w22
  4137c0:	97ffcf87 	bl	4075dc <posix_irq_unlock>
			ret = true;
		}
	}

	return ret;
}
  4137c4:	2a1503e0 	mov	w0, w21
  4137c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4137cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4137d0:	a94363f7 	ldp	x23, x24, [sp, #48]
  4137d4:	f94023f9 	ldr	x25, [sp, #64]
  4137d8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4137dc:	d65f03c0 	ret

00000000004137e0 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
  4137e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4137e4:	910003fd 	mov	x29, sp
  4137e8:	f9000bf3 	str	x19, [sp, #16]
  4137ec:	aa0403f3 	mov	x19, x4
	int ret = z_pend_curr(lock, key, wait_q, timeout);
  4137f0:	97fffb0b 	bl	41241c <z_pend_curr>

	if (data != NULL) {
  4137f4:	b40000d3 	cbz	x19, 41380c <z_sched_wait+0x2c>
		*data = _current->base.swap_data;
  4137f8:	b00000c1 	adrp	x1, 42c000 <__FRAME_END__+0xfbbc>
  4137fc:	f9474021 	ldr	x1, [x1, #3712]
  413800:	f9400821 	ldr	x1, [x1, #16]
  413804:	f9401021 	ldr	x1, [x1, #32]
  413808:	f9000261 	str	x1, [x19]
	}
	return ret;
}
  41380c:	f9400bf3 	ldr	x19, [sp, #16]
  413810:	a8c27bfd 	ldp	x29, x30, [sp], #32
  413814:	d65f03c0 	ret

0000000000413818 <z_sched_waitq_walk>:

int z_sched_waitq_walk(_wait_q_t  *wait_q,
		       int (*func)(struct k_thread *, void *), void *data)
{
  413818:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  41381c:	910003fd 	mov	x29, sp
  413820:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413824:	b00000d3 	adrp	x19, 42c000 <__FRAME_END__+0xfbbc>
  413828:	a9025bf5 	stp	x21, x22, [sp, #32]
  41382c:	aa0003f6 	mov	x22, x0
  413830:	a90363f7 	stp	x23, x24, [sp, #48]
  413834:	aa0103f8 	mov	x24, x1
  413838:	f90023f9 	str	x25, [sp, #64]
  41383c:	aa0203f9 	mov	x25, x2
	return posix_irq_lock();
  413840:	97ffcf65 	bl	4075d4 <posix_irq_lock>
  413844:	2a0003f7 	mov	w23, w0
  413848:	f947d674 	ldr	x20, [x19, #4008]
  41384c:	aa1403e0 	mov	x0, x20
  413850:	97ffef58 	bl	40f5b0 <z_spin_lock_valid>
  413854:	72001c1f 	tst	w0, #0xff
  413858:	540002c1 	b.ne	4138b0 <z_sched_waitq_walk+0x98>  // b.any
  41385c:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413860:	9122ce73 	add	x19, x19, #0x8b3
  413864:	aa1303e2 	mov	x2, x19
  413868:	52801283 	mov	w3, #0x94                  	// #148
  41386c:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413870:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413874:	91238021 	add	x1, x1, #0x8e0
  413878:	91353400 	add	x0, x0, #0xd4d
  41387c:	97ffc650 	bl	4051bc <assert_print>
  413880:	aa1403e1 	mov	x1, x20
  413884:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413888:	9123d400 	add	x0, x0, #0x8f5
  41388c:	97ffc64c 	bl	4051bc <assert_print>
  413890:	52801281 	mov	w1, #0x94                  	// #148
  413894:	aa1303e0 	mov	x0, x19
  413898:	97ffc673 	bl	405264 <assert_post_action>
  41389c:	aa1303e1 	mov	x1, x19
  4138a0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4138a4:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4138a8:	91362c00 	add	x0, x0, #0xd8b
  4138ac:	97ffd060 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4138b0:	aa1403e0 	mov	x0, x20
  4138b4:	97ffef57 	bl	40f610 <z_spin_lock_set_owner>
	return list->head == list;
  4138b8:	f94002d4 	ldr	x20, [x22]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4138bc:	eb1402df 	cmp	x22, x20
  4138c0:	54000341 	b.ne	413928 <z_sched_waitq_walk+0x110>  // b.any
  4138c4:	52800015 	mov	w21, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4138c8:	f947d673 	ldr	x19, [x19, #4008]
  4138cc:	aa1303e0 	mov	x0, x19
  4138d0:	97ffef43 	bl	40f5dc <z_spin_unlock_valid>
  4138d4:	72001c1f 	tst	w0, #0xff
  4138d8:	540003e1 	b.ne	413954 <z_sched_waitq_walk+0x13c>  // b.any
  4138dc:	f0000014 	adrp	x20, 416000 <__func__.0+0x57a>
  4138e0:	9122ce94 	add	x20, x20, #0x8b3
  4138e4:	aa1403e2 	mov	x2, x20
  4138e8:	52801863 	mov	w3, #0xc3                  	// #195
  4138ec:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  4138f0:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4138f4:	91255821 	add	x1, x1, #0x956
  4138f8:	91353400 	add	x0, x0, #0xd4d
  4138fc:	97ffc630 	bl	4051bc <assert_print>
  413900:	aa1303e1 	mov	x1, x19
  413904:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413908:	9125b400 	add	x0, x0, #0x96d
  41390c:	97ffc62c 	bl	4051bc <assert_print>
  413910:	52801861 	mov	w1, #0xc3                  	// #195
  413914:	aa1403e0 	mov	x0, x20
  413918:	97ffc653 	bl	405264 <assert_post_action>
  41391c:	aa1403e1 	mov	x1, x20
  413920:	52801862 	mov	w2, #0xc3                  	// #195
  413924:	17ffffe0 	b	4138a4 <z_sched_waitq_walk+0x8c>
	struct k_thread *thread;
	int  status = 0;

	LOCKED(&sched_spinlock) {
		_WAIT_Q_FOR_EACH(wait_q, thread) {
  413928:	b4fffcf4 	cbz	x20, 4138c4 <z_sched_waitq_walk+0xac>
			 * Invoke the callback function on each waiting thread
			 * for as long as there are both waiting threads AND
			 * it returns 0.
			 */

			status = func(thread, data);
  41392c:	aa1903e1 	mov	x1, x25
  413930:	aa1403e0 	mov	x0, x20
  413934:	d63f0300 	blr	x24
  413938:	2a0003f5 	mov	w21, w0
			if (status != 0) {
  41393c:	35fffc60 	cbnz	w0, 4138c8 <z_sched_waitq_walk+0xb0>
	return (node == list->tail) ? NULL : node->next;
  413940:	f94006c0 	ldr	x0, [x22, #8]
  413944:	eb00029f 	cmp	x20, x0
  413948:	54fffbe0 	b.eq	4138c4 <z_sched_waitq_walk+0xac>  // b.none
  41394c:	f9400294 	ldr	x20, [x20]
  413950:	17fffff6 	b	413928 <z_sched_waitq_walk+0x110>
	posix_irq_unlock(key);
  413954:	2a1703e0 	mov	w0, w23
  413958:	97ffcf21 	bl	4075dc <posix_irq_unlock>
			}
		}
	}

	return status;
}
  41395c:	2a1503e0 	mov	w0, w21
  413960:	a94153f3 	ldp	x19, x20, [sp, #16]
  413964:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413968:	a94363f7 	ldp	x23, x24, [sp, #48]
  41396c:	f94023f9 	ldr	x25, [sp, #64]
  413970:	a8c57bfd 	ldp	x29, x30, [sp], #80
  413974:	d65f03c0 	ret

0000000000413978 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
  413978:	900000e0 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  41397c:	b94d4800 	ldr	w0, [x0, #3400]
  413980:	35000040 	cbnz	w0, 413988 <elapsed+0x10>
  413984:	17ffdda0 	b	40b004 <sys_clock_elapsed>
}
  413988:	52800000 	mov	w0, #0x0                   	// #0
  41398c:	d65f03c0 	ret

0000000000413990 <next_timeout>:

static int32_t next_timeout(void)
{
  413990:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
  413994:	d00000c0 	adrp	x0, 42d000 <__dso_handle>
  413998:	912aa001 	add	x1, x0, #0xaa8
  41399c:	910003fd 	mov	x29, sp
  4139a0:	f9000bf3 	str	x19, [sp, #16]
  4139a4:	f9455413 	ldr	x19, [x0, #2728]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4139a8:	eb01027f 	cmp	x19, x1
  4139ac:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
  4139b0:	97fffff2 	bl	413978 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
  4139b4:	b4000173 	cbz	x19, 4139e0 <next_timeout+0x50>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
  4139b8:	f9400e61 	ldr	x1, [x19, #24]
  4139bc:	cb20c021 	sub	x1, x1, w0, sxtw
	if ((to == NULL) ||
  4139c0:	b2407be0 	mov	x0, #0x7fffffff            	// #2147483647
  4139c4:	eb00003f 	cmp	x1, x0
  4139c8:	5400006c 	b.gt	4139d4 <next_timeout+0x44>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
  4139cc:	f100003f 	cmp	x1, #0x0
  4139d0:	9a9fa020 	csel	x0, x1, xzr, ge  // ge = tcont
	}

	return ret;
}
  4139d4:	f9400bf3 	ldr	x19, [sp, #16]
  4139d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4139dc:	d65f03c0 	ret
		ret = MAX_WAIT;
  4139e0:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
  4139e4:	17fffffc 	b	4139d4 <next_timeout+0x44>

00000000004139e8 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  4139e8:	b4000160 	cbz	x0, 413a14 <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
  4139ec:	d00000c1 	adrp	x1, 42d000 <__dso_handle>
  4139f0:	f9455821 	ldr	x1, [x1, #2736]
  4139f4:	eb01001f 	cmp	x0, x1
  4139f8:	540000e0 	b.eq	413a14 <remove_timeout+0x2c>  // b.none
  4139fc:	f9400001 	ldr	x1, [x0]
	if (next(t) != NULL) {
  413a00:	b40000a1 	cbz	x1, 413a14 <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
  413a04:	f9400c03 	ldr	x3, [x0, #24]
  413a08:	f9400c22 	ldr	x2, [x1, #24]
  413a0c:	8b030042 	add	x2, x2, x3
  413a10:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
  413a14:	a9400801 	ldp	x1, x2, [x0]
	prev->next = next;
  413a18:	f9000041 	str	x1, [x2]
	next->prev = prev;
  413a1c:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
  413a20:	a9007c1f 	stp	xzr, xzr, [x0]
}
  413a24:	d65f03c0 	ret

0000000000413a28 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  413a28:	b100045f 	cmn	x2, #0x1
  413a2c:	54001200 	b.eq	413c6c <z_add_timeout+0x244>  // b.none
{
  413a30:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  413a34:	910003fd 	mov	x29, sp
  413a38:	a90153f3 	stp	x19, x20, [sp, #16]
  413a3c:	aa0003f3 	mov	x19, x0
  413a40:	a9025bf5 	stp	x21, x22, [sp, #32]
  413a44:	f9001bf7 	str	x23, [sp, #48]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
  413a48:	f9400000 	ldr	x0, [x0]
  413a4c:	b40002a0 	cbz	x0, 413aa0 <z_add_timeout+0x78>
  413a50:	90000033 	adrp	x19, 417000 <CSWTCH.25+0x8a4>
  413a54:	91026e73 	add	x19, x19, #0x9b
  413a58:	aa1303e2 	mov	x2, x19
  413a5c:	90000021 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  413a60:	9102fc21 	add	x1, x1, #0xbf
  413a64:	52800bc3 	mov	w3, #0x5e                  	// #94
  413a68:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413a6c:	91353400 	add	x0, x0, #0xd4d
  413a70:	97ffc5d3 	bl	4051bc <assert_print>
  413a74:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413a78:	91254c00 	add	x0, x0, #0x953
  413a7c:	97ffc5d0 	bl	4051bc <assert_print>
  413a80:	aa1303e0 	mov	x0, x19
  413a84:	52800bc1 	mov	w1, #0x5e                  	// #94
  413a88:	97ffc5f7 	bl	405264 <assert_post_action>
  413a8c:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413a90:	aa1303e1 	mov	x1, x19
  413a94:	91362c00 	add	x0, x0, #0xd8b
  413a98:	52800bc2 	mov	w2, #0x5e                  	// #94
  413a9c:	97ffcfe4 	bl	407a2c <posix_print_error_and_exit>
	to->fn = fn;
  413aa0:	f9000a61 	str	x1, [x19, #16]
  413aa4:	aa0203f4 	mov	x20, x2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413aa8:	900000f5 	adrp	x21, 42f000 <can_loopback_dev_data_0+0xc0>
  413aac:	911f02b7 	add	x23, x21, #0x7c0
	return posix_irq_lock();
  413ab0:	97ffcec9 	bl	4075d4 <posix_irq_lock>
  413ab4:	2a0003f6 	mov	w22, w0
  413ab8:	aa1703e0 	mov	x0, x23
  413abc:	97ffeebd 	bl	40f5b0 <z_spin_lock_valid>
  413ac0:	72001c1f 	tst	w0, #0xff
  413ac4:	540002c1 	b.ne	413b1c <z_add_timeout+0xf4>  // b.any
  413ac8:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413acc:	9122ce73 	add	x19, x19, #0x8b3
  413ad0:	aa1303e2 	mov	x2, x19
  413ad4:	52801283 	mov	w3, #0x94                  	// #148
  413ad8:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413adc:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413ae0:	91238021 	add	x1, x1, #0x8e0
  413ae4:	91353400 	add	x0, x0, #0xd4d
  413ae8:	97ffc5b5 	bl	4051bc <assert_print>
  413aec:	aa1703e1 	mov	x1, x23
  413af0:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413af4:	9123d400 	add	x0, x0, #0x8f5
  413af8:	97ffc5b1 	bl	4051bc <assert_print>
  413afc:	aa1303e0 	mov	x0, x19
  413b00:	52801281 	mov	w1, #0x94                  	// #148
  413b04:	97ffc5d8 	bl	405264 <assert_post_action>
  413b08:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413b0c:	aa1303e1 	mov	x1, x19
  413b10:	91362c00 	add	x0, x0, #0xd8b
  413b14:	52801282 	mov	w2, #0x94                  	// #148
  413b18:	97ffcfc5 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413b1c:	aa1703e0 	mov	x0, x23
  413b20:	97ffeebc 	bl	40f610 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
  413b24:	b1000a9f 	cmn	x20, #0x2
  413b28:	5400028c 	b.gt	413b78 <z_add_timeout+0x150>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
  413b2c:	900000e0 	adrp	x0, 42f000 <can_loopback_dev_data_0+0xc0>
  413b30:	92800023 	mov	x3, #0xfffffffffffffffe    	// #-2
  413b34:	f943dc00 	ldr	x0, [x0, #1976]
  413b38:	cb000063 	sub	x3, x3, x0
  413b3c:	cb140062 	sub	x2, x3, x20

			to->dticks = MAX(1, ticks);
  413b40:	f100005f 	cmp	x2, #0x0
  413b44:	9a9fc442 	csinc	x2, x2, xzr, gt
	return list->head == list;
  413b48:	d00000c0 	adrp	x0, 42d000 <__dso_handle>
  413b4c:	912aa001 	add	x1, x0, #0xaa8
  413b50:	f9000e62 	str	x2, [x19, #24]
  413b54:	f9455402 	ldr	x2, [x0, #2728]
	sys_dnode_t *const tail = list->tail;
  413b58:	f9400424 	ldr	x4, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  413b5c:	eb01005f 	cmp	x2, x1
  413b60:	540001e1 	b.ne	413b9c <z_add_timeout+0x174>  // b.any
	node->next = list;
  413b64:	912aa001 	add	x1, x0, #0xaa8
	node->prev = tail;
  413b68:	a9001261 	stp	x1, x4, [x19]
	tail->next = node;
  413b6c:	f9000093 	str	x19, [x4]
	list->tail = node;
  413b70:	f9000433 	str	x19, [x1, #8]
}
  413b74:	14000015 	b	413bc8 <z_add_timeout+0x1a0>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
  413b78:	91000694 	add	x20, x20, #0x1
  413b7c:	97ffff7f 	bl	413978 <elapsed>
  413b80:	8b20c282 	add	x2, x20, w0, sxtw
  413b84:	17fffff1 	b	413b48 <z_add_timeout+0x120>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
  413b88:	cb030021 	sub	x1, x1, x3
  413b8c:	f9000e61 	str	x1, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
  413b90:	eb02009f 	cmp	x4, x2
  413b94:	54fffe80 	b.eq	413b64 <z_add_timeout+0x13c>  // b.none
  413b98:	f9400042 	ldr	x2, [x2]
		for (t = first(); t != NULL; t = next(t)) {
  413b9c:	b4fffe42 	cbz	x2, 413b64 <z_add_timeout+0x13c>
			if (t->dticks > to->dticks) {
  413ba0:	f9400c43 	ldr	x3, [x2, #24]
  413ba4:	f9400e61 	ldr	x1, [x19, #24]
  413ba8:	eb01007f 	cmp	x3, x1
  413bac:	54fffeed 	b.le	413b88 <z_add_timeout+0x160>
				t->dticks -= to->dticks;
  413bb0:	cb010063 	sub	x3, x3, x1
  413bb4:	f9000c43 	str	x3, [x2, #24]
	sys_dnode_t *const prev = successor->prev;
  413bb8:	f9400441 	ldr	x1, [x2, #8]
	node->prev = prev;
  413bbc:	a9000662 	stp	x2, x1, [x19]
	prev->next = node;
  413bc0:	f9000033 	str	x19, [x1]
	successor->prev = node;
  413bc4:	f9000453 	str	x19, [x2, #8]
	return list->head == list;
  413bc8:	912aa001 	add	x1, x0, #0xaa8
  413bcc:	f9455400 	ldr	x0, [x0, #2728]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  413bd0:	eb01001f 	cmp	x0, x1
  413bd4:	540000c0 	b.eq	413bec <z_add_timeout+0x1c4>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
  413bd8:	eb00027f 	cmp	x19, x0
  413bdc:	54000081 	b.ne	413bec <z_add_timeout+0x1c4>  // b.any
			sys_clock_set_timeout(next_timeout(), false);
  413be0:	97ffff6c 	bl	413990 <next_timeout>
  413be4:	52800001 	mov	w1, #0x0                   	// #0
  413be8:	97ffdcfe 	bl	40afe0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413bec:	911f02b5 	add	x21, x21, #0x7c0
  413bf0:	aa1503e0 	mov	x0, x21
  413bf4:	97ffee7a 	bl	40f5dc <z_spin_unlock_valid>
  413bf8:	72001c1f 	tst	w0, #0xff
  413bfc:	540002c1 	b.ne	413c54 <z_add_timeout+0x22c>  // b.any
  413c00:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413c04:	9122ce73 	add	x19, x19, #0x8b3
  413c08:	aa1303e2 	mov	x2, x19
  413c0c:	52801863 	mov	w3, #0xc3                  	// #195
  413c10:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413c14:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413c18:	91255821 	add	x1, x1, #0x956
  413c1c:	91353400 	add	x0, x0, #0xd4d
  413c20:	97ffc567 	bl	4051bc <assert_print>
  413c24:	aa1503e1 	mov	x1, x21
  413c28:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413c2c:	9125b400 	add	x0, x0, #0x96d
  413c30:	97ffc563 	bl	4051bc <assert_print>
  413c34:	aa1303e0 	mov	x0, x19
  413c38:	52801861 	mov	w1, #0xc3                  	// #195
  413c3c:	97ffc58a 	bl	405264 <assert_post_action>
  413c40:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413c44:	aa1303e1 	mov	x1, x19
  413c48:	91362c00 	add	x0, x0, #0xd8b
  413c4c:	52801862 	mov	w2, #0xc3                  	// #195
  413c50:	97ffcf77 	bl	407a2c <posix_print_error_and_exit>
	posix_irq_unlock(key);
  413c54:	2a1603e0 	mov	w0, w22
		}
	}
}
  413c58:	a94153f3 	ldp	x19, x20, [sp, #16]
  413c5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413c60:	f9401bf7 	ldr	x23, [sp, #48]
  413c64:	a8c47bfd 	ldp	x29, x30, [sp], #64
  413c68:	17ffce5d 	b	4075dc <posix_irq_unlock>
  413c6c:	d65f03c0 	ret

0000000000413c70 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
  413c70:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  413c74:	910003fd 	mov	x29, sp
  413c78:	a90153f3 	stp	x19, x20, [sp, #16]
  413c7c:	aa0003f4 	mov	x20, x0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413c80:	900000f3 	adrp	x19, 42f000 <can_loopback_dev_data_0+0xc0>
  413c84:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  413c88:	97ffce53 	bl	4075d4 <posix_irq_lock>
  413c8c:	911f0276 	add	x22, x19, #0x7c0
  413c90:	2a0003f5 	mov	w21, w0
  413c94:	aa1603e0 	mov	x0, x22
  413c98:	97ffee46 	bl	40f5b0 <z_spin_lock_valid>
  413c9c:	72001c1f 	tst	w0, #0xff
  413ca0:	540002c1 	b.ne	413cf8 <z_abort_timeout+0x88>  // b.any
  413ca4:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413ca8:	9122ce73 	add	x19, x19, #0x8b3
  413cac:	aa1303e2 	mov	x2, x19
  413cb0:	52801283 	mov	w3, #0x94                  	// #148
  413cb4:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413cb8:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413cbc:	91238021 	add	x1, x1, #0x8e0
  413cc0:	91353400 	add	x0, x0, #0xd4d
  413cc4:	97ffc53e 	bl	4051bc <assert_print>
  413cc8:	aa1603e1 	mov	x1, x22
  413ccc:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413cd0:	9123d400 	add	x0, x0, #0x8f5
  413cd4:	97ffc53a 	bl	4051bc <assert_print>
  413cd8:	aa1303e0 	mov	x0, x19
  413cdc:	52801281 	mov	w1, #0x94                  	// #148
  413ce0:	97ffc561 	bl	405264 <assert_post_action>
  413ce4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413ce8:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413cec:	aa1303e1 	mov	x1, x19
  413cf0:	91362c00 	add	x0, x0, #0xd8b
  413cf4:	97ffcf4e 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413cf8:	aa1603e0 	mov	x0, x22
  413cfc:	97ffee45 	bl	40f610 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
  413d00:	f9400280 	ldr	x0, [x20]
  413d04:	b4000360 	cbz	x0, 413d70 <z_abort_timeout+0x100>
			remove_timeout(to);
			ret = 0;
  413d08:	52800016 	mov	w22, #0x0                   	// #0
			remove_timeout(to);
  413d0c:	aa1403e0 	mov	x0, x20
  413d10:	97ffff36 	bl	4139e8 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413d14:	911f0274 	add	x20, x19, #0x7c0
  413d18:	aa1403e0 	mov	x0, x20
  413d1c:	97ffee30 	bl	40f5dc <z_spin_unlock_valid>
  413d20:	72001c1f 	tst	w0, #0xff
  413d24:	540002a1 	b.ne	413d78 <z_abort_timeout+0x108>  // b.any
  413d28:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413d2c:	9122ce73 	add	x19, x19, #0x8b3
  413d30:	aa1303e2 	mov	x2, x19
  413d34:	52801863 	mov	w3, #0xc3                  	// #195
  413d38:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413d3c:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413d40:	91255821 	add	x1, x1, #0x956
  413d44:	91353400 	add	x0, x0, #0xd4d
  413d48:	97ffc51d 	bl	4051bc <assert_print>
  413d4c:	aa1403e1 	mov	x1, x20
  413d50:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413d54:	9125b400 	add	x0, x0, #0x96d
  413d58:	97ffc519 	bl	4051bc <assert_print>
  413d5c:	aa1303e0 	mov	x0, x19
  413d60:	52801861 	mov	w1, #0xc3                  	// #195
  413d64:	97ffc540 	bl	405264 <assert_post_action>
  413d68:	52801862 	mov	w2, #0xc3                  	// #195
  413d6c:	17ffffdf 	b	413ce8 <z_abort_timeout+0x78>
	int ret = -EINVAL;
  413d70:	128002b6 	mov	w22, #0xffffffea            	// #-22
  413d74:	17ffffe8 	b	413d14 <z_abort_timeout+0xa4>
	posix_irq_unlock(key);
  413d78:	2a1503e0 	mov	w0, w21
  413d7c:	97ffce18 	bl	4075dc <posix_irq_unlock>
		}
	}

	return ret;
}
  413d80:	2a1603e0 	mov	w0, w22
  413d84:	a94153f3 	ldp	x19, x20, [sp, #16]
  413d88:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413d8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  413d90:	d65f03c0 	ret

0000000000413d94 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
  413d94:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  413d98:	910003fd 	mov	x29, sp
  413d9c:	a90153f3 	stp	x19, x20, [sp, #16]
  413da0:	2a0003f3 	mov	w19, w0
  413da4:	a9025bf5 	stp	x21, x22, [sp, #32]
  413da8:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413dac:	900000f7 	adrp	x23, 42f000 <can_loopback_dev_data_0+0xc0>
  413db0:	911f02f6 	add	x22, x23, #0x7c0
  413db4:	a9046bf9 	stp	x25, x26, [sp, #64]
  413db8:	f9002bfb 	str	x27, [sp, #80]
	return posix_irq_lock();
  413dbc:	97ffce06 	bl	4075d4 <posix_irq_lock>
  413dc0:	2a0003f4 	mov	w20, w0
  413dc4:	aa1603e0 	mov	x0, x22
  413dc8:	97ffedfa 	bl	40f5b0 <z_spin_lock_valid>
  413dcc:	72001c1f 	tst	w0, #0xff
  413dd0:	540002c1 	b.ne	413e28 <sys_clock_announce+0x94>  // b.any
  413dd4:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413dd8:	9122ce73 	add	x19, x19, #0x8b3
  413ddc:	aa1303e2 	mov	x2, x19
  413de0:	52801283 	mov	w3, #0x94                  	// #148
  413de4:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413de8:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413dec:	91238021 	add	x1, x1, #0x8e0
  413df0:	91353400 	add	x0, x0, #0xd4d
  413df4:	97ffc4f2 	bl	4051bc <assert_print>
  413df8:	911f02e1 	add	x1, x23, #0x7c0
  413dfc:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413e00:	9123d400 	add	x0, x0, #0x8f5
  413e04:	97ffc4ee 	bl	4051bc <assert_print>
  413e08:	aa1303e0 	mov	x0, x19
  413e0c:	52801281 	mov	w1, #0x94                  	// #148
  413e10:	97ffc515 	bl	405264 <assert_post_action>
  413e14:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413e18:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413e1c:	aa1303e1 	mov	x1, x19
  413e20:	91362c00 	add	x0, x0, #0xd8b
  413e24:	97ffcf02 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413e28:	aa1603e0 	mov	x0, x22
  413e2c:	97ffedf9 	bl	40f610 <z_spin_lock_set_owner>
	return list->head == list;
  413e30:	d00000c0 	adrp	x0, 42d000 <__dso_handle>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
  413e34:	900000f8 	adrp	x24, 42f000 <can_loopback_dev_data_0+0xc0>
  413e38:	912aa01a 	add	x26, x0, #0xaa8
  413e3c:	900000f9 	adrp	x25, 42f000 <can_loopback_dev_data_0+0xc0>
  413e40:	b90d4b13 	str	w19, [x24, #3400]
  413e44:	f9455413 	ldr	x19, [x0, #2728]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  413e48:	eb1a027f 	cmp	x19, x26
  413e4c:	54000740 	b.eq	413f34 <sys_clock_announce+0x1a0>  // b.none

	struct _timeout *t = first();

	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
  413e50:	9135231b 	add	x27, x24, #0xd48
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
  413e54:	f943df20 	ldr	x0, [x25, #1976]
	     (t != NULL) && (t->dticks <= announce_remaining);
  413e58:	b9400361 	ldr	w1, [x27]
  413e5c:	b40006d3 	cbz	x19, 413f34 <sys_clock_announce+0x1a0>
  413e60:	f9400e75 	ldr	x21, [x19, #24]
  413e64:	93407c22 	sxtw	x2, w1
  413e68:	eb21c2bf 	cmp	x21, w1, sxtw
  413e6c:	5400008d 	b.le	413e7c <sys_clock_announce+0xe8>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
  413e70:	cb0202b5 	sub	x21, x21, x2
  413e74:	f9000e75 	str	x21, [x19, #24]
  413e78:	1400002f 	b	413f34 <sys_clock_announce+0x1a0>
		t->dticks = 0;
  413e7c:	f9000e7f 	str	xzr, [x19, #24]
		curr_tick += dt;
  413e80:	8b35c000 	add	x0, x0, w21, sxtw
  413e84:	f903df20 	str	x0, [x25, #1976]
		remove_timeout(t);
  413e88:	aa1303e0 	mov	x0, x19
  413e8c:	97fffed7 	bl	4139e8 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413e90:	aa1603e0 	mov	x0, x22
  413e94:	97ffedd2 	bl	40f5dc <z_spin_unlock_valid>
  413e98:	72001c1f 	tst	w0, #0xff
  413e9c:	54000261 	b.ne	413ee8 <sys_clock_announce+0x154>  // b.any
  413ea0:	f0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  413ea4:	9122ce73 	add	x19, x19, #0x8b3
  413ea8:	aa1303e2 	mov	x2, x19
  413eac:	52801863 	mov	w3, #0xc3                  	// #195
  413eb0:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413eb4:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413eb8:	91255821 	add	x1, x1, #0x956
  413ebc:	91353400 	add	x0, x0, #0xd4d
  413ec0:	97ffc4bf 	bl	4051bc <assert_print>
  413ec4:	911f02e1 	add	x1, x23, #0x7c0
  413ec8:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413ecc:	9125b400 	add	x0, x0, #0x96d
  413ed0:	97ffc4bb 	bl	4051bc <assert_print>
  413ed4:	aa1303e0 	mov	x0, x19
  413ed8:	52801861 	mov	w1, #0xc3                  	// #195
  413edc:	97ffc4e2 	bl	405264 <assert_post_action>
  413ee0:	52801862 	mov	w2, #0xc3                  	// #195
  413ee4:	17ffffcd 	b	413e18 <sys_clock_announce+0x84>
	posix_irq_unlock(key);
  413ee8:	2a1403e0 	mov	w0, w20
  413eec:	97ffcdbc 	bl	4075dc <posix_irq_unlock>
		t->fn(t);
  413ef0:	f9400a61 	ldr	x1, [x19, #16]
  413ef4:	aa1303e0 	mov	x0, x19
  413ef8:	d63f0020 	blr	x1
	return posix_irq_lock();
  413efc:	97ffcdb6 	bl	4075d4 <posix_irq_lock>
  413f00:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413f04:	aa1603e0 	mov	x0, x22
  413f08:	97ffedaa 	bl	40f5b0 <z_spin_lock_valid>
  413f0c:	72001c1f 	tst	w0, #0xff
  413f10:	54fff620 	b.eq	413dd4 <sys_clock_announce+0x40>  // b.none
	z_spin_lock_set_owner(l);
  413f14:	aa1603e0 	mov	x0, x22
  413f18:	97ffedbe 	bl	40f610 <z_spin_lock_set_owner>
		announce_remaining -= dt;
  413f1c:	b9400360 	ldr	w0, [x27]
	return list->head == list;
  413f20:	f9400353 	ldr	x19, [x26]
  413f24:	4b150000 	sub	w0, w0, w21
  413f28:	b9000360 	str	w0, [x27]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  413f2c:	eb1a027f 	cmp	x19, x26
  413f30:	54fff921 	b.ne	413e54 <sys_clock_announce+0xc0>  // b.any
	}

	curr_tick += announce_remaining;
  413f34:	f943df21 	ldr	x1, [x25, #1976]
  413f38:	b98d4b00 	ldrsw	x0, [x24, #3400]
	announce_remaining = 0;
  413f3c:	b90d4b1f 	str	wzr, [x24, #3400]
	curr_tick += announce_remaining;
  413f40:	8b010000 	add	x0, x0, x1
  413f44:	f903df20 	str	x0, [x25, #1976]

	sys_clock_set_timeout(next_timeout(), false);
  413f48:	97fffe92 	bl	413990 <next_timeout>
  413f4c:	52800001 	mov	w1, #0x0                   	// #0
  413f50:	97ffdc24 	bl	40afe0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413f54:	911f02e0 	add	x0, x23, #0x7c0
  413f58:	97ffeda1 	bl	40f5dc <z_spin_unlock_valid>
  413f5c:	72001c1f 	tst	w0, #0xff
  413f60:	54fffa00 	b.eq	413ea0 <sys_clock_announce+0x10c>  // b.none
	posix_irq_unlock(key);
  413f64:	2a1403e0 	mov	w0, w20
  413f68:	97ffcd9d 	bl	4075dc <posix_irq_unlock>
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
  413f6c:	a94153f3 	ldp	x19, x20, [sp, #16]
  413f70:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413f74:	a94363f7 	ldp	x23, x24, [sp, #48]
  413f78:	a9446bf9 	ldp	x25, x26, [sp, #64]
  413f7c:	f9402bfb 	ldr	x27, [sp, #80]
  413f80:	a8c67bfd 	ldp	x29, x30, [sp], #96
	z_time_slice();
  413f84:	17fff743 	b	411c90 <z_time_slice>

0000000000413f88 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
  413f88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  413f8c:	910003fd 	mov	x29, sp
  413f90:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413f94:	900000f3 	adrp	x19, 42f000 <can_loopback_dev_data_0+0xc0>
  413f98:	911f0273 	add	x19, x19, #0x7c0
  413f9c:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  413fa0:	97ffcd8d 	bl	4075d4 <posix_irq_lock>
  413fa4:	2a0003f5 	mov	w21, w0
  413fa8:	aa1303e0 	mov	x0, x19
  413fac:	97ffed81 	bl	40f5b0 <z_spin_lock_valid>
  413fb0:	72001c1f 	tst	w0, #0xff
  413fb4:	540002c1 	b.ne	41400c <sys_clock_tick_get+0x84>  // b.any
  413fb8:	f0000014 	adrp	x20, 416000 <__func__.0+0x57a>
  413fbc:	9122ce94 	add	x20, x20, #0x8b3
  413fc0:	aa1403e2 	mov	x2, x20
  413fc4:	52801283 	mov	w3, #0x94                  	// #148
  413fc8:	f0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  413fcc:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  413fd0:	91238021 	add	x1, x1, #0x8e0
  413fd4:	91353400 	add	x0, x0, #0xd4d
  413fd8:	97ffc479 	bl	4051bc <assert_print>
  413fdc:	aa1303e1 	mov	x1, x19
  413fe0:	f0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  413fe4:	9123d400 	add	x0, x0, #0x8f5
  413fe8:	97ffc475 	bl	4051bc <assert_print>
  413fec:	aa1403e0 	mov	x0, x20
  413ff0:	52801281 	mov	w1, #0x94                  	// #148
  413ff4:	97ffc49c 	bl	405264 <assert_post_action>
  413ff8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413ffc:	b0000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  414000:	aa1403e1 	mov	x1, x20
  414004:	91362c00 	add	x0, x0, #0xd8b
  414008:	97ffce89 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  41400c:	aa1303e0 	mov	x0, x19
  414010:	97ffed80 	bl	40f610 <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
  414014:	97fffe59 	bl	413978 <elapsed>
  414018:	f00000c1 	adrp	x1, 42f000 <can_loopback_dev_data_0+0xc0>
  41401c:	f943dc21 	ldr	x1, [x1, #1976]
  414020:	8b20c034 	add	x20, x1, w0, sxtw
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414024:	aa1303e0 	mov	x0, x19
  414028:	97ffed6d 	bl	40f5dc <z_spin_unlock_valid>
  41402c:	72001c1f 	tst	w0, #0xff
  414030:	54000261 	b.ne	41407c <sys_clock_tick_get+0xf4>  // b.any
  414034:	d0000014 	adrp	x20, 416000 <__func__.0+0x57a>
  414038:	9122ce94 	add	x20, x20, #0x8b3
  41403c:	aa1403e2 	mov	x2, x20
  414040:	52801863 	mov	w3, #0xc3                  	// #195
  414044:	d0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  414048:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  41404c:	91255821 	add	x1, x1, #0x956
  414050:	91353400 	add	x0, x0, #0xd4d
  414054:	97ffc45a 	bl	4051bc <assert_print>
  414058:	aa1303e1 	mov	x1, x19
  41405c:	d0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  414060:	9125b400 	add	x0, x0, #0x96d
  414064:	97ffc456 	bl	4051bc <assert_print>
  414068:	aa1403e0 	mov	x0, x20
  41406c:	52801861 	mov	w1, #0xc3                  	// #195
  414070:	97ffc47d 	bl	405264 <assert_post_action>
  414074:	52801862 	mov	w2, #0xc3                  	// #195
  414078:	17ffffe1 	b	413ffc <sys_clock_tick_get+0x74>
	posix_irq_unlock(key);
  41407c:	2a1503e0 	mov	w0, w21
  414080:	97ffcd57 	bl	4075dc <posix_irq_unlock>
	}
	return t;
}
  414084:	aa1403e0 	mov	x0, x20
  414088:	a94153f3 	ldp	x19, x20, [sp, #16]
  41408c:	f94013f5 	ldr	x21, [sp, #32]
  414090:	a8c37bfd 	ldp	x29, x30, [sp], #48
  414094:	d65f03c0 	ret

0000000000414098 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
  414098:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  41409c:	910003fd 	mov	x29, sp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
  4140a0:	97ffffba 	bl	413f88 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
  4140a4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4140a8:	d65f03c0 	ret

00000000004140ac <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
  4140ac:	17ffffb7 	b	413f88 <sys_clock_tick_get>

00000000004140b0 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
  4140b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4140b4:	910003fd 	mov	x29, sp
  4140b8:	f9000bf3 	str	x19, [sp, #16]
  4140bc:	aa0003f3 	mov	x19, x0
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4140c0:	b100041f 	cmn	x0, #0x1
  4140c4:	54000180 	b.eq	4140f4 <sys_clock_timeout_end_calc+0x44>  // b.none
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  4140c8:	b5000080 	cbnz	x0, 4140d8 <sys_clock_timeout_end_calc+0x28>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
  4140cc:	f9400bf3 	ldr	x19, [sp, #16]
  4140d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
		return sys_clock_tick_get();
  4140d4:	17ffffad 	b	413f88 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
  4140d8:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
  4140dc:	eb130000 	subs	x0, x0, x19
  4140e0:	540000a5 	b.pl	4140f4 <sys_clock_timeout_end_calc+0x44>  // b.nfrst
		return sys_clock_tick_get() + MAX(1, dt);
  4140e4:	97ffffa9 	bl	413f88 <sys_clock_tick_get>
  4140e8:	f100027f 	cmp	x19, #0x0
  4140ec:	9a9fc673 	csinc	x19, x19, xzr, gt
  4140f0:	8b000260 	add	x0, x19, x0
}
  4140f4:	f9400bf3 	ldr	x19, [sp, #16]
  4140f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4140fc:	d65f03c0 	ret

0000000000414100 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
  414100:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  414104:	910003fd 	mov	x29, sp
  414108:	a90153f3 	stp	x19, x20, [sp, #16]
  41410c:	aa0003f4 	mov	x20, x0
  414110:	a9025bf5 	stp	x21, x22, [sp, #32]
  414114:	2a0103f5 	mov	w21, w1
  414118:	f9001bf7 	str	x23, [sp, #48]
	struct z_poller *poller = event->poller;
  41411c:	f9400813 	ldr	x19, [x0, #16]
	int retcode = 0;

	if (poller != NULL) {
  414120:	b4000113 	cbz	x19, 414140 <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
  414124:	39400660 	ldrb	w0, [x19, #1]
  414128:	7100041f 	cmp	w0, #0x1
  41412c:	540004c1 	b.ne	4141c4 <signal_poll_event+0xc4>  // b.any
	if (!z_is_thread_pending(thread)) {
  414130:	385a9260 	ldurb	w0, [x19, #-87]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
  414134:	d101c276 	sub	x22, x19, #0x70
  414138:	37080160 	tbnz	w0, #1, 414164 <signal_poll_event+0x64>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
  41413c:	3900027f 	strb	wzr, [x19]
	event->state |= state;
  414140:	f9400e80 	ldr	x0, [x20, #24]
	event->poller = NULL;
  414144:	f9000a9f 	str	xzr, [x20, #16]
	event->state |= state;
  414148:	d34e5000 	ubfx	x0, x0, #14, #7
  41414c:	2a0002b5 	orr	w21, w21, w0
  414150:	b9401a80 	ldr	w0, [x20, #24]
  414154:	33121aa0 	bfi	w0, w21, #14, #7
  414158:	b9001a80 	str	w0, [x20, #24]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
  41415c:	52800000 	mov	w0, #0x0                   	// #0
  414160:	14000006 	b	414178 <signal_poll_event+0x78>
	if (z_is_thread_timeout_expired(thread)) {
  414164:	f94022c0 	ldr	x0, [x22, #64]
  414168:	b100081f 	cmn	x0, #0x2
  41416c:	54000101 	b.ne	41418c <signal_poll_event+0x8c>  // b.any
		return -EAGAIN;
  414170:	12800140 	mov	w0, #0xfffffff5            	// #-11
		poller->is_polling = false;
  414174:	3900027f 	strb	wzr, [x19]
}
  414178:	a94153f3 	ldp	x19, x20, [sp, #16]
  41417c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  414180:	f9401bf7 	ldr	x23, [sp, #48]
  414184:	a8c47bfd 	ldp	x29, x30, [sp], #64
  414188:	d65f03c0 	ret
	z_unpend_thread(thread);
  41418c:	aa1603e0 	mov	x0, x22
  414190:	97fff5f6 	bl	411968 <z_unpend_thread>
	arch_thread_return_value_set(thread,
  414194:	710022bf 	cmp	w21, #0x8
  414198:	12800060 	mov	w0, #0xfffffffc            	// #-4
  41419c:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  4141a0:	b9004ec0 	str	w0, [x22, #76]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  4141a4:	394066c0 	ldrb	w0, [x22, #25]
  4141a8:	f240101f 	tst	x0, #0x1f
  4141ac:	54fffc81 	b.ne	41413c <signal_poll_event+0x3c>  // b.any
	if (!z_is_thread_ready(thread)) {
  4141b0:	f85b8260 	ldur	x0, [x19, #-72]
  4141b4:	b5fffc40 	cbnz	x0, 41413c <signal_poll_event+0x3c>
	z_ready_thread(thread);
  4141b8:	aa1603e0 	mov	x0, x22
  4141bc:	97fff74f 	bl	411ef8 <z_ready_thread>
		poller->is_polling = false;
  4141c0:	17ffffdf 	b	41413c <signal_poll_event+0x3c>
		} else if (poller->mode == MODE_TRIGGERED) {
  4141c4:	7100081f 	cmp	w0, #0x2
  4141c8:	54fffba1 	b.ne	41413c <signal_poll_event+0x3c>  // b.any
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
  4141cc:	39400260 	ldrb	w0, [x19]
  4141d0:	34fffb80 	cbz	w0, 414140 <signal_poll_event+0x40>
  4141d4:	f85f8277 	ldur	x23, [x19, #-8]
  4141d8:	d100a276 	sub	x22, x19, #0x28
  4141dc:	b4fffb17 	cbz	x23, 41413c <signal_poll_event+0x3c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
  4141e0:	91008260 	add	x0, x19, #0x20
  4141e4:	97fffea3 	bl	413c70 <z_abort_timeout>
		twork->poll_result = 0;
  4141e8:	b900427f 	str	wzr, [x19, #64]
		z_work_submit_to_queue(work_q, &twork->work);
  4141ec:	aa1603e1 	mov	x1, x22
  4141f0:	aa1703e0 	mov	x0, x23
  4141f4:	97fff310 	bl	410e34 <z_work_submit_to_queue>
		poller->is_polling = false;
  4141f8:	17ffffd1 	b	41413c <signal_poll_event+0x3c>

00000000004141fc <z_handle_obj_poll_events>:
{
  4141fc:	aa0003e2 	mov	x2, x0
	return list->head == list;
  414200:	f9400000 	ldr	x0, [x0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
  414204:	eb00005f 	cmp	x2, x0
  414208:	540000c0 	b.eq	414220 <z_handle_obj_poll_events+0x24>  // b.none
	sys_dnode_t *const prev = node->prev;
  41420c:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
  414210:	f9000062 	str	x2, [x3]
	next->prev = prev;
  414214:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
  414218:	a9007c1f 	stp	xzr, xzr, [x0]
		(void) signal_poll_event(poll_event, state);
  41421c:	17ffffb9 	b	414100 <signal_poll_event>
}
  414220:	d65f03c0 	ret

0000000000414224 <k_event_post_internal>:
	return 0;
}

static void k_event_post_internal(struct k_event *event, uint32_t events,
				  uint32_t events_mask)
{
  414224:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  414228:	910003fd 	mov	x29, sp
  41422c:	a9025bf5 	stp	x21, x22, [sp, #32]
  414230:	aa0003f5 	mov	x21, x0
  414234:	900000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  414238:	a90153f3 	stp	x19, x20, [sp, #16]
  41423c:	2a0103f3 	mov	w19, w1
	k_spinlock_key_t  key;
	struct k_thread  *thread;
	struct event_walk_data data;

	data.head = NULL;
	key = k_spin_lock(&event->lock);
  414240:	910062b6 	add	x22, x21, #0x18
{
  414244:	f9478400 	ldr	x0, [x0, #3848]
  414248:	a90363f7 	stp	x23, x24, [sp, #48]
  41424c:	2a0203f8 	mov	w24, w2
  414250:	f9400001 	ldr	x1, [x0]
  414254:	f9002fe1 	str	x1, [sp, #88]
  414258:	d2800001 	mov	x1, #0x0                   	// #0
	data.head = NULL;
  41425c:	f90027ff 	str	xzr, [sp, #72]
	return posix_irq_lock();
  414260:	97ffccdd 	bl	4075d4 <posix_irq_lock>
  414264:	2a0003f7 	mov	w23, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  414268:	aa1603e0 	mov	x0, x22
  41426c:	97ffecd1 	bl	40f5b0 <z_spin_lock_valid>
  414270:	72001c1f 	tst	w0, #0xff
  414274:	540002c1 	b.ne	4142cc <k_event_post_internal+0xa8>  // b.any
  414278:	d0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  41427c:	9122ce73 	add	x19, x19, #0x8b3
  414280:	aa1303e2 	mov	x2, x19
  414284:	52801283 	mov	w3, #0x94                  	// #148
  414288:	d0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  41428c:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  414290:	91238021 	add	x1, x1, #0x8e0
  414294:	91353400 	add	x0, x0, #0xd4d
  414298:	97ffc3c9 	bl	4051bc <assert_print>
  41429c:	aa1603e1 	mov	x1, x22
  4142a0:	d0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  4142a4:	9123d400 	add	x0, x0, #0x8f5
  4142a8:	97ffc3c5 	bl	4051bc <assert_print>
  4142ac:	aa1303e0 	mov	x0, x19
  4142b0:	52801281 	mov	w1, #0x94                  	// #148
  4142b4:	97ffc3ec 	bl	405264 <assert_post_action>
  4142b8:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4142bc:	aa1303e1 	mov	x1, x19
  4142c0:	91362c00 	add	x0, x0, #0xd8b
  4142c4:	52801282 	mov	w2, #0x94                  	// #148
  4142c8:	97ffcdd9 	bl	407a2c <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4142cc:	aa1603e0 	mov	x0, x22
  4142d0:	97ffecd0 	bl	40f610 <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_event, post, event, events,
					events_mask);

	events = (event->events & ~events_mask) |
  4142d4:	b94012b4 	ldr	w20, [x21, #16]
	 * 1. Walk the waitq and create a linked list of threads to unpend.
	 * 2. Unpend each of the threads in the linked list
	 * 3. Ready each of the threads in the linked list
	 */

	z_sched_waitq_walk(&event->wait_q, event_walk_op, &data);
  4142d8:	aa1503e0 	mov	x0, x21
  4142dc:	90000001 	adrp	x1, 414000 <sys_clock_tick_get+0x78>
  4142e0:	91157021 	add	x1, x1, #0x55c
  4142e4:	4a130293 	eor	w19, w20, w19
  4142e8:	0a180262 	and	w2, w19, w24
	events = (event->events & ~events_mask) |
  4142ec:	4a020294 	eor	w20, w20, w2
	event->events = events;
  4142f0:	b90012b4 	str	w20, [x21, #16]
	z_sched_waitq_walk(&event->wait_q, event_walk_op, &data);
  4142f4:	910123e2 	add	x2, sp, #0x48
	data.events = events;
  4142f8:	b90053f4 	str	w20, [sp, #80]
	z_sched_waitq_walk(&event->wait_q, event_walk_op, &data);
  4142fc:	97fffd47 	bl	413818 <z_sched_waitq_walk>

	if (data.head != NULL) {
  414300:	f94027f3 	ldr	x19, [sp, #72]
  414304:	b4000113 	cbz	x19, 414324 <k_event_post_internal+0x100>
  414308:	b9004e7f 	str	wzr, [x19, #76]
		thread = data.head;
		struct k_thread *next;
		do {
			arch_thread_return_value_set(thread, 0);
			thread->events = events;
  41430c:	aa1303e0 	mov	x0, x19
  414310:	b9008274 	str	w20, [x19, #128]
			next = thread->next_event_link;
			z_sched_wake_thread(thread, false);
  414314:	52800001 	mov	w1, #0x0                   	// #0
			next = thread->next_event_link;
  414318:	f9403e73 	ldr	x19, [x19, #120]
			z_sched_wake_thread(thread, false);
  41431c:	97fff783 	bl	412128 <z_sched_wake_thread>
			thread = next;
		} while (thread != NULL);
  414320:	17fffff9 	b	414304 <k_event_post_internal+0xe0>
	}

	z_reschedule(&event->lock, key);
  414324:	2a1703e1 	mov	w1, w23
  414328:	aa1603e0 	mov	x0, x22
  41432c:	97fff498 	bl	41158c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_event, post, event, events,
				       events_mask);
}
  414330:	900000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  414334:	f9478400 	ldr	x0, [x0, #3848]
  414338:	f9402fe2 	ldr	x2, [sp, #88]
  41433c:	f9400001 	ldr	x1, [x0]
  414340:	eb010042 	subs	x2, x2, x1
  414344:	d2800001 	mov	x1, #0x0                   	// #0
  414348:	54000040 	b.eq	414350 <k_event_post_internal+0x12c>  // b.none
  41434c:	97ffb459 	bl	4014b0 <__stack_chk_fail@plt>
  414350:	a94153f3 	ldp	x19, x20, [sp, #16]
  414354:	a9425bf5 	ldp	x21, x22, [sp, #32]
  414358:	a94363f7 	ldp	x23, x24, [sp, #48]
  41435c:	a8c67bfd 	ldp	x29, x30, [sp], #96
  414360:	d65f03c0 	ret

0000000000414364 <k_event_wait_internal>:
#include <syscalls/k_event_clear_mrsh.c>
#endif

static uint32_t k_event_wait_internal(struct k_event *event, uint32_t events,
				      unsigned int options, k_timeout_t timeout)
{
  414364:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  414368:	910003fd 	mov	x29, sp
  41436c:	a9025bf5 	stp	x21, x22, [sp, #32]
  414370:	aa0003f5 	mov	x21, x0
	return _kernel.cpus[0].nested != 0U;
  414374:	900000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  414378:	a90153f3 	stp	x19, x20, [sp, #16]
  41437c:	2a0103f3 	mov	w19, w1
  414380:	f9474000 	ldr	x0, [x0, #3712]
  414384:	a90363f7 	stp	x23, x24, [sp, #48]
  414388:	a9046bf9 	stp	x25, x26, [sp, #64]
  41438c:	2a0203fa 	mov	w26, w2
  414390:	aa0303f9 	mov	x25, x3
  414394:	f9002bfb 	str	x27, [sp, #80]
	uint32_t  rv = 0;
	unsigned int  wait_condition;
	struct k_thread  *thread;

	__ASSERT(((arch_is_in_isr() == false) ||
  414398:	b9400000 	ldr	w0, [x0]
  41439c:	340002c0 	cbz	w0, 4143f4 <k_event_wait_internal+0x90>
  4143a0:	b40002a3 	cbz	x3, 4143f4 <k_event_wait_internal+0x90>
  4143a4:	f0000013 	adrp	x19, 417000 <CSWTCH.25+0x8a4>
  4143a8:	91037e73 	add	x19, x19, #0xdf
  4143ac:	aa1303e2 	mov	x2, x19
  4143b0:	d0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  4143b4:	9130c421 	add	x1, x1, #0xc31
  4143b8:	52801d43 	mov	w3, #0xea                  	// #234
  4143bc:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4143c0:	91353400 	add	x0, x0, #0xd4d
  4143c4:	97ffc37e 	bl	4051bc <assert_print>
  4143c8:	d0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  4143cc:	91254c00 	add	x0, x0, #0x953
  4143d0:	97ffc37b 	bl	4051bc <assert_print>
  4143d4:	aa1303e0 	mov	x0, x19
  4143d8:	52801d41 	mov	w1, #0xea                  	// #234
  4143dc:	97ffc3a2 	bl	405264 <assert_post_action>
  4143e0:	52801d42 	mov	w2, #0xea                  	// #234
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4143e4:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4143e8:	aa1303e1 	mov	x1, x19
  4143ec:	91362c00 	add	x0, x0, #0xd8b
  4143f0:	97ffcd8f 	bl	407a2c <posix_print_error_and_exit>
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_event, wait, event, events,
					options, timeout);

	if (events == 0) {
  4143f4:	34000933 	cbz	w19, 414518 <k_event_wait_internal+0x1b4>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_event, wait, event, events, 0);
		return 0;
	}

	wait_condition = options & K_EVENT_WAIT_MASK;
  4143f8:	1200035b 	and	w27, w26, #0x1
	return z_impl_z_current_get();
  4143fc:	97fffb58 	bl	41315c <z_impl_z_current_get>
	thread = z_current_get();

	k_spinlock_key_t  key = k_spin_lock(&event->lock);
  414400:	910062b4 	add	x20, x21, #0x18
  414404:	aa0003f7 	mov	x23, x0
  414408:	97ffcc73 	bl	4075d4 <posix_irq_lock>
  41440c:	2a0003f8 	mov	w24, w0
  414410:	aa1403e0 	mov	x0, x20
  414414:	97ffec67 	bl	40f5b0 <z_spin_lock_valid>
  414418:	72001c1f 	tst	w0, #0xff
  41441c:	54000261 	b.ne	414468 <k_event_wait_internal+0x104>  // b.any
  414420:	d0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  414424:	9122ce73 	add	x19, x19, #0x8b3
  414428:	aa1303e2 	mov	x2, x19
  41442c:	52801283 	mov	w3, #0x94                  	// #148
  414430:	d0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  414434:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  414438:	91238021 	add	x1, x1, #0x8e0
  41443c:	91353400 	add	x0, x0, #0xd4d
  414440:	97ffc35f 	bl	4051bc <assert_print>
  414444:	aa1403e1 	mov	x1, x20
  414448:	d0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  41444c:	9123d400 	add	x0, x0, #0x8f5
  414450:	97ffc35b 	bl	4051bc <assert_print>
  414454:	aa1303e0 	mov	x0, x19
  414458:	52801281 	mov	w1, #0x94                  	// #148
  41445c:	97ffc382 	bl	405264 <assert_post_action>
  414460:	52801282 	mov	w2, #0x94                  	// #148
  414464:	17ffffe0 	b	4143e4 <k_event_wait_internal+0x80>
	z_spin_lock_set_owner(l);
  414468:	aa1403e0 	mov	x0, x20
  41446c:	97ffec69 	bl	40f610 <z_spin_lock_set_owner>

	if (options & K_EVENT_WAIT_RESET) {
  414470:	3608005a 	tbz	w26, #1, 414478 <k_event_wait_internal+0x114>
		event->events = 0;
  414474:	b90012bf 	str	wzr, [x21, #16]
	}

	/* Test if the wait conditions have already been met. */

	if (are_wait_conditions_met(events, event->events, wait_condition)) {
  414478:	b94012b6 	ldr	w22, [x21, #16]
	uint32_t  match = current & desired;
  41447c:	0a1302c0 	and	w0, w22, w19
	if (wait_condition == K_EVENT_WAIT_ALL) {
  414480:	3400033b 	cbz	w27, 4144e4 <k_event_wait_internal+0x180>
	if (are_wait_conditions_met(events, event->events, wait_condition)) {
  414484:	6b00027f 	cmp	w19, w0
  414488:	54000301 	b.ne	4144e8 <k_event_wait_internal+0x184>  // b.any
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41448c:	aa1403e0 	mov	x0, x20
  414490:	97ffec53 	bl	40f5dc <z_spin_unlock_valid>
  414494:	72001c1f 	tst	w0, #0xff
  414498:	540003a1 	b.ne	41450c <k_event_wait_internal+0x1a8>  // b.any
  41449c:	d0000013 	adrp	x19, 416000 <__func__.0+0x57a>
  4144a0:	9122ce73 	add	x19, x19, #0x8b3
  4144a4:	aa1303e2 	mov	x2, x19
  4144a8:	52801863 	mov	w3, #0xc3                  	// #195
  4144ac:	d0000001 	adrp	x1, 416000 <__func__.0+0x57a>
  4144b0:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  4144b4:	91255821 	add	x1, x1, #0x956
  4144b8:	91353400 	add	x0, x0, #0xd4d
  4144bc:	97ffc340 	bl	4051bc <assert_print>
  4144c0:	aa1403e1 	mov	x1, x20
  4144c4:	d0000000 	adrp	x0, 416000 <__func__.0+0x57a>
  4144c8:	9125b400 	add	x0, x0, #0x96d
  4144cc:	97ffc33c 	bl	4051bc <assert_print>
  4144d0:	aa1303e0 	mov	x0, x19
  4144d4:	52801861 	mov	w1, #0xc3                  	// #195
  4144d8:	97ffc363 	bl	405264 <assert_post_action>
  4144dc:	52801862 	mov	w2, #0xc3                  	// #195
  4144e0:	17ffffc1 	b	4143e4 <k_event_wait_internal+0x80>
  4144e4:	35fffd40 	cbnz	w0, 41448c <k_event_wait_internal+0x128>
		goto out;
	}

	/* Match conditions have not been met. */

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  4144e8:	b5000299 	cbnz	x25, 414538 <k_event_wait_internal+0x1d4>
  4144ec:	aa1403e0 	mov	x0, x20
  4144f0:	97ffec3b 	bl	40f5dc <z_spin_unlock_valid>
  4144f4:	72001c1f 	tst	w0, #0xff
  4144f8:	54fffd20 	b.eq	41449c <k_event_wait_internal+0x138>  // b.none
	posix_irq_unlock(key);
  4144fc:	2a1803e0 	mov	w0, w24
  414500:	97ffcc37 	bl	4075dc <posix_irq_unlock>
	uint32_t  rv = 0;
  414504:	52800016 	mov	w22, #0x0                   	// #0
  414508:	14000003 	b	414514 <k_event_wait_internal+0x1b0>
  41450c:	2a1803e0 	mov	w0, w24
  414510:	97ffcc33 	bl	4075dc <posix_irq_unlock>

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_event, wait, event,
				       events, rv & events);

	return rv & events;
  414514:	0a160273 	and	w19, w19, w22
}
  414518:	2a1303e0 	mov	w0, w19
  41451c:	a94153f3 	ldp	x19, x20, [sp, #16]
  414520:	a9425bf5 	ldp	x21, x22, [sp, #32]
  414524:	a94363f7 	ldp	x23, x24, [sp, #48]
  414528:	a9446bf9 	ldp	x25, x26, [sp, #64]
  41452c:	f9402bfb 	ldr	x27, [sp, #80]
  414530:	a8c67bfd 	ldp	x29, x30, [sp], #96
  414534:	d65f03c0 	ret
	thread->event_options = options;
  414538:	29106af3 	stp	w19, w26, [x23, #128]
	if (z_pend_curr(&event->lock, key, &event->wait_q, timeout) == 0) {
  41453c:	aa1903e3 	mov	x3, x25
  414540:	aa1503e2 	mov	x2, x21
  414544:	2a1803e1 	mov	w1, w24
  414548:	aa1403e0 	mov	x0, x20
  41454c:	97fff7b4 	bl	41241c <z_pend_curr>
  414550:	35fffda0 	cbnz	w0, 414504 <k_event_wait_internal+0x1a0>
		rv = thread->events;
  414554:	b94082f6 	ldr	w22, [x23, #128]
  414558:	17ffffef 	b	414514 <k_event_wait_internal+0x1b0>

000000000041455c <event_walk_op>:
	wait_condition = thread->event_options & K_EVENT_WAIT_MASK;
  41455c:	29501003 	ldp	w3, w4, [x0, #128]
	uint32_t  match = current & desired;
  414560:	b9400822 	ldr	w2, [x1, #8]
  414564:	0a020062 	and	w2, w3, w2
	if (wait_condition == K_EVENT_WAIT_ALL) {
  414568:	360001e4 	tbz	w4, #0, 4145a4 <event_walk_op+0x48>
	if (are_wait_conditions_met(thread->events, event_data->events,
  41456c:	6b02007f 	cmp	w3, w2
  414570:	540001c1 	b.ne	4145a8 <event_walk_op+0x4c>  // b.any
{
  414574:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		thread->no_wake_on_timeout = true;
  414578:	52800022 	mov	w2, #0x1                   	// #1
{
  41457c:	910003fd 	mov	x29, sp
		thread->no_wake_on_timeout = true;
  414580:	39022002 	strb	w2, [x0, #136]
		thread->next_event_link = event_data->head;
  414584:	f9400022 	ldr	x2, [x1]
  414588:	f9003c02 	str	x2, [x0, #120]
		event_data->head = thread;
  41458c:	f9000020 	str	x0, [x1]
		z_abort_timeout(&thread->base.timeout);
  414590:	9100a000 	add	x0, x0, #0x28
  414594:	97fffdb7 	bl	413c70 <z_abort_timeout>
}
  414598:	52800000 	mov	w0, #0x0                   	// #0
  41459c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4145a0:	d65f03c0 	ret
	if (are_wait_conditions_met(thread->events, event_data->events,
  4145a4:	35fffe82 	cbnz	w2, 414574 <event_walk_op+0x18>
}
  4145a8:	52800000 	mov	w0, #0x0                   	// #0
  4145ac:	d65f03c0 	ret

00000000004145b0 <z_impl_k_event_init>:
	list->tail = (sys_dnode_t *)list;
  4145b0:	a9000000 	stp	x0, x0, [x0]
	event->events = 0;
  4145b4:	b900101f 	str	wzr, [x0, #16]
	event->lock = (struct k_spinlock) {};
  4145b8:	f9000c1f 	str	xzr, [x0, #24]
}
  4145bc:	d65f03c0 	ret

00000000004145c0 <z_impl_k_event_post>:
{
  4145c0:	2a0103e2 	mov	w2, w1
	k_event_post_internal(event, events, events);
  4145c4:	17ffff18 	b	414224 <k_event_post_internal>

00000000004145c8 <z_impl_k_event_clear>:
	k_event_post_internal(event, 0, events);
  4145c8:	2a0103e2 	mov	w2, w1
  4145cc:	52800001 	mov	w1, #0x0                   	// #0
  4145d0:	17ffff15 	b	414224 <k_event_post_internal>

00000000004145d4 <z_impl_k_event_wait>:
uint32_t z_impl_k_event_wait(struct k_event *event, uint32_t events,
			     bool reset, k_timeout_t timeout)
{
	uint32_t options = reset ? K_EVENT_WAIT_RESET : 0;

	return k_event_wait_internal(event, events, options, timeout);
  4145d4:	531f1c42 	ubfiz	w2, w2, #1, #8
  4145d8:	17ffff63 	b	414364 <k_event_wait_internal>

00000000004145dc <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
  4145dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4145e0:	910003fd 	mov	x29, sp
  4145e4:	a90153f3 	stp	x19, x20, [sp, #16]
  4145e8:	aa0103f4 	mov	x20, x1
  4145ec:	f90013f5 	str	x21, [sp, #32]
  4145f0:	aa0003f5 	mov	x21, x0
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
  4145f4:	97ffeae2 	bl	40f17c <k_is_in_isr>
  4145f8:	72001c1f 	tst	w0, #0xff
  4145fc:	54000521 	b.ne	4146a0 <z_thread_aligned_alloc+0xc4>  // b.any
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
  414600:	900000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  414604:	f9474000 	ldr	x0, [x0, #3712]
  414608:	f9400800 	ldr	x0, [x0, #16]
  41460c:	f9405813 	ldr	x19, [x0, #176]
	}

	if (heap != NULL) {
  414610:	b40004b3 	cbz	x19, 4146a4 <z_thread_aligned_alloc+0xc8>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
  414614:	b1002282 	adds	x2, x20, #0x8
  414618:	54000442 	b.cs	4146a0 <z_thread_aligned_alloc+0xc4>  // b.hs, b.nlast
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
  41461c:	b27d02a1 	orr	x1, x21, #0x8
  414620:	aa1303e0 	mov	x0, x19
  414624:	d2800003 	mov	x3, #0x0                   	// #0
  414628:	97ffe9c8 	bl	40ed48 <k_heap_aligned_alloc>
	if (mem == NULL) {
  41462c:	b40003a0 	cbz	x0, 4146a0 <z_thread_aligned_alloc+0xc4>
	*heap_ref = heap;
  414630:	f9000013 	str	x19, [x0]
	mem = ++heap_ref;
  414634:	91002013 	add	x19, x0, #0x8
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
  414638:	b4000375 	cbz	x21, 4146a4 <z_thread_aligned_alloc+0xc8>
  41463c:	d10006a0 	sub	x0, x21, #0x1
  414640:	ea00027f 	tst	x19, x0
  414644:	54000300 	b.eq	4146a4 <z_thread_aligned_alloc+0xc8>  // b.none
  414648:	f0000014 	adrp	x20, 417000 <CSWTCH.25+0x8a4>
  41464c:	91040a94 	add	x20, x20, #0x102
  414650:	528004a3 	mov	w3, #0x25                  	// #37
  414654:	aa1403e2 	mov	x2, x20
  414658:	f0000001 	adrp	x1, 417000 <CSWTCH.25+0x8a4>
  41465c:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  414660:	91049821 	add	x1, x1, #0x126
  414664:	91353400 	add	x0, x0, #0xd4d
  414668:	97ffc2d5 	bl	4051bc <assert_print>
  41466c:	aa1503e2 	mov	x2, x21
  414670:	aa1303e1 	mov	x1, x19
  414674:	f0000000 	adrp	x0, 417000 <CSWTCH.25+0x8a4>
  414678:	91056000 	add	x0, x0, #0x158
  41467c:	97ffc2d0 	bl	4051bc <assert_print>
  414680:	aa1403e0 	mov	x0, x20
  414684:	528004a1 	mov	w1, #0x25                  	// #37
  414688:	97ffc2f7 	bl	405264 <assert_post_action>
  41468c:	90000000 	adrp	x0, 414000 <sys_clock_tick_get+0x78>
  414690:	aa1403e1 	mov	x1, x20
  414694:	91362c00 	add	x0, x0, #0xd8b
  414698:	528004a2 	mov	w2, #0x25                  	// #37
  41469c:	97ffcce4 	bl	407a2c <posix_print_error_and_exit>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
  4146a0:	d2800013 	mov	x19, #0x0                   	// #0
	}

	return ret;
}
  4146a4:	aa1303e0 	mov	x0, x19
  4146a8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4146ac:	f94013f5 	ldr	x21, [sp, #32]
  4146b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4146b4:	d65f03c0 	ret

00000000004146b8 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
  4146b8:	f0000000 	adrp	x0, 417000 <CSWTCH.25+0x8a4>
  4146bc:	91060000 	add	x0, x0, #0x180
  4146c0:	17ffbd83 	b	403ccc <printk>

00000000004146c4 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
  4146c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4146c8:	900000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
	struct k_work_queue_config cfg = {
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
  4146cc:	d2808002 	mov	x2, #0x400                 	// #1024
{
  4146d0:	910003fd 	mov	x29, sp
  4146d4:	f9478400 	ldr	x0, [x0, #3848]
	k_work_queue_start(&k_sys_work_q,
  4146d8:	910063e4 	add	x4, sp, #0x18
  4146dc:	12800003 	mov	w3, #0xffffffff            	// #-1
{
  4146e0:	f9400001 	ldr	x1, [x0]
  4146e4:	f90017e1 	str	x1, [sp, #40]
  4146e8:	d2800001 	mov	x1, #0x0                   	// #0
	struct k_work_queue_config cfg = {
  4146ec:	f0000000 	adrp	x0, 417000 <CSWTCH.25+0x8a4>
  4146f0:	91070c00 	add	x0, x0, #0x1c3
  4146f4:	f9000fe0 	str	x0, [sp, #24]
	k_work_queue_start(&k_sys_work_q,
  4146f8:	900000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  4146fc:	d00000e1 	adrp	x1, 432000 <z_interrupt_stacks+0x268>
  414700:	91166021 	add	x1, x1, #0x598
	struct k_work_queue_config cfg = {
  414704:	390083ff 	strb	wzr, [sp, #32]
	k_work_queue_start(&k_sys_work_q,
  414708:	f947f800 	ldr	x0, [x0, #4080]
  41470c:	97fff24c 	bl	41103c <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
  414710:	900000c0 	adrp	x0, 42c000 <__FRAME_END__+0xfbbc>
  414714:	f9478400 	ldr	x0, [x0, #3848]
  414718:	f94017e2 	ldr	x2, [sp, #40]
  41471c:	f9400001 	ldr	x1, [x0]
  414720:	eb010042 	subs	x2, x2, x1
  414724:	d2800001 	mov	x1, #0x0                   	// #0
  414728:	54000040 	b.eq	414730 <k_sys_work_q_init+0x6c>  // b.none
  41472c:	97ffb361 	bl	4014b0 <__stack_chk_fail@plt>
  414730:	52800000 	mov	w0, #0x0                   	// #0
  414734:	a8c37bfd 	ldp	x29, x30, [sp], #48
  414738:	d65f03c0 	ret

Disassembly of section .fini:

000000000041473c <_fini>:
  41473c:	d503201f 	nop
  414740:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  414744:	910003fd 	mov	x29, sp
  414748:	a8c17bfd 	ldp	x29, x30, [sp], #16
  41474c:	d65f03c0 	ret
