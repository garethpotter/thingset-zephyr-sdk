
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section .init:

00000000004012f8 <_init>:
  4012f8:	d503201f 	nop
  4012fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  401300:	910003fd 	mov	x29, sp
  401304:	940003fb 	bl	4022f0 <call_weak_fn>
  401308:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40130c:	d65f03c0 	ret

Disassembly of section .plt:

0000000000401310 <.plt>:
  401310:	a9bf7bf0 	stp	x16, x30, [sp, #-16]!
  401314:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401318:	f945d611 	ldr	x17, [x16, #2984]
  40131c:	912ea210 	add	x16, x16, #0xba8
  401320:	d61f0220 	br	x17
  401324:	d503201f 	nop
  401328:	d503201f 	nop
  40132c:	d503201f 	nop

0000000000401330 <memcpy@plt>:
  401330:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401334:	f945da11 	ldr	x17, [x16, #2992]
  401338:	912ec210 	add	x16, x16, #0xbb0
  40133c:	d61f0220 	br	x17

0000000000401340 <memmove@plt>:
  401340:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401344:	f945de11 	ldr	x17, [x16, #3000]
  401348:	912ee210 	add	x16, x16, #0xbb8
  40134c:	d61f0220 	br	x17

0000000000401350 <getcwd@plt>:
  401350:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401354:	f945e211 	ldr	x17, [x16, #3008]
  401358:	912f0210 	add	x16, x16, #0xbc0
  40135c:	d61f0220 	br	x17

0000000000401360 <strtoul@plt>:
  401360:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401364:	f945e611 	ldr	x17, [x16, #3016]
  401368:	912f2210 	add	x16, x16, #0xbc8
  40136c:	d61f0220 	br	x17

0000000000401370 <strlen@plt>:
  401370:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401374:	f945ea11 	ldr	x17, [x16, #3024]
  401378:	912f4210 	add	x16, x16, #0xbd0
  40137c:	d61f0220 	br	x17

0000000000401380 <exit@plt>:
  401380:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401384:	f945ee11 	ldr	x17, [x16, #3032]
  401388:	912f6210 	add	x16, x16, #0xbd8
  40138c:	d61f0220 	br	x17

0000000000401390 <__libc_start_main@plt>:
  401390:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401394:	f945f211 	ldr	x17, [x16, #3040]
  401398:	912f8210 	add	x16, x16, #0xbe0
  40139c:	d61f0220 	br	x17

00000000004013a0 <strtoll@plt>:
  4013a0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4013a4:	f945f611 	ldr	x17, [x16, #3048]
  4013a8:	912fa210 	add	x16, x16, #0xbe8
  4013ac:	d61f0220 	br	x17

00000000004013b0 <strnlen@plt>:
  4013b0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4013b4:	f945fa11 	ldr	x17, [x16, #3056]
  4013b8:	912fc210 	add	x16, x16, #0xbf0
  4013bc:	d61f0220 	br	x17

00000000004013c0 <strtod@plt>:
  4013c0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4013c4:	f945fe11 	ldr	x17, [x16, #3064]
  4013c8:	912fe210 	add	x16, x16, #0xbf8
  4013cc:	d61f0220 	br	x17

00000000004013d0 <__sigsetjmp@plt>:
  4013d0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4013d4:	f9460211 	ldr	x17, [x16, #3072]
  4013d8:	91300210 	add	x16, x16, #0xc00
  4013dc:	d61f0220 	br	x17

00000000004013e0 <__cxa_finalize@plt>:
  4013e0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4013e4:	f9460611 	ldr	x17, [x16, #3080]
  4013e8:	91302210 	add	x16, x16, #0xc08
  4013ec:	d61f0220 	br	x17

00000000004013f0 <clock_gettime@plt>:
  4013f0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4013f4:	f9460a11 	ldr	x17, [x16, #3088]
  4013f8:	91304210 	add	x16, x16, #0xc10
  4013fc:	d61f0220 	br	x17

0000000000401400 <setvbuf@plt>:
  401400:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401404:	f9460e11 	ldr	x17, [x16, #3096]
  401408:	91306210 	add	x16, x16, #0xc18
  40140c:	d61f0220 	br	x17

0000000000401410 <snprintf@plt>:
  401410:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401414:	f9461211 	ldr	x17, [x16, #3104]
  401418:	91308210 	add	x16, x16, #0xc20
  40141c:	d61f0220 	br	x17

0000000000401420 <__memcpy_chk@plt>:
  401420:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401424:	f9461611 	ldr	x17, [x16, #3112]
  401428:	9130a210 	add	x16, x16, #0xc28
  40142c:	d61f0220 	br	x17

0000000000401430 <__snprintf_chk@plt>:
  401430:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401434:	f9461a11 	ldr	x17, [x16, #3120]
  401438:	9130c210 	add	x16, x16, #0xc30
  40143c:	d61f0220 	br	x17

0000000000401440 <strtok_r@plt>:
  401440:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401444:	f9461e11 	ldr	x17, [x16, #3128]
  401448:	9130e210 	add	x16, x16, #0xc38
  40144c:	d61f0220 	br	x17

0000000000401450 <__vsnprintf_chk@plt>:
  401450:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401454:	f9462211 	ldr	x17, [x16, #3136]
  401458:	91310210 	add	x16, x16, #0xc40
  40145c:	d61f0220 	br	x17

0000000000401460 <lroundf@plt>:
  401460:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401464:	f9462611 	ldr	x17, [x16, #3144]
  401468:	91312210 	add	x16, x16, #0xc48
  40146c:	d61f0220 	br	x17

0000000000401470 <sigemptyset@plt>:
  401470:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401474:	f9462a11 	ldr	x17, [x16, #3152]
  401478:	91314210 	add	x16, x16, #0xc50
  40147c:	d61f0220 	br	x17

0000000000401480 <strncmp@plt>:
  401480:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401484:	f9462e11 	ldr	x17, [x16, #3160]
  401488:	91316210 	add	x16, x16, #0xc58
  40148c:	d61f0220 	br	x17

0000000000401490 <memset@plt>:
  401490:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401494:	f9463211 	ldr	x17, [x16, #3168]
  401498:	91318210 	add	x16, x16, #0xc60
  40149c:	d61f0220 	br	x17

00000000004014a0 <sleep@plt>:
  4014a0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4014a4:	f9463611 	ldr	x17, [x16, #3176]
  4014a8:	9131a210 	add	x16, x16, #0xc68
  4014ac:	d61f0220 	br	x17

00000000004014b0 <random@plt>:
  4014b0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4014b4:	f9463a11 	ldr	x17, [x16, #3184]
  4014b8:	9131c210 	add	x16, x16, #0xc70
  4014bc:	d61f0220 	br	x17

00000000004014c0 <__vfprintf_chk@plt>:
  4014c0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4014c4:	f9463e11 	ldr	x17, [x16, #3192]
  4014c8:	9131e210 	add	x16, x16, #0xc78
  4014cc:	d61f0220 	br	x17

00000000004014d0 <calloc@plt>:
  4014d0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4014d4:	f9464211 	ldr	x17, [x16, #3200]
  4014d8:	91320210 	add	x16, x16, #0xc80
  4014dc:	d61f0220 	br	x17

00000000004014e0 <pthread_cond_broadcast@plt>:
  4014e0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4014e4:	f9464611 	ldr	x17, [x16, #3208]
  4014e8:	91322210 	add	x16, x16, #0xc88
  4014ec:	d61f0220 	br	x17

00000000004014f0 <strcasecmp@plt>:
  4014f0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4014f4:	f9464a11 	ldr	x17, [x16, #3216]
  4014f8:	91324210 	add	x16, x16, #0xc90
  4014fc:	d61f0220 	br	x17

0000000000401500 <realloc@plt>:
  401500:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401504:	f9464e11 	ldr	x17, [x16, #3224]
  401508:	91326210 	add	x16, x16, #0xc98
  40150c:	d61f0220 	br	x17

0000000000401510 <strdup@plt>:
  401510:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401514:	f9465211 	ldr	x17, [x16, #3232]
  401518:	91328210 	add	x16, x16, #0xca0
  40151c:	d61f0220 	br	x17

0000000000401520 <__stack_chk_fail@plt>:
  401520:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401524:	f9465611 	ldr	x17, [x16, #3240]
  401528:	9132a210 	add	x16, x16, #0xca8
  40152c:	d61f0220 	br	x17

0000000000401530 <sigaction@plt>:
  401530:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401534:	f9465a11 	ldr	x17, [x16, #3248]
  401538:	9132c210 	add	x16, x16, #0xcb0
  40153c:	d61f0220 	br	x17

0000000000401540 <__gmon_start__@plt>:
  401540:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401544:	f9465e11 	ldr	x17, [x16, #3256]
  401548:	9132e210 	add	x16, x16, #0xcb8
  40154c:	d61f0220 	br	x17

0000000000401550 <__getauxval@plt>:
  401550:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401554:	f9466211 	ldr	x17, [x16, #3264]
  401558:	91330210 	add	x16, x16, #0xcc0
  40155c:	d61f0220 	br	x17

0000000000401560 <abort@plt>:
  401560:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401564:	f9466611 	ldr	x17, [x16, #3272]
  401568:	91332210 	add	x16, x16, #0xcc8
  40156c:	d61f0220 	br	x17

0000000000401570 <pthread_exit@plt>:
  401570:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401574:	f9466a11 	ldr	x17, [x16, #3280]
  401578:	91334210 	add	x16, x16, #0xcd0
  40157c:	d61f0220 	br	x17

0000000000401580 <__fprintf_chk@plt>:
  401580:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401584:	f9466e11 	ldr	x17, [x16, #3288]
  401588:	91336210 	add	x16, x16, #0xcd8
  40158c:	d61f0220 	br	x17

0000000000401590 <strcmp@plt>:
  401590:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401594:	f9467211 	ldr	x17, [x16, #3296]
  401598:	91338210 	add	x16, x16, #0xce0
  40159c:	d61f0220 	br	x17

00000000004015a0 <__ctype_b_loc@plt>:
  4015a0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4015a4:	f9467611 	ldr	x17, [x16, #3304]
  4015a8:	9133a210 	add	x16, x16, #0xce8
  4015ac:	d61f0220 	br	x17

00000000004015b0 <pthread_detach@plt>:
  4015b0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4015b4:	f9467a11 	ldr	x17, [x16, #3312]
  4015b8:	9133c210 	add	x16, x16, #0xcf0
  4015bc:	d61f0220 	br	x17

00000000004015c0 <strtol@plt>:
  4015c0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4015c4:	f9467e11 	ldr	x17, [x16, #3320]
  4015c8:	9133e210 	add	x16, x16, #0xcf8
  4015cc:	d61f0220 	br	x17

00000000004015d0 <free@plt>:
  4015d0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4015d4:	f9468211 	ldr	x17, [x16, #3328]
  4015d8:	91340210 	add	x16, x16, #0xd00
  4015dc:	d61f0220 	br	x17

00000000004015e0 <pthread_cond_wait@plt>:
  4015e0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4015e4:	f9468611 	ldr	x17, [x16, #3336]
  4015e8:	91342210 	add	x16, x16, #0xd08
  4015ec:	d61f0220 	br	x17

00000000004015f0 <nanosleep@plt>:
  4015f0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4015f4:	f9468a11 	ldr	x17, [x16, #3344]
  4015f8:	91344210 	add	x16, x16, #0xd10
  4015fc:	d61f0220 	br	x17

0000000000401600 <__pthread_unwind_next@plt>:
  401600:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401604:	f9468e11 	ldr	x17, [x16, #3352]
  401608:	91346210 	add	x16, x16, #0xd18
  40160c:	d61f0220 	br	x17

0000000000401610 <strchr@plt>:
  401610:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401614:	f9469211 	ldr	x17, [x16, #3360]
  401618:	91348210 	add	x16, x16, #0xd20
  40161c:	d61f0220 	br	x17

0000000000401620 <strtoull@plt>:
  401620:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401624:	f9469611 	ldr	x17, [x16, #3368]
  401628:	9134a210 	add	x16, x16, #0xd28
  40162c:	d61f0220 	br	x17

0000000000401630 <pthread_create@plt>:
  401630:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401634:	f9469a11 	ldr	x17, [x16, #3376]
  401638:	9134c210 	add	x16, x16, #0xd30
  40163c:	d61f0220 	br	x17

0000000000401640 <memchr@plt>:
  401640:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401644:	f9469e11 	ldr	x17, [x16, #3384]
  401648:	9134e210 	add	x16, x16, #0xd38
  40164c:	d61f0220 	br	x17

0000000000401650 <isatty@plt>:
  401650:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401654:	f946a211 	ldr	x17, [x16, #3392]
  401658:	91350210 	add	x16, x16, #0xd40
  40165c:	d61f0220 	br	x17

0000000000401660 <srandom@plt>:
  401660:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401664:	f946a611 	ldr	x17, [x16, #3400]
  401668:	91352210 	add	x16, x16, #0xd48
  40166c:	d61f0220 	br	x17

0000000000401670 <strncpy@plt>:
  401670:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401674:	f946aa11 	ldr	x17, [x16, #3408]
  401678:	91354210 	add	x16, x16, #0xd50
  40167c:	d61f0220 	br	x17

0000000000401680 <__pthread_register_cancel@plt>:
  401680:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401684:	f946ae11 	ldr	x17, [x16, #3416]
  401688:	91356210 	add	x16, x16, #0xd58
  40168c:	d61f0220 	br	x17

0000000000401690 <pthread_self@plt>:
  401690:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  401694:	f946b211 	ldr	x17, [x16, #3424]
  401698:	91358210 	add	x16, x16, #0xd60
  40169c:	d61f0220 	br	x17

00000000004016a0 <__errno_location@plt>:
  4016a0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4016a4:	f946b611 	ldr	x17, [x16, #3432]
  4016a8:	9135a210 	add	x16, x16, #0xd68
  4016ac:	d61f0220 	br	x17

00000000004016b0 <pthread_cancel@plt>:
  4016b0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4016b4:	f946ba11 	ldr	x17, [x16, #3440]
  4016b8:	9135c210 	add	x16, x16, #0xd70
  4016bc:	d61f0220 	br	x17

00000000004016c0 <pthread_mutex_lock@plt>:
  4016c0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4016c4:	f946be11 	ldr	x17, [x16, #3448]
  4016c8:	9135e210 	add	x16, x16, #0xd78
  4016cc:	d61f0220 	br	x17

00000000004016d0 <pthread_mutex_unlock@plt>:
  4016d0:	90000190 	adrp	x16, 431000 <__FRAME_END__+0x10804>
  4016d4:	f946c211 	ldr	x17, [x16, #3456]
  4016d8:	91360210 	add	x16, x16, #0xd80
  4016dc:	d61f0220 	br	x17

Disassembly of section .text:

0000000000401700 <init_have_lse_atomics>:
  401700:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  401704:	d2800200 	mov	x0, #0x10                  	// #16
  401708:	910003fd 	mov	x29, sp
  40170c:	97ffff91 	bl	401550 <__getauxval@plt>
  401710:	53082000 	ubfx	w0, w0, #8, #1
  401714:	900001a1 	adrp	x1, 435000 <stdout_buff+0xc1>
  401718:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40171c:	3905ac20 	strb	w0, [x1, #363]
  401720:	d65f03c0 	ret
  401724:	d503201f 	nop
  401728:	d503201f 	nop
  40172c:	d503201f 	nop
  401730:	d503201f 	nop
  401734:	d503201f 	nop
  401738:	d503201f 	nop
  40173c:	d503201f 	nop

0000000000401740 <_start>:
  401740:	d503201f 	nop
  401744:	d280001d 	mov	x29, #0x0                   	// #0
  401748:	d280001e 	mov	x30, #0x0                   	// #0
  40174c:	aa0003e5 	mov	x5, x0
  401750:	f94003e1 	ldr	x1, [sp]
  401754:	910023e2 	add	x2, sp, #0x8
  401758:	910003e6 	mov	x6, sp
  40175c:	90000180 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  401760:	f947b800 	ldr	x0, [x0, #3952]
  401764:	d2800003 	mov	x3, #0x0                   	// #0
  401768:	d2800004 	mov	x4, #0x0                   	// #0
  40176c:	97ffff09 	bl	401390 <__libc_start_main@plt>
  401770:	97ffff7c 	bl	401560 <abort@plt>
  401774:	d503201f 	nop
  401778:	d503201f 	nop
  40177c:	d503201f 	nop

0000000000401780 <deregister_tm_clones>:
  401780:	b0000180 	adrp	x0, 432000 <__dso_handle>
  401784:	91298000 	add	x0, x0, #0xa60
  401788:	b0000181 	adrp	x1, 432000 <__dso_handle>
  40178c:	91298021 	add	x1, x1, #0xa60
  401790:	eb00003f 	cmp	x1, x0
  401794:	540000c0 	b.eq	4017ac <deregister_tm_clones+0x2c>  // b.none
  401798:	90000181 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40179c:	f946d021 	ldr	x1, [x1, #3488]
  4017a0:	b4000061 	cbz	x1, 4017ac <deregister_tm_clones+0x2c>
  4017a4:	aa0103f0 	mov	x16, x1
  4017a8:	d61f0200 	br	x16
  4017ac:	d65f03c0 	ret

00000000004017b0 <register_tm_clones>:
  4017b0:	b0000180 	adrp	x0, 432000 <__dso_handle>
  4017b4:	91298000 	add	x0, x0, #0xa60
  4017b8:	b0000181 	adrp	x1, 432000 <__dso_handle>
  4017bc:	91298021 	add	x1, x1, #0xa60
  4017c0:	cb000021 	sub	x1, x1, x0
  4017c4:	d37ffc22 	lsr	x2, x1, #63
  4017c8:	8b810c41 	add	x1, x2, x1, asr #3
  4017cc:	9341fc21 	asr	x1, x1, #1
  4017d0:	b40000c1 	cbz	x1, 4017e8 <register_tm_clones+0x38>
  4017d4:	90000182 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  4017d8:	f947e442 	ldr	x2, [x2, #4040]
  4017dc:	b4000062 	cbz	x2, 4017e8 <register_tm_clones+0x38>
  4017e0:	aa0203f0 	mov	x16, x2
  4017e4:	d61f0200 	br	x16
  4017e8:	d65f03c0 	ret
  4017ec:	d503201f 	nop

00000000004017f0 <__do_global_dtors_aux>:
  4017f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4017f4:	910003fd 	mov	x29, sp
  4017f8:	f9000bf3 	str	x19, [sp, #16]
  4017fc:	f0000193 	adrp	x19, 434000 <ztest_thread+0xb8>
  401800:	39789260 	ldrb	w0, [x19, #3620]
  401804:	35000140 	cbnz	w0, 40182c <__do_global_dtors_aux+0x3c>
  401808:	90000180 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40180c:	f946e800 	ldr	x0, [x0, #3536]
  401810:	b4000080 	cbz	x0, 401820 <__do_global_dtors_aux+0x30>
  401814:	b0000180 	adrp	x0, 432000 <__dso_handle>
  401818:	f9400000 	ldr	x0, [x0]
  40181c:	97fffef1 	bl	4013e0 <__cxa_finalize@plt>
  401820:	97ffffd8 	bl	401780 <deregister_tm_clones>
  401824:	52800020 	mov	w0, #0x1                   	// #1
  401828:	39389260 	strb	w0, [x19, #3620]
  40182c:	f9400bf3 	ldr	x19, [sp, #16]
  401830:	a8c27bfd 	ldp	x29, x30, [sp], #32
  401834:	d65f03c0 	ret
  401838:	d503201f 	nop
  40183c:	d503201f 	nop

0000000000401840 <frame_dummy>:
  401840:	17ffffdc 	b	4017b0 <register_tm_clones>
  401844:	d503201f 	nop
  401848:	d503201f 	nop
  40184c:	d503201f 	nop

0000000000401850 <__aarch64_ldadd8_acq_rel>:
  401850:	d503245f 	bti	c
  401854:	900001b0 	adrp	x16, 435000 <stdout_buff+0xc1>
  401858:	3945ae10 	ldrb	w16, [x16, #363]
  40185c:	34000070 	cbz	w16, 401868 <__aarch64_ldadd8_acq_rel+0x18>
  401860:	f8e00020 	ldaddal	x0, x0, [x1]
  401864:	d65f03c0 	ret
  401868:	aa0003f0 	mov	x16, x0
  40186c:	c85ffc20 	ldaxr	x0, [x1]
  401870:	8b100011 	add	x17, x0, x16
  401874:	c80ffc31 	stlxr	w15, x17, [x1]
  401878:	35ffffaf 	cbnz	w15, 40186c <__aarch64_ldadd8_acq_rel+0x1c>
  40187c:	d65f03c0 	ret

0000000000401880 <__divtf3>:
  401880:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  401884:	910003fd 	mov	x29, sp
  401888:	3d8007e0 	str	q0, [sp, #16]
  40188c:	3d800be1 	str	q1, [sp, #32]
  401890:	a94103e1 	ldp	x1, x0, [sp, #16]
  401894:	a9420fe6 	ldp	x6, x3, [sp, #32]
  401898:	d53b440c 	mrs	x12, fpcr
  40189c:	d37ffc04 	lsr	x4, x0, #63
  4018a0:	d340bc02 	ubfx	x2, x0, #0, #48
  4018a4:	12001c8d 	and	w13, w4, #0xff
  4018a8:	aa0403ea 	mov	x10, x4
  4018ac:	d370f808 	ubfx	x8, x0, #48, #15
  4018b0:	34001ee8 	cbz	w8, 401c8c <__divtf3+0x40c>
  4018b4:	528fffe4 	mov	w4, #0x7fff                	// #32767
  4018b8:	6b04011f 	cmp	w8, w4
  4018bc:	540020c0 	b.eq	401cd4 <__divtf3+0x454>  // b.none
  4018c0:	92403d08 	and	x8, x8, #0xffff
  4018c4:	93c1f442 	extr	x2, x2, x1, #61
  4018c8:	9287ffce 	mov	x14, #0xffffffffffffc001    	// #-16383
  4018cc:	d37df021 	lsl	x1, x1, #3
  4018d0:	8b0e0108 	add	x8, x8, x14
  4018d4:	b24d0045 	orr	x5, x2, #0x8000000000000
  4018d8:	d2800010 	mov	x16, #0x0                   	// #0
  4018dc:	d2800002 	mov	x2, #0x0                   	// #0
  4018e0:	52800000 	mov	w0, #0x0                   	// #0
  4018e4:	d37ffc64 	lsr	x4, x3, #63
  4018e8:	d340bc67 	ubfx	x7, x3, #0, #48
  4018ec:	12001c8f 	and	w15, w4, #0xff
  4018f0:	aa0403e9 	mov	x9, x4
  4018f4:	d370f864 	ubfx	x4, x3, #48, #15
  4018f8:	34001a04 	cbz	w4, 401c38 <__divtf3+0x3b8>
  4018fc:	528fffeb 	mov	w11, #0x7fff                	// #32767
  401900:	6b0b009f 	cmp	w4, w11
  401904:	54001f80 	b.eq	401cf4 <__divtf3+0x474>  // b.none
  401908:	9287ffcb 	mov	x11, #0xffffffffffffc001    	// #-16383
  40190c:	92403c84 	and	x4, x4, #0xffff
  401910:	8b0b0084 	add	x4, x4, x11
  401914:	93c6f4e7 	extr	x7, x7, x6, #61
  401918:	4a0f01ab 	eor	w11, w13, w15
  40191c:	b24d00e7 	orr	x7, x7, #0x8000000000000
  401920:	cb040108 	sub	x8, x8, x4
  401924:	d37df0c6 	lsl	x6, x6, #3
  401928:	92401d6e 	and	x14, x11, #0xff
  40192c:	d2800003 	mov	x3, #0x0                   	// #0
  401930:	f100245f 	cmp	x2, #0x9
  401934:	5400046c 	b.gt	4019c0 <__divtf3+0x140>
  401938:	f1001c5f 	cmp	x2, #0x7
  40193c:	54002bcc 	b.gt	401eb4 <__divtf3+0x634>
  401940:	f1000c5f 	cmp	x2, #0x3
  401944:	540000e0 	b.eq	401960 <__divtf3+0xe0>  // b.none
  401948:	5400050d 	b.le	4019e8 <__divtf3+0x168>
  40194c:	f100145f 	cmp	x2, #0x5
  401950:	54000400 	b.eq	4019d0 <__divtf3+0x150>  // b.none
  401954:	5400080d 	b.le	401a54 <__divtf3+0x1d4>
  401958:	f100185f 	cmp	x2, #0x6
  40195c:	54000640 	b.eq	401a24 <__divtf3+0x1a4>  // b.none
  401960:	f100047f 	cmp	x3, #0x1
  401964:	54002780 	b.eq	401e54 <__divtf3+0x5d4>  // b.none
  401968:	b40000a3 	cbz	x3, 40197c <__divtf3+0xfc>
  40196c:	f100087f 	cmp	x3, #0x2
  401970:	54003260 	b.eq	401fbc <__divtf3+0x73c>  // b.none
  401974:	f1000c7f 	cmp	x3, #0x3
  401978:	54003160 	b.eq	401fa4 <__divtf3+0x724>  // b.none
  40197c:	d287ffe1 	mov	x1, #0x3fff                	// #16383
  401980:	8b010104 	add	x4, x8, x1
  401984:	f100009f 	cmp	x4, #0x0
  401988:	5400222d 	b.le	401dcc <__divtf3+0x54c>
  40198c:	f24008df 	tst	x6, #0x7
  401990:	540026c1 	b.ne	401e68 <__divtf3+0x5e8>  // b.any
  401994:	1200012b 	and	w11, w9, #0x1
  401998:	b6a00067 	tbz	x7, #52, 4019a4 <__divtf3+0x124>
  40199c:	924bf8e7 	and	x7, x7, #0xffefffffffffffff
  4019a0:	91401104 	add	x4, x8, #0x4, lsl #12
  4019a4:	d28fffc2 	mov	x2, #0x7ffe                	// #32766
  4019a8:	eb02009f 	cmp	x4, x2
  4019ac:	54002cec 	b.gt	401f48 <__divtf3+0x6c8>
  4019b0:	d343c8e5 	ubfx	x5, x7, #3, #48
  4019b4:	93c60ce1 	extr	x1, x7, x6, #3
  4019b8:	12003884 	and	w4, w4, #0x7fff
  4019bc:	1400001d 	b	401a30 <__divtf3+0x1b0>
  4019c0:	f1002c5f 	cmp	x2, #0xb
  4019c4:	54001c4c 	b.gt	401d4c <__divtf3+0x4cc>
  4019c8:	f100285f 	cmp	x2, #0xa
  4019cc:	54fffca1 	b.ne	401960 <__divtf3+0xe0>  // b.any
  4019d0:	5280000b 	mov	w11, #0x0                   	// #0
  4019d4:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  4019d8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  4019dc:	52800020 	mov	w0, #0x1                   	// #1
  4019e0:	528fffe4 	mov	w4, #0x7fff                	// #32767
  4019e4:	14000013 	b	401a30 <__divtf3+0x1b0>
  4019e8:	f100045f 	cmp	x2, #0x1
  4019ec:	54000181 	b.ne	401a1c <__divtf3+0x19c>  // b.any
  4019f0:	d2800002 	mov	x2, #0x0                   	// #0
  4019f4:	9e670040 	fmov	d0, x2
  4019f8:	d34101ce 	lsl	x14, x14, #63
  4019fc:	321f0000 	orr	w0, w0, #0x2
  401a00:	b25039c3 	orr	x3, x14, #0x7fff000000000000
  401a04:	9eaf0060 	fmov	v0.d[1], x3
  401a08:	3d8007e0 	str	q0, [sp, #16]
  401a0c:	9400021d 	bl	402280 <__sfp_handle_exceptions>
  401a10:	3dc007e0 	ldr	q0, [sp, #16]
  401a14:	a8c37bfd 	ldp	x29, x30, [sp], #48
  401a18:	d65f03c0 	ret
  401a1c:	f100085f 	cmp	x2, #0x2
  401a20:	540001e1 	b.ne	401a5c <__divtf3+0x1dc>  // b.any
  401a24:	52800004 	mov	w4, #0x0                   	// #0
  401a28:	d2800005 	mov	x5, #0x0                   	// #0
  401a2c:	d2800001 	mov	x1, #0x0                   	// #0
  401a30:	d2800003 	mov	x3, #0x0                   	// #0
  401a34:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  401a38:	b340bca3 	bfxil	x3, x5, #0, #48
  401a3c:	9e670020 	fmov	d0, x1
  401a40:	b3503c83 	bfi	x3, x4, #48, #16
  401a44:	9eaf0060 	fmov	v0.d[1], x3
  401a48:	35fffe00 	cbnz	w0, 401a08 <__divtf3+0x188>
  401a4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  401a50:	d65f03c0 	ret
  401a54:	f100105f 	cmp	x2, #0x4
  401a58:	54fffe60 	b.eq	401a24 <__divtf3+0x1a4>  // b.none
  401a5c:	eb0700bf 	cmp	x5, x7
  401a60:	54000068 	b.hi	401a6c <__divtf3+0x1ec>  // b.pmore
  401a64:	fa4100c2 	ccmp	x6, x1, #0x2, eq  // eq = none
  401a68:	54002da8 	b.hi	40201c <__divtf3+0x79c>  // b.pmore
  401a6c:	d341fca3 	lsr	x3, x5, #1
  401a70:	93c104a2 	extr	x2, x5, x1, #1
  401a74:	d3410021 	lsl	x1, x1, #63
  401a78:	d354cce9 	ubfx	x9, x7, #20, #32
  401a7c:	93c6d0e4 	extr	x4, x7, x6, #52
  401a80:	92407c8a 	and	x10, x4, #0xffffffff
  401a84:	d374ccc5 	lsl	x5, x6, #12
  401a88:	9ac90867 	udiv	x7, x3, x9
  401a8c:	9b098ce3 	msub	x3, x7, x9, x3
  401a90:	9b077d46 	mul	x6, x10, x7
  401a94:	93c28063 	extr	x3, x3, x2, #32
  401a98:	eb0300df 	cmp	x6, x3
  401a9c:	540000c9 	b.ls	401ab4 <__divtf3+0x234>  // b.plast
  401aa0:	ab030083 	adds	x3, x4, x3
  401aa4:	d10004ed 	sub	x13, x7, #0x1
  401aa8:	fa4330c0 	ccmp	x6, x3, #0x0, cc  // cc = lo, ul, last
  401aac:	54003088 	b.hi	4020bc <__divtf3+0x83c>  // b.pmore
  401ab0:	aa0d03e7 	mov	x7, x13
  401ab4:	cb060063 	sub	x3, x3, x6
  401ab8:	9ac90866 	udiv	x6, x3, x9
  401abc:	9b098cc3 	msub	x3, x6, x9, x3
  401ac0:	9b067d50 	mul	x16, x10, x6
  401ac4:	b3607c62 	bfi	x2, x3, #32, #32
  401ac8:	eb02021f 	cmp	x16, x2
  401acc:	540000c9 	b.ls	401ae4 <__divtf3+0x264>  // b.plast
  401ad0:	ab020082 	adds	x2, x4, x2
  401ad4:	d10004c3 	sub	x3, x6, #0x1
  401ad8:	fa423200 	ccmp	x16, x2, #0x0, cc  // cc = lo, ul, last
  401adc:	54002ea8 	b.hi	4020b0 <__divtf3+0x830>  // b.pmore
  401ae0:	aa0303e6 	mov	x6, x3
  401ae4:	aa0780d1 	orr	x17, x6, x7, lsl #32
  401ae8:	92407caf 	and	x15, x5, #0xffffffff
  401aec:	92407e27 	and	x7, x17, #0xffffffff
  401af0:	d360fcad 	lsr	x13, x5, #32
  401af4:	d360fe26 	lsr	x6, x17, #32
  401af8:	cb100042 	sub	x2, x2, x16
  401afc:	d2c00032 	mov	x18, #0x100000000           	// #4294967296
  401b00:	9b0f7ce3 	mul	x3, x7, x15
  401b04:	9b0f7cde 	mul	x30, x6, x15
  401b08:	9b0779a7 	madd	x7, x13, x7, x30
  401b0c:	92407c70 	and	x16, x3, #0xffffffff
  401b10:	9b0d7cc6 	mul	x6, x6, x13
  401b14:	8b4380e3 	add	x3, x7, x3, lsr #32
  401b18:	8b1200c7 	add	x7, x6, x18
  401b1c:	eb0303df 	cmp	x30, x3
  401b20:	9a8680e6 	csel	x6, x7, x6, hi  // hi = pmore
  401b24:	8b038210 	add	x16, x16, x3, lsl #32
  401b28:	8b4380c3 	add	x3, x6, x3, lsr #32
  401b2c:	eb03005f 	cmp	x2, x3
  401b30:	54001ca3 	b.cc	401ec4 <__divtf3+0x644>  // b.lo, b.ul, b.last
  401b34:	fa500022 	ccmp	x1, x16, #0x2, eq  // eq = none
  401b38:	aa1103e7 	mov	x7, x17
  401b3c:	54001c43 	b.cc	401ec4 <__divtf3+0x644>  // b.lo, b.ul, b.last
  401b40:	eb100021 	subs	x1, x1, x16
  401b44:	da030042 	sbc	x2, x2, x3
  401b48:	eb02009f 	cmp	x4, x2
  401b4c:	54002be0 	b.eq	4020c8 <__divtf3+0x848>  // b.none
  401b50:	9ac90846 	udiv	x6, x2, x9
  401b54:	9b0988c2 	msub	x2, x6, x9, x2
  401b58:	9b067d43 	mul	x3, x10, x6
  401b5c:	93c18042 	extr	x2, x2, x1, #32
  401b60:	eb02007f 	cmp	x3, x2
  401b64:	540000c9 	b.ls	401b7c <__divtf3+0x2fc>  // b.plast
  401b68:	ab020082 	adds	x2, x4, x2
  401b6c:	d10004cb 	sub	x11, x6, #0x1
  401b70:	fa423060 	ccmp	x3, x2, #0x0, cc  // cc = lo, ul, last
  401b74:	540030e8 	b.hi	402190 <__divtf3+0x910>  // b.pmore
  401b78:	aa0b03e6 	mov	x6, x11
  401b7c:	cb030042 	sub	x2, x2, x3
  401b80:	9ac90843 	udiv	x3, x2, x9
  401b84:	9b098869 	msub	x9, x3, x9, x2
  401b88:	9b037d4a 	mul	x10, x10, x3
  401b8c:	b3607d21 	bfi	x1, x9, #32, #32
  401b90:	eb01015f 	cmp	x10, x1
  401b94:	540000c9 	b.ls	401bac <__divtf3+0x32c>  // b.plast
  401b98:	ab010081 	adds	x1, x4, x1
  401b9c:	d1000462 	sub	x2, x3, #0x1
  401ba0:	fa413140 	ccmp	x10, x1, #0x0, cc  // cc = lo, ul, last
  401ba4:	54002f08 	b.hi	402184 <__divtf3+0x904>  // b.pmore
  401ba8:	aa0203e3 	mov	x3, x2
  401bac:	aa068066 	orr	x6, x3, x6, lsl #32
  401bb0:	cb0a0021 	sub	x1, x1, x10
  401bb4:	92407cc3 	and	x3, x6, #0xffffffff
  401bb8:	d2c0002b 	mov	x11, #0x100000000           	// #4294967296
  401bbc:	d360fcca 	lsr	x10, x6, #32
  401bc0:	9b037de2 	mul	x2, x15, x3
  401bc4:	9b0f7d4f 	mul	x15, x10, x15
  401bc8:	9b033da3 	madd	x3, x13, x3, x15
  401bcc:	92407c49 	and	x9, x2, #0xffffffff
  401bd0:	9b0a7dad 	mul	x13, x13, x10
  401bd4:	8b428062 	add	x2, x3, x2, lsr #32
  401bd8:	8b0b01a3 	add	x3, x13, x11
  401bdc:	eb0201ff 	cmp	x15, x2
  401be0:	9a8d806d 	csel	x13, x3, x13, hi  // hi = pmore
  401be4:	8b028123 	add	x3, x9, x2, lsl #32
  401be8:	8b4281a2 	add	x2, x13, x2, lsr #32
  401bec:	eb02003f 	cmp	x1, x2
  401bf0:	54002042 	b.cs	401ff8 <__divtf3+0x778>  // b.hs, b.nlast
  401bf4:	ab010089 	adds	x9, x4, x1
  401bf8:	d10004ca 	sub	x10, x6, #0x1
  401bfc:	aa0903e1 	mov	x1, x9
  401c00:	540000a2 	b.cs	401c14 <__divtf3+0x394>  // b.hs, b.nlast
  401c04:	eb02013f 	cmp	x9, x2
  401c08:	54002823 	b.cc	40210c <__divtf3+0x88c>  // b.lo, b.ul, b.last
  401c0c:	fa4300a2 	ccmp	x5, x3, #0x2, eq  // eq = none
  401c10:	540027e3 	b.cc	40210c <__divtf3+0x88c>  // b.lo, b.ul, b.last
  401c14:	eb0300bf 	cmp	x5, x3
  401c18:	aa0a03e6 	mov	x6, x10
  401c1c:	1a9f07e9 	cset	w9, ne  // ne = any
  401c20:	7100013f 	cmp	w9, #0x0
  401c24:	aa0e03e9 	mov	x9, x14
  401c28:	fa420020 	ccmp	x1, x2, #0x0, eq  // eq = none
  401c2c:	b24000c1 	orr	x1, x6, #0x1
  401c30:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  401c34:	17ffff52 	b	40197c <__divtf3+0xfc>
  401c38:	aa0700c3 	orr	x3, x6, x7
  401c3c:	b4000b63 	cbz	x3, 401da8 <__divtf3+0x528>
  401c40:	b4001707 	cbz	x7, 401f20 <__divtf3+0x6a0>
  401c44:	dac010e3 	clz	x3, x7
  401c48:	d1003c64 	sub	x4, x3, #0xf
  401c4c:	11000c8e 	add	w14, w4, #0x3
  401c50:	528007ab 	mov	w11, #0x3d                  	// #61
  401c54:	4b040164 	sub	w4, w11, w4
  401c58:	9ace20e7 	lsl	x7, x7, x14
  401c5c:	9ac424c4 	lsr	x4, x6, x4
  401c60:	aa070087 	orr	x7, x4, x7
  401c64:	9ace20c6 	lsl	x6, x6, x14
  401c68:	8b080064 	add	x4, x3, x8
  401c6c:	4a0f01ab 	eor	w11, w13, w15
  401c70:	d287fde8 	mov	x8, #0x3fef                	// #16367
  401c74:	92401d6e 	and	x14, x11, #0xff
  401c78:	8b080088 	add	x8, x4, x8
  401c7c:	d2800003 	mov	x3, #0x0                   	// #0
  401c80:	f100245f 	cmp	x2, #0x9
  401c84:	54ffe5ad 	b.le	401938 <__divtf3+0xb8>
  401c88:	17ffff4e 	b	4019c0 <__divtf3+0x140>
  401c8c:	aa020025 	orr	x5, x1, x2
  401c90:	b4000805 	cbz	x5, 401d90 <__divtf3+0x510>
  401c94:	b4001342 	cbz	x2, 401efc <__divtf3+0x67c>
  401c98:	dac01040 	clz	x0, x2
  401c9c:	d1003c05 	sub	x5, x0, #0xf
  401ca0:	11000ca7 	add	w7, w5, #0x3
  401ca4:	528007a4 	mov	w4, #0x3d                  	// #61
  401ca8:	4b050084 	sub	w4, w4, w5
  401cac:	9ac72042 	lsl	x2, x2, x7
  401cb0:	9ac42424 	lsr	x4, x1, x4
  401cb4:	aa020085 	orr	x5, x4, x2
  401cb8:	9ac72021 	lsl	x1, x1, x7
  401cbc:	9287fdc8 	mov	x8, #0xffffffffffffc011    	// #-16367
  401cc0:	d2800002 	mov	x2, #0x0                   	// #0
  401cc4:	cb000108 	sub	x8, x8, x0
  401cc8:	d2800010 	mov	x16, #0x0                   	// #0
  401ccc:	52800000 	mov	w0, #0x0                   	// #0
  401cd0:	17ffff05 	b	4018e4 <__divtf3+0x64>
  401cd4:	aa020025 	orr	x5, x1, x2
  401cd8:	b50004e5 	cbnz	x5, 401d74 <__divtf3+0x4f4>
  401cdc:	d2800001 	mov	x1, #0x0                   	// #0
  401ce0:	d2800102 	mov	x2, #0x8                   	// #8
  401ce4:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401ce8:	d2800050 	mov	x16, #0x2                   	// #2
  401cec:	52800000 	mov	w0, #0x0                   	// #0
  401cf0:	17fffefd 	b	4018e4 <__divtf3+0x64>
  401cf4:	928fffc3 	mov	x3, #0xffffffffffff8001    	// #-32767
  401cf8:	8b030108 	add	x8, x8, x3
  401cfc:	aa0700c3 	orr	x3, x6, x7
  401d00:	b4000303 	cbz	x3, 401d60 <__divtf3+0x4e0>
  401d04:	f25100ff 	tst	x7, #0x800000000000
  401d08:	b2400442 	orr	x2, x2, #0x3
  401d0c:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
  401d10:	d2800063 	mov	x3, #0x3                   	// #3
  401d14:	4a0f01ab 	eor	w11, w13, w15
  401d18:	92401d6e 	and	x14, x11, #0xff
  401d1c:	f100245f 	cmp	x2, #0x9
  401d20:	54ffe0cd 	b.le	401938 <__divtf3+0xb8>
  401d24:	f1003c5f 	cmp	x2, #0xf
  401d28:	54ffe4c1 	b.ne	4019c0 <__divtf3+0x140>  // b.any
  401d2c:	b6780ba5 	tbz	x5, #47, 401ea0 <__divtf3+0x620>
  401d30:	b7780b87 	tbnz	x7, #47, 401ea0 <__divtf3+0x620>
  401d34:	b25100e5 	orr	x5, x7, #0x800000000000
  401d38:	2a0f03eb 	mov	w11, w15
  401d3c:	9240bca5 	and	x5, x5, #0xffffffffffff
  401d40:	aa0603e1 	mov	x1, x6
  401d44:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401d48:	17ffff3a 	b	401a30 <__divtf3+0x1b0>
  401d4c:	aa0503e7 	mov	x7, x5
  401d50:	aa0103e6 	mov	x6, x1
  401d54:	aa0a03e9 	mov	x9, x10
  401d58:	aa1003e3 	mov	x3, x16
  401d5c:	17ffff01 	b	401960 <__divtf3+0xe0>
  401d60:	b27f0042 	orr	x2, x2, #0x2
  401d64:	d2800007 	mov	x7, #0x0                   	// #0
  401d68:	d2800006 	mov	x6, #0x0                   	// #0
  401d6c:	d2800043 	mov	x3, #0x2                   	// #2
  401d70:	17ffffe9 	b	401d14 <__divtf3+0x494>
  401d74:	d36ffc40 	lsr	x0, x2, #47
  401d78:	aa0203e5 	mov	x5, x2
  401d7c:	52000000 	eor	w0, w0, #0x1
  401d80:	d2800182 	mov	x2, #0xc                   	// #12
  401d84:	d28fffe8 	mov	x8, #0x7fff                	// #32767
  401d88:	d2800070 	mov	x16, #0x3                   	// #3
  401d8c:	17fffed6 	b	4018e4 <__divtf3+0x64>
  401d90:	d2800001 	mov	x1, #0x0                   	// #0
  401d94:	d2800082 	mov	x2, #0x4                   	// #4
  401d98:	d2800008 	mov	x8, #0x0                   	// #0
  401d9c:	d2800030 	mov	x16, #0x1                   	// #1
  401da0:	52800000 	mov	w0, #0x0                   	// #0
  401da4:	17fffed0 	b	4018e4 <__divtf3+0x64>
  401da8:	4a0f01ab 	eor	w11, w13, w15
  401dac:	b2400042 	orr	x2, x2, #0x1
  401db0:	92401d6e 	and	x14, x11, #0xff
  401db4:	d2800007 	mov	x7, #0x0                   	// #0
  401db8:	d2800006 	mov	x6, #0x0                   	// #0
  401dbc:	d2800023 	mov	x3, #0x1                   	// #1
  401dc0:	f100245f 	cmp	x2, #0x9
  401dc4:	54ffdbad 	b.le	401938 <__divtf3+0xb8>
  401dc8:	17fffefe 	b	4019c0 <__divtf3+0x140>
  401dcc:	d2800021 	mov	x1, #0x1                   	// #1
  401dd0:	cb040024 	sub	x4, x1, x4
  401dd4:	1200012b 	and	w11, w9, #0x1
  401dd8:	f101d09f 	cmp	x4, #0x74
  401ddc:	5400102c 	b.gt	401fe0 <__divtf3+0x760>
  401de0:	f100fc9f 	cmp	x4, #0x3f
  401de4:	5400126d 	b.le	402030 <__divtf3+0x7b0>
  401de8:	52801001 	mov	w1, #0x80                  	// #128
  401dec:	4b040021 	sub	w1, w1, w4
  401df0:	f101009f 	cmp	x4, #0x40
  401df4:	51010084 	sub	w4, w4, #0x40
  401df8:	9ac120e1 	lsl	x1, x7, x1
  401dfc:	aa0100c1 	orr	x1, x6, x1
  401e00:	9a861026 	csel	x6, x1, x6, ne  // ne = any
  401e04:	9ac424e1 	lsr	x1, x7, x4
  401e08:	f10000df 	cmp	x6, #0x0
  401e0c:	9a9f07e2 	cset	x2, ne  // ne = any
  401e10:	aa010041 	orr	x1, x2, x1
  401e14:	f2400825 	ands	x5, x1, #0x7
  401e18:	54001260 	b.eq	402064 <__divtf3+0x7e4>  // b.none
  401e1c:	d2800005 	mov	x5, #0x0                   	// #0
  401e20:	926a058c 	and	x12, x12, #0xc00000
  401e24:	321c0000 	orr	w0, w0, #0x10
  401e28:	f150019f 	cmp	x12, #0x400, lsl #12
  401e2c:	54001800 	b.eq	40212c <__divtf3+0x8ac>  // b.none
  401e30:	f160019f 	cmp	x12, #0x800, lsl #12
  401e34:	54001c80 	b.eq	4021c4 <__divtf3+0x944>  // b.none
  401e38:	b4001b8c 	cbz	x12, 4021a8 <__divtf3+0x928>
  401e3c:	b7981805 	tbnz	x5, #51, 40213c <__divtf3+0x8bc>
  401e40:	321d0000 	orr	w0, w0, #0x8
  401e44:	93c10ca1 	extr	x1, x5, x1, #3
  401e48:	52800004 	mov	w4, #0x0                   	// #0
  401e4c:	d343c8a5 	ubfx	x5, x5, #3, #48
  401e50:	1400004b 	b	401f7c <__divtf3+0x6fc>
  401e54:	1200012b 	and	w11, w9, #0x1
  401e58:	52800004 	mov	w4, #0x0                   	// #0
  401e5c:	d2800005 	mov	x5, #0x0                   	// #0
  401e60:	d2800001 	mov	x1, #0x0                   	// #0
  401e64:	17fffef3 	b	401a30 <__divtf3+0x1b0>
  401e68:	926a0581 	and	x1, x12, #0xc00000
  401e6c:	321c0000 	orr	w0, w0, #0x10
  401e70:	f150003f 	cmp	x1, #0x400, lsl #12
  401e74:	540017c0 	b.eq	40216c <__divtf3+0x8ec>  // b.none
  401e78:	f160003f 	cmp	x1, #0x800, lsl #12
  401e7c:	540010e0 	b.eq	402098 <__divtf3+0x818>  // b.none
  401e80:	b5ffd8a1 	cbnz	x1, 401994 <__divtf3+0x114>
  401e84:	92400cc1 	and	x1, x6, #0xf
  401e88:	1200012b 	and	w11, w9, #0x1
  401e8c:	f100103f 	cmp	x1, #0x4
  401e90:	54ffd840 	b.eq	401998 <__divtf3+0x118>  // b.none
  401e94:	b10010c6 	adds	x6, x6, #0x4
  401e98:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  401e9c:	17fffebf 	b	401998 <__divtf3+0x118>
  401ea0:	b25100a5 	orr	x5, x5, #0x800000000000
  401ea4:	2a0d03eb 	mov	w11, w13
  401ea8:	9240bca5 	and	x5, x5, #0xffffffffffff
  401eac:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401eb0:	17fffee0 	b	401a30 <__divtf3+0x1b0>
  401eb4:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401eb8:	d2800005 	mov	x5, #0x0                   	// #0
  401ebc:	d2800001 	mov	x1, #0x0                   	// #0
  401ec0:	17fffedc 	b	401a30 <__divtf3+0x1b0>
  401ec4:	ab050026 	adds	x6, x1, x5
  401ec8:	d1000627 	sub	x7, x17, #0x1
  401ecc:	9a040042 	adc	x2, x2, x4
  401ed0:	9a9f37f2 	cset	x18, cs  // cs = hs, nlast
  401ed4:	aa0603e1 	mov	x1, x6
  401ed8:	eb02009f 	cmp	x4, x2
  401edc:	540007a2 	b.cs	401fd0 <__divtf3+0x750>  // b.hs, b.nlast
  401ee0:	eb02007f 	cmp	x3, x2
  401ee4:	54000969 	b.ls	402010 <__divtf3+0x790>  // b.plast
  401ee8:	ab0600a6 	adds	x6, x5, x6
  401eec:	d1000a27 	sub	x7, x17, #0x2
  401ef0:	aa0603e1 	mov	x1, x6
  401ef4:	9a040042 	adc	x2, x2, x4
  401ef8:	17ffff12 	b	401b40 <__divtf3+0x2c0>
  401efc:	dac01020 	clz	x0, x1
  401f00:	9100c405 	add	x5, x0, #0x31
  401f04:	91010000 	add	x0, x0, #0x40
  401f08:	f100f0bf 	cmp	x5, #0x3c
  401f0c:	54ffecad 	b.le	401ca0 <__divtf3+0x420>
  401f10:	5100f4a5 	sub	w5, w5, #0x3d
  401f14:	9ac52025 	lsl	x5, x1, x5
  401f18:	d2800001 	mov	x1, #0x0                   	// #0
  401f1c:	17ffff68 	b	401cbc <__divtf3+0x43c>
  401f20:	dac010c3 	clz	x3, x6
  401f24:	9100c464 	add	x4, x3, #0x31
  401f28:	91010063 	add	x3, x3, #0x40
  401f2c:	f100f09f 	cmp	x4, #0x3c
  401f30:	54ffe8ed 	b.le	401c4c <__divtf3+0x3cc>
  401f34:	5100f484 	sub	w4, w4, #0x3d
  401f38:	9ac420c4 	lsl	x4, x6, x4
  401f3c:	d2800006 	mov	x6, #0x0                   	// #0
  401f40:	aa0403e7 	mov	x7, x4
  401f44:	17ffff49 	b	401c68 <__divtf3+0x3e8>
  401f48:	926a0581 	and	x1, x12, #0xc00000
  401f4c:	f150003f 	cmp	x1, #0x400, lsl #12
  401f50:	54001000 	b.eq	402150 <__divtf3+0x8d0>  // b.none
  401f54:	f160003f 	cmp	x1, #0x800, lsl #12
  401f58:	54000920 	b.eq	40207c <__divtf3+0x7fc>  // b.none
  401f5c:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401f60:	d2800005 	mov	x5, #0x0                   	// #0
  401f64:	b4000081 	cbz	x1, 401f74 <__divtf3+0x6f4>
  401f68:	2a0203e4 	mov	w4, w2
  401f6c:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  401f70:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  401f74:	52800282 	mov	w2, #0x14                  	// #20
  401f78:	2a020000 	orr	w0, w0, w2
  401f7c:	d2800003 	mov	x3, #0x0                   	// #0
  401f80:	2a0b3c84 	orr	w4, w4, w11, lsl #15
  401f84:	b340bca3 	bfxil	x3, x5, #0, #48
  401f88:	9e670020 	fmov	d0, x1
  401f8c:	b3503c83 	bfi	x3, x4, #48, #16
  401f90:	9eaf0060 	fmov	v0.d[1], x3
  401f94:	3d8007e0 	str	q0, [sp, #16]
  401f98:	940000ba 	bl	402280 <__sfp_handle_exceptions>
  401f9c:	3dc007e0 	ldr	q0, [sp, #16]
  401fa0:	17fffe9d 	b	401a14 <__divtf3+0x194>
  401fa4:	b25100e5 	orr	x5, x7, #0x800000000000
  401fa8:	1200012b 	and	w11, w9, #0x1
  401fac:	9240bca5 	and	x5, x5, #0xffffffffffff
  401fb0:	aa0603e1 	mov	x1, x6
  401fb4:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401fb8:	17fffe9e 	b	401a30 <__divtf3+0x1b0>
  401fbc:	1200012b 	and	w11, w9, #0x1
  401fc0:	528fffe4 	mov	w4, #0x7fff                	// #32767
  401fc4:	d2800005 	mov	x5, #0x0                   	// #0
  401fc8:	d2800001 	mov	x1, #0x0                   	// #0
  401fcc:	17fffe99 	b	401a30 <__divtf3+0x1b0>
  401fd0:	f100025f 	cmp	x18, #0x0
  401fd4:	fa420080 	ccmp	x4, x2, #0x0, eq  // eq = none
  401fd8:	54ffdb41 	b.ne	401b40 <__divtf3+0x2c0>  // b.any
  401fdc:	17ffffc1 	b	401ee0 <__divtf3+0x660>
  401fe0:	aa0700c1 	orr	x1, x6, x7
  401fe4:	b5000861 	cbnz	x1, 4020f0 <__divtf3+0x870>
  401fe8:	321d0000 	orr	w0, w0, #0x8
  401fec:	52800004 	mov	w4, #0x0                   	// #0
  401ff0:	d2800005 	mov	x5, #0x0                   	// #0
  401ff4:	17ffffe2 	b	401f7c <__divtf3+0x6fc>
  401ff8:	f100007f 	cmp	x3, #0x0
  401ffc:	1a9f07e9 	cset	w9, ne  // ne = any
  402000:	7100013f 	cmp	w9, #0x0
  402004:	fa421020 	ccmp	x1, x2, #0x0, ne  // ne = any
  402008:	54ffe0c1 	b.ne	401c20 <__divtf3+0x3a0>  // b.any
  40200c:	17fffefa 	b	401bf4 <__divtf3+0x374>
  402010:	fa460200 	ccmp	x16, x6, #0x0, eq  // eq = none
  402014:	54ffd969 	b.ls	401b40 <__divtf3+0x2c0>  // b.plast
  402018:	17ffffb4 	b	401ee8 <__divtf3+0x668>
  40201c:	aa0103e2 	mov	x2, x1
  402020:	d1000508 	sub	x8, x8, #0x1
  402024:	aa0503e3 	mov	x3, x5
  402028:	d2800001 	mov	x1, #0x0                   	// #0
  40202c:	17fffe93 	b	401a78 <__divtf3+0x1f8>
  402030:	52800801 	mov	w1, #0x40                  	// #64
  402034:	4b040021 	sub	w1, w1, w4
  402038:	9ac424c3 	lsr	x3, x6, x4
  40203c:	9ac120c6 	lsl	x6, x6, x1
  402040:	f10000df 	cmp	x6, #0x0
  402044:	9a9f07e2 	cset	x2, ne  // ne = any
  402048:	9ac120e1 	lsl	x1, x7, x1
  40204c:	aa030021 	orr	x1, x1, x3
  402050:	9ac424e5 	lsr	x5, x7, x4
  402054:	aa020021 	orr	x1, x1, x2
  402058:	f240083f 	tst	x1, #0x7
  40205c:	54ffee21 	b.ne	401e20 <__divtf3+0x5a0>  // b.any
  402060:	b7980b85 	tbnz	x5, #51, 4021d0 <__divtf3+0x950>
  402064:	52800004 	mov	w4, #0x0                   	// #0
  402068:	93c10ca1 	extr	x1, x5, x1, #3
  40206c:	d343c8a5 	ubfx	x5, x5, #3, #48
  402070:	365fce0c 	tbz	w12, #11, 401a30 <__divtf3+0x1b0>
  402074:	321d0000 	orr	w0, w0, #0x8
  402078:	17ffffc1 	b	401f7c <__divtf3+0x6fc>
  40207c:	f100013f 	cmp	x9, #0x0
  402080:	528fffe1 	mov	w1, #0x7fff                	// #32767
  402084:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  402088:	1a810044 	csel	w4, w2, w1, eq  // eq = none
  40208c:	9a9f00a5 	csel	x5, x5, xzr, eq  // eq = none
  402090:	da9f13e1 	csetm	x1, eq  // eq = none
  402094:	17ffffb8 	b	401f74 <__divtf3+0x6f4>
  402098:	5280000b 	mov	w11, #0x0                   	// #0
  40209c:	b4ffc7e9 	cbz	x9, 401998 <__divtf3+0x118>
  4020a0:	b10020c6 	adds	x6, x6, #0x8
  4020a4:	5280002b 	mov	w11, #0x1                   	// #1
  4020a8:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  4020ac:	17fffe3b 	b	401998 <__divtf3+0x118>
  4020b0:	d10008c6 	sub	x6, x6, #0x2
  4020b4:	8b040042 	add	x2, x2, x4
  4020b8:	17fffe8b 	b	401ae4 <__divtf3+0x264>
  4020bc:	d10008e7 	sub	x7, x7, #0x2
  4020c0:	8b040063 	add	x3, x3, x4
  4020c4:	17fffe7c 	b	401ab4 <__divtf3+0x234>
  4020c8:	d287ffe2 	mov	x2, #0x3fff                	// #16383
  4020cc:	8b020104 	add	x4, x8, x2
  4020d0:	aa0e03e9 	mov	x9, x14
  4020d4:	92800006 	mov	x6, #0xffffffffffffffff    	// #-1
  4020d8:	f100009f 	cmp	x4, #0x0
  4020dc:	54ffec6c 	b.gt	401e68 <__divtf3+0x5e8>
  4020e0:	d2800021 	mov	x1, #0x1                   	// #1
  4020e4:	cb040024 	sub	x4, x1, x4
  4020e8:	f101d09f 	cmp	x4, #0x74
  4020ec:	54ffe7ad 	b.le	401de0 <__divtf3+0x560>
  4020f0:	926a058c 	and	x12, x12, #0xc00000
  4020f4:	321c0000 	orr	w0, w0, #0x10
  4020f8:	f150019f 	cmp	x12, #0x400, lsl #12
  4020fc:	54000500 	b.eq	40219c <__divtf3+0x91c>  // b.none
  402100:	f160019f 	cmp	x12, #0x800, lsl #12
  402104:	9a9f0121 	csel	x1, x9, xzr, eq  // eq = none
  402108:	17ffffb8 	b	401fe8 <__divtf3+0x768>
  40210c:	d37ff8aa 	lsl	x10, x5, #1
  402110:	d10008c6 	sub	x6, x6, #0x2
  402114:	eb0a00bf 	cmp	x5, x10
  402118:	9a849481 	cinc	x1, x4, hi  // hi = pmore
  40211c:	eb0a007f 	cmp	x3, x10
  402120:	8b010121 	add	x1, x9, x1
  402124:	1a9f07e9 	cset	w9, ne  // ne = any
  402128:	17fffebe 	b	401c20 <__divtf3+0x3a0>
  40212c:	b5000069 	cbnz	x9, 402138 <__divtf3+0x8b8>
  402130:	b1002021 	adds	x1, x1, #0x8
  402134:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  402138:	b69fe845 	tbz	x5, #51, 401e40 <__divtf3+0x5c0>
  40213c:	321d0000 	orr	w0, w0, #0x8
  402140:	52800024 	mov	w4, #0x1                   	// #1
  402144:	d2800005 	mov	x5, #0x0                   	// #0
  402148:	d2800001 	mov	x1, #0x0                   	// #0
  40214c:	17ffff8c 	b	401f7c <__divtf3+0x6fc>
  402150:	f100013f 	cmp	x9, #0x0
  402154:	528fffe1 	mov	w1, #0x7fff                	// #32767
  402158:	92ffffe5 	mov	x5, #0xffffffffffff        	// #281474976710655
  40215c:	1a811044 	csel	w4, w2, w1, ne  // ne = any
  402160:	9a9f10a5 	csel	x5, x5, xzr, ne  // ne = any
  402164:	da9f03e1 	csetm	x1, ne  // ne = any
  402168:	17ffff83 	b	401f74 <__divtf3+0x6f4>
  40216c:	5280002b 	mov	w11, #0x1                   	// #1
  402170:	b5ffc149 	cbnz	x9, 401998 <__divtf3+0x118>
  402174:	b10020c6 	adds	x6, x6, #0x8
  402178:	5280000b 	mov	w11, #0x0                   	// #0
  40217c:	9a8734e7 	cinc	x7, x7, cs  // cs = hs, nlast
  402180:	17fffe06 	b	401998 <__divtf3+0x118>
  402184:	d1000863 	sub	x3, x3, #0x2
  402188:	8b040021 	add	x1, x1, x4
  40218c:	17fffe88 	b	401bac <__divtf3+0x32c>
  402190:	d10008c6 	sub	x6, x6, #0x2
  402194:	8b040042 	add	x2, x2, x4
  402198:	17fffe79 	b	401b7c <__divtf3+0x2fc>
  40219c:	d2800021 	mov	x1, #0x1                   	// #1
  4021a0:	cb090021 	sub	x1, x1, x9
  4021a4:	17ffff91 	b	401fe8 <__divtf3+0x768>
  4021a8:	92400c22 	and	x2, x1, #0xf
  4021ac:	f100105f 	cmp	x2, #0x4
  4021b0:	54fffc40 	b.eq	402138 <__divtf3+0x8b8>  // b.none
  4021b4:	b1001021 	adds	x1, x1, #0x4
  4021b8:	9a8534a5 	cinc	x5, x5, cs  // cs = hs, nlast
  4021bc:	b79ffc05 	tbnz	x5, #51, 40213c <__divtf3+0x8bc>
  4021c0:	17ffff20 	b	401e40 <__divtf3+0x5c0>
  4021c4:	b5fffb69 	cbnz	x9, 402130 <__divtf3+0x8b0>
  4021c8:	b79ffba5 	tbnz	x5, #51, 40213c <__divtf3+0x8bc>
  4021cc:	17ffff1d 	b	401e40 <__divtf3+0x5c0>
  4021d0:	321c0000 	orr	w0, w0, #0x10
  4021d4:	17ffffda 	b	40213c <__divtf3+0x8bc>
  4021d8:	d503201f 	nop
  4021dc:	d503201f 	nop

00000000004021e0 <__floatunditf>:
  4021e0:	b40002a0 	cbz	x0, 402234 <__floatunditf+0x54>
  4021e4:	dac01001 	clz	x1, x0
  4021e8:	528807c2 	mov	w2, #0x403e                	// #16446
  4021ec:	4b010042 	sub	w2, w2, w1
  4021f0:	d2880de3 	mov	x3, #0x406f                	// #16495
  4021f4:	12003844 	and	w4, w2, #0x7fff
  4021f8:	cb22c062 	sub	x2, x3, w2, sxtw
  4021fc:	f100fc5f 	cmp	x2, #0x3f
  402200:	540002ac 	b.gt	402254 <__floatunditf+0x74>
  402204:	1100c423 	add	w3, w1, #0x31
  402208:	528001e2 	mov	w2, #0xf                   	// #15
  40220c:	4b010041 	sub	w1, w2, w1
  402210:	9ac12401 	lsr	x1, x0, x1
  402214:	9240bc21 	and	x1, x1, #0xffffffffffff
  402218:	9ac32000 	lsl	x0, x0, x3
  40221c:	d2800003 	mov	x3, #0x0                   	// #0
  402220:	b340bc23 	bfxil	x3, x1, #0, #48
  402224:	9e670000 	fmov	d0, x0
  402228:	b3503c83 	bfi	x3, x4, #48, #16
  40222c:	9eaf0060 	fmov	v0.d[1], x3
  402230:	d65f03c0 	ret
  402234:	d2800001 	mov	x1, #0x0                   	// #0
  402238:	d2800003 	mov	x3, #0x0                   	// #0
  40223c:	b340bc23 	bfxil	x3, x1, #0, #48
  402240:	9e670000 	fmov	d0, x0
  402244:	52800004 	mov	w4, #0x0                   	// #0
  402248:	b3503c83 	bfi	x3, x4, #48, #16
  40224c:	9eaf0060 	fmov	v0.d[1], x3
  402250:	d65f03c0 	ret
  402254:	51003c21 	sub	w1, w1, #0xf
  402258:	d2800003 	mov	x3, #0x0                   	// #0
  40225c:	9ac12001 	lsl	x1, x0, x1
  402260:	9240bc21 	and	x1, x1, #0xffffffffffff
  402264:	d2800000 	mov	x0, #0x0                   	// #0
  402268:	9e670000 	fmov	d0, x0
  40226c:	b340bc23 	bfxil	x3, x1, #0, #48
  402270:	b3503c83 	bfi	x3, x4, #48, #16
  402274:	9eaf0060 	fmov	v0.d[1], x3
  402278:	d65f03c0 	ret
  40227c:	d503201f 	nop

0000000000402280 <__sfp_handle_exceptions>:
  402280:	36000080 	tbz	w0, #0, 402290 <__sfp_handle_exceptions+0x10>
  402284:	0f000401 	movi	v1.2s, #0x0
  402288:	1e211820 	fdiv	s0, s1, s1
  40228c:	d53b4421 	mrs	x1, fpsr
  402290:	360800a0 	tbz	w0, #1, 4022a4 <__sfp_handle_exceptions+0x24>
  402294:	1e2e1001 	fmov	s1, #1.000000000000000000e+00
  402298:	0f000402 	movi	v2.2s, #0x0
  40229c:	1e221820 	fdiv	s0, s1, s2
  4022a0:	d53b4421 	mrs	x1, fpsr
  4022a4:	36100100 	tbz	w0, #2, 4022c4 <__sfp_handle_exceptions+0x44>
  4022a8:	5298b5c2 	mov	w2, #0xc5ae                	// #50606
  4022ac:	12b01001 	mov	w1, #0x7f7fffff            	// #2139095039
  4022b0:	72ae93a2 	movk	w2, #0x749d, lsl #16
  4022b4:	1e270021 	fmov	s1, w1
  4022b8:	1e270042 	fmov	s2, w2
  4022bc:	1e222820 	fadd	s0, s1, s2
  4022c0:	d53b4421 	mrs	x1, fpsr
  4022c4:	36180080 	tbz	w0, #3, 4022d4 <__sfp_handle_exceptions+0x54>
  4022c8:	0f044401 	movi	v1.2s, #0x80, lsl #16
  4022cc:	1e210820 	fmul	s0, s1, s1
  4022d0:	d53b4421 	mrs	x1, fpsr
  4022d4:	362000c0 	tbz	w0, #4, 4022ec <__sfp_handle_exceptions+0x6c>
  4022d8:	12b01000 	mov	w0, #0x7f7fffff            	// #2139095039
  4022dc:	1e2e1002 	fmov	s2, #1.000000000000000000e+00
  4022e0:	1e270001 	fmov	s1, w0
  4022e4:	1e223820 	fsub	s0, s1, s2
  4022e8:	d53b4420 	mrs	x0, fpsr
  4022ec:	d65f03c0 	ret

00000000004022f0 <call_weak_fn>:
  4022f0:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4022f4:	f9475800 	ldr	x0, [x0, #3760]
  4022f8:	b4000040 	cbz	x0, 402300 <call_weak_fn+0x10>
  4022fc:	17fffc91 	b	401540 <__gmon_start__@plt>
  402300:	d65f03c0 	ret

0000000000402304 <_OffsetAbsSyms>:
#include <zephyr/kernel.h>
#include <kernel_arch_data.h>
#include <gen_offset.h>
#include <kernel_offsets.h>

GEN_ABS_SYM_END
  402304:	d65f03c0 	ret

0000000000402308 <k_timer_stop>:
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_TIMER_STOP);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_stop(timer);
  402308:	140054f9 	b	4176ec <z_impl_k_timer_stop>

000000000040230c <send_can_tx_callback>:
        receive_can_rx(rctx, frame);
    }
}

static void send_can_tx_callback(const struct device *dev, int error, void *arg)
{
  40230c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402310:	910003fd 	mov	x29, sp
    struct isotp_fast_send_ctx *sctx = arg;

    ARG_UNUSED(dev);

    sctx->backlog--;
  402314:	39434c40 	ldrb	w0, [x2, #211]
{
  402318:	f9000bf3 	str	x19, [sp, #16]
  40231c:	aa0203f3 	mov	x19, x2
    sctx->backlog--;
  402320:	51000400 	sub	w0, w0, #0x1
  402324:	39034c40 	strb	w0, [x2, #211]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
  402328:	91024040 	add	x0, x2, #0x90
  40232c:	94004473 	bl	4134f8 <z_impl_k_sem_give>
    k_sem_give(&sctx->sem);

    if (sctx->state == ISOTP_TX_WAIT_BACKLOG) {
  402330:	f9406260 	ldr	x0, [x19, #192]
  402334:	530c4c00 	ubfx	w0, w0, #12, #8
  402338:	7100181f 	cmp	w0, #0x6
  40233c:	54000181 	b.ne	40236c <send_can_tx_callback+0x60>  // b.any
        if (sctx->backlog > 0) {
  402340:	39434e60 	ldrb	w0, [x19, #211]
  402344:	350001c0 	cbnz	w0, 40237c <send_can_tx_callback+0x70>
            return;
        }

        sctx->state = ISOTP_TX_WAIT_FIN;
  402348:	79418260 	ldrh	w0, [x19, #192]
  40234c:	91030261 	add	x1, x19, #0xc0
  402350:	12002c00 	and	w0, w0, #0xfff
  402354:	32140800 	orr	w0, w0, #0x7000
  402358:	79018260 	strh	w0, [x19, #192]
  40235c:	aa0103e0 	mov	x0, x1
  402360:	39400821 	ldrb	w1, [x1, #2]
  402364:	121c6c21 	and	w1, w1, #0xfffffff0
  402368:	39000801 	strb	w1, [x0, #2]
    }

    k_work_submit(&sctx->work);
  40236c:	91006260 	add	x0, x19, #0x18
}
  402370:	f9400bf3 	ldr	x19, [sp, #16]
  402374:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&sctx->work);
  402378:	14004749 	b	41409c <k_work_submit>
}
  40237c:	f9400bf3 	ldr	x19, [sp, #16]
  402380:	a8c27bfd 	ldp	x29, x30, [sp], #32
  402384:	d65f03c0 	ret

0000000000402388 <can_bytes_to_dlc>:
	       num_bytes <= 20 ? 11 :
	       num_bytes <= 24 ? 12 :
	       num_bytes <= 32 ? 13 :
	       num_bytes <= 48 ? 14 :
	       15;
}
  402388:	d65f03c0 	ret

000000000040238c <z_log_msg_runtime_create.constprop.0>:
 *
 * @param fmt String.
 *
 * @param ... String arguments.
 */
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40238c:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  402390:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  402394:	12001c42 	and	w2, w2, #0xff
  402398:	910003fd 	mov	x29, sp
  40239c:	f9475c00 	ldr	x0, [x0, #3768]
  4023a0:	3d8023e0 	str	q0, [sp, #128]
  4023a4:	3d8027e1 	str	q1, [sp, #144]
  4023a8:	3d802be2 	str	q2, [sp, #160]
  4023ac:	3d802fe3 	str	q3, [sp, #176]
  4023b0:	3d8033e4 	str	q4, [sp, #192]
  4023b4:	3d8037e5 	str	q5, [sp, #208]
  4023b8:	3d803be6 	str	q6, [sp, #224]
  4023bc:	3d803fe7 	str	q7, [sp, #240]
  4023c0:	f90087e7 	str	x7, [sp, #264]
  4023c4:	f9400003 	ldr	x3, [x0]
  4023c8:	f9003fe3 	str	x3, [sp, #120]
  4023cc:	d2800003 	mov	x3, #0x0                   	// #0
					     size_t dlen, uint32_t package_flags,
					     const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
  4023d0:	910443e0 	add	x0, sp, #0x110
  4023d4:	a90383e0 	stp	x0, x0, [sp, #56]
  4023d8:	910403e0 	add	x0, sp, #0x100
  4023dc:	9100e3e3 	add	x3, sp, #0x38
  4023e0:	f90027e0 	str	x0, [sp, #72]
  4023e4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  4023e8:	b90053e0 	str	w0, [sp, #80]
  4023ec:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  4023f0:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  4023f4:	910163e0 	add	x0, sp, #0x58
  4023f8:	ad400460 	ldp	q0, q1, [x3]
  4023fc:	ad000400 	stp	q0, q1, [x0]
		va_end(parm7.val);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_runtime_vcreate(domain_id, source, level, data, dlen, package_flags, fmt, ap);
  402400:	ad400400 	ldp	q0, q1, [x0]
  402404:	910043e7 	add	x7, sp, #0x10
  402408:	52800000 	mov	w0, #0x0                   	// #0
  40240c:	52800005 	mov	w5, #0x0                   	// #0
  402410:	d2800004 	mov	x4, #0x0                   	// #0
  402414:	d2800003 	mov	x3, #0x0                   	// #0
  402418:	ad0004e0 	stp	q0, q1, [x7]
  40241c:	94001463 	bl	4075a8 <z_impl_z_log_msg_runtime_vcreate>
				   data, dlen, package_flags, fmt, ap);
	va_end(ap);
}
  402420:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  402424:	f9475c00 	ldr	x0, [x0, #3768]
  402428:	f9403fe2 	ldr	x2, [sp, #120]
  40242c:	f9400001 	ldr	x1, [x0]
  402430:	eb010042 	subs	x2, x2, x1
  402434:	d2800001 	mov	x1, #0x0                   	// #0
  402438:	54000040 	b.eq	402440 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40243c:	97fffc39 	bl	401520 <__stack_chk_fail@plt>
  402440:	a8d17bfd 	ldp	x29, x30, [sp], #272
  402444:	d65f03c0 	ret

0000000000402448 <send_timeout_handler>:

    send_state_machine(sctx);
}

static void send_timeout_handler(struct k_timer *timer)
{
  402448:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40244c:	910003fd 	mov	x29, sp
  402450:	f9000bf3 	str	x19, [sp, #16]
  402454:	aa0003f3 	mov	x19, x0
    struct isotp_fast_send_ctx *sctx = CONTAINER_OF(timer, struct isotp_fast_send_ctx, timer);

    if (sctx->state != ISOTP_TX_SEND_CF) {
  402458:	f9404400 	ldr	x0, [x0, #136]
  40245c:	530c4c00 	ubfx	w0, w0, #12, #8
  402460:	7100101f 	cmp	w0, #0x4
  402464:	54000240 	b.eq	4024ac <send_timeout_handler+0x64>  // b.none
        LOG_ERR("Timed out waiting for FC frame");
  402468:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40246c:	52800000 	mov	w0, #0x0                   	// #0
  402470:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  402474:	52800005 	mov	w5, #0x0                   	// #0
  402478:	f9478421 	ldr	x1, [x1, #3848]
  40247c:	913c24c6 	add	x6, x6, #0xf09
  402480:	d2800004 	mov	x4, #0x0                   	// #0
  402484:	d2800003 	mov	x3, #0x0                   	// #0
  402488:	52800022 	mov	w2, #0x1                   	// #1
  40248c:	97ffffc0 	bl	40238c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  402490:	b9408a61 	ldr	w1, [x19, #136]
  402494:	52900000 	mov	w0, #0x8000                	// #32768
  402498:	72bfc000 	movk	w0, #0xfe00, lsl #16
  40249c:	12005c21 	and	w1, w1, #0xffffff
  4024a0:	120c5c21 	and	w1, w1, #0xfff00fff
  4024a4:	2a000021 	orr	w1, w1, w0
  4024a8:	b9008a61 	str	w1, [x19, #136]
        send_report_error(sctx, ISOTP_N_TIMEOUT_BS);
    }

    k_work_submit(&sctx->work);
  4024ac:	d1008260 	sub	x0, x19, #0x20
}
  4024b0:	f9400bf3 	ldr	x19, [sp, #16]
  4024b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&sctx->work);
  4024b8:	140046f9 	b	41409c <k_work_submit>

00000000004024bc <receive_can_tx>:
    if (error != 0) {
  4024bc:	34000361 	cbz	w1, 402528 <receive_can_tx+0x6c>
{
  4024c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4024c4:	2a0103e7 	mov	w7, w1
        LOG_ERR("Error sending FC frame (%d)", error);
  4024c8:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
{
  4024cc:	910003fd 	mov	x29, sp
        LOG_ERR("Error sending FC frame (%d)", error);
  4024d0:	f9478421 	ldr	x1, [x1, #3848]
{
  4024d4:	f9000bf3 	str	x19, [sp, #16]
  4024d8:	aa0203f3 	mov	x19, x2
        LOG_ERR("Error sending FC frame (%d)", error);
  4024dc:	52800005 	mov	w5, #0x0                   	// #0
  4024e0:	d2800004 	mov	x4, #0x0                   	// #0
  4024e4:	d2800003 	mov	x3, #0x0                   	// #0
  4024e8:	52800000 	mov	w0, #0x0                   	// #0
  4024ec:	52800022 	mov	w2, #0x1                   	// #1
  4024f0:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  4024f4:	913ca0c6 	add	x6, x6, #0xf28
  4024f8:	97ffffa5 	bl	40238c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  4024fc:	b940a261 	ldr	w1, [x19, #160]
  402500:	528e0000 	mov	w0, #0x7000                	// #28672
  402504:	72bee000 	movk	w0, #0xf700, lsl #16
  402508:	12005c21 	and	w1, w1, #0xffffff
  40250c:	120c5c21 	and	w1, w1, #0xfff00fff
  402510:	2a000021 	orr	w1, w1, w0
  402514:	b900a261 	str	w1, [x19, #160]
        k_work_submit(&rctx->work);
  402518:	91006260 	add	x0, x19, #0x18
}
  40251c:	f9400bf3 	ldr	x19, [sp, #16]
  402520:	a8c27bfd 	ldp	x29, x30, [sp], #32
        k_work_submit(&rctx->work);
  402524:	140046de 	b	41409c <k_work_submit>
  402528:	d65f03c0 	ret

000000000040252c <receive_timeout_handler>:
{
  40252c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402530:	910003fd 	mov	x29, sp
  402534:	f9000bf3 	str	x19, [sp, #16]
  402538:	aa0003f3 	mov	x19, x0
    switch (rctx->state) {
  40253c:	f9403400 	ldr	x0, [x0, #104]
  402540:	530c4c00 	ubfx	w0, w0, #12, #8
  402544:	71000c1f 	cmp	w0, #0x3
  402548:	54000300 	b.eq	4025a8 <receive_timeout_handler+0x7c>  // b.none
  40254c:	7100141f 	cmp	w0, #0x5
  402550:	54000241 	b.ne	402598 <receive_timeout_handler+0x6c>  // b.any
            LOG_ERR("Timeout while waiting for CF");
  402554:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402558:	52800000 	mov	w0, #0x0                   	// #0
  40255c:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  402560:	52800005 	mov	w5, #0x0                   	// #0
  402564:	f9478421 	ldr	x1, [x1, #3848]
  402568:	913d10c6 	add	x6, x6, #0xf44
  40256c:	d2800004 	mov	x4, #0x0                   	// #0
  402570:	d2800003 	mov	x3, #0x0                   	// #0
  402574:	52800022 	mov	w2, #0x1                   	// #1
  402578:	97ffff85 	bl	40238c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  40257c:	b9406a60 	ldr	w0, [x19, #104]
  402580:	528e0001 	mov	w1, #0x7000                	// #28672
  402584:	72bfa001 	movk	w1, #0xfd00, lsl #16
  402588:	12005c00 	and	w0, w0, #0xffffff
  40258c:	120c5c00 	and	w0, w0, #0xfff00fff
  402590:	2a010000 	orr	w0, w0, w1
  402594:	b9006a60 	str	w0, [x19, #104]
    k_work_submit(&rctx->work);
  402598:	d1008260 	sub	x0, x19, #0x20
}
  40259c:	f9400bf3 	ldr	x19, [sp, #16]
  4025a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_work_submit(&rctx->work);
  4025a4:	140046be 	b	41409c <k_work_submit>
            rctx->state = ISOTP_RX_STATE_SEND_WAIT;
  4025a8:	7940d260 	ldrh	w0, [x19, #104]
  4025ac:	9101a261 	add	x1, x19, #0x68
  4025b0:	12002c00 	and	w0, w0, #0xfff
  4025b4:	32130400 	orr	w0, w0, #0x6000
  4025b8:	7900d260 	strh	w0, [x19, #104]
  4025bc:	aa0103e0 	mov	x0, x1
  4025c0:	39400821 	ldrb	w1, [x1, #2]
  4025c4:	121c6c21 	and	w1, w1, #0xfffffff0
  4025c8:	39000801 	strb	w1, [x0, #2]
            break;
  4025cc:	17fffff3 	b	402598 <receive_timeout_handler+0x6c>

00000000004025d0 <sys_slist_find_and_remove.isra.0>:
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  4025d0:	f9400002 	ldr	x2, [x0]
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  4025d4:	d2800003 	mov	x3, #0x0                   	// #0
  4025d8:	b4000162 	cbz	x2, 402604 <sys_slist_find_and_remove.isra.0+0x34>
  4025dc:	eb01005f 	cmp	x2, x1
  4025e0:	54000201 	b.ne	402620 <sys_slist_find_and_remove.isra.0+0x50>  // b.any
	return node->next;
  4025e4:	f9400022 	ldr	x2, [x1]
Z_GENLIST_REMOVE(slist, snode)
  4025e8:	b5000103 	cbnz	x3, 402608 <sys_slist_find_and_remove.isra.0+0x38>
  4025ec:	f9400403 	ldr	x3, [x0, #8]
	list->head = node;
  4025f0:	f9000002 	str	x2, [x0]
Z_GENLIST_REMOVE(slist, snode)
  4025f4:	eb03003f 	cmp	x1, x3
  4025f8:	54000041 	b.ne	402600 <sys_slist_find_and_remove.isra.0+0x30>  // b.any
	list->tail = node;
  4025fc:	f9000402 	str	x2, [x0, #8]
	parent->next = child;
  402600:	f900003f 	str	xzr, [x1]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  402604:	d65f03c0 	ret
	parent->next = child;
  402608:	f9000062 	str	x2, [x3]
Z_GENLIST_REMOVE(slist, snode)
  40260c:	f9400402 	ldr	x2, [x0, #8]
  402610:	eb02003f 	cmp	x1, x2
  402614:	54ffff61 	b.ne	402600 <sys_slist_find_and_remove.isra.0+0x30>  // b.any
	list->tail = node;
  402618:	f9000403 	str	x3, [x0, #8]
}
  40261c:	17fffff9 	b	402600 <sys_slist_find_and_remove.isra.0+0x30>
	return node->next;
  402620:	aa0203e3 	mov	x3, x2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
  402624:	f9400042 	ldr	x2, [x2]
  402628:	17ffffec 	b	4025d8 <sys_slist_find_and_remove.isra.0+0x8>

000000000040262c <free_send_ctx>:
{
  40262c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402630:	910003fd 	mov	x29, sp
  402634:	f9000bf3 	str	x19, [sp, #16]
  402638:	aa0003f3 	mov	x19, x0
    k_timer_stop(&(*ctx)->timer);
  40263c:	f9400000 	ldr	x0, [x0]
  402640:	9100e000 	add	x0, x0, #0x38
  402644:	97ffff31 	bl	402308 <k_timer_stop>
    sys_slist_find_and_remove(&isotp_send_ctx_list, &(*ctx)->node);
  402648:	f9400261 	ldr	x1, [x19]
  40264c:	b0000180 	adrp	x0, 433000 <obj_0x28+0x18>
  402650:	9102e000 	add	x0, x0, #0xb8
  402654:	97ffffdf 	bl	4025d0 <sys_slist_find_and_remove.isra.0>
    k_mem_slab_free(&isotp_send_ctx_slab, (void **)ctx);
  402658:	aa1303e1 	mov	x1, x19
  40265c:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
}
  402660:	f9400bf3 	ldr	x19, [sp, #16]
  402664:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_send_ctx_slab, (void **)ctx);
  402668:	f947f400 	ldr	x0, [x0, #4072]
  40266c:	14003e39 	b	411f50 <k_mem_slab_free>

0000000000402670 <free_recv_ctx>:
{
  402670:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  402674:	910003fd 	mov	x29, sp
  402678:	f9000bf3 	str	x19, [sp, #16]
  40267c:	aa0003f3 	mov	x19, x0
    k_timer_stop(&(*rctx)->timer);
  402680:	f9400000 	ldr	x0, [x0]
  402684:	9100e000 	add	x0, x0, #0x38
  402688:	97ffff20 	bl	402308 <k_timer_stop>
    sys_slist_find_and_remove(&isotp_recv_ctx_list, &(*rctx)->node);
  40268c:	f9400261 	ldr	x1, [x19]
  402690:	b0000180 	adrp	x0, 433000 <obj_0x28+0x18>
  402694:	9102a000 	add	x0, x0, #0xa8
  402698:	97ffffce 	bl	4025d0 <sys_slist_find_and_remove.isra.0>
    net_buf_unref((*rctx)->buffer);
  40269c:	f9400260 	ldr	x0, [x19]
  4026a0:	f9404800 	ldr	x0, [x0, #144]
  4026a4:	94002492 	bl	40b8ec <net_buf_unref>
    k_mem_slab_free(&isotp_recv_ctx_slab, (void **)rctx);
  4026a8:	aa1303e1 	mov	x1, x19
  4026ac:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
}
  4026b0:	f9400bf3 	ldr	x19, [sp, #16]
  4026b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    k_mem_slab_free(&isotp_recv_ctx_slab, (void **)rctx);
  4026b8:	f947b000 	ldr	x0, [x0, #3936]
  4026bc:	14003e25 	b	411f50 <k_mem_slab_free>

00000000004026c0 <get_send_ctx>:
{
  4026c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4026c4:	910003fd 	mov	x29, sp
  4026c8:	f9001bf7 	str	x23, [sp, #48]
  4026cc:	aa0003f7 	mov	x23, x0
  4026d0:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4026d4:	a9025bf5 	stp	x21, x22, [sp, #32]
	return list->head;
  4026d8:	b0000196 	adrp	x22, 433000 <obj_0x28+0x18>
  4026dc:	f9475c00 	ldr	x0, [x0, #3768]
  4026e0:	a90153f3 	stp	x19, x20, [sp, #16]
  4026e4:	2a0103f4 	mov	w20, w1
  4026e8:	f9405ec3 	ldr	x3, [x22, #184]
  4026ec:	f9400001 	ldr	x1, [x0]
  4026f0:	f90027e1 	str	x1, [sp, #72]
  4026f4:	d2800001 	mov	x1, #0x0                   	// #0
  4026f8:	aa0203f5 	mov	x21, x2
    return (isotp_fast_node_id)(frame->id & ISOTP_FIXED_ADDR_SA_MASK);
}

static inline isotp_fast_node_id isotp_fast_get_addr_recipient(isotp_fast_msg_id addr)
{
    return (isotp_fast_node_id)((addr & ISOTP_FIXED_ADDR_TA_MASK) >> ISOTP_FIXED_ADDR_TA_POS);
  4026fc:	d3483e80 	ubfx	x0, x20, #8, #8
    SYS_SLIST_FOR_EACH_CONTAINER(&isotp_send_ctx_list, context, node)
  402700:	f90023e3 	str	x3, [sp, #64]
  402704:	b50003e3 	cbnz	x3, 402780 <get_send_ctx+0xc0>
    int err = k_mem_slab_alloc(&isotp_send_ctx_slab, (void **)&context, K_NO_WAIT);
  402708:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40270c:	910103e1 	add	x1, sp, #0x40
  402710:	d2800002 	mov	x2, #0x0                   	// #0
  402714:	f947f400 	ldr	x0, [x0, #4072]
  402718:	94003db0 	bl	411dd8 <k_mem_slab_alloc>
  40271c:	2a0003f3 	mov	w19, w0
    if (err != 0) {
  402720:	35000540 	cbnz	w0, 4027c8 <get_send_ctx+0x108>
    *sctx = context;
  402724:	f94023e0 	ldr	x0, [sp, #64]
  402728:	f90002a0 	str	x0, [x21]
    k_work_init(&context->work, receive_work_handler);
  40272c:	b0000001 	adrp	x1, 403000 <send_work_handler+0xf4>
  402730:	911c4021 	add	x1, x1, #0x710
  402734:	91006000 	add	x0, x0, #0x18
    context->ctx = ctx;
  402738:	f81f0017 	stur	x23, [x0, #-16]
    context->recipient_addr = recipient_addr;
  40273c:	b81f8014 	stur	w20, [x0, #-8]
    context->error = 0;
  402740:	3902ac1f 	strb	wzr, [x0, #171]
    k_work_init(&context->work, receive_work_handler);
  402744:	940045c9 	bl	413e68 <k_work_init>
    k_timer_init(&context->timer, receive_timeout_handler, NULL);
  402748:	f94023e0 	ldr	x0, [sp, #64]
  40274c:	d2800002 	mov	x2, #0x0                   	// #0
  402750:	90000001 	adrp	x1, 402000 <__divtf3+0x780>
  402754:	9114b021 	add	x1, x1, #0x52c
  402758:	9100e000 	add	x0, x0, #0x38
  40275c:	940053c2 	bl	417664 <k_timer_init>
    sys_slist_append(&isotp_send_ctx_list, &context->node);
  402760:	f94023e0 	ldr	x0, [sp, #64]
	return list->tail;
  402764:	9102e2c1 	add	x1, x22, #0xb8
	parent->next = child;
  402768:	f900001f 	str	xzr, [x0]
	return list->tail;
  40276c:	f9400422 	ldr	x2, [x1, #8]
Z_GENLIST_APPEND(slist, snode)
  402770:	b5000262 	cbnz	x2, 4027bc <get_send_ctx+0xfc>
	list->head = node;
  402774:	f9005ec0 	str	x0, [x22, #184]
	list->tail = node;
  402778:	f9000420 	str	x0, [x1, #8]
}
  40277c:	14000006 	b	402794 <get_send_ctx+0xd4>
        if (isotp_fast_get_addr_recipient(context->recipient_addr) == recipient_id) {
  402780:	39404461 	ldrb	w1, [x3, #17]
  402784:	6b00003f 	cmp	w1, w0
  402788:	54000161 	b.ne	4027b4 <get_send_ctx+0xf4>  // b.any
            return 0;
  40278c:	52800013 	mov	w19, #0x0                   	// #0
            *sctx = context;
  402790:	f90002a3 	str	x3, [x21]
}
  402794:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  402798:	f9475c00 	ldr	x0, [x0, #3768]
  40279c:	f94027e2 	ldr	x2, [sp, #72]
  4027a0:	f9400001 	ldr	x1, [x0]
  4027a4:	eb010042 	subs	x2, x2, x1
  4027a8:	d2800001 	mov	x1, #0x0                   	// #0
  4027ac:	54000120 	b.eq	4027d0 <get_send_ctx+0x110>  // b.none
  4027b0:	97fffb5c 	bl	401520 <__stack_chk_fail@plt>
	return node->next;
  4027b4:	f9400063 	ldr	x3, [x3]
  4027b8:	17ffffd2 	b	402700 <get_send_ctx+0x40>
	parent->next = child;
  4027bc:	f9000040 	str	x0, [x2]
	list->tail = node;
  4027c0:	f9000420 	str	x0, [x1, #8]
}
  4027c4:	17fffff4 	b	402794 <get_send_ctx+0xd4>
        return ISOTP_NO_CTX_LEFT;
  4027c8:	12800193 	mov	w19, #0xfffffff3            	// #-13
  4027cc:	17fffff2 	b	402794 <get_send_ctx+0xd4>
}
  4027d0:	2a1303e0 	mov	w0, w19
  4027d4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4027d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4027dc:	f9401bf7 	ldr	x23, [sp, #48]
  4027e0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4027e4:	d65f03c0 	ret

00000000004027e8 <can_rx_callback>:
{
  4027e8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  4027ec:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4027f0:	910003fd 	mov	x29, sp
  4027f4:	a90153f3 	stp	x19, x20, [sp, #16]
  4027f8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4027fc:	aa0103f5 	mov	x21, x1
  402800:	aa0203f6 	mov	x22, x2
  402804:	a90363f7 	stp	x23, x24, [sp, #48]
  402808:	f9475c00 	ldr	x0, [x0, #3768]
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  40280c:	b9400033 	ldr	w19, [x1]
{
  402810:	f90023f9 	str	x25, [sp, #64]
  402814:	f9400001 	ldr	x1, [x0]
  402818:	f90037e1 	str	x1, [sp, #104]
  40281c:	d2800001 	mov	x1, #0x0                   	// #0
    if ((frame->data[index++] & ISOTP_PCI_TYPE_MASK) == ISOTP_PCI_TYPE_FC) {
  402820:	394022a0 	ldrb	w0, [x21, #8]
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402824:	d3407273 	ubfx	x19, x19, #0, #29
    if ((frame->data[index++] & ISOTP_PCI_TYPE_MASK) == ISOTP_PCI_TYPE_FC) {
  402828:	121c0c00 	and	w0, w0, #0xf0
  40282c:	7100c01f 	cmp	w0, #0x30
  402830:	54001061 	b.ne	402a3c <can_rx_callback+0x254>  // b.any
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402834:	53181e60 	ubfiz	w0, w19, #8, #8
  402838:	d3483e61 	ubfx	x1, x19, #8, #8
    isotp_fast_msg_id sender_id =
  40283c:	2a000021 	orr	w1, w1, w0
        (frame->id & 0xFFFF0000) | ((frame->id & 0xFF00) >> 8) | ((frame->id & 0xFF) << 8);
  402840:	12103e73 	and	w19, w19, #0xffff0000
        if (get_send_ctx(ctx, sender_id, &sctx) != 0) {
  402844:	910183e2 	add	x2, sp, #0x60
  402848:	2a130021 	orr	w1, w1, w19
  40284c:	aa1603e0 	mov	x0, x22
  402850:	97ffff9c 	bl	4026c0 <get_send_ctx>
  402854:	350016a0 	cbnz	w0, 402b28 <can_rx_callback+0x340>
        send_can_rx(sctx, frame);
  402858:	f94033f3 	ldr	x19, [sp, #96]
    if (sctx->state == ISOTP_TX_WAIT_FC) {
  40285c:	f9406260 	ldr	x0, [x19, #192]
  402860:	530c4c00 	ubfx	w0, w0, #12, #8
  402864:	71000c1f 	cmp	w0, #0x3
  402868:	54000d61 	b.ne	402a14 <can_rx_callback+0x22c>  // b.any
        k_timer_stop(&sctx->timer);
  40286c:	9100e274 	add	x20, x19, #0x38
  402870:	aa1403e0 	mov	x0, x20
  402874:	97fffea5 	bl	402308 <k_timer_stop>
    if ((*data & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_FC) {
  402878:	394022a1 	ldrb	w1, [x21, #8]
  40287c:	121c0c20 	and	w0, w1, #0xf0
  402880:	7100c01f 	cmp	w0, #0x30
  402884:	54000220 	b.eq	4028c8 <can_rx_callback+0xe0>  // b.none
        LOG_ERR("Got unexpected PDU expected FC");
  402888:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  40288c:	913d84c6 	add	x6, x6, #0xf61
        LOG_ERR("Got unexpected PDU");
  402890:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402894:	52800000 	mov	w0, #0x0                   	// #0
  402898:	52800005 	mov	w5, #0x0                   	// #0
  40289c:	d2800004 	mov	x4, #0x0                   	// #0
  4028a0:	f9478421 	ldr	x1, [x1, #3848]
  4028a4:	d2800003 	mov	x3, #0x0                   	// #0
  4028a8:	52800022 	mov	w2, #0x1                   	// #1
  4028ac:	97fffeb8 	bl	40238c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  4028b0:	b940c260 	ldr	w0, [x19, #192]
  4028b4:	52900001 	mov	w1, #0x8000                	// #32768
  4028b8:	72bf4001 	movk	w1, #0xfa00, lsl #16
  4028bc:	12005c00 	and	w0, w0, #0xffffff
  4028c0:	120c5c00 	and	w0, w0, #0xfff00fff
  4028c4:	1400004b 	b	4029f0 <can_rx_callback+0x208>
    switch (*data++ & ISOTP_PCI_FS_MASK) {
  4028c8:	12000c21 	and	w1, w1, #0xf
  4028cc:	7100043f 	cmp	w1, #0x1
  4028d0:	540003a0 	b.eq	402944 <can_rx_callback+0x15c>  // b.none
  4028d4:	7100083f 	cmp	w1, #0x2
  4028d8:	540006e0 	b.eq	4029b4 <can_rx_callback+0x1cc>  // b.none
  4028dc:	35000901 	cbnz	w1, 4029fc <can_rx_callback+0x214>
            sctx->state = ISOTP_TX_SEND_CF;
  4028e0:	79418260 	ldrh	w0, [x19, #192]
  4028e4:	91030261 	add	x1, x19, #0xc0
  4028e8:	12002c00 	and	w0, w0, #0xfff
  4028ec:	32120000 	orr	w0, w0, #0x4000
  4028f0:	79018260 	strh	w0, [x19, #192]
  4028f4:	aa0103e0 	mov	x0, x1
  4028f8:	39400821 	ldrb	w1, [x1, #2]
  4028fc:	121c6c21 	and	w1, w1, #0xfffffff0
  402900:	39000801 	strb	w1, [x0, #2]
            sctx->wft = 0;
  402904:	3903427f 	strb	wzr, [x19, #208]
            sctx->backlog = 0;
  402908:	39034e7f 	strb	wzr, [x19, #211]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_RESET);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_reset(sem);
  40290c:	91024260 	add	x0, x19, #0x90
  402910:	940043a2 	bl	413798 <z_impl_k_sem_reset>
            sctx->bs = *data++;
  402914:	394026a0 	ldrb	w0, [x21, #9]
  402918:	39034660 	strb	w0, [x19, #209]
            sctx->stmin = *data++;
  40291c:	39402aa0 	ldrb	w0, [x21, #10]
  402920:	39035260 	strb	w0, [x19, #212]
    k_work_submit(&sctx->work);
  402924:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  402928:	f9475c00 	ldr	x0, [x0, #3768]
  40292c:	f94037e2 	ldr	x2, [sp, #104]
  402930:	f9400001 	ldr	x1, [x0]
  402934:	eb010042 	subs	x2, x2, x1
  402938:	d2800001 	mov	x1, #0x0                   	// #0
  40293c:	54000720 	b.eq	402a20 <can_rx_callback+0x238>  // b.none
}
  402940:	97fffaf8 	bl	401520 <__stack_chk_fail@plt>
	z_impl_k_timer_start(timer, duration, period);
  402944:	d2800002 	mov	x2, #0x0                   	// #0
  402948:	aa1403e0 	mov	x0, x20
  40294c:	d2800c81 	mov	x1, #0x64                  	// #100
  402950:	9400534c 	bl	417680 <z_impl_k_timer_start>
            if (sctx->wft >= CONFIG_ISOTP_WFTMAX) {
  402954:	39434260 	ldrb	w0, [x19, #208]
  402958:	7100241f 	cmp	w0, #0x9
  40295c:	54000249 	b.ls	4029a4 <can_rx_callback+0x1bc>  // b.plast
                LOG_WRN("Got too many wait frames");
  402960:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402964:	52800000 	mov	w0, #0x0                   	// #0
  402968:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  40296c:	52800005 	mov	w5, #0x0                   	// #0
  402970:	f9478421 	ldr	x1, [x1, #3848]
  402974:	913e00c6 	add	x6, x6, #0xf80
  402978:	d2800004 	mov	x4, #0x0                   	// #0
  40297c:	d2800003 	mov	x3, #0x0                   	// #0
  402980:	52800042 	mov	w2, #0x2                   	// #2
  402984:	97fffe82 	bl	40238c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  402988:	b940c260 	ldr	w0, [x19, #192]
  40298c:	52900001 	mov	w1, #0x8000                	// #32768
  402990:	72bf2001 	movk	w1, #0xf900, lsl #16
  402994:	12005c00 	and	w0, w0, #0xffffff
  402998:	120c5c00 	and	w0, w0, #0xfff00fff
  40299c:	2a010000 	orr	w0, w0, w1
  4029a0:	b900c260 	str	w0, [x19, #192]
            sctx->wft++;
  4029a4:	39434260 	ldrb	w0, [x19, #208]
  4029a8:	11000400 	add	w0, w0, #0x1
  4029ac:	39034260 	strb	w0, [x19, #208]
            break;
  4029b0:	17ffffdd 	b	402924 <can_rx_callback+0x13c>
            LOG_ERR("Got overflow FC frame");
  4029b4:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4029b8:	52800000 	mov	w0, #0x0                   	// #0
  4029bc:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  4029c0:	52800005 	mov	w5, #0x0                   	// #0
  4029c4:	f9478421 	ldr	x1, [x1, #3848]
  4029c8:	913e64c6 	add	x6, x6, #0xf99
  4029cc:	d2800004 	mov	x4, #0x0                   	// #0
  4029d0:	d2800003 	mov	x3, #0x0                   	// #0
  4029d4:	52800022 	mov	w2, #0x1                   	// #1
  4029d8:	97fffe6d 	bl	40238c <z_log_msg_runtime_create.constprop.0>
    sctx->state = ISOTP_TX_ERR;
  4029dc:	b940c260 	ldr	w0, [x19, #192]
  4029e0:	52900001 	mov	w1, #0x8000                	// #32768
  4029e4:	72bf0001 	movk	w1, #0xf800, lsl #16
  4029e8:	12005c00 	and	w0, w0, #0xffffff
  4029ec:	120c5c00 	and	w0, w0, #0xfff00fff
  4029f0:	2a010000 	orr	w0, w0, w1
  4029f4:	b900c260 	str	w0, [x19, #192]
}
  4029f8:	17ffffcb 	b	402924 <can_rx_callback+0x13c>
    sctx->state = ISOTP_TX_ERR;
  4029fc:	b940c260 	ldr	w0, [x19, #192]
  402a00:	52900001 	mov	w1, #0x8000                	// #32768
  402a04:	72bf6001 	movk	w1, #0xfb00, lsl #16
  402a08:	12005c00 	and	w0, w0, #0xffffff
  402a0c:	120c5c00 	and	w0, w0, #0xfff00fff
  402a10:	17fffff8 	b	4029f0 <can_rx_callback+0x208>
        LOG_ERR("Got unexpected PDU");
  402a14:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  402a18:	913ebcc6 	add	x6, x6, #0xfaf
  402a1c:	17ffff9d 	b	402890 <can_rx_callback+0xa8>
    k_work_submit(&sctx->work);
  402a20:	91006260 	add	x0, x19, #0x18
}
  402a24:	a94153f3 	ldp	x19, x20, [sp, #16]
  402a28:	a9425bf5 	ldp	x21, x22, [sp, #32]
  402a2c:	a94363f7 	ldp	x23, x24, [sp, #48]
  402a30:	f94023f9 	ldr	x25, [sp, #64]
  402a34:	a8c77bfd 	ldp	x29, x30, [sp], #112
    k_work_submit(&sctx->work);
  402a38:	14004599 	b	41409c <k_work_submit>
	return list->head;
  402a3c:	b0000197 	adrp	x23, 433000 <obj_0x28+0x18>
    return (isotp_fast_node_id)(addr & ISOTP_FIXED_ADDR_SA_MASK);
  402a40:	12001e60 	and	w0, w19, #0xff
  402a44:	f94056f4 	ldr	x20, [x23, #168]
    SYS_SLIST_FOR_EACH_CONTAINER(&isotp_recv_ctx_list, context, node)
  402a48:	f90033f4 	str	x20, [sp, #96]
  402a4c:	b50002b4 	cbnz	x20, 402aa0 <can_rx_callback+0x2b8>
    int err = k_mem_slab_alloc(&isotp_recv_ctx_slab, (void **)&context, K_NO_WAIT);
  402a50:	f0000174 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  402a54:	910183f8 	add	x24, sp, #0x60
  402a58:	aa1803e1 	mov	x1, x24
  402a5c:	d2800002 	mov	x2, #0x0                   	// #0
  402a60:	f947b294 	ldr	x20, [x20, #3936]
  402a64:	aa1403e0 	mov	x0, x20
  402a68:	94003cdc 	bl	411dd8 <k_mem_slab_alloc>
  402a6c:	2a0003e7 	mov	w7, w0
    if (err != 0) {
  402a70:	34000920 	cbz	w0, 402b94 <can_rx_callback+0x3ac>
        LOG_ERR("No space for receive context - error %d.", err);
  402a74:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402a78:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  402a7c:	52800005 	mov	w5, #0x0                   	// #0
  402a80:	913f48c6 	add	x6, x6, #0xfd2
  402a84:	f9478421 	ldr	x1, [x1, #3848]
  402a88:	d2800004 	mov	x4, #0x0                   	// #0
  402a8c:	d2800003 	mov	x3, #0x0                   	// #0
  402a90:	52800022 	mov	w2, #0x1                   	// #1
  402a94:	52800000 	mov	w0, #0x0                   	// #0
  402a98:	97fffe3d 	bl	40238c <z_log_msg_runtime_create.constprop.0>
        return ISOTP_NO_CTX_LEFT;
  402a9c:	14000019 	b	402b00 <can_rx_callback+0x318>
        if (isotp_fast_get_addr_sender(context->sender_addr) == sender_id) {
  402aa0:	39404281 	ldrb	w1, [x20, #16]
  402aa4:	6b01001f 	cmp	w0, w1
  402aa8:	54000721 	b.ne	402b8c <can_rx_callback+0x3a4>  // b.any
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf * __must_check net_buf_alloc(struct net_buf_pool *pool,
							  k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
  402aac:	d2800001 	mov	x1, #0x0                   	// #0
  402ab0:	90000180 	adrp	x0, 432000 <__dso_handle>
  402ab4:	9137a000 	add	x0, x0, #0xde8
            *rctx = context;
  402ab8:	f9002ff4 	str	x20, [sp, #88]
  402abc:	94002387 	bl	40b8d8 <net_buf_alloc_fixed>
            context->frag = net_buf_alloc(&isotp_rx_pool, K_NO_WAIT);
  402ac0:	f9004e80 	str	x0, [x20, #152]
            if (context->frag == NULL) {
  402ac4:	f94033e0 	ldr	x0, [sp, #96]
  402ac8:	f9404c01 	ldr	x1, [x0, #152]
  402acc:	b5000481 	cbnz	x1, 402b5c <can_rx_callback+0x374>
                LOG_ERR("No free buffers");
  402ad0:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402ad4:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  402ad8:	913f08c6 	add	x6, x6, #0xfc2
  402adc:	52800005 	mov	w5, #0x0                   	// #0
  402ae0:	f9478421 	ldr	x1, [x1, #3848]
  402ae4:	d2800004 	mov	x4, #0x0                   	// #0
  402ae8:	d2800003 	mov	x3, #0x0                   	// #0
  402aec:	52800022 	mov	w2, #0x1                   	// #1
  402af0:	52800000 	mov	w0, #0x0                   	// #0
  402af4:	97fffe26 	bl	40238c <z_log_msg_runtime_create.constprop.0>
                free_recv_ctx(rctx);
  402af8:	910163e0 	add	x0, sp, #0x58
  402afc:	97fffedd 	bl	402670 <free_recv_ctx>
            LOG_ERR("RX buffer full");
  402b00:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402b04:	d00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  402b08:	52800005 	mov	w5, #0x0                   	// #0
  402b0c:	910020c6 	add	x6, x6, #0x8
  402b10:	f9478421 	ldr	x1, [x1, #3848]
  402b14:	d2800004 	mov	x4, #0x0                   	// #0
  402b18:	d2800003 	mov	x3, #0x0                   	// #0
  402b1c:	52800022 	mov	w2, #0x1                   	// #1
  402b20:	52800000 	mov	w0, #0x0                   	// #0
  402b24:	97fffe1a 	bl	40238c <z_log_msg_runtime_create.constprop.0>
}
  402b28:	f0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  402b2c:	f9475c00 	ldr	x0, [x0, #3768]
  402b30:	f94037e2 	ldr	x2, [sp, #104]
  402b34:	f9400001 	ldr	x1, [x0]
  402b38:	eb010042 	subs	x2, x2, x1
  402b3c:	d2800001 	mov	x1, #0x0                   	// #0
  402b40:	54fff001 	b.ne	402940 <can_rx_callback+0x158>  // b.any
  402b44:	a94153f3 	ldp	x19, x20, [sp, #16]
  402b48:	a9425bf5 	ldp	x21, x22, [sp, #32]
  402b4c:	a94363f7 	ldp	x23, x24, [sp, #48]
  402b50:	f94023f9 	ldr	x25, [sp, #64]
  402b54:	a8c77bfd 	ldp	x29, x30, [sp], #112
  402b58:	d65f03c0 	ret
            net_buf_frag_add(context->buffer, context->frag);
  402b5c:	f9404800 	ldr	x0, [x0, #144]
  402b60:	94002400 	bl	40bb60 <net_buf_frag_add>
        receive_can_rx(rctx, frame);
  402b64:	f9402ff3 	ldr	x19, [sp, #88]
    switch (rctx->state) {
  402b68:	f9405260 	ldr	x0, [x19, #160]
  402b6c:	530c4c01 	ubfx	w1, w0, #12, #8
  402b70:	72141c1f 	tst	w0, #0xff000
  402b74:	54000780 	b.eq	402c64 <can_rx_callback+0x47c>  // b.none
  402b78:	7100143f 	cmp	w1, #0x5
  402b7c:	54000fa0 	b.eq	402d70 <can_rx_callback+0x588>  // b.none
    k_work_submit(&rctx->work);
  402b80:	91006260 	add	x0, x19, #0x18
  402b84:	94004546 	bl	41409c <k_work_submit>
  402b88:	17ffffe8 	b	402b28 <can_rx_callback+0x340>
	return node->next;
  402b8c:	f9400294 	ldr	x20, [x20]
  402b90:	17ffffae 	b	402a48 <can_rx_callback+0x260>
    context->buffer = net_buf_alloc(&isotp_rx_pool, K_NO_WAIT);
  402b94:	f94033f9 	ldr	x25, [sp, #96]
  402b98:	d2800001 	mov	x1, #0x0                   	// #0
  402b9c:	90000180 	adrp	x0, 432000 <__dso_handle>
  402ba0:	9137a000 	add	x0, x0, #0xde8
  402ba4:	9400234d 	bl	40b8d8 <net_buf_alloc_fixed>
  402ba8:	f9004b20 	str	x0, [x25, #144]
    if (!context->buffer) {
  402bac:	f94033e0 	ldr	x0, [sp, #96]
  402bb0:	f9404801 	ldr	x1, [x0, #144]
  402bb4:	b50001e1 	cbnz	x1, 402bf0 <can_rx_callback+0x408>
        k_mem_slab_free(&isotp_recv_ctx_slab, (void **)&context);
  402bb8:	aa1803e1 	mov	x1, x24
  402bbc:	aa1403e0 	mov	x0, x20
  402bc0:	94003ce4 	bl	411f50 <k_mem_slab_free>
        LOG_ERR("No net bufs.");
  402bc4:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402bc8:	b00000a6 	adrp	x6, 417000 <z_abort_timeout+0x38>
  402bcc:	52800005 	mov	w5, #0x0                   	// #0
  402bd0:	913fecc6 	add	x6, x6, #0xffb
  402bd4:	f9478421 	ldr	x1, [x1, #3848]
  402bd8:	d2800004 	mov	x4, #0x0                   	// #0
  402bdc:	d2800003 	mov	x3, #0x0                   	// #0
  402be0:	52800022 	mov	w2, #0x1                   	// #1
  402be4:	52800000 	mov	w0, #0x0                   	// #0
  402be8:	97fffde9 	bl	40238c <z_log_msg_runtime_create.constprop.0>
        return ISOTP_NO_NET_BUF_LEFT;
  402bec:	17ffffc5 	b	402b00 <can_rx_callback+0x318>
    context->frag = context->buffer;
  402bf0:	f9004c01 	str	x1, [x0, #152]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  402bf4:	b940a001 	ldr	w1, [x0, #160]
    context->ctx = ctx;
  402bf8:	f9000416 	str	x22, [x0, #8]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  402bfc:	12005c21 	and	w1, w1, #0xffffff
    context->sender_addr = sender_addr;
  402c00:	b9001013 	str	w19, [x0, #16]
    context->state = ISOTP_RX_STATE_WAIT_FF_SF;
  402c04:	120c5c21 	and	w1, w1, #0xfff00fff
  402c08:	b900a001 	str	w1, [x0, #160]
    k_work_init(&context->work, receive_work_handler);
  402c0c:	b0000001 	adrp	x1, 403000 <send_work_handler+0xf4>
  402c10:	911c4021 	add	x1, x1, #0x710
    *rctx = context;
  402c14:	f9002fe0 	str	x0, [sp, #88]
    k_work_init(&context->work, receive_work_handler);
  402c18:	91006000 	add	x0, x0, #0x18
  402c1c:	94004493 	bl	413e68 <k_work_init>
    k_timer_init(&context->timer, receive_timeout_handler, NULL);
  402c20:	f94033e0 	ldr	x0, [sp, #96]
  402c24:	d2800002 	mov	x2, #0x0                   	// #0
  402c28:	90000001 	adrp	x1, 402000 <__divtf3+0x780>
  402c2c:	9114b021 	add	x1, x1, #0x52c
  402c30:	9100e000 	add	x0, x0, #0x38
  402c34:	9400528c 	bl	417664 <k_timer_init>
    sys_slist_append(&isotp_recv_ctx_list, &context->node);
  402c38:	f94033e0 	ldr	x0, [sp, #96]
	return list->tail;
  402c3c:	9102a2e1 	add	x1, x23, #0xa8
	parent->next = child;
  402c40:	f900001f 	str	xzr, [x0]
	return list->tail;
  402c44:	f9400422 	ldr	x2, [x1, #8]
Z_GENLIST_APPEND(slist, snode)
  402c48:	b5000082 	cbnz	x2, 402c58 <can_rx_callback+0x470>
	list->head = node;
  402c4c:	f90056e0 	str	x0, [x23, #168]
	list->tail = node;
  402c50:	f9000420 	str	x0, [x1, #8]
	list->head = node;
  402c54:	17ffffc4 	b	402b64 <can_rx_callback+0x37c>
	parent->next = child;
  402c58:	f9000040 	str	x0, [x2]
	list->tail = node;
  402c5c:	f9000420 	str	x0, [x1, #8]
  402c60:	17ffffc1 	b	402b64 <can_rx_callback+0x37c>
    switch (frame->data[index] & ISOTP_PCI_TYPE_MASK) {
  402c64:	394022a0 	ldrb	w0, [x21, #8]
  402c68:	721c0c01 	ands	w1, w0, #0xf0
  402c6c:	540004e0 	b.eq	402d08 <can_rx_callback+0x520>  // b.none
  402c70:	7100403f 	cmp	w1, #0x10
  402c74:	54fff861 	b.ne	402b80 <can_rx_callback+0x398>  // b.any
            if (frame->dlc != ISOTP_FF_DL_MIN) {
  402c78:	394012a1 	ldrb	w1, [x21, #4]
  402c7c:	7100203f 	cmp	w1, #0x8
  402c80:	54fff801 	b.ne	402b80 <can_rx_callback+0x398>  // b.any
    len = ((pci & ISOTP_PCI_FF_DL_UPPER_MASK) << 8) | data[1];
  402c84:	394026a1 	ldrb	w1, [x21, #9]
  402c88:	53180c00 	ubfiz	w0, w0, #8, #4
  402c8c:	2a010000 	orr	w0, w0, w1
    if (!len) {
  402c90:	35000060 	cbnz	w0, 402c9c <can_rx_callback+0x4b4>
        len = UNALIGNED_GET((uint32_t *)data);
  402c94:	b9400aa0 	ldr	w0, [x21, #8]
  402c98:	5ac00800 	rev	w0, w0
            rctx->rem_len = receive_get_ff_length(frame->data);
  402c9c:	aa1303e1 	mov	x1, x19
            rctx->state = ISOTP_RX_STATE_PROCESS_FF;
  402ca0:	12002c00 	and	w0, w0, #0xfff
  402ca4:	32130000 	orr	w0, w0, #0x2000
            payload_len = CAN_MAX_DLEN - index;
  402ca8:	528000d4 	mov	w20, #0x6                   	// #6
            rctx->rem_len = receive_get_ff_length(frame->data);
  402cac:	784a0c22 	ldrh	w2, [x1, #160]!
            rctx->state = ISOTP_RX_STATE_PROCESS_FF;
  402cb0:	79014260 	strh	w0, [x19, #160]
  402cb4:	39400820 	ldrb	w0, [x1, #2]
  402cb8:	121c6c00 	and	w0, w0, #0xfffffff0
  402cbc:	39000820 	strb	w0, [x1, #2]
            rctx->sn_expected = 1;
  402cc0:	52800021 	mov	w1, #0x1                   	// #1
  402cc4:	39429a60 	ldrb	w0, [x19, #166]
  402cc8:	33000c20 	bfxil	w0, w1, #0, #4
            index += 2;
  402ccc:	52800041 	mov	w1, #0x2                   	// #2
            rctx->sn_expected = 1;
  402cd0:	39029a60 	strb	w0, [x19, #166]
 * @return The original tail of the buffer.
 */
static inline void *net_buf_add_mem(struct net_buf *buf, const void *mem,
				    size_t len)
{
	return net_buf_simple_add_mem(&buf->b, mem, len);
  402cd4:	f9404e60 	ldr	x0, [x19, #152]
    net_buf_add_mem(rctx->frag, &frame->data[index], payload_len);
  402cd8:	11002021 	add	w1, w1, #0x8
  402cdc:	92401e82 	and	x2, x20, #0xff
  402ce0:	8b21c2a1 	add	x1, x21, w1, sxtw
  402ce4:	91006000 	add	x0, x0, #0x18
  402ce8:	94002421 	bl	40bd6c <net_buf_simple_add_mem>
    rctx->rem_len -= payload_len;
  402cec:	f9405260 	ldr	x0, [x19, #160]
  402cf0:	79414261 	ldrh	w1, [x19, #160]
  402cf4:	d3402c00 	ubfx	x0, x0, #0, #12
  402cf8:	4b140000 	sub	w0, w0, w20
  402cfc:	33002c01 	bfxil	w1, w0, #0, #12
  402d00:	79014261 	strh	w1, [x19, #160]
  402d04:	17ffff9f 	b	402b80 <can_rx_callback+0x398>
            rctx->rem_len = receive_get_sf_length(frame->data, &index);
  402d08:	79414261 	ldrh	w1, [x19, #160]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402d0c:	71001c1f 	cmp	w0, #0x7
            rctx->rem_len = receive_get_sf_length(frame->data, &index);
  402d10:	33002c01 	bfxil	w1, w0, #0, #12
  402d14:	79014261 	strh	w1, [x19, #160]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402d18:	528000e1 	mov	w1, #0x7                   	// #7
  402d1c:	1a819000 	csel	w0, w0, w1, ls  // ls = plast
            if (payload_len > can_dlc_to_bytes(frame->dlc)) {
  402d20:	394012a1 	ldrb	w1, [x21, #4]
            payload_len = MIN(rctx->rem_len, CAN_MAX_DLEN - index);
  402d24:	12001c14 	and	w20, w0, #0xff
	return dlc > 0x0F ? 64 : dlc_table[dlc];
  402d28:	71003c3f 	cmp	w1, #0xf
  402d2c:	540000c8 	b.hi	402d44 <can_rx_callback+0x55c>  // b.pmore
            if (payload_len > can_dlc_to_bytes(frame->dlc)) {
  402d30:	d00000a0 	adrp	x0, 418000 <table.0+0x1d8>
  402d34:	91033000 	add	x0, x0, #0xcc
  402d38:	3861c800 	ldrb	w0, [x0, w1, sxtw]
  402d3c:	6b14001f 	cmp	w0, w20
  402d40:	54fff203 	b.cc	402b80 <can_rx_callback+0x398>  // b.lo, b.ul, b.last
            rctx->state = ISOTP_RX_STATE_PROCESS_SF;
  402d44:	79414260 	ldrh	w0, [x19, #160]
  402d48:	91028261 	add	x1, x19, #0xa0
  402d4c:	12002c00 	and	w0, w0, #0xfff
  402d50:	32140000 	orr	w0, w0, #0x1000
  402d54:	79014260 	strh	w0, [x19, #160]
  402d58:	aa0103e0 	mov	x0, x1
  402d5c:	39400821 	ldrb	w1, [x1, #2]
  402d60:	121c6c21 	and	w1, w1, #0xfffffff0
  402d64:	39000801 	strb	w1, [x0, #2]
    (*index)++;
  402d68:	52800021 	mov	w1, #0x1                   	// #1
            break;
  402d6c:	17ffffda 	b	402cd4 <can_rx_callback+0x4ec>
    if ((frame->data[index] & ISOTP_PCI_TYPE_MASK) != ISOTP_PCI_TYPE_CF) {
  402d70:	394022a0 	ldrb	w0, [x21, #8]
  402d74:	121c0c00 	and	w0, w0, #0xf0
  402d78:	7100801f 	cmp	w0, #0x20
  402d7c:	540001e0 	b.eq	402db8 <can_rx_callback+0x5d0>  // b.none
    rctx->state = ISOTP_RX_STATE_ERR;
  402d80:	b940a260 	ldr	w0, [x19, #160]
  402d84:	528e0001 	mov	w1, #0x7000                	// #28672
  402d88:	72bf4001 	movk	w1, #0xfa00, lsl #16
  402d8c:	12005c00 	and	w0, w0, #0xffffff
  402d90:	120c5c00 	and	w0, w0, #0xfff00fff
  402d94:	2a010000 	orr	w0, w0, w1
  402d98:	b900a260 	str	w0, [x19, #160]
        k_work_submit(&rctx->work); // to dispatch complete message
  402d9c:	91006260 	add	x0, x19, #0x18
  402da0:	940044bf 	bl	41409c <k_work_submit>
            if (rctx->state == ISOTP_RX_STATE_WAIT_CF) {
  402da4:	f9405260 	ldr	x0, [x19, #160]
  402da8:	530c4c00 	ubfx	w0, w0, #12, #8
  402dac:	7100141f 	cmp	w0, #0x5
  402db0:	54ffee81 	b.ne	402b80 <can_rx_callback+0x398>  // b.any
  402db4:	17ffff5d 	b	402b28 <can_rx_callback+0x340>
  402db8:	d2800002 	mov	x2, #0x0                   	// #0
  402dbc:	9100e260 	add	x0, x19, #0x38
  402dc0:	d2800c81 	mov	x1, #0x64                  	// #100
  402dc4:	9400522f 	bl	417680 <z_impl_k_timer_start>
    if ((frame->data[index++] & ISOTP_PCI_SN_MASK) != rctx->sn_expected++) {
  402dc8:	f9405260 	ldr	x0, [x19, #160]
  402dcc:	39429a62 	ldrb	w2, [x19, #166]
  402dd0:	394022a1 	ldrb	w1, [x21, #8]
  402dd4:	d370cc00 	ubfx	x0, x0, #48, #4
  402dd8:	11000403 	add	w3, w0, #0x1
  402ddc:	12000c21 	and	w1, w1, #0xf
  402de0:	33000c62 	bfxil	w2, w3, #0, #4
  402de4:	39029a62 	strb	w2, [x19, #166]
  402de8:	6b00003f 	cmp	w1, w0
  402dec:	54000220 	b.eq	402e30 <can_rx_callback+0x648>  // b.none
        LOG_ERR("Sequence number mismatch");
  402df0:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402df4:	52800000 	mov	w0, #0x0                   	// #0
  402df8:	d00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  402dfc:	52800005 	mov	w5, #0x0                   	// #0
  402e00:	f9478421 	ldr	x1, [x1, #3848]
  402e04:	91005cc6 	add	x6, x6, #0x17
  402e08:	d2800004 	mov	x4, #0x0                   	// #0
  402e0c:	d2800003 	mov	x3, #0x0                   	// #0
  402e10:	52800022 	mov	w2, #0x1                   	// #1
  402e14:	97fffd5e 	bl	40238c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  402e18:	b940a260 	ldr	w0, [x19, #160]
  402e1c:	528e0001 	mov	w1, #0x7000                	// #28672
  402e20:	72bf8001 	movk	w1, #0xfc00, lsl #16
  402e24:	12005c00 	and	w0, w0, #0xffffff
  402e28:	120c5c00 	and	w0, w0, #0xfff00fff
  402e2c:	17ffffda 	b	402d94 <can_rx_callback+0x5ac>
    data_len = MIN(rctx->rem_len, can_dlc_to_bytes(frame->dlc) - index);
  402e30:	f9405262 	ldr	x2, [x19, #160]
  402e34:	394012a1 	ldrb	w1, [x21, #4]
  402e38:	12002c42 	and	w2, w2, #0xfff
  402e3c:	71003c3f 	cmp	w1, #0xf
  402e40:	540003a8 	b.hi	402eb4 <can_rx_callback+0x6cc>  // b.pmore
  402e44:	d00000a0 	adrp	x0, 418000 <table.0+0x1d8>
  402e48:	91033000 	add	x0, x0, #0xcc
  402e4c:	3861c801 	ldrb	w1, [x0, w1, sxtw]
  402e50:	51000421 	sub	w1, w1, #0x1
  402e54:	6b01005f 	cmp	w2, w1
  402e58:	f9404e60 	ldr	x0, [x19, #152]
  402e5c:	1a82a034 	csel	w20, w1, w2, ge  // ge = tcont
  402e60:	1a82a022 	csel	w2, w1, w2, ge  // ge = tcont
  402e64:	910026a1 	add	x1, x21, #0x9
  402e68:	91006000 	add	x0, x0, #0x18
  402e6c:	940023c0 	bl	40bd6c <net_buf_simple_add_mem>
    rctx->rem_len -= data_len;
  402e70:	f9405260 	ldr	x0, [x19, #160]
  402e74:	79414261 	ldrh	w1, [x19, #160]
  402e78:	d3402c00 	ubfx	x0, x0, #0, #12
  402e7c:	4b140000 	sub	w0, w0, w20
  402e80:	33002c01 	bfxil	w1, w0, #0, #12
  402e84:	79014261 	strh	w1, [x19, #160]
    if (rctx->rem_len == 0) {
  402e88:	12002c20 	and	w0, w1, #0xfff
  402e8c:	f2402c3f 	tst	x1, #0xfff
  402e90:	54000161 	b.ne	402ebc <can_rx_callback+0x6d4>  // b.any
        rctx->state = ISOTP_RX_STATE_RECYCLE;
  402e94:	91028261 	add	x1, x19, #0xa0
  402e98:	32114000 	orr	w0, w0, #0xffff8000
  402e9c:	79014260 	strh	w0, [x19, #160]
  402ea0:	aa0103e0 	mov	x0, x1
  402ea4:	39400821 	ldrb	w1, [x1, #2]
  402ea8:	121c6c21 	and	w1, w1, #0xfffffff0
  402eac:	39000801 	strb	w1, [x0, #2]
  402eb0:	17ffffbb 	b	402d9c <can_rx_callback+0x5b4>
  402eb4:	52800801 	mov	w1, #0x40                  	// #64
  402eb8:	17ffffe6 	b	402e50 <can_rx_callback+0x668>
    if (rctx->ctx->opts->bs && !--rctx->bs) {
  402ebc:	f9400662 	ldr	x2, [x19, #8]
  402ec0:	f9400841 	ldr	x1, [x2, #16]
  402ec4:	39400021 	ldrb	w1, [x1]
  402ec8:	34fff6e1 	cbz	w1, 402da4 <can_rx_callback+0x5bc>
  402ecc:	39429661 	ldrb	w1, [x19, #165]
  402ed0:	51000421 	sub	w1, w1, #0x1
  402ed4:	12001c21 	and	w1, w1, #0xff
  402ed8:	39029661 	strb	w1, [x19, #165]
  402edc:	35fff641 	cbnz	w1, 402da4 <can_rx_callback+0x5bc>
        rctx->bs = rctx->ctx->opts->bs;
  402ee0:	f9400841 	ldr	x1, [x2, #16]
        rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402ee4:	32140400 	orr	w0, w0, #0x3000
        rctx->bs = rctx->ctx->opts->bs;
  402ee8:	39400021 	ldrb	w1, [x1]
  402eec:	39029661 	strb	w1, [x19, #165]
        rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  402ef0:	91028261 	add	x1, x19, #0xa0
  402ef4:	79014260 	strh	w0, [x19, #160]
  402ef8:	aa0103e0 	mov	x0, x1
  402efc:	39400821 	ldrb	w1, [x1, #2]
  402f00:	121c6c21 	and	w1, w1, #0xfffffff0
  402f04:	39000801 	strb	w1, [x0, #2]
            if (rctx->state == ISOTP_RX_STATE_WAIT_CF) {
  402f08:	17ffff1e 	b	402b80 <can_rx_callback+0x398>

0000000000402f0c <send_work_handler>:
{
  402f0c:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  402f10:	f0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  402f14:	910003fd 	mov	x29, sp
  402f18:	f9475c21 	ldr	x1, [x1, #3768]
  402f1c:	a90153f3 	stp	x19, x20, [sp, #16]
    struct isotp_fast_send_ctx *sctx = CONTAINER_OF(work, struct isotp_fast_send_ctx, work);
  402f20:	d1006013 	sub	x19, x0, #0x18
{
  402f24:	a9025bf5 	stp	x21, x22, [sp, #32]
  402f28:	a90363f7 	stp	x23, x24, [sp, #48]
  402f2c:	a9046bf9 	stp	x25, x26, [sp, #64]
  402f30:	a90573fb 	stp	x27, x28, [sp, #80]
  402f34:	f9400022 	ldr	x2, [x1]
  402f38:	f9003fe2 	str	x2, [sp, #120]
  402f3c:	d2800002 	mov	x2, #0x0                   	// #0
    send_state_machine(sctx);
  402f40:	f90033f3 	str	x19, [sp, #96]
    switch (sctx->state) {
  402f44:	f9406261 	ldr	x1, [x19, #192]
  402f48:	530c4c21 	ubfx	w1, w1, #12, #8
  402f4c:	51000821 	sub	w1, w1, #0x2
  402f50:	7100183f 	cmp	w1, #0x6
  402f54:	54001de8 	b.hi	403310 <send_work_handler+0x404>  // b.pmore
  402f58:	b00000a2 	adrp	x2, 417000 <z_abort_timeout+0x38>
  402f5c:	91374042 	add	x2, x2, #0xdd0
  402f60:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  402f64:	10000061 	adr	x1, 402f70 <send_work_handler+0x64>
  402f68:	8b22a822 	add	x2, x1, w2, sxth #2
  402f6c:	d61f0040 	br	x2
    frame->id = addr;
  402f70:	b9401262 	ldr	w2, [x19, #16]
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402f74:	52800119 	mov	w25, #0x8                   	// #8
    frame->id = addr;
  402f78:	b9406be1 	ldr	w1, [sp, #104]

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len,
  402f7c:	d28000c3 	mov	x3, #0x6                   	// #6
    prepare_frame(&frame, sctx->ctx, sctx->recipient_addr);
  402f80:	f9400678 	ldr	x24, [x19, #8]
    frame->id = addr;
  402f84:	33007041 	bfxil	w1, w2, #0, #29
  402f88:	b9006be1 	str	w1, [sp, #104]
    uint16_t len = sctx->rem_len;
  402f8c:	a94b8276 	ldp	x22, x0, [x19, #184]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402f90:	f9400b01 	ldr	x1, [x24, #16]
  402f94:	39400821 	ldrb	w1, [x1, #2]
    uint16_t len = sctx->rem_len;
  402f98:	12002c14 	and	w20, w0, #0xfff
  402f9c:	d3402c15 	ubfx	x21, x0, #0, #12
        frame.data[index++] = ISOTP_PCI_TYPE_FF | (len >> 8);
  402fa0:	53082c00 	ubfx	w0, w0, #8, #4
  402fa4:	321c0000 	orr	w0, w0, #0x10
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402fa8:	7100229f 	cmp	w20, #0x8
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402fac:	d341fc21 	lsr	x1, x1, #1
        frame.data[index++] = ISOTP_PCI_TYPE_FF | (len >> 8);
  402fb0:	3901c3e0 	strb	w0, [sp, #112]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402fb4:	121e0021 	and	w1, w1, #0x4
    sctx->sn = 1;
  402fb8:	39434a60 	ldrb	w0, [x19, #210]
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402fbc:	1a9992b5 	csel	w21, w21, w25, ls  // ls = plast
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402fc0:	32000021 	orr	w1, w1, #0x1
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402fc4:	12003eb5 	and	w21, w21, #0xffff
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  402fc8:	3901b7e1 	strb	w1, [sp, #109]
    sctx->sn = 1;
  402fcc:	52800021 	mov	w1, #0x1                   	// #1
    uint16_t size = MIN(CAN_MAX_DLEN, len) - index;
  402fd0:	51000ab7 	sub	w23, w21, #0x2
    sctx->sn = 1;
  402fd4:	33000c20 	bfxil	w0, w1, #0, #4
  402fd8:	39034a60 	strb	w0, [x19, #210]
    memcpy(&frame.data[index], sctx->data, size);
  402fdc:	92403ef7 	and	x23, x23, #0xffff
  402fe0:	aa1603e1 	mov	x1, x22
  402fe4:	aa1703e2 	mov	x2, x23
  402fe8:	9101cbe0 	add	x0, sp, #0x72
        frame.data[index++] = len & 0xFF;
  402fec:	3901c7f4 	strb	w20, [sp, #113]
  402ff0:	97fff90c 	bl	401420 <__memcpy_chk@plt>
    sctx->rem_len -= size;
  402ff4:	79418260 	ldrh	w0, [x19, #192]
  402ff8:	11000a94 	add	w20, w20, #0x2
  402ffc:	4b150294 	sub	w20, w20, w21
    sctx->data += size;
  403000:	8b1702d6 	add	x22, x22, x23
    frame.dlc = can_bytes_to_dlc(CAN_MAX_DLEN);
  403004:	3901b3f9 	strb	w25, [sp, #108]
    sctx->rem_len -= size;
  403008:	33002e80 	bfxil	w0, w20, #0, #12
    sctx->data += size;
  40300c:	f9005e76 	str	x22, [x19, #184]
    sctx->rem_len -= size;
  403010:	79018260 	strh	w0, [x19, #192]
    ret = can_send(sctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), send_can_tx_callback,
  403014:	f9400300 	ldr	x0, [x24]
		union { uintptr_t x; void * val; } parm4 = { .val = user_data };
		return (int) arch_syscall_invoke5(parm0.x, parm1.x, parm2.x, parm3.x, parm4.x, K_SYSCALL_CAN_SEND);
	}
#endif
	compiler_barrier();
	return z_impl_can_send(dev, frame, timeout, callback, user_data);
  403018:	d2800c82 	mov	x2, #0x64                  	// #100
  40301c:	aa1303e4 	mov	x4, x19
  403020:	9101a3e1 	add	x1, sp, #0x68
  403024:	f0ffffe3 	adrp	x3, 402000 <__divtf3+0x780>
  403028:	910c3063 	add	x3, x3, #0x30c
  40302c:	9400235f 	bl	40bda8 <z_impl_can_send>
            k_timer_start(&sctx->timer, K_MSEC(ISOTP_BS_TIMEOUT_MS), K_NO_WAIT);
  403030:	f94033e0 	ldr	x0, [sp, #96]
  403034:	9100e000 	add	x0, x0, #0x38
  403038:	d2800002 	mov	x2, #0x0                   	// #0
  40303c:	d2800c81 	mov	x1, #0x64                  	// #100
  403040:	94005190 	bl	417680 <z_impl_k_timer_start>
                    sctx->state = ISOTP_TX_WAIT_FC;
  403044:	f94033e1 	ldr	x1, [sp, #96]
  403048:	79418020 	ldrh	w0, [x1, #192]
  40304c:	12002c00 	and	w0, w0, #0xfff
  403050:	32140400 	orr	w0, w0, #0x3000
  403054:	14000047 	b	403170 <send_work_handler+0x264>
  403058:	f0fffff5 	adrp	x21, 402000 <__divtf3+0x780>
  40305c:	9101a3f7 	add	x23, sp, #0x68
  403060:	9101c7f8 	add	x24, sp, #0x71
  403064:	910c32b5 	add	x21, x21, #0x30c
    len = MIN(sctx->rem_len, CAN_MAX_DLEN - index);
  403068:	528000f6 	mov	w22, #0x7                   	// #7
            k_timer_stop(&sctx->timer);
  40306c:	91008000 	add	x0, x0, #0x20
  403070:	97fffca6 	bl	402308 <k_timer_stop>
                ret = send_cf(sctx);
  403074:	f94033f3 	ldr	x19, [sp, #96]
  403078:	d28000e3 	mov	x3, #0x7                   	// #7
    frame->id = addr;
  40307c:	b9406be0 	ldr	w0, [sp, #104]
  403080:	b9401261 	ldr	w1, [x19, #16]
    prepare_frame(&frame, sctx->ctx, sctx->recipient_addr);
  403084:	f940067b 	ldr	x27, [x19, #8]
    frame->id = addr;
  403088:	33007020 	bfxil	w0, w1, #0, #29
  40308c:	b9006be0 	str	w0, [sp, #104]
    frame->flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0);
  403090:	f9400b60 	ldr	x0, [x27, #16]
  403094:	39400800 	ldrb	w0, [x0, #2]
  403098:	d341fc00 	lsr	x0, x0, #1
  40309c:	121e0000 	and	w0, w0, #0x4
  4030a0:	32000000 	orr	w0, w0, #0x1
  4030a4:	3901b7e0 	strb	w0, [sp, #109]
    frame.data[index++] = ISOTP_PCI_TYPE_CF | sctx->sn;
  4030a8:	f9406a60 	ldr	x0, [x19, #208]
  4030ac:	d3504c00 	ubfx	x0, x0, #16, #4
  4030b0:	321b0000 	orr	w0, w0, #0x20
  4030b4:	3901c3e0 	strb	w0, [sp, #112]
  4030b8:	aa1803e0 	mov	x0, x24
    len = MIN(sctx->rem_len, CAN_MAX_DLEN - index);
  4030bc:	a94bd27a 	ldp	x26, x20, [x19, #184]
  4030c0:	12002e94 	and	w20, w20, #0xfff
  4030c4:	aa1a03e1 	mov	x1, x26
  4030c8:	71001e9f 	cmp	w20, #0x7
  4030cc:	1a969299 	csel	w25, w20, w22, ls  // ls = plast
    memcpy(&frame.data[index], sctx->data, len);
  4030d0:	2a1903fc 	mov	w28, w25
    sctx->rem_len -= len;
  4030d4:	4b190294 	sub	w20, w20, w25
  4030d8:	aa1c03e2 	mov	x2, x28
  4030dc:	97fff8d1 	bl	401420 <__memcpy_chk@plt>
  4030e0:	79418260 	ldrh	w0, [x19, #192]
    sctx->data += len;
  4030e4:	8b1c035a 	add	x26, x26, x28
  4030e8:	f9005e7a 	str	x26, [x19, #184]
    sctx->rem_len -= len;
  4030ec:	33002e80 	bfxil	w0, w20, #0, #12
  4030f0:	79018260 	strh	w0, [x19, #192]
    frame.dlc = can_bytes_to_dlc(len + index);
  4030f4:	11000720 	add	w0, w25, #0x1
  4030f8:	97fffca4 	bl	402388 <can_bytes_to_dlc>
  4030fc:	3901b3e0 	strb	w0, [sp, #108]
    ret = can_send(sctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), send_can_tx_callback,
  403100:	f9400360 	ldr	x0, [x27]
  403104:	d2800c82 	mov	x2, #0x64                  	// #100
  403108:	aa1303e4 	mov	x4, x19
  40310c:	aa1503e3 	mov	x3, x21
  403110:	aa1703e1 	mov	x1, x23
  403114:	94002325 	bl	40bda8 <z_impl_can_send>
  403118:	2a0003f4 	mov	w20, w0
    if (ret == 0) {
  40311c:	7100001f 	cmp	w0, #0x0
  403120:	35000ca0 	cbnz	w0, 4032b4 <send_work_handler+0x3a8>
        sctx->sn++;
  403124:	f9406a60 	ldr	x0, [x19, #208]
  403128:	39434a61 	ldrb	w1, [x19, #210]
  40312c:	d3504c00 	ubfx	x0, x0, #16, #4
  403130:	11000400 	add	w0, w0, #0x1
  403134:	33000c01 	bfxil	w1, w0, #0, #4
        sctx->bs--;
  403138:	39434660 	ldrb	w0, [x19, #209]
        sctx->sn++;
  40313c:	39034a61 	strb	w1, [x19, #210]
        sctx->bs--;
  403140:	51000400 	sub	w0, w0, #0x1
  403144:	39034660 	strb	w0, [x19, #209]
        sctx->backlog++;
  403148:	39434e60 	ldrb	w0, [x19, #211]
  40314c:	11000400 	add	w0, w0, #0x1
  403150:	39034e60 	strb	w0, [x19, #211]
    ret = ret ? ret : sctx->rem_len;
  403154:	f9406260 	ldr	x0, [x19, #192]
                if (!ret) {
  403158:	f2402c1f 	tst	x0, #0xfff
  40315c:	54000141 	b.ne	403184 <send_work_handler+0x278>  // b.any
                    sctx->state = ISOTP_TX_WAIT_BACKLOG;
  403160:	f94033e1 	ldr	x1, [sp, #96]
  403164:	79418020 	ldrh	w0, [x1, #192]
  403168:	12002c00 	and	w0, w0, #0xfff
  40316c:	32130400 	orr	w0, w0, #0x6000
            sctx->state = ISOTP_TX_SEND_CF;
  403170:	79018020 	strh	w0, [x1, #192]
  403174:	39430820 	ldrb	w0, [x1, #194]
  403178:	121c6c00 	and	w0, w0, #0xfffffff0
  40317c:	39030820 	strb	w0, [x1, #194]
            break;
  403180:	14000064 	b	403310 <send_work_handler+0x404>
                if (sctx->ctx->opts->bs && !sctx->bs) {
  403184:	f94033e0 	ldr	x0, [sp, #96]
  403188:	f9400401 	ldr	x1, [x0, #8]
  40318c:	f9400821 	ldr	x1, [x1, #16]
  403190:	39400021 	ldrb	w1, [x1]
  403194:	340000e1 	cbz	w1, 4031b0 <send_work_handler+0x2a4>
  403198:	39434401 	ldrb	w1, [x0, #209]
  40319c:	350000a1 	cbnz	w1, 4031b0 <send_work_handler+0x2a4>
  4031a0:	d2800002 	mov	x2, #0x0                   	// #0
  4031a4:	9100e000 	add	x0, x0, #0x38
  4031a8:	d2800c81 	mov	x1, #0x64                  	// #100
  4031ac:	17ffffa5 	b	403040 <send_work_handler+0x134>
                else if (sctx->stmin) {
  4031b0:	39435001 	ldrb	w1, [x0, #212]
  4031b4:	34000161 	cbz	w1, 4031e0 <send_work_handler+0x2d4>
                    sctx->state = ISOTP_TX_WAIT_ST;
  4031b8:	79418001 	ldrh	w1, [x0, #192]
  4031bc:	91030002 	add	x2, x0, #0xc0
  4031c0:	528a0003 	mov	w3, #0x5000                	// #20480
  4031c4:	12002c21 	and	w1, w1, #0xfff
  4031c8:	2a030021 	orr	w1, w1, w3
  4031cc:	79018001 	strh	w1, [x0, #192]
  4031d0:	39430800 	ldrb	w0, [x0, #194]
  4031d4:	121c6c00 	and	w0, w0, #0xfffffff0
  4031d8:	39000840 	strb	w0, [x2, #2]
                    break;
  4031dc:	1400004d 	b	403310 <send_work_handler+0x404>
	return z_impl_k_sem_take(sem, timeout);
  4031e0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  4031e4:	91024000 	add	x0, x0, #0x90
  4031e8:	940040fb 	bl	4135d4 <z_impl_k_sem_take>
            } while (ret > 0);
  4031ec:	17ffffa2 	b	403074 <send_work_handler+0x168>
            k_timer_start(&sctx->timer, stmin_to_timeout(sctx->stmin), K_NO_WAIT);
  4031f0:	39435261 	ldrb	w1, [x19, #212]
  4031f4:	91008000 	add	x0, x0, #0x20
    if (stmin > ISOTP_STMIN_MAX || (stmin > ISOTP_STMIN_MS_MAX && stmin < ISOTP_STMIN_US_BEGIN)) {
  4031f8:	51020022 	sub	w2, w1, #0x80
  4031fc:	12001c42 	and	w2, w2, #0xff
  403200:	7101c05f 	cmp	w2, #0x70
  403204:	52801f42 	mov	w2, #0xfa                  	// #250
  403208:	7a428022 	ccmp	w1, w2, #0x2, hi  // hi = pmore
  40320c:	540001c8 	b.hi	403244 <send_work_handler+0x338>  // b.pmore
    if (stmin >= ISOTP_STMIN_US_BEGIN) {
  403210:	7103c03f 	cmp	w1, #0xf0
  403214:	540001c8 	b.hi	40324c <send_work_handler+0x340>  // b.pmore
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
  403218:	11002421 	add	w1, w1, #0x9
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
  40321c:	d2800142 	mov	x2, #0xa                   	// #10
		t += off;
  403220:	92401c21 	and	x1, x1, #0xff
			return t / ((uint64_t)from_hz / to_hz);
  403224:	9ac20821 	udiv	x1, x1, x2
	z_impl_k_timer_start(timer, duration, period);
  403228:	d2800002 	mov	x2, #0x0                   	// #0
  40322c:	94005115 	bl	417680 <z_impl_k_timer_start>
            sctx->state = ISOTP_TX_SEND_CF;
  403230:	f94033e1 	ldr	x1, [sp, #96]
  403234:	79418020 	ldrh	w0, [x1, #192]
  403238:	12002c00 	and	w0, w0, #0xfff
  40323c:	32120000 	orr	w0, w0, #0x4000
  403240:	17ffffcc 	b	403170 <send_work_handler+0x264>
        return K_MSEC(ISOTP_STMIN_MS_MAX);
  403244:	d28001a1 	mov	x1, #0xd                   	// #13
  403248:	17fffff8 	b	403228 <send_work_handler+0x31c>
        return K_USEC((stmin + 1 - ISOTP_STMIN_US_BEGIN) * 100U);
  40324c:	d2800021 	mov	x1, #0x1                   	// #1
  403250:	17fffff6 	b	403228 <send_work_handler+0x31c>
            sctx->ctx->sent_callback(sctx->error, sctx->cb_arg);
  403254:	f9400660 	ldr	x0, [x19, #8]
  403258:	f9406661 	ldr	x1, [x19, #200]
  40325c:	f9401802 	ldr	x2, [x0, #48]
  403260:	39c30e60 	ldrsb	w0, [x19, #195]
            sctx->ctx->sent_callback(ISOTP_N_OK, sctx->cb_arg);
  403264:	d63f0040 	blr	x2
            sctx->state = ISOTP_TX_STATE_RESET;
  403268:	f94033e0 	ldr	x0, [sp, #96]
  40326c:	91030002 	add	x2, x0, #0xc0
  403270:	79418001 	ldrh	w1, [x0, #192]
  403274:	12002c21 	and	w1, w1, #0xfff
  403278:	79018001 	strh	w1, [x0, #192]
  40327c:	39430800 	ldrb	w0, [x0, #194]
  403280:	121c6c00 	and	w0, w0, #0xfffffff0
  403284:	39000840 	strb	w0, [x2, #2]
            free_send_ctx(&sctx);
  403288:	910183e0 	add	x0, sp, #0x60
  40328c:	97fffce8 	bl	40262c <free_send_ctx>
}
  403290:	14000020 	b	403310 <send_work_handler+0x404>
            k_timer_stop(&sctx->timer);
  403294:	91008000 	add	x0, x0, #0x20
  403298:	97fffc1c 	bl	402308 <k_timer_stop>
            sctx->ctx->sent_callback(ISOTP_N_OK, sctx->cb_arg);
  40329c:	f94033e0 	ldr	x0, [sp, #96]
  4032a0:	f9400401 	ldr	x1, [x0, #8]
  4032a4:	f9401822 	ldr	x2, [x1, #48]
  4032a8:	f9406401 	ldr	x1, [x0, #200]
  4032ac:	52800000 	mov	w0, #0x0                   	// #0
  4032b0:	17ffffed 	b	403264 <send_work_handler+0x358>
                if (ret < 0) {
  4032b4:	54fff68a 	b.ge	403184 <send_work_handler+0x278>  // b.tcont
                    LOG_ERR("Failed to send CF");
  4032b8:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4032bc:	52800022 	mov	w2, #0x1                   	// #1
  4032c0:	52800000 	mov	w0, #0x0                   	// #0
  4032c4:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  4032c8:	f9478421 	ldr	x1, [x1, #3848]
  4032cc:	9100c0c6 	add	x6, x6, #0x30
  4032d0:	52800005 	mov	w5, #0x0                   	// #0
  4032d4:	d2800004 	mov	x4, #0x0                   	// #0
  4032d8:	d2800003 	mov	x3, #0x0                   	// #0
  4032dc:	97fffc2c 	bl	40238c <z_log_msg_runtime_create.constprop.0>
                    send_report_error(sctx, ret == -EAGAIN ? ISOTP_N_TIMEOUT_A : ISOTP_N_ERROR);
  4032e0:	f94033e1 	ldr	x1, [sp, #96]
  4032e4:	31002e9f 	cmn	w20, #0xb
  4032e8:	12800102 	mov	w2, #0xfffffff7            	// #-9
  4032ec:	5a9f1042 	csinv	w2, w2, wzr, ne  // ne = any
    sctx->state = ISOTP_TX_ERR;
  4032f0:	79418020 	ldrh	w0, [x1, #192]
    sctx->error = err;
  4032f4:	39030c22 	strb	w2, [x1, #195]
    sctx->state = ISOTP_TX_ERR;
  4032f8:	12002c00 	and	w0, w0, #0xfff
  4032fc:	32114000 	orr	w0, w0, #0xffff8000
  403300:	79018020 	strh	w0, [x1, #192]
  403304:	39430820 	ldrb	w0, [x1, #194]
  403308:	121c6c00 	and	w0, w0, #0xfffffff0
  40330c:	39030820 	strb	w0, [x1, #194]
}
  403310:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403314:	f9475c00 	ldr	x0, [x0, #3768]
  403318:	f9403fe2 	ldr	x2, [sp, #120]
  40331c:	f9400001 	ldr	x1, [x0]
  403320:	eb010042 	subs	x2, x2, x1
  403324:	d2800001 	mov	x1, #0x0                   	// #0
  403328:	54000040 	b.eq	403330 <send_work_handler+0x424>  // b.none
  40332c:	97fff87d 	bl	401520 <__stack_chk_fail@plt>
  403330:	a94153f3 	ldp	x19, x20, [sp, #16]
  403334:	a9425bf5 	ldp	x21, x22, [sp, #32]
  403338:	a94363f7 	ldp	x23, x24, [sp, #48]
  40333c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  403340:	a94573fb 	ldp	x27, x28, [sp, #80]
  403344:	a8c87bfd 	ldp	x29, x30, [sp], #128
  403348:	d65f03c0 	ret

000000000040334c <receive_send_fc>:
{
  40334c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    *data++ = ISOTP_PCI_TYPE_FC | fs;
  403350:	321c0421 	orr	w1, w1, #0x30
{
  403354:	910003fd 	mov	x29, sp
  403358:	f9000bf3 	str	x19, [sp, #16]
  40335c:	aa0003f3 	mov	x19, x0
  403360:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403364:	f9475c00 	ldr	x0, [x0, #3768]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  403368:	f9400663 	ldr	x3, [x19, #8]
{
  40336c:	f9400002 	ldr	x2, [x0]
  403370:	f9001fe2 	str	x2, [sp, #56]
  403374:	d2800002 	mov	x2, #0x0                   	// #0
              | ((rctx->sender_addr & 0xFF) << 8)
  403378:	79402262 	ldrh	w2, [x19, #16]
        .id = (rctx->sender_addr & 0xFFFF0000) | ((rctx->sender_addr & 0xFF00) >> 8)
  40337c:	b9401260 	ldr	w0, [x19, #16]
              | ((rctx->sender_addr & 0xFF) << 8)
  403380:	5ac00442 	rev16	w2, w2
    struct can_frame frame = {
  403384:	a902ffff 	stp	xzr, xzr, [sp, #40]
              | ((rctx->sender_addr & 0xFF) << 8)
  403388:	12003c42 	and	w2, w2, #0xffff
        .id = (rctx->sender_addr & 0xFFFF0000) | ((rctx->sender_addr & 0xFF00) >> 8)
  40338c:	12103c00 	and	w0, w0, #0xffff0000
              | ((rctx->sender_addr & 0xFF) << 8)
  403390:	2a020000 	orr	w0, w0, w2
    struct can_frame frame = {
  403394:	52800002 	mov	w2, #0x0                   	// #0
  403398:	33007002 	bfxil	w2, w0, #0, #29
  40339c:	b9002be2 	str	w2, [sp, #40]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  4033a0:	f9400862 	ldr	x2, [x3, #16]
  4033a4:	39400840 	ldrb	w0, [x2, #2]
    *data++ = ISOTP_PCI_TYPE_FC | fs;
  4033a8:	3900c3e1 	strb	w1, [sp, #48]
            CAN_FRAME_IDE | ((rctx->ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  4033ac:	d341fc00 	lsr	x0, x0, #1
  4033b0:	121e0000 	and	w0, w0, #0x4
  4033b4:	32000000 	orr	w0, w0, #0x1
    struct can_frame frame = {
  4033b8:	3900b7e0 	strb	w0, [sp, #45]
    *data++ = rctx->ctx->opts->bs;
  4033bc:	39400040 	ldrb	w0, [x2]
  4033c0:	3900c7e0 	strb	w0, [sp, #49]
    *data++ = rctx->ctx->opts->stmin;
  4033c4:	39400440 	ldrb	w0, [x2, #1]
  4033c8:	3900cbe0 	strb	w0, [sp, #50]
    frame.dlc = can_bytes_to_dlc(payload_len);
  4033cc:	52800060 	mov	w0, #0x3                   	// #3
  4033d0:	3900b3e0 	strb	w0, [sp, #44]
    ret = can_send(rctx->ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), receive_can_tx, rctx);
  4033d4:	f9400060 	ldr	x0, [x3]
  4033d8:	f0ffffe3 	adrp	x3, 402000 <__divtf3+0x780>
  4033dc:	aa1303e4 	mov	x4, x19
  4033e0:	9112f063 	add	x3, x3, #0x4bc
  4033e4:	9100a3e1 	add	x1, sp, #0x28
  4033e8:	d2800c82 	mov	x2, #0x64                  	// #100
  4033ec:	9400226f 	bl	40bda8 <z_impl_can_send>
    if (ret) {
  4033f0:	340002a0 	cbz	w0, 403444 <receive_send_fc+0xf8>
        LOG_ERR("Can't send FC, (%d)", ret);
  4033f4:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4033f8:	2a0003e7 	mov	w7, w0
  4033fc:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403400:	52800000 	mov	w0, #0x0                   	// #0
  403404:	f9478421 	ldr	x1, [x1, #3848]
  403408:	910108c6 	add	x6, x6, #0x42
  40340c:	52800005 	mov	w5, #0x0                   	// #0
  403410:	d2800004 	mov	x4, #0x0                   	// #0
  403414:	d2800003 	mov	x3, #0x0                   	// #0
  403418:	52800022 	mov	w2, #0x1                   	// #1
  40341c:	97fffbdc 	bl	40238c <z_log_msg_runtime_create.constprop.0>
    rctx->state = ISOTP_RX_STATE_ERR;
  403420:	b940a260 	ldr	w0, [x19, #160]
  403424:	528e0001 	mov	w1, #0x7000                	// #28672
  403428:	72bfe001 	movk	w1, #0xff00, lsl #16
  40342c:	12005c00 	and	w0, w0, #0xffffff
  403430:	120c5c00 	and	w0, w0, #0xfff00fff
  403434:	2a010000 	orr	w0, w0, w1
  403438:	b900a260 	str	w0, [x19, #160]
        receive_state_machine(rctx);
  40343c:	aa1303e0 	mov	x0, x19
  403440:	9400000c 	bl	403470 <receive_state_machine>
}
  403444:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403448:	f9475c00 	ldr	x0, [x0, #3768]
  40344c:	f9401fe2 	ldr	x2, [sp, #56]
  403450:	f9400001 	ldr	x1, [x0]
  403454:	eb010042 	subs	x2, x2, x1
  403458:	d2800001 	mov	x1, #0x0                   	// #0
  40345c:	54000040 	b.eq	403464 <receive_send_fc+0x118>  // b.none
  403460:	97fff830 	bl	401520 <__stack_chk_fail@plt>
  403464:	f9400bf3 	ldr	x19, [sp, #16]
  403468:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40346c:	d65f03c0 	ret

0000000000403470 <receive_state_machine>:
{
  403470:	d100c3ff 	sub	sp, sp, #0x30
  403474:	a9017bfd 	stp	x29, x30, [sp, #16]
  403478:	910043fd 	add	x29, sp, #0x10
    switch (rctx->state) {
  40347c:	f9405007 	ldr	x7, [x0, #160]
{
  403480:	f90017e0 	str	x0, [sp, #40]
    switch (rctx->state) {
  403484:	530c4ce1 	ubfx	w1, w7, #12, #8
  403488:	51000421 	sub	w1, w1, #0x1
  40348c:	71001c3f 	cmp	w1, #0x7
  403490:	540001e8 	b.hi	4034cc <receive_state_machine+0x5c>  // b.pmore
  403494:	900000a2 	adrp	x2, 417000 <z_abort_timeout+0x38>
  403498:	91378042 	add	x2, x2, #0xde0
  40349c:	78615842 	ldrh	w2, [x2, w1, uxtw #1]
  4034a0:	10000061 	adr	x1, 4034ac <receive_state_machine+0x3c>
  4034a4:	8b22a822 	add	x2, x1, w2, sxth #2
  4034a8:	d61f0040 	br	x2
            rctx->rem_len = 0;
  4034ac:	aa0003e1 	mov	x1, x0
  4034b0:	784a0c22 	ldrh	w2, [x1, #160]!
            rctx->state = ISOTP_RX_STATE_RECYCLE;
  4034b4:	128fffe2 	mov	w2, #0xffff8000            	// #-32768
  4034b8:	79014002 	strh	w2, [x0, #160]
  4034bc:	39400822 	ldrb	w2, [x1, #2]
  4034c0:	121c6c42 	and	w2, w2, #0xfffffff0
  4034c4:	39000822 	strb	w2, [x1, #2]
                receive_state_machine(rctx);
  4034c8:	97ffffea 	bl	403470 <receive_state_machine>
}
  4034cc:	a9417bfd 	ldp	x29, x30, [sp, #16]
  4034d0:	9100c3ff 	add	sp, sp, #0x30
  4034d4:	d65f03c0 	ret
            if (rctx->ctx->opts->bs == 0
  4034d8:	f9400401 	ldr	x1, [x0, #8]
  4034dc:	f9400821 	ldr	x1, [x1, #16]
  4034e0:	39400021 	ldrb	w1, [x1]
  4034e4:	35000321 	cbnz	w1, 403548 <receive_state_machine+0xd8>
                && rctx->rem_len > CONFIG_ISOTP_FAST_RX_MAX_PACKET_COUNT * (CAN_MAX_DLEN - 1))
  4034e8:	12002ce7 	and	w7, w7, #0xfff
  4034ec:	7100e0ff 	cmp	w7, #0x38
  4034f0:	540002e9 	b.ls	40354c <receive_state_machine+0xdc>  // b.plast
                LOG_ERR("Pkt length is %d but buffer has only %d bytes", rctx->rem_len,
  4034f4:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4034f8:	52800700 	mov	w0, #0x38                  	// #56
  4034fc:	b90003e0 	str	w0, [sp]
  403500:	52800022 	mov	w2, #0x1                   	// #1
  403504:	f9478421 	ldr	x1, [x1, #3848]
  403508:	52800000 	mov	w0, #0x0                   	// #0
  40350c:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403510:	52800005 	mov	w5, #0x0                   	// #0
  403514:	910158c6 	add	x6, x6, #0x56
  403518:	d2800004 	mov	x4, #0x0                   	// #0
  40351c:	d2800003 	mov	x3, #0x0                   	// #0
  403520:	97fffb9b 	bl	40238c <z_log_msg_runtime_create.constprop.0>
                receive_report_error(rctx, ISOTP_N_BUFFER_OVERFLW);
  403524:	f94017e0 	ldr	x0, [sp, #40]
    rctx->state = ISOTP_RX_STATE_ERR;
  403528:	528e0002 	mov	w2, #0x7000                	// #28672
  40352c:	72bf0002 	movk	w2, #0xf800, lsl #16
  403530:	b940a001 	ldr	w1, [x0, #160]
  403534:	12005c21 	and	w1, w1, #0xffffff
  403538:	120c5c21 	and	w1, w1, #0xfff00fff
  40353c:	2a020021 	orr	w1, w1, w2
  403540:	b900a001 	str	w1, [x0, #160]
  403544:	17ffffe1 	b	4034c8 <receive_state_machine+0x58>
                rctx->bs = rctx->ctx->opts->bs;
  403548:	39029401 	strb	w1, [x0, #165]
            rctx->wft = ISOTP_WFT_FIRST;
  40354c:	12800001 	mov	w1, #0xffffffff            	// #-1
  403550:	39029001 	strb	w1, [x0, #164]
            rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  403554:	79414001 	ldrh	w1, [x0, #160]
  403558:	91028002 	add	x2, x0, #0xa0
  40355c:	12002c21 	and	w1, w1, #0xfff
  403560:	32140421 	orr	w1, w1, #0x3000
  403564:	79014001 	strh	w1, [x0, #160]
  403568:	aa0203e1 	mov	x1, x2
  40356c:	39400842 	ldrb	w2, [x2, #2]
  403570:	121c6c42 	and	w2, w2, #0xfffffff0
  403574:	39000822 	strb	w2, [x1, #2]
            k_timer_stop(&rctx->timer);
  403578:	9100e000 	add	x0, x0, #0x38
  40357c:	97fffb63 	bl	402308 <k_timer_stop>
            rctx->state = ISOTP_RX_STATE_SEND_FC;
  403580:	f94017e1 	ldr	x1, [sp, #40]
  403584:	79414020 	ldrh	w0, [x1, #160]
  403588:	12002c00 	and	w0, w0, #0xfff
  40358c:	32120000 	orr	w0, w0, #0x4000
  403590:	79014020 	strh	w0, [x1, #160]
  403594:	39428820 	ldrb	w0, [x1, #162]
  403598:	121c6c00 	and	w0, w0, #0xfffffff0
  40359c:	39028820 	strb	w0, [x1, #162]
            receive_send_fc(rctx, ISOTP_PCI_FS_CTS);
  4035a0:	f94017e0 	ldr	x0, [sp, #40]
  4035a4:	52800001 	mov	w1, #0x0                   	// #0
  4035a8:	97ffff69 	bl	40334c <receive_send_fc>
            k_timer_start(&rctx->timer, K_MSEC(ISOTP_CR_TIMEOUT_MS), K_NO_WAIT);
  4035ac:	f94017e0 	ldr	x0, [sp, #40]
  4035b0:	9100e000 	add	x0, x0, #0x38
  4035b4:	d2800c81 	mov	x1, #0x64                  	// #100
  4035b8:	d2800002 	mov	x2, #0x0                   	// #0
  4035bc:	94005031 	bl	417680 <z_impl_k_timer_start>
            rctx->state = ISOTP_RX_STATE_WAIT_CF;
  4035c0:	f94017e1 	ldr	x1, [sp, #40]
  4035c4:	528a0003 	mov	w3, #0x5000                	// #20480
  4035c8:	79414020 	ldrh	w0, [x1, #160]
  4035cc:	12002c00 	and	w0, w0, #0xfff
  4035d0:	2a030000 	orr	w0, w0, w3
                rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  4035d4:	79014020 	strh	w0, [x1, #160]
  4035d8:	39428820 	ldrb	w0, [x1, #162]
  4035dc:	121c6c00 	and	w0, w0, #0xfffffff0
  4035e0:	39028820 	strb	w0, [x1, #162]
                break;
  4035e4:	17ffffba 	b	4034cc <receive_state_machine+0x5c>
            if (++rctx->wft < CONFIG_ISOTP_WFTMAX) {
  4035e8:	39429007 	ldrb	w7, [x0, #164]
  4035ec:	110004e7 	add	w7, w7, #0x1
  4035f0:	12001ce7 	and	w7, w7, #0xff
  4035f4:	39029007 	strb	w7, [x0, #164]
  4035f8:	710024ff 	cmp	w7, #0x9
  4035fc:	540001a8 	b.hi	403630 <receive_state_machine+0x1c0>  // b.pmore
                receive_send_fc(rctx, ISOTP_PCI_FS_WAIT);
  403600:	52800021 	mov	w1, #0x1                   	// #1
  403604:	97ffff52 	bl	40334c <receive_send_fc>
                k_timer_start(&rctx->timer, K_MSEC(ISOTP_ALLOC_TIMEOUT_MS), K_NO_WAIT);
  403608:	f94017e0 	ldr	x0, [sp, #40]
  40360c:	9100e000 	add	x0, x0, #0x38
  403610:	d2800b41 	mov	x1, #0x5a                  	// #90
  403614:	d2800002 	mov	x2, #0x0                   	// #0
  403618:	9400501a 	bl	417680 <z_impl_k_timer_start>
                rctx->state = ISOTP_RX_STATE_TRY_ALLOC;
  40361c:	f94017e1 	ldr	x1, [sp, #40]
  403620:	79414020 	ldrh	w0, [x1, #160]
  403624:	12002c00 	and	w0, w0, #0xfff
  403628:	32140400 	orr	w0, w0, #0x3000
  40362c:	17ffffea 	b	4035d4 <receive_state_machine+0x164>
            LOG_ERR("Sent %d wait frames. Giving up to alloc now", rctx->wft);
  403630:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  403634:	52800022 	mov	w2, #0x1                   	// #1
  403638:	52800000 	mov	w0, #0x0                   	// #0
  40363c:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403640:	f9478421 	ldr	x1, [x1, #3848]
  403644:	910210c6 	add	x6, x6, #0x84
  403648:	52800005 	mov	w5, #0x0                   	// #0
  40364c:	d2800004 	mov	x4, #0x0                   	// #0
  403650:	d2800003 	mov	x3, #0x0                   	// #0
  403654:	97fffb4e 	bl	40238c <z_log_msg_runtime_create.constprop.0>
            receive_report_error(rctx, ISOTP_N_BUFFER_OVERFLW);
  403658:	f94017e1 	ldr	x1, [sp, #40]
    rctx->state = ISOTP_RX_STATE_ERR;
  40365c:	528e0002 	mov	w2, #0x7000                	// #28672
  403660:	72bf0002 	movk	w2, #0xf800, lsl #16
  403664:	b940a020 	ldr	w0, [x1, #160]
  403668:	12005c00 	and	w0, w0, #0xffffff
  40366c:	120c5c00 	and	w0, w0, #0xfff00fff
  403670:	2a020000 	orr	w0, w0, w2
  403674:	b900a020 	str	w0, [x1, #160]
            k_timer_stop(&rctx->timer);
  403678:	f94017e0 	ldr	x0, [sp, #40]
  40367c:	9100e000 	add	x0, x0, #0x38
  403680:	97fffb22 	bl	402308 <k_timer_stop>
            if (rctx->ctx->recv_error_callback) {
  403684:	f94017e0 	ldr	x0, [sp, #40]
  403688:	f9400401 	ldr	x1, [x0, #8]
  40368c:	f9401423 	ldr	x3, [x1, #40]
  403690:	b40000a3 	cbz	x3, 4036a4 <receive_state_machine+0x234>
                rctx->ctx->recv_error_callback(rctx->error, rctx->sender_addr,
  403694:	f9401022 	ldr	x2, [x1, #32]
  403698:	b9401001 	ldr	w1, [x0, #16]
  40369c:	39428c00 	ldrb	w0, [x0, #163]
  4036a0:	d63f0060 	blr	x3
            if (rctx->error == ISOTP_N_BUFFER_OVERFLW) {
  4036a4:	f94017e0 	ldr	x0, [sp, #40]
  4036a8:	39c28c01 	ldrsb	w1, [x0, #163]
  4036ac:	3100203f 	cmn	w1, #0x8
  4036b0:	54000061 	b.ne	4036bc <receive_state_machine+0x24c>  // b.any
                receive_send_fc(rctx, ISOTP_PCI_FS_OVFLW);
  4036b4:	52800041 	mov	w1, #0x2                   	// #2
  4036b8:	97ffff25 	bl	40334c <receive_send_fc>
    free_recv_ctx(rctx);
  4036bc:	9100a3e0 	add	x0, sp, #0x28
  4036c0:	97fffbec 	bl	402670 <free_recv_ctx>
            rctx->ctx->recv_callback(rctx->buffer, 0, rctx->sender_addr, rctx->ctx->recv_cb_arg);
  4036c4:	f94017e0 	ldr	x0, [sp, #40]
  4036c8:	f9400401 	ldr	x1, [x0, #8]
  4036cc:	b9401002 	ldr	w2, [x0, #16]
  4036d0:	f9404800 	ldr	x0, [x0, #144]
  4036d4:	a9418c24 	ldp	x4, x3, [x1, #24]
  4036d8:	52800001 	mov	w1, #0x0                   	// #0
  4036dc:	d63f0080 	blr	x4
            rctx->state = ISOTP_RX_STATE_UNBOUND;
  4036e0:	f94017e1 	ldr	x1, [sp, #40]
  4036e4:	128dffe3 	mov	w3, #0xffff9000            	// #-28672
  4036e8:	79414020 	ldrh	w0, [x1, #160]
  4036ec:	12002c00 	and	w0, w0, #0xfff
  4036f0:	2a030000 	orr	w0, w0, w3
  4036f4:	79014020 	strh	w0, [x1, #160]
  4036f8:	39428820 	ldrb	w0, [x1, #162]
  4036fc:	121c6c00 	and	w0, w0, #0xfffffff0
  403700:	39028820 	strb	w0, [x1, #162]
    free_recv_ctx(rctx);
  403704:	9100a3e0 	add	x0, sp, #0x28
  403708:	97fffbda 	bl	402670 <free_recv_ctx>
}
  40370c:	17ffff70 	b	4034cc <receive_state_machine+0x5c>

0000000000403710 <receive_work_handler>:
    receive_state_machine(rctx);
  403710:	d1006000 	sub	x0, x0, #0x18
  403714:	17ffff57 	b	403470 <receive_state_machine>

0000000000403718 <isotp_fast_bind>:
int isotp_fast_bind(struct isotp_fast_ctx *ctx, const struct device *can_dev,
                    const isotp_fast_msg_id my_addr, const struct isotp_fast_opts *opts,
                    isotp_fast_recv_callback_t recv_callback, void *recv_cb_arg,
                    isotp_fast_recv_error_callback_t recv_error_callback,
                    isotp_fast_send_callback_t sent_callback)
{
  403718:	d10143ff 	sub	sp, sp, #0x50
  40371c:	a9017bfd 	stp	x29, x30, [sp, #16]
  403720:	910043fd 	add	x29, sp, #0x10
  403724:	f90013f3 	str	x19, [sp, #32]
  403728:	aa0003f3 	mov	x19, x0
  40372c:	aa0103e0 	mov	x0, x1
  403730:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  403734:	f9475c21 	ldr	x1, [x1, #3768]
  403738:	f9400028 	ldr	x8, [x1]
  40373c:	f90027e8 	str	x8, [sp, #72]
  403740:	d2800008 	mov	x8, #0x0                   	// #0
	list->head = NULL;
  403744:	90000181 	adrp	x1, 433000 <obj_0x28+0x18>
  403748:	9102e028 	add	x8, x1, #0xb8
    sys_slist_init(&ctx->wait_recv_list);
#endif

    ctx->can_dev = can_dev;
    ctx->opts = opts;
    ctx->recv_callback = recv_callback;
  40374c:	a9011263 	stp	x3, x4, [x19, #16]
  403750:	f9005c3f 	str	xzr, [x1, #184]
  403754:	90000181 	adrp	x1, 433000 <obj_0x28+0x18>
	list->tail = NULL;
  403758:	f900051f 	str	xzr, [x8, #8]
	list->head = NULL;
  40375c:	9102a028 	add	x8, x1, #0xa8
  403760:	f900543f 	str	xzr, [x1, #168]
    filter->id = my_addr;
  403764:	f9401fe1 	ldr	x1, [sp, #56]
	list->tail = NULL;
  403768:	f900051f 	str	xzr, [x8, #8]
    ctx->can_dev = can_dev;
  40376c:	f9000260 	str	x0, [x19]
    ctx->recv_cb_arg = recv_cb_arg;
    ctx->recv_error_callback = recv_error_callback;
  403770:	a9021a65 	stp	x5, x6, [x19, #32]
    filter->id = my_addr;
  403774:	92030821 	and	x1, x1, #0xe0000000e0000000
    ctx->sent_callback = sent_callback;
  403778:	f9001a67 	str	x7, [x19, #48]
    ctx->my_addr = my_addr;
  40377c:	b9003a62 	str	w2, [x19, #56]
    filter->id = my_addr;
  403780:	92407042 	and	x2, x2, #0x1fffffff
  403784:	b2584442 	orr	x2, x2, #0x3ffff0000000000
  403788:	aa010042 	orr	x2, x2, x1
                    | ((opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FILTER_FDF : 0);
  40378c:	39400861 	ldrb	w1, [x3, #2]
    filter->id = my_addr;
  403790:	f9001fe2 	str	x2, [sp, #56]
                    | ((opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FILTER_FDF : 0);
  403794:	528000a2 	mov	w2, #0x5                   	// #5
  403798:	121d0021 	and	w1, w1, #0x8
	return api->add_rx_filter(dev, callback, user_data, filter);
  40379c:	9100e3e3 	add	x3, sp, #0x38
  4037a0:	2a020021 	orr	w1, w1, w2
    filter->flags = CAN_FILTER_DATA | CAN_FILTER_IDE
  4037a4:	390103e1 	strb	w1, [sp, #64]
  4037a8:	f9400801 	ldr	x1, [x0, #16]
  4037ac:	aa1303e2 	mov	x2, x19
  4037b0:	f9401824 	ldr	x4, [x1, #48]
  4037b4:	f0ffffe1 	adrp	x1, 402000 <__divtf3+0x780>
  4037b8:	911fa021 	add	x1, x1, #0x7e8
  4037bc:	d63f0080 	blr	x4

    struct can_filter filter;
    prepare_filter(&filter, my_addr, opts);
    ctx->filter_id = can_add_rx_filter(ctx->can_dev, can_rx_callback, ctx, &filter);
  4037c0:	b9000a60 	str	w0, [x19, #8]

    LOG_INF("Successfully bound to %x:%x", filter.id, filter.mask);
  4037c4:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4037c8:	52800062 	mov	w2, #0x3                   	// #3
  4037cc:	f9401fe7 	ldr	x7, [sp, #56]
  4037d0:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  4037d4:	f9478421 	ldr	x1, [x1, #3848]
  4037d8:	9102c0c6 	add	x6, x6, #0xb0
  4037dc:	d360f0e0 	ubfx	x0, x7, #32, #29
  4037e0:	b90003e0 	str	w0, [sp]
  4037e4:	120070e7 	and	w7, w7, #0x1fffffff
  4037e8:	52800000 	mov	w0, #0x0                   	// #0
  4037ec:	52800005 	mov	w5, #0x0                   	// #0
  4037f0:	d2800004 	mov	x4, #0x0                   	// #0
  4037f4:	d2800003 	mov	x3, #0x0                   	// #0
  4037f8:	97fffae5 	bl	40238c <z_log_msg_runtime_create.constprop.0>

    return ISOTP_N_OK;
}
  4037fc:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403800:	f9475c00 	ldr	x0, [x0, #3768]
  403804:	f94027e2 	ldr	x2, [sp, #72]
  403808:	f9400001 	ldr	x1, [x0]
  40380c:	eb010042 	subs	x2, x2, x1
  403810:	d2800001 	mov	x1, #0x0                   	// #0
  403814:	54000040 	b.eq	40381c <isotp_fast_bind+0x104>  // b.none
  403818:	97fff742 	bl	401520 <__stack_chk_fail@plt>
  40381c:	52800000 	mov	w0, #0x0                   	// #0
  403820:	a9417bfd 	ldp	x29, x30, [sp, #16]
  403824:	f94013f3 	ldr	x19, [sp, #32]
  403828:	910143ff 	add	sp, sp, #0x50
  40382c:	d65f03c0 	ret

0000000000403830 <isotp_fast_send>:
}
#endif /* CONFIG_ISOTP_FAST_BLOCKING_RECEIVE */

int isotp_fast_send(struct isotp_fast_ctx *ctx, const uint8_t *data, size_t len,
                    const isotp_fast_node_id their_id, void *cb_arg)
{
  403830:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    const isotp_fast_msg_id recipient_addr = (ctx->my_addr & 0xFFFF0000)
                                             | (isotp_fast_get_addr_recipient(ctx->my_addr))
                                             | (their_id << ISOTP_FIXED_ADDR_TA_POS);
  403834:	53181c63 	ubfiz	w3, w3, #8, #8
{
  403838:	910003fd 	mov	x29, sp
  40383c:	a90363f7 	stp	x23, x24, [sp, #48]
  403840:	aa0403f7 	mov	x23, x4
  403844:	d0000164 	adrp	x4, 431000 <__FRAME_END__+0x10804>
  403848:	a90153f3 	stp	x19, x20, [sp, #16]
  40384c:	aa0203f3 	mov	x19, x2
  403850:	f9475c84 	ldr	x4, [x4, #3768]
  403854:	a9025bf5 	stp	x21, x22, [sp, #32]
  403858:	f90023f9 	str	x25, [sp, #64]
  40385c:	aa0003f9 	mov	x25, x0
  403860:	f9400085 	ldr	x5, [x4]
  403864:	f90037e5 	str	x5, [sp, #104]
  403868:	d2800005 	mov	x5, #0x0                   	// #0
    const isotp_fast_msg_id recipient_addr = (ctx->my_addr & 0xFFFF0000)
  40386c:	b9403804 	ldr	w4, [x0, #56]
  403870:	12103c96 	and	w22, w4, #0xffff0000
  403874:	2a0302d6 	orr	w22, w22, w3
  403878:	d3483c84 	ubfx	x4, x4, #8, #8
  40387c:	2a0402d6 	orr	w22, w22, w4
    if (len <= (CAN_MAX_DLEN - ISOTP_FAST_SF_LEN_BYTE)) {
  403880:	f1001c5f 	cmp	x2, #0x7
  403884:	540004a8 	b.hi	403918 <isotp_fast_send+0xe8>  // b.pmore
        struct can_frame frame = {
  403888:	52800000 	mov	w0, #0x0                   	// #0
            .dlc = can_bytes_to_dlc(len + ISOTP_FAST_SF_LEN_BYTE),
  40388c:	12001c53 	and	w19, w2, #0xff
        struct can_frame frame = {
  403890:	330072c0 	bfxil	w0, w22, #0, #29
  403894:	a905ffff 	stp	xzr, xzr, [sp, #88]
  403898:	b9005be0 	str	w0, [sp, #88]
            .dlc = can_bytes_to_dlc(len + ISOTP_FAST_SF_LEN_BYTE),
  40389c:	11000660 	add	w0, w19, #0x1
  4038a0:	97fffaba 	bl	402388 <can_bytes_to_dlc>
        struct can_frame frame = {
  4038a4:	390173e0 	strb	w0, [sp, #92]
            .id = recipient_addr,
            .flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  4038a8:	f9400b20 	ldr	x0, [x25, #16]
  4038ac:	39400803 	ldrb	w3, [x0, #2]
  4038b0:	910187e0 	add	x0, sp, #0x61
        }
        else {
            frame.data[0] = (uint8_t)len;
        }
#else
        frame.data[0] = (uint8_t)len;
  4038b4:	390183f3 	strb	w19, [sp, #96]
            .flags = CAN_FRAME_IDE | ((ctx->opts->flags & ISOTP_MSG_FDF) != 0 ? CAN_FRAME_FDF : 0),
  4038b8:	d341fc63 	lsr	x3, x3, #1
  4038bc:	121e0063 	and	w3, w3, #0x4
  4038c0:	32000063 	orr	w3, w3, #0x1
        struct can_frame frame = {
  4038c4:	390177e3 	strb	w3, [sp, #93]
  4038c8:	d28000e3 	mov	x3, #0x7                   	// #7
  4038cc:	97fff6d5 	bl	401420 <__memcpy_chk@plt>
#endif
        memcpy(&frame.data[index], data, len);
        int ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A_TIMEOUT_MS), NULL, NULL);
  4038d0:	f9400320 	ldr	x0, [x25]
  4038d4:	d2800c82 	mov	x2, #0x64                  	// #100
  4038d8:	910163e1 	add	x1, sp, #0x58
  4038dc:	d2800004 	mov	x4, #0x0                   	// #0
  4038e0:	d2800003 	mov	x3, #0x0                   	// #0
  4038e4:	94002131 	bl	40bda8 <z_impl_can_send>
        ctx->sent_callback(ret, cb_arg);
        return ISOTP_N_OK;
  4038e8:	52800015 	mov	w21, #0x0                   	// #0
        ctx->sent_callback(ret, cb_arg);
  4038ec:	f9401b22 	ldr	x2, [x25, #48]
  4038f0:	aa1703e1 	mov	x1, x23
  4038f4:	d63f0040 	blr	x2
        k_timer_init(&context->timer, send_timeout_handler, NULL);

        k_work_submit(&context->work);
    }
    return ISOTP_N_OK;
  4038f8:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4038fc:	f9475c00 	ldr	x0, [x0, #3768]
  403900:	f94037e2 	ldr	x2, [sp, #104]
  403904:	f9400001 	ldr	x1, [x0]
  403908:	eb010042 	subs	x2, x2, x1
  40390c:	d2800001 	mov	x1, #0x0                   	// #0
  403910:	54000640 	b.eq	4039d8 <isotp_fast_send+0x1a8>  // b.none
  403914:	97fff703 	bl	401520 <__stack_chk_fail@plt>
        if (len > ISOTP_FAST_MAX_LEN) {
  403918:	f13ffc5f 	cmp	x2, #0xfff
  40391c:	54000568 	b.hi	4039c8 <isotp_fast_send+0x198>  // b.pmore
  403920:	aa0103f8 	mov	x24, x1
        int ret = get_send_ctx(ctx, recipient_addr, &context);
  403924:	910143e2 	add	x2, sp, #0x50
  403928:	2a1603e1 	mov	w1, w22
  40392c:	97fffb65 	bl	4026c0 <get_send_ctx>
  403930:	2a0003f5 	mov	w21, w0
        if (ret) {
  403934:	350004e0 	cbnz	w0, 4039d0 <isotp_fast_send+0x1a0>
        context->ctx = ctx;
  403938:	f9402bf4 	ldr	x20, [sp, #80]
        context->state = ISOTP_TX_SEND_FF;
  40393c:	12002e73 	and	w19, w19, #0xfff
  403940:	32130273 	orr	w19, w19, #0x2000
        context->ctx = ctx;
  403944:	f9000699 	str	x25, [x20, #8]
        context->recipient_addr = recipient_addr;
  403948:	b9001296 	str	w22, [x20, #16]
        context->data = data;
  40394c:	f9005e98 	str	x24, [x20, #184]
        context->bs = ctx->opts->bs;
  403950:	f9400b20 	ldr	x0, [x25, #16]
  403954:	39400000 	ldrb	w0, [x0]
  403958:	39034680 	strb	w0, [x20, #209]
        context->stmin = ctx->opts->stmin;
  40395c:	f9400b20 	ldr	x0, [x25, #16]
  403960:	39400400 	ldrb	w0, [x0, #1]
  403964:	39035280 	strb	w0, [x20, #212]
        context->rem_len = len;
  403968:	aa1403e0 	mov	x0, x20
  40396c:	784c0c01 	ldrh	w1, [x0, #192]!
        context->state = ISOTP_TX_SEND_FF;
  403970:	79018293 	strh	w19, [x20, #192]
  403974:	39400801 	ldrb	w1, [x0, #2]
  403978:	121c6c21 	and	w1, w1, #0xfffffff0
  40397c:	39000801 	strb	w1, [x0, #2]
        context->cb_arg = cb_arg;
  403980:	f9006697 	str	x23, [x20, #200]
	return z_impl_k_sem_init(sem, initial_count, limit);
  403984:	52800022 	mov	w2, #0x1                   	// #1
        k_work_init(&context->work, send_work_handler);
  403988:	91006293 	add	x19, x20, #0x18
  40398c:	91024280 	add	x0, x20, #0x90
  403990:	52800001 	mov	w1, #0x0                   	// #0
  403994:	94003ece 	bl	4134cc <z_impl_k_sem_init>
  403998:	aa1303e0 	mov	x0, x19
  40399c:	f0ffffe1 	adrp	x1, 402000 <__divtf3+0x780>
  4039a0:	913c3021 	add	x1, x1, #0xf0c
  4039a4:	94004131 	bl	413e68 <k_work_init>
        k_timer_init(&context->timer, send_timeout_handler, NULL);
  4039a8:	f0ffffe1 	adrp	x1, 402000 <__divtf3+0x780>
  4039ac:	91112021 	add	x1, x1, #0x448
  4039b0:	d2800002 	mov	x2, #0x0                   	// #0
  4039b4:	9100e280 	add	x0, x20, #0x38
  4039b8:	94004f2b 	bl	417664 <k_timer_init>
        k_work_submit(&context->work);
  4039bc:	aa1303e0 	mov	x0, x19
  4039c0:	940041b7 	bl	41409c <k_work_submit>
    return ISOTP_N_OK;
  4039c4:	17ffffcd 	b	4038f8 <isotp_fast_send+0xc8>
            return ISOTP_N_BUFFER_OVERFLW;
  4039c8:	128000f5 	mov	w21, #0xfffffff8            	// #-8
  4039cc:	17ffffcb 	b	4038f8 <isotp_fast_send+0xc8>
            return ISOTP_NO_NET_BUF_LEFT;
  4039d0:	12800155 	mov	w21, #0xfffffff5            	// #-11
  4039d4:	17ffffc9 	b	4038f8 <isotp_fast_send+0xc8>
  4039d8:	2a1503e0 	mov	w0, w21
  4039dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4039e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4039e4:	a94363f7 	ldp	x23, x24, [sp, #48]
  4039e8:	f94023f9 	ldr	x25, [sp, #64]
  4039ec:	a8c77bfd 	ldp	x29, x30, [sp], #112
  4039f0:	d65f03c0 	ret

00000000004039f4 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  4039f4:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  4039f8:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4039fc:	910003fd 	mov	x29, sp
  403a00:	f9475c00 	ldr	x0, [x0, #3768]
  403a04:	3d8023e0 	str	q0, [sp, #128]
  403a08:	3d8027e1 	str	q1, [sp, #144]
  403a0c:	3d802be2 	str	q2, [sp, #160]
  403a10:	3d802fe3 	str	q3, [sp, #176]
  403a14:	3d8033e4 	str	q4, [sp, #192]
  403a18:	3d8037e5 	str	q5, [sp, #208]
  403a1c:	3d803be6 	str	q6, [sp, #224]
  403a20:	3d803fe7 	str	q7, [sp, #240]
  403a24:	f90087e7 	str	x7, [sp, #264]
  403a28:	f9400002 	ldr	x2, [x0]
  403a2c:	f9003fe2 	str	x2, [sp, #120]
  403a30:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  403a34:	910443e0 	add	x0, sp, #0x110
  403a38:	a90383e0 	stp	x0, x0, [sp, #56]
  403a3c:	910403e0 	add	x0, sp, #0x100
  403a40:	9100e3e2 	add	x2, sp, #0x38
  403a44:	f90027e0 	str	x0, [sp, #72]
  403a48:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  403a4c:	b90053e0 	str	w0, [sp, #80]
  403a50:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  403a54:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  403a58:	910163e0 	add	x0, sp, #0x58
  403a5c:	ad400440 	ldp	q0, q1, [x2]
  403a60:	ad000400 	stp	q0, q1, [x0]
  403a64:	ad400400 	ldp	q0, q1, [x0]
  403a68:	910043e7 	add	x7, sp, #0x10
  403a6c:	52800062 	mov	w2, #0x3                   	// #3
  403a70:	52800000 	mov	w0, #0x0                   	// #0
  403a74:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403a78:	52800005 	mov	w5, #0x0                   	// #0
  403a7c:	910370c6 	add	x6, x6, #0xdc
  403a80:	d2800004 	mov	x4, #0x0                   	// #0
  403a84:	d2800003 	mov	x3, #0x0                   	// #0
  403a88:	ad0004e0 	stp	q0, q1, [x7]
  403a8c:	94000ec7 	bl	4075a8 <z_impl_z_log_msg_runtime_vcreate>
}
  403a90:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403a94:	f9475c00 	ldr	x0, [x0, #3768]
  403a98:	f9403fe2 	ldr	x2, [sp, #120]
  403a9c:	f9400001 	ldr	x1, [x0]
  403aa0:	eb010042 	subs	x2, x2, x1
  403aa4:	d2800001 	mov	x1, #0x0                   	// #0
  403aa8:	54000040 	b.eq	403ab0 <z_log_msg_runtime_create.constprop.0+0xbc>  // b.none
  403aac:	97fff69d 	bl	401520 <__stack_chk_fail@plt>
  403ab0:	a8d17bfd 	ldp	x29, x30, [sp], #272
  403ab4:	d65f03c0 	ret

0000000000403ab8 <thingset_sdk_init>:
{
    return k_work_reschedule_for_queue(&thingset_workq, dwork, delay);
}

static int thingset_sdk_init(void)
{
  403ab8:	d101c3ff 	sub	sp, sp, #0x70
  403abc:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403ac0:	a9037bfd 	stp	x29, x30, [sp, #48]
  403ac4:	9100c3fd 	add	x29, sp, #0x30
  403ac8:	f9475c00 	ldr	x0, [x0, #3768]
  403acc:	a90453f3 	stp	x19, x20, [sp, #64]
  403ad0:	f9400001 	ldr	x1, [x0]
  403ad4:	f90037e1 	str	x1, [sp, #104]
  403ad8:	d2800001 	mov	x1, #0x0                   	// #0
  403adc:	52800022 	mov	w2, #0x1                   	// #1
  403ae0:	2a0203e1 	mov	w1, w2
  403ae4:	f0000160 	adrp	x0, 432000 <__dso_handle>
    k_sem_init(&sbuf.lock, 1, 1);

    k_work_queue_init(&thingset_workq);
  403ae8:	90000193 	adrp	x19, 433000 <obj_0x28+0x18>
  403aec:	91002000 	add	x0, x0, #0x8
  403af0:	91032273 	add	x19, x19, #0xc8
  403af4:	94003e76 	bl	4134cc <z_impl_k_sem_init>
  403af8:	aa1303e0 	mov	x0, x19
  403afc:	9400416c 	bl	4140ac <k_work_queue_init>
    k_work_queue_start(&thingset_workq, thread_stack_area, K_THREAD_STACK_SIZEOF(thread_stack_area),
  403b00:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  403b04:	aa1303e0 	mov	x0, x19
  403b08:	d2800004 	mov	x4, #0x0                   	// #0
  403b0c:	52800043 	mov	w3, #0x2                   	// #2
  403b10:	f9479c21 	ldr	x1, [x1, #3896]
  403b14:	d2810002 	mov	x2, #0x800                 	// #2048
  403b18:	94004180 	bl	414118 <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
  403b1c:	b00000a1 	adrp	x1, 418000 <table.0+0x1d8>
  403b20:	aa1303e0 	mov	x0, x19
  403b24:	9103e821 	add	x1, x1, #0xfa
  403b28:	94003966 	bl	4120c0 <z_impl_k_thread_name_set>
                       CONFIG_THINGSET_SDK_THREAD_PRIORITY, NULL);

    k_thread_name_set(&thingset_workq.thread, "thingset_sdk");

    thingset_init_global(&ts);
  403b2c:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
        buf[i] = sys_rand32_get() & 0xFF;
  403b30:	910163f4 	add	x20, sp, #0x58
    uint8_t buf[12] = { 0 };
  403b34:	d2800013 	mov	x19, #0x0                   	// #0
    thingset_init_global(&ts);
  403b38:	f9472800 	ldr	x0, [x0, #3664]
  403b3c:	94002368 	bl	40c8dc <thingset_init_global>
    uint8_t buf[12] = { 0 };
  403b40:	f805a3ff 	stur	xzr, [sp, #90]
  403b44:	b00000a0 	adrp	x0, 418000 <table.0+0x1d8>
  403b48:	9105a000 	add	x0, x0, #0x168
  403b4c:	7900c7ff 	strh	wzr, [sp, #98]
  403b50:	79400000 	ldrh	w0, [x0]
  403b54:	7900b3e0 	strh	w0, [sp, #88]
	if (z_syscall_trap()) {
		return (uint32_t) arch_syscall_invoke0(K_SYSCALL_SYS_RAND32_GET);
	}
#endif
	compiler_barrier();
	return z_impl_sys_rand32_get();
  403b58:	94001a7c 	bl	40a548 <z_impl_sys_rand32_get>
        buf[i] = sys_rand32_get() & 0xFF;
  403b5c:	38336a80 	strb	w0, [x20, x19]
    for (int i = 0; i < sizeof(buf); i++) {
  403b60:	91000673 	add	x19, x19, #0x1
  403b64:	f100327f 	cmp	x19, #0xc
  403b68:	54ffff81 	b.ne	403b58 <thingset_sdk_init+0xa0>  // b.any
    crc = crc32_ieee(buf, 8);
  403b6c:	d0000173 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  403b70:	aa1403e0 	mov	x0, x20
  403b74:	d2800101 	mov	x1, #0x8                   	// #8
  403b78:	94000955 	bl	4060cc <crc32_ieee>
    memcpy(eui64, &crc, 4);
  403b7c:	f9470e73 	ldr	x19, [x19, #3608]
    crc = crc32_ieee(buf + 4, 8);
  403b80:	d2800101 	mov	x1, #0x8                   	// #8
# ifdef __va_arg_pack
__fortify_function int
__NTH (snprintf (char *__restrict __s, size_t __n,
		 const char *__restrict __fmt, ...))
{
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  403b84:	d0000174 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  403b88:	b9000260 	str	w0, [x19]
  403b8c:	910173e0 	add	x0, sp, #0x5c
  403b90:	9400094f 	bl	4060cc <crc32_ieee>
    snprintf(node_id, sizeof(node_id), "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X", eui64[0], eui64[1],
  403b94:	53187c01 	lsr	w1, w0, #24
    eui64[0] &= ~(1U << 1);
  403b98:	39400265 	ldrb	w5, [x19]
  403b9c:	d2800223 	mov	x3, #0x11                  	// #17
  403ba0:	b9000660 	str	w0, [x19, #4]
  403ba4:	52800022 	mov	w2, #0x1                   	// #1
  403ba8:	121e78a5 	and	w5, w5, #0xfffffffd
    snprintf(node_id, sizeof(node_id), "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X", eui64[0], eui64[1],
  403bac:	39400a67 	ldrb	w7, [x19, #2]
    eui64[0] &= ~(1U << 1);
  403bb0:	12001ca5 	and	w5, w5, #0xff
  403bb4:	39000265 	strb	w5, [x19]
    snprintf(node_id, sizeof(node_id), "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X", eui64[0], eui64[1],
  403bb8:	39400666 	ldrb	w6, [x19, #1]
  403bbc:	b00000a4 	adrp	x4, 418000 <table.0+0x1d8>
  403bc0:	b90023e1 	str	w1, [sp, #32]
  403bc4:	d3505c01 	ubfx	x1, x0, #16, #8
  403bc8:	b9001be1 	str	w1, [sp, #24]
  403bcc:	d3483c01 	ubfx	x1, x0, #8, #8
  403bd0:	12001c00 	and	w0, w0, #0xff
  403bd4:	b9000be0 	str	w0, [sp, #8]
  403bd8:	b90013e1 	str	w1, [sp, #16]
  403bdc:	91041c84 	add	x4, x4, #0x107
  403be0:	f9471e94 	ldr	x20, [x20, #3640]
  403be4:	aa0303e1 	mov	x1, x3
  403be8:	39400e60 	ldrb	w0, [x19, #3]
  403bec:	b90003e0 	str	w0, [sp]
  403bf0:	aa1403e0 	mov	x0, x20
  403bf4:	97fff60f 	bl	401430 <__snprintf_chk@plt>
    LOG_INF("ThingSet Node ID (EUI-64): %s", node_id);
  403bf8:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  403bfc:	52800062 	mov	w2, #0x3                   	// #3
  403c00:	52800000 	mov	w0, #0x0                   	// #0
  403c04:	aa1403e7 	mov	x7, x20
  403c08:	f946c821 	ldr	x1, [x1, #3472]
  403c0c:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403c10:	52800005 	mov	w5, #0x0                   	// #0
  403c14:	910370c6 	add	x6, x6, #0xdc
  403c18:	d2800004 	mov	x4, #0x0                   	// #0
  403c1c:	d2800003 	mov	x3, #0x0                   	// #0
  403c20:	97ffff75 	bl	4039f4 <z_log_msg_runtime_create.constprop.0>
    thingset_storage_load();
    thingset_set_update_callback(&ts, TS_SUBSET_NVM, thingset_storage_save_queued);
#endif

    return 0;
}
  403c24:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403c28:	f9475c00 	ldr	x0, [x0, #3768]
  403c2c:	f94037e2 	ldr	x2, [sp, #104]
  403c30:	f9400001 	ldr	x1, [x0]
  403c34:	eb010042 	subs	x2, x2, x1
  403c38:	d2800001 	mov	x1, #0x0                   	// #0
  403c3c:	54000040 	b.eq	403c44 <thingset_sdk_init+0x18c>  // b.none
  403c40:	97fff638 	bl	401520 <__stack_chk_fail@plt>
  403c44:	52800000 	mov	w0, #0x0                   	// #0
  403c48:	a9437bfd 	ldp	x29, x30, [sp, #48]
  403c4c:	a94453f3 	ldp	x19, x20, [sp, #64]
  403c50:	9101c3ff 	add	sp, sp, #0x70
  403c54:	d65f03c0 	ret

0000000000403c58 <thingset_sdk_shared_buffer>:
}
  403c58:	f0000160 	adrp	x0, 432000 <__dso_handle>
  403c5c:	91002000 	add	x0, x0, #0x8
  403c60:	d65f03c0 	ret

0000000000403c64 <thingset_sdk_reschedule_work>:
    return k_work_reschedule_for_queue(&thingset_workq, dwork, delay);
  403c64:	aa0103e2 	mov	x2, x1
  403c68:	aa0003e1 	mov	x1, x0
  403c6c:	90000180 	adrp	x0, 433000 <obj_0x28+0x18>
  403c70:	91032000 	add	x0, x0, #0xc8
  403c74:	140041b0 	b	414334 <k_work_reschedule_for_queue>

0000000000403c78 <thingset_can_report_rx_cb>:
    /* Optimization: store in internal database to exclude from potentially available addresses */
}

static void thingset_can_report_rx_cb(const struct device *dev, struct can_frame *frame,
                                      void *user_data)
{
  403c78:	aa0103e4 	mov	x4, x1
    struct thingset_can *ts_can = user_data;
    uint16_t data_id = THINGSET_CAN_DATA_ID_GET(frame->id);
  403c7c:	b8408423 	ldr	w3, [x1], #8
        }
    }
    else
#endif /* CONFIG_THINGSET_CAN_PACKETIZED_REPORTS_RX */
    {
        ts_can->report_rx_cb(data_id, frame->data, can_dlc_to_bytes(frame->dlc), source_addr);
  403c80:	f941f445 	ldr	x5, [x2, #1000]
  403c84:	39401084 	ldrb	w4, [x4, #4]
    uint16_t data_id = THINGSET_CAN_DATA_ID_GET(frame->id);
  403c88:	d3485c60 	ubfx	x0, x3, #8, #16
    uint8_t source_addr = THINGSET_CAN_SOURCE_GET(frame->id);
  403c8c:	12001c63 	and	w3, w3, #0xff
	return dlc > 0x0F ? 64 : dlc_table[dlc];
  403c90:	71003c9f 	cmp	w4, #0xf
  403c94:	540000e8 	b.hi	403cb0 <thingset_can_report_rx_cb+0x38>  // b.pmore
  403c98:	b00000a2 	adrp	x2, 418000 <table.0+0x1d8>
  403c9c:	910e4042 	add	x2, x2, #0x390
  403ca0:	3864c842 	ldrb	w2, [x2, w4, sxtw]
        ts_can->report_rx_cb(data_id, frame->data, can_dlc_to_bytes(frame->dlc), source_addr);
  403ca4:	92401c42 	and	x2, x2, #0xff
  403ca8:	aa0503f0 	mov	x16, x5
  403cac:	d61f0200 	br	x16
  403cb0:	52800802 	mov	w2, #0x40                  	// #64
  403cb4:	17fffffc 	b	403ca4 <thingset_can_report_rx_cb+0x2c>

0000000000403cb8 <thingset_can_report_tx_cb>:
}

static void thingset_can_report_tx_cb(const struct device *dev, int error, void *user_data)
{
    /* Do nothing: Reports are fire and forget. */
}
  403cb8:	d65f03c0 	ret

0000000000403cbc <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  403cbc:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  403cc0:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403cc4:	12001c42 	and	w2, w2, #0xff
  403cc8:	910003fd 	mov	x29, sp
  403ccc:	f9475c00 	ldr	x0, [x0, #3768]
  403cd0:	3d8023e0 	str	q0, [sp, #128]
  403cd4:	3d8027e1 	str	q1, [sp, #144]
  403cd8:	3d802be2 	str	q2, [sp, #160]
  403cdc:	3d802fe3 	str	q3, [sp, #176]
  403ce0:	3d8033e4 	str	q4, [sp, #192]
  403ce4:	3d8037e5 	str	q5, [sp, #208]
  403ce8:	3d803be6 	str	q6, [sp, #224]
  403cec:	3d803fe7 	str	q7, [sp, #240]
  403cf0:	f90087e7 	str	x7, [sp, #264]
  403cf4:	f9400003 	ldr	x3, [x0]
  403cf8:	f9003fe3 	str	x3, [sp, #120]
  403cfc:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(ap, fmt);
  403d00:	910443e0 	add	x0, sp, #0x110
  403d04:	a90383e0 	stp	x0, x0, [sp, #56]
  403d08:	910403e0 	add	x0, sp, #0x100
  403d0c:	9100e3e3 	add	x3, sp, #0x38
  403d10:	f90027e0 	str	x0, [sp, #72]
  403d14:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  403d18:	b90053e0 	str	w0, [sp, #80]
  403d1c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  403d20:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  403d24:	910163e0 	add	x0, sp, #0x58
  403d28:	ad400460 	ldp	q0, q1, [x3]
  403d2c:	ad000400 	stp	q0, q1, [x0]
  403d30:	ad400400 	ldp	q0, q1, [x0]
  403d34:	910043e7 	add	x7, sp, #0x10
  403d38:	52800000 	mov	w0, #0x0                   	// #0
  403d3c:	52800005 	mov	w5, #0x0                   	// #0
  403d40:	d2800004 	mov	x4, #0x0                   	// #0
  403d44:	d2800003 	mov	x3, #0x0                   	// #0
  403d48:	ad0004e0 	stp	q0, q1, [x7]
  403d4c:	94000e17 	bl	4075a8 <z_impl_z_log_msg_runtime_vcreate>
}
  403d50:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403d54:	f9475c00 	ldr	x0, [x0, #3768]
  403d58:	f9403fe2 	ldr	x2, [sp, #120]
  403d5c:	f9400001 	ldr	x1, [x0]
  403d60:	eb010042 	subs	x2, x2, x1
  403d64:	d2800001 	mov	x1, #0x0                   	// #0
  403d68:	54000040 	b.eq	403d70 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  403d6c:	97fff5ed 	bl	401520 <__stack_chk_fail@plt>
  403d70:	a8d17bfd 	ldp	x29, x30, [sp], #272
  403d74:	d65f03c0 	ret

0000000000403d78 <thingset_can_addr_claim_rx_cb>:
{
  403d78:	d10183ff 	sub	sp, sp, #0x60
    LOG_INF("Received address claim from node 0x%.2X with EUI-64 "
  403d7c:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403d80:	52800005 	mov	w5, #0x0                   	// #0
  403d84:	9105d0c6 	add	x6, x6, #0x174
  403d88:	d2800004 	mov	x4, #0x0                   	// #0
  403d8c:	d2800003 	mov	x3, #0x0                   	// #0
{
  403d90:	a9047bfd 	stp	x29, x30, [sp, #64]
  403d94:	910103fd 	add	x29, sp, #0x40
  403d98:	a90553f3 	stp	x19, x20, [sp, #80]
  403d9c:	aa0103f3 	mov	x19, x1
  403da0:	aa0203f4 	mov	x20, x2
    LOG_INF("Received address claim from node 0x%.2X with EUI-64 "
  403da4:	39404020 	ldrb	w0, [x1, #16]
  403da8:	52800062 	mov	w2, #0x3                   	// #3
  403dac:	b9003be0 	str	w0, [sp, #56]
  403db0:	39403820 	ldrb	w0, [x1, #14]
  403db4:	b90033e0 	str	w0, [sp, #48]
  403db8:	39403420 	ldrb	w0, [x1, #13]
  403dbc:	b9002be0 	str	w0, [sp, #40]
  403dc0:	39403020 	ldrb	w0, [x1, #12]
  403dc4:	b90023e0 	str	w0, [sp, #32]
  403dc8:	39402c20 	ldrb	w0, [x1, #11]
  403dcc:	b9001be0 	str	w0, [sp, #24]
  403dd0:	39402820 	ldrb	w0, [x1, #10]
  403dd4:	b90013e0 	str	w0, [sp, #16]
  403dd8:	39402420 	ldrb	w0, [x1, #9]
  403ddc:	b9000be0 	str	w0, [sp, #8]
  403de0:	39402020 	ldrb	w0, [x1, #8]
  403de4:	b90003e0 	str	w0, [sp]
  403de8:	52800000 	mov	w0, #0x0                   	// #0
  403dec:	39400027 	ldrb	w7, [x1]
  403df0:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  403df4:	f946f421 	ldr	x1, [x1, #3560]
  403df8:	97ffffb1 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
    if (ts_can->node_addr == THINGSET_CAN_SOURCE_GET(frame->id)) {
  403dfc:	394fe281 	ldrb	w1, [x20, #1016]
  403e00:	39400260 	ldrb	w0, [x19]
  403e04:	6b00003f 	cmp	w1, w0
  403e08:	540000e1 	b.ne	403e24 <thingset_can_addr_claim_rx_cb+0xac>  // b.any
	z_impl_k_event_post(event, events);
  403e0c:	91036280 	add	x0, x20, #0xd8
  403e10:	52800061 	mov	w1, #0x3                   	// #3
}
  403e14:	a9447bfd 	ldp	x29, x30, [sp, #64]
  403e18:	a94553f3 	ldp	x19, x20, [sp, #80]
  403e1c:	910183ff 	add	sp, sp, #0x60
  403e20:	14004f78 	b	417c00 <z_impl_k_event_post>
  403e24:	a9447bfd 	ldp	x29, x30, [sp, #64]
  403e28:	a94553f3 	ldp	x19, x20, [sp, #80]
  403e2c:	910183ff 	add	sp, sp, #0x60
  403e30:	d65f03c0 	ret

0000000000403e34 <thingset_can_addr_claim_tx_handler>:
{
  403e34:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  403e38:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
                  | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  403e3c:	d1014004 	sub	x4, x0, #0x50
{
  403e40:	910003fd 	mov	x29, sp
  403e44:	f9475c21 	ldr	x1, [x1, #3768]
  403e48:	f9400022 	ldr	x2, [x1]
  403e4c:	f90017e2 	str	x2, [sp, #40]
  403e50:	d2800002 	mov	x2, #0x0                   	// #0
                  | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  403e54:	394ea001 	ldrb	w1, [x0, #936]
  403e58:	529fe002 	mov	w2, #0xff00                	// #65280
    struct can_frame tx_frame = {
  403e5c:	f9000fff 	str	xzr, [sp, #24]
                  | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  403e60:	72a26002 	movk	w2, #0x1300, lsl #16
  403e64:	2a020021 	orr	w1, w1, w2
    tx_frame.id = THINGSET_CAN_TYPE_NETWORK | THINGSET_CAN_PRIO_NETWORK_MGMT
  403e68:	b9001be1 	str	w1, [sp, #24]
    tx_frame.dlc = sizeof(eui64);
  403e6c:	52802101 	mov	w1, #0x108                 	// #264
  403e70:	79003be1 	strh	w1, [sp, #28]
    memcpy(tx_frame.data, eui64, sizeof(eui64));
  403e74:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
    int err = can_send(ts_can->dev, &tx_frame, K_MSEC(100), thingset_can_addr_claim_tx_cb, ts_can);
  403e78:	f85b0000 	ldur	x0, [x0, #-80]
  403e7c:	f9470c21 	ldr	x1, [x1, #3608]
  403e80:	f9400021 	ldr	x1, [x1]
  403e84:	f90013e1 	str	x1, [sp, #32]
  403e88:	b0000003 	adrp	x3, 404000 <thingset_can_report_tx_handler+0x7c>
  403e8c:	910063e1 	add	x1, sp, #0x18
  403e90:	9105f063 	add	x3, x3, #0x17c
  403e94:	d2800142 	mov	x2, #0xa                   	// #10
  403e98:	94001fc4 	bl	40bda8 <z_impl_can_send>
    if (err != 0) {
  403e9c:	34000180 	cbz	w0, 403ecc <thingset_can_addr_claim_tx_handler+0x98>
        LOG_ERR("Address claim failed with %d", err);
  403ea0:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  403ea4:	2a0003e7 	mov	w7, w0
  403ea8:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403eac:	52800005 	mov	w5, #0x0                   	// #0
  403eb0:	f946f421 	ldr	x1, [x1, #3560]
  403eb4:	910740c6 	add	x6, x6, #0x1d0
  403eb8:	d2800004 	mov	x4, #0x0                   	// #0
  403ebc:	d2800003 	mov	x3, #0x0                   	// #0
  403ec0:	52800022 	mov	w2, #0x1                   	// #1
  403ec4:	52800000 	mov	w0, #0x0                   	// #0
  403ec8:	97ffff7d 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
}
  403ecc:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403ed0:	f9475c00 	ldr	x0, [x0, #3768]
  403ed4:	f94017e2 	ldr	x2, [sp, #40]
  403ed8:	f9400001 	ldr	x1, [x0]
  403edc:	eb010042 	subs	x2, x2, x1
  403ee0:	d2800001 	mov	x1, #0x0                   	// #0
  403ee4:	54000040 	b.eq	403eec <thingset_can_addr_claim_tx_handler+0xb8>  // b.none
  403ee8:	97fff58e 	bl	401520 <__stack_chk_fail@plt>
  403eec:	a8c37bfd 	ldp	x29, x30, [sp], #48
  403ef0:	d65f03c0 	ret

0000000000403ef4 <thingset_can_addr_discovery_rx_cb>:
{
  403ef4:	d100c3ff 	sub	sp, sp, #0x30
    LOG_INF("Received address discovery frame with ID %X (rand %.2X)", frame->id,
  403ef8:	52800005 	mov	w5, #0x0                   	// #0
  403efc:	d2800004 	mov	x4, #0x0                   	// #0
  403f00:	d2800003 	mov	x3, #0x0                   	// #0
  403f04:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403f08:	9107b4c6 	add	x6, x6, #0x1ed
{
  403f0c:	a9017bfd 	stp	x29, x30, [sp, #16]
  403f10:	910043fd 	add	x29, sp, #0x10
  403f14:	f90013f3 	str	x19, [sp, #32]
  403f18:	aa0203f3 	mov	x19, x2
    LOG_INF("Received address discovery frame with ID %X (rand %.2X)", frame->id,
  403f1c:	52800062 	mov	w2, #0x3                   	// #3
  403f20:	b9400027 	ldr	w7, [x1]
  403f24:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  403f28:	f946f421 	ldr	x1, [x1, #3560]
  403f2c:	d3505ce0 	ubfx	x0, x7, #16, #8
  403f30:	b90003e0 	str	w0, [sp]
  403f34:	120070e7 	and	w7, w7, #0x1fffffff
  403f38:	52800000 	mov	w0, #0x0                   	// #0
  403f3c:	97ffff60 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
}
  403f40:	a9417bfd 	ldp	x29, x30, [sp, #16]
    thingset_sdk_reschedule_work(&ts_can->addr_claim_work, K_NO_WAIT);
  403f44:	91014260 	add	x0, x19, #0x50
}
  403f48:	f94013f3 	ldr	x19, [sp, #32]
    thingset_sdk_reschedule_work(&ts_can->addr_claim_work, K_NO_WAIT);
  403f4c:	d2800001 	mov	x1, #0x0                   	// #0
}
  403f50:	9100c3ff 	add	sp, sp, #0x30
    thingset_sdk_reschedule_work(&ts_can->addr_claim_work, K_NO_WAIT);
  403f54:	17ffff44 	b	403c64 <thingset_sdk_reschedule_work>

0000000000403f58 <isotp_fast_recv_error_callback>:
}

void isotp_fast_recv_error_callback(int8_t error, isotp_fast_msg_id sender_addr, void *arg)
{
    struct thingset_can *ts_can = arg;
    LOG_ERR("RX error %d", error);
  403f58:	d0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  403f5c:	13001c07 	sxtb	w7, w0
  403f60:	b00000a6 	adrp	x6, 418000 <table.0+0x1d8>
  403f64:	52800005 	mov	w5, #0x0                   	// #0
  403f68:	f946f421 	ldr	x1, [x1, #3560]
  403f6c:	910894c6 	add	x6, x6, #0x225
  403f70:	d2800004 	mov	x4, #0x0                   	// #0
  403f74:	d2800003 	mov	x3, #0x0                   	// #0
  403f78:	52800022 	mov	w2, #0x1                   	// #1
  403f7c:	52800000 	mov	w0, #0x0                   	// #0
  403f80:	17ffff4f 	b	403cbc <z_log_msg_runtime_create.constprop.0>

0000000000403f84 <thingset_can_report_tx_handler>:
{
  403f84:	d10203ff 	sub	sp, sp, #0x80
  403f88:	a9017bfd 	stp	x29, x30, [sp, #16]
  403f8c:	910043fd 	add	x29, sp, #0x10
  403f90:	a9035bf5 	stp	x21, x22, [sp, #48]
  403f94:	aa0003f6 	mov	x22, x0
  403f98:	d0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  403f9c:	a90253f3 	stp	x19, x20, [sp, #32]
  403fa0:	f9475c00 	ldr	x0, [x0, #3768]
  403fa4:	a90463f7 	stp	x23, x24, [sp, #64]
    while ((obj = thingset_iterate_subsets(&ts, TS_SUBSET_LIVE, obj)) != NULL) {
  403fa8:	d0000177 	adrp	x23, 431000 <__FRAME_END__+0x10804>
{
  403fac:	f9002bf9 	str	x25, [sp, #80]
  403fb0:	90000018 	adrp	x24, 403000 <send_work_handler+0xf4>
            LOG_WRN("Unable to send CAN frame with ID %x as it is too large (%d)", frame.id,
  403fb4:	b00000b9 	adrp	x25, 418000 <table.0+0x1d8>
  403fb8:	9132e318 	add	x24, x24, #0xcb8
{
  403fbc:	f9400001 	ldr	x1, [x0]
  403fc0:	f9003fe1 	str	x1, [sp, #120]
  403fc4:	d2800001 	mov	x1, #0x0                   	// #0
    struct can_frame frame = {
  403fc8:	52800020 	mov	w0, #0x1                   	// #1
  403fcc:	a906ffff 	stp	xzr, xzr, [sp, #104]
            LOG_WRN("Unable to send CAN frame with ID %x as it is too large (%d)", frame.id,
  403fd0:	9108c739 	add	x25, x25, #0x231
    struct can_frame frame = {
  403fd4:	3901b7e0 	strb	w0, [sp, #109]
    struct shared_buffer *sbuf = thingset_sdk_shared_buffer();
  403fd8:	97ffff20 	bl	403c58 <thingset_sdk_shared_buffer>
    while ((obj = thingset_iterate_subsets(&ts, TS_SUBSET_LIVE, obj)) != NULL) {
  403fdc:	f9472af7 	ldr	x23, [x23, #3664]
    struct shared_buffer *sbuf = thingset_sdk_shared_buffer();
  403fe0:	aa0003f4 	mov	x20, x0
    struct thingset_data_object *obj = NULL;
  403fe4:	d2800002 	mov	x2, #0x0                   	// #0
    while ((obj = thingset_iterate_subsets(&ts, TS_SUBSET_LIVE, obj)) != NULL) {
  403fe8:	aa1703e0 	mov	x0, x23
  403fec:	52800041 	mov	w1, #0x2                   	// #2
  403ff0:	940022be 	bl	40cae8 <thingset_iterate_subsets>
  403ff4:	aa0003f3 	mov	x19, x0
  403ff8:	b50004e0 	cbnz	x0, 404094 <thingset_can_report_tx_handler+0x110>
    ts_can->next_pub_time += 1000 * live_reporting_period;
  403ffc:	d0000175 	adrp	x21, 431000 <__FRAME_END__+0x10804>
  404000:	52807d17 	mov	w23, #0x3e8                 	// #1000
  404004:	f941f6c0 	ldr	x0, [x22, #1000]
  404008:	d10022d4 	sub	x20, x22, #0x8
  40400c:	f94756b5 	ldr	x21, [x21, #3752]
  404010:	b94002b3 	ldr	w19, [x21]
  404014:	1b177e73 	mul	w19, w19, w23
  404018:	8b334013 	add	x19, x0, w19, uxtw
  40401c:	f901fa93 	str	x19, [x20, #1008]
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
  404020:	d2800158 	mov	x24, #0xa                   	// #10
	return z_impl_k_uptime_ticks();
  404024:	94004cf8 	bl	417404 <z_impl_k_uptime_ticks>
  404028:	9b187c00 	mul	x0, x0, x24
    if (ts_can->next_pub_time <= k_uptime_get()) {
  40402c:	eb00027f 	cmp	x19, x0
  404030:	540000ec 	b.gt	40404c <thingset_can_report_tx_handler+0xc8>
  404034:	94004cf4 	bl	417404 <z_impl_k_uptime_ticks>
  404038:	9b187c00 	mul	x0, x0, x24
        ts_can->next_pub_time = k_uptime_get() + 1000 * live_reporting_period;
  40403c:	b94002a1 	ldr	w1, [x21]
  404040:	1b177c21 	mul	w1, w1, w23
  404044:	8b214001 	add	x1, x0, w1, uxtw
  404048:	f901fa81 	str	x1, [x20, #1008]
		t += off;
  40404c:	f941fa80 	ldr	x0, [x20, #1008]
  404050:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
  404054:	91002400 	add	x0, x0, #0x9
    thingset_sdk_reschedule_work(dwork, K_TIMEOUT_ABS_MS(ts_can->next_pub_time));
  404058:	f100241f 	cmp	x0, #0x9
  40405c:	54000089 	b.ls	40406c <thingset_can_report_tx_handler+0xe8>  // b.plast
			return t / ((uint64_t)from_hz / to_hz);
  404060:	d2800142 	mov	x2, #0xa                   	// #10
  404064:	9ac20800 	udiv	x0, x0, x2
  404068:	cb000021 	sub	x1, x1, x0
  40406c:	aa1603e0 	mov	x0, x22
  404070:	97fffefd 	bl	403c64 <thingset_sdk_reschedule_work>
}
  404074:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404078:	f9475c00 	ldr	x0, [x0, #3768]
  40407c:	f9403fe2 	ldr	x2, [sp, #120]
  404080:	f9400001 	ldr	x1, [x0]
  404084:	eb010042 	subs	x2, x2, x1
  404088:	d2800001 	mov	x1, #0x0                   	// #0
  40408c:	540006a0 	b.eq	404160 <thingset_can_report_tx_handler+0x1dc>  // b.none
  404090:	97fff524 	bl	401520 <__stack_chk_fail@plt>
	return z_impl_k_sem_take(sem, timeout);
  404094:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  404098:	aa1403e0 	mov	x0, x20
  40409c:	94003d4e 	bl	4135d4 <z_impl_k_sem_take>
        data_len = thingset_export_item(&ts, sbuf->data, sbuf->size, obj, THINGSET_BIN_VALUES_ONLY);
  4040a0:	a9428a81 	ldp	x1, x2, [x20, #40]
  4040a4:	aa1303e3 	mov	x3, x19
  4040a8:	aa1703e0 	mov	x0, x23
  4040ac:	528000c4 	mov	w4, #0x6                   	// #6
  4040b0:	9400224f 	bl	40c9ec <thingset_export_item>
  4040b4:	2a0003f5 	mov	w21, w0
        if (data_len > CAN_MAX_DLEN) {
  4040b8:	7100201f 	cmp	w0, #0x8
  4040bc:	540001e9 	b.ls	4040f8 <thingset_can_report_tx_handler+0x174>  // b.plast
            LOG_WRN("Unable to send CAN frame with ID %x as it is too large (%d)", frame.id,
  4040c0:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4040c4:	b90003f5 	str	w21, [sp]
  4040c8:	f94037e7 	ldr	x7, [sp, #104]
  4040cc:	aa1903e6 	mov	x6, x25
  4040d0:	f946f421 	ldr	x1, [x1, #3560]
  4040d4:	120070e7 	and	w7, w7, #0x1fffffff
  4040d8:	52800005 	mov	w5, #0x0                   	// #0
  4040dc:	d2800004 	mov	x4, #0x0                   	// #0
  4040e0:	d2800003 	mov	x3, #0x0                   	// #0
  4040e4:	52800042 	mov	w2, #0x2                   	// #2
  4040e8:	52800000 	mov	w0, #0x0                   	// #0
  4040ec:	97fffef4 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
        obj++; /* continue with object behind current one */
  4040f0:	91008262 	add	x2, x19, #0x20
  4040f4:	17ffffbd 	b	403fe8 <thingset_can_report_tx_handler+0x64>
        else if (data_len > 0) {
  4040f8:	340002e0 	cbz	w0, 404154 <thingset_can_report_tx_handler+0x1d0>
  4040fc:	f9401681 	ldr	x1, [x20, #40]
  404100:	93407c02 	sxtw	x2, w0
  404104:	d2800103 	mov	x3, #0x8                   	// #8
  404108:	9101c3e0 	add	x0, sp, #0x70
  40410c:	97fff4c5 	bl	401420 <__memcpy_chk@plt>
	z_impl_k_sem_give(sem);
  404110:	aa1403e0 	mov	x0, x20
  404114:	94003cf9 	bl	4134f8 <z_impl_k_sem_give>
                       | THINGSET_CAN_DATA_ID_SET(obj->id)
  404118:	79400661 	ldrh	w1, [x19, #2]
                       | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  40411c:	394fc2c0 	ldrb	w0, [x22, #1008]
            frame.dlc = data_len;
  404120:	3901b3f5 	strb	w21, [sp, #108]
                       | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  404124:	2a012001 	orr	w1, w0, w1, lsl #8
            frame.id = THINGSET_CAN_TYPE_REPORT | THINGSET_CAN_PRIO_REPORT_LOW
  404128:	b9406be0 	ldr	w0, [sp, #104]
                       | THINGSET_CAN_SOURCE_SET(ts_can->node_addr);
  40412c:	32070c21 	orr	w1, w1, #0x1e000000
            frame.id = THINGSET_CAN_TYPE_REPORT | THINGSET_CAN_PRIO_REPORT_LOW
  404130:	33007020 	bfxil	w0, w1, #0, #29
  404134:	b9006be0 	str	w0, [sp, #104]
            if (can_send(ts_can->dev, &frame, K_MSEC(10), thingset_can_report_tx_cb, NULL) != 0) {
  404138:	f85f82c0 	ldur	x0, [x22, #-8]
  40413c:	d2800004 	mov	x4, #0x0                   	// #0
  404140:	aa1803e3 	mov	x3, x24
  404144:	9101a3e1 	add	x1, sp, #0x68
  404148:	d2800022 	mov	x2, #0x1                   	// #1
  40414c:	94001f17 	bl	40bda8 <z_impl_can_send>
                LOG_DBG("Error sending CAN frame with ID %x", frame.id);
  404150:	17ffffe8 	b	4040f0 <thingset_can_report_tx_handler+0x16c>
  404154:	aa1403e0 	mov	x0, x20
  404158:	94003ce8 	bl	4134f8 <z_impl_k_sem_give>
}
  40415c:	17ffffe5 	b	4040f0 <thingset_can_report_tx_handler+0x16c>
}
  404160:	a9417bfd 	ldp	x29, x30, [sp, #16]
  404164:	a94253f3 	ldp	x19, x20, [sp, #32]
  404168:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40416c:	a94463f7 	ldp	x23, x24, [sp, #64]
  404170:	f9402bf9 	ldr	x25, [sp, #80]
  404174:	910203ff 	add	sp, sp, #0x80
  404178:	d65f03c0 	ret

000000000040417c <thingset_can_addr_claim_tx_cb>:
{
  40417c:	2a0103e7 	mov	w7, w1
    if (error == 0) {
  404180:	35000081 	cbnz	w1, 404190 <thingset_can_addr_claim_tx_cb+0x14>
	z_impl_k_event_post(event, events);
  404184:	52800021 	mov	w1, #0x1                   	// #1
  404188:	91036040 	add	x0, x2, #0xd8
  40418c:	14004e9d 	b	417c00 <z_impl_k_event_post>
        LOG_ERR("Address claim failed with %d", error);
  404190:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  404194:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  404198:	52800005 	mov	w5, #0x0                   	// #0
  40419c:	910740c6 	add	x6, x6, #0x1d0
  4041a0:	f946f421 	ldr	x1, [x1, #3560]
  4041a4:	d2800004 	mov	x4, #0x0                   	// #0
  4041a8:	d2800003 	mov	x3, #0x0                   	// #0
  4041ac:	52800022 	mov	w2, #0x1                   	// #1
  4041b0:	52800000 	mov	w0, #0x0                   	// #0
  4041b4:	17fffec2 	b	403cbc <z_log_msg_runtime_create.constprop.0>

00000000004041b8 <thingset_can_reset_request_response>:
{
  4041b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4041bc:	910003fd 	mov	x29, sp
  4041c0:	f9000bf3 	str	x19, [sp, #16]
  4041c4:	aa0003f3 	mov	x19, x0
    rr->sender_addr = 0;
  4041c8:	b900801f 	str	wzr, [x0, #128]
    rr->cb_arg = NULL;
  4041cc:	a908fc1f 	stp	xzr, xzr, [x0, #136]
	z_impl_k_timer_stop(timer);
  4041d0:	9100a000 	add	x0, x0, #0x28
  4041d4:	94004d46 	bl	4176ec <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
  4041d8:	aa1303e0 	mov	x0, x19
}
  4041dc:	f9400bf3 	ldr	x19, [sp, #16]
  4041e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4041e4:	14003cc5 	b	4134f8 <z_impl_k_sem_give>

00000000004041e8 <thingset_can_request_response_timeout_handler>:
{
  4041e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    rr->callback(NULL, 0, -ETIMEDOUT, 0, rr->cb_arg);
  4041ec:	52800003 	mov	w3, #0x0                   	// #0
  4041f0:	12800da2 	mov	w2, #0xffffff92            	// #-110
{
  4041f4:	910003fd 	mov	x29, sp
  4041f8:	f9000bf3 	str	x19, [sp, #16]
    rr->callback(NULL, 0, -ETIMEDOUT, 0, rr->cb_arg);
  4041fc:	d2800001 	mov	x1, #0x0                   	// #0
  404200:	d100a013 	sub	x19, x0, #0x28
  404204:	a9461005 	ldp	x5, x4, [x0, #96]
  404208:	d2800000 	mov	x0, #0x0                   	// #0
  40420c:	d63f00a0 	blr	x5
    thingset_can_reset_request_response(rr);
  404210:	aa1303e0 	mov	x0, x19
}
  404214:	f9400bf3 	ldr	x19, [sp, #16]
  404218:	a8c27bfd 	ldp	x29, x30, [sp], #32
    thingset_can_reset_request_response(rr);
  40421c:	17ffffe7 	b	4041b8 <thingset_can_reset_request_response>

0000000000404220 <isotp_fast_sent_callback>:
}

void isotp_fast_sent_callback(int result, void *arg)
{
    struct thingset_can *ts_can = arg;
    if (ts_can->request_response.callback != NULL && result != 0) {
  404220:	f940c025 	ldr	x5, [x1, #384]
  404224:	b4000205 	cbz	x5, 404264 <isotp_fast_sent_callback+0x44>
  404228:	2a0003e2 	mov	w2, w0
  40422c:	340001c0 	cbz	w0, 404264 <isotp_fast_sent_callback+0x44>
{
  404230:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
        ts_can->request_response.callback(NULL, 0, result, 0, ts_can->request_response.cb_arg);
  404234:	52800003 	mov	w3, #0x0                   	// #0
  404238:	d2800000 	mov	x0, #0x0                   	// #0
{
  40423c:	910003fd 	mov	x29, sp
  404240:	f9000bf3 	str	x19, [sp, #16]
  404244:	aa0103f3 	mov	x19, x1
        ts_can->request_response.callback(NULL, 0, result, 0, ts_can->request_response.cb_arg);
  404248:	d2800001 	mov	x1, #0x0                   	// #0
  40424c:	f940c664 	ldr	x4, [x19, #392]
  404250:	d63f00a0 	blr	x5
        thingset_can_reset_request_response(&ts_can->request_response);
  404254:	9103e260 	add	x0, x19, #0xf8
    }
}
  404258:	f9400bf3 	ldr	x19, [sp, #16]
  40425c:	a8c27bfd 	ldp	x29, x30, [sp], #32
        thingset_can_reset_request_response(&ts_can->request_response);
  404260:	17ffffd6 	b	4041b8 <thingset_can_reset_request_response>
  404264:	d65f03c0 	ret

0000000000404268 <thingset_can_send_inst>:
{
  404268:	d10183ff 	sub	sp, sp, #0x60
  40426c:	a9017bfd 	stp	x29, x30, [sp, #16]
  404270:	910043fd 	add	x29, sp, #0x10
  404274:	a90253f3 	stp	x19, x20, [sp, #32]
  404278:	aa0003f3 	mov	x19, x0
  40427c:	aa0403f4 	mov	x20, x4
  404280:	a9035bf5 	stp	x21, x22, [sp, #48]
  404284:	12001c76 	and	w22, w3, #0xff
  404288:	aa0603f5 	mov	x21, x6
  40428c:	a90463f7 	stp	x23, x24, [sp, #64]
  404290:	aa0103f7 	mov	x23, x1
  404294:	aa0203f8 	mov	x24, x2
  404298:	f9002bf9 	str	x25, [sp, #80]
  40429c:	aa0503f9 	mov	x25, x5
    if (!device_is_ready(ts_can->dev)) {
  4042a0:	f9400000 	ldr	x0, [x0]
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
  4042a4:	94003452 	bl	4113ec <z_device_is_ready>
  4042a8:	72001c1f 	tst	w0, #0xff
  4042ac:	54000600 	b.eq	40436c <thingset_can_send_inst+0x104>  // b.none
    if (rsp_callback != NULL) {
  4042b0:	b4000294 	cbz	x20, 404300 <thingset_can_send_inst+0x98>
	return z_impl_k_sem_take(sem, timeout);
  4042b4:	aa1503e1 	mov	x1, x21
  4042b8:	9103e260 	add	x0, x19, #0xf8
  4042bc:	94003cc6 	bl	4135d4 <z_impl_k_sem_take>
        if (k_sem_take(&ts_can->request_response.sem, timeout) != 0) {
  4042c0:	350005a0 	cbnz	w0, 404374 <thingset_can_send_inst+0x10c>
        k_timer_init(&ts_can->request_response.timer, thingset_can_request_response_timeout_handler,
  4042c4:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
        ts_can->request_response.cb_arg = callback_arg;
  4042c8:	a9186674 	stp	x20, x25, [x19, #384]
        k_timer_init(&ts_can->request_response.timer, thingset_can_request_response_timeout_handler,
  4042cc:	91048274 	add	x20, x19, #0x120
  4042d0:	f9474421 	ldr	x1, [x1, #3720]
  4042d4:	aa1403e0 	mov	x0, x20
  4042d8:	d2800002 	mov	x2, #0x0                   	// #0
  4042dc:	94004ce2 	bl	417664 <k_timer_init>
	z_impl_k_timer_start(timer, duration, period);
  4042e0:	aa1403e0 	mov	x0, x20
  4042e4:	aa1503e2 	mov	x2, x21
  4042e8:	aa1503e1 	mov	x1, x21
  4042ec:	94004ce5 	bl	417680 <z_impl_k_timer_start>
                                               | THINGSET_CAN_TARGET_SET(ts_can->node_addr)
  4042f0:	394fe260 	ldrb	w0, [x19, #1016]
                                               | THINGSET_CAN_SOURCE_SET(target_addr);
  4042f4:	2a0022c0 	orr	w0, w22, w0, lsl #8
  4042f8:	32050400 	orr	w0, w0, #0x18000000
        ts_can->request_response.sender_addr = THINGSET_CAN_TYPE_CHANNEL | THINGSET_CAN_PRIO_CHANNEL
  4042fc:	b9017a60 	str	w0, [x19, #376]
    int ret = isotp_fast_send(&ts_can->ctx, tx_buf, tx_len, target_addr, ts_can);
  404300:	aa1303e4 	mov	x4, x19
  404304:	2a1603e3 	mov	w3, w22
  404308:	aa1803e2 	mov	x2, x24
  40430c:	aa1703e1 	mov	x1, x23
  404310:	91026260 	add	x0, x19, #0x98
  404314:	97fffd47 	bl	403830 <isotp_fast_send>
    if (ret == ISOTP_N_OK) {
  404318:	340001c0 	cbz	w0, 404350 <thingset_can_send_inst+0xe8>
        LOG_ERR("Error sending data to addr %d: %d", target_addr, ret);
  40431c:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  404320:	b90003e0 	str	w0, [sp]
  404324:	2a1603e7 	mov	w7, w22
  404328:	52800000 	mov	w0, #0x0                   	// #0
  40432c:	f946f421 	ldr	x1, [x1, #3560]
  404330:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  404334:	52800005 	mov	w5, #0x0                   	// #0
  404338:	9109b4c6 	add	x6, x6, #0x26d
  40433c:	d2800004 	mov	x4, #0x0                   	// #0
  404340:	d2800003 	mov	x3, #0x0                   	// #0
  404344:	52800022 	mov	w2, #0x1                   	// #1
  404348:	97fffe5d 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
        return -EIO;
  40434c:	12800080 	mov	w0, #0xfffffffb            	// #-5
}
  404350:	a9417bfd 	ldp	x29, x30, [sp, #16]
  404354:	a94253f3 	ldp	x19, x20, [sp, #32]
  404358:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40435c:	a94463f7 	ldp	x23, x24, [sp, #64]
  404360:	f9402bf9 	ldr	x25, [sp, #80]
  404364:	910183ff 	add	sp, sp, #0x60
  404368:	d65f03c0 	ret
        return -ENODEV;
  40436c:	12800240 	mov	w0, #0xffffffed            	// #-19
  404370:	17fffff8 	b	404350 <thingset_can_send_inst+0xe8>
            return -ETIMEDOUT;
  404374:	12800da0 	mov	w0, #0xffffff92            	// #-110
  404378:	17fffff6 	b	404350 <thingset_can_send_inst+0xe8>

000000000040437c <isotp_fast_recv_callback>:
    if (rem_len < 0) {
  40437c:	7100003f 	cmp	w1, #0x0
  404380:	5400018a 	b.ge	4043b0 <isotp_fast_recv_callback+0x34>  // b.tcont
  404384:	2a0103e7 	mov	w7, w1
        LOG_ERR("RX error %d", rem_len);
  404388:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40438c:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  404390:	52800005 	mov	w5, #0x0                   	// #0
  404394:	f946f421 	ldr	x1, [x1, #3560]
  404398:	910894c6 	add	x6, x6, #0x225
  40439c:	d2800004 	mov	x4, #0x0                   	// #0
  4043a0:	d2800003 	mov	x3, #0x0                   	// #0
  4043a4:	52800022 	mov	w2, #0x1                   	// #1
  4043a8:	52800000 	mov	w0, #0x0                   	// #0
  4043ac:	17fffe44 	b	403cbc <z_log_msg_runtime_create.constprop.0>
    if (rem_len == 0) {
  4043b0:	54000841 	b.ne	4044b8 <isotp_fast_recv_callback+0x13c>  // b.any
{
  4043b4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4043b8:	aa0003e1 	mov	x1, x0
  4043bc:	910003fd 	mov	x29, sp
  4043c0:	a90153f3 	stp	x19, x20, [sp, #16]
  4043c4:	aa0303f3 	mov	x19, x3
  4043c8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4043cc:	2a0203f5 	mov	w21, w2
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
  4043d0:	d2800016 	mov	x22, #0x0                   	// #0
  4043d4:	f9001bf7 	str	x23, [sp, #48]
  4043d8:	14000004 	b	4043e8 <isotp_fast_recv_callback+0x6c>

	while (buf) {
		bytes += buf->len;
  4043dc:	79404022 	ldrh	w2, [x1, #32]
		buf = buf->frags;
  4043e0:	f9400421 	ldr	x1, [x1, #8]
		bytes += buf->len;
  4043e4:	8b0202d6 	add	x22, x22, x2
	while (buf) {
  4043e8:	b5ffffa1 	cbnz	x1, 4043dc <isotp_fast_recv_callback+0x60>
        net_buf_linearize(ts_can->rx_buffer, sizeof(ts_can->rx_buffer), buffer, 0, len);
  4043ec:	91064277 	add	x23, x19, #0x190
  4043f0:	aa0003e2 	mov	x2, x0
  4043f4:	aa1603e4 	mov	x4, x22
  4043f8:	aa1703e0 	mov	x0, x23
  4043fc:	d2800003 	mov	x3, #0x0                   	// #0
  404400:	d2804b01 	mov	x1, #0x258                 	// #600
  404404:	94001dfa 	bl	40bbec <net_buf_linearize>
        if (ts_can->request_response.callback != NULL
  404408:	f940c265 	ldr	x5, [x19, #384]
  40440c:	b4000205 	cbz	x5, 40444c <isotp_fast_recv_callback+0xd0>
            && ts_can->request_response.sender_addr == sender_addr)
  404410:	b9417a60 	ldr	w0, [x19, #376]
  404414:	6b0002bf 	cmp	w21, w0
  404418:	540001a1 	b.ne	40444c <isotp_fast_recv_callback+0xd0>  // b.any
            ts_can->request_response.callback(ts_can->rx_buffer, len, 0,
  40441c:	f940c664 	ldr	x4, [x19, #392]
  404420:	2a1503e3 	mov	w3, w21
  404424:	aa1603e1 	mov	x1, x22
  404428:	aa1703e0 	mov	x0, x23
  40442c:	52800002 	mov	w2, #0x0                   	// #0
  404430:	d63f00a0 	blr	x5
            thingset_can_reset_request_response(&ts_can->request_response);
  404434:	9103e260 	add	x0, x19, #0xf8
}
  404438:	a94153f3 	ldp	x19, x20, [sp, #16]
  40443c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404440:	f9401bf7 	ldr	x23, [sp, #48]
  404444:	a8c47bfd 	ldp	x29, x30, [sp], #64
            thingset_can_reset_request_response(&ts_can->request_response);
  404448:	17ffff5c 	b	4041b8 <thingset_can_reset_request_response>
            struct shared_buffer *sbuf = thingset_sdk_shared_buffer();
  40444c:	97fffe03 	bl	403c58 <thingset_sdk_shared_buffer>
  404450:	aa0003f4 	mov	x20, x0
                thingset_process_message(&ts, ts_can->rx_buffer, len, sbuf->data, sbuf->size);
  404454:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404458:	aa1603e2 	mov	x2, x22
  40445c:	aa1703e1 	mov	x1, x23
  404460:	a9429283 	ldp	x3, x4, [x20, #40]
  404464:	f9472800 	ldr	x0, [x0, #3664]
  404468:	9400212a 	bl	40c910 <thingset_process_message>
            if (tx_len > 0) {
  40446c:	7100001f 	cmp	w0, #0x0
  404470:	540001ad 	b.le	4044a4 <isotp_fast_recv_callback+0x128>
                thingset_can_send_inst(ts_can, sbuf->data, tx_len, target_id, NULL, NULL,
  404474:	2a1503e3 	mov	w3, w21
  404478:	93407c02 	sxtw	x2, w0
  40447c:	aa1303e0 	mov	x0, x19
  404480:	d2800006 	mov	x6, #0x0                   	// #0
}
  404484:	a9425bf5 	ldp	x21, x22, [sp, #32]
                thingset_can_send_inst(ts_can, sbuf->data, tx_len, target_id, NULL, NULL,
  404488:	d2800005 	mov	x5, #0x0                   	// #0
  40448c:	f9401681 	ldr	x1, [x20, #40]
  404490:	d2800004 	mov	x4, #0x0                   	// #0
}
  404494:	a94153f3 	ldp	x19, x20, [sp, #16]
  404498:	f9401bf7 	ldr	x23, [sp, #48]
  40449c:	a8c47bfd 	ldp	x29, x30, [sp], #64
                thingset_can_send_inst(ts_can, sbuf->data, tx_len, target_id, NULL, NULL,
  4044a0:	17ffff72 	b	404268 <thingset_can_send_inst>
}
  4044a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4044a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4044ac:	f9401bf7 	ldr	x23, [sp, #48]
  4044b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4044b4:	d65f03c0 	ret
  4044b8:	d65f03c0 	ret

00000000004044bc <thingset_can_init_inst>:
    return 0;
}
#endif /* CONFIG_ISOTP_FAST */

int thingset_can_init_inst(struct thingset_can *ts_can, const struct device *can_dev)
{
  4044bc:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  4044c0:	910003fd 	mov	x29, sp
  4044c4:	a90153f3 	stp	x19, x20, [sp, #16]
  4044c8:	aa0003f3 	mov	x19, x0
  4044cc:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4044d0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4044d4:	aa0103f5 	mov	x21, x1
    struct can_frame tx_frame = {
  4044d8:	52800034 	mov	w20, #0x1                   	// #1
{
  4044dc:	f9475c00 	ldr	x0, [x0, #3768]
  4044e0:	a90363f7 	stp	x23, x24, [sp, #48]
  4044e4:	a9046bf9 	stp	x25, x26, [sp, #64]
  4044e8:	f9002bfb 	str	x27, [sp, #80]
  4044ec:	f9400001 	ldr	x1, [x0]
  4044f0:	f90047e1 	str	x1, [sp, #136]
  4044f4:	d2800001 	mov	x1, #0x0                   	// #0
    struct can_frame tx_frame = {
  4044f8:	a907ffff 	stp	xzr, xzr, [sp, #120]
  4044fc:	3901f7f4 	strb	w20, [sp, #125]
  404500:	aa1503e0 	mov	x0, x21
  404504:	940033ba 	bl	4113ec <z_device_is_ready>
        .flags = CAN_FRAME_IDE,
    };
    int filter_id;
    int err;

    if (!device_is_ready(can_dev)) {
  404508:	72001c1f 	tst	w0, #0xff
  40450c:	54000261 	b.ne	404558 <thingset_can_init_inst+0x9c>  // b.any
        LOG_ERR("CAN device not ready");
  404510:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  404514:	2a1403e2 	mov	w2, w20
        return -ENODEV;
  404518:	12800254 	mov	w20, #0xffffffed            	// #-19
        LOG_ERR("CAN device not ready");
  40451c:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  404520:	f946f421 	ldr	x1, [x1, #3560]
  404524:	910a3cc6 	add	x6, x6, #0x28f
  404528:	52800005 	mov	w5, #0x0                   	// #0
  40452c:	d2800004 	mov	x4, #0x0                   	// #0
  404530:	d2800003 	mov	x3, #0x0                   	// #0
  404534:	97fffde2 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
#endif

    thingset_sdk_reschedule_work(&ts_can->reporting_work, K_NO_WAIT);

    return 0;
}
  404538:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40453c:	f9475c00 	ldr	x0, [x0, #3768]
  404540:	f94047e2 	ldr	x2, [sp, #136]
  404544:	f9400001 	ldr	x1, [x0]
  404548:	eb010042 	subs	x2, x2, x1
  40454c:	d2800001 	mov	x1, #0x0                   	// #0
  404550:	54001860 	b.eq	40485c <thingset_can_init_inst+0x3a0>  // b.none
  404554:	97fff3f3 	bl	401520 <__stack_chk_fail@plt>
	return z_impl_k_sem_init(sem, initial_count, limit);
  404558:	52800022 	mov	w2, #0x1                   	// #1
  40455c:	9103e260 	add	x0, x19, #0xf8
  404560:	2a0203e1 	mov	w1, w2
    k_work_init_delayable(&ts_can->reporting_work, thingset_can_report_tx_handler);
  404564:	91002277 	add	x23, x19, #0x8
  404568:	94003bd9 	bl	4134cc <z_impl_k_sem_init>
    k_work_init_delayable(&ts_can->addr_claim_work, thingset_can_addr_claim_tx_handler);
  40456c:	91014278 	add	x24, x19, #0x50
    k_work_init_delayable(&ts_can->reporting_work, thingset_can_report_tx_handler);
  404570:	aa1703e0 	mov	x0, x23
  404574:	f0ffffe1 	adrp	x1, 403000 <send_work_handler+0xf4>
  404578:	913e1021 	add	x1, x1, #0xf84
  40457c:	94003f40 	bl	41427c <k_work_init_delayable>
    k_work_init_delayable(&ts_can->addr_claim_work, thingset_can_addr_claim_tx_handler);
  404580:	aa1803e0 	mov	x0, x24
  404584:	f0ffffe1 	adrp	x1, 403000 <send_work_handler+0xf4>
  404588:	9138d021 	add	x1, x1, #0xe34
  40458c:	94003f3c 	bl	41427c <k_work_init_delayable>
    if (ts_can->node_addr < 1 || ts_can->node_addr > THINGSET_CAN_ADDR_MAX) {
  404590:	394fe260 	ldrb	w0, [x19, #1016]
    ts_can->dev = can_dev;
  404594:	f9000275 	str	x21, [x19]
    if (ts_can->node_addr < 1 || ts_can->node_addr > THINGSET_CAN_ADDR_MAX) {
  404598:	51000400 	sub	w0, w0, #0x1
  40459c:	12001c00 	and	w0, w0, #0xff
  4045a0:	7103f01f 	cmp	w0, #0xfc
  4045a4:	54000049 	b.ls	4045ac <thingset_can_init_inst+0xf0>  // b.plast
        ts_can->node_addr = 1;
  4045a8:	390fe274 	strb	w20, [x19, #1016]
    k_event_init(&ts_can->events);
  4045ac:	91036276 	add	x22, x19, #0xd8
	z_impl_k_event_init(event);
  4045b0:	aa1603e0 	mov	x0, x22
  4045b4:	94004d8f 	bl	417bf0 <z_impl_k_event_init>
    can_start(ts_can->dev);
  4045b8:	f9400260 	ldr	x0, [x19]
	return api->start(dev);
  4045bc:	f9400801 	ldr	x1, [x0, #16]
  4045c0:	f9400421 	ldr	x1, [x1, #8]
  4045c4:	d63f0020 	blr	x1
        can_add_rx_filter(ts_can->dev, thingset_can_addr_claim_rx_cb, ts_can, &addr_claim_filter);
  4045c8:	f9400260 	ldr	x0, [x19]
	return api->add_rx_filter(dev, callback, user_data, filter);
  4045cc:	aa1303e2 	mov	x2, x19
  4045d0:	f0000083 	adrp	x3, 417000 <z_abort_timeout+0x38>
  4045d4:	9137c063 	add	x3, x3, #0xdf0
  4045d8:	f9400801 	ldr	x1, [x0, #16]
  4045dc:	f9401824 	ldr	x4, [x1, #48]
  4045e0:	f0ffffe1 	adrp	x1, 403000 <send_work_handler+0xf4>
  4045e4:	9135e021 	add	x1, x1, #0xd78
  4045e8:	d63f0080 	blr	x4
  4045ec:	2a0003f4 	mov	w20, w0
    if (filter_id < 0) {
  4045f0:	37f803a0 	tbnz	w0, #31, 404664 <thingset_can_init_inst+0x1a8>
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  4045f4:	b0000179 	adrp	x25, 431000 <__FRAME_END__+0x10804>
                      | THINGSET_CAN_SOURCE_SET(THINGSET_CAN_ADDR_ANONYMOUS);
  4045f8:	52801fda 	mov	w26, #0xfe                  	// #254
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  4045fc:	900000b4 	adrp	x20, 418000 <table.0+0x1d8>
  404600:	910b2294 	add	x20, x20, #0x2c8
  404604:	f946f739 	ldr	x25, [x25, #3560]
                      | THINGSET_CAN_SOURCE_SET(THINGSET_CAN_ADDR_ANONYMOUS);
  404608:	72a2601a 	movk	w26, #0x1300, lsl #16
	z_impl_k_event_clear(event, events);
  40460c:	52800061 	mov	w1, #0x3                   	// #3
  404610:	aa1603e0 	mov	x0, x22
  404614:	94004d7d 	bl	417c08 <z_impl_k_event_clear>
  404618:	940017cc 	bl	40a548 <z_impl_sys_rand32_get>
                      | THINGSET_CAN_RAND_SET(rand) | THINGSET_CAN_TARGET_SET(ts_can->node_addr)
  40461c:	53101c01 	ubfiz	w1, w0, #16, #8
  404620:	394fe260 	ldrb	w0, [x19, #1016]
        tx_frame.dlc = 0;
  404624:	3901f3ff 	strb	wzr, [sp, #124]
                      | THINGSET_CAN_RAND_SET(rand) | THINGSET_CAN_TARGET_SET(ts_can->node_addr)
  404628:	2a002020 	orr	w0, w1, w0, lsl #8
        tx_frame.id = THINGSET_CAN_PRIO_NETWORK_MGMT | THINGSET_CAN_TYPE_NETWORK
  40462c:	b9407be1 	ldr	w1, [sp, #120]
                      | THINGSET_CAN_SOURCE_SET(THINGSET_CAN_ADDR_ANONYMOUS);
  404630:	2a1a0000 	orr	w0, w0, w26
        tx_frame.id = THINGSET_CAN_PRIO_NETWORK_MGMT | THINGSET_CAN_TYPE_NETWORK
  404634:	33007001 	bfxil	w1, w0, #0, #29
  404638:	b9007be1 	str	w1, [sp, #120]
        err = can_send(ts_can->dev, &tx_frame, K_MSEC(10), NULL, NULL);
  40463c:	f9400260 	ldr	x0, [x19]
  404640:	d2800004 	mov	x4, #0x0                   	// #0
  404644:	9101e3e1 	add	x1, sp, #0x78
  404648:	d2800003 	mov	x3, #0x0                   	// #0
  40464c:	d2800022 	mov	x2, #0x1                   	// #1
  404650:	94001dd6 	bl	40bda8 <z_impl_can_send>
        if (err != 0) {
  404654:	34000200 	cbz	w0, 404694 <thingset_can_init_inst+0x1d8>
	return z_impl_k_sleep(timeout);
  404658:	d2800140 	mov	x0, #0xa                   	// #10
  40465c:	9400476e 	bl	416414 <z_impl_k_sleep>
                continue;
  404660:	17ffffeb 	b	40460c <thingset_can_init_inst+0x150>
        LOG_ERR("Unable to add addr_claim filter: %d", filter_id);
  404664:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  404668:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  40466c:	2a0003e7 	mov	w7, w0
  404670:	910a90c6 	add	x6, x6, #0x2a4
  404674:	f946f421 	ldr	x1, [x1, #3560]
  404678:	52800005 	mov	w5, #0x0                   	// #0
  40467c:	d2800004 	mov	x4, #0x0                   	// #0
  404680:	d2800003 	mov	x3, #0x0                   	// #0
  404684:	52800022 	mov	w2, #0x1                   	// #1
        LOG_ERR("Unable to add addr_discovery filter: %d", filter_id);
  404688:	52800000 	mov	w0, #0x0                   	// #0
  40468c:	97fffd8c 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
        return filter_id;
  404690:	17ffffaa 	b	404538 <thingset_can_init_inst+0x7c>
	return z_impl_k_event_wait(event, events, reset, timeout);
  404694:	d2800643 	mov	x3, #0x32                  	// #50
  404698:	aa1603e0 	mov	x0, x22
  40469c:	52800002 	mov	w2, #0x0                   	// #0
  4046a0:	52800061 	mov	w1, #0x3                   	// #3
  4046a4:	94004d5c 	bl	417c14 <z_impl_k_event_wait>
        if (event & EVENT_ADDRESS_ALREADY_USED) {
  4046a8:	f240041f 	tst	x0, #0x3
  4046ac:	54000220 	b.eq	4046f0 <thingset_can_init_inst+0x234>  // b.none
  4046b0:	940017a6 	bl	40a548 <z_impl_sys_rand32_get>
            ts_can->node_addr = 1 + sys_rand32_get() % THINGSET_CAN_ADDR_MAX;
  4046b4:	52801fa1 	mov	w1, #0xfd                  	// #253
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  4046b8:	aa1403e6 	mov	x6, x20
  4046bc:	52800005 	mov	w5, #0x0                   	// #0
  4046c0:	d2800004 	mov	x4, #0x0                   	// #0
            ts_can->node_addr = 1 + sys_rand32_get() % THINGSET_CAN_ADDR_MAX;
  4046c4:	1ac10807 	udiv	w7, w0, w1
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  4046c8:	d2800003 	mov	x3, #0x0                   	// #0
  4046cc:	52800042 	mov	w2, #0x2                   	// #2
            ts_can->node_addr = 1 + sys_rand32_get() % THINGSET_CAN_ADDR_MAX;
  4046d0:	1b0180e7 	msub	w7, w7, w1, w0
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  4046d4:	aa1903e1 	mov	x1, x25
  4046d8:	52800000 	mov	w0, #0x0                   	// #0
            ts_can->node_addr = 1 + sys_rand32_get() % THINGSET_CAN_ADDR_MAX;
  4046dc:	110004e7 	add	w7, w7, #0x1
  4046e0:	12001ce7 	and	w7, w7, #0xff
  4046e4:	390fe267 	strb	w7, [x19, #1016]
            LOG_WRN("Node addr already in use, trying 0x%.2X", ts_can->node_addr);
  4046e8:	97fffd75 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
  4046ec:	17ffffc8 	b	40460c <thingset_can_init_inst+0x150>
            can_get_state(ts_can->dev, NULL, &err_cnt_before);
  4046f0:	f9400260 	ldr	x0, [x19]
	return api->get_state(dev, state, err_cnt);
  4046f4:	f9400801 	ldr	x1, [x0, #16]
  4046f8:	910183e2 	add	x2, sp, #0x60
  4046fc:	f9402023 	ldr	x3, [x1, #64]
  404700:	d2800001 	mov	x1, #0x0                   	// #0
  404704:	d63f0060 	blr	x3
            thingset_sdk_reschedule_work(&ts_can->addr_claim_work, K_NO_WAIT);
  404708:	aa1803e0 	mov	x0, x24
  40470c:	d2800001 	mov	x1, #0x0                   	// #0
  404710:	97fffd55 	bl	403c64 <thingset_sdk_reschedule_work>
  404714:	d2800143 	mov	x3, #0xa                   	// #10
  404718:	aa1603e0 	mov	x0, x22
  40471c:	52800002 	mov	w2, #0x0                   	// #0
  404720:	52800021 	mov	w1, #0x1                   	// #1
  404724:	94004d3c 	bl	417c14 <z_impl_k_event_wait>
            if (!(event & EVENT_ADDRESS_CLAIM_MSG_SENT)) {
  404728:	3607f980 	tbz	w0, #0, 404658 <thingset_can_init_inst+0x19c>
            can_get_state(ts_can->dev, NULL, &err_cnt_after);
  40472c:	f9400260 	ldr	x0, [x19]
  404730:	f9400801 	ldr	x1, [x0, #16]
  404734:	9101a3fb 	add	x27, sp, #0x68
  404738:	aa1b03e2 	mov	x2, x27
  40473c:	f9402023 	ldr	x3, [x1, #64]
  404740:	d2800001 	mov	x1, #0x0                   	// #0
  404744:	d63f0060 	blr	x3
            if (err_cnt_after.tx_err_cnt <= err_cnt_before.tx_err_cnt) {
  404748:	3941a3e1 	ldrb	w1, [sp, #104]
  40474c:	394183e0 	ldrb	w0, [sp, #96]
  404750:	6b00003f 	cmp	w1, w0
  404754:	54fff5c8 	b.hi	40460c <thingset_can_init_inst+0x150>  // b.pmore
	z_impl_k_event_post(event, events);
  404758:	52800041 	mov	w1, #0x2                   	// #2
  40475c:	aa1603e0 	mov	x0, x22
                LOG_INF("Using CAN node address 0x%.2X", ts_can->node_addr);
  404760:	b0000176 	adrp	x22, 431000 <__FRAME_END__+0x10804>
  404764:	94004d27 	bl	417c00 <z_impl_k_event_post>
  404768:	394fe267 	ldrb	w7, [x19, #1016]
  40476c:	52800005 	mov	w5, #0x0                   	// #0
  404770:	f946f6d6 	ldr	x22, [x22, #3560]
  404774:	d2800004 	mov	x4, #0x0                   	// #0
  404778:	d2800003 	mov	x3, #0x0                   	// #0
  40477c:	52800062 	mov	w2, #0x3                   	// #3
  404780:	aa1603e1 	mov	x1, x22
  404784:	52800000 	mov	w0, #0x0                   	// #0
  404788:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  40478c:	910bc0c6 	add	x6, x6, #0x2f0
  404790:	97fffd4b 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
    struct can_filter addr_discovery_filter = {
  404794:	b90073ff 	str	wzr, [sp, #112]
              | THINGSET_CAN_TARGET_SET(ts_can->node_addr),
  404798:	394fe260 	ldrb	w0, [x19, #1016]
  40479c:	52801fc1 	mov	w1, #0xfe                  	// #254
  4047a0:	72a06001 	movk	w1, #0x300, lsl #16
	return api->add_rx_filter(dev, callback, user_data, filter);
  4047a4:	aa1b03e3 	mov	x3, x27
  4047a8:	aa1303e2 	mov	x2, x19
  4047ac:	2a002020 	orr	w0, w1, w0, lsl #8
    struct can_filter addr_discovery_filter = {
  4047b0:	d2dfffe1 	mov	x1, #0xffff00000000        	// #281470681743360
  4047b4:	f2e06001 	movk	x1, #0x300, lsl #48
  4047b8:	aa010000 	orr	x0, x0, x1
  4047bc:	f90037e0 	str	x0, [sp, #104]
  4047c0:	528000a0 	mov	w0, #0x5                   	// #5
  4047c4:	3901c3e0 	strb	w0, [sp, #112]
    filter_id = can_add_rx_filter(ts_can->dev, thingset_can_addr_discovery_rx_cb, ts_can,
  4047c8:	f9400260 	ldr	x0, [x19]
  4047cc:	f9400801 	ldr	x1, [x0, #16]
  4047d0:	f9401824 	ldr	x4, [x1, #48]
  4047d4:	f0ffffe1 	adrp	x1, 403000 <send_work_handler+0xf4>
  4047d8:	913bd021 	add	x1, x1, #0xef4
  4047dc:	d63f0080 	blr	x4
  4047e0:	2a0003f4 	mov	w20, w0
    if (filter_id < 0) {
  4047e4:	36f80140 	tbz	w0, #31, 40480c <thingset_can_init_inst+0x350>
        LOG_ERR("Unable to add addr_discovery filter: %d", filter_id);
  4047e8:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  4047ec:	2a0003e7 	mov	w7, w0
  4047f0:	910c38c6 	add	x6, x6, #0x30e
  4047f4:	aa1603e1 	mov	x1, x22
  4047f8:	52800005 	mov	w5, #0x0                   	// #0
  4047fc:	d2800004 	mov	x4, #0x0                   	// #0
  404800:	d2800003 	mov	x3, #0x0                   	// #0
  404804:	52800022 	mov	w2, #0x1                   	// #1
  404808:	17ffffa0 	b	404688 <thingset_can_init_inst+0x1cc>
                                | THINGSET_CAN_TARGET_SET(ts_can->node_addr);
  40480c:	394fe262 	ldrb	w2, [x19, #1016]
    isotp_fast_bind(&ts_can->ctx, can_dev, my_addr, &fc_opts, isotp_fast_recv_callback, ts_can,
  404810:	b0000167 	adrp	x7, 431000 <__FRAME_END__+0x10804>
  404814:	b0000166 	adrp	x6, 431000 <__FRAME_END__+0x10804>
  404818:	b0000164 	adrp	x4, 431000 <__FRAME_END__+0x10804>
  40481c:	f94764e7 	ldr	x7, [x7, #3784]
                                | THINGSET_CAN_TARGET_SET(ts_can->node_addr);
  404820:	53185c42 	lsl	w2, w2, #8
    isotp_fast_bind(&ts_can->ctx, can_dev, my_addr, &fc_opts, isotp_fast_recv_callback, ts_can,
  404824:	f94700c6 	ldr	x6, [x6, #3584]
  404828:	aa1303e5 	mov	x5, x19
  40482c:	f947a084 	ldr	x4, [x4, #3904]
  404830:	32050442 	orr	w2, w2, #0x18000000
  404834:	900000a3 	adrp	x3, 418000 <table.0+0x1d8>
  404838:	910e8063 	add	x3, x3, #0x3a0
  40483c:	aa1503e1 	mov	x1, x21
  404840:	91026260 	add	x0, x19, #0x98
  404844:	97fffbb5 	bl	403718 <isotp_fast_bind>
    return 0;
  404848:	52800014 	mov	w20, #0x0                   	// #0
    thingset_sdk_reschedule_work(&ts_can->reporting_work, K_NO_WAIT);
  40484c:	aa1703e0 	mov	x0, x23
  404850:	d2800001 	mov	x1, #0x0                   	// #0
  404854:	97fffd04 	bl	403c64 <thingset_sdk_reschedule_work>
    return 0;
  404858:	17ffff38 	b	404538 <thingset_can_init_inst+0x7c>
}
  40485c:	2a1403e0 	mov	w0, w20
  404860:	a94153f3 	ldp	x19, x20, [sp, #16]
  404864:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404868:	a94363f7 	ldp	x23, x24, [sp, #48]
  40486c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  404870:	f9402bfb 	ldr	x27, [sp, #80]
  404874:	a8c97bfd 	ldp	x29, x30, [sp], #144
  404878:	d65f03c0 	ret

000000000040487c <thingset_can_thread>:
{
    return &ts_can_single;
}

static void thingset_can_thread()
{
  40487c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    int err;

    err = thingset_can_init_inst(&ts_can_single, can_dev);
  404880:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  404884:	d0000160 	adrp	x0, 432000 <__dso_handle>
{
  404888:	910003fd 	mov	x29, sp
    err = thingset_can_init_inst(&ts_can_single, can_dev);
  40488c:	f946fc21 	ldr	x1, [x1, #3576]
  404890:	91012000 	add	x0, x0, #0x48
  404894:	97ffff0a 	bl	4044bc <thingset_can_init_inst>
    if (err != 0) {
  404898:	340001a0 	cbz	w0, 4048cc <thingset_can_thread+0x50>
    }

    while (true) {
        k_sleep(K_FOREVER);
    }
}
  40489c:	a8c17bfd 	ldp	x29, x30, [sp], #16
        LOG_ERR("Failed to init ThingSet CAN: %d", err);
  4048a0:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4048a4:	2a0003e7 	mov	w7, w0
  4048a8:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  4048ac:	f946f421 	ldr	x1, [x1, #3560]
  4048b0:	910cd8c6 	add	x6, x6, #0x336
  4048b4:	52800005 	mov	w5, #0x0                   	// #0
  4048b8:	d2800004 	mov	x4, #0x0                   	// #0
  4048bc:	d2800003 	mov	x3, #0x0                   	// #0
  4048c0:	52800022 	mov	w2, #0x1                   	// #1
  4048c4:	52800000 	mov	w0, #0x0                   	// #0
  4048c8:	17fffcfd 	b	403cbc <z_log_msg_runtime_create.constprop.0>
	return z_impl_k_sleep(timeout);
  4048cc:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  4048d0:	940046d1 	bl	416414 <z_impl_k_sleep>
    while (true) {
  4048d4:	17fffffe 	b	4048cc <thingset_can_thread+0x50>

00000000004048d8 <thingset_can_set_report_rx_callback_inst>:
{
  4048d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4048dc:	910003fd 	mov	x29, sp
  4048e0:	a90153f3 	stp	x19, x20, [sp, #16]
  4048e4:	aa0003f3 	mov	x19, x0
  4048e8:	aa0103f4 	mov	x20, x1
    if (!device_is_ready(ts_can->dev)) {
  4048ec:	f9400000 	ldr	x0, [x0]
  4048f0:	940032bf 	bl	4113ec <z_device_is_ready>
  4048f4:	72001c1f 	tst	w0, #0xff
  4048f8:	540003a0 	b.eq	40496c <thingset_can_set_report_rx_callback_inst+0x94>  // b.none
    if (rx_cb == NULL) {
  4048fc:	b40003d4 	cbz	x20, 404974 <thingset_can_set_report_rx_callback_inst+0x9c>
        can_add_rx_filter(ts_can->dev, thingset_can_report_rx_cb, ts_can, &report_filter);
  404900:	f9400260 	ldr	x0, [x19]
    ts_can->report_rx_cb = rx_cb;
  404904:	f901f674 	str	x20, [x19, #1000]
  404908:	aa1303e2 	mov	x2, x19
  40490c:	f0000083 	adrp	x3, 417000 <z_abort_timeout+0x38>
  404910:	9137f063 	add	x3, x3, #0xdfc
  404914:	f9400801 	ldr	x1, [x0, #16]
  404918:	f9401824 	ldr	x4, [x1, #48]
  40491c:	f0ffffe1 	adrp	x1, 403000 <send_work_handler+0xf4>
  404920:	9131e021 	add	x1, x1, #0xc78
  404924:	d63f0080 	blr	x4
  404928:	2a0003f3 	mov	w19, w0
    if (filter_id < 0) {
  40492c:	36f80280 	tbz	w0, #31, 40497c <thingset_can_set_report_rx_callback_inst+0xa4>
        LOG_ERR("Unable to add report filter: %d", filter_id);
  404930:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  404934:	2a0003e7 	mov	w7, w0
  404938:	900000a6 	adrp	x6, 418000 <table.0+0x1d8>
  40493c:	52800005 	mov	w5, #0x0                   	// #0
  404940:	f946f421 	ldr	x1, [x1, #3560]
  404944:	910d58c6 	add	x6, x6, #0x356
  404948:	d2800004 	mov	x4, #0x0                   	// #0
  40494c:	d2800003 	mov	x3, #0x0                   	// #0
  404950:	52800022 	mov	w2, #0x1                   	// #1
  404954:	52800000 	mov	w0, #0x0                   	// #0
  404958:	97fffcd9 	bl	403cbc <z_log_msg_runtime_create.constprop.0>
}
  40495c:	2a1303e0 	mov	w0, w19
  404960:	a94153f3 	ldp	x19, x20, [sp, #16]
  404964:	a8c27bfd 	ldp	x29, x30, [sp], #32
  404968:	d65f03c0 	ret
        return -ENODEV;
  40496c:	12800253 	mov	w19, #0xffffffed            	// #-19
  404970:	17fffffb 	b	40495c <thingset_can_set_report_rx_callback_inst+0x84>
        return -EINVAL;
  404974:	128002b3 	mov	w19, #0xffffffea            	// #-22
  404978:	17fffff9 	b	40495c <thingset_can_set_report_rx_callback_inst+0x84>
    return 0;
  40497c:	52800013 	mov	w19, #0x0                   	// #0
  404980:	17fffff7 	b	40495c <thingset_can_set_report_rx_callback_inst+0x84>

0000000000404984 <thingset_can_send>:
    return thingset_can_send_inst(&ts_can_single, tx_buf, tx_len, target_addr, rsp_callback,
  404984:	aa0503e6 	mov	x6, x5
  404988:	aa0403e5 	mov	x5, x4
  40498c:	aa0303e4 	mov	x4, x3
  404990:	2a0203e3 	mov	w3, w2
  404994:	aa0103e2 	mov	x2, x1
  404998:	aa0003e1 	mov	x1, x0
  40499c:	d0000160 	adrp	x0, 432000 <__dso_handle>
  4049a0:	91012000 	add	x0, x0, #0x48
  4049a4:	17fffe31 	b	404268 <thingset_can_send_inst>

00000000004049a8 <thingset_can_set_report_rx_callback>:
    return thingset_can_set_report_rx_callback_inst(&ts_can_single, rx_cb);
  4049a8:	aa0003e1 	mov	x1, x0
  4049ac:	d0000160 	adrp	x0, 432000 <__dso_handle>
  4049b0:	91012000 	add	x0, x0, #0x48
  4049b4:	17ffffc9 	b	4048d8 <thingset_can_set_report_rx_callback_inst>

00000000004049b8 <report_rx_callback>:
	z_impl_k_sem_give(sem);
  4049b8:	f0000160 	adrp	x0, 433000 <obj_0x28+0x18>
  4049bc:	91192000 	add	x0, x0, #0x648
  4049c0:	14003ace 	b	4134f8 <z_impl_k_sem_give>

00000000004049c4 <z_zassert.constprop.0>:

#define z_zexpect(cond, default_msg, file, line, func, msg, ...) z_zexpect_(cond, file, line)

#else /* CONFIG_ZTEST_ASSERT_VERBOSE != 0 */

static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  4049c4:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  4049c8:	910003fd 	mov	x29, sp
  4049cc:	a9025bf5 	stp	x21, x22, [sp, #32]
  4049d0:	aa0103f6 	mov	x22, x1
  4049d4:	b0000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4049d8:	a90153f3 	stp	x19, x20, [sp, #16]
  4049dc:	f9475c21 	ldr	x1, [x1, #3768]
  4049e0:	f9001bf7 	str	x23, [sp, #48]
  4049e4:	3d8027e0 	str	q0, [sp, #144]
			     const char *func, const char *msg, ...)
{
	if (cond == false) {
  4049e8:	72001c17 	ands	w23, w0, #0xff
static inline bool z_zassert(bool cond, const char *default_msg, const char *file, int line,
  4049ec:	3d802be1 	str	q1, [sp, #160]
  4049f0:	3d802fe2 	str	q2, [sp, #176]
  4049f4:	3d8033e3 	str	q3, [sp, #192]
  4049f8:	3d8037e4 	str	q4, [sp, #208]
  4049fc:	3d803be5 	str	q5, [sp, #224]
  404a00:	3d803fe6 	str	q6, [sp, #240]
  404a04:	3d8043e7 	str	q7, [sp, #256]
  404a08:	a9111fe6 	stp	x6, x7, [sp, #272]
  404a0c:	f9400022 	ldr	x2, [x1]
  404a10:	f90047e2 	str	x2, [sp, #136]
  404a14:	d2800002 	mov	x2, #0x0                   	// #0
	if (cond == false) {
  404a18:	54000401 	b.ne	404a98 <z_zassert.constprop.0+0xd4>  // b.any
		va_list vargs;

		va_start(vargs, msg);
  404a1c:	910483e0 	add	x0, sp, #0x120
  404a20:	a90683e0 	stp	x0, x0, [sp, #104]
  404a24:	910443e0 	add	x0, sp, #0x110
  404a28:	f9003fe0 	str	x0, [sp, #120]
  404a2c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  404a30:	b90083e0 	str	w0, [sp, #128]
  404a34:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  404a38:	aa0503f3 	mov	x19, x5
  404a3c:	2a0303f4 	mov	w20, w3
  404a40:	aa0403f5 	mov	x21, x4
  404a44:	b90087e0 	str	w0, [sp, #132]
		PRINT("\n    Assertion failed at %s:%d: %s: %s\n", ztest_relative_filename(file),
  404a48:	900000a0 	adrp	x0, 418000 <table.0+0x1d8>
  404a4c:	910e8c00 	add	x0, x0, #0x3a3
  404a50:	940019e5 	bl	40b1e4 <ztest_relative_filename>
  404a54:	aa0003e1 	mov	x1, x0
  404a58:	aa1603e4 	mov	x4, x22
  404a5c:	aa1503e3 	mov	x3, x21
  404a60:	2a1403e2 	mov	w2, w20
  404a64:	900000a0 	adrp	x0, 418000 <table.0+0x1d8>
  404a68:	910fb000 	add	x0, x0, #0x3ec
  404a6c:	9400031b 	bl	4056d8 <printk>
		      line, func, default_msg);
		vprintk(msg, vargs);
  404a70:	9101a3e0 	add	x0, sp, #0x68
  404a74:	910103e1 	add	x1, sp, #0x40
  404a78:	ad400400 	ldp	q0, q1, [x0]
  404a7c:	aa1303e0 	mov	x0, x19
  404a80:	ad000420 	stp	q0, q1, [x1]
  404a84:	9400030c 	bl	4056b4 <vprintk>
		printk("\n");
  404a88:	b00000a0 	adrp	x0, 419000 <__func__.2+0xa80>
  404a8c:	912e7000 	add	x0, x0, #0xb9c
  404a90:	94000312 	bl	4056d8 <printk>
		va_end(vargs);
		ztest_test_fail();
  404a94:	94001747 	bl	40a7b0 <ztest_test_fail>
		PRINT("\n   Assertion succeeded at %s:%d (%s)\n", ztest_relative_filename(file),
		      line, func);
	}
#endif
	return true;
}
  404a98:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404a9c:	f9475c00 	ldr	x0, [x0, #3768]
  404aa0:	f94047e2 	ldr	x2, [sp, #136]
  404aa4:	f9400001 	ldr	x1, [x0]
  404aa8:	eb010042 	subs	x2, x2, x1
  404aac:	d2800001 	mov	x1, #0x0                   	// #0
  404ab0:	54000040 	b.eq	404ab8 <z_zassert.constprop.0+0xf4>  // b.none
  404ab4:	97fff29b 	bl	401520 <__stack_chk_fail@plt>
  404ab8:	2a1703e0 	mov	w0, w23
  404abc:	a94153f3 	ldp	x19, x20, [sp, #16]
  404ac0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404ac4:	f9401bf7 	ldr	x23, [sp, #48]
  404ac8:	a8d27bfd 	ldp	x29, x30, [sp], #288
  404acc:	d65f03c0 	ret

0000000000404ad0 <_thingset_isotp_fast_test_send_request_to_node_wrapper>:
static void request_rx_cb(const struct device *dev, struct can_frame *frame, void *user_data)
{
    k_sem_give(&request_tx_sem);
}

ZTEST(thingset_isotp_fast, test_send_request_to_node)
  404ad0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  404ad4:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404ad8:	910003fd 	mov	x29, sp
  404adc:	f9475c00 	ldr	x0, [x0, #3768]
  404ae0:	a90153f3 	stp	x19, x20, [sp, #16]
  404ae4:	f90013f5 	str	x21, [sp, #32]
  404ae8:	f9400001 	ldr	x1, [x0]
  404aec:	f90027e1 	str	x1, [sp, #72]
  404af0:	d2800001 	mov	x1, #0x0                   	// #0
{
    struct can_filter other_node_filter = {
  404af4:	d2998000 	mov	x0, #0xcc00                	// #52224
  404af8:	f2a30000 	movk	x0, #0x1800, lsl #16
  404afc:	f2dfe000 	movk	x0, #0xff00, lsl #32
  404b00:	f2e3e000 	movk	x0, #0x1f00, lsl #48
  404b04:	f9001be0 	str	x0, [sp, #48]
  404b08:	528000a0 	mov	w0, #0x5                   	// #5
  404b0c:	b9003be0 	str	w0, [sp, #56]
        .id = 0x1800CC00,
        .mask = 0x1F00FF00,
        .flags = CAN_FILTER_DATA | CAN_FILTER_IDE,
    };
    uint8_t req_buf[] = { 0x01, 0x00 }; /* simple single-frame request via ISO-TP */
  404b10:	52800020 	mov	w0, #0x1                   	// #1
  404b14:	790083e0 	strh	w0, [sp, #64]
	z_impl_k_sem_reset(sem);
  404b18:	f0000175 	adrp	x21, 433000 <obj_0x28+0x18>
  404b1c:	9119c2a0 	add	x0, x21, #0x670
  404b20:	94003b1e 	bl	413798 <z_impl_k_sem_reset>
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  404b24:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
	if (filter == NULL || (filter->flags & (CAN_FILTER_DATA | CAN_FILTER_RTR)) == 0) {
  404b28:	3940e3e2 	ldrb	w2, [sp, #56]
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  404b2c:	f946fc00 	ldr	x0, [x0, #3576]
  404b30:	f9400801 	ldr	x1, [x0, #16]
	if (filter == NULL || (filter->flags & (CAN_FILTER_DATA | CAN_FILTER_RTR)) == 0) {
  404b34:	721f045f 	tst	w2, #0x6
  404b38:	54000640 	b.eq	404c00 <_thingset_isotp_fast_test_send_request_to_node_wrapper+0x130>  // b.none
	return api->add_rx_filter(dev, callback, user_data, filter);
  404b3c:	f9401824 	ldr	x4, [x1, #48]
  404b40:	9100c3e3 	add	x3, sp, #0x30
  404b44:	d2800002 	mov	x2, #0x0                   	// #0
  404b48:	90000001 	adrp	x1, 404000 <thingset_can_report_tx_handler+0x7c>
  404b4c:	91306021 	add	x1, x1, #0xc18
  404b50:	d63f0080 	blr	x4
  404b54:	2a0003e6 	mov	w6, w0
    int err;

    k_sem_reset(&request_tx_sem);

    err = can_add_rx_filter(can_dev, &request_rx_cb, NULL, &other_node_filter);
    zassert_false(err < 0, "adding rx filter failed: %d", err);
  404b58:	2a2603e0 	mvn	w0, w6
  404b5c:	900000b4 	adrp	x20, 418000 <table.0+0x1d8>
  404b60:	900000b3 	adrp	x19, 418000 <table.0+0x1d8>
  404b64:	91154a94 	add	x20, x20, #0x552
  404b68:	910e8e73 	add	x19, x19, #0x3a3
  404b6c:	aa1403e4 	mov	x4, x20
  404b70:	aa1303e2 	mov	x2, x19
  404b74:	52800803 	mov	w3, #0x40                  	// #64
  404b78:	531f7c00 	lsr	w0, w0, #31
  404b7c:	900000a5 	adrp	x5, 418000 <table.0+0x1d8>
  404b80:	900000a1 	adrp	x1, 418000 <table.0+0x1d8>
  404b84:	911050a5 	add	x5, x5, #0x414
  404b88:	9110c021 	add	x1, x1, #0x430
  404b8c:	97ffff8e 	bl	4049c4 <z_zassert.constprop.0>

    thingset_can_send(req_buf, sizeof(req_buf), 0xCC, NULL, NULL, TEST_RECEIVE_TIMEOUT);
  404b90:	910103e0 	add	x0, sp, #0x40
  404b94:	d2800145 	mov	x5, #0xa                   	// #10
  404b98:	d2800004 	mov	x4, #0x0                   	// #0
  404b9c:	d2800003 	mov	x3, #0x0                   	// #0
  404ba0:	12800662 	mov	w2, #0xffffffcc            	// #-52
  404ba4:	d2800041 	mov	x1, #0x2                   	// #2
  404ba8:	97ffff77 	bl	404984 <thingset_can_send>
	return z_impl_k_sem_take(sem, timeout);
  404bac:	d2800141 	mov	x1, #0xa                   	// #10
  404bb0:	9119c2a0 	add	x0, x21, #0x670
  404bb4:	94003a88 	bl	4135d4 <z_impl_k_sem_take>

    err = k_sem_take(&request_tx_sem, TEST_RECEIVE_TIMEOUT);
    zassert_equal(err, 0, "receive timeout");
  404bb8:	7100001f 	cmp	w0, #0x0
  404bbc:	aa1303e2 	mov	x2, x19
  404bc0:	1a9f17e0 	cset	w0, eq  // eq = none
  404bc4:	aa1403e4 	mov	x4, x20
  404bc8:	900000a5 	adrp	x5, 418000 <table.0+0x1d8>
  404bcc:	528008a3 	mov	w3, #0x45                  	// #69
  404bd0:	911108a5 	add	x5, x5, #0x442
  404bd4:	900000a1 	adrp	x1, 418000 <table.0+0x1d8>
  404bd8:	91114821 	add	x1, x1, #0x452
  404bdc:	97ffff7a 	bl	4049c4 <z_zassert.constprop.0>
ZTEST(thingset_isotp_fast, test_send_request_to_node)
  404be0:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404be4:	f9475c00 	ldr	x0, [x0, #3768]
  404be8:	f94027e2 	ldr	x2, [sp, #72]
  404bec:	f9400001 	ldr	x1, [x0]
  404bf0:	eb010042 	subs	x2, x2, x1
  404bf4:	d2800001 	mov	x1, #0x0                   	// #0
  404bf8:	54000080 	b.eq	404c08 <_thingset_isotp_fast_test_send_request_to_node_wrapper+0x138>  // b.none
  404bfc:	97fff249 	bl	401520 <__stack_chk_fail@plt>
		return -EINVAL;
  404c00:	128002a6 	mov	w6, #0xffffffea            	// #-22
  404c04:	17ffffd5 	b	404b58 <_thingset_isotp_fast_test_send_request_to_node_wrapper+0x88>
  404c08:	a94153f3 	ldp	x19, x20, [sp, #16]
  404c0c:	f94013f5 	ldr	x21, [sp, #32]
  404c10:	a8c57bfd 	ldp	x29, x30, [sp], #80
  404c14:	d65f03c0 	ret

0000000000404c18 <request_rx_cb>:
	z_impl_k_sem_give(sem);
  404c18:	f0000160 	adrp	x0, 433000 <obj_0x28+0x18>
  404c1c:	9119c000 	add	x0, x0, #0x670
  404c20:	14003a36 	b	4134f8 <z_impl_k_sem_give>

0000000000404c24 <_thingset_isotp_fast_test_receive_report_from_node_wrapper>:
ZTEST(thingset_isotp_fast, test_receive_report_from_node)
  404c24:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  404c28:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404c2c:	910003fd 	mov	x29, sp
  404c30:	f9475c00 	ldr	x0, [x0, #3768]
  404c34:	a90153f3 	stp	x19, x20, [sp, #16]
  404c38:	a9025bf5 	stp	x21, x22, [sp, #32]
  404c3c:	f9400001 	ldr	x1, [x0]
  404c40:	f90027e1 	str	x1, [sp, #72]
  404c44:	d2800001 	mov	x1, #0x0                   	// #0
    struct can_frame report_frame = {
  404c48:	d2800040 	mov	x0, #0x2                   	// #2
  404c4c:	f2a3c000 	movk	x0, #0x1e00, lsl #16
  404c50:	f2c02020 	movk	x0, #0x101, lsl #32
  404c54:	f9001fe0 	str	x0, [sp, #56]
  404c58:	d2801ec0 	mov	x0, #0xf6                  	// #246
  404c5c:	f90023e0 	str	x0, [sp, #64]
	z_impl_k_sem_reset(sem);
  404c60:	f0000176 	adrp	x22, 433000 <obj_0x28+0x18>
  404c64:	911922d6 	add	x22, x22, #0x648
  404c68:	aa1603e0 	mov	x0, x22
  404c6c:	94003acb 	bl	413798 <z_impl_k_sem_reset>
  404c70:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404c74:	9100e3e1 	add	x1, sp, #0x38
  404c78:	d2800004 	mov	x4, #0x0                   	// #0
  404c7c:	d2800003 	mov	x3, #0x0                   	// #0
  404c80:	f946fc00 	ldr	x0, [x0, #3576]
  404c84:	d2800022 	mov	x2, #0x1                   	// #1
    zassert_equal(err, 0, "can_send failed: %d", err);
  404c88:	900000b5 	adrp	x21, 418000 <table.0+0x1d8>
  404c8c:	900000b4 	adrp	x20, 418000 <table.0+0x1d8>
  404c90:	911602b5 	add	x21, x21, #0x580
  404c94:	910e8e94 	add	x20, x20, #0x3a3
  404c98:	94001c44 	bl	40bda8 <z_impl_can_send>
  404c9c:	7100001f 	cmp	w0, #0x0
  404ca0:	900000b3 	adrp	x19, 418000 <table.0+0x1d8>
  404ca4:	91114a73 	add	x19, x19, #0x452
  404ca8:	2a0003e6 	mov	w6, w0
  404cac:	aa1503e4 	mov	x4, x21
  404cb0:	aa1403e2 	mov	x2, x20
  404cb4:	aa1303e1 	mov	x1, x19
  404cb8:	1a9f17e0 	cset	w0, eq  // eq = none
  404cbc:	52800503 	mov	w3, #0x28                  	// #40
  404cc0:	900000a5 	adrp	x5, 418000 <table.0+0x1d8>
  404cc4:	91119ca5 	add	x5, x5, #0x467
  404cc8:	97ffff3f 	bl	4049c4 <z_zassert.constprop.0>
	return z_impl_k_sem_take(sem, timeout);
  404ccc:	d2800141 	mov	x1, #0xa                   	// #10
  404cd0:	aa1603e0 	mov	x0, x22
  404cd4:	94003a40 	bl	4135d4 <z_impl_k_sem_take>
    zassert_equal(err, 0, "receive timeout");
  404cd8:	7100001f 	cmp	w0, #0x0
  404cdc:	aa1403e2 	mov	x2, x20
  404ce0:	aa1303e1 	mov	x1, x19
  404ce4:	1a9f17e0 	cset	w0, eq  // eq = none
  404ce8:	aa1503e4 	mov	x4, x21
  404cec:	900000a5 	adrp	x5, 418000 <table.0+0x1d8>
  404cf0:	52800563 	mov	w3, #0x2b                  	// #43
  404cf4:	911108a5 	add	x5, x5, #0x442
  404cf8:	97ffff33 	bl	4049c4 <z_zassert.constprop.0>
ZTEST(thingset_isotp_fast, test_receive_report_from_node)
  404cfc:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404d00:	f9475c00 	ldr	x0, [x0, #3768]
  404d04:	f94027e2 	ldr	x2, [sp, #72]
  404d08:	f9400001 	ldr	x1, [x0]
  404d0c:	eb010042 	subs	x2, x2, x1
  404d10:	d2800001 	mov	x1, #0x0                   	// #0
  404d14:	54000040 	b.eq	404d1c <_thingset_isotp_fast_test_receive_report_from_node_wrapper+0xf8>  // b.none
  404d18:	97fff202 	bl	401520 <__stack_chk_fail@plt>
  404d1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  404d20:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404d24:	a8c57bfd 	ldp	x29, x30, [sp], #80
  404d28:	d65f03c0 	ret

0000000000404d2c <thingset_isotp_fast_setup>:
}

static void *thingset_isotp_fast_setup(void)
{
  404d2c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  404d30:	910003fd 	mov	x29, sp
  404d34:	a90153f3 	stp	x19, x20, [sp, #16]
  404d38:	a9025bf5 	stp	x21, x22, [sp, #32]
  404d3c:	f9001bf7 	str	x23, [sp, #48]
	return z_impl_k_sem_init(sem, initial_count, limit);
  404d40:	52800022 	mov	w2, #0x1                   	// #1
  404d44:	52800001 	mov	w1, #0x0                   	// #0
  404d48:	f0000160 	adrp	x0, 433000 <obj_0x28+0x18>
  404d4c:	91192000 	add	x0, x0, #0x648
  404d50:	940039df 	bl	4134cc <z_impl_k_sem_init>
  404d54:	52800022 	mov	w2, #0x1                   	// #1
  404d58:	52800001 	mov	w1, #0x0                   	// #0
  404d5c:	f0000160 	adrp	x0, 433000 <obj_0x28+0x18>
  404d60:	9119c000 	add	x0, x0, #0x670
  404d64:	940039da 	bl	4134cc <z_impl_k_sem_init>
    int err;

    k_sem_init(&report_rx_sem, 0, 1);
    k_sem_init(&request_tx_sem, 0, 1);

    thingset_init_global(&ts);
  404d68:	f0000160 	adrp	x0, 433000 <obj_0x28+0x18>
  404d6c:	911a6000 	add	x0, x0, #0x698
  404d70:	94001edb 	bl	40c8dc <thingset_init_global>
  404d74:	b0000173 	adrp	x19, 431000 <__FRAME_END__+0x10804>

    zassert_true(device_is_ready(can_dev), "CAN device not ready");
  404d78:	900000b5 	adrp	x21, 418000 <table.0+0x1d8>
  404d7c:	900000b4 	adrp	x20, 418000 <table.0+0x1d8>
  404d80:	9114e2b5 	add	x21, x21, #0x538
  404d84:	f946fe73 	ldr	x19, [x19, #3576]
  404d88:	910e8e94 	add	x20, x20, #0x3a3
  404d8c:	aa1303e0 	mov	x0, x19
  404d90:	94003197 	bl	4113ec <z_device_is_ready>
  404d94:	aa1503e4 	mov	x4, x21
  404d98:	aa1403e2 	mov	x2, x20
  404d9c:	52800a23 	mov	w3, #0x51                  	// #81
  404da0:	900000a5 	adrp	x5, 418000 <table.0+0x1d8>
  404da4:	900000a1 	adrp	x1, 418000 <table.0+0x1d8>
  404da8:	910a3ca5 	add	x5, x5, #0x28f
  404dac:	9111ec21 	add	x1, x1, #0x47b
  404db0:	97ffff05 	bl	4049c4 <z_zassert.constprop.0>
	return api->stop(dev);
  404db4:	f9400a77 	ldr	x23, [x19, #16]
  404db8:	aa1303e0 	mov	x0, x19
  404dbc:	f9400ae1 	ldr	x1, [x23, #16]
  404dc0:	d63f0020 	blr	x1
	return api->set_mode(dev, mode);
  404dc4:	f9400ee2 	ldr	x2, [x23, #24]
  404dc8:	aa1303e0 	mov	x0, x19
  404dcc:	52800021 	mov	w1, #0x1                   	// #1

    (void)can_stop(can_dev);

    err = can_set_mode(can_dev, CAN_MODE_LOOPBACK);
    zassert_equal(err, 0, "failed to set loopback mode (err %d)", err);
  404dd0:	900000b6 	adrp	x22, 418000 <table.0+0x1d8>
  404dd4:	91114ad6 	add	x22, x22, #0x452
  404dd8:	d63f0040 	blr	x2
  404ddc:	7100001f 	cmp	w0, #0x0
  404de0:	2a0003e6 	mov	w6, w0
  404de4:	aa1503e4 	mov	x4, x21
  404de8:	aa1403e2 	mov	x2, x20
  404dec:	aa1603e1 	mov	x1, x22
  404df0:	1a9f17e0 	cset	w0, eq  // eq = none
  404df4:	52800ac3 	mov	w3, #0x56                  	// #86
  404df8:	900000a5 	adrp	x5, 418000 <table.0+0x1d8>
  404dfc:	91127ca5 	add	x5, x5, #0x49f
  404e00:	97fffef1 	bl	4049c4 <z_zassert.constprop.0>
	return api->start(dev);
  404e04:	f94006e1 	ldr	x1, [x23, #8]
  404e08:	aa1303e0 	mov	x0, x19
  404e0c:	d63f0020 	blr	x1

    err = can_start(can_dev);
    zassert_equal(err, 0, "failed to start CAN controller (err %d)", err);
  404e10:	7100001f 	cmp	w0, #0x0
  404e14:	2a0003e6 	mov	w6, w0
  404e18:	aa1503e4 	mov	x4, x21
  404e1c:	aa1403e2 	mov	x2, x20
  404e20:	aa1603e1 	mov	x1, x22
  404e24:	1a9f17e0 	cset	w0, eq  // eq = none
  404e28:	52800b23 	mov	w3, #0x59                  	// #89
  404e2c:	900000a5 	adrp	x5, 418000 <table.0+0x1d8>
  404e30:	911310a5 	add	x5, x5, #0x4c4
  404e34:	97fffee4 	bl	4049c4 <z_zassert.constprop.0>
	return z_impl_k_sleep(timeout);
  404e38:	d2800c80 	mov	x0, #0x64                  	// #100
  404e3c:	94004576 	bl	416414 <z_impl_k_sleep>

    /* wait for address claiming to finish */
    k_sleep(K_MSEC(1000));

    thingset_can_set_report_rx_callback(report_rx_callback);
  404e40:	90000000 	adrp	x0, 404000 <thingset_can_report_tx_handler+0x7c>
  404e44:	9126e000 	add	x0, x0, #0x9b8
  404e48:	97fffed8 	bl	4049a8 <thingset_can_set_report_rx_callback>

    return NULL;
}
  404e4c:	d2800000 	mov	x0, #0x0                   	// #0
  404e50:	a94153f3 	ldp	x19, x20, [sp, #16]
  404e54:	a9425bf5 	ldp	x21, x22, [sp, #32]
  404e58:	f9401bf7 	ldr	x23, [sp, #48]
  404e5c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  404e60:	d65f03c0 	ret

0000000000404e64 <cbvprintf_package>:
	return cb(str, strl, ctx);
}

int cbvprintf_package(void *packaged, size_t len, uint32_t flags,
		      const char *fmt, va_list ap)
{
  404e64:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  404e68:	910003fd 	mov	x29, sp
  404e6c:	a90153f3 	stp	x19, x20, [sp, #16]
  404e70:	aa0003f4 	mov	x20, x0
  404e74:	b0000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  404e78:	a9025bf5 	stp	x21, x22, [sp, #32]
  404e7c:	aa0103f5 	mov	x21, x1
  404e80:	f9475c00 	ldr	x0, [x0, #3768]
  404e84:	a90363f7 	stp	x23, x24, [sp, #48]
  404e88:	a9046bf9 	stp	x25, x26, [sp, #64]
  404e8c:	a90573fb 	stp	x27, x28, [sp, #80]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
	bool is_str_arg = false;
	union cbprintf_package_hdr *pkg_hdr = packaged;

	/* Buffer must be aligned at least to size of a pointer. */
	if ((uintptr_t)packaged % sizeof(void *)) {
  404e90:	f2400a9c 	ands	x28, x20, #0x7
{
  404e94:	f9400001 	ldr	x1, [x0]
  404e98:	f90067e1 	str	x1, [sp, #200]
  404e9c:	d2800001 	mov	x1, #0x0                   	// #0
  404ea0:	121e0040 	and	w0, w2, #0x4
  404ea4:	b90083e0 	str	w0, [sp, #128]
	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
  404ea8:	d3431441 	ubfx	x1, x2, #3, #3
  404eac:	29436488 	ldp	w8, w25, [x4, #24]
  404eb0:	a940289b 	ldp	x27, x10, [x4]
  404eb4:	f940088c 	ldr	x12, [x4, #16]
	if ((uintptr_t)packaged % sizeof(void *)) {
  404eb8:	54003781 	b.ne	4055a8 <cbvprintf_package+0x744>  // b.any
  404ebc:	aa0303fa 	mov	x26, x3
  404ec0:	11000421 	add	w1, w1, #0x1
	 * which is guaranteed to be at least 4 bytes, we just reserve
	 * multiple of pointer size for the above to preserve alignment.
	 *
	 * Refer to union cbprintf_package_hdr for more details.
	 */
	buf += sizeof(*pkg_hdr);
  404ec4:	91002293 	add	x19, x20, #0x8
	 * When buf0 is NULL we don't store anything.
	 * Instead we count the needed space to store the data.
	 * In this case, incoming len argument indicates the anticipated
	 * buffer "misalignment" offset.
	 */
	if (buf0 == NULL) {
  404ec8:	b5003754 	cbnz	x20, 4055b0 <cbvprintf_package+0x74c>
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  404ecc:	92400ab5 	and	x21, x21, #0x7
		 * the total as this won't be part of the buffer. To avoid
		 * going negative with an unsigned variable, we add an offset
		 * (CBPRINTF_PACKAGE_ALIGNMENT) that will be removed before
		 * returning.
		 */
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  404ed0:	d2800100 	mov	x0, #0x8                   	// #8
		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
  404ed4:	910022b3 	add	x19, x21, #0x8
		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
  404ed8:	cb150015 	sub	x21, x0, x21
	 * which is in the middle of the following while() loop. That's the
	 * reason for the post-decrement on fmt as it will be incremented
	 * prior to the next (actually first) round of that loop.
	 */
	s = fmt--;
	align = VA_STACK_ALIGN(char *);
  404edc:	52800118 	mov	w24, #0x8                   	// #8
					align = VA_STACK_ALIGN(int);
					size = sizeof(int);
				}
				continue;
			}
			switch (*fmt) {
  404ee0:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  404ee4:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  404ee8:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  404eec:	f000008b 	adrp	x11, 417000 <z_abort_timeout+0x38>
	s = fmt--;
  404ef0:	d1000749 	sub	x9, x26, #0x1
	size = sizeof(char *);
  404ef4:	2a1803f6 	mov	w22, w24
			switch (*fmt) {
  404ef8:	9138716b 	add	x11, x11, #0xe1c
  404efc:	f0000080 	adrp	x0, 417000 <z_abort_timeout+0x38>
	bool parsing = false;
  404f00:	52800017 	mov	w23, #0x0                   	// #0
			switch (*fmt) {
  404f04:	91382000 	add	x0, x0, #0xe08
	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
  404f08:	12800006 	mov	w6, #0xffffffff            	// #-1
	unsigned int s_ro_cnt = 0; /* number of ro strings */
  404f0c:	52800005 	mov	w5, #0x0                   	// #0
	unsigned int s_rw_cnt = 0; /* number of rw strings */
  404f10:	52800004 	mov	w4, #0x0                   	// #0
	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
  404f14:	52800003 	mov	w3, #0x0                   	// #0
  404f18:	d280002d 	mov	x13, #0x1                   	// #1
			switch (*fmt) {
  404f1c:	f2c0004e 	movk	x14, #0x2, lsl #32
  404f20:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  404f24:	f2e06012 	movk	x18, #0x300, lsl #48
  404f28:	f90033e0 	str	x0, [sp, #96]

		/* copy va_list data over to our buffer */
		if (is_str_arg) {
			s = va_arg(ap, char *);
process_string:
			if (buf0 != NULL) {
  404f2c:	b4000054 	cbz	x20, 404f34 <cbvprintf_package+0xd0>
				*(const char **)buf = s;
  404f30:	f900027a 	str	x26, [x19]
			}

			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);

			if (is_ro && !do_ro) {
  404f34:	721f0050 	ands	w16, w2, #0x2
  404f38:	7a400824 	ccmp	w1, #0x0, #0x4, eq  // eq = none
  404f3c:	54001aec 	b.gt	405298 <cbvprintf_package+0x434>
				/* nothing to do */
			} else {
				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
  404f40:	cb140260 	sub	x0, x19, x20
  404f44:	d342fc00 	lsr	x0, x0, #2
				 * In the do_ro case we must consider
				 * room for possible STR_POS_RO_FLAG.
				 * Otherwise the index range is 8 bits
				 * and any overflow is caught later.
				 */
				if (do_ro && s_ptr_idx > STR_POS_MASK) {
  404f48:	7101fc1f 	cmp	w0, #0x7f
  404f4c:	7a408a04 	ccmp	w16, #0x0, #0x4, hi  // hi = pmore
  404f50:	54001640 	b.eq	405218 <cbvprintf_package+0x3b4>  // b.none
					__ASSERT(false, "String with too many arguments");
  404f54:	900000b3 	adrp	x19, 418000 <table.0+0x1d8>
  404f58:	9116ca73 	add	x19, x19, #0x5b2
  404f5c:	aa1303e2 	mov	x2, x19
  404f60:	d00000a1 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  404f64:	91253c21 	add	x1, x1, #0x94f
  404f68:	52804f63 	mov	w3, #0x27b                 	// #635
  404f6c:	900000a0 	adrp	x0, 418000 <table.0+0x1d8>
  404f70:	91178000 	add	x0, x0, #0x5e0
  404f74:	940007ad 	bl	406e28 <assert_print>
  404f78:	900000a0 	adrp	x0, 418000 <table.0+0x1d8>
  404f7c:	9117f400 	add	x0, x0, #0x5fd
  404f80:	940007aa 	bl	406e28 <assert_print>
  404f84:	aa1303e0 	mov	x0, x19
  404f88:	52804f61 	mov	w1, #0x27b                 	// #635
  404f8c:	940007d1 	bl	406ed0 <assert_post_action>
  404f90:	52804f62 	mov	w2, #0x27b                 	// #635
					return -EINVAL;
				}

				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
					__ASSERT(false, "str_ptr_pos[] too small");
  404f94:	900000a0 	adrp	x0, 418000 <table.0+0x1d8>
  404f98:	aa1303e1 	mov	x1, x19
  404f9c:	91187800 	add	x0, x0, #0x61e
  404fa0:	940011be 	bl	409698 <posix_print_error_and_exit>
			switch (*fmt) {
  404fa4:	7101e91f 	cmp	w8, #0x7a
  404fa8:	540000e8 	b.hi	404fc4 <cbvprintf_package+0x160>  // b.pmore
  404fac:	71019d1f 	cmp	w8, #0x67
  404fb0:	54000208 	b.hi	404ff0 <cbvprintf_package+0x18c>  // b.pmore
  404fb4:	7100a91f 	cmp	w8, #0x2a
  404fb8:	54000408 	b.hi	405038 <cbvprintf_package+0x1d4>  // b.pmore
  404fbc:	71007d1f 	cmp	w8, #0x1f
  404fc0:	540002e8 	b.hi	40501c <cbvprintf_package+0x1b8>  // b.pmore
				parsing = false;
  404fc4:	52800017 	mov	w23, #0x0                   	// #0
			if (*++fmt == '\0') {
  404fc8:	38401d28 	ldrb	w8, [x9, #1]!
  404fcc:	340022a8 	cbz	w8, 405420 <cbvprintf_package+0x5bc>
			if (!parsing) {
  404fd0:	35fffeb7 	cbnz	w23, 404fa4 <cbvprintf_package+0x140>
				if (*fmt == '%') {
  404fd4:	7100951f 	cmp	w8, #0x25
  404fd8:	54ffff81 	b.ne	404fc8 <cbvprintf_package+0x164>  // b.any
					arg_idx++;
  404fdc:	110004c6 	add	w6, w6, #0x1
					parsing = true;
  404fe0:	52800037 	mov	w23, #0x1                   	// #1
					align = VA_STACK_ALIGN(int);
  404fe4:	52800118 	mov	w24, #0x8                   	// #8
					size = sizeof(int);
  404fe8:	52800096 	mov	w22, #0x4                   	// #4
  404fec:	17fffff7 	b	404fc8 <cbvprintf_package+0x164>
			switch (*fmt) {
  404ff0:	5101a108 	sub	w8, w8, #0x68
  404ff4:	7100491f 	cmp	w8, #0x12
  404ff8:	54fffe68 	b.hi	404fc4 <cbvprintf_package+0x160>  // b.pmore
  404ffc:	f94033e7 	ldr	x7, [sp, #96]
  405000:	386848e8 	ldrb	w8, [x7, w8, uxtw]
  405004:	10000070 	adr	x16, 405010 <cbvprintf_package+0x1ac>
  405008:	8b288a08 	add	x8, x16, w8, sxtb #2
  40500c:	d61f0100 	br	x8
  405010:	52800118 	mov	w24, #0x8                   	// #8
  405014:	2a1803f6 	mov	w22, w24
  405018:	17ffffec 	b	404fc8 <cbvprintf_package+0x164>
  40501c:	51008108 	sub	w8, w8, #0x20
  405020:	7100291f 	cmp	w8, #0xa
  405024:	54fffd08 	b.hi	404fc4 <cbvprintf_package+0x160>  // b.pmore
  405028:	38684968 	ldrb	w8, [x11, w8, uxtw]
  40502c:	10000070 	adr	x16, 405038 <cbvprintf_package+0x1d4>
  405030:	8b288a08 	add	x8, x16, w8, sxtb #2
  405034:	d61f0100 	br	x8
  405038:	5100ad08 	sub	w8, w8, #0x2b
  40503c:	9ac821a8 	lsl	x8, x13, x8
  405040:	ea0e011f 	tst	x8, x14
  405044:	54fffc21 	b.ne	404fc8 <cbvprintf_package+0x164>  // b.any
  405048:	ea0f011f 	tst	x8, x15
  40504c:	540003e1 	b.ne	4050c8 <cbvprintf_package+0x264>  // b.any
  405050:	ea12011f 	tst	x8, x18
  405054:	54fffb80 	b.eq	404fc4 <cbvprintf_package+0x160>  // b.none
				if (fmt[-1] == 'l') {
  405058:	385ff128 	ldurb	w8, [x9, #-1]
				parsing = false;
  40505c:	52800017 	mov	w23, #0x0                   	// #0
				if (fmt[-1] == 'l') {
  405060:	7101b11f 	cmp	w8, #0x6c
  405064:	52800008 	mov	w8, #0x0                   	// #0
  405068:	54000061 	b.ne	405074 <cbvprintf_package+0x210>  // b.any
				align = VA_STACK_ALIGN(void *);
  40506c:	52800118 	mov	w24, #0x8                   	// #8
				size = sizeof(void *);
  405070:	2a1803f6 	mov	w22, w24
		buf = (void *) ROUND_UP(buf, align);
  405074:	2a1803f0 	mov	w16, w24
  405078:	d1000673 	sub	x19, x19, #0x1
  40507c:	8b384273 	add	x19, x19, w24, uxtw
  405080:	cb1003f0 	neg	x16, x16
  405084:	8a100273 	and	x19, x19, x16
		if (buf0 != NULL && BUF_OFFSET + size > len) {
  405088:	b40000d4 	cbz	x20, 4050a0 <cbvprintf_package+0x23c>
  40508c:	2a1603f0 	mov	w16, w22
  405090:	cb140210 	sub	x16, x16, x20
  405094:	8b130210 	add	x16, x16, x19
  405098:	eb15021f 	cmp	x16, x21
  40509c:	54000408 	b.hi	40511c <cbvprintf_package+0x2b8>  // b.pmore
		if (is_str_arg) {
  4050a0:	34001488 	cbz	w8, 405330 <cbvprintf_package+0x4cc>
			s = va_arg(ap, char *);
  4050a4:	37f80a80 	tbnz	w0, #31, 4051f4 <cbvprintf_package+0x390>
  4050a8:	91003fdb 	add	x27, x30, #0xf
  4050ac:	2a0003e8 	mov	w8, w0
  4050b0:	927df37b 	and	x27, x27, #0xfffffffffffffff8
			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
  4050b4:	51000421 	sub	w1, w1, #0x1
			s = va_arg(ap, char *);
  4050b8:	f94003da 	ldr	x26, [x30]
  4050bc:	17ffff9c 	b	404f2c <cbvprintf_package+0xc8>
				arg_idx--;
  4050c0:	510004c6 	sub	w6, w6, #0x1
				continue;
  4050c4:	17ffffc0 	b	404fc4 <cbvprintf_package+0x160>
				if (fmt[-1] == 'L') {
  4050c8:	385ff138 	ldurb	w24, [x9, #-1]
  4050cc:	7101331f 	cmp	w24, #0x4c
  4050d0:	540004a1 	b.ne	405164 <cbvprintf_package+0x300>  // b.any
					v.ld = va_arg(ap, long double);
  4050d4:	37f80379 	tbnz	w25, #31, 405140 <cbvprintf_package+0x2dc>
  4050d8:	91003fc8 	add	x8, x30, #0xf
  4050dc:	2a1903f7 	mov	w23, w25
  4050e0:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  4050e4:	9100411e 	add	x30, x8, #0x10
  4050e8:	a9404510 	ldp	x16, x17, [x8]
					size = sizeof(long double);
  4050ec:	aa1e03e8 	mov	x8, x30
  4050f0:	52800216 	mov	w22, #0x10                  	// #16
				buf = (void *) ROUND_UP(buf, align);
  4050f4:	2a1603f9 	mov	w25, w22
  4050f8:	d1000673 	sub	x19, x19, #0x1
  4050fc:	8b364273 	add	x19, x19, w22, uxtw
  405100:	cb1903fb 	neg	x27, x25
  405104:	8a1b0273 	and	x19, x19, x27
				if (buf0 != NULL) {
  405108:	b40005b4 	cbz	x20, 4051bc <cbvprintf_package+0x358>
					if (BUF_OFFSET + size > len) {
  40510c:	cb14033b 	sub	x27, x25, x20
  405110:	8b13037b 	add	x27, x27, x19
  405114:	eb15037f 	cmp	x27, x21
  405118:	54000489 	b.ls	4051a8 <cbvprintf_package+0x344>  // b.plast
			return -ENOSPC;
  40511c:	12800360 	mov	w0, #0xffffffe4            	// #-28
	return BUF_OFFSET;

#undef BUF_OFFSET
#undef STR_POS_RO_FLAG
#undef STR_POS_MASK
}
  405120:	90000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  405124:	f9475c21 	ldr	x1, [x1, #3768]
  405128:	f94067e3 	ldr	x3, [sp, #200]
  40512c:	f9400022 	ldr	x2, [x1]
  405130:	eb020063 	subs	x3, x3, x2
  405134:	d2800002 	mov	x2, #0x0                   	// #0
  405138:	54002420 	b.eq	4055bc <cbvprintf_package+0x758>  // b.none
  40513c:	97fff0f9 	bl	401520 <__stack_chk_fail@plt>
					v.ld = va_arg(ap, long double);
  405140:	11004337 	add	w23, w25, #0x10
  405144:	710002ff 	cmp	w23, #0x0
  405148:	540000ad 	b.le	40515c <cbvprintf_package+0x2f8>
  40514c:	91003fc8 	add	x8, x30, #0xf
  405150:	927ced08 	and	x8, x8, #0xfffffffffffffff0
  405154:	9100411e 	add	x30, x8, #0x10
  405158:	17ffffe4 	b	4050e8 <cbvprintf_package+0x284>
  40515c:	8b39c188 	add	x8, x12, w25, sxtw
  405160:	17ffffe2 	b	4050e8 <cbvprintf_package+0x284>
					v.d = va_arg(ap, double);
  405164:	37f80119 	tbnz	w25, #31, 405184 <cbvprintf_package+0x320>
  405168:	91003fc8 	add	x8, x30, #0xf
  40516c:	2a1903f7 	mov	w23, w25
  405170:	927df108 	and	x8, x8, #0xfffffffffffffff8
  405174:	d2800011 	mov	x17, #0x0                   	// #0
					size = sizeof(double);
  405178:	52800116 	mov	w22, #0x8                   	// #8
					v.d = va_arg(ap, double);
  40517c:	f94003d0 	ldr	x16, [x30]
					size = sizeof(double);
  405180:	17ffffdd 	b	4050f4 <cbvprintf_package+0x290>
					v.d = va_arg(ap, double);
  405184:	11004337 	add	w23, w25, #0x10
  405188:	710002ff 	cmp	w23, #0x0
  40518c:	5400008d 	b.le	40519c <cbvprintf_package+0x338>
  405190:	91003fc8 	add	x8, x30, #0xf
  405194:	927df108 	and	x8, x8, #0xfffffffffffffff8
  405198:	17fffff7 	b	405174 <cbvprintf_package+0x310>
  40519c:	aa1e03e8 	mov	x8, x30
  4051a0:	8b39c19e 	add	x30, x12, w25, sxtw
  4051a4:	17fffff4 	b	405174 <cbvprintf_package+0x310>
					} else if (fmt[-1] == 'L') {
  4051a8:	7101331f 	cmp	w24, #0x4c
  4051ac:	54000121 	b.ne	4051d0 <cbvprintf_package+0x36c>  // b.any
						*(long double *)buf = v.ld;
  4051b0:	9e670200 	fmov	d0, x16
  4051b4:	9eaf0220 	fmov	v0.d[1], x17
  4051b8:	3d800260 	str	q0, [x19]
				buf += size;
  4051bc:	8b190273 	add	x19, x19, x25
				continue;
  4051c0:	aa0803fe 	mov	x30, x8
  4051c4:	2a1703f9 	mov	w25, w23
  4051c8:	2a1603f8 	mov	w24, w22
  4051cc:	17ffff7e 	b	404fc4 <cbvprintf_package+0x160>
						*(double *)buf = v.d;
  4051d0:	f9000270 	str	x16, [x19]
  4051d4:	17fffffa 	b	4051bc <cbvprintf_package+0x358>
			switch (*fmt) {
  4051d8:	52800008 	mov	w8, #0x0                   	// #0
				parsing = false;
  4051dc:	52800017 	mov	w23, #0x0                   	// #0
  4051e0:	17ffffa3 	b	40506c <cbvprintf_package+0x208>
				is_str_arg = true;
  4051e4:	2a1703e8 	mov	w8, w23
  4051e8:	17fffffd 	b	4051dc <cbvprintf_package+0x378>
			switch (*fmt) {
  4051ec:	52800008 	mov	w8, #0x0                   	// #0
  4051f0:	17ffffa1 	b	405074 <cbvprintf_package+0x210>
			s = va_arg(ap, char *);
  4051f4:	11002008 	add	w8, w0, #0x8
  4051f8:	7100011f 	cmp	w8, #0x0
  4051fc:	5400008d 	b.le	40520c <cbvprintf_package+0x3a8>
  405200:	91003fdb 	add	x27, x30, #0xf
  405204:	927df37b 	and	x27, x27, #0xfffffffffffffff8
  405208:	17ffffab 	b	4050b4 <cbvprintf_package+0x250>
  40520c:	aa1e03fb 	mov	x27, x30
  405210:	8b20c15e 	add	x30, x10, w0, sxtw
  405214:	17ffffa8 	b	4050b4 <cbvprintf_package+0x250>
				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
  405218:	71003c7f 	cmp	w3, #0xf
  40521c:	54000249 	b.ls	405264 <cbvprintf_package+0x400>  // b.plast
					__ASSERT(false, "str_ptr_pos[] too small");
  405220:	f0000093 	adrp	x19, 418000 <table.0+0x1d8>
  405224:	9116ca73 	add	x19, x19, #0x5b2
  405228:	aa1303e2 	mov	x2, x19
  40522c:	b00000a1 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  405230:	91253c21 	add	x1, x1, #0x94f
  405234:	52805003 	mov	w3, #0x280                 	// #640
  405238:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  40523c:	91178000 	add	x0, x0, #0x5e0
  405240:	940006fa 	bl	406e28 <assert_print>
  405244:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405248:	91190c00 	add	x0, x0, #0x643
  40524c:	940006f7 	bl	406e28 <assert_print>
  405250:	aa1303e0 	mov	x0, x19
  405254:	52805001 	mov	w1, #0x280                 	// #640
  405258:	9400071e 	bl	406ed0 <assert_post_action>
  40525c:	52805002 	mov	w2, #0x280                 	// #640
  405260:	17ffff4d 	b	404f94 <cbvprintf_package+0x130>
				if (buf0 != NULL) {
  405264:	b4000274 	cbz	x20, 4052b0 <cbvprintf_package+0x44c>
					str_ptr_pos[s_idx] = s_ptr_idx;
  405268:	2a0303f0 	mov	w16, w3
  40526c:	9102a3f1 	add	x17, sp, #0xa8
					str_ptr_arg[s_idx] = arg_idx;
  405270:	9102e3fe 	add	x30, sp, #0xb8
					str_ptr_pos[s_idx] = s_ptr_idx;
  405274:	12001c00 	and	w0, w0, #0xff
  405278:	38306a20 	strb	w0, [x17, x16]
					str_ptr_arg[s_idx] = arg_idx;
  40527c:	38306bc6 	strb	w6, [x30, x16]
					if (is_ro) {
  405280:	7100003f 	cmp	w1, #0x0
  405284:	5400012d 	b.le	4052a8 <cbvprintf_package+0x444>
						s_ro_cnt++;
  405288:	110004a5 	add	w5, w5, #0x1
						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
  40528c:	32196000 	orr	w0, w0, #0xffffff80
  405290:	38306a20 	strb	w0, [x17, x16]
				s_idx++;
  405294:	11000463 	add	w3, w3, #0x1
			buf += sizeof(char *);
  405298:	91002273 	add	x19, x19, #0x8
			is_str_arg = false;
  40529c:	2a0803e0 	mov	w0, w8
  4052a0:	aa1b03fe 	mov	x30, x27
  4052a4:	17ffff49 	b	404fc8 <cbvprintf_package+0x164>
						s_rw_cnt++;
  4052a8:	11000484 	add	w4, w4, #0x1
  4052ac:	17fffffa 	b	405294 <cbvprintf_package+0x430>
				} else if (is_ro) {
  4052b0:	7100003f 	cmp	w1, #0x0
  4052b4:	5400006d 	b.le	4052c0 <cbvprintf_package+0x45c>
					len += 1;
  4052b8:	910006b5 	add	x21, x21, #0x1
  4052bc:	17fffff6 	b	405294 <cbvprintf_package+0x430>
				} else if (rws_pos_en) {
  4052c0:	b94083e0 	ldr	w0, [sp, #128]
					len += 2;
  4052c4:	91000ab5 	add	x21, x21, #0x2
				} else if (rws_pos_en) {
  4052c8:	35fffe60 	cbnz	w0, 405294 <cbvprintf_package+0x430>
					len += strlen(s) + 1 + 1;
  4052cc:	aa1a03e0 	mov	x0, x26
  4052d0:	a906b3ea 	stp	x10, x12, [sp, #104]
  4052d4:	f9003fe9 	str	x9, [sp, #120]
  4052d8:	291093e3 	stp	w3, w4, [sp, #132]
  4052dc:	29119be5 	stp	w5, w6, [sp, #140]
  4052e0:	2912a3e1 	stp	w1, w8, [sp, #148]
  4052e4:	b9009fe2 	str	w2, [sp, #156]
  4052e8:	97fff022 	bl	401370 <strlen@plt>
  4052ec:	d2c40012 	mov	x18, #0x200000000000        	// #35184372088832
  4052f0:	d2a3880f 	mov	x15, #0x1c400000            	// #473956352
  4052f4:	d28ffdae 	mov	x14, #0x7fed                	// #32749
  4052f8:	8b0002b5 	add	x21, x21, x0
  4052fc:	295093e3 	ldp	w3, w4, [sp, #132]
  405300:	d0000080 	adrp	x0, 417000 <z_abort_timeout+0x38>
  405304:	29519be5 	ldp	w5, w6, [sp, #140]
  405308:	9138700b 	add	x11, x0, #0xe1c
  40530c:	2952a3e1 	ldp	w1, w8, [sp, #148]
  405310:	f2e06012 	movk	x18, #0x300, lsl #48
  405314:	b9409fe2 	ldr	w2, [sp, #156]
  405318:	f2e3880f 	movk	x15, #0x1c40, lsl #48
  40531c:	f2c0004e 	movk	x14, #0x2, lsl #32
  405320:	d280002d 	mov	x13, #0x1                   	// #1
  405324:	a946b3ea 	ldp	x10, x12, [sp, #104]
  405328:	f9403fe9 	ldr	x9, [sp, #120]
  40532c:	17ffffda 	b	405294 <cbvprintf_package+0x430>
		} else if (size == sizeof(int)) {
  405330:	710012df 	cmp	w22, #0x4
  405334:	540002a1 	b.ne	405388 <cbvprintf_package+0x524>  // b.any
			int v = va_arg(ap, int);
  405338:	37f80160 	tbnz	w0, #31, 405364 <cbvprintf_package+0x500>
  40533c:	91002fc8 	add	x8, x30, #0xb
  405340:	2a0003f0 	mov	w16, w0
  405344:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  405348:	b4000074 	cbz	x20, 405354 <cbvprintf_package+0x4f0>
			int v = va_arg(ap, int);
  40534c:	b94003c0 	ldr	w0, [x30]
				*(int *)buf = v;
  405350:	b9000260 	str	w0, [x19]
			buf += sizeof(int);
  405354:	91001273 	add	x19, x19, #0x4
  405358:	2a1003e0 	mov	w0, w16
  40535c:	aa0803fe 	mov	x30, x8
  405360:	17ffff1a 	b	404fc8 <cbvprintf_package+0x164>
			int v = va_arg(ap, int);
  405364:	11002010 	add	w16, w0, #0x8
  405368:	7100021f 	cmp	w16, #0x0
  40536c:	5400008d 	b.le	40537c <cbvprintf_package+0x518>
  405370:	91002fc8 	add	x8, x30, #0xb
  405374:	927df108 	and	x8, x8, #0xfffffffffffffff8
  405378:	17fffff4 	b	405348 <cbvprintf_package+0x4e4>
  40537c:	aa1e03e8 	mov	x8, x30
  405380:	8b20c15e 	add	x30, x10, w0, sxtw
  405384:	17fffff1 	b	405348 <cbvprintf_package+0x4e4>
		} else if (size == sizeof(long)) {
  405388:	710022df 	cmp	w22, #0x8
  40538c:	54000261 	b.ne	4053d8 <cbvprintf_package+0x574>  // b.any
			long v = va_arg(ap, long);
  405390:	37f80120 	tbnz	w0, #31, 4053b4 <cbvprintf_package+0x550>
  405394:	91003fc8 	add	x8, x30, #0xf
  405398:	2a0003f0 	mov	w16, w0
  40539c:	927df108 	and	x8, x8, #0xfffffffffffffff8
			if (buf0 != NULL) {
  4053a0:	b4000074 	cbz	x20, 4053ac <cbvprintf_package+0x548>
			long v = va_arg(ap, long);
  4053a4:	f94003c0 	ldr	x0, [x30]
				*(long *)buf = v;
  4053a8:	f9000260 	str	x0, [x19]
			buf += sizeof(long);
  4053ac:	91002273 	add	x19, x19, #0x8
  4053b0:	17ffffea 	b	405358 <cbvprintf_package+0x4f4>
			long v = va_arg(ap, long);
  4053b4:	11002010 	add	w16, w0, #0x8
  4053b8:	7100021f 	cmp	w16, #0x0
  4053bc:	5400008d 	b.le	4053cc <cbvprintf_package+0x568>
  4053c0:	91003fc8 	add	x8, x30, #0xf
  4053c4:	927df108 	and	x8, x8, #0xfffffffffffffff8
  4053c8:	17fffff6 	b	4053a0 <cbvprintf_package+0x53c>
  4053cc:	aa1e03e8 	mov	x8, x30
  4053d0:	8b20c15e 	add	x30, x10, w0, sxtw
  4053d4:	17fffff3 	b	4053a0 <cbvprintf_package+0x53c>
			__ASSERT(false, "unexpected size %u", size);
  4053d8:	f0000093 	adrp	x19, 418000 <table.0+0x1d8>
  4053dc:	9116ca73 	add	x19, x19, #0x5b2
  4053e0:	aa1303e2 	mov	x2, x19
  4053e4:	528058a3 	mov	w3, #0x2c5                 	// #709
  4053e8:	b00000a1 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4053ec:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4053f0:	91253c21 	add	x1, x1, #0x94f
  4053f4:	91178000 	add	x0, x0, #0x5e0
  4053f8:	9400068c 	bl	406e28 <assert_print>
  4053fc:	2a1603e1 	mov	w1, w22
  405400:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405404:	91197400 	add	x0, x0, #0x65d
  405408:	94000688 	bl	406e28 <assert_print>
  40540c:	aa1303e0 	mov	x0, x19
  405410:	528058a1 	mov	w1, #0x2c5                 	// #709
  405414:	940006af 	bl	406ed0 <assert_post_action>
  405418:	528058a2 	mov	w2, #0x2c5                 	// #709
  40541c:	17fffede 	b	404f94 <cbvprintf_package+0x130>
	if (BUF_OFFSET / sizeof(int) > 255) {
  405420:	cb140261 	sub	x1, x19, x20
  405424:	f10ffc3f 	cmp	x1, #0x3ff
  405428:	54000249 	b.ls	405470 <cbvprintf_package+0x60c>  // b.plast
		__ASSERT(false, "too many format args");
  40542c:	f0000093 	adrp	x19, 418000 <table.0+0x1d8>
  405430:	9116ca73 	add	x19, x19, #0x5b2
  405434:	aa1303e2 	mov	x2, x19
  405438:	b00000a1 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  40543c:	91253c21 	add	x1, x1, #0x94f
  405440:	52805a23 	mov	w3, #0x2d1                 	// #721
  405444:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405448:	91178000 	add	x0, x0, #0x5e0
  40544c:	94000677 	bl	406e28 <assert_print>
  405450:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405454:	9119c800 	add	x0, x0, #0x672
  405458:	94000674 	bl	406e28 <assert_print>
  40545c:	aa1303e0 	mov	x0, x19
  405460:	52805a21 	mov	w1, #0x2d1                 	// #721
  405464:	9400069b 	bl	406ed0 <assert_post_action>
  405468:	52805a22 	mov	w2, #0x2d1                 	// #721
  40546c:	17fffeca 	b	404f94 <cbvprintf_package+0x130>
	if (buf0 == NULL) {
  405470:	b5000094 	cbnz	x20, 405480 <cbvprintf_package+0x61c>
		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
  405474:	510022a0 	sub	w0, w21, #0x8
  405478:	0b010000 	add	w0, w0, w1
  40547c:	17ffff29 	b	405120 <cbvprintf_package+0x2bc>
	if (rws_pos_en) {
  405480:	b94083e0 	ldr	w0, [sp, #128]
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  405484:	d342fc21 	lsr	x1, x1, #2
	*(char **)buf0 = NULL;
  405488:	f900029f 	str	xzr, [x20]
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  40548c:	12001c84 	and	w4, w4, #0xff
	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
  405490:	39000281 	strb	w1, [x20]
	if (rws_pos_en) {
  405494:	34000120 	cbz	w0, 4054b8 <cbvprintf_package+0x654>
		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
  405498:	39000e84 	strb	w4, [x20, #3]
	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
  40549c:	39000a85 	strb	w5, [x20, #2]
	if (s_ro_cnt) {
  4054a0:	9102a3f8 	add	x24, sp, #0xa8
  4054a4:	35000265 	cbnz	w5, 4054f0 <cbvprintf_package+0x68c>
		if (BUF_OFFSET + 1 + size > len) {
  4054a8:	d2800036 	mov	x22, #0x1                   	// #1
			*buf++ = str_ptr_arg[i];
  4054ac:	9102e3f7 	add	x23, sp, #0xb8
		if (BUF_OFFSET + 1 + size > len) {
  4054b0:	cb1402d6 	sub	x22, x22, x20
  4054b4:	1400002d 	b	405568 <cbvprintf_package+0x704>
		pkg_hdr->desc.str_cnt = s_rw_cnt;
  4054b8:	39000684 	strb	w4, [x20, #1]
		pkg_hdr->desc.rw_str_cnt = 0;
  4054bc:	17fffff8 	b	40549c <cbvprintf_package+0x638>
			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
  4054c0:	38e16b04 	ldrsb	w4, [x24, x1]
  4054c4:	38786820 	ldrb	w0, [x1, x24]
  4054c8:	36f800c4 	tbz	w4, #31, 4054e0 <cbvprintf_package+0x67c>
			if (BUF_OFFSET + 1 > len) {
  4054cc:	8b020264 	add	x4, x19, x2
			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
  4054d0:	12001800 	and	w0, w0, #0x7f
			if (BUF_OFFSET + 1 > len) {
  4054d4:	eb15009f 	cmp	x4, x21
  4054d8:	54ffe228 	b.hi	40511c <cbvprintf_package+0x2b8>  // b.pmore
			*buf++ = pos;
  4054dc:	38001660 	strb	w0, [x19], #1
		for (i = 0; i < s_idx; i++) {
  4054e0:	91000421 	add	x1, x1, #0x1
  4054e4:	6b01007f 	cmp	w3, w1
  4054e8:	54fffec8 	b.hi	4054c0 <cbvprintf_package+0x65c>  // b.pmore
  4054ec:	17ffffef 	b	4054a8 <cbvprintf_package+0x644>
			if (BUF_OFFSET + 1 > len) {
  4054f0:	d2800022 	mov	x2, #0x1                   	// #1
  4054f4:	d2800001 	mov	x1, #0x0                   	// #0
  4054f8:	cb140042 	sub	x2, x2, x20
  4054fc:	17fffffa 	b	4054e4 <cbvprintf_package+0x680>
		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
  405500:	34000065 	cbz	w5, 40550c <cbvprintf_package+0x6a8>
  405504:	39c00300 	ldrsb	w0, [x24]
  405508:	37f802c0 	tbnz	w0, #31, 405560 <cbvprintf_package+0x6fc>
		if (rws_pos_en) {
  40550c:	b94083e0 	ldr	w0, [sp, #128]
  405510:	34000340 	cbz	w0, 405578 <cbvprintf_package+0x714>
			*buf++ = str_ptr_arg[i];
  405514:	38776b80 	ldrb	w0, [x28, x23]
  405518:	38001660 	strb	w0, [x19], #1
			size = 0;
  40551c:	52800000 	mov	w0, #0x0                   	// #0
		if (BUF_OFFSET + 1 + size > len) {
  405520:	2a0003f9 	mov	w25, w0
  405524:	8b204260 	add	x0, x19, w0, uxtw
  405528:	8b160000 	add	x0, x0, x22
  40552c:	b90063e3 	str	w3, [sp, #96]
  405530:	b9006be5 	str	w5, [sp, #104]
  405534:	eb15001f 	cmp	x0, x21
  405538:	54ffdf28 	b.hi	40511c <cbvprintf_package+0x2b8>  // b.pmore
		*buf++ = str_ptr_pos[i];
  40553c:	39400300 	ldrb	w0, [x24]
  405540:	aa1903e2 	mov	x2, x25
  405544:	38001660 	strb	w0, [x19], #1
  405548:	aa1a03e1 	mov	x1, x26
  40554c:	aa1303e0 	mov	x0, x19
  405550:	97ffef78 	bl	401330 <memcpy@plt>
		buf += size;
  405554:	b94063e3 	ldr	w3, [sp, #96]
  405558:	8b190273 	add	x19, x19, x25
  40555c:	b9406be5 	ldr	w5, [sp, #104]
	for (i = 0; i < s_idx; i++) {
  405560:	9100079c 	add	x28, x28, #0x1
  405564:	91000718 	add	x24, x24, #0x1
  405568:	6b1c007f 	cmp	w3, w28
  40556c:	54fffca8 	b.hi	405500 <cbvprintf_package+0x69c>  // b.pmore
	return BUF_OFFSET;
  405570:	4b140260 	sub	w0, w19, w20
  405574:	17fffeeb 	b	405120 <cbvprintf_package+0x2bc>
			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
  405578:	39400300 	ldrb	w0, [x24]
  40557c:	b90063e3 	str	w3, [sp, #96]
  405580:	b9006be5 	str	w5, [sp, #104]
  405584:	d37ef400 	lsl	x0, x0, #2
  405588:	f8606a9a 	ldr	x26, [x20, x0]
			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
  40558c:	f8206a9f 	str	xzr, [x20, x0]
			size = strlen(s) + 1;
  405590:	aa1a03e0 	mov	x0, x26
  405594:	97ffef77 	bl	401370 <strlen@plt>
  405598:	b94063e3 	ldr	w3, [sp, #96]
  40559c:	11000400 	add	w0, w0, #0x1
  4055a0:	b9406be5 	ldr	w5, [sp, #104]
  4055a4:	17ffffdf 	b	405520 <cbvprintf_package+0x6bc>
		return -EFAULT;
  4055a8:	128001a0 	mov	w0, #0xfffffff2            	// #-14
  4055ac:	17fffedd 	b	405120 <cbvprintf_package+0x2bc>
	if (buf0 != NULL && BUF_OFFSET + sizeof(char *) > len) {
  4055b0:	f1003ebf 	cmp	x21, #0xf
  4055b4:	54ffc948 	b.hi	404edc <cbvprintf_package+0x78>  // b.pmore
  4055b8:	17fffed9 	b	40511c <cbvprintf_package+0x2b8>
}
  4055bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4055c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4055c4:	a94363f7 	ldp	x23, x24, [sp, #48]
  4055c8:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4055cc:	a94573fb 	ldp	x27, x28, [sp, #80]
  4055d0:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  4055d4:	d65f03c0 	ret

00000000004055d8 <cbpprintf_external>:
	uint8_t *buf = packaged;
	struct cbprintf_package_hdr_ext *hdr = packaged;
	char *s, **ps;
	unsigned int i, args_size, s_nbr, ros_nbr, rws_nbr, s_idx;

	if (buf == NULL) {
  4055d8:	b40005e3 	cbz	x3, 405694 <cbpprintf_external+0xbc>
{
  4055dc:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  4055e0:	910003fd 	mov	x29, sp
  4055e4:	a90153f3 	stp	x19, x20, [sp, #16]
  4055e8:	aa0303f4 	mov	x20, x3
  4055ec:	a9025bf5 	stp	x21, x22, [sp, #32]
  4055f0:	aa0003f6 	mov	x22, x0
  4055f4:	aa0103f5 	mov	x21, x1
  4055f8:	a90363f7 	stp	x23, x24, [sp, #48]
  4055fc:	aa0203f7 	mov	x23, x2
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);

	/*
	 * Patch in string pointers.
	 */
	for (i = 0; i < s_nbr; i++) {
  405600:	52800018 	mov	w24, #0x0                   	// #0
{
  405604:	f90023f9 	str	x25, [sp, #64]
	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
  405608:	39400c60 	ldrb	w0, [x3, #3]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  40560c:	39400073 	ldrb	w19, [x3]
	s_nbr     = hdr->hdr.desc.str_cnt;
  405610:	39400479 	ldrb	w25, [x3, #1]
	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
  405614:	d37f1c00 	ubfiz	x0, x0, #1, #8
  405618:	8b334813 	add	x19, x0, w19, uxtw #2
  40561c:	39400860 	ldrb	w0, [x3, #2]
  405620:	8b000273 	add	x19, x19, x0
  405624:	8b130073 	add	x19, x3, x19
	for (i = 0; i < s_nbr; i++) {
  405628:	6b19031f 	cmp	w24, w25
  40562c:	54000223 	b.cc	405670 <cbpprintf_external+0x98>  // b.lo, b.ul, b.last
		/* move to next string */
		s += strlen(s) + 1;
	}

	/* Skip past the header */
	buf += sizeof(*hdr);
  405630:	91004280 	add	x0, x20, #0x10
	u.__ap.__gr_top = NULL;
  405634:	a9077fe0 	stp	x0, xzr, [sp, #112]
	return formatter(out, ctx, fmt, u.ap);
  405638:	910143e3 	add	x3, sp, #0x50
	u.__ap.__gr_offs = 0;
  40563c:	a9087fff 	stp	xzr, xzr, [sp, #128]
	return formatter(out, ctx, fmt, u.ap);
  405640:	aa1703e1 	mov	x1, x23
  405644:	aa1603e0 	mov	x0, x22
  405648:	ad4387e0 	ldp	q0, q1, [sp, #112]
  40564c:	ad000460 	stp	q0, q1, [x3]
  405650:	f9400682 	ldr	x2, [x20, #8]
  405654:	d63f02a0 	blr	x21

	/* Turn this into a va_list and  print it */
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
}
  405658:	a94153f3 	ldp	x19, x20, [sp, #16]
  40565c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  405660:	a94363f7 	ldp	x23, x24, [sp, #48]
  405664:	f94023f9 	ldr	x25, [sp, #64]
  405668:	a8c97bfd 	ldp	x29, x30, [sp], #144
  40566c:	d65f03c0 	ret
		ps = (char **)(buf + s_idx * sizeof(int));
  405670:	38401660 	ldrb	w0, [x19], #1
	for (i = 0; i < s_nbr; i++) {
  405674:	11000718 	add	w24, w24, #0x1
		ps = (char **)(buf + s_idx * sizeof(int));
  405678:	d37ef400 	lsl	x0, x0, #2
		*ps = s;
  40567c:	f8206a93 	str	x19, [x20, x0]
		s += strlen(s) + 1;
  405680:	aa1303e0 	mov	x0, x19
  405684:	97ffef3b 	bl	401370 <strlen@plt>
  405688:	91000400 	add	x0, x0, #0x1
  40568c:	8b000273 	add	x19, x19, x0
	for (i = 0; i < s_nbr; i++) {
  405690:	17ffffe6 	b	405628 <cbpprintf_external+0x50>
		return -EINVAL;
  405694:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  405698:	d65f03c0 	ret

000000000040569c <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  40569c:	52800000 	mov	w0, #0x0                   	// #0
  4056a0:	d65f03c0 	ret

00000000004056a4 <__printk_hook_install>:
 * routine that outputs one ASCII character at a time.
 * @param fn putc routine to install
 */
void __printk_hook_install(int (*fn)(int c))
{
	_char_out = fn;
  4056a4:	90000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4056a8:	f947c821 	ldr	x1, [x1, #3984]
  4056ac:	f9000020 	str	x0, [x1]
}
  4056b0:	d65f03c0 	ret

00000000004056b4 <vprintk>:
	(void) ctx_p;
	return _char_out(c);
}

void vprintk(const char *fmt, va_list ap)
{
  4056b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4056b8:	910003fd 	mov	x29, sp
	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		z_log_vprintk(fmt, ap);
  4056bc:	ad400420 	ldp	q0, q1, [x1]
  4056c0:	910043e2 	add	x2, sp, #0x10
  4056c4:	aa0203e1 	mov	x1, x2
  4056c8:	ad000440 	stp	q0, q1, [x2]
  4056cc:	9400069e 	bl	407144 <z_log_vprintk>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
  4056d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4056d4:	d65f03c0 	ret

00000000004056d8 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
  4056d8:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  4056dc:	910003fd 	mov	x29, sp
  4056e0:	a90e8be1 	stp	x1, x2, [sp, #232]
  4056e4:	90000161 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4056e8:	f9475c21 	ldr	x1, [x1, #3768]
  4056ec:	3d801be0 	str	q0, [sp, #96]
  4056f0:	3d801fe1 	str	q1, [sp, #112]
  4056f4:	3d8023e2 	str	q2, [sp, #128]
  4056f8:	3d8027e3 	str	q3, [sp, #144]
  4056fc:	3d802be4 	str	q4, [sp, #160]
  405700:	3d802fe5 	str	q5, [sp, #176]
  405704:	3d8033e6 	str	q6, [sp, #192]
  405708:	3d8037e7 	str	q7, [sp, #208]
  40570c:	a90f93e3 	stp	x3, x4, [sp, #248]
  405710:	a9109be5 	stp	x5, x6, [sp, #264]
  405714:	f9008fe7 	str	x7, [sp, #280]
  405718:	f9400022 	ldr	x2, [x1]
  40571c:	f9002fe2 	str	x2, [sp, #88]
  405720:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  405724:	910483e1 	add	x1, sp, #0x120
  405728:	a90387e1 	stp	x1, x1, [sp, #56]
  40572c:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  405730:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  405734:	f90027e1 	str	x1, [sp, #72]
  405738:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  40573c:	b90053e1 	str	w1, [sp, #80]
  405740:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  405744:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  405748:	910043e1 	add	x1, sp, #0x10
  40574c:	ad400440 	ldp	q0, q1, [x2]
  405750:	ad000420 	stp	q0, q1, [x1]
  405754:	97ffffd8 	bl	4056b4 <vprintk>

	va_end(ap);
}
  405758:	90000160 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40575c:	f9475c00 	ldr	x0, [x0, #3768]
  405760:	f9402fe2 	ldr	x2, [sp, #88]
  405764:	f9400001 	ldr	x1, [x0]
  405768:	eb010042 	subs	x2, x2, x1
  40576c:	d2800001 	mov	x1, #0x0                   	// #0
  405770:	54000040 	b.eq	405778 <printk+0xa0>  // b.none
  405774:	97ffef6b 	bl	401520 <__stack_chk_fail@plt>
  405778:	a8d27bfd 	ldp	x29, x30, [sp], #288
  40577c:	d65f03c0 	ret

0000000000405780 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
  405780:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  405784:	aa0003e4 	mov	x4, x0
  405788:	aa0103e0 	mov	x0, x1
  40578c:	910003fd 	mov	x29, sp
  405790:	aa0203e1 	mov	x1, x2
  405794:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
  405798:	d63f0080 	blr	x4
	return z_impl_z_current_get();
  40579c:	94004346 	bl	4164b4 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
  4057a0:	94000b55 	bl	4084f4 <z_impl_k_thread_abort>
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  4057a4:	f0000081 	adrp	x1, 418000 <table.0+0x1d8>
  4057a8:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4057ac:	911a6821 	add	x1, x1, #0x69a
  4057b0:	91187800 	add	x0, x0, #0x61e
  4057b4:	528005a2 	mov	w2, #0x2d                  	// #45
  4057b8:	94000fb8 	bl	409698 <posix_print_error_and_exit>

00000000004057bc <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
  4057bc:	d2800082 	mov	x2, #0x4                   	// #4
  4057c0:	8b214c41 	add	x1, x2, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
  4057c4:	b8616800 	ldr	w0, [x0, x1]
}
  4057c8:	53017c00 	lsr	w0, w0, #1
  4057cc:	d65f03c0 	ret

00000000004057d0 <free_list_remove_bidx>:
		return ((uint32_t *)cmem)[f];
  4057d0:	8b214c04 	add	x4, x0, w1, uxtw #3
  4057d4:	b9400c83 	ldr	w3, [x4, #12]

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & BIT(bidx));

	if (next_free_chunk(h, c) == c) {
  4057d8:	6b03003f 	cmp	w1, w3
  4057dc:	93407c41 	sxtw	x1, w2
  4057e0:	54000121 	b.ne	405804 <free_list_remove_bidx+0x34>  // b.any
		/* this is the last chunk */
		h->avail_buckets &= ~BIT(bidx);
  4057e4:	d2800023 	mov	x3, #0x1                   	// #1
		b->next = 0;
  4057e8:	91001021 	add	x1, x1, #0x4
		h->avail_buckets &= ~BIT(bidx);
  4057ec:	9ac22062 	lsl	x2, x3, x2
  4057f0:	b9400c03 	ldr	w3, [x0, #12]
  4057f4:	0a220062 	bic	w2, w3, w2
  4057f8:	b9000c02 	str	w2, [x0, #12]
		b->next = 0;
  4057fc:	b821781f 	str	wzr, [x0, x1, lsl #2]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes -= chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
  405800:	d65f03c0 	ret
		b->next = second;
  405804:	91001021 	add	x1, x1, #0x4
  405808:	b9400882 	ldr	w2, [x4, #8]
  40580c:	b8217803 	str	w3, [x0, x1, lsl #2]
		((uint32_t *)cmem)[f] = val;
  405810:	d2800181 	mov	x1, #0xc                   	// #12
  405814:	8b224c21 	add	x1, x1, w2, uxtw #3
  405818:	b8216803 	str	w3, [x0, x1]
  40581c:	d37d7c63 	ubfiz	x3, x3, #3, #32
  405820:	91002063 	add	x3, x3, #0x8
  405824:	b8236802 	str	w2, [x0, x3]
}
  405828:	17fffff6 	b	405800 <free_list_remove_bidx+0x30>

000000000040582c <alloc_chunk>:
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  40582c:	51000424 	sub	w4, w1, #0x1
	return 31 - __builtin_clz(usable_sz);
  405830:	528003e6 	mov	w6, #0x1f                  	// #31
  405834:	5ac01084 	clz	w4, w4

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
  405838:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40583c:	4b0400c6 	sub	w6, w6, w4
  405840:	910003fd 	mov	x29, sp
  405844:	8b26c808 	add	x8, x0, w6, sxtw #2
  405848:	aa0003e3 	mov	x3, x0
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
  40584c:	b940110a 	ldr	w10, [x8, #16]
  405850:	3400030a 	cbz	w10, 4058b0 <alloc_chunk+0x84>
  405854:	2a0103e7 	mov	w7, w1
  405858:	52800069 	mov	w9, #0x3                   	// #3
		return ((uint32_t *)cmem)[f];
  40585c:	d280018b 	mov	x11, #0xc                   	// #12
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
  405860:	b9401105 	ldr	w5, [x8, #16]
			if (chunk_size(h, c) >= sz) {
  405864:	aa0303e0 	mov	x0, x3
  405868:	2a0503e1 	mov	w1, w5
  40586c:	97ffffd4 	bl	4057bc <chunk_size>
  405870:	6b07001f 	cmp	w0, w7
  405874:	54000103 	b.cc	405894 <alloc_chunk+0x68>  // b.lo, b.ul, b.last
				free_list_remove_bidx(h, c, bi);
  405878:	2a0603e2 	mov	w2, w6

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
  40587c:	2a0503e1 	mov	w1, w5
  405880:	aa0303e0 	mov	x0, x3
  405884:	97ffffd3 	bl	4057d0 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
  405888:	2a0503e0 	mov	w0, w5
  40588c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  405890:	d65f03c0 	ret
  405894:	8b254d65 	add	x5, x11, w5, uxtw #3
		} while (--i && b->next != first);
  405898:	71000529 	subs	w9, w9, #0x1
  40589c:	b8656860 	ldr	w0, [x3, x5]
			b->next = next_free_chunk(h, c);
  4058a0:	b9001100 	str	w0, [x8, #16]
		} while (--i && b->next != first);
  4058a4:	54000060 	b.eq	4058b0 <alloc_chunk+0x84>  // b.none
  4058a8:	6b00015f 	cmp	w10, w0
  4058ac:	54fffda1 	b.ne	405860 <alloc_chunk+0x34>  // b.any
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
  4058b0:	52800400 	mov	w0, #0x20                  	// #32
  4058b4:	4b040000 	sub	w0, w0, w4
  4058b8:	d2800025 	mov	x5, #0x1                   	// #1
  4058bc:	9ac020a5 	lsl	x5, x5, x0
  4058c0:	b9400c60 	ldr	w0, [x3, #12]
  4058c4:	4b0503e5 	neg	w5, w5
	if (bmask != 0U) {
  4058c8:	6a0000a5 	ands	w5, w5, w0
  4058cc:	54fffde0 	b.eq	405888 <alloc_chunk+0x5c>  // b.none
		int minbucket = __builtin_ctz(bmask);
  4058d0:	5ac000a2 	rbit	w2, w5
  4058d4:	5ac01042 	clz	w2, w2
		chunkid_t c = h->buckets[minbucket].next;
  4058d8:	8b22c860 	add	x0, x3, w2, sxtw #2
  4058dc:	b9401005 	ldr	w5, [x0, #16]
  4058e0:	17ffffe7 	b	40587c <alloc_chunk+0x50>

00000000004058e4 <free_list_remove>:
{
  4058e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4058e8:	aa0003e3 	mov	x3, x0
  4058ec:	2a0103e4 	mov	w4, w1
  4058f0:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  4058f4:	97ffffb2 	bl	4057bc <chunk_size>
	if (!solo_free_header(h, c)) {
  4058f8:	7100041f 	cmp	w0, #0x1
  4058fc:	54000120 	b.eq	405920 <free_list_remove+0x3c>  // b.none
}
  405900:	a8c17bfd 	ldp	x29, x30, [sp], #16
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  405904:	51000402 	sub	w2, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  405908:	5ac01042 	clz	w2, w2
		free_list_remove_bidx(h, c, bidx);
  40590c:	528003e0 	mov	w0, #0x1f                  	// #31
  405910:	2a0403e1 	mov	w1, w4
  405914:	4b020002 	sub	w2, w0, w2
  405918:	aa0303e0 	mov	x0, x3
  40591c:	17ffffad 	b	4057d0 <free_list_remove_bidx>
}
  405920:	a8c17bfd 	ldp	x29, x30, [sp], #16
  405924:	d65f03c0 	ret

0000000000405928 <free_list_add>:
{
  405928:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40592c:	aa0003e3 	mov	x3, x0
  405930:	2a0103e4 	mov	w4, w1
  405934:	910003fd 	mov	x29, sp
	return big_heap(h) && chunk_size(h, c) == 1U;
  405938:	97ffffa1 	bl	4057bc <chunk_size>
	if (!solo_free_header(h, c)) {
  40593c:	7100041f 	cmp	w0, #0x1
  405940:	54000260 	b.eq	40598c <free_list_add+0x64>  // b.none
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  405944:	51000400 	sub	w0, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
  405948:	528003e1 	mov	w1, #0x1f                  	// #31
  40594c:	5ac01000 	clz	w0, w0
  405950:	4b000021 	sub	w1, w1, w0
	if (b->next == 0U) {
  405954:	d37d7c80 	ubfiz	x0, x4, #3, #32
  405958:	91002006 	add	x6, x0, #0x8
		((uint32_t *)cmem)[f] = val;
  40595c:	91003000 	add	x0, x0, #0xc
  405960:	8b21c867 	add	x7, x3, w1, sxtw #2
  405964:	b94010e5 	ldr	w5, [x7, #16]
  405968:	35000165 	cbnz	w5, 405994 <free_list_add+0x6c>
		h->avail_buckets |= BIT(bidx);
  40596c:	d2800022 	mov	x2, #0x1                   	// #1
  405970:	9ac12042 	lsl	x2, x2, x1
  405974:	b9400c61 	ldr	w1, [x3, #12]
  405978:	2a020021 	orr	w1, w1, w2
  40597c:	b9000c61 	str	w1, [x3, #12]
		b->next = c;
  405980:	b90010e4 	str	w4, [x7, #16]
  405984:	b8266864 	str	w4, [x3, x6]
  405988:	b8206864 	str	w4, [x3, x0]
}
  40598c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  405990:	d65f03c0 	ret
		return ((uint32_t *)cmem)[f];
  405994:	d37d7ca1 	ubfiz	x1, x5, #3, #32
  405998:	91002021 	add	x1, x1, #0x8
  40599c:	b8616862 	ldr	w2, [x3, x1]
		((uint32_t *)cmem)[f] = val;
  4059a0:	b8266862 	str	w2, [x3, x6]
  4059a4:	b8206865 	str	w5, [x3, x0]
  4059a8:	d2800180 	mov	x0, #0xc                   	// #12
  4059ac:	8b224c02 	add	x2, x0, w2, uxtw #3
  4059b0:	b8226864 	str	w4, [x3, x2]
  4059b4:	b8216864 	str	w4, [x3, x1]
  4059b8:	17fffff5 	b	40598c <free_list_add+0x64>

00000000004059bc <merge_chunks>:
{
  4059bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4059c0:	2a0203e3 	mov	w3, w2
  4059c4:	aa0003e4 	mov	x4, x0
  4059c8:	910003fd 	mov	x29, sp
  4059cc:	2a0103e6 	mov	w6, w1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
  4059d0:	97ffff7b 	bl	4057bc <chunk_size>
  4059d4:	2a0303e1 	mov	w1, w3
  4059d8:	2a0003e5 	mov	w5, w0
  4059dc:	aa0403e0 	mov	x0, x4
  4059e0:	97ffff77 	bl	4057bc <chunk_size>
  4059e4:	0b0000a5 	add	w5, w5, w0
  4059e8:	d2800080 	mov	x0, #0x4                   	// #4
  4059ec:	8b264c06 	add	x6, x0, w6, uxtw #3
	return c + chunk_size(h, c);
  4059f0:	2a0303e1 	mov	w1, w3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  4059f4:	531f78a0 	lsl	w0, w5, #1
		((uint32_t *)cmem)[f] = val;
  4059f8:	b8266880 	str	w0, [x4, x6]
	return c + chunk_size(h, c);
  4059fc:	aa0403e0 	mov	x0, x4
  405a00:	97ffff6f 	bl	4057bc <chunk_size>
	void *cmem = &buf[c];
  405a04:	0b000063 	add	w3, w3, w0
  405a08:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  405a0c:	b8236885 	str	w5, [x4, x3]
}
  405a10:	a8c17bfd 	ldp	x29, x30, [sp], #16
  405a14:	d65f03c0 	ret

0000000000405a18 <free_chunk>:
{
  405a18:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  405a1c:	2a0103e8 	mov	w8, w1
  405a20:	aa0003e7 	mov	x7, x0
  405a24:	910003fd 	mov	x29, sp
	return c + chunk_size(h, c);
  405a28:	97ffff65 	bl	4057bc <chunk_size>
  405a2c:	0b000101 	add	w1, w8, w0
		return ((uint32_t *)cmem)[f];
  405a30:	d2800080 	mov	x0, #0x4                   	// #4
  405a34:	8b214c00 	add	x0, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  405a38:	b86068e0 	ldr	w0, [x7, x0]
	if (!chunk_used(h, right_chunk(h, c))) {
  405a3c:	37000140 	tbnz	w0, #0, 405a64 <free_chunk+0x4c>
		free_list_remove(h, right_chunk(h, c));
  405a40:	aa0703e0 	mov	x0, x7
  405a44:	97ffffa8 	bl	4058e4 <free_list_remove>
	return c + chunk_size(h, c);
  405a48:	2a0803e1 	mov	w1, w8
  405a4c:	aa0703e0 	mov	x0, x7
  405a50:	97ffff5b 	bl	4057bc <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
  405a54:	0b000102 	add	w2, w8, w0
  405a58:	2a0803e1 	mov	w1, w8
  405a5c:	aa0703e0 	mov	x0, x7
  405a60:	97ffffd7 	bl	4059bc <merge_chunks>
	void *cmem = &buf[c];
  405a64:	d37d7d09 	ubfiz	x9, x8, #3, #32
		return ((uint32_t *)cmem)[f];
  405a68:	d2800080 	mov	x0, #0x4                   	// #4
	return c - chunk_field(h, c, LEFT_SIZE);
  405a6c:	b86968e1 	ldr	w1, [x7, x9]
  405a70:	4b010101 	sub	w1, w8, w1
		return ((uint32_t *)cmem)[f];
  405a74:	8b214c00 	add	x0, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  405a78:	b86068e0 	ldr	w0, [x7, x0]
	if (!chunk_used(h, left_chunk(h, c))) {
  405a7c:	37000140 	tbnz	w0, #0, 405aa4 <free_chunk+0x8c>
		free_list_remove(h, left_chunk(h, c));
  405a80:	aa0703e0 	mov	x0, x7
  405a84:	97ffff98 	bl	4058e4 <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
  405a88:	b86968e1 	ldr	w1, [x7, x9]
		merge_chunks(h, left_chunk(h, c), c);
  405a8c:	2a0803e2 	mov	w2, w8
  405a90:	aa0703e0 	mov	x0, x7
  405a94:	4b010101 	sub	w1, w8, w1
  405a98:	97ffffc9 	bl	4059bc <merge_chunks>
  405a9c:	b86968e0 	ldr	w0, [x7, x9]
  405aa0:	4b000108 	sub	w8, w8, w0
}
  405aa4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free_list_add(h, c);
  405aa8:	2a0803e1 	mov	w1, w8
  405aac:	aa0703e0 	mov	x0, x7
  405ab0:	17ffff9e 	b	405928 <free_list_add>

0000000000405ab4 <split_chunks>:
{
  405ab4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  405ab8:	2a0203e3 	mov	w3, w2
  405abc:	2a0103e5 	mov	w5, w1
  405ac0:	aa0003e4 	mov	x4, x0
  405ac4:	910003fd 	mov	x29, sp
	chunksz_t rsz = sz0 - lsz;
  405ac8:	4b0300a6 	sub	w6, w5, w3
	chunksz_t sz0 = chunk_size(h, lc);
  405acc:	97ffff3c 	bl	4057bc <chunk_size>
	chunksz_t rsz = sz0 - lsz;
  405ad0:	0b0000c6 	add	w6, w6, w0
		((uint32_t *)cmem)[f] = val;
  405ad4:	d2800080 	mov	x0, #0x4                   	// #4
	chunksz_t lsz = rc - lc;
  405ad8:	4b050061 	sub	w1, w3, w5
  405adc:	8b254c05 	add	x5, x0, w5, uxtw #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  405ae0:	531f7820 	lsl	w0, w1, #1
		((uint32_t *)cmem)[f] = val;
  405ae4:	b8256880 	str	w0, [x4, x5]
	void *cmem = &buf[c];
  405ae8:	d37d7c60 	ubfiz	x0, x3, #3, #32
		((uint32_t *)cmem)[f] = val;
  405aec:	8b000082 	add	x2, x4, x0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  405af0:	531f78c5 	lsl	w5, w6, #1
		((uint32_t *)cmem)[f] = val;
  405af4:	b9000445 	str	w5, [x2, #4]
  405af8:	b8206881 	str	w1, [x4, x0]
	return c + chunk_size(h, c);
  405afc:	2a0303e1 	mov	w1, w3
  405b00:	aa0403e0 	mov	x0, x4
  405b04:	97ffff2e 	bl	4057bc <chunk_size>
	void *cmem = &buf[c];
  405b08:	0b000063 	add	w3, w3, w0
  405b0c:	d37df063 	lsl	x3, x3, #3
		((uint32_t *)cmem)[f] = val;
  405b10:	b8236886 	str	w6, [x4, x3]
}
  405b14:	a8c17bfd 	ldp	x29, x30, [sp], #16
  405b18:	d65f03c0 	ret

0000000000405b1c <sys_heap_free>:
	if (mem == NULL) {
  405b1c:	b4000901 	cbz	x1, 405c3c <sys_heap_free+0x120>
{
  405b20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  405b24:	d1002023 	sub	x3, x1, #0x8
{
  405b28:	910003fd 	mov	x29, sp
  405b2c:	a90153f3 	stp	x19, x20, [sp, #16]
  405b30:	aa0103f3 	mov	x19, x1
	struct z_heap *h = heap->heap;
  405b34:	f9400004 	ldr	x4, [x0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  405b38:	d2800100 	mov	x0, #0x8                   	// #8
  405b3c:	cb040063 	sub	x3, x3, x4
  405b40:	9ac00c63 	sdiv	x3, x3, x0
		return ((uint32_t *)cmem)[f];
  405b44:	8b234c86 	add	x6, x4, w3, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
  405b48:	b94004c5 	ldr	w5, [x6, #4]
	__ASSERT(chunk_used(h, c),
  405b4c:	370002c5 	tbnz	w5, #0, 405ba4 <sys_heap_free+0x88>
  405b50:	f0000094 	adrp	x20, 418000 <table.0+0x1d8>
  405b54:	911b0e94 	add	x20, x20, #0x6c3
  405b58:	aa1403e2 	mov	x2, x20
  405b5c:	528015e3 	mov	w3, #0xaf                  	// #175
  405b60:	f0000081 	adrp	x1, 418000 <table.0+0x1d8>
  405b64:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405b68:	911b9021 	add	x1, x1, #0x6e4
  405b6c:	91178000 	add	x0, x0, #0x5e0
  405b70:	940004ae 	bl	406e28 <assert_print>
  405b74:	aa1303e1 	mov	x1, x19
  405b78:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405b7c:	911bd400 	add	x0, x0, #0x6f5
  405b80:	940004aa 	bl	406e28 <assert_print>
  405b84:	aa1403e0 	mov	x0, x20
  405b88:	528015e1 	mov	w1, #0xaf                  	// #175
  405b8c:	940004d1 	bl	406ed0 <assert_post_action>
  405b90:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405b94:	aa1403e1 	mov	x1, x20
  405b98:	91187800 	add	x0, x0, #0x61e
  405b9c:	528015e2 	mov	w2, #0xaf                  	// #175
  405ba0:	94000ebe 	bl	409698 <posix_print_error_and_exit>
	return c + chunk_size(h, c);
  405ba4:	2a0303e1 	mov	w1, w3
  405ba8:	aa0403e0 	mov	x0, x4
  405bac:	97ffff04 	bl	4057bc <chunk_size>
  405bb0:	0b030001 	add	w1, w0, w3
	void *cmem = &buf[c];
  405bb4:	0b030000 	add	w0, w0, w3
  405bb8:	d37df000 	lsl	x0, x0, #3
	return c - chunk_field(h, c, LEFT_SIZE);
  405bbc:	b8606880 	ldr	w0, [x4, x0]
  405bc0:	4b000021 	sub	w1, w1, w0
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
  405bc4:	6b01007f 	cmp	w3, w1
  405bc8:	540002c0 	b.eq	405c20 <sys_heap_free+0x104>  // b.none
  405bcc:	f0000094 	adrp	x20, 418000 <table.0+0x1d8>
  405bd0:	911b0e94 	add	x20, x20, #0x6c3
  405bd4:	aa1403e2 	mov	x2, x20
  405bd8:	528016e3 	mov	w3, #0xb7                  	// #183
  405bdc:	f0000081 	adrp	x1, 418000 <table.0+0x1d8>
  405be0:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405be4:	911cb421 	add	x1, x1, #0x72d
  405be8:	91178000 	add	x0, x0, #0x5e0
  405bec:	9400048f 	bl	406e28 <assert_print>
  405bf0:	aa1303e1 	mov	x1, x19
  405bf4:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405bf8:	911d4c00 	add	x0, x0, #0x753
  405bfc:	9400048b 	bl	406e28 <assert_print>
  405c00:	aa1403e0 	mov	x0, x20
  405c04:	528016e1 	mov	w1, #0xb7                  	// #183
  405c08:	940004b2 	bl	406ed0 <assert_post_action>
  405c0c:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405c10:	aa1403e1 	mov	x1, x20
  405c14:	91187800 	add	x0, x0, #0x61e
  405c18:	528016e2 	mov	w2, #0xb7                  	// #183
  405c1c:	94000e9f 	bl	409698 <posix_print_error_and_exit>
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
  405c20:	121f78a5 	and	w5, w5, #0xfffffffe
  405c24:	b90004c5 	str	w5, [x6, #4]
	free_chunk(h, c);
  405c28:	2a0303e1 	mov	w1, w3
  405c2c:	aa0403e0 	mov	x0, x4
}
  405c30:	a94153f3 	ldp	x19, x20, [sp, #16]
  405c34:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free_chunk(h, c);
  405c38:	17ffff78 	b	405a18 <free_chunk>
  405c3c:	d65f03c0 	ret

0000000000405c40 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
	struct z_heap *h = heap->heap;
  405c40:	f940000d 	ldr	x13, [x0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
  405c44:	b50000c1 	cbnz	x1, 405c5c <sys_heap_alloc+0x1c>
		return NULL;
  405c48:	d2800000 	mov	x0, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  405c4c:	d65f03c0 	ret
		return NULL;
  405c50:	d2800000 	mov	x0, #0x0                   	// #0
}
  405c54:	a8c17bfd 	ldp	x29, x30, [sp], #16
  405c58:	d65f03c0 	ret
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  405c5c:	b94009a0 	ldr	w0, [x13, #8]
	if (bytes == 0U || size_too_big(h, bytes)) {
  405c60:	eb410c1f 	cmp	x0, x1, lsr #3
  405c64:	54ffff29 	b.ls	405c48 <sys_heap_alloc+0x8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  405c68:	91003c21 	add	x1, x1, #0xf
{
  405c6c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	chunkid_t c = alloc_chunk(h, chunk_sz);
  405c70:	aa0d03e0 	mov	x0, x13
  405c74:	d343fc2c 	lsr	x12, x1, #3
{
  405c78:	910003fd 	mov	x29, sp
	chunkid_t c = alloc_chunk(h, chunk_sz);
  405c7c:	2a0c03e1 	mov	w1, w12
  405c80:	97fffeeb 	bl	40582c <alloc_chunk>
  405c84:	2a0003e8 	mov	w8, w0
	if (c == 0U) {
  405c88:	34fffe40 	cbz	w0, 405c50 <sys_heap_alloc+0x10>
	if (chunk_size(h, c) > chunk_sz) {
  405c8c:	2a0003e1 	mov	w1, w0
  405c90:	aa0d03e0 	mov	x0, x13
  405c94:	97fffeca 	bl	4057bc <chunk_size>
  405c98:	6b0c001f 	cmp	w0, w12
  405c9c:	54000129 	b.ls	405cc0 <sys_heap_alloc+0x80>  // b.plast
		split_chunks(h, c, c + chunk_sz);
  405ca0:	0b0c010c 	add	w12, w8, w12
  405ca4:	2a0803e1 	mov	w1, w8
  405ca8:	2a0c03e2 	mov	w2, w12
  405cac:	aa0d03e0 	mov	x0, x13
  405cb0:	97ffff81 	bl	405ab4 <split_chunks>
		free_list_add(h, c + chunk_sz);
  405cb4:	2a0c03e1 	mov	w1, w12
  405cb8:	aa0d03e0 	mov	x0, x13
  405cbc:	97ffff1b 	bl	405928 <free_list_add>
	void *cmem = &buf[c];
  405cc0:	d37d7d08 	ubfiz	x8, x8, #3, #32
  405cc4:	8b0801a1 	add	x1, x13, x8
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  405cc8:	91002108 	add	x8, x8, #0x8
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  405ccc:	b9400420 	ldr	w0, [x1, #4]
  405cd0:	32000000 	orr	w0, w0, #0x1
  405cd4:	b9000420 	str	w0, [x1, #4]
  405cd8:	8b0801a0 	add	x0, x13, x8
	return mem;
  405cdc:	17ffffde 	b	405c54 <sys_heap_alloc+0x14>

0000000000405ce0 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
  405ce0:	aa0203ec 	mov	x12, x2
  405ce4:	91003c43 	add	x3, x2, #0xf
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
  405ce8:	cb0103e2 	neg	x2, x1
  405cec:	8a01004e 	and	x14, x2, x1
	struct z_heap *h = heap->heap;
  405cf0:	f940000d 	ldr	x13, [x0]
	if (align != rew) {
  405cf4:	ea22003f 	bics	xzr, x1, x2
  405cf8:	54000400 	b.eq	405d78 <sys_heap_aligned_alloc+0x98>  // b.none
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
  405cfc:	f10021df 	cmp	x14, #0x8
  405d00:	aa0e03ef 	mov	x15, x14
  405d04:	d2800100 	mov	x0, #0x8                   	// #8
  405d08:	9a8091c0 	csel	x0, x14, x0, ls  // ls = plast
		align -= rew;
  405d0c:	cb0e002e 	sub	x14, x1, x14
{
  405d10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
			return sys_heap_alloc(heap, bytes);
		}
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  405d14:	d10005d2 	sub	x18, x14, #0x1
{
  405d18:	910003fd 	mov	x29, sp
  405d1c:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");
  405d20:	ea0e025f 	tst	x18, x14
  405d24:	54000380 	b.eq	405d94 <sys_heap_aligned_alloc+0xb4>  // b.none
  405d28:	f0000093 	adrp	x19, 418000 <table.0+0x1d8>
  405d2c:	911b0e73 	add	x19, x19, #0x6c3
  405d30:	aa1303e2 	mov	x2, x19
  405d34:	f0000081 	adrp	x1, 418000 <table.0+0x1d8>
  405d38:	911e3c21 	add	x1, x1, #0x78f
  405d3c:	52802883 	mov	w3, #0x144                 	// #324
  405d40:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405d44:	91178000 	add	x0, x0, #0x5e0
  405d48:	94000438 	bl	406e28 <assert_print>
  405d4c:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405d50:	911ea800 	add	x0, x0, #0x7aa
  405d54:	94000435 	bl	406e28 <assert_print>
  405d58:	aa1303e0 	mov	x0, x19
  405d5c:	52802881 	mov	w1, #0x144                 	// #324
  405d60:	9400045c 	bl	406ed0 <assert_post_action>
  405d64:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405d68:	aa1303e1 	mov	x1, x19
  405d6c:	91187800 	add	x0, x0, #0x61e
  405d70:	52802882 	mov	w2, #0x144                 	// #324
  405d74:	94000e49 	bl	409698 <posix_print_error_and_exit>
		if (align <= chunk_header_bytes(h)) {
  405d78:	f100203f 	cmp	x1, #0x8
  405d7c:	54000068 	b.hi	405d88 <sys_heap_aligned_alloc+0xa8>  // b.pmore
			return sys_heap_alloc(heap, bytes);
  405d80:	aa0c03e1 	mov	x1, x12
  405d84:	17ffffaf 	b	405c40 <sys_heap_alloc>
		rew = 0;
  405d88:	d280000f 	mov	x15, #0x0                   	// #0
		gap = chunk_header_bytes(h);
  405d8c:	d2800100 	mov	x0, #0x8                   	// #8
  405d90:	17ffffe0 	b	405d10 <sys_heap_aligned_alloc+0x30>

	if (bytes == 0 || size_too_big(h, bytes)) {
  405d94:	b50000cc 	cbnz	x12, 405dac <sys_heap_aligned_alloc+0xcc>
		return NULL;
  405d98:	d2800009 	mov	x9, #0x0                   	// #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
  405d9c:	aa0903e0 	mov	x0, x9
  405da0:	f9400bf3 	ldr	x19, [sp, #16]
  405da4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  405da8:	d65f03c0 	ret
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
  405dac:	b94009a1 	ldr	w1, [x13, #8]
	if (bytes == 0 || size_too_big(h, bytes)) {
  405db0:	eb4c0c3f 	cmp	x1, x12, lsr #3
  405db4:	54ffff29 	b.ls	405d98 <sys_heap_aligned_alloc+0xb8>  // b.plast
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  405db8:	cb0001c1 	sub	x1, x14, x0
	chunkid_t c0 = alloc_chunk(h, padded_sz);
  405dbc:	aa0d03e0 	mov	x0, x13
  405dc0:	8b030021 	add	x1, x1, x3
  405dc4:	d3438821 	ubfx	x1, x1, #3, #32
  405dc8:	97fffe99 	bl	40582c <alloc_chunk>
  405dcc:	2a0003e7 	mov	w7, w0
	if (c0 == 0) {
  405dd0:	34fffe40 	cbz	w0, 405d98 <sys_heap_aligned_alloc+0xb8>
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  405dd4:	d37d7ce9 	ubfiz	x9, x7, #3, #32
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  405dd8:	cb0e03ee 	neg	x14, x14
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
  405ddc:	91002129 	add	x9, x9, #0x8
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  405de0:	d2800100 	mov	x0, #0x8                   	// #8
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
  405de4:	8b0f0129 	add	x9, x9, x15
  405de8:	8b0901a9 	add	x9, x13, x9
  405dec:	8b120129 	add	x9, x9, x18
  405df0:	8a0e0129 	and	x9, x9, x14
  405df4:	cb0f0129 	sub	x9, x9, x15
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  405df8:	d100212a 	sub	x10, x9, #0x8
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  405dfc:	8b0c0128 	add	x8, x9, x12
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  405e00:	cb0d014a 	sub	x10, x10, x13
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
  405e04:	91001d08 	add	x8, x8, #0x7
  405e08:	927df108 	and	x8, x8, #0xfffffffffffffff8
	chunkid_t c_end = end - chunk_buf(h);
  405e0c:	cb0d0108 	sub	x8, x8, x13
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
  405e10:	9ac00d4a 	sdiv	x10, x10, x0
	chunkid_t c_end = end - chunk_buf(h);
  405e14:	9343fd08 	asr	x8, x8, #3
	if (c > c0) {
  405e18:	6b0a00ff 	cmp	w7, w10
  405e1c:	54000102 	b.cs	405e3c <sys_heap_aligned_alloc+0x15c>  // b.hs, b.nlast
		split_chunks(h, c0, c);
  405e20:	2a0a03e2 	mov	w2, w10
  405e24:	2a0703e1 	mov	w1, w7
  405e28:	aa0d03e0 	mov	x0, x13
  405e2c:	97ffff22 	bl	405ab4 <split_chunks>
		free_list_add(h, c0);
  405e30:	2a0703e1 	mov	w1, w7
  405e34:	aa0d03e0 	mov	x0, x13
  405e38:	97fffebc 	bl	405928 <free_list_add>
	return c + chunk_size(h, c);
  405e3c:	2a0a03e1 	mov	w1, w10
  405e40:	aa0d03e0 	mov	x0, x13
  405e44:	97fffe5e 	bl	4057bc <chunk_size>
  405e48:	0b0a0000 	add	w0, w0, w10
	if (right_chunk(h, c) > c_end) {
  405e4c:	6b00011f 	cmp	w8, w0
  405e50:	54000102 	b.cs	405e70 <sys_heap_aligned_alloc+0x190>  // b.hs, b.nlast
		split_chunks(h, c, c_end);
  405e54:	2a0803e2 	mov	w2, w8
  405e58:	2a0a03e1 	mov	w1, w10
  405e5c:	aa0d03e0 	mov	x0, x13
  405e60:	97ffff15 	bl	405ab4 <split_chunks>
		free_list_add(h, c_end);
  405e64:	2a0803e1 	mov	w1, w8
  405e68:	aa0d03e0 	mov	x0, x13
  405e6c:	97fffeaf 	bl	405928 <free_list_add>
	void *cmem = &buf[c];
  405e70:	8b2a4daa 	add	x10, x13, w10, uxtw #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  405e74:	b9400540 	ldr	w0, [x10, #4]
  405e78:	32000000 	orr	w0, w0, #0x1
  405e7c:	b9000540 	str	w0, [x10, #4]
  405e80:	17ffffc7 	b	405d9c <sys_heap_aligned_alloc+0xbc>

0000000000405e84 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
  405e84:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (IS_ENABLED(CONFIG_SYS_HEAP_SMALL_ONLY)) {
		/* Must fit in a 15 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffU, "heap size is too big");
	} else {
		/* Must fit in a 31 bit count of HUNK_UNIT */
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  405e88:	b24087e3 	mov	x3, #0x3ffffffff           	// #17179869183
{
  405e8c:	910003fd 	mov	x29, sp
  405e90:	a90153f3 	stp	x19, x20, [sp, #16]
  405e94:	f90013f5 	str	x21, [sp, #32]
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
  405e98:	eb03005f 	cmp	x2, x3
  405e9c:	540002a9 	b.ls	405ef0 <sys_heap_init+0x6c>  // b.plast
  405ea0:	f0000093 	adrp	x19, 418000 <table.0+0x1d8>
  405ea4:	911b0e73 	add	x19, x19, #0x6c3
  405ea8:	aa1303e2 	mov	x2, x19
  405eac:	f0000081 	adrp	x1, 418000 <table.0+0x1d8>
  405eb0:	911f1c21 	add	x1, x1, #0x7c7
  405eb4:	52803dc3 	mov	w3, #0x1ee                 	// #494
  405eb8:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405ebc:	91178000 	add	x0, x0, #0x5e0
  405ec0:	940003da 	bl	406e28 <assert_print>
  405ec4:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405ec8:	911f8400 	add	x0, x0, #0x7e1
  405ecc:	940003d7 	bl	406e28 <assert_print>
  405ed0:	aa1303e0 	mov	x0, x19
  405ed4:	52803dc1 	mov	w1, #0x1ee                 	// #494
  405ed8:	940003fe 	bl	406ed0 <assert_post_action>
  405edc:	52803dc2 	mov	w2, #0x1ee                 	// #494
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
  405ee0:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405ee4:	aa1303e1 	mov	x1, x19
  405ee8:	91187800 	add	x0, x0, #0x61e
  405eec:	94000deb 	bl	409698 <posix_print_error_and_exit>
  405ef0:	f100205f 	cmp	x2, #0x8
  405ef4:	54000248 	b.hi	405f3c <sys_heap_init+0xb8>  // b.pmore
  405ef8:	f0000093 	adrp	x19, 418000 <table.0+0x1d8>
  405efc:	911b0e73 	add	x19, x19, #0x6c3
  405f00:	aa1303e2 	mov	x2, x19
  405f04:	f0000081 	adrp	x1, 418000 <table.0+0x1d8>
  405f08:	911fe021 	add	x1, x1, #0x7f8
  405f0c:	52803e43 	mov	w3, #0x1f2                 	// #498
  405f10:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405f14:	91178000 	add	x0, x0, #0x5e0
  405f18:	940003c4 	bl	406e28 <assert_print>
  405f1c:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405f20:	91206400 	add	x0, x0, #0x819
  405f24:	940003c1 	bl	406e28 <assert_print>
  405f28:	aa1303e0 	mov	x0, x19
  405f2c:	52803e41 	mov	w1, #0x1f2                 	// #498
  405f30:	940003e8 	bl	406ed0 <assert_post_action>
  405f34:	52803e42 	mov	w2, #0x1f2                 	// #498
  405f38:	17ffffea 	b	405ee0 <sys_heap_init+0x5c>
	bytes -= heap_footer_bytes(bytes);
  405f3c:	d1002042 	sub	x2, x2, #0x8

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  405f40:	91001c34 	add	x20, x1, #0x7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  405f44:	8b020033 	add	x19, x1, x2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
  405f48:	927df294 	and	x20, x20, #0xfffffffffffffff8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
  405f4c:	927df273 	and	x19, x19, #0xfffffffffffffff8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
  405f50:	cb140273 	sub	x19, x19, x20
  405f54:	d343fe73 	lsr	x19, x19, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");
  405f58:	71000a7f 	cmp	w19, #0x2
  405f5c:	54000248 	b.hi	405fa4 <sys_heap_init+0x120>  // b.pmore
  405f60:	f0000093 	adrp	x19, 418000 <table.0+0x1d8>
  405f64:	911b0e73 	add	x19, x19, #0x6c3
  405f68:	aa1303e2 	mov	x2, x19
  405f6c:	f0000081 	adrp	x1, 418000 <table.0+0x1d8>
  405f70:	9120c821 	add	x1, x1, #0x832
  405f74:	52803f63 	mov	w3, #0x1fb                 	// #507
  405f78:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405f7c:	91178000 	add	x0, x0, #0x5e0
  405f80:	940003aa 	bl	406e28 <assert_print>
  405f84:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405f88:	91206400 	add	x0, x0, #0x819
  405f8c:	940003a7 	bl	406e28 <assert_print>
  405f90:	aa1303e0 	mov	x0, x19
  405f94:	52803f61 	mov	w1, #0x1fb                 	// #507
  405f98:	940003ce 	bl	406ed0 <assert_post_action>
  405f9c:	52803f62 	mov	w2, #0x1fb                 	// #507
  405fa0:	17ffffd0 	b	405ee0 <sys_heap_init+0x5c>

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
  405fa4:	f9000014 	str	x20, [x0]
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
  405fa8:	51000660 	sub	w0, w19, #0x1
	return 31 - __builtin_clz(usable_sz);
  405fac:	5ac01000 	clz	w0, w0
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
  405fb0:	52800495 	mov	w21, #0x24                  	// #36
  405fb4:	4b0002b5 	sub	w21, w21, w0
  405fb8:	d28000e1 	mov	x1, #0x7                   	// #7
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
  405fbc:	29017e93 	stp	w19, wzr, [x20, #8]
  405fc0:	8b35c835 	add	x21, x1, w21, sxtw #2
  405fc4:	d343feb5 	lsr	x21, x21, #3

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");
  405fc8:	11000aa1 	add	w1, w21, #0x2
  405fcc:	6b13003f 	cmp	w1, w19
  405fd0:	54000249 	b.ls	406018 <sys_heap_init+0x194>  // b.plast
  405fd4:	f0000093 	adrp	x19, 418000 <table.0+0x1d8>
  405fd8:	911b0e73 	add	x19, x19, #0x6c3
  405fdc:	aa1303e2 	mov	x2, x19
  405fe0:	f0000081 	adrp	x1, 418000 <table.0+0x1d8>
  405fe4:	91216c21 	add	x1, x1, #0x85b
  405fe8:	52804183 	mov	w3, #0x20c                 	// #524
  405fec:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405ff0:	91178000 	add	x0, x0, #0x5e0
  405ff4:	9400038d 	bl	406e28 <assert_print>
  405ff8:	f0000080 	adrp	x0, 418000 <table.0+0x1d8>
  405ffc:	91206400 	add	x0, x0, #0x819
  406000:	9400038a 	bl	406e28 <assert_print>
  406004:	aa1303e0 	mov	x0, x19
  406008:	52804181 	mov	w1, #0x20c                 	// #524
  40600c:	940003b1 	bl	406ed0 <assert_post_action>
  406010:	52804182 	mov	w2, #0x20c                 	// #524
  406014:	17ffffb3 	b	405ee0 <sys_heap_init+0x5c>

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
  406018:	52800402 	mov	w2, #0x20                  	// #32
  40601c:	4b000042 	sub	w2, w2, w0
  406020:	52800001 	mov	w1, #0x0                   	// #0
  406024:	91004280 	add	x0, x20, #0x10
  406028:	d37ef442 	lsl	x2, x2, #2
  40602c:	97ffed19 	bl	401490 <memset@plt>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  406030:	531f7aa0 	lsl	w0, w21, #1
		((uint32_t *)cmem)[f] = val;
  406034:	8b150e82 	add	x2, x20, x21, lsl #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406038:	32000000 	orr	w0, w0, #0x1
	void *cmem = &buf[c];
  40603c:	d37df2a1 	lsl	x1, x21, #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406040:	2900029f 	stp	wzr, w0, [x20]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
  406044:	4b150260 	sub	w0, w19, w21
	void *cmem = &buf[c];
  406048:	d37d7e73 	ubfiz	x19, x19, #3, #32
	chunk_set(h, c, SIZE_AND_USED, size << 1);
  40604c:	531f7803 	lsl	w3, w0, #1
		((uint32_t *)cmem)[f] = val;
  406050:	b9000443 	str	w3, [x2, #4]
  406054:	b8216a95 	str	w21, [x20, x1]
  406058:	8b130281 	add	x1, x20, x19
  40605c:	b8336a80 	str	w0, [x20, x19]
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
  406060:	52800020 	mov	w0, #0x1                   	// #1
  406064:	b9000420 	str	w0, [x1, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
  406068:	2a1503e1 	mov	w1, w21
  40606c:	aa1403e0 	mov	x0, x20
}
  406070:	a94153f3 	ldp	x19, x20, [sp, #16]
  406074:	f94013f5 	ldr	x21, [sp, #32]
  406078:	a8c37bfd 	ldp	x29, x30, [sp], #48
	free_list_add(h, chunk0_size);
  40607c:	17fffe2b 	b	405928 <free_list_add>

0000000000406080 <crc32_ieee_update>:
	crc = ~crc;

	for (size_t i = 0; i < len; i++) {
		uint8_t byte = data[i];

		crc = (crc >> 4) ^ table[(crc ^ byte) & 0x0f];
  406080:	b0000085 	adrp	x5, 417000 <z_abort_timeout+0x38>
	crc = ~crc;
  406084:	2a2003e0 	mvn	w0, w0
		crc = (crc >> 4) ^ table[(crc ^ byte) & 0x0f];
  406088:	9138a0a5 	add	x5, x5, #0xe28
	for (size_t i = 0; i < len; i++) {
  40608c:	d2800004 	mov	x4, #0x0                   	// #0
  406090:	eb02009f 	cmp	x4, x2
  406094:	54000061 	b.ne	4060a0 <crc32_ieee_update+0x20>  // b.any
		crc = (crc >> 4) ^ table[(crc ^ ((uint32_t)byte >> 4)) & 0x0f];
	}

	return (~crc);
}
  406098:	2a2003e0 	mvn	w0, w0
  40609c:	d65f03c0 	ret
		uint8_t byte = data[i];
  4060a0:	38646823 	ldrb	w3, [x1, x4]
	for (size_t i = 0; i < len; i++) {
  4060a4:	91000484 	add	x4, x4, #0x1
		crc = (crc >> 4) ^ table[(crc ^ byte) & 0x0f];
  4060a8:	4a000066 	eor	w6, w3, w0
  4060ac:	92400cc6 	and	x6, x6, #0xf
  4060b0:	b86678a6 	ldr	w6, [x5, x6, lsl #2]
  4060b4:	4a4010c0 	eor	w0, w6, w0, lsr #4
		crc = (crc >> 4) ^ table[(crc ^ ((uint32_t)byte >> 4)) & 0x0f];
  4060b8:	4a431003 	eor	w3, w0, w3, lsr #4
  4060bc:	92400c63 	and	x3, x3, #0xf
  4060c0:	b86378a3 	ldr	w3, [x5, x3, lsl #2]
  4060c4:	4a401060 	eor	w0, w3, w0, lsr #4
	for (size_t i = 0; i < len; i++) {
  4060c8:	17fffff2 	b	406090 <crc32_ieee_update+0x10>

00000000004060cc <crc32_ieee>:
	return crc32_ieee_update(0x0, data, len);
  4060cc:	aa0103e2 	mov	x2, x1
  4060d0:	aa0003e1 	mov	x1, x0
  4060d4:	52800000 	mov	w0, #0x0                   	// #0
  4060d8:	17ffffea 	b	406080 <crc32_ieee_update>

00000000004060dc <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
  4060dc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4060e0:	910003fd 	mov	x29, sp
  4060e4:	a90153f3 	stp	x19, x20, [sp, #16]
  4060e8:	aa0203f4 	mov	x20, x2
	size_t count = 0;
  4060ec:	d2800013 	mov	x19, #0x0                   	// #0
{
  4060f0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4060f4:	aa0003f6 	mov	x22, x0
  4060f8:	aa0303f5 	mov	x21, x3
  4060fc:	f9001bf7 	str	x23, [sp, #48]
  406100:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
  406104:	8b130280 	add	x0, x20, x19
  406108:	eb0002bf 	cmp	x21, x0
  40610c:	54000148 	b.hi	406134 <outs+0x58>  // b.pmore
  406110:	b40000f5 	cbz	x21, 40612c <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
  406114:	2a1303e0 	mov	w0, w19
}
  406118:	a94153f3 	ldp	x19, x20, [sp, #16]
  40611c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406120:	f9401bf7 	ldr	x23, [sp, #48]
  406124:	a8c47bfd 	ldp	x29, x30, [sp], #64
  406128:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
  40612c:	38736a80 	ldrb	w0, [x20, x19]
  406130:	34ffff20 	cbz	w0, 406114 <outs+0x38>
		int rc = out((int)*sp++, ctx);
  406134:	38736a80 	ldrb	w0, [x20, x19]
  406138:	aa1703e1 	mov	x1, x23
  40613c:	d63f02c0 	blr	x22
		if (rc < 0) {
  406140:	37fffec0 	tbnz	w0, #31, 406118 <outs+0x3c>
		++count;
  406144:	91000673 	add	x19, x19, #0x1
  406148:	17ffffef 	b	406104 <outs+0x28>

000000000040614c <extract_decimal>:
{
  40614c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  406150:	910003fd 	mov	x29, sp
  406154:	a90153f3 	stp	x19, x20, [sp, #16]
  406158:	aa0003f4 	mov	x20, x0
	const char *sp = *str;
  40615c:	f9400013 	ldr	x19, [x0]
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406160:	97ffed10 	bl	4015a0 <__ctype_b_loc@plt>
		val = 10U * val + *sp++ - '0';
  406164:	d2800144 	mov	x4, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406168:	f9400002 	ldr	x2, [x0]
	size_t val = 0;
  40616c:	d2800000 	mov	x0, #0x0                   	// #0
	while (isdigit((int)(unsigned char)*sp) != 0) {
  406170:	39400263 	ldrb	w3, [x19]
  406174:	78637841 	ldrh	w1, [x2, x3, lsl #1]
  406178:	375800a1 	tbnz	w1, #11, 40618c <extract_decimal+0x40>
	*str = sp;
  40617c:	f9000293 	str	x19, [x20]
}
  406180:	a94153f3 	ldp	x19, x20, [sp, #16]
  406184:	a8c27bfd 	ldp	x29, x30, [sp], #32
  406188:	d65f03c0 	ret
		val = 10U * val + *sp++ - '0';
  40618c:	9b040c00 	madd	x0, x0, x4, x3
  406190:	91000673 	add	x19, x19, #0x1
  406194:	d100c000 	sub	x0, x0, #0x30
  406198:	17fffff6 	b	406170 <extract_decimal+0x24>

000000000040619c <encode_uint>:
{
  40619c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4061a0:	910003fd 	mov	x29, sp
  4061a4:	a90153f3 	stp	x19, x20, [sp, #16]
  4061a8:	aa0103f3 	mov	x19, x1
  4061ac:	aa0303f4 	mov	x20, x3
  4061b0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4061b4:	aa0203f6 	mov	x22, x2
  4061b8:	aa0003f5 	mov	x21, x0
	bool upcase = isupper((int)conv->specifier) != 0;
  4061bc:	97ffecf9 	bl	4015a0 <__ctype_b_loc@plt>
  4061c0:	39400e62 	ldrb	w2, [x19, #3]
  4061c4:	f9400000 	ldr	x0, [x0]
  4061c8:	39400e61 	ldrb	w1, [x19, #3]
  4061cc:	78627802 	ldrh	w2, [x0, x2, lsl #1]
  4061d0:	12180042 	and	w2, w2, #0x100
	switch (specifier) {
  4061d4:	7101bc3f 	cmp	w1, #0x6f
  4061d8:	54000400 	b.eq	406258 <encode_uint+0xbc>  // b.none
  4061dc:	54000388 	b.hi	40624c <encode_uint+0xb0>  // b.pmore
		return 16;
  4061e0:	7101603f 	cmp	w1, #0x58
  4061e4:	d2800145 	mov	x5, #0xa                   	// #10
  4061e8:	d2800200 	mov	x0, #0x10                  	// #16
  4061ec:	9a8010a5 	csel	x5, x5, x0, ne  // ne = any
	char *bp = bps + (bpe - bps);
  4061f0:	aa1403e0 	mov	x0, x20
		unsigned int lsv = (unsigned int)(value % radix);
  4061f4:	9ac50aa3 	udiv	x3, x21, x5
  4061f8:	9b05d461 	msub	x1, x3, x5, x21
		*--bp = (lsv <= 9) ? ('0' + lsv)
  4061fc:	12001c24 	and	w4, w1, #0xff
  406200:	f100243f 	cmp	x1, #0x9
  406204:	54000328 	b.hi	406268 <encode_uint+0xcc>  // b.pmore
  406208:	1100c084 	add	w4, w4, #0x30
  40620c:	12001c84 	and	w4, w4, #0xff
  406210:	381ffc04 	strb	w4, [x0, #-1]!
	} while ((value != 0) && (bps < bp));
  406214:	eb0502bf 	cmp	x21, x5
  406218:	fa562000 	ccmp	x0, x22, #0x0, cs  // cs = hs, nlast
  40621c:	54000228 	b.hi	406260 <encode_uint+0xc4>  // b.pmore
	if (conv->flag_hash) {
  406220:	79400261 	ldrh	w1, [x19]
  406224:	362800c1 	tbz	w1, #5, 40623c <encode_uint+0xa0>
		if (radix == 8) {
  406228:	f10020bf 	cmp	x5, #0x8
  40622c:	540002c1 	b.ne	406284 <encode_uint+0xe8>  // b.any
			conv->altform_0 = true;
  406230:	39400a61 	ldrb	w1, [x19, #2]
  406234:	321d0021 	orr	w1, w1, #0x8
			conv->altform_0c = true;
  406238:	39000a61 	strb	w1, [x19, #2]
}
  40623c:	a94153f3 	ldp	x19, x20, [sp, #16]
  406240:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406244:	a8c37bfd 	ldp	x29, x30, [sp], #48
  406248:	d65f03c0 	ret
	switch (specifier) {
  40624c:	121c7821 	and	w1, w1, #0xfffffff7
		return 16;
  406250:	7101c03f 	cmp	w1, #0x70
  406254:	17ffffe4 	b	4061e4 <encode_uint+0x48>
	switch (specifier) {
  406258:	d2800105 	mov	x5, #0x8                   	// #8
  40625c:	17ffffe5 	b	4061f0 <encode_uint+0x54>
		value /= radix;
  406260:	aa0303f5 	mov	x21, x3
  406264:	17ffffe4 	b	4061f4 <encode_uint+0x58>
		*--bp = (lsv <= 9) ? ('0' + lsv)
  406268:	1100dc81 	add	w1, w4, #0x37
  40626c:	11015c84 	add	w4, w4, #0x57
  406270:	12001c21 	and	w1, w1, #0xff
  406274:	12001c84 	and	w4, w4, #0xff
  406278:	7100005f 	cmp	w2, #0x0
  40627c:	1a810084 	csel	w4, w4, w1, eq  // eq = none
  406280:	17ffffe4 	b	406210 <encode_uint+0x74>
		} else if (radix == 16) {
  406284:	f10040bf 	cmp	x5, #0x10
  406288:	54fffda1 	b.ne	40623c <encode_uint+0xa0>  // b.any
			conv->altform_0c = true;
  40628c:	39400a61 	ldrb	w1, [x19, #2]
  406290:	321c0021 	orr	w1, w1, #0x10
  406294:	17ffffe9 	b	406238 <encode_uint+0x9c>

0000000000406298 <z_cbvprintf_impl>:

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
  406298:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
  40629c:	910003fd 	mov	x29, sp
  4062a0:	a9046bf9 	stp	x25, x26, [sp, #64]
  4062a4:	aa0003f9 	mov	x25, x0
  4062a8:	f0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4062ac:	a90153f3 	stp	x19, x20, [sp, #16]
  4062b0:	aa0103fa 	mov	x26, x1
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
  4062b4:	d2800013 	mov	x19, #0x0                   	// #0
{
  4062b8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4062bc:	aa0203f5 	mov	x21, x2
  4062c0:	a90363f7 	stp	x23, x24, [sp, #48]
  4062c4:	a90573fb 	stp	x27, x28, [sp, #80]
  4062c8:	f9475c00 	ldr	x0, [x0, #3768]
  4062cc:	a940607c 	ldp	x28, x24, [x3]
  4062d0:	f9400001 	ldr	x1, [x0]
  4062d4:	f90067e1 	str	x1, [sp, #200]
  4062d8:	d2800001 	mov	x1, #0x0                   	// #0
  4062dc:	b940187b 	ldr	w27, [x3, #24]
  4062e0:	f9400860 	ldr	x0, [x3, #16]
  4062e4:	f9003be0 	str	x0, [sp, #112]
  4062e8:	b9401c60 	ldr	w0, [x3, #28]
  4062ec:	b90067e0 	str	w0, [sp, #100]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
  4062f0:	91031be0 	add	x0, sp, #0xc6
  4062f4:	f90037e0 	str	x0, [sp, #104]
  4062f8:	394002a0 	ldrb	w0, [x21]
  4062fc:	35000140 	cbnz	w0, 406324 <z_cbvprintf_impl+0x8c>
			OUTC(' ');
			--width;
		}
	}

	return count;
  406300:	2a1303e0 	mov	w0, w19
#undef OUTS
#undef OUTC
}
  406304:	f0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  406308:	f9475c21 	ldr	x1, [x1, #3768]
  40630c:	f94067e3 	ldr	x3, [sp, #200]
  406310:	f9400022 	ldr	x2, [x1]
  406314:	eb020063 	subs	x3, x3, x2
  406318:	d2800002 	mov	x2, #0x0                   	// #0
  40631c:	54005780 	b.eq	406e0c <z_cbvprintf_impl+0xb74>  // b.none
  406320:	97ffec80 	bl	401520 <__stack_chk_fail@plt>
			OUTC(*fp++);
  406324:	910006b4 	add	x20, x21, #0x1
		if (*fp != '%') {
  406328:	7100941f 	cmp	w0, #0x25
  40632c:	540000c0 	b.eq	406344 <z_cbvprintf_impl+0xac>  // b.none
			OUTC('%');
  406330:	aa1a03e1 	mov	x1, x26
  406334:	d63f0320 	blr	x25
  406338:	37fffe60 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  40633c:	91000673 	add	x19, x19, #0x1
			break;
  406340:	14000140 	b	406840 <z_cbvprintf_impl+0x5a8>
		} state = {
  406344:	a9097fff 	stp	xzr, xzr, [sp, #144]
  406348:	a90a7fff 	stp	xzr, xzr, [sp, #160]
	if (*sp == '%') {
  40634c:	394006a0 	ldrb	w0, [x21, #1]
  406350:	7100941f 	cmp	w0, #0x25
  406354:	54000661 	b.ne	406420 <z_cbvprintf_impl+0x188>  // b.any
		conv->specifier = *sp++;
  406358:	91000ab4 	add	x20, x21, #0x2
  40635c:	39028fe0 	strb	w0, [sp, #163]
		if (conv->width_star) {
  406360:	794143e0 	ldrh	w0, [sp, #160]
  406364:	364021c0 	tbz	w0, #8, 40679c <z_cbvprintf_impl+0x504>
			width = va_arg(ap, int);
  406368:	37f8205b 	tbnz	w27, #31, 406770 <z_cbvprintf_impl+0x4d8>
  40636c:	91002f81 	add	x1, x28, #0xb
  406370:	aa1c03e0 	mov	x0, x28
  406374:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  406378:	b9400016 	ldr	w22, [x0]
			if (width < 0) {
  40637c:	36f800b6 	tbz	w22, #31, 406390 <z_cbvprintf_impl+0xf8>
				conv->flag_dash = true;
  406380:	794143e0 	ldrh	w0, [sp, #160]
				width = -width;
  406384:	4b1603f6 	neg	w22, w22
				conv->flag_dash = true;
  406388:	321e0000 	orr	w0, w0, #0x4
  40638c:	790143e0 	strh	w0, [sp, #160]
		if (conv->prec_star) {
  406390:	794143e0 	ldrh	w0, [sp, #160]
  406394:	36502220 	tbz	w0, #10, 4067d8 <z_cbvprintf_impl+0x540>
			int arg = va_arg(ap, int);
  406398:	37f820bb 	tbnz	w27, #31, 4067ac <z_cbvprintf_impl+0x514>
  40639c:	91002f81 	add	x1, x28, #0xb
  4063a0:	aa1c03e0 	mov	x0, x28
  4063a4:	927df03c 	and	x28, x1, #0xfffffffffffffff8
  4063a8:	b9400017 	ldr	w23, [x0]
			if (arg < 0) {
  4063ac:	36f800b7 	tbz	w23, #31, 4063c0 <z_cbvprintf_impl+0x128>
				conv->prec_present = false;
  4063b0:	794143e0 	ldrh	w0, [sp, #160]
		int precision = -1;
  4063b4:	12800017 	mov	w23, #0xffffffff            	// #-1
				conv->prec_present = false;
  4063b8:	12167800 	and	w0, w0, #0xfffffdff
  4063bc:	790143e0 	strh	w0, [sp, #160]
		conv->pad0_value = 0;
  4063c0:	f80a43ff 	stur	xzr, [sp, #164]
			= (enum specifier_cat_enum)conv->specifier_cat;
  4063c4:	f94053e1 	ldr	x1, [sp, #160]
		enum specifier_cat_enum specifier_cat
  4063c8:	53104820 	ubfx	w0, w1, #16, #3
			= (enum length_mod_enum)conv->length_mod;
  4063cc:	530b3821 	ubfx	w1, w1, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
  4063d0:	7100041f 	cmp	w0, #0x1
  4063d4:	54002721 	b.ne	4068b8 <z_cbvprintf_impl+0x620>  // b.any
			switch (length_mod) {
  4063d8:	51000c22 	sub	w2, w1, #0x3
  4063dc:	7100105f 	cmp	w2, #0x4
  4063e0:	54002048 	b.hi	4067e8 <z_cbvprintf_impl+0x550>  // b.pmore
  4063e4:	b0000080 	adrp	x0, 417000 <z_abort_timeout+0x38>
  4063e8:	9139a000 	add	x0, x0, #0xe68
  4063ec:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
  4063f0:	10000062 	adr	x2, 4063fc <z_cbvprintf_impl+0x164>
  4063f4:	8b20a840 	add	x0, x2, w0, sxth #2
  4063f8:	d61f0000 	br	x0
		switch (*sp) {
  4063fc:	7100b43f 	cmp	w1, #0x2d
  406400:	540000a0 	b.eq	406414 <z_cbvprintf_impl+0x17c>  // b.none
  406404:	7100c03f 	cmp	w1, #0x30
  406408:	540001e1 	b.ne	406444 <z_cbvprintf_impl+0x1ac>  // b.any
			conv->flag_zero = true;
  40640c:	321a0000 	orr	w0, w0, #0x40
  406410:	14000002 	b	406418 <z_cbvprintf_impl+0x180>
			conv->flag_dash = true;
  406414:	321e0000 	orr	w0, w0, #0x4
			++sp;
  406418:	91000694 	add	x20, x20, #0x1
			conv->flag_zero = true;
  40641c:	790143e0 	strh	w0, [sp, #160]
		switch (*sp) {
  406420:	39400281 	ldrb	w1, [x20]
  406424:	794143e0 	ldrh	w0, [sp, #160]
  406428:	7100ac3f 	cmp	w1, #0x2b
  40642c:	54000b00 	b.eq	40658c <z_cbvprintf_impl+0x2f4>  // b.none
  406430:	54fffe68 	b.hi	4063fc <z_cbvprintf_impl+0x164>  // b.pmore
  406434:	7100803f 	cmp	w1, #0x20
  406438:	54000ae0 	b.eq	406594 <z_cbvprintf_impl+0x2fc>  // b.none
  40643c:	71008c3f 	cmp	w1, #0x23
  406440:	54000ae0 	b.eq	40659c <z_cbvprintf_impl+0x304>  // b.none
	if (conv->flag_zero && conv->flag_dash) {
  406444:	b940a3e1 	ldr	w1, [sp, #160]
  406448:	52800882 	mov	w2, #0x44                  	// #68
  40644c:	0a020021 	and	w1, w1, w2
  406450:	6b02003f 	cmp	w1, w2
  406454:	54000061 	b.ne	406460 <z_cbvprintf_impl+0x1c8>  // b.any
		conv->flag_zero = false;
  406458:	12197800 	and	w0, w0, #0xffffffbf
  40645c:	790143e0 	strh	w0, [sp, #160]
	conv->width_present = true;
  406460:	794143e0 	ldrh	w0, [sp, #160]
  406464:	f90047f4 	str	x20, [sp, #136]
  406468:	32190001 	orr	w1, w0, #0x80
  40646c:	790143e1 	strh	w1, [sp, #160]
	if (*sp == '*') {
  406470:	39400281 	ldrb	w1, [x20]
  406474:	7100a83f 	cmp	w1, #0x2a
  406478:	54000961 	b.ne	4065a4 <z_cbvprintf_impl+0x30c>  // b.any
		return ++sp;
  40647c:	91000694 	add	x20, x20, #0x1
		conv->width_star = true;
  406480:	32190400 	orr	w0, w0, #0x180
  406484:	790143e0 	strh	w0, [sp, #160]
	sp = extract_prec(conv, sp);
  406488:	f90047f4 	str	x20, [sp, #136]
	conv->prec_present = (*sp == '.');
  40648c:	39400280 	ldrb	w0, [x20]
  406490:	7100b81f 	cmp	w0, #0x2e
  406494:	794143e0 	ldrh	w0, [sp, #160]
  406498:	1a9f17e1 	cset	w1, eq  // eq = none
  40649c:	33170020 	bfi	w0, w1, #9, #1
  4064a0:	790143e0 	strh	w0, [sp, #160]
	if (!conv->prec_present) {
  4064a4:	54000121 	b.ne	4064c8 <z_cbvprintf_impl+0x230>  // b.any
	++sp;
  4064a8:	91000681 	add	x1, x20, #0x1
  4064ac:	f90047e1 	str	x1, [sp, #136]
	if (*sp == '*') {
  4064b0:	39400681 	ldrb	w1, [x20, #1]
  4064b4:	7100a83f 	cmp	w1, #0x2a
  4064b8:	54000961 	b.ne	4065e4 <z_cbvprintf_impl+0x34c>  // b.any
		return ++sp;
  4064bc:	91000a94 	add	x20, x20, #0x2
		conv->prec_star = true;
  4064c0:	32160000 	orr	w0, w0, #0x400
  4064c4:	790143e0 	strh	w0, [sp, #160]
	switch (*sp) {
  4064c8:	aa1403e1 	mov	x1, x20
  4064cc:	38401420 	ldrb	w0, [x1], #1
  4064d0:	7101b01f 	cmp	w0, #0x6c
  4064d4:	54000d00 	b.eq	406674 <z_cbvprintf_impl+0x3dc>  // b.none
  4064d8:	54000a68 	b.hi	406624 <z_cbvprintf_impl+0x38c>  // b.pmore
  4064dc:	7101a01f 	cmp	w0, #0x68
  4064e0:	54000b00 	b.eq	406640 <z_cbvprintf_impl+0x3a8>  // b.none
  4064e4:	7101a81f 	cmp	w0, #0x6a
  4064e8:	54000d60 	b.eq	406694 <z_cbvprintf_impl+0x3fc>  // b.none
  4064ec:	7101301f 	cmp	w0, #0x4c
  4064f0:	54000de0 	b.eq	4066ac <z_cbvprintf_impl+0x414>  // b.none
  4064f4:	aa1403e1 	mov	x1, x20
	conv->specifier = *sp++;
  4064f8:	aa0103f4 	mov	x20, x1
  4064fc:	38401682 	ldrb	w2, [x20], #1
  406500:	39028fe2 	strb	w2, [sp, #163]
	switch (conv->specifier) {
  406504:	7101a45f 	cmp	w2, #0x69
  406508:	54001028 	b.hi	40670c <z_cbvprintf_impl+0x474>  // b.pmore
  40650c:	7101005f 	cmp	w2, #0x40
  406510:	54001069 	b.ls	40671c <z_cbvprintf_impl+0x484>  // b.plast
  406514:	51010441 	sub	w1, w2, #0x41
  406518:	d2800020 	mov	x0, #0x1                   	// #1
  40651c:	d2800e23 	mov	x3, #0x71                  	// #113
  406520:	9ac12001 	lsl	x1, x0, x1
  406524:	f2c00e23 	movk	x3, #0x71, lsl #32
  406528:	ea03003f 	tst	x1, x3
  40652c:	54001021 	b.ne	406730 <z_cbvprintf_impl+0x498>  // b.any
  406530:	d2c02103 	mov	x3, #0x10800000000         	// #1133871366144
  406534:	ea03003f 	tst	x1, x3
  406538:	540000c1 	b.ne	406550 <z_cbvprintf_impl+0x2b8>  // b.any
  40653c:	d2a01000 	mov	x0, #0x800000              	// #8388608
  406540:	f2c00080 	movk	x0, #0x4, lsl #32
  406544:	ea00003f 	tst	x1, x0
  406548:	54000ea0 	b.eq	40671c <z_cbvprintf_impl+0x484>  // b.none
  40654c:	52800040 	mov	w0, #0x2                   	// #2
		conv->specifier_cat = SPECIFIER_SINT;
  406550:	39428be1 	ldrb	w1, [sp, #162]
  406554:	33000801 	bfxil	w1, w0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
  406558:	794143e0 	ldrh	w0, [sp, #160]
		conv->specifier_cat = SPECIFIER_SINT;
  40655c:	39028be1 	strb	w1, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  406560:	12150c01 	and	w1, w0, #0x7800
  406564:	7140103f 	cmp	w1, #0x4, lsl #12
  406568:	54000061 	b.ne	406574 <z_cbvprintf_impl+0x2dc>  // b.any
			conv->invalid = true;
  40656c:	32000000 	orr	w0, w0, #0x1
  406570:	790143e0 	strh	w0, [sp, #160]
		if (conv->specifier == 'c') {
  406574:	71018c5f 	cmp	w2, #0x63
  406578:	54000d81 	b.ne	406728 <z_cbvprintf_impl+0x490>  // b.any
		if (conv->length_mod != LENGTH_NONE) {
  40657c:	794143e0 	ldrh	w0, [sp, #160]
  406580:	72150c1f 	tst	w0, #0x7800
  406584:	1a9f07e0 	cset	w0, ne  // ne = any
  406588:	1400006e 	b	406740 <z_cbvprintf_impl+0x4a8>
			conv->flag_plus = true;
  40658c:	321d0000 	orr	w0, w0, #0x8
  406590:	17ffffa2 	b	406418 <z_cbvprintf_impl+0x180>
			conv->flag_space = true;
  406594:	321c0000 	orr	w0, w0, #0x10
  406598:	17ffffa0 	b	406418 <z_cbvprintf_impl+0x180>
			conv->flag_hash = true;
  40659c:	321b0000 	orr	w0, w0, #0x20
  4065a0:	17ffff9e 	b	406418 <z_cbvprintf_impl+0x180>
	size_t width = extract_decimal(&sp);
  4065a4:	910223e0 	add	x0, sp, #0x88
  4065a8:	97fffee9 	bl	40614c <extract_decimal>
	if (sp != wp) {
  4065ac:	f94047e1 	ldr	x1, [sp, #136]
  4065b0:	eb14003f 	cmp	x1, x20
  4065b4:	54fff6a0 	b.eq	406488 <z_cbvprintf_impl+0x1f0>  // b.none
		conv->width_value = width;
  4065b8:	b900a7e0 	str	w0, [sp, #164]
				      || (width != (size_t)conv->width_value));
  4065bc:	37f80100 	tbnz	w0, #31, 4065dc <z_cbvprintf_impl+0x344>
  4065c0:	eb20c01f 	cmp	x0, w0, sxtw
  4065c4:	1a9f07e2 	cset	w2, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
  4065c8:	794143e0 	ldrh	w0, [sp, #160]
  4065cc:	aa0103f4 	mov	x20, x1
  4065d0:	331f0040 	bfi	w0, w2, #1, #1
  4065d4:	790143e0 	strh	w0, [sp, #160]
  4065d8:	17ffffac 	b	406488 <z_cbvprintf_impl+0x1f0>
				      || (width != (size_t)conv->width_value));
  4065dc:	52800022 	mov	w2, #0x1                   	// #1
  4065e0:	17fffffa 	b	4065c8 <z_cbvprintf_impl+0x330>
	size_t prec = extract_decimal(&sp);
  4065e4:	910223e0 	add	x0, sp, #0x88
  4065e8:	97fffed9 	bl	40614c <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
  4065ec:	f94053e1 	ldr	x1, [sp, #160]
	conv->prec_value = prec;
  4065f0:	b900abe0 	str	w0, [sp, #168]
	conv->unsupported |= ((conv->prec_value < 0)
  4065f4:	53010421 	ubfx	w1, w1, #1, #1
			      || (prec != (size_t)conv->prec_value));
  4065f8:	37f80120 	tbnz	w0, #31, 40661c <z_cbvprintf_impl+0x384>
  4065fc:	eb20c01f 	cmp	x0, w0, sxtw
  406600:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
  406604:	2a000020 	orr	w0, w1, w0
  406608:	794143e1 	ldrh	w1, [sp, #160]
	return sp;
  40660c:	f94047f4 	ldr	x20, [sp, #136]
	conv->unsupported |= ((conv->prec_value < 0)
  406610:	331f0001 	bfi	w1, w0, #1, #1
  406614:	790143e1 	strh	w1, [sp, #160]
	return sp;
  406618:	17ffffac 	b	4064c8 <z_cbvprintf_impl+0x230>
			      || (prec != (size_t)conv->prec_value));
  40661c:	52800020 	mov	w0, #0x1                   	// #1
  406620:	17fffff9 	b	406604 <z_cbvprintf_impl+0x36c>
	switch (*sp) {
  406624:	7101d01f 	cmp	w0, #0x74
  406628:	540003c0 	b.eq	4066a0 <z_cbvprintf_impl+0x408>  // b.none
  40662c:	7101e81f 	cmp	w0, #0x7a
  406630:	54fff621 	b.ne	4064f4 <z_cbvprintf_impl+0x25c>  // b.any
		conv->length_mod = LENGTH_Z;
  406634:	794143e0 	ldrh	w0, [sp, #160]
  406638:	528000c2 	mov	w2, #0x6                   	// #6
  40663c:	1400000b 	b	406668 <z_cbvprintf_impl+0x3d0>
		if (*++sp == 'h') {
  406640:	39400680 	ldrb	w0, [x20, #1]
  406644:	7101a01f 	cmp	w0, #0x68
  406648:	794143e0 	ldrh	w0, [sp, #160]
  40664c:	540000c1 	b.ne	406664 <z_cbvprintf_impl+0x3cc>  // b.any
			conv->length_mod = LENGTH_HH;
  406650:	52800021 	mov	w1, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
  406654:	33150c20 	bfi	w0, w1, #11, #4
			++sp;
  406658:	91000a81 	add	x1, x20, #0x2
			conv->length_mod = LENGTH_LL;
  40665c:	790143e0 	strh	w0, [sp, #160]
			++sp;
  406660:	17ffffa6 	b	4064f8 <z_cbvprintf_impl+0x260>
			conv->length_mod = LENGTH_H;
  406664:	52800042 	mov	w2, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
  406668:	33150c40 	bfi	w0, w2, #11, #4
		conv->unsupported = true;
  40666c:	790143e0 	strh	w0, [sp, #160]
		break;
  406670:	17ffffa2 	b	4064f8 <z_cbvprintf_impl+0x260>
		if (*++sp == 'l') {
  406674:	39400680 	ldrb	w0, [x20, #1]
  406678:	7101b01f 	cmp	w0, #0x6c
  40667c:	794143e0 	ldrh	w0, [sp, #160]
  406680:	54000061 	b.ne	40668c <z_cbvprintf_impl+0x3f4>  // b.any
			conv->length_mod = LENGTH_LL;
  406684:	52800081 	mov	w1, #0x4                   	// #4
  406688:	17fffff3 	b	406654 <z_cbvprintf_impl+0x3bc>
			conv->length_mod = LENGTH_L;
  40668c:	52800062 	mov	w2, #0x3                   	// #3
  406690:	17fffff6 	b	406668 <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_J;
  406694:	794143e0 	ldrh	w0, [sp, #160]
  406698:	528000a2 	mov	w2, #0x5                   	// #5
  40669c:	17fffff3 	b	406668 <z_cbvprintf_impl+0x3d0>
		conv->length_mod = LENGTH_T;
  4066a0:	794143e0 	ldrh	w0, [sp, #160]
  4066a4:	528000e2 	mov	w2, #0x7                   	// #7
  4066a8:	17fffff0 	b	406668 <z_cbvprintf_impl+0x3d0>
		conv->unsupported = true;
  4066ac:	794143e0 	ldrh	w0, [sp, #160]
  4066b0:	128f0042 	mov	w2, #0xffff87fd            	// #-30723
  4066b4:	0a020000 	and	w0, w0, w2
  4066b8:	52880042 	mov	w2, #0x4002                	// #16386
  4066bc:	2a020000 	orr	w0, w0, w2
  4066c0:	17ffffeb 	b	40666c <z_cbvprintf_impl+0x3d4>
  4066c4:	d2800020 	mov	x0, #0x1                   	// #1
  4066c8:	9ac12000 	lsl	x0, x0, x1
	switch (conv->specifier) {
  4066cc:	d2809041 	mov	x1, #0x482                 	// #1154
  4066d0:	ea01001f 	tst	x0, x1
  4066d4:	54fff3c1 	b.ne	40654c <z_cbvprintf_impl+0x2b4>  // b.any
  4066d8:	d2800481 	mov	x1, #0x24                  	// #36
  4066dc:	ea01001f 	tst	x0, x1
  4066e0:	540003e1 	b.ne	40675c <z_cbvprintf_impl+0x4c4>  // b.any
  4066e4:	360001c0 	tbz	w0, #0, 40671c <z_cbvprintf_impl+0x484>
		conv->specifier_cat = SPECIFIER_PTR;
  4066e8:	39428be0 	ldrb	w0, [sp, #162]
  4066ec:	52800061 	mov	w1, #0x3                   	// #3
  4066f0:	33000820 	bfxil	w0, w1, #0, #3
  4066f4:	39028be0 	strb	w0, [sp, #162]
		if (conv->length_mod == LENGTH_UPPER_L) {
  4066f8:	794143e0 	ldrh	w0, [sp, #160]
  4066fc:	12150c00 	and	w0, w0, #0x7800
  406700:	7140101f 	cmp	w0, #0x4, lsl #12
  406704:	1a9f17e0 	cset	w0, eq  // eq = none
  406708:	1400000e 	b	406740 <z_cbvprintf_impl+0x4a8>
	switch (conv->specifier) {
  40670c:	5101b841 	sub	w1, w2, #0x6e
  406710:	12001c21 	and	w1, w1, #0xff
  406714:	7100283f 	cmp	w1, #0xa
  406718:	54fffd69 	b.ls	4066c4 <z_cbvprintf_impl+0x42c>  // b.plast
		conv->invalid = true;
  40671c:	794143e0 	ldrh	w0, [sp, #160]
  406720:	32000000 	orr	w0, w0, #0x1
  406724:	790143e0 	strh	w0, [sp, #160]
	bool unsupported = false;
  406728:	52800000 	mov	w0, #0x0                   	// #0
  40672c:	14000005 	b	406740 <z_cbvprintf_impl+0x4a8>
		conv->specifier_cat = SPECIFIER_FP;
  406730:	39428be1 	ldrb	w1, [sp, #162]
  406734:	52800082 	mov	w2, #0x4                   	// #4
  406738:	33000841 	bfxil	w1, w2, #0, #3
  40673c:	39028be1 	strb	w1, [sp, #162]
	conv->unsupported |= unsupported;
  406740:	f94053e1 	ldr	x1, [sp, #160]
  406744:	d3410421 	ubfx	x1, x1, #1, #1
  406748:	2a010000 	orr	w0, w0, w1
  40674c:	794143e1 	ldrh	w1, [sp, #160]
  406750:	331f0001 	bfi	w1, w0, #1, #1
  406754:	790143e1 	strh	w1, [sp, #160]
	return sp;
  406758:	17ffff02 	b	406360 <z_cbvprintf_impl+0xc8>
		conv->specifier_cat = SPECIFIER_PTR;
  40675c:	39428be0 	ldrb	w0, [sp, #162]
  406760:	52800061 	mov	w1, #0x3                   	// #3
  406764:	33000820 	bfxil	w0, w1, #0, #3
  406768:	39028be0 	strb	w0, [sp, #162]
  40676c:	17ffff84 	b	40657c <z_cbvprintf_impl+0x2e4>
			width = va_arg(ap, int);
  406770:	11002361 	add	w1, w27, #0x8
  406774:	7100003f 	cmp	w1, #0x0
  406778:	540000cd 	b.le	406790 <z_cbvprintf_impl+0x4f8>
  40677c:	91002f82 	add	x2, x28, #0xb
  406780:	aa1c03e0 	mov	x0, x28
  406784:	2a0103fb 	mov	w27, w1
  406788:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  40678c:	17fffefb 	b	406378 <z_cbvprintf_impl+0xe0>
  406790:	8b3bc300 	add	x0, x24, w27, sxtw
  406794:	2a0103fb 	mov	w27, w1
  406798:	17fffef8 	b	406378 <z_cbvprintf_impl+0xe0>
			width = conv->width_value;
  40679c:	b940a7f6 	ldr	w22, [sp, #164]
  4067a0:	f279001f 	tst	x0, #0x80
  4067a4:	5a9f12d6 	csinv	w22, w22, wzr, ne  // ne = any
  4067a8:	17fffefa 	b	406390 <z_cbvprintf_impl+0xf8>
			int arg = va_arg(ap, int);
  4067ac:	11002361 	add	w1, w27, #0x8
  4067b0:	7100003f 	cmp	w1, #0x0
  4067b4:	540000cd 	b.le	4067cc <z_cbvprintf_impl+0x534>
  4067b8:	91002f82 	add	x2, x28, #0xb
  4067bc:	aa1c03e0 	mov	x0, x28
  4067c0:	2a0103fb 	mov	w27, w1
  4067c4:	927df05c 	and	x28, x2, #0xfffffffffffffff8
  4067c8:	17fffef8 	b	4063a8 <z_cbvprintf_impl+0x110>
  4067cc:	8b3bc300 	add	x0, x24, w27, sxtw
  4067d0:	2a0103fb 	mov	w27, w1
  4067d4:	17fffef5 	b	4063a8 <z_cbvprintf_impl+0x110>
			precision = conv->prec_value;
  4067d8:	b940abf7 	ldr	w23, [sp, #168]
  4067dc:	f277001f 	tst	x0, #0x200
  4067e0:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
  4067e4:	17fffef7 	b	4063c0 <z_cbvprintf_impl+0x128>
				value->sint = va_arg(ap, int);
  4067e8:	37f8031b 	tbnz	w27, #31, 406848 <z_cbvprintf_impl+0x5b0>
  4067ec:	91002f82 	add	x2, x28, #0xb
  4067f0:	2a1b03e3 	mov	w3, w27
  4067f4:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4067f8:	b9800380 	ldrsw	x0, [x28]
  4067fc:	f9004be0 	str	x0, [sp, #144]
				break;
  406800:	2a0303fb 	mov	w27, w3
  406804:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  406808:	7100043f 	cmp	w1, #0x1
  40680c:	540004e1 	b.ne	4068a8 <z_cbvprintf_impl+0x610>  // b.any
				value->sint = (signed char)value->sint;
  406810:	93401c00 	sxtb	x0, w0
				value->uint = (unsigned short)value->uint;
  406814:	f9004be0 	str	x0, [sp, #144]
		if (conv->invalid || conv->unsupported) {
  406818:	b940a3e0 	ldr	w0, [sp, #160]
  40681c:	f240041f 	tst	x0, #0x3
  406820:	540015a0 	b.eq	406ad4 <z_cbvprintf_impl+0x83c>  // b.none
			OUTS(sp, fp);
  406824:	aa1403e3 	mov	x3, x20
  406828:	aa1503e2 	mov	x2, x21
  40682c:	aa1a03e1 	mov	x1, x26
  406830:	aa1903e0 	mov	x0, x25
  406834:	97fffe2a 	bl	4060dc <outs>
  406838:	37ffd660 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  40683c:	8b20c273 	add	x19, x19, w0, sxtw
			continue;
  406840:	aa1403f5 	mov	x21, x20
  406844:	17fffead 	b	4062f8 <z_cbvprintf_impl+0x60>
				value->sint = va_arg(ap, int);
  406848:	11002363 	add	w3, w27, #0x8
  40684c:	7100007f 	cmp	w3, #0x0
  406850:	5400008d 	b.le	406860 <z_cbvprintf_impl+0x5c8>
  406854:	91002f82 	add	x2, x28, #0xb
  406858:	927df042 	and	x2, x2, #0xfffffffffffffff8
  40685c:	17ffffe7 	b	4067f8 <z_cbvprintf_impl+0x560>
  406860:	aa1c03e2 	mov	x2, x28
  406864:	8b3bc31c 	add	x28, x24, w27, sxtw
  406868:	17ffffe4 	b	4067f8 <z_cbvprintf_impl+0x560>
					(sint_value_type)va_arg(ap, ptrdiff_t);
  40686c:	37f800db 	tbnz	w27, #31, 406884 <z_cbvprintf_impl+0x5ec>
  406870:	91003f82 	add	x2, x28, #0xf
  406874:	2a1b03e3 	mov	w3, w27
  406878:	927df042 	and	x2, x2, #0xfffffffffffffff8
  40687c:	f9400380 	ldr	x0, [x28]
  406880:	17ffffdf 	b	4067fc <z_cbvprintf_impl+0x564>
  406884:	11002363 	add	w3, w27, #0x8
  406888:	7100007f 	cmp	w3, #0x0
  40688c:	5400008d 	b.le	40689c <z_cbvprintf_impl+0x604>
  406890:	91003f82 	add	x2, x28, #0xf
  406894:	927df042 	and	x2, x2, #0xfffffffffffffff8
  406898:	17fffff9 	b	40687c <z_cbvprintf_impl+0x5e4>
  40689c:	aa1c03e2 	mov	x2, x28
  4068a0:	8b3bc31c 	add	x28, x24, w27, sxtw
  4068a4:	17fffff6 	b	40687c <z_cbvprintf_impl+0x5e4>
			} else if (length_mod == LENGTH_H) {
  4068a8:	7100083f 	cmp	w1, #0x2
  4068ac:	54fffb61 	b.ne	406818 <z_cbvprintf_impl+0x580>  // b.any
				value->sint = (short)value->sint;
  4068b0:	93403c00 	sxth	x0, w0
  4068b4:	17ffffd8 	b	406814 <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_UINT) {
  4068b8:	7100081f 	cmp	w0, #0x2
  4068bc:	540008c1 	b.ne	4069d4 <z_cbvprintf_impl+0x73c>  // b.any
			switch (length_mod) {
  4068c0:	51000c22 	sub	w2, w1, #0x3
  4068c4:	7100105f 	cmp	w2, #0x4
  4068c8:	540000e8 	b.hi	4068e4 <z_cbvprintf_impl+0x64c>  // b.pmore
  4068cc:	b0000080 	adrp	x0, 417000 <z_abort_timeout+0x38>
  4068d0:	9139d000 	add	x0, x0, #0xe74
  4068d4:	38624800 	ldrb	w0, [x0, w2, uxtw]
  4068d8:	10000062 	adr	x2, 4068e4 <z_cbvprintf_impl+0x64c>
  4068dc:	8b208840 	add	x0, x2, w0, sxtb #2
  4068e0:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
  4068e4:	37f8019b 	tbnz	w27, #31, 406914 <z_cbvprintf_impl+0x67c>
  4068e8:	91002f82 	add	x2, x28, #0xb
  4068ec:	2a1b03e3 	mov	w3, w27
  4068f0:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4068f4:	b9400380 	ldr	w0, [x28]
  4068f8:	f9004be0 	str	x0, [sp, #144]
				break;
  4068fc:	2a0303fb 	mov	w27, w3
  406900:	aa0203fc 	mov	x28, x2
			if (length_mod == LENGTH_HH) {
  406904:	7100043f 	cmp	w1, #0x1
  406908:	540005e1 	b.ne	4069c4 <z_cbvprintf_impl+0x72c>  // b.any
				value->uint = (unsigned char)value->uint;
  40690c:	92401c00 	and	x0, x0, #0xff
  406910:	17ffffc1 	b	406814 <z_cbvprintf_impl+0x57c>
				value->uint = va_arg(ap, unsigned int);
  406914:	11002363 	add	w3, w27, #0x8
  406918:	7100007f 	cmp	w3, #0x0
  40691c:	5400008d 	b.le	40692c <z_cbvprintf_impl+0x694>
  406920:	91002f82 	add	x2, x28, #0xb
  406924:	927df042 	and	x2, x2, #0xfffffffffffffff8
  406928:	17fffff3 	b	4068f4 <z_cbvprintf_impl+0x65c>
  40692c:	aa1c03e2 	mov	x2, x28
  406930:	8b3bc31c 	add	x28, x24, w27, sxtw
  406934:	17fffff0 	b	4068f4 <z_cbvprintf_impl+0x65c>
				if ((!WCHAR_IS_SIGNED)
  406938:	39428fe0 	ldrb	w0, [sp, #163]
  40693c:	71018c1f 	cmp	w0, #0x63
  406940:	54000ac1 	b.ne	406a98 <z_cbvprintf_impl+0x800>  // b.any
					value->uint = (wchar_t)va_arg(ap,
  406944:	37f8011b 	tbnz	w27, #31, 406964 <z_cbvprintf_impl+0x6cc>
  406948:	91002f80 	add	x0, x28, #0xb
  40694c:	2a1b03e2 	mov	w2, w27
  406950:	927df000 	and	x0, x0, #0xfffffffffffffff8
  406954:	b9400383 	ldr	w3, [x28]
			value->ptr = va_arg(ap, void *);
  406958:	2a0203fb 	mov	w27, w2
  40695c:	f9004be3 	str	x3, [sp, #144]
  406960:	1400003e 	b	406a58 <z_cbvprintf_impl+0x7c0>
					value->uint = (wchar_t)va_arg(ap,
  406964:	11002362 	add	w2, w27, #0x8
  406968:	7100005f 	cmp	w2, #0x0
  40696c:	5400008d 	b.le	40697c <z_cbvprintf_impl+0x6e4>
  406970:	91002f80 	add	x0, x28, #0xb
  406974:	927df000 	and	x0, x0, #0xfffffffffffffff8
  406978:	17fffff7 	b	406954 <z_cbvprintf_impl+0x6bc>
  40697c:	aa1c03e0 	mov	x0, x28
  406980:	8b3bc31c 	add	x28, x24, w27, sxtw
  406984:	17fffff4 	b	406954 <z_cbvprintf_impl+0x6bc>
					(uint_value_type)va_arg(ap, size_t);
  406988:	37f800db 	tbnz	w27, #31, 4069a0 <z_cbvprintf_impl+0x708>
  40698c:	91003f82 	add	x2, x28, #0xf
  406990:	2a1b03e3 	mov	w3, w27
  406994:	927df042 	and	x2, x2, #0xfffffffffffffff8
  406998:	f9400380 	ldr	x0, [x28]
  40699c:	17ffffd7 	b	4068f8 <z_cbvprintf_impl+0x660>
  4069a0:	11002363 	add	w3, w27, #0x8
  4069a4:	7100007f 	cmp	w3, #0x0
  4069a8:	5400008d 	b.le	4069b8 <z_cbvprintf_impl+0x720>
  4069ac:	91003f82 	add	x2, x28, #0xf
  4069b0:	927df042 	and	x2, x2, #0xfffffffffffffff8
  4069b4:	17fffff9 	b	406998 <z_cbvprintf_impl+0x700>
  4069b8:	aa1c03e2 	mov	x2, x28
  4069bc:	8b3bc31c 	add	x28, x24, w27, sxtw
  4069c0:	17fffff6 	b	406998 <z_cbvprintf_impl+0x700>
			} else if (length_mod == LENGTH_H) {
  4069c4:	7100083f 	cmp	w1, #0x2
  4069c8:	54fff281 	b.ne	406818 <z_cbvprintf_impl+0x580>  // b.any
				value->uint = (unsigned short)value->uint;
  4069cc:	92403c00 	and	x0, x0, #0xffff
  4069d0:	17ffff91 	b	406814 <z_cbvprintf_impl+0x57c>
		} else if (specifier_cat == SPECIFIER_FP) {
  4069d4:	7100101f 	cmp	w0, #0x4
  4069d8:	540005c1 	b.ne	406a90 <z_cbvprintf_impl+0x7f8>  // b.any
				value->ldbl = va_arg(ap, long double);
  4069dc:	b94067e0 	ldr	w0, [sp, #100]
			if (length_mod == LENGTH_UPPER_L) {
  4069e0:	7100203f 	cmp	w1, #0x8
  4069e4:	540002c1 	b.ne	406a3c <z_cbvprintf_impl+0x7a4>  // b.any
				value->ldbl = va_arg(ap, long double);
  4069e8:	37f80120 	tbnz	w0, #31, 406a0c <z_cbvprintf_impl+0x774>
  4069ec:	91003f80 	add	x0, x28, #0xf
  4069f0:	b94067e2 	ldr	w2, [sp, #100]
  4069f4:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  4069f8:	9100401c 	add	x28, x0, #0x10
  4069fc:	3dc00000 	ldr	q0, [x0]
  406a00:	b90067e2 	str	w2, [sp, #100]
  406a04:	3d8027e0 	str	q0, [sp, #144]
  406a08:	17ffff84 	b	406818 <z_cbvprintf_impl+0x580>
  406a0c:	b94067e0 	ldr	w0, [sp, #100]
  406a10:	11004002 	add	w2, w0, #0x10
  406a14:	7100005f 	cmp	w2, #0x0
  406a18:	540000ad 	b.le	406a2c <z_cbvprintf_impl+0x794>
  406a1c:	91003f80 	add	x0, x28, #0xf
  406a20:	927cec00 	and	x0, x0, #0xfffffffffffffff0
  406a24:	9100401c 	add	x28, x0, #0x10
  406a28:	17fffff5 	b	4069fc <z_cbvprintf_impl+0x764>
  406a2c:	f9403be3 	ldr	x3, [sp, #112]
  406a30:	b94067e0 	ldr	w0, [sp, #100]
  406a34:	8b20c060 	add	x0, x3, w0, sxtw
  406a38:	17fffff1 	b	4069fc <z_cbvprintf_impl+0x764>
				value->dbl = va_arg(ap, double);
  406a3c:	37f80120 	tbnz	w0, #31, 406a60 <z_cbvprintf_impl+0x7c8>
  406a40:	91003f80 	add	x0, x28, #0xf
  406a44:	b94067e2 	ldr	w2, [sp, #100]
  406a48:	927df000 	and	x0, x0, #0xfffffffffffffff8
  406a4c:	fd400380 	ldr	d0, [x28]
  406a50:	b90067e2 	str	w2, [sp, #100]
  406a54:	fd004be0 	str	d0, [sp, #144]
			value->ptr = va_arg(ap, void *);
  406a58:	aa0003fc 	mov	x28, x0
  406a5c:	17ffff6f 	b	406818 <z_cbvprintf_impl+0x580>
				value->dbl = va_arg(ap, double);
  406a60:	b94067e0 	ldr	w0, [sp, #100]
  406a64:	11004002 	add	w2, w0, #0x10
  406a68:	7100005f 	cmp	w2, #0x0
  406a6c:	5400008d 	b.le	406a7c <z_cbvprintf_impl+0x7e4>
  406a70:	91003f80 	add	x0, x28, #0xf
  406a74:	927df000 	and	x0, x0, #0xfffffffffffffff8
  406a78:	17fffff5 	b	406a4c <z_cbvprintf_impl+0x7b4>
  406a7c:	f9403be4 	ldr	x4, [sp, #112]
  406a80:	aa1c03e0 	mov	x0, x28
  406a84:	b94067e3 	ldr	w3, [sp, #100]
  406a88:	8b23c09c 	add	x28, x4, w3, sxtw
  406a8c:	17fffff0 	b	406a4c <z_cbvprintf_impl+0x7b4>
		} else if (specifier_cat == SPECIFIER_PTR) {
  406a90:	71000c1f 	cmp	w0, #0x3
  406a94:	54ffec21 	b.ne	406818 <z_cbvprintf_impl+0x580>  // b.any
			value->ptr = va_arg(ap, void *);
  406a98:	37f800db 	tbnz	w27, #31, 406ab0 <z_cbvprintf_impl+0x818>
  406a9c:	91003f80 	add	x0, x28, #0xf
  406aa0:	2a1b03e2 	mov	w2, w27
  406aa4:	927df000 	and	x0, x0, #0xfffffffffffffff8
  406aa8:	f9400383 	ldr	x3, [x28]
  406aac:	17ffffab 	b	406958 <z_cbvprintf_impl+0x6c0>
  406ab0:	11002362 	add	w2, w27, #0x8
  406ab4:	7100005f 	cmp	w2, #0x0
  406ab8:	5400008d 	b.le	406ac8 <z_cbvprintf_impl+0x830>
  406abc:	91003f80 	add	x0, x28, #0xf
  406ac0:	927df000 	and	x0, x0, #0xfffffffffffffff8
  406ac4:	17fffff9 	b	406aa8 <z_cbvprintf_impl+0x810>
  406ac8:	aa1c03e0 	mov	x0, x28
  406acc:	8b3bc31c 	add	x28, x24, w27, sxtw
  406ad0:	17fffff6 	b	406aa8 <z_cbvprintf_impl+0x810>
		switch (conv->specifier) {
  406ad4:	39428fe0 	ldrb	w0, [sp, #163]
  406ad8:	7101e01f 	cmp	w0, #0x78
  406adc:	54ffeb28 	b.hi	406840 <z_cbvprintf_impl+0x5a8>  // b.pmore
  406ae0:	7101881f 	cmp	w0, #0x62
  406ae4:	540000e8 	b.hi	406b00 <z_cbvprintf_impl+0x868>  // b.pmore
  406ae8:	7100941f 	cmp	w0, #0x25
  406aec:	54ffc220 	b.eq	406330 <z_cbvprintf_impl+0x98>  // b.none
  406af0:	7101601f 	cmp	w0, #0x58
  406af4:	54ffea61 	b.ne	406840 <z_cbvprintf_impl+0x5a8>  // b.any
  406af8:	52800006 	mov	w6, #0x0                   	// #0
  406afc:	14000043 	b	406c08 <z_cbvprintf_impl+0x970>
  406b00:	51018c00 	sub	w0, w0, #0x63
  406b04:	7100541f 	cmp	w0, #0x15
  406b08:	54ffe9c8 	b.hi	406840 <z_cbvprintf_impl+0x5a8>  // b.pmore
  406b0c:	b0000082 	adrp	x2, 417000 <z_abort_timeout+0x38>
  406b10:	9139f042 	add	x2, x2, #0xe7c
  406b14:	78605842 	ldrh	w2, [x2, w0, uxtw #1]
  406b18:	10000060 	adr	x0, 406b24 <z_cbvprintf_impl+0x88c>
  406b1c:	8b22a802 	add	x2, x0, w2, sxth #2
  406b20:	d61f0040 	br	x2
			bps = (const char *)value->ptr;
  406b24:	f9404bf5 	ldr	x21, [sp, #144]
			if (precision >= 0) {
  406b28:	37f80497 	tbnz	w23, #31, 406bb8 <z_cbvprintf_impl+0x920>
				len = strnlen(bps, precision);
  406b2c:	93407ee1 	sxtw	x1, w23
  406b30:	aa1503e0 	mov	x0, x21
  406b34:	97ffea1f 	bl	4013b0 <strnlen@plt>
			bpe = bps + len;
  406b38:	8b0002b7 	add	x23, x21, x0
		char sign = 0;
  406b3c:	52800006 	mov	w6, #0x0                   	// #0
		if (bps == NULL) {
  406b40:	b4ffe815 	cbz	x21, 406840 <z_cbvprintf_impl+0x5a8>
		size_t nj_len = (bpe - bps);
  406b44:	cb1502e0 	sub	x0, x23, x21
		if (sign != 0) {
  406b48:	34000046 	cbz	w6, 406b50 <z_cbvprintf_impl+0x8b8>
			nj_len += 1U;
  406b4c:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
  406b50:	39428be2 	ldrb	w2, [sp, #162]
  406b54:	36200ce2 	tbz	w2, #4, 406cf0 <z_cbvprintf_impl+0xa58>
			nj_len += 2U;
  406b58:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
  406b5c:	b980a7e1 	ldrsw	x1, [sp, #164]
  406b60:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
  406b64:	36300062 	tbz	w2, #6, 406b70 <z_cbvprintf_impl+0x8d8>
			nj_len += conv->pad0_pre_exp;
  406b68:	b980abe1 	ldrsw	x1, [sp, #168]
  406b6c:	8b010000 	add	x0, x0, x1
		if (width > 0) {
  406b70:	710002df 	cmp	w22, #0x0
  406b74:	54000dad 	b.le	406d28 <z_cbvprintf_impl+0xa90>
			width -= (int)nj_len;
  406b78:	4b0002d6 	sub	w22, w22, w0
			if (!conv->flag_dash) {
  406b7c:	f94053e0 	ldr	x0, [sp, #160]
  406b80:	721e001f 	tst	w0, #0x4
  406b84:	54000d21 	b.ne	406d28 <z_cbvprintf_impl+0xa90>  // b.any
				if (conv->flag_zero) {
  406b88:	794143e0 	ldrh	w0, [sp, #160]
  406b8c:	36301280 	tbz	w0, #6, 406ddc <z_cbvprintf_impl+0xb44>
					if (sign != 0) {
  406b90:	340012a6 	cbz	w6, 406de4 <z_cbvprintf_impl+0xb4c>
						OUTC(sign);
  406b94:	aa1a03e1 	mov	x1, x26
  406b98:	2a0603e0 	mov	w0, w6
  406b9c:	d63f0320 	blr	x25
  406ba0:	37ffbb20 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  406ba4:	91000673 	add	x19, x19, #0x1
					pad = '0';
  406ba8:	52800602 	mov	w2, #0x30                  	// #48
						OUTC(sign);
  406bac:	52800006 	mov	w6, #0x0                   	// #0
					pad = '0';
  406bb0:	2a1603e0 	mov	w0, w22
  406bb4:	1400005a 	b	406d1c <z_cbvprintf_impl+0xa84>
				len = strlen(bps);
  406bb8:	aa1503e0 	mov	x0, x21
  406bbc:	97ffe9ed 	bl	401370 <strlen@plt>
  406bc0:	17ffffde 	b	406b38 <z_cbvprintf_impl+0x8a0>
			bps = buf;
  406bc4:	9102c3f5 	add	x21, sp, #0xb0
			bpe = buf + 1;
  406bc8:	9102c7f7 	add	x23, sp, #0xb1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
  406bcc:	f9404be0 	ldr	x0, [sp, #144]
  406bd0:	3902c3e0 	strb	w0, [sp, #176]
			break;
  406bd4:	52800006 	mov	w6, #0x0                   	// #0
  406bd8:	17ffffdb 	b	406b44 <z_cbvprintf_impl+0x8ac>
			if (conv->flag_plus) {
  406bdc:	794143e0 	ldrh	w0, [sp, #160]
			} else if (conv->flag_space) {
  406be0:	d3441006 	ubfx	x6, x0, #4, #1
  406be4:	f27d001f 	tst	x0, #0x8
  406be8:	52800560 	mov	w0, #0x2b                  	// #43
  406bec:	531b68c6 	lsl	w6, w6, #5
  406bf0:	1a8000c6 	csel	w6, w6, w0, eq  // eq = none
			sint = value->sint;
  406bf4:	f9404be0 	ldr	x0, [sp, #144]
			if (sint < 0) {
  406bf8:	b6f80080 	tbz	x0, #63, 406c08 <z_cbvprintf_impl+0x970>
				value->uint = (uint_value_type)-sint;
  406bfc:	cb0003e0 	neg	x0, x0
				sign = '-';
  406c00:	528005a6 	mov	w6, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
  406c04:	f9004be0 	str	x0, [sp, #144]
			bps = encode_uint(value->uint, conv, buf, bpe);
  406c08:	f94037e3 	ldr	x3, [sp, #104]
  406c0c:	9102c3e2 	add	x2, sp, #0xb0
  406c10:	f9404be0 	ldr	x0, [sp, #144]
  406c14:	910283e1 	add	x1, sp, #0xa0
  406c18:	b9007be6 	str	w6, [sp, #120]
  406c1c:	97fffd60 	bl	40619c <encode_uint>
  406c20:	aa0003f5 	mov	x21, x0
  406c24:	b9407be6 	ldr	w6, [sp, #120]
			if (precision >= 0) {
  406c28:	37f80157 	tbnz	w23, #31, 406c50 <z_cbvprintf_impl+0x9b8>
				size_t len = bpe - bps;
  406c2c:	f94037e0 	ldr	x0, [sp, #104]
				conv->flag_zero = false;
  406c30:	794143e1 	ldrh	w1, [sp, #160]
				size_t len = bpe - bps;
  406c34:	cb150000 	sub	x0, x0, x21
				conv->flag_zero = false;
  406c38:	12197821 	and	w1, w1, #0xffffffbf
  406c3c:	790143e1 	strh	w1, [sp, #160]
				if (len < (size_t)precision) {
  406c40:	eb37c01f 	cmp	x0, w23, sxtw
  406c44:	54000062 	b.cs	406c50 <z_cbvprintf_impl+0x9b8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
  406c48:	4b0002e0 	sub	w0, w23, w0
  406c4c:	b900a7e0 	str	w0, [sp, #164]
		const char *bpe = buf + sizeof(buf);
  406c50:	f94037f7 	ldr	x23, [sp, #104]
  406c54:	17ffffbb 	b	406b40 <z_cbvprintf_impl+0x8a8>
			if (value->ptr != NULL) {
  406c58:	f9404be0 	ldr	x0, [sp, #144]
  406c5c:	b4000400 	cbz	x0, 406cdc <z_cbvprintf_impl+0xa44>
				bps = encode_uint((uintptr_t)value->ptr, conv,
  406c60:	f94037e3 	ldr	x3, [sp, #104]
  406c64:	910283e1 	add	x1, sp, #0xa0
  406c68:	9102c3e2 	add	x2, sp, #0xb0
  406c6c:	97fffd4c 	bl	40619c <encode_uint>
  406c70:	aa0003f5 	mov	x21, x0
				conv->altform_0c = true;
  406c74:	794147e0 	ldrh	w0, [sp, #162]
  406c78:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
  406c7c:	52800006 	mov	w6, #0x0                   	// #0
				conv->altform_0c = true;
  406c80:	0a010000 	and	w0, w0, w1
  406c84:	528f0201 	mov	w1, #0x7810                	// #30736
  406c88:	2a010000 	orr	w0, w0, w1
  406c8c:	790147e0 	strh	w0, [sp, #162]
				goto prec_int_pad0;
  406c90:	17ffffe6 	b	406c28 <z_cbvprintf_impl+0x990>
				store_count(conv, value->ptr, count);
  406c94:	93407e60 	sxtw	x0, w19
  406c98:	f9404be2 	ldr	x2, [sp, #144]
	switch ((enum length_mod_enum)conv->length_mod) {
  406c9c:	71001c3f 	cmp	w1, #0x7
  406ca0:	54ffdd08 	b.hi	406840 <z_cbvprintf_impl+0x5a8>  // b.pmore
  406ca4:	b0000083 	adrp	x3, 417000 <z_abort_timeout+0x38>
  406ca8:	913aa063 	add	x3, x3, #0xea8
  406cac:	38614863 	ldrb	w3, [x3, w1, uxtw]
  406cb0:	10000061 	adr	x1, 406cbc <z_cbvprintf_impl+0xa24>
  406cb4:	8b238823 	add	x3, x1, w3, sxtb #2
  406cb8:	d61f0060 	br	x3
		*(int *)dp = count;
  406cbc:	b9000040 	str	w0, [x2]
		break;
  406cc0:	17fffee0 	b	406840 <z_cbvprintf_impl+0x5a8>
		*(signed char *)dp = (signed char)count;
  406cc4:	39000053 	strb	w19, [x2]
		break;
  406cc8:	17fffede 	b	406840 <z_cbvprintf_impl+0x5a8>
		*(short *)dp = (short)count;
  406ccc:	79000053 	strh	w19, [x2]
		break;
  406cd0:	17fffedc 	b	406840 <z_cbvprintf_impl+0x5a8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
  406cd4:	f9000040 	str	x0, [x2]
		break;
  406cd8:	17fffeda 	b	406840 <z_cbvprintf_impl+0x5a8>
			bps = "(nil)";
  406cdc:	d0000095 	adrp	x21, 418000 <table.0+0x1d8>
			bpe = bps + 5;
  406ce0:	d0000097 	adrp	x23, 418000 <table.0+0x1d8>
			bps = "(nil)";
  406ce4:	91221ab5 	add	x21, x21, #0x886
			bpe = bps + 5;
  406ce8:	91222ef7 	add	x23, x23, #0x88b
  406cec:	17ffffba 	b	406bd4 <z_cbvprintf_impl+0x93c>
		} else if (conv->altform_0) {
  406cf0:	361ff362 	tbz	w2, #3, 406b5c <z_cbvprintf_impl+0x8c4>
			nj_len += 1U;
  406cf4:	91000400 	add	x0, x0, #0x1
  406cf8:	17ffff99 	b	406b5c <z_cbvprintf_impl+0x8c4>
  406cfc:	290f1be2 	stp	w2, w6, [sp, #120]
					OUTC(pad);
  406d00:	aa1a03e1 	mov	x1, x26
  406d04:	2a0203e0 	mov	w0, w2
  406d08:	d63f0320 	blr	x25
  406d0c:	37ffafc0 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  406d10:	294f1be2 	ldp	w2, w6, [sp, #120]
  406d14:	91000673 	add	x19, x19, #0x1
				while (width-- > 0) {
  406d18:	2a1603e0 	mov	w0, w22
  406d1c:	510006d6 	sub	w22, w22, #0x1
  406d20:	7100001f 	cmp	w0, #0x0
  406d24:	54fffecc 	b.gt	406cfc <z_cbvprintf_impl+0xa64>
		if (sign != 0) {
  406d28:	340000c6 	cbz	w6, 406d40 <z_cbvprintf_impl+0xaa8>
			OUTC(sign);
  406d2c:	aa1a03e1 	mov	x1, x26
  406d30:	2a0603e0 	mov	w0, w6
  406d34:	d63f0320 	blr	x25
  406d38:	37ffae60 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  406d3c:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c | conv->altform_0) {
  406d40:	f94053e0 	ldr	x0, [sp, #160]
  406d44:	d3545001 	ubfx	x1, x0, #20, #1
  406d48:	d3534c00 	ubfx	x0, x0, #19, #1
  406d4c:	2a000020 	orr	w0, w1, w0
  406d50:	360000c0 	tbz	w0, #0, 406d68 <z_cbvprintf_impl+0xad0>
				OUTC('0');
  406d54:	aa1a03e1 	mov	x1, x26
  406d58:	52800600 	mov	w0, #0x30                  	// #48
  406d5c:	d63f0320 	blr	x25
  406d60:	37ffad20 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  406d64:	91000673 	add	x19, x19, #0x1
			if (conv->altform_0c) {
  406d68:	39428be0 	ldrb	w0, [sp, #162]
  406d6c:	362000c0 	tbz	w0, #4, 406d84 <z_cbvprintf_impl+0xaec>
				OUTC(conv->specifier);
  406d70:	39428fe0 	ldrb	w0, [sp, #163]
  406d74:	aa1a03e1 	mov	x1, x26
  406d78:	d63f0320 	blr	x25
  406d7c:	37ffac40 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  406d80:	91000673 	add	x19, x19, #0x1
			while (pad_len-- > 0) {
  406d84:	b940a7e2 	ldr	w2, [sp, #164]
  406d88:	0b130042 	add	w2, w2, w19
  406d8c:	4b130040 	sub	w0, w2, w19
  406d90:	7100001f 	cmp	w0, #0x0
  406d94:	540002cc 	b.gt	406dec <z_cbvprintf_impl+0xb54>
			OUTS(bps, bpe);
  406d98:	aa1703e3 	mov	x3, x23
  406d9c:	aa1503e2 	mov	x2, x21
  406da0:	aa1a03e1 	mov	x1, x26
  406da4:	aa1903e0 	mov	x0, x25
  406da8:	97fffccd 	bl	4060dc <outs>
  406dac:	37ffaac0 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  406db0:	8b20c273 	add	x19, x19, w0, sxtw
		while (width > 0) {
  406db4:	0b1302d6 	add	w22, w22, w19
  406db8:	4b1302c0 	sub	w0, w22, w19
  406dbc:	7100001f 	cmp	w0, #0x0
  406dc0:	54ffd40d 	b.le	406840 <z_cbvprintf_impl+0x5a8>
			OUTC(' ');
  406dc4:	aa1a03e1 	mov	x1, x26
  406dc8:	52800400 	mov	w0, #0x20                  	// #32
  406dcc:	d63f0320 	blr	x25
  406dd0:	37ffa9a0 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  406dd4:	91000673 	add	x19, x19, #0x1
			--width;
  406dd8:	17fffff8 	b	406db8 <z_cbvprintf_impl+0xb20>
				char pad = ' ';
  406ddc:	52800402 	mov	w2, #0x20                  	// #32
  406de0:	17ffff74 	b	406bb0 <z_cbvprintf_impl+0x918>
					pad = '0';
  406de4:	52800602 	mov	w2, #0x30                  	// #48
  406de8:	17ffff72 	b	406bb0 <z_cbvprintf_impl+0x918>
  406dec:	b9007be2 	str	w2, [sp, #120]
				OUTC('0');
  406df0:	aa1a03e1 	mov	x1, x26
  406df4:	52800600 	mov	w0, #0x30                  	// #48
  406df8:	d63f0320 	blr	x25
  406dfc:	37ffa840 	tbnz	w0, #31, 406304 <z_cbvprintf_impl+0x6c>
  406e00:	b9407be2 	ldr	w2, [sp, #120]
  406e04:	91000673 	add	x19, x19, #0x1
  406e08:	17ffffe1 	b	406d8c <z_cbvprintf_impl+0xaf4>
}
  406e0c:	a94153f3 	ldp	x19, x20, [sp, #16]
  406e10:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406e14:	a94363f7 	ldp	x23, x24, [sp, #48]
  406e18:	a9446bf9 	ldp	x25, x26, [sp, #64]
  406e1c:	a94573fb 	ldp	x27, x28, [sp, #80]
  406e20:	a8cd7bfd 	ldp	x29, x30, [sp], #208
  406e24:	d65f03c0 	ret

0000000000406e28 <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
  406e28:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  406e2c:	910003fd 	mov	x29, sp
  406e30:	a90e8be1 	stp	x1, x2, [sp, #232]
  406e34:	f0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  406e38:	f9475c21 	ldr	x1, [x1, #3768]
  406e3c:	3d801be0 	str	q0, [sp, #96]
  406e40:	3d801fe1 	str	q1, [sp, #112]
  406e44:	3d8023e2 	str	q2, [sp, #128]
  406e48:	3d8027e3 	str	q3, [sp, #144]
  406e4c:	3d802be4 	str	q4, [sp, #160]
  406e50:	3d802fe5 	str	q5, [sp, #176]
  406e54:	3d8033e6 	str	q6, [sp, #192]
  406e58:	3d8037e7 	str	q7, [sp, #208]
  406e5c:	a90f93e3 	stp	x3, x4, [sp, #248]
  406e60:	a9109be5 	stp	x5, x6, [sp, #264]
  406e64:	f9008fe7 	str	x7, [sp, #280]
  406e68:	f9400022 	ldr	x2, [x1]
  406e6c:	f9002fe2 	str	x2, [sp, #88]
  406e70:	d2800002 	mov	x2, #0x0                   	// #0
	va_list ap;

	va_start(ap, fmt);
  406e74:	910483e1 	add	x1, sp, #0x120
  406e78:	a90387e1 	stp	x1, x1, [sp, #56]
  406e7c:	910383e1 	add	x1, sp, #0xe0

	vprintk(fmt, ap);
  406e80:	9100e3e2 	add	x2, sp, #0x38
	va_start(ap, fmt);
  406e84:	f90027e1 	str	x1, [sp, #72]
  406e88:	128006e1 	mov	w1, #0xffffffc8            	// #-56
  406e8c:	b90053e1 	str	w1, [sp, #80]
  406e90:	12800fe1 	mov	w1, #0xffffff80            	// #-128
  406e94:	b90057e1 	str	w1, [sp, #84]
	vprintk(fmt, ap);
  406e98:	910043e1 	add	x1, sp, #0x10
  406e9c:	ad400440 	ldp	q0, q1, [x2]
  406ea0:	ad000420 	stp	q0, q1, [x1]
  406ea4:	97fffa04 	bl	4056b4 <vprintk>

	va_end(ap);
}
  406ea8:	f0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  406eac:	f9475c00 	ldr	x0, [x0, #3768]
  406eb0:	f9402fe2 	ldr	x2, [sp, #88]
  406eb4:	f9400001 	ldr	x1, [x0]
  406eb8:	eb010042 	subs	x2, x2, x1
  406ebc:	d2800001 	mov	x1, #0x0                   	// #0
  406ec0:	54000040 	b.eq	406ec8 <assert_print+0xa0>  // b.none
  406ec4:	97ffe997 	bl	401520 <__stack_chk_fail@plt>
  406ec8:	a8d27bfd 	ldp	x29, x30, [sp], #288
  406ecc:	d65f03c0 	ret

0000000000406ed0 <assert_post_action>:
{
  406ed0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	k_panic();
  406ed4:	52800562 	mov	w2, #0x2b                  	// #43
  406ed8:	d0000081 	adrp	x1, 418000 <table.0+0x1d8>
{
  406edc:	910003fd 	mov	x29, sp
	k_panic();
  406ee0:	91223021 	add	x1, x1, #0x88c
  406ee4:	d0000080 	adrp	x0, 418000 <table.0+0x1d8>
  406ee8:	9117d000 	add	x0, x0, #0x5f4
  406eec:	97ffffcf 	bl	406e28 <assert_print>
}
  406ef0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	k_panic();
  406ef4:	d2800001 	mov	x1, #0x0                   	// #0
  406ef8:	52800080 	mov	w0, #0x4                   	// #4
  406efc:	14002987 	b	411518 <z_fatal_error>

0000000000406f00 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_EXPERIMENTAL, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
  406f00:	d65f03c0 	ret

0000000000406f04 <dummy_timestamp>:
static void msg_process(union log_msg_generic *msg);

static log_timestamp_t dummy_timestamp(void)
{
	return 0;
}
  406f04:	52800000 	mov	w0, #0x0                   	// #0
  406f08:	d65f03c0 	ret

0000000000406f0c <default_get_timestamp>:

extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
  406f0c:	1400162c 	b	40c7bc <sys_clock_cycle_get_32>

0000000000406f10 <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
  406f10:	f9400400 	ldr	x0, [x0, #8]
}
  406f14:	39402400 	ldrb	w0, [x0, #9]
  406f18:	d65f03c0 	ret

0000000000406f1c <log_backend_is_ready>:
	if (backend->api->is_ready != NULL) {
  406f1c:	f9400001 	ldr	x1, [x0]
  406f20:	f9401021 	ldr	x1, [x1, #32]
  406f24:	b4000061 	cbz	x1, 406f30 <log_backend_is_ready+0x14>
		return backend->api->is_ready(backend);
  406f28:	aa0103f0 	mov	x16, x1
  406f2c:	d61f0200 	br	x16
}
  406f30:	52800000 	mov	w0, #0x0                   	// #0
  406f34:	d65f03c0 	ret

0000000000406f38 <z_log_init.isra.0>:
	}

	return mask;
}

static uint32_t z_log_init(bool blocking, bool can_sleep)
  406f38:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  406f3c:	910003fd 	mov	x29, sp
  406f40:	a9025bf5 	stp	x21, x22, [sp, #32]
	STRUCT_SECTION_COUNT(log_backend, &cnt);
  406f44:	f0000156 	adrp	x22, 431000 <__FRAME_END__+0x10804>
  406f48:	f0000155 	adrp	x21, 431000 <__FRAME_END__+0x10804>
  406f4c:	f947fed6 	ldr	x22, [x22, #4088]
  406f50:	a90153f3 	stp	x19, x20, [sp, #16]
  406f54:	f947c2b3 	ldr	x19, [x21, #3968]
  406f58:	a9046bf9 	stp	x25, x26, [sp, #64]
  406f5c:	12001c19 	and	w25, w0, #0xff
  406f60:	cb1302c0 	sub	x0, x22, x19
  406f64:	a90363f7 	stp	x23, x24, [sp, #48]
  406f68:	d345fc00 	lsr	x0, x0, #5

	if (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY)) {
		return 0;
	}

	__ASSERT_NO_MSG(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
  406f6c:	7100241f 	cmp	w0, #0x9
  406f70:	54000249 	b.ls	406fb8 <z_log_init.isra.0+0x80>  // b.plast
  406f74:	d0000093 	adrp	x19, 418000 <table.0+0x1d8>
  406f78:	9122be73 	add	x19, x19, #0x8af
  406f7c:	aa1303e2 	mov	x2, x19
  406f80:	52802323 	mov	w3, #0x119                 	// #281
  406f84:	d0000081 	adrp	x1, 418000 <table.0+0x1d8>
  406f88:	d0000080 	adrp	x0, 418000 <table.0+0x1d8>
  406f8c:	91237021 	add	x1, x1, #0x8dc
  406f90:	91178000 	add	x0, x0, #0x5e0
  406f94:	97ffffa5 	bl	406e28 <assert_print>
  406f98:	aa1303e0 	mov	x0, x19
  406f9c:	52802321 	mov	w1, #0x119                 	// #281
  406fa0:	97ffffcc 	bl	406ed0 <assert_post_action>
  406fa4:	52802322 	mov	w2, #0x119                 	// #281
		z_log_links_initiate();
	}


	/* Assign ids to backends. */
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  406fa8:	d0000080 	adrp	x0, 418000 <table.0+0x1d8>
  406fac:	aa1303e1 	mov	x1, x19
  406fb0:	91187800 	add	x0, x0, #0x61e
  406fb4:	940009b9 	bl	409698 <posix_print_error_and_exit>
  406fb8:	12001c37 	and	w23, w1, #0xff
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  406fbc:	d2800020 	mov	x0, #0x1                   	// #1
  406fc0:	b0000161 	adrp	x1, 433000 <obj_0x28+0x18>
  406fc4:	9129c021 	add	x1, x1, #0xa70
  406fc8:	97ffea22 	bl	401850 <__aarch64_ldadd8_acq_rel>
	if (atomic_inc(&initialized) != 0) {
  406fcc:	b40005c0 	cbz	x0, 407084 <z_log_init.isra.0+0x14c>
			}
		}
	}

	return mask;
}
  406fd0:	a94153f3 	ldp	x19, x20, [sp, #16]
  406fd4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  406fd8:	a94363f7 	ldp	x23, x24, [sp, #48]
  406fdc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  406fe0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  406fe4:	d65f03c0 	ret
		if (backend->autostart) {
  406fe8:	39406260 	ldrb	w0, [x19, #24]
  406fec:	340001e0 	cbz	w0, 407028 <z_log_init.isra.0+0xf0>
	if (backend->api->init) {
  406ff0:	f9400260 	ldr	x0, [x19]
  406ff4:	f9400c01 	ldr	x1, [x0, #24]
  406ff8:	b4000061 	cbz	x1, 407004 <z_log_init.isra.0+0xcc>
		backend->api->init(backend);
  406ffc:	aa1303e0 	mov	x0, x19
  407000:	d63f0020 	blr	x1
			if (log_backend_is_ready(backend) == 0) {
  407004:	aa1303e0 	mov	x0, x19
  407008:	97ffffc5 	bl	406f1c <log_backend_is_ready>
  40700c:	35000360 	cbnz	w0, 407078 <z_log_init.isra.0+0x140>
				log_backend_enable(backend,
  407010:	f9400660 	ldr	x0, [x19, #8]
  407014:	52800082 	mov	w2, #0x4                   	// #4
  407018:	f9400001 	ldr	x1, [x0]
  40701c:	aa1303e0 	mov	x0, x19
  407020:	94000125 	bl	4074b4 <log_backend_enable>
			i++;
  407024:	11000718 	add	w24, w24, #0x1
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407028:	91008273 	add	x19, x19, #0x20
  40702c:	eb16027f 	cmp	x19, x22
  407030:	54000329 	b.ls	407094 <z_log_init.isra.0+0x15c>  // b.plast
  407034:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  407038:	9122be73 	add	x19, x19, #0x8af
  40703c:	aa1303e2 	mov	x2, x19
  407040:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407044:	91240021 	add	x1, x1, #0x900
  407048:	528024c3 	mov	w3, #0x126                 	// #294
  40704c:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407050:	91178000 	add	x0, x0, #0x5e0
  407054:	97ffff75 	bl	406e28 <assert_print>
  407058:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  40705c:	91248400 	add	x0, x0, #0x921
  407060:	97ffff72 	bl	406e28 <assert_print>
  407064:	aa1303e0 	mov	x0, x19
  407068:	528024c1 	mov	w1, #0x126                 	// #294
  40706c:	97ffff99 	bl	406ed0 <assert_post_action>
  407070:	528024c2 	mov	w2, #0x126                 	// #294
  407074:	17ffffcd 	b	406fa8 <z_log_init.isra.0+0x70>
				mask |= BIT(i);
  407078:	9ad82340 	lsl	x0, x26, x24
  40707c:	2a000294 	orr	w20, w20, w0
  407080:	17ffffe9 	b	407024 <z_log_init.isra.0+0xec>
	int i = 0;
  407084:	52800018 	mov	w24, #0x0                   	// #0
	uint32_t mask = 0;
  407088:	52800014 	mov	w20, #0x0                   	// #0
				mask |= BIT(i);
  40708c:	d280003a 	mov	x26, #0x1                   	// #1
  407090:	17ffffe7 	b	40702c <z_log_init.isra.0+0xf4>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407094:	54fffaa3 	b.cc	406fe8 <z_log_init.isra.0+0xb0>  // b.lo, b.ul, b.last
	if (blocking) {
  407098:	34fff9d9 	cbz	w25, 406fd0 <z_log_init.isra.0+0x98>
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  40709c:	f947c2b5 	ldr	x21, [x21, #3968]
		mask_cpy &= ~BIT(i);
  4070a0:	d2800039 	mov	x25, #0x1                   	// #1
		while (mask) {
  4070a4:	34fff974 	cbz	w20, 406fd0 <z_log_init.isra.0+0x98>
  4070a8:	2a1403f8 	mov	w24, w20
		uint32_t i = __builtin_ctz(mask_cpy);
  4070ac:	5ac00280 	rbit	w0, w20
  4070b0:	5ac01000 	clz	w0, w0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  4070b4:	d37b1416 	ubfiz	x22, x0, #5, #6
		mask_cpy &= ~BIT(i);
  4070b8:	9ac02321 	lsl	x1, x25, x0
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  4070bc:	8b1602b6 	add	x22, x21, x22
		mask_cpy &= ~BIT(i);
  4070c0:	2a2103fa 	mvn	w26, w1
  4070c4:	0a210294 	bic	w20, w20, w1
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
  4070c8:	394062c1 	ldrb	w1, [x22, #24]
  4070cc:	34000181 	cbz	w1, 4070fc <z_log_init.isra.0+0x1c4>
	STRUCT_SECTION_GET(log_backend, idx, &backend);
  4070d0:	937b7c00 	sbfiz	x0, x0, #5, #32
  4070d4:	8b150013 	add	x19, x0, x21
  4070d8:	aa1303e0 	mov	x0, x19
  4070dc:	97ffff90 	bl	406f1c <log_backend_is_ready>
  4070e0:	350000e0 	cbnz	w0, 4070fc <z_log_init.isra.0+0x1c4>
			log_backend_enable(backend,
  4070e4:	f94006c0 	ldr	x0, [x22, #8]
			mask &= ~BIT(i);
  4070e8:	0a1a0318 	and	w24, w24, w26
			log_backend_enable(backend,
  4070ec:	52800082 	mov	w2, #0x4                   	// #4
  4070f0:	f9400001 	ldr	x1, [x0]
  4070f4:	aa1303e0 	mov	x0, x19
  4070f8:	940000ef 	bl	4074b4 <log_backend_enable>
	while (mask_cpy) {
  4070fc:	35fffd94 	cbnz	w20, 4070ac <z_log_init.isra.0+0x174>
			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
  407100:	34000077 	cbz	w23, 40710c <z_log_init.isra.0+0x1d4>
	return z_impl_k_sleep(timeout);
  407104:	d2800020 	mov	x0, #0x1                   	// #1
  407108:	94003cc3 	bl	416414 <z_impl_k_sleep>
  40710c:	2a1803f4 	mov	w20, w24
  407110:	17ffffe5 	b	4070a4 <z_log_init.isra.0+0x16c>

0000000000407114 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(void)
{
  407114:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
				COND_CODE_1(CONFIG_LOG_PROCESS_THREAD,
					K_MSEC(CONFIG_LOG_PROCESS_THREAD_STARTUP_DELAY_MS),
					K_NO_WAIT));
		k_thread_name_set(&logging_thread, "logging");
	} else {
		(void)z_log_init(false, false);
  407118:	52800001 	mov	w1, #0x0                   	// #0
  40711c:	52800000 	mov	w0, #0x0                   	// #0
{
  407120:	910003fd 	mov	x29, sp
		(void)z_log_init(false, false);
  407124:	97ffff85 	bl	406f38 <z_log_init.isra.0>
	}

	return 0;
}
  407128:	52800000 	mov	w0, #0x0                   	// #0
  40712c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  407130:	d65f03c0 	ret

0000000000407134 <log_format_func_t_get>:
}
  407134:	d0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  407138:	91230021 	add	x1, x1, #0x8c0
  40713c:	f8605820 	ldr	x0, [x1, w0, uxtw #3]
  407140:	d65f03c0 	ret

0000000000407144 <z_log_vprintk>:
{
  407144:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  407148:	aa0003e6 	mov	x6, x0
  40714c:	910003fd 	mov	x29, sp
  407150:	ad400420 	ldp	q0, q1, [x1]
  407154:	9100c3e2 	add	x2, sp, #0x30
  407158:	ad000440 	stp	q0, q1, [x2]
  40715c:	ad400440 	ldp	q0, q1, [x2]
  407160:	910043e7 	add	x7, sp, #0x10
  407164:	52800005 	mov	w5, #0x0                   	// #0
  407168:	d2800004 	mov	x4, #0x0                   	// #0
  40716c:	d2800003 	mov	x3, #0x0                   	// #0
  407170:	52800002 	mov	w2, #0x0                   	// #0
  407174:	d2800001 	mov	x1, #0x0                   	// #0
  407178:	52800000 	mov	w0, #0x0                   	// #0
  40717c:	ad0004e0 	stp	q0, q1, [x7]
  407180:	9400010a 	bl	4075a8 <z_impl_z_log_msg_runtime_vcreate>
}
  407184:	a8c57bfd 	ldp	x29, x30, [sp], #80
  407188:	d65f03c0 	ret

000000000040718c <log_set_timestamp_func>:
{
  40718c:	aa0003e2 	mov	x2, x0
	if (timestamp_getter == NULL) {
  407190:	b4000140 	cbz	x0, 4071b8 <log_set_timestamp_func+0x2c>
{
  407194:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  407198:	2a0103e0 	mov	w0, w1
	timestamp_func = timestamp_getter;
  40719c:	f0000141 	adrp	x1, 432000 <__dso_handle>
{
  4071a0:	910003fd 	mov	x29, sp
	timestamp_func = timestamp_getter;
  4071a4:	f9022822 	str	x2, [x1, #1104]
		log_output_timestamp_freq_set(freq);
  4071a8:	9400033c 	bl	407e98 <log_output_timestamp_freq_set>
	return 0;
  4071ac:	52800000 	mov	w0, #0x0                   	// #0
}
  4071b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4071b4:	d65f03c0 	ret
		return -EINVAL;
  4071b8:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
  4071bc:	d65f03c0 	ret

00000000004071c0 <log_core_init>:
	panic_mode = false;
  4071c0:	b0000160 	adrp	x0, 434000 <ztest_thread+0xb8>
		log_set_timestamp_func(default_get_timestamp,
  4071c4:	52884801 	mov	w1, #0x4240                	// #16960
  4071c8:	72a001e1 	movk	w1, #0xf, lsl #16
	panic_mode = false;
  4071cc:	3938f81f 	strb	wzr, [x0, #3646]
	dropped_cnt = 0;
  4071d0:	90000160 	adrp	x0, 433000 <obj_0x28+0x18>
  4071d4:	f905341f 	str	xzr, [x0, #2664]
	buffered_cnt = 0;
  4071d8:	90000160 	adrp	x0, 433000 <obj_0x28+0x18>
  4071dc:	f905301f 	str	xzr, [x0, #2656]
		log_set_timestamp_func(default_get_timestamp,
  4071e0:	f0ffffe0 	adrp	x0, 406000 <sys_heap_init+0x17c>
  4071e4:	913c3000 	add	x0, x0, #0xf0c
  4071e8:	17ffffe9 	b	40718c <log_set_timestamp_func>

00000000004071ec <z_impl_log_panic>:
{
  4071ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4071f0:	910003fd 	mov	x29, sp
  4071f4:	f90013f5 	str	x21, [sp, #32]
	if (panic_mode) {
  4071f8:	b0000175 	adrp	x21, 434000 <ztest_thread+0xb8>
{
  4071fc:	a90153f3 	stp	x19, x20, [sp, #16]
	if (panic_mode) {
  407200:	3978faa0 	ldrb	w0, [x21, #3646]
  407204:	35000740 	cbnz	w0, 4072ec <z_impl_log_panic+0x100>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407208:	d0000153 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  40720c:	d0000154 	adrp	x20, 431000 <__FRAME_END__+0x10804>
	(void)z_log_init(true, false);
  407210:	52800001 	mov	w1, #0x0                   	// #0
  407214:	52800020 	mov	w0, #0x1                   	// #1
  407218:	97ffff48 	bl	406f38 <z_log_init.isra.0>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  40721c:	f947c273 	ldr	x19, [x19, #3968]
  407220:	f947fe94 	ldr	x20, [x20, #4088]
  407224:	eb14027f 	cmp	x19, x20
  407228:	540005c9 	b.ls	4072e0 <z_impl_log_panic+0xf4>  // b.plast
  40722c:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  407230:	9122be73 	add	x19, x19, #0x8af
  407234:	aa1303e2 	mov	x2, x19
  407238:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  40723c:	91240021 	add	x1, x1, #0x900
  407240:	52803103 	mov	w3, #0x188                 	// #392
  407244:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407248:	91178000 	add	x0, x0, #0x5e0
  40724c:	97fffef7 	bl	406e28 <assert_print>
  407250:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407254:	91248400 	add	x0, x0, #0x921
  407258:	97fffef4 	bl	406e28 <assert_print>
  40725c:	aa1303e0 	mov	x0, x19
  407260:	52803101 	mov	w1, #0x188                 	// #392
  407264:	97ffff1b 	bl	406ed0 <assert_post_action>
  407268:	52803102 	mov	w2, #0x188                 	// #392
  40726c:	14000013 	b	4072b8 <z_impl_log_panic+0xcc>
		if (log_backend_is_active(backend)) {
  407270:	aa1303e0 	mov	x0, x19
  407274:	97ffff27 	bl	406f10 <log_backend_is_active>
  407278:	72001c1f 	tst	w0, #0xff
  40727c:	540002e0 	b.eq	4072d8 <z_impl_log_panic+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  407280:	b5000253 	cbnz	x19, 4072c8 <z_impl_log_panic+0xdc>
  407284:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  407288:	91250273 	add	x19, x19, #0x940
  40728c:	aa1303e2 	mov	x2, x19
  407290:	52801a03 	mov	w3, #0xd0                  	// #208
  407294:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407298:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  40729c:	9125e021 	add	x1, x1, #0x978
  4072a0:	91178000 	add	x0, x0, #0x5e0
  4072a4:	97fffee1 	bl	406e28 <assert_print>
  4072a8:	aa1303e0 	mov	x0, x19
  4072ac:	52801a01 	mov	w1, #0xd0                  	// #208
  4072b0:	97ffff08 	bl	406ed0 <assert_post_action>
  4072b4:	52801a02 	mov	w2, #0xd0                  	// #208
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  4072b8:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4072bc:	aa1303e1 	mov	x1, x19
  4072c0:	91187800 	add	x0, x0, #0x61e
  4072c4:	940008f5 	bl	409698 <posix_print_error_and_exit>
	backend->api->panic(backend);
  4072c8:	f9400260 	ldr	x0, [x19]
  4072cc:	f9400801 	ldr	x1, [x0, #16]
  4072d0:	aa1303e0 	mov	x0, x19
  4072d4:	d63f0020 	blr	x1
  4072d8:	91008273 	add	x19, x19, #0x20
  4072dc:	17ffffd2 	b	407224 <z_impl_log_panic+0x38>
  4072e0:	54fffc83 	b.cc	407270 <z_impl_log_panic+0x84>  // b.lo, b.ul, b.last
	panic_mode = true;
  4072e4:	52800020 	mov	w0, #0x1                   	// #1
  4072e8:	3938faa0 	strb	w0, [x21, #3646]
}
  4072ec:	a94153f3 	ldp	x19, x20, [sp, #16]
  4072f0:	f94013f5 	ldr	x21, [sp, #32]
  4072f4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4072f8:	d65f03c0 	ret

00000000004072fc <z_log_notify_backend_enabled>:
}
  4072fc:	d65f03c0 	ret

0000000000407300 <z_impl_log_process>:
  407300:	52800000 	mov	w0, #0x0                   	// #0
  407304:	d65f03c0 	ret

0000000000407308 <z_log_dropped>:
{
  407308:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40730c:	90000161 	adrp	x1, 433000 <obj_0x28+0x18>
  407310:	9129a021 	add	x1, x1, #0xa68
  407314:	910003fd 	mov	x29, sp
  407318:	f9000bf3 	str	x19, [sp, #16]
  40731c:	12001c13 	and	w19, w0, #0xff
  407320:	d2800020 	mov	x0, #0x1                   	// #1
  407324:	97ffe94b 	bl	401850 <__aarch64_ldadd8_acq_rel>
	if (buffered) {
  407328:	340000b3 	cbz	w19, 40733c <z_log_dropped+0x34>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
  40732c:	90000161 	adrp	x1, 433000 <obj_0x28+0x18>
  407330:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  407334:	91298021 	add	x1, x1, #0xa60
  407338:	97ffe946 	bl	401850 <__aarch64_ldadd8_acq_rel>
}
  40733c:	f9400bf3 	ldr	x19, [sp, #16]
  407340:	a8c27bfd 	ldp	x29, x30, [sp], #32
  407344:	d65f03c0 	ret

0000000000407348 <z_log_msg_commit>:
{
  407348:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40734c:	910003fd 	mov	x29, sp
  407350:	a90153f3 	stp	x19, x20, [sp, #16]
  407354:	aa0003f4 	mov	x20, x0
	msg->hdr.timestamp = timestamp_func();
  407358:	f0000140 	adrp	x0, 432000 <__dso_handle>
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  40735c:	d0000153 	adrp	x19, 431000 <__FRAME_END__+0x10804>
{
  407360:	f90013f5 	str	x21, [sp, #32]
	msg->hdr.timestamp = timestamp_func();
  407364:	f9422800 	ldr	x0, [x0, #1104]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407368:	d0000155 	adrp	x21, 431000 <__FRAME_END__+0x10804>
	msg->hdr.timestamp = timestamp_func();
  40736c:	d63f0000 	blr	x0
  407370:	b9000680 	str	w0, [x20, #4]
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407374:	f947c273 	ldr	x19, [x19, #3968]
  407378:	f947feb5 	ldr	x21, [x21, #4088]
  40737c:	eb15027f 	cmp	x19, x21
  407380:	540005e9 	b.ls	40743c <z_log_msg_commit+0xf4>  // b.plast
  407384:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  407388:	9122be73 	add	x19, x19, #0x8af
  40738c:	aa1303e2 	mov	x2, x19
  407390:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407394:	91240021 	add	x1, x1, #0x900
  407398:	528038a3 	mov	w3, #0x1c5                 	// #453
  40739c:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4073a0:	91178000 	add	x0, x0, #0x5e0
  4073a4:	97fffea1 	bl	406e28 <assert_print>
  4073a8:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4073ac:	91248400 	add	x0, x0, #0x921
  4073b0:	97fffe9e 	bl	406e28 <assert_print>
  4073b4:	aa1303e0 	mov	x0, x19
  4073b8:	528038a1 	mov	w1, #0x1c5                 	// #453
  4073bc:	97fffec5 	bl	406ed0 <assert_post_action>
  4073c0:	528038a2 	mov	w2, #0x1c5                 	// #453
  4073c4:	14000013 	b	407410 <z_log_msg_commit+0xc8>
		if (log_backend_is_active(backend) &&
  4073c8:	aa1303e0 	mov	x0, x19
  4073cc:	97fffed1 	bl	406f10 <log_backend_is_active>
  4073d0:	72001c1f 	tst	w0, #0xff
  4073d4:	54000300 	b.eq	407434 <z_log_msg_commit+0xec>  // b.none
	__ASSERT_NO_MSG(backend != NULL);
  4073d8:	b5000253 	cbnz	x19, 407420 <z_log_msg_commit+0xd8>
  4073dc:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  4073e0:	91250273 	add	x19, x19, #0x940
  4073e4:	aa1303e2 	mov	x2, x19
  4073e8:	52801643 	mov	w3, #0xb2                  	// #178
  4073ec:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  4073f0:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4073f4:	9125e021 	add	x1, x1, #0x978
  4073f8:	91178000 	add	x0, x0, #0x5e0
  4073fc:	97fffe8b 	bl	406e28 <assert_print>
  407400:	aa1303e0 	mov	x0, x19
  407404:	52801641 	mov	w1, #0xb2                  	// #178
  407408:	97fffeb2 	bl	406ed0 <assert_post_action>
  40740c:	52801642 	mov	w2, #0xb2                  	// #178
	STRUCT_SECTION_FOREACH(log_backend, backend) {
  407410:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407414:	aa1303e1 	mov	x1, x19
  407418:	91187800 	add	x0, x0, #0x61e
  40741c:	9400089f 	bl	409698 <posix_print_error_and_exit>
	backend->api->process(backend, msg);
  407420:	f9400260 	ldr	x0, [x19]
  407424:	aa1403e1 	mov	x1, x20
  407428:	f9400002 	ldr	x2, [x0]
  40742c:	aa1303e0 	mov	x0, x19
  407430:	d63f0040 	blr	x2
  407434:	91008273 	add	x19, x19, #0x20
  407438:	17ffffd1 	b	40737c <z_log_msg_commit+0x34>
  40743c:	54fffc63 	b.cc	4073c8 <z_log_msg_commit+0x80>  // b.lo, b.ul, b.last
}
  407440:	a94153f3 	ldp	x19, x20, [sp, #16]
  407444:	f94013f5 	ldr	x21, [sp, #32]
  407448:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40744c:	d65f03c0 	ret

0000000000407450 <z_log_get_tag>:
}
  407450:	d2800000 	mov	x0, #0x0                   	// #0
  407454:	d65f03c0 	ret

0000000000407458 <log_src_cnt_get>:
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
  407458:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40745c:	d0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  407460:	f9474c00 	ldr	x0, [x0, #3736]
  407464:	f9470821 	ldr	x1, [x1, #3600]
  407468:	cb010000 	sub	x0, x0, x1
	if (z_log_is_local_domain(domain_id)) {
		return z_log_sources_count();
	}

	return link_source_count(domain_id);
}
  40746c:	d3448c00 	ubfx	x0, x0, #4, #32
  407470:	d65f03c0 	ret

0000000000407474 <log_source_name_get>:

	return (const char *)cached;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t source_id)
{
  407474:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  407478:	910003fd 	mov	x29, sp
  40747c:	f9000bf3 	str	x19, [sp, #16]
  407480:	2a0103f3 	mov	w19, w1
	if (z_log_is_local_domain(domain_id)) {
		if (source_id < log_src_cnt_get(domain_id)) {
  407484:	97fffff5 	bl	407458 <log_src_cnt_get>
  407488:	6b13001f 	cmp	w0, w19
  40748c:	54000109 	b.ls	4074ac <log_source_name_get+0x38>  // b.plast
			return TYPE_SECTION_START(log_const)[source_id].name;
  407490:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  407494:	d37c7e73 	ubfiz	x19, x19, #4, #32
  407498:	f9470800 	ldr	x0, [x0, #3600]
  40749c:	f8736800 	ldr	x0, [x0, x19]
			return NULL;
		}
	}

	return link_source_name_get(domain_id, source_id);
}
  4074a0:	f9400bf3 	ldr	x19, [sp, #16]
  4074a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4074a8:	d65f03c0 	ret
			return NULL;
  4074ac:	d2800000 	mov	x0, #0x0                   	// #0
  4074b0:	17fffffc 	b	4074a0 <log_source_name_get+0x2c>

00000000004074b4 <log_backend_enable>:
			uint32_t level)
{
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
  4074b4:	d0000143 	adrp	x3, 431000 <__FRAME_END__+0x10804>
  4074b8:	f947c063 	ldr	x3, [x3, #3968]
  4074bc:	cb030003 	sub	x3, x0, x3
	__ASSERT_NO_MSG(backend != NULL);
  4074c0:	b50002a0 	cbnz	x0, 407514 <log_backend_enable+0x60>
{
  4074c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4074c8:	52801be3 	mov	w3, #0xdf                  	// #223
  4074cc:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  4074d0:	910003fd 	mov	x29, sp
  4074d4:	f9000bf3 	str	x19, [sp, #16]
  4074d8:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  4074dc:	91250273 	add	x19, x19, #0x940
  4074e0:	9125e021 	add	x1, x1, #0x978
  4074e4:	aa1303e2 	mov	x2, x19
  4074e8:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4074ec:	91178000 	add	x0, x0, #0x5e0
  4074f0:	97fffe4e 	bl	406e28 <assert_print>
  4074f4:	aa1303e0 	mov	x0, x19
  4074f8:	52801be1 	mov	w1, #0xdf                  	// #223
  4074fc:	97fffe75 	bl	406ed0 <assert_post_action>
  407500:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407504:	aa1303e1 	mov	x1, x19
  407508:	91187800 	add	x0, x0, #0x61e
  40750c:	52801be2 	mov	w2, #0xdf                  	// #223
  407510:	94000862 	bl	409698 <posix_print_error_and_exit>
	backend->cb->id = id;
  407514:	f9400404 	ldr	x4, [x0, #8]
  407518:	9345fc63 	asr	x3, x3, #5
  40751c:	11000463 	add	w3, w3, #0x1
  407520:	12001c63 	and	w3, w3, #0xff
  407524:	39002083 	strb	w3, [x4, #8]

	log_backend_id_set(backend, id);
	backend->cb->level = level;
  407528:	f9400403 	ldr	x3, [x0, #8]
  40752c:	39002862 	strb	w2, [x3, #10]
	backend->cb->ctx = ctx;
  407530:	f9400402 	ldr	x2, [x0, #8]
  407534:	f9000041 	str	x1, [x2]
	backend->cb->active = true;
  407538:	52800021 	mov	w1, #0x1                   	// #1
  40753c:	f9400400 	ldr	x0, [x0, #8]
  407540:	39002401 	strb	w1, [x0, #9]
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
  407544:	17ffff6e 	b	4072fc <z_log_notify_backend_enabled>

0000000000407548 <z_log_msg_finalize>:
	 (IS_ENABLED(CONFIG_LOG_FRONTEND_ONLY) || log_backend_count_get() == 0))

void z_log_msg_finalize(struct log_msg *msg, const void *source,
			 const struct log_msg_desc desc, const void *data)
{
	if (!msg) {
  407548:	b5000060 	cbnz	x0, 407554 <z_log_msg_finalize+0xc>
		z_log_dropped(false);
  40754c:	52800000 	mov	w0, #0x0                   	// #0
  407550:	17ffff6e 	b	407308 <z_log_dropped>
{
  407554:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  407558:	910003fd 	mov	x29, sp
  40755c:	a90153f3 	stp	x19, x20, [sp, #16]
  407560:	aa0003f3 	mov	x19, x0
  407564:	2a0203f4 	mov	w20, w2
  407568:	f90013f5 	str	x21, [sp, #32]
  40756c:	aa0103f5 	mov	x21, x1
  407570:	aa0303e1 	mov	x1, x3

		return;
	}

	if (data) {
  407574:	b40000c3 	cbz	x3, 40758c <z_log_msg_finalize+0x44>
		uint8_t *d = msg->data + desc.package_len;
  407578:	d3494e83 	ubfx	x3, x20, #9, #11
  40757c:	91004000 	add	x0, x0, #0x10
  407580:	53147c42 	lsr	w2, w2, #20
  407584:	8b030000 	add	x0, x0, x3
  407588:	97ffe76a 	bl	401330 <memcpy@plt>

		memcpy(d, data, desc.data_len);
	}

	msg->hdr.desc = desc;
  40758c:	b9000274 	str	w20, [x19]
	msg->hdr.source = source;
	z_log_msg_commit(msg);
  407590:	aa1303e0 	mov	x0, x19
	msg->hdr.source = source;
  407594:	f9000675 	str	x21, [x19, #8]
}
  407598:	a94153f3 	ldp	x19, x20, [sp, #16]
  40759c:	f94013f5 	ldr	x21, [sp, #32]
  4075a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_log_msg_commit(msg);
  4075a4:	17ffff69 	b	407348 <z_log_msg_commit>

00000000004075a8 <z_impl_z_log_msg_runtime_vcreate>:
#endif

void z_impl_z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,
				uint8_t level, const void *data, size_t dlen,
				uint32_t package_flags, const char *fmt, va_list ap)
{
  4075a8:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
  4075ac:	910003fd 	mov	x29, sp
  4075b0:	a9046bf9 	stp	x25, x26, [sp, #64]
  4075b4:	12001c1a 	and	w26, w0, #0xff
  4075b8:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4075bc:	a90153f3 	stp	x19, x20, [sp, #16]
  4075c0:	aa0103f4 	mov	x20, x1
  4075c4:	12001c53 	and	w19, w2, #0xff
  4075c8:	f9475c00 	ldr	x0, [x0, #3768]
  4075cc:	a9025bf5 	stp	x21, x22, [sp, #32]
  4075d0:	2a0503f9 	mov	w25, w5
  4075d4:	a90363f7 	stp	x23, x24, [sp, #48]
  4075d8:	aa0303f5 	mov	x21, x3
  4075dc:	d10043ff 	sub	sp, sp, #0x10
  4075e0:	f9400001 	ldr	x1, [x0]
  4075e4:	f9004fa1 	str	x1, [x29, #152]
  4075e8:	d2800001 	mov	x1, #0x0                   	// #0
  4075ec:	aa0403f8 	mov	x24, x4
  4075f0:	aa0603f6 	mov	x22, x6
  4075f4:	aa0703f7 	mov	x23, x7
	int plen;

	if (fmt) {
  4075f8:	b40003a6 	cbz	x6, 40766c <z_impl_z_log_msg_runtime_vcreate+0xc4>
		va_list ap2;

		va_copy(ap2, ap);
  4075fc:	ad4004e0 	ldp	q0, q1, [x7]
  407600:	9101e3a0 	add	x0, x29, #0x78
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  407604:	910143a4 	add	x4, x29, #0x50
  407608:	aa0603e3 	mov	x3, x6
  40760c:	2a0503e2 	mov	w2, w5
  407610:	d2800201 	mov	x1, #0x10                  	// #16
		va_copy(ap2, ap);
  407614:	ad000400 	stp	q0, q1, [x0]
		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
  407618:	d2800000 	mov	x0, #0x0                   	// #0
  40761c:	ad000480 	stp	q0, q1, [x4]
  407620:	97fff611 	bl	404e64 <cbvprintf_package>
					 package_flags, fmt, ap2);
		__ASSERT_NO_MSG(plen >= 0);
  407624:	36f80260 	tbz	w0, #31, 407670 <z_impl_z_log_msg_runtime_vcreate+0xc8>
  407628:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  40762c:	91279273 	add	x19, x19, #0x9e4
  407630:	aa1303e2 	mov	x2, x19
  407634:	52800ea3 	mov	w3, #0x75                  	// #117
  407638:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  40763c:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407640:	91284021 	add	x1, x1, #0xa10
  407644:	91178000 	add	x0, x0, #0x5e0
  407648:	97fffdf8 	bl	406e28 <assert_print>
  40764c:	aa1303e0 	mov	x0, x19
  407650:	52800ea1 	mov	w1, #0x75                  	// #117
  407654:	97fffe1f 	bl	406ed0 <assert_post_action>
  407658:	52800ea2 	mov	w2, #0x75                  	// #117
		pkg = msg->data;
	}

	if (pkg && fmt) {
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
		__ASSERT_NO_MSG(plen >= 0);
  40765c:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407660:	aa1303e1 	mov	x1, x19
  407664:	91187800 	add	x0, x0, #0x61e
  407668:	9400080c 	bl	409698 <posix_print_error_and_exit>
		plen = 0;
  40766c:	52800000 	mov	w0, #0x0                   	// #0
	struct log_msg_desc desc =
  407670:	531a0a73 	ubfiz	w19, w19, #6, #3
  407674:	531d0b5a 	ubfiz	w26, w26, #3, #3
  407678:	53172802 	ubfiz	w2, w0, #9, #11
  40767c:	2a1a0273 	orr	w19, w19, w26
  407680:	2a020273 	orr	w19, w19, w2
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  407684:	93407c01 	sxtw	x1, w0
	struct log_msg_desc desc =
  407688:	2a185273 	orr	w19, w19, w24, lsl #20
	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
  40768c:	91005f18 	add	x24, x24, #0x17
  407690:	8b20c300 	add	x0, x24, w0, sxtw
		msg = alloca(msg_wlen * sizeof(int));
  407694:	927df000 	and	x0, x0, #0xfffffffffffffff8
  407698:	91003c00 	add	x0, x0, #0xf
  40769c:	927cec02 	and	x2, x0, #0xfffffffffffffff0
  4076a0:	9270bc00 	and	x0, x0, #0xffffffffffff0000
  4076a4:	cb2063e0 	sub	x0, sp, x0
  4076a8:	eb2063ff 	cmp	sp, x0
  4076ac:	54000080 	b.eq	4076bc <z_impl_z_log_msg_runtime_vcreate+0x114>  // b.none
  4076b0:	d14043ff 	sub	sp, sp, #0x10, lsl #12
  4076b4:	f90203ff 	str	xzr, [sp, #1024]
  4076b8:	17fffffc 	b	4076a8 <z_impl_z_log_msg_runtime_vcreate+0x100>
  4076bc:	92403c40 	and	x0, x2, #0xffff
  4076c0:	cb2063ff 	sub	sp, sp, x0
  4076c4:	f90003ff 	str	xzr, [sp]
  4076c8:	f110001f 	cmp	x0, #0x400
  4076cc:	54000043 	b.cc	4076d4 <z_impl_z_log_msg_runtime_vcreate+0x12c>  // b.lo, b.ul, b.last
  4076d0:	f90203ff 	str	xzr, [sp, #1024]
  4076d4:	910043f8 	add	x24, sp, #0x10
	if (pkg && fmt) {
  4076d8:	b40002f6 	cbz	x22, 407734 <z_impl_z_log_msg_runtime_vcreate+0x18c>
		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
  4076dc:	ad4006e0 	ldp	q0, q1, [x23]
  4076e0:	910143a4 	add	x4, x29, #0x50
  4076e4:	aa1603e3 	mov	x3, x22
  4076e8:	2a1903e2 	mov	w2, w25
  4076ec:	91004300 	add	x0, x24, #0x10
  4076f0:	ad000480 	stp	q0, q1, [x4]
  4076f4:	97fff5dc 	bl	404e64 <cbvprintf_package>
		__ASSERT_NO_MSG(plen >= 0);
  4076f8:	36f801e0 	tbz	w0, #31, 407734 <z_impl_z_log_msg_runtime_vcreate+0x18c>
  4076fc:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  407700:	91279273 	add	x19, x19, #0x9e4
  407704:	aa1303e2 	mov	x2, x19
  407708:	528011e3 	mov	w3, #0x8f                  	// #143
  40770c:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407710:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407714:	91284021 	add	x1, x1, #0xa10
  407718:	91178000 	add	x0, x0, #0x5e0
  40771c:	97fffdc3 	bl	406e28 <assert_print>
  407720:	aa1303e0 	mov	x0, x19
  407724:	528011e1 	mov	w1, #0x8f                  	// #143
  407728:	97fffdea 	bl	406ed0 <assert_post_action>
  40772c:	528011e2 	mov	w2, #0x8f                  	// #143
  407730:	17ffffcb 	b	40765c <z_impl_z_log_msg_runtime_vcreate+0xb4>
	if (IS_ENABLED(CONFIG_LOG_FRONTEND)) {
		log_frontend_msg(source, desc, pkg, data);
	}

	if (BACKENDS_IN_USE()) {
		z_log_msg_finalize(msg, source, desc, data);
  407734:	2a1303e2 	mov	w2, w19
  407738:	aa1403e1 	mov	x1, x20
  40773c:	aa1803e0 	mov	x0, x24
  407740:	aa1503e3 	mov	x3, x21
  407744:	97ffff81 	bl	407548 <z_log_msg_finalize>
	}
}
  407748:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40774c:	f9475c00 	ldr	x0, [x0, #3768]
  407750:	f9404fa2 	ldr	x2, [x29, #152]
  407754:	f9400001 	ldr	x1, [x0]
  407758:	eb010042 	subs	x2, x2, x1
  40775c:	d2800001 	mov	x1, #0x0                   	// #0
  407760:	54000040 	b.eq	407768 <z_impl_z_log_msg_runtime_vcreate+0x1c0>  // b.none
  407764:	97ffe76f 	bl	401520 <__stack_chk_fail@plt>
  407768:	910003bf 	mov	sp, x29
  40776c:	a94153f3 	ldp	x19, x20, [sp, #16]
  407770:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407774:	a94363f7 	ldp	x23, x24, [sp, #48]
  407778:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40777c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
  407780:	d65f03c0 	ret

0000000000407784 <out_func>:

	return ret;
}

static int out_func(int c, void *ctx)
{
  407784:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  407788:	d0000142 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  40778c:	910003fd 	mov	x29, sp
  407790:	f9475c42 	ldr	x2, [x2, #3768]
  407794:	f9400043 	ldr	x3, [x2]
  407798:	f9000fe3 	str	x3, [sp, #24]
  40779c:	d2800003 	mov	x3, #0x0                   	// #0
	int idx;

	if (IS_ENABLED(CONFIG_LOG_MODE_IMMEDIATE)) {
		/* Backend must be thread safe in synchronous operation. */
		/* Need that step for big endian */
		char x = (char)c;
  4077a0:	39005fe0 	strb	w0, [sp, #23]

		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
  4077a4:	a9400023 	ldp	x3, x0, [x1]
  4077a8:	d2800021 	mov	x1, #0x1                   	// #1
  4077ac:	f9400402 	ldr	x2, [x0, #8]
  4077b0:	91005fe0 	add	x0, sp, #0x17
  4077b4:	d63f0060 	blr	x3
	out_ctx->buf[idx] = (uint8_t)c;

	__ASSERT_NO_MSG(out_ctx->control_block->offset <= out_ctx->size);

	return 0;
}
  4077b8:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4077bc:	f9475c00 	ldr	x0, [x0, #3768]
  4077c0:	f9400fe2 	ldr	x2, [sp, #24]
  4077c4:	f9400001 	ldr	x1, [x0]
  4077c8:	eb010042 	subs	x2, x2, x1
  4077cc:	d2800001 	mov	x1, #0x0                   	// #0
  4077d0:	54000040 	b.eq	4077d8 <out_func+0x54>  // b.none
  4077d4:	97ffe753 	bl	401520 <__stack_chk_fail@plt>
  4077d8:	52800000 	mov	w0, #0x0                   	// #0
  4077dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4077e0:	d65f03c0 	ret

00000000004077e4 <cr_out_func>:

static int cr_out_func(int c, void *ctx)
{
  4077e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4077e8:	910003fd 	mov	x29, sp
  4077ec:	a90153f3 	stp	x19, x20, [sp, #16]
  4077f0:	2a0003f3 	mov	w19, w0
  4077f4:	aa0103f4 	mov	x20, x1
	if (c == '\n') {
  4077f8:	7100281f 	cmp	w0, #0xa
  4077fc:	54000061 	b.ne	407808 <cr_out_func+0x24>  // b.any
		out_func((int)'\r', ctx);
  407800:	528001a0 	mov	w0, #0xd                   	// #13
  407804:	97ffffe0 	bl	407784 <out_func>
	}
	out_func(c, ctx);
  407808:	aa1403e1 	mov	x1, x20
  40780c:	2a1303e0 	mov	w0, w19
  407810:	97ffffdd 	bl	407784 <out_func>

	return 0;
}
  407814:	52800000 	mov	w0, #0x0                   	// #0
  407818:	a94153f3 	ldp	x19, x20, [sp, #16]
  40781c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  407820:	d65f03c0 	ret

0000000000407824 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
  407824:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  407828:	910003fd 	mov	x29, sp
  40782c:	a90153f3 	stp	x19, x20, [sp, #16]
  407830:	aa0103f4 	mov	x20, x1
  407834:	aa0203f3 	mov	x19, x2
  407838:	a9025bf5 	stp	x21, x22, [sp, #32]
  40783c:	aa0003f5 	mov	x21, x0
  407840:	aa0303f6 	mov	x22, x3
	int processed;

	do {
		processed = outf(buf, len, ctx);
  407844:	aa1303e1 	mov	x1, x19
  407848:	aa1403e0 	mov	x0, x20
  40784c:	aa1603e2 	mov	x2, x22
  407850:	d63f02a0 	blr	x21
		len -= processed;
		buf += processed;
  407854:	8b20c294 	add	x20, x20, w0, sxtw
	} while (len != 0);
  407858:	eb20c273 	subs	x19, x19, w0, sxtw
  40785c:	54ffff41 	b.ne	407844 <buffer_write+0x20>  // b.any
}
  407860:	a94153f3 	ldp	x19, x20, [sp, #16]
  407864:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407868:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40786c:	d65f03c0 	ret

0000000000407870 <cbvprintf>:
#ifdef CONFIG_PICOLIBC
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
  407870:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  407874:	910003fd 	mov	x29, sp
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
  407878:	ad400460 	ldp	q0, q1, [x3]
  40787c:	910043e4 	add	x4, sp, #0x10
  407880:	aa0403e3 	mov	x3, x4
  407884:	ad000480 	stp	q0, q1, [x4]
  407888:	52800004 	mov	w4, #0x0                   	// #0
  40788c:	97fffa83 	bl	406298 <z_cbvprintf_impl>
}
  407890:	a8c37bfd 	ldp	x29, x30, [sp], #48
  407894:	d65f03c0 	ret

0000000000407898 <print_formatted>:
{
  407898:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40789c:	910003fd 	mov	x29, sp
  4078a0:	a90e0fe2 	stp	x2, x3, [sp, #224]
  4078a4:	d0000142 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  4078a8:	f9475c42 	ldr	x2, [x2, #3768]
  4078ac:	3d801be0 	str	q0, [sp, #96]
  4078b0:	3d801fe1 	str	q1, [sp, #112]
  4078b4:	3d8023e2 	str	q2, [sp, #128]
  4078b8:	3d8027e3 	str	q3, [sp, #144]
  4078bc:	3d802be4 	str	q4, [sp, #160]
  4078c0:	3d802fe5 	str	q5, [sp, #176]
  4078c4:	3d8033e6 	str	q6, [sp, #192]
  4078c8:	3d8037e7 	str	q7, [sp, #208]
  4078cc:	a90f17e4 	stp	x4, x5, [sp, #240]
  4078d0:	a9101fe6 	stp	x6, x7, [sp, #256]
  4078d4:	f9400043 	ldr	x3, [x2]
  4078d8:	f9002fe3 	str	x3, [sp, #88]
  4078dc:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(args, fmt);
  4078e0:	910443e2 	add	x2, sp, #0x110
  4078e4:	a9038be2 	stp	x2, x2, [sp, #56]
  4078e8:	910383e2 	add	x2, sp, #0xe0
	length = cbvprintf(out_func, (void *)output, fmt, args);
  4078ec:	910043e3 	add	x3, sp, #0x10
	va_start(args, fmt);
  4078f0:	f90027e2 	str	x2, [sp, #72]
  4078f4:	128005e2 	mov	w2, #0xffffffd0            	// #-48
  4078f8:	b90053e2 	str	w2, [sp, #80]
  4078fc:	12800fe2 	mov	w2, #0xffffff80            	// #-128
  407900:	b90057e2 	str	w2, [sp, #84]
	length = cbvprintf(out_func, (void *)output, fmt, args);
  407904:	9100e3e2 	add	x2, sp, #0x38
  407908:	ad400440 	ldp	q0, q1, [x2]
  40790c:	aa0103e2 	mov	x2, x1
  407910:	aa0003e1 	mov	x1, x0
  407914:	90000000 	adrp	x0, 407000 <z_log_init.isra.0+0xc8>
  407918:	911e1000 	add	x0, x0, #0x784
  40791c:	ad000460 	stp	q0, q1, [x3]
  407920:	97ffffd4 	bl	407870 <cbvprintf>
}
  407924:	d0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  407928:	f9475c21 	ldr	x1, [x1, #3768]
  40792c:	f9402fe3 	ldr	x3, [sp, #88]
  407930:	f9400022 	ldr	x2, [x1]
  407934:	eb020063 	subs	x3, x3, x2
  407938:	d2800002 	mov	x2, #0x0                   	// #0
  40793c:	54000040 	b.eq	407944 <print_formatted+0xac>  // b.none
  407940:	97ffe6f8 	bl	401520 <__stack_chk_fail@plt>
  407944:	a8d17bfd 	ldp	x29, x30, [sp], #272
  407948:	d65f03c0 	ret

000000000040794c <log_output_flush>:


void log_output_flush(const struct log_output *output)
{
  40794c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  407950:	910003fd 	mov	x29, sp
  407954:	f9000bf3 	str	x19, [sp, #16]
  407958:	aa0003f3 	mov	x19, x0
	buffer_write(output->func, output->buf,
  40795c:	a9408400 	ldp	x0, x1, [x0, #8]
  407960:	a9400c02 	ldp	x2, x3, [x0]
  407964:	f9400260 	ldr	x0, [x19]
  407968:	97ffffaf 	bl	407824 <buffer_write>
		     output->control_block->offset,
		     output->control_block->ctx);

	output->control_block->offset = 0;
  40796c:	f9400660 	ldr	x0, [x19, #8]
  407970:	f900001f 	str	xzr, [x0]
}
  407974:	f9400bf3 	ldr	x19, [sp, #16]
  407978:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40797c:	d65f03c0 	ret

0000000000407980 <log_output_process>:
			uint8_t level,
			const uint8_t *package,
			const uint8_t *data,
			size_t data_len,
			uint32_t flags)
{
  407980:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  407984:	910003fd 	mov	x29, sp
  407988:	a90153f3 	stp	x19, x20, [sp, #16]
  40798c:	aa0003f3 	mov	x19, x0
  407990:	a9025bf5 	stp	x21, x22, [sp, #32]
  407994:	aa0703f5 	mov	x21, x7
  407998:	b94083f6 	ldr	w22, [sp, #128]
  40799c:	a90363f7 	stp	x23, x24, [sp, #48]
  4079a0:	aa0603f7 	mov	x23, x6
  4079a4:	a9046bf9 	stp	x25, x26, [sp, #64]
  4079a8:	aa0303fa 	mov	x26, x3
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	uint32_t prefix_offset;
	cbprintf_cb cb;

	if (!raw_string) {
  4079ac:	72001c99 	ands	w25, w4, #0xff
{
  4079b0:	a90573fb 	stp	x27, x28, [sp, #80]
  4079b4:	aa0503fb 	mov	x27, x5
	if (!raw_string) {
  4079b8:	54001100 	b.eq	407bd8 <log_output_process+0x258>  // b.none
	__ASSERT_NO_MSG(level <= LOG_LEVEL_DBG);
  4079bc:	7100133f 	cmp	w25, #0x4
  4079c0:	54000249 	b.ls	407a08 <log_output_process+0x88>  // b.plast
  4079c4:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  4079c8:	91287e73 	add	x19, x19, #0xa1f
  4079cc:	aa1303e2 	mov	x2, x19
  4079d0:	52803663 	mov	w3, #0x1b3                 	// #435
  4079d4:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  4079d8:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4079dc:	91293821 	add	x1, x1, #0xa4e
  4079e0:	91178000 	add	x0, x0, #0x5e0
  4079e4:	97fffd11 	bl	406e28 <assert_print>
  4079e8:	aa1303e0 	mov	x0, x19
  4079ec:	52803661 	mov	w1, #0x1b3                 	// #435
  4079f0:	97fffd38 	bl	406ed0 <assert_post_action>
  4079f4:	52803662 	mov	w2, #0x1b3                 	// #435

	if (package) {
		int err = cbpprintf(cb, (void *)output, (void *)package);

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
  4079f8:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  4079fc:	aa1303e1 	mov	x1, x19
  407a00:	91187800 	add	x0, x0, #0x61e
  407a04:	94000725 	bl	409698 <posix_print_error_and_exit>
  407a08:	121d02c0 	and	w0, w22, #0x8
  407a0c:	aa0203fc 	mov	x28, x2
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
  407a10:	2a0103f4 	mov	w20, w1
  407a14:	b9007be0 	str	w0, [sp, #120]
	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
  407a18:	97fffe8e 	bl	407450 <z_log_get_tag>
  407a1c:	aa0003e2 	mov	x2, x0
	if (tag) {
  407a20:	b40009e0 	cbz	x0, 407b5c <log_output_process+0x1dc>
		length += print_formatted(output, "%s ", tag);
  407a24:	aa1303e0 	mov	x0, x19
  407a28:	d0000081 	adrp	x1, 419000 <__func__.2+0xa80>
  407a2c:	913e6021 	add	x1, x1, #0xf98
  407a30:	97ffff9a 	bl	407898 <print_formatted>
  407a34:	2a0003f8 	mov	w24, w0
	if (stamp) {
  407a38:	121f02c0 	and	w0, w22, #0x2
  407a3c:	34000140 	cbz	w0, 407a64 <log_output_process+0xe4>
	if (!format) {
  407a40:	52800880 	mov	w0, #0x44                  	// #68
  407a44:	6a0002df 	tst	w22, w0
  407a48:	540008e1 	b.ne	407b64 <log_output_process+0x1e4>  // b.any
		length = print_formatted(output, "[%08lu] ", timestamp);
  407a4c:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407a50:	2a1403e2 	mov	w2, w20
  407a54:	91296821 	add	x1, x1, #0xa5a
  407a58:	aa1303e0 	mov	x0, x19
  407a5c:	97ffff8f 	bl	407898 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
  407a60:	0b000318 	add	w24, w24, w0
	if (color) {
  407a64:	120002c0 	and	w0, w22, #0x1
  407a68:	34000180 	cbz	w0, 407a98 <log_output_process+0x118>
		const char *log_color = start && (colors[level] != NULL) ?
  407a6c:	2a1903e1 	mov	w1, w25
  407a70:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  407a74:	911ca000 	add	x0, x0, #0x728
  407a78:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  407a7c:	b5000062 	cbnz	x2, 407a88 <log_output_process+0x108>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
  407a80:	b0000082 	adrp	x2, 418000 <table.0+0x1d8>
  407a84:	91286842 	add	x2, x2, #0xa1a
		print_formatted(output, "%s", log_color);
  407a88:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407a8c:	aa1303e0 	mov	x0, x19
  407a90:	9103dc21 	add	x1, x1, #0xf7
  407a94:	97ffff81 	bl	407898 <print_formatted>
	if (level_on) {
  407a98:	121d02c0 	and	w0, w22, #0x8
  407a9c:	340009a0 	cbz	w0, 407bd0 <log_output_process+0x250>
		total += print_formatted(output, "<%s> ", severity[level]);
  407aa0:	2a1903e1 	mov	w1, w25
  407aa4:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  407aa8:	911d4000 	add	x0, x0, #0x750
  407aac:	f8617802 	ldr	x2, [x0, x1, lsl #3]
  407ab0:	aa1303e0 	mov	x0, x19
  407ab4:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407ab8:	9129fc21 	add	x1, x1, #0xa7f
  407abc:	97ffff77 	bl	407898 <print_formatted>
  407ac0:	2a0003f4 	mov	w20, w0
	if (domain) {
  407ac4:	b40000fc 	cbz	x28, 407ae0 <log_output_process+0x160>
		total += print_formatted(output, "%s/", domain);
  407ac8:	aa1c03e2 	mov	x2, x28
  407acc:	aa1303e0 	mov	x0, x19
  407ad0:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407ad4:	912a1421 	add	x1, x1, #0xa85
  407ad8:	97ffff70 	bl	407898 <print_formatted>
  407adc:	0b000294 	add	w20, w20, w0
	if (source) {
  407ae0:	b40000fa 	cbz	x26, 407afc <log_output_process+0x17c>
		total += print_formatted(output,
  407ae4:	aa1a03e2 	mov	x2, x26
  407ae8:	aa1303e0 	mov	x0, x19
  407aec:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407af0:	912a2421 	add	x1, x1, #0xa89
  407af4:	97ffff69 	bl	407898 <print_formatted>
  407af8:	0b000294 	add	w20, w20, w0
		cb = out_func;
  407afc:	90000000 	adrp	x0, 407000 <z_log_init.isra.0+0xc8>
	length += ids_print(output, level_on, func_on, domain, source, level);
  407b00:	0b180294 	add	w20, w20, w24
		cb = out_func;
  407b04:	911e1000 	add	x0, x0, #0x784
	if (package) {
  407b08:	b40007bb 	cbz	x27, 407bfc <log_output_process+0x27c>
		return cbpprintf_external(out, cbvprintf_tagged_args,
					  ctx, packaged);
	}
#endif

	return cbpprintf_external(out, cbvprintf, ctx, packaged);
  407b0c:	90000001 	adrp	x1, 407000 <z_log_init.isra.0+0xc8>
  407b10:	aa1b03e3 	mov	x3, x27
  407b14:	aa1303e2 	mov	x2, x19
  407b18:	9121c021 	add	x1, x1, #0x870
  407b1c:	97fff6af 	bl	4055d8 <cbpprintf_external>
		__ASSERT_NO_MSG(err >= 0);
  407b20:	36f806e0 	tbz	w0, #31, 407bfc <log_output_process+0x27c>
  407b24:	b0000093 	adrp	x19, 418000 <table.0+0x1d8>
  407b28:	91287e73 	add	x19, x19, #0xa1f
  407b2c:	aa1303e2 	mov	x2, x19
  407b30:	52804123 	mov	w3, #0x209                 	// #521
  407b34:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407b38:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407b3c:	912a3821 	add	x1, x1, #0xa8e
  407b40:	91178000 	add	x0, x0, #0x5e0
  407b44:	97fffcb9 	bl	406e28 <assert_print>
  407b48:	aa1303e0 	mov	x0, x19
  407b4c:	52804121 	mov	w1, #0x209                 	// #521
  407b50:	97fffce0 	bl	406ed0 <assert_post_action>
  407b54:	52804122 	mov	w2, #0x209                 	// #521
  407b58:	17ffffa8 	b	4079f8 <log_output_process+0x78>
	uint32_t length = 0U;
  407b5c:	52800018 	mov	w24, #0x0                   	// #0
  407b60:	17ffffb6 	b	407a38 <log_output_process+0xb8>
	} else if (freq != 0U) {
  407b64:	b0000160 	adrp	x0, 434000 <ztest_thread+0xb8>
  407b68:	b94dcc06 	ldr	w6, [x0, #3532]
  407b6c:	340002e6 	cbz	w6, 407bc8 <log_output_process+0x248>
		timestamp /= timestamp_div;
  407b70:	b0000160 	adrp	x0, 434000 <ztest_thread+0xb8>
  407b74:	5281c201 	mov	w1, #0xe10                 	// #3600
		ms = (remainder * 1000U) / freq;
  407b78:	52807d03 	mov	w3, #0x3e8                 	// #1000
				length = print_formatted(output,
  407b7c:	52800784 	mov	w4, #0x3c                  	// #60
		timestamp /= timestamp_div;
  407b80:	b94dd000 	ldr	w0, [x0, #3536]
  407b84:	1ac00a94 	udiv	w20, w20, w0
		total_seconds = timestamp / freq;
  407b88:	1ac60a80 	udiv	w0, w20, w6
		seconds -= hours * 3600U;
  407b8c:	1ac10802 	udiv	w2, w0, w1
  407b90:	1b018041 	msub	w1, w2, w1, w0
		remainder = timestamp % freq;
  407b94:	1b06d000 	msub	w0, w0, w6, w20
		ms = (remainder * 1000U) / freq;
  407b98:	1b037c00 	mul	w0, w0, w3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
  407b9c:	1ac60805 	udiv	w5, w0, w6
  407ba0:	1b0680a0 	msub	w0, w5, w6, w0
  407ba4:	1b037c00 	mul	w0, w0, w3
				length = print_formatted(output,
  407ba8:	1ac40823 	udiv	w3, w1, w4
  407bac:	1ac60806 	udiv	w6, w0, w6
  407bb0:	aa1303e0 	mov	x0, x19
  407bb4:	1b048464 	msub	w4, w3, w4, w1
  407bb8:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407bbc:	91298c21 	add	x1, x1, #0xa63
  407bc0:	97ffff36 	bl	407898 <print_formatted>
  407bc4:	17ffffa7 	b	407a60 <log_output_process+0xe0>
		length = 0;
  407bc8:	52800000 	mov	w0, #0x0                   	// #0
  407bcc:	17ffffa5 	b	407a60 <log_output_process+0xe0>
	int total = 0;
  407bd0:	52800014 	mov	w20, #0x0                   	// #0
  407bd4:	17ffffbc 	b	407ac4 <log_output_process+0x144>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  407bd8:	f100047f 	cmp	x3, #0x1
  407bdc:	540000a0 	b.eq	407bf0 <log_output_process+0x270>  // b.none
  407be0:	90000000 	adrp	x0, 407000 <z_log_init.isra.0+0xc8>
  407be4:	911f9000 	add	x0, x0, #0x7e4
		prefix_offset = 0;
  407be8:	52800014 	mov	w20, #0x0                   	// #0
  407bec:	17ffffc7 	b	407b08 <log_output_process+0x188>
		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
  407bf0:	90000000 	adrp	x0, 407000 <z_log_init.isra.0+0xc8>
  407bf4:	911e1000 	add	x0, x0, #0x784
  407bf8:	17fffffc 	b	407be8 <log_output_process+0x268>
	}

	if (data_len) {
  407bfc:	b4000895 	cbz	x21, 407d0c <log_output_process+0x38c>
		print_formatted(output, " ");
  407c00:	b0000098 	adrp	x24, 418000 <table.0+0x1d8>
  407c04:	912a8b18 	add	x24, x24, #0xaa2
		print_formatted(ctx, "\r\n");
  407c08:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407c0c:	912a5c00 	add	x0, x0, #0xa97
  407c10:	f9003be0 	str	x0, [sp, #112]
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
  407c14:	52800200 	mov	w0, #0x10                  	// #16
  407c18:	6b0002bf 	cmp	w21, w0
  407c1c:	1a8092a1 	csel	w1, w21, w0, ls  // ls = plast
  407c20:	1a8092a0 	csel	w0, w21, w0, ls  // ls = plast
  407c24:	f90033e0 	str	x0, [sp, #96]
  407c28:	b9007be1 	str	w1, [sp, #120]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  407c2c:	372000d6 	tbnz	w22, #4, 407c44 <log_output_process+0x2c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  407c30:	362809b6 	tbz	w22, #5, 407d64 <log_output_process+0x3e4>
		print_formatted(ctx, "\n");
  407c34:	d0000081 	adrp	x1, 419000 <__func__.2+0xa80>
  407c38:	912e7021 	add	x1, x1, #0xb9c
		print_formatted(ctx, "\r\n");
  407c3c:	aa1303e0 	mov	x0, x19
  407c40:	97ffff16 	bl	407898 <print_formatted>
		prefix_offset = 0;
  407c44:	5280001b 	mov	w27, #0x0                   	// #0
	for (int i = 0; i < prefix_offset; i++) {
  407c48:	6b1b029f 	cmp	w20, w27
  407c4c:	5400090c 	b.gt	407d6c <log_output_process+0x3ec>
			print_formatted(output, "%02x ", data[i]);
  407c50:	b000009c 	adrp	x28, 418000 <table.0+0x1d8>
  407c54:	912a6b9c 	add	x28, x28, #0xa9a
			print_formatted(output, "   ");
  407c58:	b0000080 	adrp	x0, 418000 <table.0+0x1d8>
  407c5c:	d280001a 	mov	x26, #0x0                   	// #0
  407c60:	912a8000 	add	x0, x0, #0xaa0
  407c64:	f90037e0 	str	x0, [sp, #104]
		if (i < length) {
  407c68:	b9407be0 	ldr	w0, [sp, #120]
  407c6c:	2a1a03fb 	mov	w27, w26
  407c70:	6b1a001f 	cmp	w0, w26
  407c74:	54000969 	b.ls	407da0 <log_output_process+0x420>  // b.plast
			print_formatted(output, "%02x ", data[i]);
  407c78:	387a6ae2 	ldrb	w2, [x23, x26]
  407c7c:	aa1c03e1 	mov	x1, x28
  407c80:	aa1303e0 	mov	x0, x19
  407c84:	97ffff05 	bl	407898 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  407c88:	f1003f5f 	cmp	x26, #0xf
  407c8c:	540007a1 	b.ne	407d80 <log_output_process+0x400>  // b.any
			print_formatted(output, "%c",
  407c90:	b000009b 	adrp	x27, 418000 <table.0+0x1d8>
  407c94:	912a9b7b 	add	x27, x27, #0xaa6
	print_formatted(output, "|");
  407c98:	d280001c 	mov	x28, #0x0                   	// #0
  407c9c:	528005da 	mov	w26, #0x2e                  	// #46
  407ca0:	aa1303e0 	mov	x0, x19
  407ca4:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407ca8:	912a9021 	add	x1, x1, #0xaa4
  407cac:	97fffefb 	bl	407898 <print_formatted>
		if (i < length) {
  407cb0:	b9407be0 	ldr	w0, [sp, #120]
  407cb4:	b9006bfc 	str	w28, [sp, #104]
  407cb8:	6b1c001f 	cmp	w0, w28
  407cbc:	540008c9 	b.ls	407dd4 <log_output_process+0x454>  // b.plast
			unsigned char c = (unsigned char)data[i];
  407cc0:	387c6ae2 	ldrb	w2, [x23, x28]
  407cc4:	b9007fe2 	str	w2, [sp, #124]
			      isprint((int)c) != 0 ? c : '.');
  407cc8:	97ffe636 	bl	4015a0 <__ctype_b_loc@plt>
  407ccc:	b9407fe2 	ldr	w2, [sp, #124]
  407cd0:	f9400000 	ldr	x0, [x0]
  407cd4:	d37f1c41 	ubfiz	x1, x2, #1, #8
			print_formatted(output, "%c",
  407cd8:	78616800 	ldrh	w0, [x0, x1]
  407cdc:	aa1b03e1 	mov	x1, x27
  407ce0:	f272001f 	tst	x0, #0x4000
  407ce4:	aa1303e0 	mov	x0, x19
  407ce8:	1a9a1042 	csel	w2, w2, w26, ne  // ne = any
  407cec:	97fffeeb 	bl	407898 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
  407cf0:	f1003f9f 	cmp	x28, #0xf
  407cf4:	540005e1 	b.ne	407db0 <log_output_process+0x430>  // b.any
		data += length;
  407cf8:	f94033e0 	ldr	x0, [sp, #96]
  407cfc:	8b0002f7 	add	x23, x23, x0
	} while (len);
  407d00:	b9407be0 	ldr	w0, [sp, #120]
  407d04:	6b0002b5 	subs	w21, w21, w0
  407d08:	54fff861 	b.ne	407c14 <log_output_process+0x294>  // b.any
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
	}

	if (!raw_string) {
  407d0c:	340001d9 	cbz	w25, 407d44 <log_output_process+0x3c4>
	if (color) {
  407d10:	360000f6 	tbz	w22, #0, 407d2c <log_output_process+0x3ac>
		print_formatted(output, "%s", log_color);
  407d14:	b0000082 	adrp	x2, 418000 <table.0+0x1d8>
  407d18:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407d1c:	91286842 	add	x2, x2, #0xa1a
  407d20:	9103dc21 	add	x1, x1, #0xf7
  407d24:	aa1303e0 	mov	x0, x19
  407d28:	97fffedc 	bl	407898 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
  407d2c:	372000d6 	tbnz	w22, #4, 407d44 <log_output_process+0x3c4>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
  407d30:	362805b6 	tbz	w22, #5, 407de4 <log_output_process+0x464>
		print_formatted(ctx, "\n");
  407d34:	d0000081 	adrp	x1, 419000 <__func__.2+0xa80>
  407d38:	912e7021 	add	x1, x1, #0xb9c
		print_formatted(ctx, "\r\n");
  407d3c:	aa1303e0 	mov	x0, x19
  407d40:	97fffed6 	bl	407898 <print_formatted>
		postfix_print(output, flags, level);
	}

	log_output_flush(output);
  407d44:	aa1303e0 	mov	x0, x19
}
  407d48:	a94153f3 	ldp	x19, x20, [sp, #16]
  407d4c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407d50:	a94363f7 	ldp	x23, x24, [sp, #48]
  407d54:	a9446bf9 	ldp	x25, x26, [sp, #64]
  407d58:	a94573fb 	ldp	x27, x28, [sp, #80]
  407d5c:	a8c87bfd 	ldp	x29, x30, [sp], #128
	log_output_flush(output);
  407d60:	17fffefb 	b	40794c <log_output_flush>
		print_formatted(ctx, "\r\n");
  407d64:	f9403be1 	ldr	x1, [sp, #112]
  407d68:	17ffffb5 	b	407c3c <log_output_process+0x2bc>
		print_formatted(output, " ");
  407d6c:	aa1803e1 	mov	x1, x24
  407d70:	aa1303e0 	mov	x0, x19
	for (int i = 0; i < prefix_offset; i++) {
  407d74:	1100077b 	add	w27, w27, #0x1
		print_formatted(output, " ");
  407d78:	97fffec8 	bl	407898 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
  407d7c:	17ffffb3 	b	407c48 <log_output_process+0x2c8>
		if (i > 0 && !(i % 8)) {
  407d80:	1100077b 	add	w27, w27, #0x1
  407d84:	f2400b7f 	tst	x27, #0x7
  407d88:	54000081 	b.ne	407d98 <log_output_process+0x418>  // b.any
			print_formatted(output, " ");
  407d8c:	aa1803e1 	mov	x1, x24
  407d90:	aa1303e0 	mov	x0, x19
  407d94:	97fffec1 	bl	407898 <print_formatted>
  407d98:	9100075a 	add	x26, x26, #0x1
  407d9c:	17ffffb3 	b	407c68 <log_output_process+0x2e8>
			print_formatted(output, "   ");
  407da0:	f94037e1 	ldr	x1, [sp, #104]
  407da4:	aa1303e0 	mov	x0, x19
  407da8:	97fffebc 	bl	407898 <print_formatted>
  407dac:	17ffffb7 	b	407c88 <log_output_process+0x308>
		if (i > 0 && !(i % 8)) {
  407db0:	b9406be0 	ldr	w0, [sp, #104]
  407db4:	11000400 	add	w0, w0, #0x1
  407db8:	f240081f 	tst	x0, #0x7
  407dbc:	54000081 	b.ne	407dcc <log_output_process+0x44c>  // b.any
			print_formatted(output, " ");
  407dc0:	aa1803e1 	mov	x1, x24
  407dc4:	aa1303e0 	mov	x0, x19
  407dc8:	97fffeb4 	bl	407898 <print_formatted>
  407dcc:	9100079c 	add	x28, x28, #0x1
  407dd0:	17ffffb8 	b	407cb0 <log_output_process+0x330>
			print_formatted(output, " ");
  407dd4:	aa1803e1 	mov	x1, x24
  407dd8:	aa1303e0 	mov	x0, x19
  407ddc:	97fffeaf 	bl	407898 <print_formatted>
  407de0:	17ffffc4 	b	407cf0 <log_output_process+0x370>
		print_formatted(ctx, "\r\n");
  407de4:	b0000081 	adrp	x1, 418000 <table.0+0x1d8>
  407de8:	912a5c21 	add	x1, x1, #0xa97
  407dec:	17ffffd4 	b	407d3c <log_output_process+0x3bc>

0000000000407df0 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg, uint32_t flags)
{
  407df0:	d10143ff 	sub	sp, sp, #0x50
  407df4:	a9017bfd 	stp	x29, x30, [sp, #16]
  407df8:	910043fd 	add	x29, sp, #0x10
  407dfc:	a90253f3 	stp	x19, x20, [sp, #32]
  407e00:	aa0003f4 	mov	x20, x0
  407e04:	aa0103f3 	mov	x19, x1
  407e08:	a9035bf5 	stp	x21, x22, [sp, #48]
  407e0c:	2a0203f5 	mov	w21, w2
  407e10:	f90023f7 	str	x23, [sp, #64]
 *
 * @return Pointer to the source data.
 */
static inline const void *log_msg_get_source(struct log_msg *msg)
{
	return msg->hdr.source;
  407e14:	a9400c20 	ldp	x0, x3, [x1]
 *
 * @return Timestamp.
 */
static inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)
{
	return msg->hdr.timestamp;
  407e18:	b9400436 	ldr	w22, [x1, #4]
	return msg->hdr.desc.level;
  407e1c:	d3462017 	ubfx	x23, x0, #6, #3
		/* Remote domain is converting source pointer to ID */
		source_id = (int16_t)(uintptr_t)log_msg_get_source(msg);
	} else {
		void *source = (void *)log_msg_get_source(msg);

		if (source != NULL) {
  407e20:	b4000143 	cbz	x3, 407e48 <log_output_msg_process+0x58>
  407e24:	d0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  407e28:	f9470821 	ldr	x1, [x1, #3600]
  407e2c:	cb010063 	sub	x3, x3, x1
  407e30:	d344fc63 	lsr	x3, x3, #4
			source_id = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
  407e34:	13003c61 	sxth	w1, w3
		} else {
			source_id = -1;
		}
	}

	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  407e38:	377802c3 	tbnz	w3, #15, 407e90 <log_output_msg_process+0xa0>
  407e3c:	53031400 	ubfx	w0, w0, #3, #3
  407e40:	97fffd8d 	bl	407474 <log_source_name_get>
  407e44:	aa0003e3 	mov	x3, x0
 *
 * @return pointer to the package.
 */
static inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;
  407e48:	f8410667 	ldr	x7, [x19], #16
	size_t plen, dlen;
	uint8_t *package = log_msg_get_package(msg, &plen);
	uint8_t *data = log_msg_get_data(msg, &dlen);

	log_output_process(output, timestamp, NULL, sname, level,
  407e4c:	b90003f5 	str	w21, [sp]
  407e50:	2a1703e4 	mov	w4, w23
  407e54:	2a1603e1 	mov	w1, w22
  407e58:	d2800002 	mov	x2, #0x0                   	// #0
  407e5c:	d3494ce0 	ubfx	x0, x7, #9, #11
  407e60:	53147ce7 	lsr	w7, w7, #20
  407e64:	f100001f 	cmp	x0, #0x0
	return msg->data + msg->hdr.desc.package_len;
  407e68:	8b000266 	add	x6, x19, x0
  407e6c:	9a9f1265 	csel	x5, x19, xzr, ne  // ne = any
  407e70:	aa1403e0 	mov	x0, x20
  407e74:	97fffec3 	bl	407980 <log_output_process>
			   plen > 0 ? package : NULL, data, dlen, flags);
}
  407e78:	a9417bfd 	ldp	x29, x30, [sp, #16]
  407e7c:	a94253f3 	ldp	x19, x20, [sp, #32]
  407e80:	a9435bf5 	ldp	x21, x22, [sp, #48]
  407e84:	f94023f7 	ldr	x23, [sp, #64]
  407e88:	910143ff 	add	sp, sp, #0x50
  407e8c:	d65f03c0 	ret
	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
  407e90:	d2800003 	mov	x3, #0x0                   	// #0
  407e94:	17ffffed 	b	407e48 <log_output_msg_process+0x58>

0000000000407e98 <log_output_timestamp_freq_set>:
		     output->control_block->ctx);
}

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
  407e98:	b0000162 	adrp	x2, 434000 <ztest_thread+0xb8>
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
  407e9c:	52884804 	mov	w4, #0x4240                	// #16960
	timestamp_div = 1U;
  407ea0:	52800021 	mov	w1, #0x1                   	// #1
	while (frequency > 1000000) {
  407ea4:	52800003 	mov	w3, #0x0                   	// #0
	timestamp_div = 1U;
  407ea8:	b90dd041 	str	w1, [x2, #3536]
	while (frequency > 1000000) {
  407eac:	72a001e4 	movk	w4, #0xf, lsl #16
  407eb0:	6b04001f 	cmp	w0, w4
  407eb4:	540000c8 	b.hi	407ecc <log_output_timestamp_freq_set+0x34>  // b.pmore
  407eb8:	34000043 	cbz	w3, 407ec0 <log_output_timestamp_freq_set+0x28>
  407ebc:	b90dd041 	str	w1, [x2, #3536]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
  407ec0:	b0000161 	adrp	x1, 434000 <ztest_thread+0xb8>
  407ec4:	b90dcc20 	str	w0, [x1, #3532]
}
  407ec8:	d65f03c0 	ret
		frequency /= 2U;
  407ecc:	53017c00 	lsr	w0, w0, #1
		timestamp_div *= 2U;
  407ed0:	531f7821 	lsl	w1, w1, #1
  407ed4:	52800023 	mov	w3, #0x1                   	// #1
  407ed8:	17fffff6 	b	407eb0 <log_output_timestamp_freq_set+0x18>

0000000000407edc <format_set>:
	log_output_func(&log_output_posix, &msg->log, flags);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
	log_format_current = log_type;
  407edc:	b0000160 	adrp	x0, 434000 <ztest_thread+0xb8>
  407ee0:	b90dd401 	str	w1, [x0, #3540]
	return 0;
}
  407ee4:	52800000 	mov	w0, #0x0                   	// #0
  407ee8:	d65f03c0 	ret

0000000000407eec <panic>:
	log_output_flush(&log_output_posix);
  407eec:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  407ef0:	911ec000 	add	x0, x0, #0x7b0
  407ef4:	17fffe96 	b	40794c <log_output_flush>

0000000000407ef8 <char_out>:
{
  407ef8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  407efc:	910003fd 	mov	x29, sp
  407f00:	a90153f3 	stp	x19, x20, [sp, #16]
  407f04:	b0000174 	adrp	x20, 434000 <ztest_thread+0xb8>
  407f08:	aa0003f3 	mov	x19, x0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  407f0c:	91376294 	add	x20, x20, #0xdd8
{
  407f10:	a9025bf5 	stp	x21, x22, [sp, #32]
		posix_print_trace("%s\n", stdout_buff);
  407f14:	b0000175 	adrp	x21, 434000 <ztest_thread+0xb8>
{
  407f18:	aa0103f6 	mov	x22, x1
		posix_print_trace("%s\n", stdout_buff);
  407f1c:	913cfeb5 	add	x21, x21, #0xf3f
{
  407f20:	a90363f7 	stp	x23, x24, [sp, #48]
  407f24:	8b010017 	add	x23, x0, x1
		posix_print_trace("%s\n", stdout_buff);
  407f28:	d0000098 	adrp	x24, 419000 <__func__.2+0xa80>
	for (size_t i = 0; i < length; i++) {
  407f2c:	eb17027f 	cmp	x19, x23
  407f30:	540000e1 	b.ne	407f4c <char_out+0x54>  // b.any
}
  407f34:	2a1603e0 	mov	w0, w22
  407f38:	a94153f3 	ldp	x19, x20, [sp, #16]
  407f3c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  407f40:	a94363f7 	ldp	x23, x24, [sp, #48]
  407f44:	a8c47bfd 	ldp	x29, x30, [sp], #64
  407f48:	d65f03c0 	ret
		preprint_char(data[i]);
  407f4c:	39400260 	ldrb	w0, [x19]
	if (c == '\r') {
  407f50:	7100341f 	cmp	w0, #0xd
  407f54:	54000240 	b.eq	407f9c <char_out+0xa4>  // b.none
	if (c != '\n') {
  407f58:	7100281f 	cmp	w0, #0xa
  407f5c:	54000240 	b.eq	407fa4 <char_out+0xac>  // b.none
		stdout_buff[n_pend++] = c;
  407f60:	b9400282 	ldr	w2, [x20]
  407f64:	11000441 	add	w1, w2, #0x1
  407f68:	b9000281 	str	w1, [x20]
  407f6c:	3822caa0 	strb	w0, [x21, w2, sxtw]
	int printnow = 0;
  407f70:	52800000 	mov	w0, #0x0                   	// #0
		stdout_buff[n_pend] = 0;
  407f74:	3821cabf 	strb	wzr, [x21, w1, sxtw]
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  407f78:	b9400281 	ldr	w1, [x20]
  407f7c:	7103f83f 	cmp	w1, #0xfe
  407f80:	5400004c 	b.gt	407f88 <char_out+0x90>
	if (printnow) {
  407f84:	340000c0 	cbz	w0, 407f9c <char_out+0xa4>
		posix_print_trace("%s\n", stdout_buff);
  407f88:	aa1503e1 	mov	x1, x21
  407f8c:	9122eb00 	add	x0, x24, #0x8ba
  407f90:	94000628 	bl	409830 <posix_print_trace>
		stdout_buff[0] = 0;
  407f94:	390002bf 	strb	wzr, [x21]
		n_pend = 0;
  407f98:	b900029f 	str	wzr, [x20]
	for (size_t i = 0; i < length; i++) {
  407f9c:	91000673 	add	x19, x19, #0x1
  407fa0:	17ffffe3 	b	407f2c <char_out+0x34>
		printnow = 1;
  407fa4:	52800020 	mov	w0, #0x1                   	// #1
  407fa8:	17fffff4 	b	407f78 <char_out+0x80>

0000000000407fac <process>:
{
  407fac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  407fb0:	b0000160 	adrp	x0, 434000 <ztest_thread+0xb8>
{
  407fb4:	910003fd 	mov	x29, sp
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  407fb8:	b94dd400 	ldr	w0, [x0, #3540]
{
  407fbc:	f9000bf3 	str	x19, [sp, #16]
  407fc0:	aa0103f3 	mov	x19, x1
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
  407fc4:	97fffc5c 	bl	407134 <log_format_func_t_get>
  407fc8:	aa0003f0 	mov	x16, x0
	log_output_func(&log_output_posix, &msg->log, flags);
  407fcc:	aa1303e1 	mov	x1, x19
  407fd0:	528001e2 	mov	w2, #0xf                   	// #15
}
  407fd4:	f9400bf3 	ldr	x19, [sp, #16]
	log_output_func(&log_output_posix, &msg->log, flags);
  407fd8:	d0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
}
  407fdc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	log_output_func(&log_output_posix, &msg->log, flags);
  407fe0:	911ec000 	add	x0, x0, #0x7b0
  407fe4:	d61f0200 	br	x16

0000000000407fe8 <sys_trace_isr_enter>:
 *
 * SPDX-License-Identifier: Apache-2.0
 */


void sys_trace_isr_enter(void) {}
  407fe8:	d65f03c0 	ret

0000000000407fec <sys_trace_isr_exit>:
  407fec:	d65f03c0 	ret

0000000000407ff0 <sys_trace_idle>:
  407ff0:	d65f03c0 	ret

0000000000407ff4 <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
  407ff4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  407ff8:	910003fd 	mov	x29, sp
	sys_trace_idle();
  407ffc:	97fffffd 	bl	407ff0 <sys_trace_idle>
	posix_irq_full_unlock();
  408000:	94000493 	bl	40924c <posix_irq_full_unlock>
	posix_halt_cpu();
}
  408004:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_halt_cpu();
  408008:	140001d9 	b	40876c <posix_halt_cpu>

000000000040800c <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
  40800c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
  408010:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408014:	912b8800 	add	x0, x0, #0xae2
{
  408018:	910003fd 	mov	x29, sp
	posix_print_error_and_exit("Exiting due to fatal error\n");
  40801c:	9400059f 	bl	409698 <posix_print_error_and_exit>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  408020:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408024:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408028:	912bf821 	add	x1, x1, #0xafe
  40802c:	91187800 	add	x0, x0, #0x61e
  408030:	528002a2 	mov	w2, #0x15                  	// #21
  408034:	94000599 	bl	409698 <posix_print_error_and_exit>

0000000000408038 <arch_irq_enable>:
}
#endif

void arch_irq_enable(unsigned int irq)
{
	posix_irq_enable(irq);
  408038:	14000487 	b	409254 <posix_irq_enable>

000000000040803c <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
  40803c:	34000080 	cbz	w0, 40804c <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  408040:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408044:	912ca400 	add	x0, x0, #0xb29
  408048:	14000594 	b	409698 <posix_print_error_and_exit>
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
  40804c:	d65f03c0 	ret

0000000000408050 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
  408050:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408054:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  408058:	912b4000 	add	x0, x0, #0xad0
{
  40805c:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408060:	97ffe59c 	bl	4016d0 <pthread_mutex_unlock@plt>
  408064:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408068:	912d0c21 	add	x1, x1, #0xb43
  40806c:	97fffff4 	bl	40803c <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  408070:	97ffe588 	bl	401690 <pthread_self@plt>
}
  408074:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  408078:	17ffe54e 	b	4015b0 <pthread_detach@plt>

000000000040807c <abort_tail>:
{
  40807c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	threads_table[this_th_nbr].running = false;
  408080:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  408084:	937b7c00 	sbfiz	x0, x0, #5, #32
{
  408088:	910003fd 	mov	x29, sp
	threads_table[this_th_nbr].running = false;
  40808c:	f9458021 	ldr	x1, [x1, #2816]
  408090:	8b000022 	add	x2, x1, x0
  408094:	3900105f 	strb	wzr, [x2, #4]
	threads_table[this_th_nbr].state = ABORTED;
  408098:	52800062 	mov	w2, #0x3                   	// #3
  40809c:	b8206822 	str	w2, [x1, x0]
	posix_preexit_cleanup();
  4080a0:	97ffffec 	bl	408050 <posix_preexit_cleanup>
	pthread_exit(NULL);
  4080a4:	d2800000 	mov	x0, #0x0                   	// #0
  4080a8:	97ffe532 	bl	401570 <pthread_exit@plt>

00000000004080ac <posix_wait_until_allowed>:
{
  4080ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4080b0:	910003fd 	mov	x29, sp
  4080b4:	a9025bf5 	stp	x21, x22, [sp, #32]
	threads_table[this_th_nbr].running = false;
  4080b8:	f0000155 	adrp	x21, 433000 <obj_0x28+0x18>
	while (this_th_nbr != currently_allowed_thread) {
  4080bc:	90000176 	adrp	x22, 434000 <ztest_thread+0xb8>
{
  4080c0:	a90153f3 	stp	x19, x20, [sp, #16]
	threads_table[this_th_nbr].running = false;
  4080c4:	937b7c14 	sbfiz	x20, x0, #5, #32
{
  4080c8:	2a0003f3 	mov	w19, w0
	threads_table[this_th_nbr].running = false;
  4080cc:	f94582a0 	ldr	x0, [x21, #2816]
	while (this_th_nbr != currently_allowed_thread) {
  4080d0:	913772d6 	add	x22, x22, #0xddc
{
  4080d4:	a90363f7 	stp	x23, x24, [sp, #48]
		pthread_cond_wait(&cond_threads, &mtx_threads);
  4080d8:	f0000157 	adrp	x23, 433000 <obj_0x28+0x18>
	threads_table[this_th_nbr].running = false;
  4080dc:	8b140000 	add	x0, x0, x20
		pthread_cond_wait(&cond_threads, &mtx_threads);
  4080e0:	f0000158 	adrp	x24, 433000 <obj_0x28+0x18>
  4080e4:	912b42f7 	add	x23, x23, #0xad0
  4080e8:	912a8318 	add	x24, x24, #0xaa0
	threads_table[this_th_nbr].running = false;
  4080ec:	3900101f 	strb	wzr, [x0, #4]
	while (this_th_nbr != currently_allowed_thread) {
  4080f0:	b94002c0 	ldr	w0, [x22]
  4080f4:	6b13001f 	cmp	w0, w19
  4080f8:	54000141 	b.ne	408120 <posix_wait_until_allowed+0x74>  // b.any
	threads_table[this_th_nbr].running = true;
  4080fc:	f94582a0 	ldr	x0, [x21, #2816]
  408100:	52800021 	mov	w1, #0x1                   	// #1
  408104:	8b140000 	add	x0, x0, x20
  408108:	39001001 	strb	w1, [x0, #4]
}
  40810c:	a94153f3 	ldp	x19, x20, [sp, #16]
  408110:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408114:	a94363f7 	ldp	x23, x24, [sp, #48]
  408118:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40811c:	d65f03c0 	ret
		pthread_cond_wait(&cond_threads, &mtx_threads);
  408120:	aa1703e1 	mov	x1, x23
  408124:	aa1803e0 	mov	x0, x24
  408128:	97ffe52e 	bl	4015e0 <pthread_cond_wait@plt>
		if (threads_table &&
  40812c:	f94582a0 	ldr	x0, [x21, #2816]
  408130:	b4fffe00 	cbz	x0, 4080f0 <posix_wait_until_allowed+0x44>
  408134:	b8746800 	ldr	w0, [x0, x20]
  408138:	7100081f 	cmp	w0, #0x2
  40813c:	54fffda1 	b.ne	4080f0 <posix_wait_until_allowed+0x44>  // b.any
			abort_tail(this_th_nbr);
  408140:	2a1303e0 	mov	w0, w19
  408144:	97ffffce 	bl	40807c <abort_tail>

0000000000408148 <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
  408148:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  40814c:	3940fc00 	ldrb	w0, [x0, #63]
  408150:	34000180 	cbz	w0, 408180 <posix_cleanup_handler+0x38>
{
  408154:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408158:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  40815c:	912b4000 	add	x0, x0, #0xad0
{
  408160:	910003fd 	mov	x29, sp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
  408164:	97ffe55b 	bl	4016d0 <pthread_mutex_unlock@plt>
  408168:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  40816c:	912d0c21 	add	x1, x1, #0xb43
  408170:	97ffffb3 	bl	40803c <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
  408174:	97ffe547 	bl	401690 <pthread_self@plt>
}
  408178:	a8c17bfd 	ldp	x29, x30, [sp], #16
	pthread_detach(pthread_self());
  40817c:	17ffe50d 	b	4015b0 <pthread_detach@plt>
  408180:	d65f03c0 	ret

0000000000408184 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
  408184:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  408188:	910003fd 	mov	x29, sp
  40818c:	f9000be0 	str	x0, [sp, #16]
  408190:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408194:	f9475c00 	ldr	x0, [x0, #3768]
  408198:	f9400001 	ldr	x1, [x0]
  40819c:	f9007fe1 	str	x1, [sp, #248]
  4081a0:	d2800001 	mov	x1, #0x0                   	// #0

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  4081a4:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  4081a8:	912b4000 	add	x0, x0, #0xad0
  4081ac:	97ffe545 	bl	4016c0 <pthread_mutex_lock@plt>
  4081b0:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  4081b4:	912d9821 	add	x1, x1, #0xb66
  4081b8:	97ffffa1 	bl	40803c <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
  4081bc:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  4081c0:	f9458000 	ldr	x0, [x0, #2816]
  4081c4:	b50000a0 	cbnz	x0, 4081d8 <posix_thread_starter+0x54>
		posix_cleanup_handler(arg);
  4081c8:	f9400be0 	ldr	x0, [sp, #16]
  4081cc:	97ffffdf 	bl	408148 <posix_cleanup_handler>
		pthread_exit(NULL);
  4081d0:	d2800000 	mov	x0, #0x0                   	// #0
  4081d4:	97ffe4e7 	bl	401570 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
  4081d8:	90000000 	adrp	x0, 408000 <arch_cpu_idle+0xc>
  4081dc:	91052000 	add	x0, x0, #0x148
  4081e0:	52800001 	mov	w1, #0x0                   	// #0
  4081e4:	f9000fe0 	str	x0, [sp, #24]
  4081e8:	910083e0 	add	x0, sp, #0x20
  4081ec:	97ffe479 	bl	4013d0 <__sigsetjmp@plt>
  4081f0:	340000a0 	cbz	w0, 408204 <posix_thread_starter+0x80>
  4081f4:	a94107e0 	ldp	x0, x1, [sp, #16]
  4081f8:	d63f0020 	blr	x1
  4081fc:	910083e0 	add	x0, sp, #0x20
  408200:	97ffe500 	bl	401600 <__pthread_unwind_next@plt>
  408204:	910083e0 	add	x0, sp, #0x20
  408208:	97ffe51e 	bl	401680 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
  40820c:	b94013e0 	ldr	w0, [sp, #16]
  408210:	97ffffa7 	bl	4080ac <posix_wait_until_allowed>

	posix_new_thread_pre_start();
  408214:	94000108 	bl	408634 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
  408218:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  40821c:	b94013e0 	ldr	w0, [sp, #16]
  408220:	f9458021 	ldr	x1, [x1, #2816]
  408224:	937b7c00 	sbfiz	x0, x0, #5, #32
  408228:	8b000020 	add	x0, x1, x0
  40822c:	f9400c00 	ldr	x0, [x0, #24]

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
  408230:	a9410c02 	ldp	x2, x3, [x0, #16]
  408234:	f9400401 	ldr	x1, [x0, #8]
  408238:	f9400000 	ldr	x0, [x0]
  40823c:	97fff551 	bl	405780 <z_thread_entry>

0000000000408240 <posix_swap>:
{
  408240:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408244:	910003fd 	mov	x29, sp
  408248:	f9000bf3 	str	x19, [sp, #16]
  40824c:	2a0103f3 	mov	w19, w1
	currently_allowed_thread = next_allowed_th;
  408250:	90000161 	adrp	x1, 434000 <ztest_thread+0xb8>
  408254:	b90ddc20 	str	w0, [x1, #3548]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  408258:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  40825c:	912a8000 	add	x0, x0, #0xaa0
  408260:	97ffe4a0 	bl	4014e0 <pthread_cond_broadcast@plt>
  408264:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408268:	912e1c21 	add	x1, x1, #0xb87
  40826c:	97ffff74 	bl	40803c <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
  408270:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  408274:	937b7e60 	sbfiz	x0, x19, #5, #32
  408278:	f9458021 	ldr	x1, [x1, #2816]
  40827c:	b8606820 	ldr	w0, [x1, x0]
  408280:	7100081f 	cmp	w0, #0x2
		abort_tail(this_th_nbr);
  408284:	2a1303e0 	mov	w0, w19
	if (threads_table[this_th_nbr].state == ABORTING) {
  408288:	54000041 	b.ne	408290 <posix_swap+0x50>  // b.any
		abort_tail(this_th_nbr);
  40828c:	97ffff7c 	bl	40807c <abort_tail>
}
  408290:	f9400bf3 	ldr	x19, [sp, #16]
  408294:	a8c27bfd 	ldp	x29, x30, [sp], #32
		posix_wait_until_allowed(this_th_nbr);
  408298:	17ffff85 	b	4080ac <posix_wait_until_allowed>

000000000040829c <posix_main_thread_start>:
{
  40829c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	currently_allowed_thread = next_allowed_th;
  4082a0:	90000161 	adrp	x1, 434000 <ztest_thread+0xb8>
{
  4082a4:	910003fd 	mov	x29, sp
	currently_allowed_thread = next_allowed_th;
  4082a8:	b90ddc20 	str	w0, [x1, #3548]
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
  4082ac:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  4082b0:	912a8000 	add	x0, x0, #0xaa0
  4082b4:	97ffe48b 	bl	4014e0 <pthread_cond_broadcast@plt>
  4082b8:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  4082bc:	912e1c21 	add	x1, x1, #0xb87
  4082c0:	97ffff5f 	bl	40803c <pc_safe_call>
	posix_preexit_cleanup();
  4082c4:	97ffff63 	bl	408050 <posix_preexit_cleanup>
	pthread_exit(NULL);
  4082c8:	d2800000 	mov	x0, #0x0                   	// #0
  4082cc:	97ffe4a9 	bl	401570 <pthread_exit@plt>

00000000004082d0 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
  4082d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (int i = 0; i < threads_table_size; i++) {
  4082d4:	d2800002 	mov	x2, #0x0                   	// #0
{
  4082d8:	910003fd 	mov	x29, sp
  4082dc:	a9025bf5 	stp	x21, x22, [sp, #32]
		if ((threads_table[i].state == NOTUSED)
  4082e0:	f0000155 	adrp	x21, 433000 <obj_0x28+0x18>
	for (int i = 0; i < threads_table_size; i++) {
  4082e4:	90000176 	adrp	x22, 434000 <ztest_thread+0xb8>
{
  4082e8:	a90153f3 	stp	x19, x20, [sp, #16]
  4082ec:	aa0003f4 	mov	x20, x0
	for (int i = 0; i < threads_table_size; i++) {
  4082f0:	b94de6c1 	ldr	w1, [x22, #3556]
		if ((threads_table[i].state == NOTUSED)
  4082f4:	f94582a0 	ldr	x0, [x21, #2816]
  4082f8:	d1008003 	sub	x3, x0, #0x20
  4082fc:	2a0203f3 	mov	w19, w2
	for (int i = 0; i < threads_table_size; i++) {
  408300:	6b02003f 	cmp	w1, w2
  408304:	5400026c 	b.gt	408350 <posix_new_thread+0x80>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
  408308:	11010021 	add	w1, w1, #0x40
	threads_table = realloc(threads_table,
  40830c:	937b7c21 	sbfiz	x1, x1, #5, #32
  408310:	97ffe47c 	bl	401500 <realloc@plt>
  408314:	f90582a0 	str	x0, [x21, #2816]
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  408318:	b5000080 	cbnz	x0, 408328 <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  40831c:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408320:	912eb400 	add	x0, x0, #0xbad
  408324:	940004dd 	bl	409698 <posix_print_error_and_exit>
	(void)memset(&threads_table[threads_table_size], 0,
  408328:	b94de6d3 	ldr	w19, [x22, #3556]
   case no work is done at all.  We detect these problems by referring
   non-existing functions.  */
__fortify_function void *
__NTH (memset (void *__dest, int __ch, size_t __len))
{
  return __builtin___memset_chk (__dest, __ch, __len,
  40832c:	d2810002 	mov	x2, #0x800                 	// #2048
  408330:	f94582a3 	ldr	x3, [x21, #2816]
  408334:	52800001 	mov	w1, #0x0                   	// #0
  408338:	937b7e60 	sbfiz	x0, x19, #5, #32
  40833c:	8b000060 	add	x0, x3, x0
  408340:	97ffe454 	bl	401490 <memset@plt>
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
  408344:	11010260 	add	w0, w19, #0x40
  408348:	b90de6c0 	str	w0, [x22, #3556]
	return threads_table_size - PC_ALLOC_CHUNK_SIZE;
  40834c:	14000005 	b	408360 <posix_new_thread+0x90>
		if ((threads_table[i].state == NOTUSED)
  408350:	91000442 	add	x2, x2, #0x1
  408354:	d37be844 	lsl	x4, x2, #5
  408358:	b8646864 	ldr	w4, [x3, x4]
  40835c:	35fffd04 	cbnz	w4, 4082fc <posix_new_thread+0x2c>
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
  408360:	f94582a1 	ldr	x1, [x21, #2816]
  408364:	937b7e60 	sbfiz	x0, x19, #5, #32
  408368:	52800022 	mov	w2, #0x1                   	// #1
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
	threads_table[t_slot].t_status = ptr;
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  40836c:	93407e63 	sxtw	x3, w19
	threads_table[t_slot].state = USED;
  408370:	8b000024 	add	x4, x1, x0
  408374:	b8206822 	str	w2, [x1, x0]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  408378:	90000161 	adrp	x1, 434000 <ztest_thread+0xb8>
  40837c:	b94de020 	ldr	w0, [x1, #3552]
	threads_table[t_slot].running = false;
  408380:	3900109f 	strb	wzr, [x4, #4]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  408384:	b9001080 	str	w0, [x4, #16]
  408388:	0b020002 	add	w2, w0, w2
	threads_table[t_slot].t_status = ptr;
  40838c:	f9000c94 	str	x20, [x4, #24]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  408390:	91002080 	add	x0, x4, #0x8
	ptr->thread_idx = t_slot;
  408394:	b9002293 	str	w19, [x20, #32]
	threads_table[t_slot].thead_cnt = thread_create_count++;
  408398:	b90de022 	str	w2, [x1, #3552]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  40839c:	d2800001 	mov	x1, #0x0                   	// #0
  4083a0:	90000002 	adrp	x2, 408000 <arch_cpu_idle+0xc>
  4083a4:	91061042 	add	x2, x2, #0x184
  4083a8:	97ffe4a2 	bl	401630 <pthread_create@plt>
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
  4083ac:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  4083b0:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
}
  4083b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  4083b8:	912f5421 	add	x1, x1, #0xbd5
}
  4083bc:	a8c37bfd 	ldp	x29, x30, [sp], #48
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
  4083c0:	17ffff1f 	b	40803c <pc_safe_call>

00000000004083c4 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
  4083c4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_create_count = 0;
  4083c8:	90000160 	adrp	x0, 434000 <ztest_thread+0xb8>

	currently_allowed_thread = -1;
  4083cc:	12800001 	mov	w1, #0xffffffff            	// #-1
{
  4083d0:	910003fd 	mov	x29, sp
	thread_create_count = 0;
  4083d4:	b90de01f 	str	wzr, [x0, #3552]
	currently_allowed_thread = -1;
  4083d8:	90000160 	adrp	x0, 434000 <ztest_thread+0xb8>
  4083dc:	b90ddc01 	str	w1, [x0, #3548]

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
  4083e0:	d2800401 	mov	x1, #0x20                  	// #32
  4083e4:	d2800800 	mov	x0, #0x40                  	// #64
  4083e8:	97ffe43a 	bl	4014d0 <calloc@plt>
  4083ec:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  4083f0:	f9058020 	str	x0, [x1, #2816]
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
  4083f4:	b5000080 	cbnz	x0, 408404 <posix_init_multithreading+0x40>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
  4083f8:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  4083fc:	912eb400 	add	x0, x0, #0xbad
  408400:	940004a6 	bl	409698 <posix_print_error_and_exit>
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
  408404:	52800801 	mov	w1, #0x40                  	// #64
  408408:	90000160 	adrp	x0, 434000 <ztest_thread+0xb8>
  40840c:	b90de401 	str	w1, [x0, #3556]


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  408410:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  408414:	912b4000 	add	x0, x0, #0xad0
  408418:	97ffe4aa 	bl	4016c0 <pthread_mutex_lock@plt>
}
  40841c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
  408420:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408424:	912d9821 	add	x1, x1, #0xb66
  408428:	17ffff05 	b	40803c <pc_safe_call>

000000000040842c <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
  40842c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  408430:	910003fd 	mov	x29, sp
  408434:	a9025bf5 	stp	x21, x22, [sp, #32]

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  408438:	f0000155 	adrp	x21, 433000 <obj_0x28+0x18>
  40843c:	f94582a0 	ldr	x0, [x21, #2816]
{
  408440:	a90153f3 	stp	x19, x20, [sp, #16]
  408444:	f9001bf7 	str	x23, [sp, #48]
	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
  408448:	b4000200 	cbz	x0, 408488 <posix_core_clean_up+0x5c>
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;
  40844c:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>

	for (int i = 0; i < threads_table_size; i++) {
  408450:	90000174 	adrp	x20, 434000 <ztest_thread+0xb8>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
			posix_print_warning(
  408454:	90000096 	adrp	x22, 418000 <table.0+0x1d8>
	for (int i = 0; i < threads_table_size; i++) {
  408458:	91379294 	add	x20, x20, #0xde4
			posix_print_warning(
  40845c:	9130e6d6 	add	x22, x22, #0xc39
	terminate = true;
  408460:	52800021 	mov	w1, #0x1                   	// #1
	for (int i = 0; i < threads_table_size; i++) {
  408464:	d2800013 	mov	x19, #0x0                   	// #0
	terminate = true;
  408468:	3900fc01 	strb	w1, [x0, #63]
	for (int i = 0; i < threads_table_size; i++) {
  40846c:	b9400281 	ldr	w1, [x20]
		if (threads_table[i].state != USED) {
  408470:	912c02b7 	add	x23, x21, #0xb00
  408474:	f94582a0 	ldr	x0, [x21, #2816]
	for (int i = 0; i < threads_table_size; i++) {
  408478:	6b13003f 	cmp	w1, w19
  40847c:	5400010c 	b.gt	40849c <posix_core_clean_up+0x70>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
  408480:	97ffe454 	bl	4015d0 <free@plt>
	threads_table = NULL;
  408484:	f90002ff 	str	xzr, [x23]
}
  408488:	a94153f3 	ldp	x19, x20, [sp, #16]
  40848c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408490:	f9401bf7 	ldr	x23, [sp, #48]
  408494:	a8c47bfd 	ldp	x29, x30, [sp], #64
  408498:	d65f03c0 	ret
		if (threads_table[i].state != USED) {
  40849c:	d37bea61 	lsl	x1, x19, #5
  4084a0:	8b131402 	add	x2, x0, x19, lsl #5
  4084a4:	b8616800 	ldr	w0, [x0, x1]
  4084a8:	7100041f 	cmp	w0, #0x1
  4084ac:	540000e1 	b.ne	4084c8 <posix_core_clean_up+0x9c>  // b.any
		if (pthread_cancel(threads_table[i].thread)) {
  4084b0:	f9400440 	ldr	x0, [x2, #8]
  4084b4:	97ffe47f 	bl	4016b0 <pthread_cancel@plt>
  4084b8:	34000080 	cbz	w0, 4084c8 <posix_core_clean_up+0x9c>
			posix_print_warning(
  4084bc:	2a1303e1 	mov	w1, w19
  4084c0:	aa1603e0 	mov	x0, x22
  4084c4:	940004a9 	bl	409768 <posix_print_warning>
	for (int i = 0; i < threads_table_size; i++) {
  4084c8:	91000673 	add	x19, x19, #0x1
  4084cc:	17ffffe8 	b	40846c <posix_core_clean_up+0x40>

00000000004084d0 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
  4084d0:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  4084d4:	937b7c00 	sbfiz	x0, x0, #5, #32
  4084d8:	f9458021 	ldr	x1, [x1, #2816]
  4084dc:	b8606822 	ldr	w2, [x1, x0]
  4084e0:	7100045f 	cmp	w2, #0x1
  4084e4:	54000061 	b.ne	4084f0 <posix_abort_thread+0x20>  // b.any

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
  4084e8:	52800042 	mov	w2, #0x2                   	// #2
  4084ec:	b8206822 	str	w2, [x1, x0]
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
  4084f0:	d65f03c0 	ret

00000000004084f4 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
  4084f4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4084f8:	910003fd 	mov	x29, sp
  4084fc:	a90153f3 	stp	x19, x20, [sp, #16]
  408500:	aa0003f4 	mov	x20, x0
  408504:	a9025bf5 	stp	x21, x22, [sp, #32]
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
  408508:	f9402813 	ldr	x19, [x0, #80]
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
  40850c:	b9402276 	ldr	w22, [x19, #32]
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
  408510:	9400034c 	bl	409240 <posix_irq_lock>
  408514:	2a0003f5 	mov	w21, w0

	key = irq_lock();

	if (_current == thread) {
  408518:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40851c:	f9471000 	ldr	x0, [x0, #3616]
  408520:	f9400800 	ldr	x0, [x0, #16]
  408524:	eb14001f 	cmp	x0, x20
  408528:	54000141 	b.ne	408550 <z_impl_k_thread_abort+0x5c>  // b.any
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
  40852c:	b9402660 	ldr	w0, [x19, #36]
  408530:	350002a0 	cbnz	w0, 408584 <z_impl_k_thread_abort+0x90>
			tstatus->aborted = 1;
  408534:	52800020 	mov	w0, #0x1                   	// #1
  408538:	b9002660 	str	w0, [x19, #36]
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
  40853c:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  408540:	937b7ec0 	sbfiz	x0, x22, #5, #32
  408544:	52800042 	mov	w2, #0x2                   	// #2
  408548:	f9458021 	ldr	x1, [x1, #2816]
  40854c:	b8206822 	str	w2, [x1, x0]
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
  408550:	aa1403e0 	mov	x0, x20
  408554:	940037dc 	bl	4164c4 <z_thread_abort>

	if (tstatus->aborted == 0) {
  408558:	b9402660 	ldr	w0, [x19, #36]
  40855c:	350000a0 	cbnz	w0, 408570 <z_impl_k_thread_abort+0x7c>
		PC_DEBUG("%s aborting now [%i] %i\n",
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
  408560:	52800020 	mov	w0, #0x1                   	// #1
  408564:	b9002660 	str	w0, [x19, #36]
		posix_abort_thread(thread_idx);
  408568:	2a1603e0 	mov	w0, w22
  40856c:	97ffffd9 	bl	4084d0 <posix_abort_thread>
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
  408570:	2a1503e0 	mov	w0, w21
}
  408574:	a94153f3 	ldp	x19, x20, [sp, #16]
  408578:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40857c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule_irqlock(key);
  408580:	140030c3 	b	41488c <z_reschedule_irqlock>
			posix_print_warning(/* LCOV_EXCL_LINE */
  408584:	2a1603e1 	mov	w1, w22
  408588:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  40858c:	9131b400 	add	x0, x0, #0xc6d
  408590:	94000476 	bl	409768 <posix_print_warning>
  408594:	17ffffea 	b	40853c <z_impl_k_thread_abort+0x48>

0000000000408598 <arch_swap>:
#include <zephyr/irq.h>
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
  408598:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40859c:	910003fd 	mov	x29, sp
  4085a0:	f9000bf3 	str	x19, [sp, #16]
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
  4085a4:	b0000153 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  4085a8:	f9471273 	ldr	x19, [x19, #3616]
  4085ac:	f9400a61 	ldr	x1, [x19, #16]
  4085b0:	b9004820 	str	w0, [x1, #72]
	_current->callee_saved.retval = -EAGAIN;
  4085b4:	12800140 	mov	w0, #0xfffffff5            	// #-11
  4085b8:	b9004c20 	str	w0, [x1, #76]
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
  4085bc:	f9401660 	ldr	x0, [x19, #40]
	posix_thread_status_t *this_thread_ptr  =
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
  4085c0:	f9000a60 	str	x0, [x19, #16]
	posix_thread_status_t *this_thread_ptr  =
  4085c4:	f9402821 	ldr	x1, [x1, #80]
	posix_thread_status_t *ready_thread_ptr =
  4085c8:	f9402802 	ldr	x2, [x0, #80]
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
  4085cc:	b9402021 	ldr	w1, [x1, #32]
  4085d0:	b9402040 	ldr	w0, [x2, #32]
  4085d4:	97ffff1b 	bl	408240 <posix_swap>
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
  4085d8:	f9400a60 	ldr	x0, [x19, #16]
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
  4085dc:	b9404800 	ldr	w0, [x0, #72]
  4085e0:	9400031a 	bl	409248 <posix_irq_unlock>

	return _current->callee_saved.retval;
  4085e4:	f9400a60 	ldr	x0, [x19, #16]
}
  4085e8:	f9400bf3 	ldr	x19, [sp, #16]
  4085ec:	b9404c00 	ldr	w0, [x0, #76]
  4085f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4085f4:	d65f03c0 	ret

00000000004085f8 <arch_switch_to_main_thread>:
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
  4085f8:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4085fc:	f9471000 	ldr	x0, [x0, #3616]
  408600:	f9401401 	ldr	x1, [x0, #40]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
  408604:	f9000801 	str	x1, [x0, #16]
	posix_thread_status_t *ready_thread_ptr =
  408608:	f9402822 	ldr	x2, [x1, #80]

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
  40860c:	b9402040 	ldr	w0, [x2, #32]
  408610:	17ffff23 	b	40829c <posix_main_thread_start>

0000000000408614 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
  408614:	aa0003e1 	mov	x1, x0
	posix_thread_status_t *thread_status;

	/* We store it in the same place where normal archs store the
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
  408618:	d100a040 	sub	x0, x2, #0x28

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
  40861c:	f81d8043 	stur	x3, [x2, #-40]
	thread_status->arg1 = p1;
	thread_status->arg2 = p2;
  408620:	a9009404 	stp	x4, x5, [x0, #8]
	thread_status->arg3 = p3;
  408624:	f9000c06 	str	x6, [x0, #24]
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
  408628:	b900241f 	str	wzr, [x0, #36]
#endif

	thread->callee_saved.thread_status = thread_status;
  40862c:	f9002820 	str	x0, [x1, #80]

	posix_new_thread(thread_status);
  408630:	17ffff28 	b	4082d0 <posix_new_thread>

0000000000408634 <posix_new_thread_pre_start>:
}

void posix_new_thread_pre_start(void)
{
	posix_irq_full_unlock();
  408634:	14000306 	b	40924c <posix_irq_full_unlock>

0000000000408638 <pc_safe_call>:
	if (unlikely(test)) {
  408638:	34000080 	cbz	w0, 408648 <pc_safe_call+0x10>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  40863c:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408640:	912ca400 	add	x0, x0, #0xb29
  408644:	14000415 	b	409698 <posix_print_error_and_exit>
}
  408648:	d65f03c0 	ret

000000000040864c <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
  40864c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408650:	910003fd 	mov	x29, sp
  408654:	f9000bf3 	str	x19, [sp, #16]
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  408658:	f0000153 	adrp	x19, 433000 <obj_0x28+0x18>
  40865c:	912ce273 	add	x19, x19, #0xb38
  408660:	aa1303e0 	mov	x0, x19
  408664:	97ffe417 	bl	4016c0 <pthread_mutex_lock@plt>
  408668:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  40866c:	9133a421 	add	x1, x1, #0xce9
  408670:	97fffff2 	bl	408638 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  408674:	aa1303e0 	mov	x0, x19
  408678:	97ffe416 	bl	4016d0 <pthread_mutex_unlock@plt>
  40867c:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408680:	91341821 	add	x1, x1, #0xd06
  408684:	97ffffed 	bl	408638 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
  408688:	97ffff4f 	bl	4083c4 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
  40868c:	94002468 	bl	41182c <z_cstart>

0000000000408690 <posix_is_cpu_running>:
	return !cpu_halted;
  408690:	d0000140 	adrp	x0, 432000 <__dso_handle>
  408694:	39695c00 	ldrb	w0, [x0, #2647]
}
  408698:	52000000 	eor	w0, w0, #0x1
  40869c:	d65f03c0 	ret

00000000004086a0 <posix_change_cpu_state_and_wait>:
{
  4086a0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4086a4:	910003fd 	mov	x29, sp
  4086a8:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4086ac:	f0000155 	adrp	x21, 433000 <obj_0x28+0x18>
{
  4086b0:	12001c16 	and	w22, w0, #0xff
  4086b4:	f9001bf7 	str	x23, [sp, #48]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4086b8:	912ce2b7 	add	x23, x21, #0xb38
  4086bc:	aa1703e0 	mov	x0, x23
{
  4086c0:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4086c4:	97ffe3ff 	bl	4016c0 <pthread_mutex_lock@plt>
	cpu_halted = halted;
  4086c8:	d0000153 	adrp	x19, 432000 <__dso_handle>
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4086cc:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  4086d0:	9133a421 	add	x1, x1, #0xce9
  4086d4:	97ffffd9 	bl	408638 <pc_safe_call>
	cpu_halted = halted;
  4086d8:	39295e76 	strb	w22, [x19, #2647]
	while (cpu_halted == halted) {
  4086dc:	91295e73 	add	x19, x19, #0xa57
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  4086e0:	f0000154 	adrp	x20, 433000 <obj_0x28+0x18>
  4086e4:	912c2294 	add	x20, x20, #0xb08
  4086e8:	aa1403e0 	mov	x0, x20
  4086ec:	97ffe37d 	bl	4014e0 <pthread_cond_broadcast@plt>
  4086f0:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  4086f4:	91349421 	add	x1, x1, #0xd25
  4086f8:	97ffffd0 	bl	408638 <pc_safe_call>
	while (cpu_halted == halted) {
  4086fc:	39400260 	ldrb	w0, [x19]
  408700:	6b16001f 	cmp	w0, w22
  408704:	54000140 	b.eq	40872c <posix_change_cpu_state_and_wait+0x8c>  // b.none
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  408708:	912ce2a0 	add	x0, x21, #0xb38
  40870c:	97ffe3f1 	bl	4016d0 <pthread_mutex_unlock@plt>
}
  408710:	a94153f3 	ldp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  408714:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
}
  408718:	a9425bf5 	ldp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  40871c:	91341821 	add	x1, x1, #0xd06
}
  408720:	f9401bf7 	ldr	x23, [sp, #48]
  408724:	a8c47bfd 	ldp	x29, x30, [sp], #64
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  408728:	17ffffc4 	b	408638 <pc_safe_call>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  40872c:	aa1703e1 	mov	x1, x23
  408730:	aa1403e0 	mov	x0, x20
  408734:	97ffe3ab 	bl	4015e0 <pthread_cond_wait@plt>
  408738:	17fffff1 	b	4086fc <posix_change_cpu_state_and_wait+0x5c>

000000000040873c <posix_interrupt_raised>:
{
  40873c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(false);
  408740:	52800000 	mov	w0, #0x0                   	// #0
{
  408744:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(false);
  408748:	97ffffd6 	bl	4086a0 <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
  40874c:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  408750:	39410000 	ldrb	w0, [x0, #64]
  408754:	34000080 	cbz	w0, 408764 <posix_interrupt_raised+0x28>
}
  408758:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_exit(0);
  40875c:	52800000 	mov	w0, #0x0                   	// #0
  408760:	14000378 	b	409540 <posix_exit>
}
  408764:	a8c17bfd 	ldp	x29, x30, [sp], #16
  408768:	d65f03c0 	ret

000000000040876c <posix_halt_cpu>:
{
  40876c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	posix_change_cpu_state_and_wait(true);
  408770:	52800020 	mov	w0, #0x1                   	// #1
{
  408774:	910003fd 	mov	x29, sp
	posix_change_cpu_state_and_wait(true);
  408778:	97ffffca 	bl	4086a0 <posix_change_cpu_state_and_wait>
}
  40877c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	posix_irq_handler();
  408780:	14000245 	b	409094 <posix_irq_handler>

0000000000408784 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
  408784:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  408788:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40878c:	910003fd 	mov	x29, sp
  408790:	f9475c00 	ldr	x0, [x0, #3768]
  408794:	a90153f3 	stp	x19, x20, [sp, #16]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));

	cpu_halted = false;
  408798:	d0000153 	adrp	x19, 432000 <__dso_handle>
{
  40879c:	a9025bf5 	stp	x21, x22, [sp, #32]
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4087a0:	f0000155 	adrp	x21, 433000 <obj_0x28+0x18>
  4087a4:	912ce2b6 	add	x22, x21, #0xb38
{
  4087a8:	f9400001 	ldr	x1, [x0]
  4087ac:	f9001fe1 	str	x1, [sp, #56]
  4087b0:	d2800001 	mov	x1, #0x0                   	// #0
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4087b4:	aa1603e0 	mov	x0, x22
	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  4087b8:	f0000154 	adrp	x20, 433000 <obj_0x28+0x18>
  4087bc:	912c2294 	add	x20, x20, #0xb08
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4087c0:	97ffe3c0 	bl	4016c0 <pthread_mutex_lock@plt>
  4087c4:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  4087c8:	9133a421 	add	x1, x1, #0xce9
  4087cc:	97ffff9b 	bl	408638 <pc_safe_call>
	cpu_halted = false;
  4087d0:	39295e7f 	strb	wzr, [x19, #2647]
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  4087d4:	90000002 	adrp	x2, 408000 <arch_cpu_idle+0xc>
	while (cpu_halted == false) {
  4087d8:	91295e73 	add	x19, x19, #0xa57
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
  4087dc:	91193042 	add	x2, x2, #0x64c
  4087e0:	d2800003 	mov	x3, #0x0                   	// #0
  4087e4:	d2800001 	mov	x1, #0x0                   	// #0
  4087e8:	9100c3e0 	add	x0, sp, #0x30
  4087ec:	97ffe391 	bl	401630 <pthread_create@plt>
  4087f0:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  4087f4:	91351c21 	add	x1, x1, #0xd47
  4087f8:	97ffff90 	bl	408638 <pc_safe_call>
	while (cpu_halted == false) {
  4087fc:	39400260 	ldrb	w0, [x19]
  408800:	34000260 	cbz	w0, 40884c <posix_boot_cpu+0xc8>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  408804:	912ce2a0 	add	x0, x21, #0xb38
  408808:	97ffe3b2 	bl	4016d0 <pthread_mutex_unlock@plt>
  40880c:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408810:	91341821 	add	x1, x1, #0xd06
  408814:	97ffff89 	bl	408638 <pc_safe_call>

	if (soc_terminate) {
  408818:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  40881c:	39410000 	ldrb	w0, [x0, #64]
  408820:	34000060 	cbz	w0, 40882c <posix_boot_cpu+0xa8>
		posix_exit(0);
  408824:	52800000 	mov	w0, #0x0                   	// #0
  408828:	94000346 	bl	409540 <posix_exit>
	}
}
  40882c:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408830:	f9475c00 	ldr	x0, [x0, #3768]
  408834:	f9401fe2 	ldr	x2, [sp, #56]
  408838:	f9400001 	ldr	x1, [x0]
  40883c:	eb010042 	subs	x2, x2, x1
  408840:	d2800001 	mov	x1, #0x0                   	// #0
  408844:	540000c0 	b.eq	40885c <posix_boot_cpu+0xd8>  // b.none
  408848:	97ffe336 	bl	401520 <__stack_chk_fail@plt>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
  40884c:	aa1603e1 	mov	x1, x22
  408850:	aa1403e0 	mov	x0, x20
  408854:	97ffe363 	bl	4015e0 <pthread_cond_wait@plt>
  408858:	17ffffe9 	b	4087fc <posix_boot_cpu+0x78>
}
  40885c:	a94153f3 	ldp	x19, x20, [sp, #16]
  408860:	a9425bf5 	ldp	x21, x22, [sp, #32]
  408864:	a8c47bfd 	ldp	x29, x30, [sp], #64
  408868:	d65f03c0 	ret

000000000040886c <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
  40886c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  408870:	b0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  408874:	91238021 	add	x1, x1, #0x8e0
{
  408878:	910003fd 	mov	x29, sp
  40887c:	a90153f3 	stp	x19, x20, [sp, #16]
	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
  408880:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
  408884:	11000400 	add	w0, w0, #0x1
  408888:	f860d834 	ldr	x20, [x1, w0, sxtw #3]
  40888c:	eb13029f 	cmp	x20, x19
  408890:	54000088 	b.hi	4088a0 <run_native_tasks+0x34>  // b.pmore
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
			(*fptr)();
		}
	}
}
  408894:	a94153f3 	ldp	x19, x20, [sp, #16]
  408898:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40889c:	d65f03c0 	ret
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
  4088a0:	f9400260 	ldr	x0, [x19]
  4088a4:	b4000040 	cbz	x0, 4088ac <run_native_tasks+0x40>
			(*fptr)();
  4088a8:	d63f0000 	blr	x0
		fptr++) {
  4088ac:	91002273 	add	x19, x19, #0x8
  4088b0:	17fffff7 	b	40888c <run_native_tasks+0x20>

00000000004088b4 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
  4088b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4088b8:	910003fd 	mov	x29, sp
  4088bc:	a90153f3 	stp	x19, x20, [sp, #16]
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
  4088c0:	d0000154 	adrp	x20, 432000 <__dso_handle>
  4088c4:	39695e80 	ldrb	w0, [x20, #2647]
{
  4088c8:	f90013f5 	str	x21, [sp, #32]
	if (cpu_halted) {
  4088cc:	340000e0 	cbz	w0, 4088e8 <posix_soc_clean_up+0x34>

		posix_core_clean_up();
  4088d0:	97fffed7 	bl	40842c <posix_core_clean_up>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
  4088d4:	a94153f3 	ldp	x19, x20, [sp, #16]
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  4088d8:	52800080 	mov	w0, #0x4                   	// #4
}
  4088dc:	f94013f5 	ldr	x21, [sp, #32]
  4088e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
  4088e4:	17ffffe2 	b	40886c <run_native_tasks>
	} else if (soc_terminate == false) {
  4088e8:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  4088ec:	39410001 	ldrb	w1, [x0, #64]
  4088f0:	35000321 	cbnz	w1, 408954 <posix_soc_clean_up+0xa0>
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  4088f4:	f0000153 	adrp	x19, 433000 <obj_0x28+0x18>
  4088f8:	912ce273 	add	x19, x19, #0xb38
		soc_terminate = true;
  4088fc:	52800035 	mov	w21, #0x1                   	// #1
  408900:	39010015 	strb	w21, [x0, #64]
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
  408904:	aa1303e0 	mov	x0, x19
  408908:	97ffe36e 	bl	4016c0 <pthread_mutex_lock@plt>
  40890c:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408910:	9133a421 	add	x1, x1, #0xce9
  408914:	97ffff49 	bl	408638 <pc_safe_call>
		cpu_halted = true;
  408918:	39295e95 	strb	w21, [x20, #2647]
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
  40891c:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  408920:	912c2000 	add	x0, x0, #0xb08
  408924:	97ffe2ef 	bl	4014e0 <pthread_cond_broadcast@plt>
  408928:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  40892c:	91349421 	add	x1, x1, #0xd25
  408930:	97ffff42 	bl	408638 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
  408934:	aa1303e0 	mov	x0, x19
  408938:	97ffe366 	bl	4016d0 <pthread_mutex_unlock@plt>
  40893c:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408940:	91341821 	add	x1, x1, #0xd06
  408944:	97ffff3d 	bl	408638 <pc_safe_call>
			sleep(1);
  408948:	52800020 	mov	w0, #0x1                   	// #1
  40894c:	97ffe2d5 	bl	4014a0 <sleep@plt>
		while (1) {
  408950:	17fffffe 	b	408948 <posix_soc_clean_up+0x94>
}
  408954:	a94153f3 	ldp	x19, x20, [sp, #16]
  408958:	f94013f5 	ldr	x21, [sp, #32]
  40895c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  408960:	d65f03c0 	ret

0000000000408964 <hwm_signal_end_handler>:
/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
	signaled_end = 1;
  408964:	90000160 	adrp	x0, 434000 <ztest_thread+0xb8>
  408968:	52800021 	mov	w1, #0x1                   	// #1
  40896c:	b90de801 	str	w1, [x0, #3560]
}
  408970:	d65f03c0 	ret

0000000000408974 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
  408974:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
  408978:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40897c:	910003fd 	mov	x29, sp
  408980:	f9475c00 	ldr	x0, [x0, #3768]
  408984:	f9000bf3 	str	x19, [sp, #16]
  408988:	f9400001 	ldr	x1, [x0]
  40898c:	f9005fe1 	str	x1, [sp, #184]
  408990:	d2800001 	mov	x1, #0x0                   	// #0
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
  408994:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408998:	f9474000 	ldr	x0, [x0, #3712]
  40899c:	f90013e0 	str	x0, [sp, #32]
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
  4089a0:	9100a3e0 	add	x0, sp, #0x28
  4089a4:	97ffe2b3 	bl	401470 <sigemptyset@plt>
	if (unlikely(test)) {
  4089a8:	340000c0 	cbz	w0, 4089c0 <hwm_set_sig_handler+0x4c>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  4089ac:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  4089b0:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  4089b4:	91360821 	add	x1, x1, #0xd82
  4089b8:	912ca400 	add	x0, x0, #0xb29
  4089bc:	94000337 	bl	409698 <posix_print_error_and_exit>

	act.sa_flags = SA_RESETHAND;
  4089c0:	52b00000 	mov	w0, #0x80000000            	// #-2147483648

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  4089c4:	910083f3 	add	x19, sp, #0x20
  4089c8:	aa1303e1 	mov	x1, x19
  4089cc:	d2800002 	mov	x2, #0x0                   	// #0
	act.sa_flags = SA_RESETHAND;
  4089d0:	b900abe0 	str	w0, [sp, #168]
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
  4089d4:	528001e0 	mov	w0, #0xf                   	// #15
  4089d8:	97ffe2d6 	bl	401530 <sigaction@plt>
	if (unlikely(test)) {
  4089dc:	340000c0 	cbz	w0, 4089f4 <hwm_set_sig_handler+0x80>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  4089e0:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  4089e4:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  4089e8:	91367021 	add	x1, x1, #0xd9c
  4089ec:	912ca400 	add	x0, x0, #0xb29
  4089f0:	9400032a 	bl	409698 <posix_print_error_and_exit>
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
  4089f4:	aa1303e1 	mov	x1, x19
  4089f8:	d2800002 	mov	x2, #0x0                   	// #0
  4089fc:	52800040 	mov	w0, #0x2                   	// #2
  408a00:	97ffe2cc 	bl	401530 <sigaction@plt>
	if (unlikely(test)) {
  408a04:	340000c0 	cbz	w0, 408a1c <hwm_set_sig_handler+0xa8>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
  408a08:	90000081 	adrp	x1, 418000 <table.0+0x1d8>
  408a0c:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408a10:	9136ec21 	add	x1, x1, #0xdbb
  408a14:	912ca400 	add	x0, x0, #0xb29
  408a18:	94000320 	bl	409698 <posix_print_error_and_exit>
}
  408a1c:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408a20:	f9475c00 	ldr	x0, [x0, #3768]
  408a24:	f9405fe2 	ldr	x2, [sp, #184]
  408a28:	f9400001 	ldr	x1, [x0]
  408a2c:	eb010042 	subs	x2, x2, x1
  408a30:	d2800001 	mov	x1, #0x0                   	// #0
  408a34:	54000040 	b.eq	408a3c <hwm_set_sig_handler+0xc8>  // b.none
  408a38:	97ffe2ba 	bl	401520 <__stack_chk_fail@plt>
  408a3c:	f9400bf3 	ldr	x19, [sp, #16]
  408a40:	a8cc7bfd 	ldp	x29, x30, [sp], #192
  408a44:	d65f03c0 	ret

0000000000408a48 <hwm_find_next_timer>:
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];
  408a48:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
  408a4c:	b0000142 	adrp	x2, 431000 <__FRAME_END__+0x10804>
	next_timer_index = 0;
  408a50:	d0000141 	adrp	x1, 432000 <__dso_handle>
	next_timer_time  = *Timer_list[0];
  408a54:	f9474800 	ldr	x0, [x0, #3728]
	next_timer_index = 0;
  408a58:	b90a2c3f 	str	wzr, [x1, #2604]
		if (next_timer_time > *Timer_list[i]) {
  408a5c:	f9478842 	ldr	x2, [x2, #3856]
	next_timer_time  = *Timer_list[0];
  408a60:	f9400003 	ldr	x3, [x0]
  408a64:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
		if (next_timer_time > *Timer_list[i]) {
  408a68:	f9400042 	ldr	x2, [x2]
	next_timer_time  = *Timer_list[0];
  408a6c:	f905b403 	str	x3, [x0, #2920]
		if (next_timer_time > *Timer_list[i]) {
  408a70:	eb02007f 	cmp	x3, x2
  408a74:	54000089 	b.ls	408a84 <hwm_find_next_timer+0x3c>  // b.plast
			next_timer_index = i;
  408a78:	52800023 	mov	w3, #0x1                   	// #1
			next_timer_time = *Timer_list[i];
  408a7c:	f905b402 	str	x2, [x0, #2920]
			next_timer_index = i;
  408a80:	b90a2c23 	str	w3, [x1, #2604]
		if (next_timer_time > *Timer_list[i]) {
  408a84:	b0000142 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  408a88:	f945b403 	ldr	x3, [x0, #2920]
  408a8c:	f947d442 	ldr	x2, [x2, #4008]
  408a90:	f9400042 	ldr	x2, [x2]
  408a94:	eb03005f 	cmp	x2, x3
  408a98:	54000082 	b.cs	408aa8 <hwm_find_next_timer+0x60>  // b.hs, b.nlast
			next_timer_index = i;
  408a9c:	52800043 	mov	w3, #0x2                   	// #2
			next_timer_time = *Timer_list[i];
  408aa0:	f905b402 	str	x2, [x0, #2920]
			next_timer_index = i;
  408aa4:	b90a2c23 	str	w3, [x1, #2604]
		}
	}
}
  408aa8:	d65f03c0 	ret

0000000000408aac <hwm_one_event>:

/**
 * Execute the next scheduled HW event/timer
 */
void hwm_one_event(void)
{
  408aac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  408ab0:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
{
  408ab4:	910003fd 	mov	x29, sp
  408ab8:	a90153f3 	stp	x19, x20, [sp, #16]
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
  408abc:	f0000153 	adrp	x19, 433000 <obj_0x28+0x18>
  408ac0:	d0000154 	adrp	x20, 432000 <__dso_handle>
  408ac4:	f945b401 	ldr	x1, [x0, #2920]
  408ac8:	f945ba62 	ldr	x2, [x19, #2928]
  408acc:	eb02003f 	cmp	x1, x2
  408ad0:	540003c3 	b.cc	408b48 <hwm_one_event+0x9c>  // b.lo, b.ul, b.last
		simu_time = next_timer_time;
  408ad4:	f905ba61 	str	x1, [x19, #2928]
	if (signaled_end || (simu_time > end_of_time)) {
  408ad8:	90000160 	adrp	x0, 434000 <ztest_thread+0xb8>
  408adc:	b94de801 	ldr	w1, [x0, #3560]
  408ae0:	f945ba60 	ldr	x0, [x19, #2928]
  408ae4:	350000a1 	cbnz	w1, 408af8 <hwm_one_event+0x4c>
  408ae8:	d0000141 	adrp	x1, 432000 <__dso_handle>
  408aec:	f9422c21 	ldr	x1, [x1, #1112]
  408af0:	eb00003f 	cmp	x1, x0
  408af4:	54000162 	b.cs	408b20 <hwm_one_event+0x74>  // b.hs, b.nlast
				((long double)simu_time)/1.0e6L);
  408af8:	97ffe5ba 	bl	4021e0 <__floatunditf>
		posix_print_trace("\nStopped at %.3Lfs\n",
  408afc:	f0000060 	adrp	x0, 417000 <z_abort_timeout+0x38>
  408b00:	9136c000 	add	x0, x0, #0xdb0
  408b04:	3dc00001 	ldr	q1, [x0]
  408b08:	97ffe35e 	bl	401880 <__divtf3>
  408b0c:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408b10:	91383800 	add	x0, x0, #0xe0e
  408b14:	94000347 	bl	409830 <posix_print_trace>
		posix_exit(0);
  408b18:	52800000 	mov	w0, #0x0                   	// #0
  408b1c:	94000289 	bl	409540 <posix_exit>
	hwm_sleep_until_next_timer();

	switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
  408b20:	b94a2e80 	ldr	w0, [x20, #2604]
  408b24:	7100041f 	cmp	w0, #0x1
  408b28:	540001a0 	b.eq	408b5c <hwm_one_event+0xb0>  // b.none
  408b2c:	7100081f 	cmp	w0, #0x2
  408b30:	540001a0 	b.eq	408b64 <hwm_one_event+0xb8>  // b.none
  408b34:	350001c0 	cbnz	w0, 408b6c <hwm_one_event+0xc0>
	case HWTIMER:
		hwtimer_timer_reached();
  408b38:	940000b7 	bl	408e14 <hwtimer_timer_reached>
		break;
		/* LCOV_EXCL_STOP */
	}

	hwm_find_next_timer();
}
  408b3c:	a94153f3 	ldp	x19, x20, [sp, #16]
  408b40:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  408b44:	17ffffc1 	b	408a48 <hwm_find_next_timer>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
  408b48:	b94a2e83 	ldr	w3, [x20, #2604]
  408b4c:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408b50:	91376400 	add	x0, x0, #0xdd9
  408b54:	94000305 	bl	409768 <posix_print_warning>
  408b58:	17ffffe0 	b	408ad8 <hwm_one_event+0x2c>
		hw_irq_ctrl_timer_triggered();
  408b5c:	94000274 	bl	40952c <hw_irq_ctrl_timer_triggered>
		break;
  408b60:	17fffff7 	b	408b3c <hwm_one_event+0x90>
		hw_counter_triggered();
  408b64:	94000615 	bl	40a3b8 <hw_counter_triggered>
		break;
  408b68:	17fffff5 	b	408b3c <hwm_one_event+0x90>
		posix_print_error_and_exit(
  408b6c:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408b70:	91388800 	add	x0, x0, #0xe22
  408b74:	940002c9 	bl	409698 <posix_print_error_and_exit>
		break;
  408b78:	17fffff1 	b	408b3c <hwm_one_event+0x90>

0000000000408b7c <hwm_set_end_of_time>:
/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
	end_of_time = new_end_of_time;
  408b7c:	d0000141 	adrp	x1, 432000 <__dso_handle>
  408b80:	f9022c20 	str	x0, [x1, #1112]
}
  408b84:	d65f03c0 	ret

0000000000408b88 <hwm_get_time>:
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
	return simu_time;
}
  408b88:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  408b8c:	f945b800 	ldr	x0, [x0, #2928]
  408b90:	d65f03c0 	ret

0000000000408b94 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
  408b94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  408b98:	910003fd 	mov	x29, sp
	hwm_set_sig_handler();
  408b9c:	97ffff76 	bl	408974 <hwm_set_sig_handler>
	hwtimer_init();
  408ba0:	94000055 	bl	408cf4 <hwtimer_init>
	hw_counter_init();
  408ba4:	940005f8 	bl	40a384 <hw_counter_init>
	hw_irq_ctrl_init();
  408ba8:	940001da 	bl	409310 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
  408bac:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hwm_find_next_timer();
  408bb0:	17ffffa6 	b	408a48 <hwm_find_next_timer>

0000000000408bb4 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
  408bb4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  408bb8:	910003fd 	mov	x29, sp
	hwtimer_cleanup();
  408bbc:	94000086 	bl	408dd4 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
  408bc0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	hw_irq_ctrl_cleanup();
  408bc4:	140001e0 	b	409344 <hw_irq_ctrl_cleanup>

0000000000408bc8 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
  408bc8:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408bcc:	f947bc00 	ldr	x0, [x0, #3960]
  408bd0:	f9400001 	ldr	x1, [x0]
  408bd4:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408bd8:	f9477800 	ldr	x0, [x0, #3824]
  408bdc:	f9400000 	ldr	x0, [x0]
  408be0:	eb01001f 	cmp	x0, x1
  408be4:	9a819000 	csel	x0, x0, x1, ls  // ls = plast
  408be8:	b0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  408bec:	f9474821 	ldr	x1, [x1, #3728]
  408bf0:	f9000020 	str	x0, [x1]
}
  408bf4:	d65f03c0 	ret

0000000000408bf8 <native_add_time_options>:
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
  408bf8:	d0000140 	adrp	x0, 432000 <__dso_handle>
  408bfc:	9111a000 	add	x0, x0, #0x468
  408c00:	14000573 	b	40a1cc <native_add_command_line_opts>

0000000000408c04 <cmd_stop_at_found>:
{
  408c04:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408c08:	910003fd 	mov	x29, sp
  408c0c:	f9000bf3 	str	x19, [sp, #16]
	if (args.stop_at < 0) {
  408c10:	f0000153 	adrp	x19, 433000 <obj_0x28+0x18>
  408c14:	fd45be60 	ldr	d0, [x19, #2936]
  408c18:	1e602018 	fcmpe	d0, #0.0
  408c1c:	54000144 	b.mi	408c44 <cmd_stop_at_found+0x40>  // b.first
	hwm_set_end_of_time(args.stop_at*1e6);
  408c20:	fd45be60 	ldr	d0, [x19, #2936]
  408c24:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  408c28:	f2e825c0 	movk	x0, #0x412e, lsl #48
  408c2c:	9e670001 	fmov	d1, x0
}
  408c30:	f9400bf3 	ldr	x19, [sp, #16]
	hwm_set_end_of_time(args.stop_at*1e6);
  408c34:	1e610800 	fmul	d0, d0, d1
}
  408c38:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_set_end_of_time(args.stop_at*1e6);
  408c3c:	9e790000 	fcvtzu	x0, d0
  408c40:	17ffffcf 	b	408b7c <hwm_set_end_of_time>
  408c44:	aa0003e1 	mov	x1, x0
		posix_print_error_and_exit("Error: stop-at must be positive "
  408c48:	90000080 	adrp	x0, 418000 <table.0+0x1d8>
  408c4c:	9138f800 	add	x0, x0, #0xe3e
  408c50:	94000292 	bl	409698 <posix_print_error_and_exit>
  408c54:	17fffff3 	b	408c20 <cmd_stop_at_found+0x1c>

0000000000408c58 <hwtimer_set_real_time_mode>:
	real_time_mode = new_rt;
  408c58:	b0000161 	adrp	x1, 435000 <stdout_buff+0xc1>
  408c5c:	39010420 	strb	w0, [x1, #65]
}
  408c60:	d65f03c0 	ret

0000000000408c64 <cmd_no_realtime_found>:
	hwtimer_set_real_time_mode(false);
  408c64:	52800000 	mov	w0, #0x0                   	// #0
  408c68:	17fffffc 	b	408c58 <hwtimer_set_real_time_mode>

0000000000408c6c <cmd_realtime_found>:
	hwtimer_set_real_time_mode(true);
  408c6c:	52800020 	mov	w0, #0x1                   	// #1
  408c70:	17fffffa 	b	408c58 <hwtimer_set_real_time_mode>

0000000000408c74 <get_host_us_time>:
{
  408c74:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  408c78:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408c7c:	910003fd 	mov	x29, sp
  408c80:	f9475c00 	ldr	x0, [x0, #3768]
  408c84:	f9400001 	ldr	x1, [x0]
  408c88:	f90017e1 	str	x1, [sp, #40]
  408c8c:	d2800001 	mov	x1, #0x0                   	// #0
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
  408c90:	52800080 	mov	w0, #0x4                   	// #4
  408c94:	910063e1 	add	x1, sp, #0x18
  408c98:	97ffe1d6 	bl	4013f0 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  408c9c:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  408ca0:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  408ca4:	f2e825c0 	movk	x0, #0x412e, lsl #48
  408ca8:	9e670001 	fmov	d1, x0
  408cac:	fd400fe0 	ldr	d0, [sp, #24]
  408cb0:	f94013e0 	ldr	x0, [sp, #32]
  408cb4:	7e61d800 	ucvtf	d0, d0
  408cb8:	9ac10c00 	sdiv	x0, x0, x1
}
  408cbc:	b0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  408cc0:	1e610800 	fmul	d0, d0, d1
}
  408cc4:	f9475c21 	ldr	x1, [x1, #3768]
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  408cc8:	9e620001 	scvtf	d1, x0
}
  408ccc:	f94017e3 	ldr	x3, [sp, #40]
  408cd0:	f9400022 	ldr	x2, [x1]
  408cd4:	eb020063 	subs	x3, x3, x2
  408cd8:	d2800002 	mov	x2, #0x0                   	// #0
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  408cdc:	1e612800 	fadd	d0, d0, d1
}
  408ce0:	54000040 	b.eq	408ce8 <get_host_us_time+0x74>  // b.none
  408ce4:	97ffe20f 	bl	401520 <__stack_chk_fail@plt>
  408ce8:	9e790000 	fcvtzu	x0, d0
  408cec:	a8c37bfd 	ldp	x29, x30, [sp], #48
  408cf0:	d65f03c0 	ret

0000000000408cf4 <hwtimer_init>:
{
  408cf4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  408cf8:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408cfc:	910003fd 	mov	x29, sp
  408d00:	f9475c00 	ldr	x0, [x0, #3768]
  408d04:	f9400001 	ldr	x1, [x0]
  408d08:	f90017e1 	str	x1, [sp, #40]
  408d0c:	d2800001 	mov	x1, #0x0                   	// #0
	silent_ticks = 0;
  408d10:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
	hw_timer_tick_timer = NEVER;
  408d14:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	silent_ticks = 0;
  408d18:	f905e41f 	str	xzr, [x0, #3016]
	hw_timer_tick_timer = NEVER;
  408d1c:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408d20:	f947bc00 	ldr	x0, [x0, #3960]
  408d24:	f9000001 	str	x1, [x0]
	hw_timer_awake_timer = NEVER;
  408d28:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408d2c:	f9477800 	ldr	x0, [x0, #3824]
  408d30:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  408d34:	97ffffa5 	bl	408bc8 <hwtimer_update_timer>
	if (real_time_mode) {
  408d38:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  408d3c:	39410400 	ldrb	w0, [x0, #65]
  408d40:	340000c0 	cbz	w0, 408d58 <hwtimer_init+0x64>
		boot_time = get_host_us_time();
  408d44:	97ffffcc 	bl	408c74 <get_host_us_time>
		last_radj_rtime = boot_time;
  408d48:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  408d4c:	f905d820 	str	x0, [x1, #2992]
		last_radj_stime = 0U;
  408d50:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  408d54:	f905dc1f 	str	xzr, [x0, #3000]
	if (!reset_rtc) {
  408d58:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  408d5c:	39410800 	ldrb	w0, [x0, #66]
  408d60:	35000260 	cbnz	w0, 408dac <hwtimer_init+0xb8>
		clock_gettime(CLOCK_REALTIME, &tv);
  408d64:	910063e1 	add	x1, sp, #0x18
  408d68:	97ffe1a2 	bl	4013f0 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  408d6c:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  408d70:	d2807d02 	mov	x2, #0x3e8                 	// #1000
  408d74:	f2e825c0 	movk	x0, #0x412e, lsl #48
  408d78:	9e670001 	fmov	d1, x0
  408d7c:	fd400fe0 	ldr	d0, [sp, #24]
		rtc_offset += realhosttime;
  408d80:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  408d84:	f94013e0 	ldr	x0, [sp, #32]
  408d88:	7e61d800 	ucvtf	d0, d0
  408d8c:	9ac20c00 	sdiv	x0, x0, x2
		rtc_offset += realhosttime;
  408d90:	f945e022 	ldr	x2, [x1, #3008]
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
  408d94:	1e610800 	fmul	d0, d0, d1
  408d98:	9e620001 	scvtf	d1, x0
  408d9c:	1e612800 	fadd	d0, d0, d1
  408da0:	9e790000 	fcvtzu	x0, d0
		rtc_offset += realhosttime;
  408da4:	8b020000 	add	x0, x0, x2
  408da8:	f905e020 	str	x0, [x1, #3008]
}
  408dac:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408db0:	f9475c00 	ldr	x0, [x0, #3768]
  408db4:	f94017e2 	ldr	x2, [sp, #40]
  408db8:	f9400001 	ldr	x1, [x0]
  408dbc:	eb010042 	subs	x2, x2, x1
  408dc0:	d2800001 	mov	x1, #0x0                   	// #0
  408dc4:	54000040 	b.eq	408dcc <hwtimer_init+0xd8>  // b.none
  408dc8:	97ffe1d6 	bl	401520 <__stack_chk_fail@plt>
  408dcc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  408dd0:	d65f03c0 	ret

0000000000408dd4 <hwtimer_cleanup>:
}
  408dd4:	d65f03c0 	ret

0000000000408dd8 <hwtimer_enable>:
{
  408dd8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  408ddc:	910003fd 	mov	x29, sp
  408de0:	f9000bf3 	str	x19, [sp, #16]
	tick_p = period;
  408de4:	f0000153 	adrp	x19, 433000 <obj_0x28+0x18>
  408de8:	f905ea60 	str	x0, [x19, #3024]
	hw_timer_tick_timer = hwm_get_time() + tick_p;
  408dec:	97ffff67 	bl	408b88 <hwm_get_time>
  408df0:	f945ea61 	ldr	x1, [x19, #3024]
  408df4:	8b000020 	add	x0, x1, x0
  408df8:	b0000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  408dfc:	f947bc21 	ldr	x1, [x1, #3960]
  408e00:	f9000020 	str	x0, [x1]
	hwtimer_update_timer();
  408e04:	97ffff71 	bl	408bc8 <hwtimer_update_timer>
}
  408e08:	f9400bf3 	ldr	x19, [sp, #16]
  408e0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwm_find_next_timer();
  408e10:	17ffff0e 	b	408a48 <hwm_find_next_timer>

0000000000408e14 <hwtimer_timer_reached>:
{
  408e14:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  408e18:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408e1c:	910003fd 	mov	x29, sp
  408e20:	f9475c00 	ldr	x0, [x0, #3768]
  408e24:	a90153f3 	stp	x19, x20, [sp, #16]
  408e28:	f90013f5 	str	x21, [sp, #32]
  408e2c:	f9400001 	ldr	x1, [x0]
  408e30:	f9002fe1 	str	x1, [sp, #88]
  408e34:	d2800001 	mov	x1, #0x0                   	// #0
	uint64_t Now = hw_timer_timer;
  408e38:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408e3c:	f9474800 	ldr	x0, [x0, #3728]
  408e40:	f9400013 	ldr	x19, [x0]
	if (hw_timer_awake_timer == Now) {
  408e44:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408e48:	f9477800 	ldr	x0, [x0, #3824]
  408e4c:	f9400001 	ldr	x1, [x0]
  408e50:	eb13003f 	cmp	x1, x19
  408e54:	540000c1 	b.ne	408e6c <hwtimer_timer_reached+0x58>  // b.any
	hw_timer_awake_timer = NEVER;
  408e58:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  408e5c:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  408e60:	97ffff5a 	bl	408bc8 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
  408e64:	529fffe0 	mov	w0, #0xffff                	// #65535
  408e68:	9400018a 	bl	409490 <hw_irq_ctrl_set_irq>
	if (hw_timer_tick_timer == Now) {
  408e6c:	b0000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  408e70:	b0000154 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  408e74:	aa0003f5 	mov	x21, x0
  408e78:	f947bc01 	ldr	x1, [x0, #3960]
  408e7c:	f9400021 	ldr	x1, [x1]
  408e80:	eb13003f 	cmp	x1, x19
  408e84:	54000661 	b.ne	408f50 <hwtimer_timer_reached+0x13c>  // b.any
	if (real_time_mode) {
  408e88:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  408e8c:	39410400 	ldrb	w0, [x0, #65]
  408e90:	34000460 	cbz	w0, 408f1c <hwtimer_timer_reached+0x108>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  408e94:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  408e98:	f945dc00 	ldr	x0, [x0, #3000]
  408e9c:	cb000273 	sub	x19, x19, x0
				    / clock_ratio
  408ea0:	d0000140 	adrp	x0, 432000 <__dso_handle>
  408ea4:	9e630260 	ucvtf	d0, x19
  408ea8:	fd423001 	ldr	d1, [x0, #1120]
				    + last_radj_rtime;
  408eac:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
				    / clock_ratio
  408eb0:	1e611800 	fdiv	d0, d0, d1
				    + last_radj_rtime;
  408eb4:	fd45d801 	ldr	d1, [x0, #2992]
  408eb8:	7e61d821 	ucvtf	d1, d1
  408ebc:	1e612800 	fadd	d0, d0, d1
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
  408ec0:	9e790013 	fcvtzu	x19, d0
		uint64_t real_time = get_host_us_time();
  408ec4:	97ffff6c 	bl	408c74 <get_host_us_time>
		int64_t diff = expected_rt - real_time;
  408ec8:	cb000260 	sub	x0, x19, x0
		if (diff > 0) { /* we need to slow down */
  408ecc:	f100001f 	cmp	x0, #0x0
  408ed0:	5400026d 	b.le	408f1c <hwtimer_timer_reached+0x108>
			requested_time.tv_sec  = diff / 1e6;
  408ed4:	9e620000 	scvtf	d0, x0
  408ed8:	f0000060 	adrp	x0, 417000 <z_abort_timeout+0x38>
			(void) nanosleep(&requested_time, &remaining);
  408edc:	910123e1 	add	x1, sp, #0x48
			requested_time.tv_sec  = diff / 1e6;
  408ee0:	fd46e002 	ldr	d2, [x0, #3520]
						 requested_time.tv_sec*1e6)*1e3;
  408ee4:	d2c80000 	mov	x0, #0x400000000000        	// #70368744177664
  408ee8:	f2e811e0 	movk	x0, #0x408f, lsl #48
			requested_time.tv_sec  = diff / 1e6;
  408eec:	1e621801 	fdiv	d1, d0, d2
  408ef0:	5ee1b821 	fcvtzs	d1, d1
  408ef4:	fd001fe1 	str	d1, [sp, #56]
						 requested_time.tv_sec*1e6)*1e3;
  408ef8:	5e61d821 	scvtf	d1, d1
  408efc:	1e620821 	fmul	d1, d1, d2
			requested_time.tv_nsec = (diff -
  408f00:	1e613800 	fsub	d0, d0, d1
						 requested_time.tv_sec*1e6)*1e3;
  408f04:	9e670001 	fmov	d1, x0
			(void) nanosleep(&requested_time, &remaining);
  408f08:	9100e3e0 	add	x0, sp, #0x38
						 requested_time.tv_sec*1e6)*1e3;
  408f0c:	1e610800 	fmul	d0, d0, d1
			requested_time.tv_nsec = (diff -
  408f10:	5ee1b800 	fcvtzs	d0, d0
  408f14:	fd0023e0 	str	d0, [sp, #64]
			(void) nanosleep(&requested_time, &remaining);
  408f18:	97ffe1b6 	bl	4015f0 <nanosleep@plt>
	hw_timer_tick_timer += tick_p;
  408f1c:	f947bea0 	ldr	x0, [x21, #3960]
  408f20:	f0000142 	adrp	x2, 433000 <obj_0x28+0x18>
  408f24:	f945e842 	ldr	x2, [x2, #3024]
  408f28:	f9400001 	ldr	x1, [x0]
  408f2c:	8b020021 	add	x1, x1, x2
  408f30:	f9000001 	str	x1, [x0]
	hwtimer_update_timer();
  408f34:	97ffff25 	bl	408bc8 <hwtimer_update_timer>
	if (silent_ticks > 0) {
  408f38:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  408f3c:	f945e420 	ldr	x0, [x1, #3016]
  408f40:	f100001f 	cmp	x0, #0x0
  408f44:	540001ad 	b.le	408f78 <hwtimer_timer_reached+0x164>
		silent_ticks -= 1;
  408f48:	d1000400 	sub	x0, x0, #0x1
  408f4c:	f905e420 	str	x0, [x1, #3016]
}
  408f50:	f9475e80 	ldr	x0, [x20, #3768]
  408f54:	f9402fe2 	ldr	x2, [sp, #88]
  408f58:	f9400001 	ldr	x1, [x0]
  408f5c:	eb010042 	subs	x2, x2, x1
  408f60:	d2800001 	mov	x1, #0x0                   	// #0
  408f64:	54000161 	b.ne	408f90 <hwtimer_timer_reached+0x17c>  // b.any
  408f68:	a94153f3 	ldp	x19, x20, [sp, #16]
  408f6c:	f94013f5 	ldr	x21, [sp, #32]
  408f70:	a8c67bfd 	ldp	x29, x30, [sp], #96
  408f74:	d65f03c0 	ret
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  408f78:	f9475e80 	ldr	x0, [x20, #3768]
  408f7c:	f9402fe2 	ldr	x2, [sp, #88]
  408f80:	f9400001 	ldr	x1, [x0]
  408f84:	eb010042 	subs	x2, x2, x1
  408f88:	d2800001 	mov	x1, #0x0                   	// #0
  408f8c:	54000040 	b.eq	408f94 <hwtimer_timer_reached+0x180>  // b.none
}
  408f90:	97ffe164 	bl	401520 <__stack_chk_fail@plt>
  408f94:	a94153f3 	ldp	x19, x20, [sp, #16]
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  408f98:	52800000 	mov	w0, #0x0                   	// #0
}
  408f9c:	f94013f5 	ldr	x21, [sp, #32]
  408fa0:	a8c67bfd 	ldp	x29, x30, [sp], #96
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
  408fa4:	1400013b 	b	409490 <hw_irq_ctrl_set_irq>

0000000000408fa8 <hwtimer_set_silent_ticks>:
	silent_ticks = sys_ticks;
  408fa8:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  408fac:	f905e420 	str	x0, [x1, #3016]
}
  408fb0:	d65f03c0 	ret

0000000000408fb4 <hwtimer_reset_rtc>:
	reset_rtc = true;
  408fb4:	b0000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  408fb8:	52800021 	mov	w1, #0x1                   	// #1
  408fbc:	39010801 	strb	w1, [x0, #66]
}
  408fc0:	d65f03c0 	ret

0000000000408fc4 <cmd_rtcreset_found>:
	hwtimer_reset_rtc();
  408fc4:	17fffffc 	b	408fb4 <hwtimer_reset_rtc>

0000000000408fc8 <hwtimer_set_rtc_offset>:
	rtc_offset = offset;
  408fc8:	f0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  408fcc:	f905e020 	str	x0, [x1, #3008]
}
  408fd0:	d65f03c0 	ret

0000000000408fd4 <cmd_rtcoffset_found>:
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
  408fd4:	f0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  408fd8:	fd45c000 	ldr	d0, [x0, #2944]
  408fdc:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  408fe0:	f2e825c0 	movk	x0, #0x412e, lsl #48
  408fe4:	9e670001 	fmov	d1, x0
  408fe8:	1e610800 	fmul	d0, d0, d1
  408fec:	9e780000 	fcvtzs	x0, d0
  408ff0:	17fffff6 	b	408fc8 <hwtimer_set_rtc_offset>

0000000000408ff4 <hwtimer_set_rt_ratio>:
	clock_ratio = ratio;
  408ff4:	d0000140 	adrp	x0, 432000 <__dso_handle>
  408ff8:	fd023000 	str	d0, [x0, #1120]
}
  408ffc:	d65f03c0 	ret

0000000000409000 <cmd_rt_ratio_found>:
{
  409000:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409004:	910003fd 	mov	x29, sp
  409008:	f9000bf3 	str	x19, [sp, #16]
	if ((args.rt_ratio <= 0)) {
  40900c:	d0000153 	adrp	x19, 433000 <obj_0x28+0x18>
  409010:	912de260 	add	x0, x19, #0xb78
  409014:	fd400c00 	ldr	d0, [x0, #24]
  409018:	1e602018 	fcmpe	d0, #0.0
  40901c:	540000c9 	b.ls	409034 <cmd_rt_ratio_found+0x34>  // b.plast
	hwtimer_set_rt_ratio(args.rt_ratio);
  409020:	912de273 	add	x19, x19, #0xb78
  409024:	fd400e60 	ldr	d0, [x19, #24]
}
  409028:	f9400bf3 	ldr	x19, [sp, #16]
  40902c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  409030:	17fffff1 	b	408ff4 <hwtimer_set_rt_ratio>
		posix_print_error_and_exit("The ratio needs to be > 0. "
  409034:	f0000060 	adrp	x0, 418000 <table.0+0x1d8>
  409038:	91399000 	add	x0, x0, #0xe64
  40903c:	94000197 	bl	409698 <posix_print_error_and_exit>
  409040:	17fffff8 	b	409020 <cmd_rt_ratio_found+0x20>

0000000000409044 <cmd_rt_drift_found>:
{
  409044:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!(args.rt_drift > -1)) {
  409048:	1e7e1000 	fmov	d0, #-1.000000000000000000e+00
{
  40904c:	910003fd 	mov	x29, sp
  409050:	f9000bf3 	str	x19, [sp, #16]
	if (!(args.rt_drift > -1)) {
  409054:	d0000153 	adrp	x19, 433000 <obj_0x28+0x18>
  409058:	912de260 	add	x0, x19, #0xb78
  40905c:	fd400801 	ldr	d1, [x0, #16]
  409060:	1e602030 	fcmpe	d1, d0
  409064:	5400008c 	b.gt	409074 <cmd_rt_drift_found+0x30>
		posix_print_error_and_exit("The drift needs to be > -1. "
  409068:	f0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40906c:	913a8000 	add	x0, x0, #0xea0
  409070:	9400018a 	bl	409698 <posix_print_error_and_exit>
	args.rt_ratio = args.rt_drift + 1;
  409074:	912de273 	add	x19, x19, #0xb78
  409078:	1e6e1001 	fmov	d1, #1.000000000000000000e+00
  40907c:	fd400a60 	ldr	d0, [x19, #16]
  409080:	1e612800 	fadd	d0, d0, d1
  409084:	fd000e60 	str	d0, [x19, #24]
}
  409088:	f9400bf3 	ldr	x19, [sp, #16]
  40908c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	hwtimer_set_rt_ratio(args.rt_ratio);
  409090:	17ffffd9 	b	408ff4 <hwtimer_set_rt_ratio>

0000000000409094 <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
  409094:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  409098:	910003fd 	mov	x29, sp
  40909c:	a90153f3 	stp	x19, x20, [sp, #16]
  4090a0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4090a4:	a90363f7 	stp	x23, x24, [sp, #48]
  4090a8:	f90023f9 	str	x25, [sp, #64]
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
  4090ac:	940000b5 	bl	409380 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
  4090b0:	350009c0 	cbnz	w0, 4091e8 <posix_irq_handler+0x154>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
  4090b4:	90000153 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  4090b8:	aa1303f4 	mov	x20, x19
  4090bc:	f9471260 	ldr	x0, [x19, #3616]
  4090c0:	b9400000 	ldr	w0, [x0]
  4090c4:	35000060 	cbnz	w0, 4090d0 <posix_irq_handler+0x3c>
		may_swap = 0;
  4090c8:	f0000141 	adrp	x1, 434000 <ztest_thread+0xb8>
  4090cc:	b90dec3f 	str	wzr, [x1, #3564]
	}

	_kernel.cpus[0].nested++;
  4090d0:	f9471281 	ldr	x1, [x20, #3616]

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
		int last_running_irq = currently_running_irq;
  4090d4:	b0000155 	adrp	x21, 432000 <__dso_handle>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  4090d8:	d0000156 	adrp	x22, 433000 <obj_0x28+0x18>
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
		hw_irq_ctrl_clear_irq(irq_nbr);

		currently_running_irq = irq_nbr;
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;
  4090dc:	9128c2b8 	add	x24, x21, #0xa30
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  4090e0:	912f62d6 	add	x22, x22, #0xbd8
	_kernel.cpus[0].nested++;
  4090e4:	11000400 	add	w0, w0, #0x1
  4090e8:	b9000020 	str	w0, [x1]
	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
  4090ec:	940000bd 	bl	4093e0 <hw_irq_ctrl_get_highest_prio_irq>
  4090f0:	2a0003f3 	mov	w19, w0
  4090f4:	3100041f 	cmn	w0, #0x1
  4090f8:	540002c1 	b.ne	409150 <posix_irq_handler+0xbc>  // b.any

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
	}

	_kernel.cpus[0].nested--;
  4090fc:	f9471294 	ldr	x20, [x20, #3616]
  409100:	b9400280 	ldr	w0, [x20]
  409104:	51000400 	sub	w0, w0, #0x1
  409108:	b9000280 	str	w0, [x20]
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
  40910c:	f0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  409110:	b94dec00 	ldr	w0, [x0, #3564]
  409114:	340006a0 	cbz	w0, 4091e8 <posix_irq_handler+0x154>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
  409118:	9400008f 	bl	409354 <hw_irq_ctrl_get_cur_prio>
  40911c:	7104001f 	cmp	w0, #0x100
  409120:	54000641 	b.ne	4091e8 <posix_irq_handler+0x154>  // b.any
		&& (_kernel.ready_q.cache != _current)) {
  409124:	f9400a80 	ldr	x0, [x20, #16]
  409128:	f9401681 	ldr	x1, [x20, #40]
  40912c:	eb00003f 	cmp	x1, x0
  409130:	540005c0 	b.eq	4091e8 <posix_irq_handler+0x154>  // b.none

		(void)z_swap_irqlock(irq_lock);
	}
}
  409134:	a94153f3 	ldp	x19, x20, [sp, #16]

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
  409138:	52800000 	mov	w0, #0x0                   	// #0
  40913c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409140:	a94363f7 	ldp	x23, x24, [sp, #48]
  409144:	f94023f9 	ldr	x25, [sp, #64]
  409148:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40914c:	17fffd13 	b	408598 <arch_swap>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  409150:	94000081 	bl	409354 <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;
  409154:	b94a32b9 	ldr	w25, [x21, #2608]
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
  409158:	2a0003f7 	mov	w23, w0
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
  40915c:	2a1303e0 	mov	w0, w19
  409160:	94000084 	bl	409370 <hw_irq_ctrl_get_prio>
  409164:	12001c00 	and	w0, w0, #0xff
  409168:	94000078 	bl	409348 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
  40916c:	2a1303e0 	mov	w0, w19
  409170:	940000bd 	bl	409464 <hw_irq_ctrl_clear_irq>
		currently_running_irq = irq_nbr;
  409174:	b90a32b3 	str	w19, [x21, #2608]
	sys_trace_isr_enter();
  409178:	97fffb9c 	bl	407fe8 <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
  40917c:	93407e61 	sxtw	x1, w19
  409180:	d2800300 	mov	x0, #0x18                  	// #24
  409184:	9b005821 	madd	x1, x1, x0, x22
  409188:	f9400422 	ldr	x2, [x1, #8]
  40918c:	b5000142 	cbnz	x2, 4091b4 <posix_irq_handler+0x120>
		posix_print_error_and_exit("Received irq %i without a "
  409190:	90000080 	adrp	x0, 419000 <__func__.2+0xa80>
  409194:	2a1303e1 	mov	w1, w19
  409198:	910ad800 	add	x0, x0, #0x2b6
  40919c:	9400013f 	bl	409698 <posix_print_error_and_exit>
	sys_trace_isr_exit();
  4091a0:	97fffb93 	bl	407fec <sys_trace_isr_exit>
		currently_running_irq = last_running_irq;
  4091a4:	b9000319 	str	w25, [x24]
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
  4091a8:	2a1703e0 	mov	w0, w23
  4091ac:	94000067 	bl	409348 <hw_irq_ctrl_set_cur_prio>
  4091b0:	17ffffcf 	b	4090ec <posix_irq_handler+0x58>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
  4091b4:	b9400420 	ldr	w0, [x1, #4]
  4091b8:	f0000153 	adrp	x19, 434000 <ztest_thread+0xb8>
  4091bc:	360000c0 	tbz	w0, #0, 4091d4 <posix_irq_handler+0x140>
			*may_swap |= ((direct_irq_f_ptr)
  4091c0:	d63f0040 	blr	x2
  4091c4:	b94dee61 	ldr	w1, [x19, #3564]
  4091c8:	2a000021 	orr	w1, w1, w0
  4091cc:	b90dee61 	str	w1, [x19, #3564]
  4091d0:	17fffff4 	b	4091a0 <posix_irq_handler+0x10c>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
  4091d4:	f9400820 	ldr	x0, [x1, #16]
  4091d8:	d63f0040 	blr	x2
			*may_swap = 1;
  4091dc:	52800020 	mov	w0, #0x1                   	// #1
  4091e0:	b90dee60 	str	w0, [x19, #3564]
  4091e4:	17ffffef 	b	4091a0 <posix_irq_handler+0x10c>
}
  4091e8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4091ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4091f0:	a94363f7 	ldp	x23, x24, [sp, #48]
  4091f4:	f94023f9 	ldr	x25, [sp, #64]
  4091f8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4091fc:	d65f03c0 	ret

0000000000409200 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
  409200:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409204:	910003fd 	mov	x29, sp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
  409208:	94000076 	bl	4093e0 <hw_irq_ctrl_get_highest_prio_irq>
  40920c:	3100041f 	cmn	w0, #0x1
  409210:	54000140 	b.eq	409238 <posix_irq_handler_im_from_sw+0x38>  // b.none
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
  409214:	97fffd1f 	bl	408690 <posix_is_cpu_running>
  409218:	350000c0 	cbnz	w0, 409230 <posix_irq_handler_im_from_sw+0x30>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
  40921c:	90000081 	adrp	x1, 419000 <__func__.2+0xa80>
  409220:	90000080 	adrp	x0, 419000 <__func__.2+0xa80>
  409224:	910c6421 	add	x1, x1, #0x319
  409228:	910b9000 	add	x0, x0, #0x2e4
  40922c:	9400011b 	bl	409698 <posix_print_error_and_exit>
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
  409230:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler();
  409234:	17ffff98 	b	409094 <posix_irq_handler>
}
  409238:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40923c:	d65f03c0 	ret

0000000000409240 <posix_irq_lock>:
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
	return hw_irq_ctrl_change_lock(true);
  409240:	52800020 	mov	w0, #0x1                   	// #1
  409244:	14000052 	b	40938c <hw_irq_ctrl_change_lock>

0000000000409248 <posix_irq_unlock>:
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
	hw_irq_ctrl_change_lock(key);
  409248:	14000051 	b	40938c <hw_irq_ctrl_change_lock>

000000000040924c <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
	hw_irq_ctrl_change_lock(false);
  40924c:	52800000 	mov	w0, #0x0                   	// #0
  409250:	1400004f 	b	40938c <hw_irq_ctrl_change_lock>

0000000000409254 <posix_irq_enable>:
}

void posix_irq_enable(unsigned int irq)
{
	hw_irq_ctrl_enable_irq(irq);
  409254:	140000aa 	b	4094fc <hw_irq_ctrl_enable_irq>

0000000000409258 <posix_isr_declare>:
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
	irq_vector_table[irq_p].irq   = irq_p;
  409258:	2a0003e4 	mov	w4, w0
  40925c:	d2800306 	mov	x6, #0x18                  	// #24
  409260:	d0000145 	adrp	x5, 433000 <obj_0x28+0x18>
  409264:	912f60a5 	add	x5, x5, #0xbd8
  409268:	9b067c84 	mul	x4, x4, x6
  40926c:	8b0400a6 	add	x6, x5, x4
  409270:	b82468a0 	str	w0, [x5, x4]
	irq_vector_table[irq_p].func  = isr_p;
	irq_vector_table[irq_p].param = isr_param_p;
	irq_vector_table[irq_p].flags = flags;
  409274:	b90004c1 	str	w1, [x6, #4]
	irq_vector_table[irq_p].param = isr_param_p;
  409278:	a9008cc2 	stp	x2, x3, [x6, #8]
}
  40927c:	d65f03c0 	ret

0000000000409280 <posix_irq_priority_set>:
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	hw_irq_ctrl_prio_set(irq, prio);
  409280:	14000038 	b	409360 <hw_irq_ctrl_prio_set>

0000000000409284 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
  409284:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  409288:	39418c01 	ldrb	w1, [x0, #99]
  40928c:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  409290:	34000061 	cbz	w1, 40929c <irq_raising_from_hw_now+0x18>
  409294:	39419001 	ldrb	w1, [x0, #100]
  409298:	34000061 	cbz	w1, 4092a4 <irq_raising_from_hw_now+0x20>
		lock_ignore = false;
  40929c:	3901901f 	strb	wzr, [x0, #100]
		posix_interrupt_raised();
  4092a0:	17fffd27 	b	40873c <posix_interrupt_raised>
	}
}
  4092a4:	d65f03c0 	ret

00000000004092a8 <hw_irq_ctrl_irq_raise_prefix>:
	if (irq < N_IRQS) {
  4092a8:	71007c1f 	cmp	w0, #0x1f
  4092ac:	54000248 	b.hi	4092f4 <hw_irq_ctrl_irq_raise_prefix+0x4c>  // b.pmore
		irq_premask |= ((uint64_t)1<<irq);
  4092b0:	d2800021 	mov	x1, #0x1                   	// #1
  4092b4:	d0000144 	adrp	x4, 433000 <obj_0x28+0x18>
  4092b8:	9ac02023 	lsl	x3, x1, x0
		if (irq_mask & (1 << irq)) {
  4092bc:	1ac02021 	lsl	w1, w1, w0
  4092c0:	d0000140 	adrp	x0, 433000 <obj_0x28+0x18>
		irq_premask |= ((uint64_t)1<<irq);
  4092c4:	f9477082 	ldr	x2, [x4, #3808]
		if (irq_mask & (1 << irq)) {
  4092c8:	93407c21 	sxtw	x1, w1
  4092cc:	f9476c00 	ldr	x0, [x0, #3800]
		irq_premask |= ((uint64_t)1<<irq);
  4092d0:	aa030042 	orr	x2, x2, x3
  4092d4:	f9077082 	str	x2, [x4, #3808]
		if (irq_mask & (1 << irq)) {
  4092d8:	ea00003f 	tst	x1, x0
  4092dc:	540000a0 	b.eq	4092f0 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.none
			irq_status |= ((uint64_t)1<<irq);
  4092e0:	d0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  4092e4:	f9477420 	ldr	x0, [x1, #3816]
  4092e8:	aa030000 	orr	x0, x0, x3
  4092ec:	f9077420 	str	x0, [x1, #3816]
}
  4092f0:	d65f03c0 	ret
	} else if (irq == PHONY_HARD_IRQ) {
  4092f4:	529fffe1 	mov	w1, #0xffff                	// #65535
  4092f8:	6b01001f 	cmp	w0, w1
  4092fc:	54ffffa1 	b.ne	4092f0 <hw_irq_ctrl_irq_raise_prefix+0x48>  // b.any
		lock_ignore = true;
  409300:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  409304:	52800021 	mov	w1, #0x1                   	// #1
  409308:	39019001 	strb	w1, [x0, #100]
}
  40930c:	17fffff9 	b	4092f0 <hw_irq_ctrl_irq_raise_prefix+0x48>

0000000000409310 <hw_irq_ctrl_init>:
		irq_prio[i] = 255U;
  409310:	6f000400 	mvni	v0.4s, #0x0
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
  409314:	d0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  409318:	f9076c1f 	str	xzr, [x0, #3800]
	irq_premask = 0U;
  40931c:	d0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  409320:	f907701f 	str	xzr, [x0, #3808]
	irqs_locked = false;
  409324:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  409328:	39018c1f 	strb	wzr, [x0, #99]
	lock_ignore = false;
  40932c:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  409330:	3901901f 	strb	wzr, [x0, #100]
		irq_prio[i] = 255U;
  409334:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  409338:	91010c00 	add	x0, x0, #0x43
  40933c:	ad000000 	stp	q0, q0, [x0]
}
  409340:	d65f03c0 	ret

0000000000409344 <hw_irq_ctrl_cleanup>:
}
  409344:	d65f03c0 	ret

0000000000409348 <hw_irq_ctrl_set_cur_prio>:
	currently_running_prio = new;
  409348:	b0000141 	adrp	x1, 432000 <__dso_handle>
  40934c:	b90a3420 	str	w0, [x1, #2612]
}
  409350:	d65f03c0 	ret

0000000000409354 <hw_irq_ctrl_get_cur_prio>:
}
  409354:	b0000140 	adrp	x0, 432000 <__dso_handle>
  409358:	b94a3400 	ldr	w0, [x0, #2612]
  40935c:	d65f03c0 	ret

0000000000409360 <hw_irq_ctrl_prio_set>:
	irq_prio[irq] = prio;
  409360:	90000162 	adrp	x2, 435000 <stdout_buff+0xc1>
  409364:	91010c42 	add	x2, x2, #0x43
  409368:	38204841 	strb	w1, [x2, w0, uxtw]
}
  40936c:	d65f03c0 	ret

0000000000409370 <hw_irq_ctrl_get_prio>:
}
  409370:	90000161 	adrp	x1, 435000 <stdout_buff+0xc1>
  409374:	91010c21 	add	x1, x1, #0x43
  409378:	38604820 	ldrb	w0, [x1, w0, uxtw]
  40937c:	d65f03c0 	ret

0000000000409380 <hw_irq_ctrl_get_current_lock>:
}
  409380:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  409384:	39418c00 	ldrb	w0, [x0, #99]
  409388:	d65f03c0 	ret

000000000040938c <hw_irq_ctrl_change_lock>:
{
  40938c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	uint32_t previous_lock = irqs_locked;
  409390:	90000161 	adrp	x1, 435000 <stdout_buff+0xc1>
	irqs_locked = new_lock;
  409394:	7100001f 	cmp	w0, #0x0
{
  409398:	910003fd 	mov	x29, sp
	irqs_locked = new_lock;
  40939c:	1a9f07e0 	cset	w0, ne  // ne = any
{
  4093a0:	f9000bf3 	str	x19, [sp, #16]
	uint32_t previous_lock = irqs_locked;
  4093a4:	39418c33 	ldrb	w19, [x1, #99]
	irqs_locked = new_lock;
  4093a8:	39018c20 	strb	w0, [x1, #99]
	if ((previous_lock == true) && (new_lock == false)) {
  4093ac:	7a400a64 	ccmp	w19, #0x0, #0x4, eq  // eq = none
  4093b0:	540000a0 	b.eq	4093c4 <hw_irq_ctrl_change_lock+0x38>  // b.none
		if (irq_status != 0U) {
  4093b4:	d0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  4093b8:	f9477400 	ldr	x0, [x0, #3816]
  4093bc:	b4000040 	cbz	x0, 4093c4 <hw_irq_ctrl_change_lock+0x38>
			posix_irq_handler_im_from_sw();
  4093c0:	97ffff90 	bl	409200 <posix_irq_handler_im_from_sw>
}
  4093c4:	2a1303e0 	mov	w0, w19
  4093c8:	f9400bf3 	ldr	x19, [sp, #16]
  4093cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4093d0:	d65f03c0 	ret

00000000004093d4 <hw_irq_ctrl_get_irq_status>:
}
  4093d4:	d0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  4093d8:	f9477400 	ldr	x0, [x0, #3816]
  4093dc:	d65f03c0 	ret

00000000004093e0 <hw_irq_ctrl_get_highest_prio_irq>:
	if (irqs_locked) {
  4093e0:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  4093e4:	39418c00 	ldrb	w0, [x0, #99]
  4093e8:	350003a0 	cbnz	w0, 40945c <hw_irq_ctrl_get_highest_prio_irq+0x7c>
{
  4093ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4093f0:	910003fd 	mov	x29, sp
	uint64_t irq_status = hw_irq_ctrl_get_irq_status();
  4093f4:	97fffff8 	bl	4093d4 <hw_irq_ctrl_get_irq_status>
  4093f8:	aa0003e2 	mov	x2, x0
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  4093fc:	b0000140 	adrp	x0, 432000 <__dso_handle>
		if ((winner_prio > (int)irq_prio[irq_nbr])
  409400:	90000164 	adrp	x4, 435000 <stdout_buff+0xc1>
  409404:	91010c84 	add	x4, x4, #0x43
	int winner_prio = 256;
  409408:	52802003 	mov	w3, #0x100                 	// #256
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40940c:	b94a3406 	ldr	w6, [x0, #2612]
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  409410:	d2800027 	mov	x7, #0x1                   	// #1
	int winner = -1;
  409414:	12800000 	mov	w0, #0xffffffff            	// #-1
	while (irq_status != 0U) {
  409418:	b5000062 	cbnz	x2, 409424 <hw_irq_ctrl_get_highest_prio_irq+0x44>
}
  40941c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  409420:	d65f03c0 	ret
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
  409424:	5ac00041 	rbit	w1, w2
  409428:	7100005f 	cmp	w2, #0x0
  40942c:	5ac01021 	clz	w1, w1
  409430:	1a8107e1 	csinc	w1, wzr, w1, eq  // eq = none
		int irq_nbr = find_lsb_set(irq_status) - 1;
  409434:	51000421 	sub	w1, w1, #0x1
		irq_status &= ~((uint64_t) 1 << irq_nbr);
  409438:	9ac120e5 	lsl	x5, x7, x1
  40943c:	8a250042 	bic	x2, x2, x5
		if ((winner_prio > (int)irq_prio[irq_nbr])
  409440:	3861c885 	ldrb	w5, [x4, w1, sxtw]
  409444:	6b0300bf 	cmp	w5, w3
  409448:	54fffe8a 	b.ge	409418 <hw_irq_ctrl_get_highest_prio_irq+0x38>  // b.tcont
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
  40944c:	6b0600bf 	cmp	w5, w6
  409450:	1a85a063 	csel	w3, w3, w5, ge  // ge = tcont
  409454:	1a81a000 	csel	w0, w0, w1, ge  // ge = tcont
  409458:	17fffff0 	b	409418 <hw_irq_ctrl_get_highest_prio_irq+0x38>
		return -1;
  40945c:	12800000 	mov	w0, #0xffffffff            	// #-1
}
  409460:	d65f03c0 	ret

0000000000409464 <hw_irq_ctrl_clear_irq>:
	irq_status  &= ~((uint64_t)1<<irq);
  409464:	d0000142 	adrp	x2, 433000 <obj_0x28+0x18>
  409468:	d2800021 	mov	x1, #0x1                   	// #1
  40946c:	9ac02020 	lsl	x0, x1, x0
  409470:	f9477441 	ldr	x1, [x2, #3816]
  409474:	8a200021 	bic	x1, x1, x0
  409478:	f9077441 	str	x1, [x2, #3816]
	irq_premask &= ~((uint64_t)1<<irq);
  40947c:	d0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  409480:	f9477022 	ldr	x2, [x1, #3808]
  409484:	8a200040 	bic	x0, x2, x0
  409488:	f9077020 	str	x0, [x1, #3808]
}
  40948c:	d65f03c0 	ret

0000000000409490 <hw_irq_ctrl_set_irq>:
{
  409490:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409494:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  409498:	97ffff84 	bl	4092a8 <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
  40949c:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  4094a0:	39418c00 	ldrb	w0, [x0, #99]
  4094a4:	34000080 	cbz	w0, 4094b4 <hw_irq_ctrl_set_irq+0x24>
  4094a8:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  4094ac:	39419000 	ldrb	w0, [x0, #100]
  4094b0:	340000e0 	cbz	w0, 4094cc <hw_irq_ctrl_set_irq+0x3c>
		irq_ctrl_timer = hwm_get_time();
  4094b4:	97fffdb5 	bl	408b88 <hwm_get_time>
  4094b8:	90000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4094bc:	f9478821 	ldr	x1, [x1, #3856]
  4094c0:	f9000020 	str	x0, [x1]
}
  4094c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
		hwm_find_next_timer();
  4094c8:	17fffd60 	b	408a48 <hwm_find_next_timer>
}
  4094cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4094d0:	d65f03c0 	ret

00000000004094d4 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
  4094d4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4094d8:	910003fd 	mov	x29, sp
	hw_irq_ctrl_irq_raise_prefix(irq);
  4094dc:	97ffff73 	bl	4092a8 <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
  4094e0:	90000160 	adrp	x0, 435000 <stdout_buff+0xc1>
  4094e4:	39418c00 	ldrb	w0, [x0, #99]
  4094e8:	35000060 	cbnz	w0, 4094f4 <hw_irq_ctrl_raise_im_from_sw+0x20>
		posix_irq_handler_im_from_sw();
	}
}
  4094ec:	a8c17bfd 	ldp	x29, x30, [sp], #16
		posix_irq_handler_im_from_sw();
  4094f0:	17ffff44 	b	409200 <posix_irq_handler_im_from_sw>
}
  4094f4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4094f8:	d65f03c0 	ret

00000000004094fc <hw_irq_ctrl_enable_irq>:
	irq_mask |= ((uint64_t)1<<irq);
  4094fc:	d0000143 	adrp	x3, 433000 <obj_0x28+0x18>
  409500:	d2800021 	mov	x1, #0x1                   	// #1
  409504:	9ac02021 	lsl	x1, x1, x0
  409508:	f9476c64 	ldr	x4, [x3, #3800]
  40950c:	aa040021 	orr	x1, x1, x4
  409510:	f9076c61 	str	x1, [x3, #3800]
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
  409514:	d0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  409518:	f9477021 	ldr	x1, [x1, #3808]
  40951c:	9ac02421 	lsr	x1, x1, x0
  409520:	36000041 	tbz	w1, #0, 409528 <hw_irq_ctrl_enable_irq+0x2c>
		hw_irq_ctrl_raise_im_from_sw(irq);
  409524:	17ffffec 	b	4094d4 <hw_irq_ctrl_raise_im_from_sw>
}
  409528:	d65f03c0 	ret

000000000040952c <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
	irq_ctrl_timer = NEVER;
  40952c:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  409530:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  409534:	f9478800 	ldr	x0, [x0, #3856]
  409538:	f9000001 	str	x1, [x0]
	irq_raising_from_hw_now();
  40953c:	17ffff52 	b	409284 <irq_raising_from_hw_now>

0000000000409540 <posix_exit>:
#include <zephyr/sys/time_units.h>
#include "cmdline.h"
#include "irq_ctrl.h"

void posix_exit(int exit_code)
{
  409540:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409544:	910003fd 	mov	x29, sp
  409548:	f9000bf3 	str	x19, [sp, #16]
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
  40954c:	f0000153 	adrp	x19, 434000 <ztest_thread+0xb8>
  409550:	b94df261 	ldr	w1, [x19, #3568]
  409554:	6b00003f 	cmp	w1, w0
  409558:	1a80a021 	csel	w1, w1, w0, ge  // ge = tcont
  40955c:	b90df261 	str	w1, [x19, #3568]
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
  409560:	97fffcd5 	bl	4088b4 <posix_soc_clean_up>
	hwm_cleanup();
  409564:	97fffd94 	bl	408bb4 <hwm_cleanup>
	native_cleanup_cmd_line();
  409568:	9400030e 	bl	40a1a0 <native_cleanup_cmd_line>
	exit(max_exit_code);
  40956c:	b94df260 	ldr	w0, [x19, #3568]
  409570:	97ffdf84 	bl	401380 <exit@plt>

0000000000409574 <posix_init>:
 * Run all early native_posix initialization steps, including command
 * line parsing and CPU start, until we are ready to let the HW models
 * run via hwm_one_event()
 */
void posix_init(int argc, char *argv[])
{
  409574:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	 * Let's ensure that even if we are redirecting to a file, we get stdout
	 * and stderr line buffered (default for console)
	 * Note that glibc ignores size. But just in case we set a reasonable
	 * number in case somebody tries to compile against a different library
	 */
	setvbuf(stdout, NULL, _IOLBF, 512);
  409578:	d2804003 	mov	x3, #0x200                 	// #512
  40957c:	52800022 	mov	w2, #0x1                   	// #1
{
  409580:	910003fd 	mov	x29, sp
  409584:	a90153f3 	stp	x19, x20, [sp, #16]
  409588:	2a0003f3 	mov	w19, w0
	setvbuf(stdout, NULL, _IOLBF, 512);
  40958c:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
{
  409590:	aa0103f4 	mov	x20, x1
	setvbuf(stdout, NULL, _IOLBF, 512);
  409594:	d2800001 	mov	x1, #0x0                   	// #0
  409598:	f9472c00 	ldr	x0, [x0, #3672]
  40959c:	f9400000 	ldr	x0, [x0]
  4095a0:	97ffdf98 	bl	401400 <setvbuf@plt>
	setvbuf(stderr, NULL, _IOLBF, 512);
  4095a4:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4095a8:	d2804003 	mov	x3, #0x200                 	// #512
  4095ac:	52800022 	mov	w2, #0x1                   	// #1
  4095b0:	d2800001 	mov	x1, #0x0                   	// #0
  4095b4:	f946f000 	ldr	x0, [x0, #3552]
  4095b8:	f9400000 	ldr	x0, [x0]
  4095bc:	97ffdf91 	bl	401400 <setvbuf@plt>

	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
  4095c0:	52800000 	mov	w0, #0x0                   	// #0
  4095c4:	97fffcaa 	bl	40886c <run_native_tasks>

	native_handle_cmd_line(argc, argv);
  4095c8:	aa1403e1 	mov	x1, x20
  4095cc:	2a1303e0 	mov	w0, w19
  4095d0:	94000335 	bl	40a2a4 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
  4095d4:	52800020 	mov	w0, #0x1                   	// #1
  4095d8:	97fffca5 	bl	40886c <run_native_tasks>

	hwm_init();
  4095dc:	97fffd6e 	bl	408b94 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
  4095e0:	52800040 	mov	w0, #0x2                   	// #2
  4095e4:	97fffca2 	bl	40886c <run_native_tasks>

	posix_boot_cpu();
  4095e8:	97fffc67 	bl	408784 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
}
  4095ec:	a94153f3 	ldp	x19, x20, [sp, #16]
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  4095f0:	52800060 	mov	w0, #0x3                   	// #3
}
  4095f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
  4095f8:	17fffc9d 	b	40886c <run_native_tasks>

00000000004095fc <main>:
 *
 * Not used when building fuzz cases, as libfuzzer has its own main()
 * and calls the "OS" through a per-case fuzz test entry point.
 */
int main(int argc, char *argv[])
{
  4095fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  409600:	910003fd 	mov	x29, sp
	posix_init(argc, argv);
  409604:	97ffffdc 	bl	409574 <posix_init>
	while (true) {
		hwm_one_event();
  409608:	97fffd29 	bl	408aac <hwm_one_event>
	while (true) {
  40960c:	17ffffff 	b	409608 <main+0xc>

0000000000409610 <trace_disable_color>:
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
	is_a_tty[0] = 0;
  409610:	b0000140 	adrp	x0, 432000 <__dso_handle>
  409614:	9128e000 	add	x0, x0, #0xa38
  409618:	f900001f 	str	xzr, [x0]
	is_a_tty[1] = 0;
}
  40961c:	d65f03c0 	ret

0000000000409620 <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
	is_a_tty[0] = -1;
  409620:	b0000140 	adrp	x0, 432000 <__dso_handle>
  409624:	9128e000 	add	x0, x0, #0xa38
  409628:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40962c:	f9000001 	str	x1, [x0]
	is_a_tty[1] = -1;

}
  409630:	d65f03c0 	ret

0000000000409634 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
	is_a_tty[0] = 1;
  409634:	b0000140 	adrp	x0, 432000 <__dso_handle>
  409638:	9128e000 	add	x0, x0, #0xa38
  40963c:	b20003e1 	mov	x1, #0x100000001           	// #4294967297
  409640:	f9000001 	str	x1, [x0]
	is_a_tty[1] = 1;
}
  409644:	d65f03c0 	ret

0000000000409648 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
  409648:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40964c:	910003fd 	mov	x29, sp
  409650:	f9000bf3 	str	x19, [sp, #16]
	if (is_a_tty[0] == -1) {
  409654:	b0000153 	adrp	x19, 432000 <__dso_handle>
  409658:	b94a3a60 	ldr	w0, [x19, #2616]
  40965c:	3100041f 	cmn	w0, #0x1
  409660:	54000081 	b.ne	409670 <decide_about_color+0x28>  // b.any
		is_a_tty[0] = isatty(STDOUT_FILENO);
  409664:	52800020 	mov	w0, #0x1                   	// #1
  409668:	97ffdffa 	bl	401650 <isatty@plt>
  40966c:	b90a3a60 	str	w0, [x19, #2616]
	}
	if (is_a_tty[1] == -1) {
  409670:	9128e273 	add	x19, x19, #0xa38
  409674:	b9400660 	ldr	w0, [x19, #4]
  409678:	3100041f 	cmn	w0, #0x1
  40967c:	54000081 	b.ne	40968c <decide_about_color+0x44>  // b.any
		is_a_tty[1] = isatty(STDERR_FILENO);
  409680:	52800040 	mov	w0, #0x2                   	// #2
  409684:	97ffdff3 	bl	401650 <isatty@plt>
  409688:	b9000660 	str	w0, [x19, #4]
	}
}
  40968c:	f9400bf3 	ldr	x19, [sp, #16]
  409690:	a8c27bfd 	ldp	x29, x30, [sp], #32
  409694:	d65f03c0 	ret

0000000000409698 <posix_print_error_and_exit>:
{
  409698:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40969c:	aa0003e8 	mov	x8, x0
  4096a0:	910003fd 	mov	x29, sp
  4096a4:	a9108be1 	stp	x1, x2, [sp, #264]
  4096a8:	90000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
  4096ac:	aa0803e2 	mov	x2, x8
  4096b0:	f9475c21 	ldr	x1, [x1, #3768]
  4096b4:	3d8023e0 	str	q0, [sp, #128]
  4096b8:	3d8027e1 	str	q1, [sp, #144]
  4096bc:	3d802be2 	str	q2, [sp, #160]
  4096c0:	3d802fe3 	str	q3, [sp, #176]
  4096c4:	3d8033e4 	str	q4, [sp, #192]
  4096c8:	3d8037e5 	str	q5, [sp, #208]
  4096cc:	3d803be6 	str	q6, [sp, #224]
  4096d0:	3d803fe7 	str	q7, [sp, #240]
  4096d4:	a91193e3 	stp	x3, x4, [sp, #280]
  4096d8:	910043e3 	add	x3, sp, #0x10
  4096dc:	a9129be5 	stp	x5, x6, [sp, #296]
  4096e0:	f9009fe7 	str	x7, [sp, #312]
  4096e4:	f9400020 	ldr	x0, [x1]
  4096e8:	f9003fe0 	str	x0, [sp, #120]
  4096ec:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  4096f0:	90000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
	va_start(variable_args, format);
  4096f4:	910503e0 	add	x0, sp, #0x140
  4096f8:	a90383e0 	stp	x0, x0, [sp, #56]
  4096fc:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  409700:	f946f021 	ldr	x1, [x1, #3552]
	va_start(variable_args, format);
  409704:	f90027e0 	str	x0, [sp, #72]
  409708:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  40970c:	b90053e0 	str	w0, [sp, #80]
  409710:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  409714:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  409718:	f9400020 	ldr	x0, [x1]
  40971c:	9100e3e1 	add	x1, sp, #0x38
  409720:	ad400420 	ldp	q0, q1, [x1]
  409724:	910163e1 	add	x1, sp, #0x58
  409728:	ad000420 	stp	q0, q1, [x1]
  40972c:	52800021 	mov	w1, #0x1                   	// #1
  409730:	ad000460 	stp	q0, q1, [x3]
  409734:	97ffdf63 	bl	4014c0 <__vfprintf_chk@plt>
	posix_exit(1);
  409738:	52800020 	mov	w0, #0x1                   	// #1
  40973c:	97ffff81 	bl	409540 <posix_exit>
}
  409740:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  409744:	f9475c00 	ldr	x0, [x0, #3768]
  409748:	f9403fe2 	ldr	x2, [sp, #120]
  40974c:	f9400001 	ldr	x1, [x0]
  409750:	eb010042 	subs	x2, x2, x1
  409754:	d2800001 	mov	x1, #0x0                   	// #0
  409758:	54000040 	b.eq	409760 <posix_print_error_and_exit+0xc8>  // b.none
  40975c:	97ffdf71 	bl	401520 <__stack_chk_fail@plt>
  409760:	a8d47bfd 	ldp	x29, x30, [sp], #320
  409764:	d65f03c0 	ret

0000000000409768 <posix_print_warning>:
{
  409768:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  40976c:	aa0003e8 	mov	x8, x0
  409770:	910003fd 	mov	x29, sp
  409774:	a9108be1 	stp	x1, x2, [sp, #264]
  409778:	90000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40977c:	aa0803e2 	mov	x2, x8
  409780:	f9475c21 	ldr	x1, [x1, #3768]
  409784:	3d8023e0 	str	q0, [sp, #128]
  409788:	3d8027e1 	str	q1, [sp, #144]
  40978c:	3d802be2 	str	q2, [sp, #160]
  409790:	3d802fe3 	str	q3, [sp, #176]
  409794:	3d8033e4 	str	q4, [sp, #192]
  409798:	3d8037e5 	str	q5, [sp, #208]
  40979c:	3d803be6 	str	q6, [sp, #224]
  4097a0:	3d803fe7 	str	q7, [sp, #240]
  4097a4:	a91193e3 	stp	x3, x4, [sp, #280]
  4097a8:	910043e3 	add	x3, sp, #0x10
  4097ac:	a9129be5 	stp	x5, x6, [sp, #296]
  4097b0:	f9009fe7 	str	x7, [sp, #312]
  4097b4:	f9400020 	ldr	x0, [x1]
  4097b8:	f9003fe0 	str	x0, [sp, #120]
  4097bc:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stderr, format, variable_args);
  4097c0:	90000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
	va_start(variable_args, format);
  4097c4:	910503e0 	add	x0, sp, #0x140
  4097c8:	a90383e0 	stp	x0, x0, [sp, #56]
  4097cc:	910403e0 	add	x0, sp, #0x100
	vfprintf(stderr, format, variable_args);
  4097d0:	f946f021 	ldr	x1, [x1, #3552]
	va_start(variable_args, format);
  4097d4:	f90027e0 	str	x0, [sp, #72]
  4097d8:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  4097dc:	b90053e0 	str	w0, [sp, #80]
  4097e0:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  4097e4:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stderr, format, variable_args);
  4097e8:	f9400020 	ldr	x0, [x1]
  4097ec:	9100e3e1 	add	x1, sp, #0x38
  4097f0:	ad400420 	ldp	q0, q1, [x1]
  4097f4:	910163e1 	add	x1, sp, #0x58
  4097f8:	ad000420 	stp	q0, q1, [x1]
  4097fc:	52800021 	mov	w1, #0x1                   	// #1
  409800:	ad000460 	stp	q0, q1, [x3]
  409804:	97ffdf2f 	bl	4014c0 <__vfprintf_chk@plt>
}
  409808:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40980c:	f9475c00 	ldr	x0, [x0, #3768]
  409810:	f9403fe2 	ldr	x2, [sp, #120]
  409814:	f9400001 	ldr	x1, [x0]
  409818:	eb010042 	subs	x2, x2, x1
  40981c:	d2800001 	mov	x1, #0x0                   	// #0
  409820:	54000040 	b.eq	409828 <posix_print_warning+0xc0>  // b.none
  409824:	97ffdf3f 	bl	401520 <__stack_chk_fail@plt>
  409828:	a8d47bfd 	ldp	x29, x30, [sp], #320
  40982c:	d65f03c0 	ret

0000000000409830 <posix_print_trace>:
{
  409830:	a9ac7bfd 	stp	x29, x30, [sp, #-320]!
  409834:	aa0003e8 	mov	x8, x0
  409838:	910003fd 	mov	x29, sp
  40983c:	a9108be1 	stp	x1, x2, [sp, #264]
  409840:	90000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  409844:	aa0803e2 	mov	x2, x8
  409848:	f9475c21 	ldr	x1, [x1, #3768]
  40984c:	3d8023e0 	str	q0, [sp, #128]
  409850:	3d8027e1 	str	q1, [sp, #144]
  409854:	3d802be2 	str	q2, [sp, #160]
  409858:	3d802fe3 	str	q3, [sp, #176]
  40985c:	3d8033e4 	str	q4, [sp, #192]
  409860:	3d8037e5 	str	q5, [sp, #208]
  409864:	3d803be6 	str	q6, [sp, #224]
  409868:	3d803fe7 	str	q7, [sp, #240]
  40986c:	a91193e3 	stp	x3, x4, [sp, #280]
  409870:	910043e3 	add	x3, sp, #0x10
  409874:	a9129be5 	stp	x5, x6, [sp, #296]
  409878:	f9009fe7 	str	x7, [sp, #312]
  40987c:	f9400020 	ldr	x0, [x1]
  409880:	f9003fe0 	str	x0, [sp, #120]
  409884:	d2800000 	mov	x0, #0x0                   	// #0
	vfprintf(stdout, format, variable_args);
  409888:	90000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
	va_start(variable_args, format);
  40988c:	910503e0 	add	x0, sp, #0x140
  409890:	a90383e0 	stp	x0, x0, [sp, #56]
  409894:	910403e0 	add	x0, sp, #0x100
	vfprintf(stdout, format, variable_args);
  409898:	f9472c21 	ldr	x1, [x1, #3672]
	va_start(variable_args, format);
  40989c:	f90027e0 	str	x0, [sp, #72]
  4098a0:	128006e0 	mov	w0, #0xffffffc8            	// #-56
  4098a4:	b90053e0 	str	w0, [sp, #80]
  4098a8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  4098ac:	b90057e0 	str	w0, [sp, #84]
	vfprintf(stdout, format, variable_args);
  4098b0:	f9400020 	ldr	x0, [x1]
  4098b4:	9100e3e1 	add	x1, sp, #0x38
  4098b8:	ad400420 	ldp	q0, q1, [x1]
  4098bc:	910163e1 	add	x1, sp, #0x58
  4098c0:	ad000420 	stp	q0, q1, [x1]
  4098c4:	52800021 	mov	w1, #0x1                   	// #1
  4098c8:	ad000460 	stp	q0, q1, [x3]
  4098cc:	97ffdefd 	bl	4014c0 <__vfprintf_chk@plt>
}
  4098d0:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4098d4:	f9475c00 	ldr	x0, [x0, #3768]
  4098d8:	f9403fe2 	ldr	x2, [sp, #120]
  4098dc:	f9400001 	ldr	x1, [x0]
  4098e0:	eb010042 	subs	x2, x2, x1
  4098e4:	d2800001 	mov	x1, #0x0                   	// #0
  4098e8:	54000040 	b.eq	4098f0 <posix_print_trace+0xc0>  // b.none
  4098ec:	97ffdf0d 	bl	401520 <__stack_chk_fail@plt>
  4098f0:	a8d47bfd 	ldp	x29, x30, [sp], #320
  4098f4:	d65f03c0 	ret

00000000004098f8 <native_add_tracing_options>:
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
  4098f8:	b0000140 	adrp	x0, 432000 <__dso_handle>
  4098fc:	9118c000 	add	x0, x0, #0x630
  409900:	14000233 	b	40a1cc <native_add_command_line_opts>

0000000000409904 <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
  409904:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  409908:	910003fd 	mov	x29, sp
  40990c:	a90153f3 	stp	x19, x20, [sp, #16]
  409910:	aa0003f4 	mov	x20, x0
  409914:	a9025bf5 	stp	x21, x22, [sp, #32]
  409918:	aa0103f6 	mov	x22, x1

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
  40991c:	39400420 	ldrb	w0, [x1, #1]
  409920:	35000440 	cbnz	w0, 4099a8 <cmd_gen_switch_syntax.constprop.0+0xa4>
		*buf++ = '[';
  409924:	52800b60 	mov	w0, #0x5b                  	// #91
		size--;
  409928:	528008b5 	mov	w21, #0x45                  	// #69
		*buf++ = '[';
  40992c:	38001680 	strb	w0, [x20], #1
	}

	if (args_s_el->is_switch == true) {
  409930:	39400ac0 	ldrb	w0, [x22, #2]
		ret = snprintf(buf, size, "-%s", args_s_el->option);
  409934:	93407ea1 	sxtw	x1, w21
  409938:	f94006c5 	ldr	x5, [x22, #8]
	if (args_s_el->is_switch == true) {
  40993c:	340003a0 	cbz	w0, 4099b0 <cmd_gen_switch_syntax.constprop.0+0xac>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  409940:	90000084 	adrp	x4, 419000 <__func__.2+0xa80>
  409944:	aa1403e0 	mov	x0, x20
  409948:	910fb884 	add	x4, x4, #0x3ee
  40994c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  409950:	52800022 	mov	w2, #0x1                   	// #1
  409954:	97ffdeb7 	bl	401430 <__snprintf_chk@plt>
  409958:	2a0003f3 	mov	w19, w0
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
  40995c:	36f800e0 	tbz	w0, #31, 409978 <cmd_gen_switch_syntax.constprop.0+0x74>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
  409960:	90000081 	adrp	x1, 419000 <__func__.2+0xa80>
  409964:	90000080 	adrp	x0, 419000 <__func__.2+0xa80>
  409968:	91101c21 	add	x1, x1, #0x407
  40996c:	91111400 	add	x0, x0, #0x445
  409970:	528020e2 	mov	w2, #0x107                 	// #263
  409974:	97ffff49 	bl	409698 <posix_print_error_and_exit>
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
  409978:	6b1302a1 	subs	w1, w21, w19
  40997c:	540003c4 	b.mi	4099f4 <cmd_gen_switch_syntax.constprop.0+0xf0>  // b.first
		return;
	}
	buf += ret;
	size -= ret;

	if (args_s_el->is_mandatory == false) {
  409980:	394006c2 	ldrb	w2, [x22, #1]
	buf += ret;
  409984:	8b33c280 	add	x0, x20, w19, sxtw
		snprintf(buf, size, "] ");
  409988:	93407c21 	sxtw	x1, w1
	if (args_s_el->is_mandatory == false) {
  40998c:	350002e2 	cbnz	w2, 4099e8 <cmd_gen_switch_syntax.constprop.0+0xe4>
  409990:	f0000062 	adrp	x2, 418000 <table.0+0x1d8>
  409994:	9129f042 	add	x2, x2, #0xa7c
	} else {
		snprintf(buf, size, " ");
	}
}
  409998:	a94153f3 	ldp	x19, x20, [sp, #16]
  40999c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4099a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4099a4:	17ffde9b 	b	401410 <snprintf@plt>
  4099a8:	528008d5 	mov	w21, #0x46                  	// #70
  4099ac:	17ffffe1 	b	409930 <cmd_gen_switch_syntax.constprop.0+0x2c>
		if (args_s_el->type != 'l') {
  4099b0:	394062c0 	ldrb	w0, [x22, #24]
			ret = snprintf(buf, size, "-%s=<%s>",
  4099b4:	f9400ac6 	ldr	x6, [x22, #16]
		if (args_s_el->type != 'l') {
  4099b8:	7101b01f 	cmp	w0, #0x6c
  4099bc:	54000100 	b.eq	4099dc <cmd_gen_switch_syntax.constprop.0+0xd8>  // b.none
  4099c0:	90000084 	adrp	x4, 419000 <__func__.2+0xa80>
  4099c4:	910fc884 	add	x4, x4, #0x3f2
  4099c8:	aa1403e0 	mov	x0, x20
  4099cc:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  4099d0:	52800022 	mov	w2, #0x1                   	// #1
  4099d4:	97ffde97 	bl	401430 <__snprintf_chk@plt>
  4099d8:	17ffffe0 	b	409958 <cmd_gen_switch_syntax.constprop.0+0x54>
  4099dc:	90000084 	adrp	x4, 419000 <__func__.2+0xa80>
  4099e0:	910fec84 	add	x4, x4, #0x3fb
  4099e4:	17fffff9 	b	4099c8 <cmd_gen_switch_syntax.constprop.0+0xc4>
  4099e8:	f0000062 	adrp	x2, 418000 <table.0+0x1d8>
  4099ec:	912a8842 	add	x2, x2, #0xaa2
  4099f0:	17ffffea 	b	409998 <cmd_gen_switch_syntax.constprop.0+0x94>
}
  4099f4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4099f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4099fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  409a00:	d65f03c0 	ret

0000000000409a04 <cmd_is_option>:
{
  409a04:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  409a08:	910003fd 	mov	x29, sp
  409a0c:	a90153f3 	stp	x19, x20, [sp, #16]
  409a10:	aa0003f4 	mov	x20, x0
  409a14:	2a0203f3 	mov	w19, w2
	size_t to_match_len = strlen(option);
  409a18:	aa0103e0 	mov	x0, x1
{
  409a1c:	a9025bf5 	stp	x21, x22, [sp, #32]
  409a20:	aa0103f5 	mov	x21, x1
  409a24:	f9001bf7 	str	x23, [sp, #48]
	size_t to_match_len = strlen(option);
  409a28:	97ffde52 	bl	401370 <strlen@plt>
  409a2c:	aa0003f7 	mov	x23, x0
	if (arg[of] == '-') {
  409a30:	39400280 	ldrb	w0, [x20]
  409a34:	7100b41f 	cmp	w0, #0x2d
	if (arg[of] == '-') {
  409a38:	9a9f17e0 	cset	x0, eq  // eq = none
	if (arg[of] == '-') {
  409a3c:	1a9f17f6 	cset	w22, eq  // eq = none
	if (arg[of] == '-') {
  409a40:	38606a80 	ldrb	w0, [x20, x0]
		of++;
  409a44:	7100b41f 	cmp	w0, #0x2d
  409a48:	1a9616d6 	cinc	w22, w22, eq  // eq = none
	if (!with_value) {
  409a4c:	93407ec2 	sxtw	x2, w22
  409a50:	34000293 	cbz	w19, 409aa0 <cmd_is_option+0x9c>
		if (*option == 0) {
  409a54:	cb0202b5 	sub	x21, x21, x2
	while (!(arg[of] == 0 && *option == 0)) {
  409a58:	38626a80 	ldrb	w0, [x20, x2]
  409a5c:	2a0203f3 	mov	w19, w2
		if (*option == 0) {
  409a60:	38626aa1 	ldrb	w1, [x21, x2]
	while (!(arg[of] == 0 && *option == 0)) {
  409a64:	2a010003 	orr	w3, w0, w1
  409a68:	34000123 	cbz	w3, 409a8c <cmd_is_option+0x88>
		if (*option == 0) {
  409a6c:	35000301 	cbnz	w1, 409acc <cmd_is_option+0xc8>
			if ((arg[of] == ':') || (arg[of] == '=')) {
  409a70:	7100e81f 	cmp	w0, #0x3a
  409a74:	528007a1 	mov	w1, #0x3d                  	// #61
  409a78:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  409a7c:	540002e1 	b.ne	409ad8 <cmd_is_option+0xd4>  // b.any
				of++;
  409a80:	11000673 	add	w19, w19, #0x1
	if (arg[of] == 0) { /* we need a value to follow */
  409a84:	3873ca80 	ldrb	w0, [x20, w19, sxtw]
  409a88:	35000160 	cbnz	w0, 409ab4 <cmd_is_option+0xb0>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
  409a8c:	aa1403e1 	mov	x1, x20
  409a90:	90000080 	adrp	x0, 419000 <__func__.2+0xa80>
  409a94:	91118000 	add	x0, x0, #0x460
  409a98:	97ffff00 	bl	409698 <posix_print_error_and_exit>
  409a9c:	14000006 	b	409ab4 <cmd_is_option+0xb0>
		if (strcmp(&arg[of], option) != 0) {
  409aa0:	aa1503e1 	mov	x1, x21
  409aa4:	8b020280 	add	x0, x20, x2
  409aa8:	97ffdeba 	bl	401590 <strcmp@plt>
  409aac:	35000040 	cbnz	w0, 409ab4 <cmd_is_option+0xb0>
			return of + to_match_len;
  409ab0:	0b1702d3 	add	w19, w22, w23
}
  409ab4:	2a1303e0 	mov	w0, w19
  409ab8:	a94153f3 	ldp	x19, x20, [sp, #16]
  409abc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409ac0:	f9401bf7 	ldr	x23, [sp, #48]
  409ac4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  409ac8:	d65f03c0 	ret
		if (arg[of] != *option) {
  409acc:	91000442 	add	x2, x2, #0x1
  409ad0:	6b01001f 	cmp	w0, w1
  409ad4:	54fffc20 	b.eq	409a58 <cmd_is_option+0x54>  // b.none
			return 0;
  409ad8:	52800013 	mov	w19, #0x0                   	// #0
  409adc:	17fffff6 	b	409ab4 <cmd_is_option+0xb0>

0000000000409ae0 <cmd_is_help_option>:
{
  409ae0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  409ae4:	910003fd 	mov	x29, sp
  409ae8:	f9000bf3 	str	x19, [sp, #16]
  409aec:	aa0003f3 	mov	x19, x0
	if (arg[0] == '-') {
  409af0:	39400000 	ldrb	w0, [x0]
  409af4:	7100b41f 	cmp	w0, #0x2d
  409af8:	540000c1 	b.ne	409b10 <cmd_is_help_option+0x30>  // b.any
	if (arg[0] == '-') {
  409afc:	aa1303e0 	mov	x0, x19
		arg++;
  409b00:	91000a73 	add	x19, x19, #0x2
	if (arg[0] == '-') {
  409b04:	38401c01 	ldrb	w1, [x0, #1]!
		arg++;
  409b08:	7100b43f 	cmp	w1, #0x2d
  409b0c:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	if ((strcasecmp(arg, "?") == 0) ||
  409b10:	90000081 	adrp	x1, 419000 <__func__.2+0xa80>
  409b14:	aa1303e0 	mov	x0, x19
  409b18:	9112e821 	add	x1, x1, #0x4ba
  409b1c:	97ffde75 	bl	4014f0 <strcasecmp@plt>
  409b20:	340001e0 	cbz	w0, 409b5c <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "h") == 0) ||
  409b24:	b0000081 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  409b28:	aa1303e0 	mov	x0, x19
  409b2c:	911c1021 	add	x1, x1, #0x704
  409b30:	97ffde70 	bl	4014f0 <strcasecmp@plt>
	if ((strcasecmp(arg, "?") == 0) ||
  409b34:	34000140 	cbz	w0, 409b5c <cmd_is_help_option+0x7c>
	    (strcasecmp(arg, "help") == 0)) {
  409b38:	aa1303e0 	mov	x0, x19
  409b3c:	90000081 	adrp	x1, 419000 <__func__.2+0xa80>
  409b40:	91155821 	add	x1, x1, #0x556
  409b44:	97ffde6b 	bl	4014f0 <strcasecmp@plt>
	    (strcasecmp(arg, "h") == 0) ||
  409b48:	7100001f 	cmp	w0, #0x0
  409b4c:	1a9f17e0 	cset	w0, eq  // eq = none
}
  409b50:	f9400bf3 	ldr	x19, [sp, #16]
  409b54:	a8c27bfd 	ldp	x29, x30, [sp], #32
  409b58:	d65f03c0 	ret
		return 1;
  409b5c:	52800020 	mov	w0, #0x1                   	// #1
  409b60:	17fffffc 	b	409b50 <cmd_is_help_option+0x70>

0000000000409b64 <cmd_read_option_value>:
{
  409b64:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  409b68:	910003fd 	mov	x29, sp
  409b6c:	a90153f3 	stp	x19, x20, [sp, #16]
  409b70:	aa0103f4 	mov	x20, x1
  409b74:	12001c41 	and	w1, w2, #0xff
  409b78:	90000142 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  409b7c:	f90013f5 	str	x21, [sp, #32]
  409b80:	aa0303f5 	mov	x21, x3
  409b84:	aa0003f3 	mov	x19, x0
  409b88:	f9475c42 	ldr	x2, [x2, #3768]
  409b8c:	f9400043 	ldr	x3, [x2]
  409b90:	f9001fe3 	str	x3, [sp, #56]
  409b94:	d2800003 	mov	x3, #0x0                   	// #0
	char *endptr = NULL;
  409b98:	f9001bff 	str	xzr, [sp, #48]
	switch (type) {
  409b9c:	7101903f 	cmp	w1, #0x64
  409ba0:	54000b40 	b.eq	409d08 <cmd_read_option_value+0x1a4>  // b.none
  409ba4:	54000168 	b.hi	409bd0 <cmd_read_option_value+0x6c>  // b.pmore
  409ba8:	7101543f 	cmp	w1, #0x55
  409bac:	540009c0 	b.eq	409ce4 <cmd_read_option_value+0x180>  // b.none
  409bb0:	7101883f 	cmp	w1, #0x62
  409bb4:	54000220 	b.eq	409bf8 <cmd_read_option_value+0x94>  // b.none
  409bb8:	7101243f 	cmp	w1, #0x49
  409bbc:	540009e0 	b.eq	409cf8 <cmd_read_option_value+0x194>  // b.none
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
  409bc0:	90000080 	adrp	x0, 419000 <__func__.2+0xa80>
  409bc4:	91142c00 	add	x0, x0, #0x50b
  409bc8:	97fffeb4 	bl	409698 <posix_print_error_and_exit>
	if (!error && endptr && *endptr != 0) {
  409bcc:	14000012 	b	409c14 <cmd_read_option_value+0xb0>
	switch (type) {
  409bd0:	7101cc3f 	cmp	w1, #0x73
  409bd4:	54000760 	b.eq	409cc0 <cmd_read_option_value+0x15c>  // b.none
  409bd8:	7101d43f 	cmp	w1, #0x75
  409bdc:	540007a0 	b.eq	409cd0 <cmd_read_option_value+0x16c>  // b.none
  409be0:	7101a43f 	cmp	w1, #0x69
  409be4:	54fffee1 	b.ne	409bc0 <cmd_read_option_value+0x5c>  // b.any
		*(int32_t *)dest = strtol(str, &endptr, 0);
  409be8:	9100c3e1 	add	x1, sp, #0x30
  409bec:	52800002 	mov	w2, #0x0                   	// #0
  409bf0:	97ffde74 	bl	4015c0 <strtol@plt>
  409bf4:	1400003a 	b	409cdc <cmd_read_option_value+0x178>
		if (strcasecmp(str, "false") == 0) {
  409bf8:	90000081 	adrp	x1, 419000 <__func__.2+0xa80>
  409bfc:	9112f021 	add	x1, x1, #0x4bc
  409c00:	97ffde3c 	bl	4014f0 <strcasecmp@plt>
  409c04:	35000120 	cbnz	w0, 409c28 <cmd_read_option_value+0xc4>
			endptr = (char *)str + 5;
  409c08:	91001660 	add	x0, x19, #0x5
			*(bool *)dest = false;
  409c0c:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  409c10:	f9001be0 	str	x0, [sp, #48]
	if (!error && endptr && *endptr != 0) {
  409c14:	f9401be0 	ldr	x0, [sp, #48]
  409c18:	b40003e0 	cbz	x0, 409c94 <cmd_read_option_value+0x130>
  409c1c:	39400000 	ldrb	w0, [x0]
  409c20:	35000300 	cbnz	w0, 409c80 <cmd_read_option_value+0x11c>
  409c24:	1400001c 	b	409c94 <cmd_read_option_value+0x130>
		} else if (strcmp(str, "0") == 0) {
  409c28:	b0000081 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  409c2c:	aa1303e0 	mov	x0, x19
  409c30:	91253c21 	add	x1, x1, #0x94f
  409c34:	97ffde57 	bl	401590 <strcmp@plt>
  409c38:	35000080 	cbnz	w0, 409c48 <cmd_read_option_value+0xe4>
			*(bool *)dest = false;
  409c3c:	3900029f 	strb	wzr, [x20]
			endptr = (char *)str + 1;
  409c40:	91000660 	add	x0, x19, #0x1
  409c44:	17fffff3 	b	409c10 <cmd_read_option_value+0xac>
		} else if (strcasecmp(str, "true") == 0) {
  409c48:	90000081 	adrp	x1, 419000 <__func__.2+0xa80>
  409c4c:	aa1303e0 	mov	x0, x19
  409c50:	91130821 	add	x1, x1, #0x4c2
  409c54:	97ffde27 	bl	4014f0 <strcasecmp@plt>
  409c58:	350000a0 	cbnz	w0, 409c6c <cmd_read_option_value+0x108>
			*(bool *)dest = true;
  409c5c:	52800020 	mov	w0, #0x1                   	// #1
  409c60:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 4;
  409c64:	91001260 	add	x0, x19, #0x4
  409c68:	17ffffea 	b	409c10 <cmd_read_option_value+0xac>
		} else if (strcmp(str, "1") == 0) {
  409c6c:	90000081 	adrp	x1, 419000 <__func__.2+0xa80>
  409c70:	aa1303e0 	mov	x0, x19
  409c74:	91131c21 	add	x1, x1, #0x4c7
  409c78:	97ffde46 	bl	401590 <strcmp@plt>
  409c7c:	340001c0 	cbz	w0, 409cb4 <cmd_read_option_value+0x150>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
  409c80:	90000080 	adrp	x0, 419000 <__func__.2+0xa80>
  409c84:	aa1303e2 	mov	x2, x19
  409c88:	aa1503e1 	mov	x1, x21
  409c8c:	91132400 	add	x0, x0, #0x4c9
  409c90:	97fffe82 	bl	409698 <posix_print_error_and_exit>
}
  409c94:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  409c98:	f9475c00 	ldr	x0, [x0, #3768]
  409c9c:	f9401fe2 	ldr	x2, [sp, #56]
  409ca0:	f9400001 	ldr	x1, [x0]
  409ca4:	eb010042 	subs	x2, x2, x1
  409ca8:	d2800001 	mov	x1, #0x0                   	// #0
  409cac:	54000360 	b.eq	409d18 <cmd_read_option_value+0x1b4>  // b.none
  409cb0:	97ffde1c 	bl	401520 <__stack_chk_fail@plt>
			*(bool *)dest = true;
  409cb4:	52800020 	mov	w0, #0x1                   	// #1
  409cb8:	39000280 	strb	w0, [x20]
			endptr = (char *)str + 1;
  409cbc:	17ffffe1 	b	409c40 <cmd_read_option_value+0xdc>
		*(char **)dest = (char *)str;
  409cc0:	f9000280 	str	x0, [x20]
		endptr = (char *)str + strlen(str);
  409cc4:	97ffddab 	bl	401370 <strlen@plt>
  409cc8:	8b000260 	add	x0, x19, x0
  409ccc:	17ffffd1 	b	409c10 <cmd_read_option_value+0xac>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
  409cd0:	9100c3e1 	add	x1, sp, #0x30
  409cd4:	52800002 	mov	w2, #0x0                   	// #0
  409cd8:	97ffdda2 	bl	401360 <strtoul@plt>
		*(int32_t *)dest = strtol(str, &endptr, 0);
  409cdc:	b9000280 	str	w0, [x20]
	if (!error && endptr && *endptr != 0) {
  409ce0:	17ffffcd 	b	409c14 <cmd_read_option_value+0xb0>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
  409ce4:	9100c3e1 	add	x1, sp, #0x30
  409ce8:	52800002 	mov	w2, #0x0                   	// #0
  409cec:	97ffde4d 	bl	401620 <strtoull@plt>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  409cf0:	f9000280 	str	x0, [x20]
	if (!error && endptr && *endptr != 0) {
  409cf4:	17ffffc8 	b	409c14 <cmd_read_option_value+0xb0>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
  409cf8:	9100c3e1 	add	x1, sp, #0x30
  409cfc:	52800002 	mov	w2, #0x0                   	// #0
  409d00:	97ffdda8 	bl	4013a0 <strtoll@plt>
  409d04:	17fffffb 	b	409cf0 <cmd_read_option_value+0x18c>
		*(double *)dest = strtod(str, &endptr);
  409d08:	9100c3e1 	add	x1, sp, #0x30
  409d0c:	97ffddad 	bl	4013c0 <strtod@plt>
  409d10:	fd000280 	str	d0, [x20]
	if (!error && endptr && *endptr != 0) {
  409d14:	17ffffc0 	b	409c14 <cmd_read_option_value+0xb0>
}
  409d18:	a94153f3 	ldp	x19, x20, [sp, #16]
  409d1c:	f94013f5 	ldr	x21, [sp, #32]
  409d20:	a8c47bfd 	ldp	x29, x30, [sp], #64
  409d24:	d65f03c0 	ret

0000000000409d28 <cmd_args_set_defaults>:
{
  409d28:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  409d2c:	910003fd 	mov	x29, sp
  409d30:	a90153f3 	stp	x19, x20, [sp, #16]
  409d34:	91002013 	add	x19, x0, #0x8
			*(double *)args_struct[count].dest = (double)NAN;
  409d38:	d0000060 	adrp	x0, 417000 <z_abort_timeout+0x38>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  409d3c:	90000094 	adrp	x20, 419000 <__func__.2+0xa80>
  409d40:	91142e94 	add	x20, x20, #0x50b
{
  409d44:	fd001be8 	str	d8, [sp, #48]
			*(double *)args_struct[count].dest = (double)NAN;
  409d48:	fd46e408 	ldr	d8, [x0, #3528]
{
  409d4c:	a9025bf5 	stp	x21, x22, [sp, #32]
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  409d50:	12800015 	mov	w21, #0xffffffff            	// #-1
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  409d54:	12b00016 	mov	w22, #0x7fffffff            	// #2147483647
	while (args_struct[count].option != NULL) {
  409d58:	f9400260 	ldr	x0, [x19]
  409d5c:	b50000c0 	cbnz	x0, 409d74 <cmd_args_set_defaults+0x4c>
}
  409d60:	a94153f3 	ldp	x19, x20, [sp, #16]
  409d64:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409d68:	fd401be8 	ldr	d8, [sp, #48]
  409d6c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  409d70:	d65f03c0 	ret
		if (args_struct[count].dest == NULL) {
  409d74:	f9400e62 	ldr	x2, [x19, #24]
  409d78:	b4000222 	cbz	x2, 409dbc <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  409d7c:	39404261 	ldrb	w1, [x19, #16]
  409d80:	7101903f 	cmp	w1, #0x64
  409d84:	54000420 	b.eq	409e08 <cmd_args_set_defaults+0xe0>  // b.none
  409d88:	540001e8 	b.hi	409dc4 <cmd_args_set_defaults+0x9c>  // b.pmore
  409d8c:	7101543f 	cmp	w1, #0x55
  409d90:	54000320 	b.eq	409df4 <cmd_args_set_defaults+0xcc>  // b.none
  409d94:	540000e8 	b.hi	409db0 <cmd_args_set_defaults+0x88>  // b.pmore
  409d98:	34000121 	cbz	w1, 409dbc <cmd_args_set_defaults+0x94>
  409d9c:	7101243f 	cmp	w1, #0x49
  409da0:	54000300 	b.eq	409e00 <cmd_args_set_defaults+0xd8>  // b.none
			posix_print_error_and_exit(CMD_TYPE_ERROR,
  409da4:	aa1403e0 	mov	x0, x20
  409da8:	97fffe3c 	bl	409698 <posix_print_error_and_exit>
			break;
  409dac:	14000004 	b	409dbc <cmd_args_set_defaults+0x94>
		switch (args_struct[count].type) {
  409db0:	7101883f 	cmp	w1, #0x62
  409db4:	54ffff81 	b.ne	409da4 <cmd_args_set_defaults+0x7c>  // b.any
			*(bool *)args_struct[count].dest = false;
  409db8:	3900005f 	strb	wzr, [x2]
			break;
  409dbc:	9100e273 	add	x19, x19, #0x38
  409dc0:	17ffffe6 	b	409d58 <cmd_args_set_defaults+0x30>
		switch (args_struct[count].type) {
  409dc4:	7101cc3f 	cmp	w1, #0x73
  409dc8:	540000e0 	b.eq	409de4 <cmd_args_set_defaults+0xbc>  // b.none
  409dcc:	7101d43f 	cmp	w1, #0x75
  409dd0:	540000e0 	b.eq	409dec <cmd_args_set_defaults+0xc4>  // b.none
  409dd4:	7101a43f 	cmp	w1, #0x69
  409dd8:	54fffe61 	b.ne	409da4 <cmd_args_set_defaults+0x7c>  // b.any
			*(int32_t *)args_struct[count].dest = INT32_MAX;
  409ddc:	b9000056 	str	w22, [x2]
			break;
  409de0:	17fffff7 	b	409dbc <cmd_args_set_defaults+0x94>
			*(char **)args_struct[count].dest = NULL;
  409de4:	f900005f 	str	xzr, [x2]
			break;
  409de8:	17fffff5 	b	409dbc <cmd_args_set_defaults+0x94>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
  409dec:	b9000055 	str	w21, [x2]
			break;
  409df0:	17fffff3 	b	409dbc <cmd_args_set_defaults+0x94>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
  409df4:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  409df8:	f9000040 	str	x0, [x2]
			break;
  409dfc:	17fffff0 	b	409dbc <cmd_args_set_defaults+0x94>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
  409e00:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  409e04:	17fffffd 	b	409df8 <cmd_args_set_defaults+0xd0>
			*(double *)args_struct[count].dest = (double)NAN;
  409e08:	fd000048 	str	d8, [x2]
			break;
  409e0c:	17ffffec 	b	409dbc <cmd_args_set_defaults+0x94>

0000000000409e10 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
  409e10:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
  409e14:	90000083 	adrp	x3, 419000 <__func__.2+0xa80>
  409e18:	90000082 	adrp	x2, 419000 <__func__.2+0xa80>
  409e1c:	910003fd 	mov	x29, sp
  409e20:	a90153f3 	stp	x19, x20, [sp, #16]
  409e24:	aa0003f4 	mov	x20, x0
  409e28:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;

	fprintf(stdout, "%s ", _HELP_SWITCH);
  409e2c:	90000153 	adrp	x19, 431000 <__FRAME_END__+0x10804>
{
  409e30:	a9025bf5 	stp	x21, x22, [sp, #32]
  409e34:	9114c063 	add	x3, x3, #0x530
  409e38:	f9475c00 	ldr	x0, [x0, #3768]
  409e3c:	a90363f7 	stp	x23, x24, [sp, #48]
  409e40:	913e6042 	add	x2, x2, #0xf98
  409e44:	f9400001 	ldr	x1, [x0]
  409e48:	f90047e1 	str	x1, [sp, #136]
  409e4c:	d2800001 	mov	x1, #0x0                   	// #0
  409e50:	90000097 	adrp	x23, 419000 <__func__.2+0xa80>
	fprintf(stdout, "%s ", _HELP_SWITCH);
  409e54:	f9472e60 	ldr	x0, [x19, #3672]
  409e58:	f0000078 	adrp	x24, 418000 <table.0+0x1d8>

	while (args_struct[count].option != NULL) {
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  409e5c:	910103f6 	add	x22, sp, #0x40
  409e60:	912e72f7 	add	x23, x23, #0xb9c
  409e64:	9103df18 	add	x24, x24, #0xf7
  409e68:	52800021 	mov	w1, #0x1                   	// #1
  409e6c:	f9400000 	ldr	x0, [x0]
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
  409e70:	52800335 	mov	w21, #0x19                  	// #25
  409e74:	97ffddc3 	bl	401580 <__fprintf_chk@plt>
	while (args_struct[count].option != NULL) {
  409e78:	f9400680 	ldr	x0, [x20, #8]
  409e7c:	b5000120 	cbnz	x0, 409ea0 <cmd_print_switches_help+0x90>
  409e80:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  409e84:	f9475c00 	ldr	x0, [x0, #3768]
  409e88:	f94047e2 	ldr	x2, [sp, #136]
  409e8c:	f9400001 	ldr	x1, [x0]
  409e90:	eb010042 	subs	x2, x2, x1
  409e94:	d2800001 	mov	x1, #0x0                   	// #0
  409e98:	54000360 	b.eq	409f04 <cmd_print_switches_help+0xf4>  // b.none
  409e9c:	97ffdda1 	bl	401520 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  409ea0:	aa1403e1 	mov	x1, x20
  409ea4:	aa1603e0 	mov	x0, x22
  409ea8:	97fffe97 	bl	409904 <cmd_gen_switch_syntax.constprop.0>
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
  409eac:	aa1603e0 	mov	x0, x22
  409eb0:	97ffdd30 	bl	401370 <strlen@plt>
  409eb4:	8b35c000 	add	x0, x0, w21, sxtw
  409eb8:	f101901f 	cmp	x0, #0x64
  409ebc:	540000e9 	b.ls	409ed8 <cmd_print_switches_help+0xc8>  // b.plast
			fprintf(stdout, "\n");
  409ec0:	f9472e60 	ldr	x0, [x19, #3672]
  409ec4:	aa1703e2 	mov	x2, x23
  409ec8:	52800021 	mov	w1, #0x1                   	// #1
			printed_in_line = 0;
  409ecc:	52800015 	mov	w21, #0x0                   	// #0
  409ed0:	f9400000 	ldr	x0, [x0]
  409ed4:	97ffddab 	bl	401580 <__fprintf_chk@plt>
		}

		fprintf(stdout, "%s", stringy);
  409ed8:	f9472e60 	ldr	x0, [x19, #3672]
  409edc:	aa1603e3 	mov	x3, x22
  409ee0:	aa1803e2 	mov	x2, x24
  409ee4:	52800021 	mov	w1, #0x1                   	// #1
  409ee8:	9100e294 	add	x20, x20, #0x38
  409eec:	f9400000 	ldr	x0, [x0]
  409ef0:	97ffdda4 	bl	401580 <__fprintf_chk@plt>
		printed_in_line += strlen(stringy);
  409ef4:	aa1603e0 	mov	x0, x22
  409ef8:	97ffdd1e 	bl	401370 <strlen@plt>
  409efc:	0b0002b5 	add	w21, w21, w0
		count++;
  409f00:	17ffffde 	b	409e78 <cmd_print_switches_help+0x68>
	}

	fprintf(stdout, "\n");
  409f04:	f9472e73 	ldr	x19, [x19, #3672]
  409f08:	90000082 	adrp	x2, 419000 <__func__.2+0xa80>
}
  409f0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  409f10:	912e7042 	add	x2, x2, #0xb9c
  409f14:	f9400260 	ldr	x0, [x19]
  409f18:	52800021 	mov	w1, #0x1                   	// #1
  409f1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  409f20:	a94363f7 	ldp	x23, x24, [sp, #48]
  409f24:	a8c97bfd 	ldp	x29, x30, [sp], #144
  409f28:	17ffdd96 	b	401580 <__fprintf_chk@plt>

0000000000409f2c <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
  409f2c:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
  409f30:	90000141 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  409f34:	910003fd 	mov	x29, sp
  409f38:	f9475c21 	ldr	x1, [x1, #3768]
  409f3c:	a90153f3 	stp	x19, x20, [sp, #16]
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  409f40:	90000154 	adrp	x20, 431000 <__FRAME_END__+0x10804>
{
  409f44:	a9025bf5 	stp	x21, x22, [sp, #32]
  409f48:	aa0003f3 	mov	x19, x0
  409f4c:	a90363f7 	stp	x23, x24, [sp, #48]
  409f50:	90000097 	adrp	x23, 419000 <__func__.2+0xa80>
  409f54:	90000098 	adrp	x24, 419000 <__func__.2+0xa80>
  409f58:	a9046bf9 	stp	x25, x26, [sp, #64]
  409f5c:	91159af7 	add	x23, x23, #0x566
  409f60:	91392b18 	add	x24, x24, #0xe4a
  409f64:	a90573fb 	stp	x27, x28, [sp, #80]
  409f68:	f9400022 	ldr	x2, [x1]
  409f6c:	f90057e2 	str	x2, [sp, #168]
  409f70:	d2800002 	mov	x2, #0x0                   	// #0
	cmd_print_switches_help(args_struct);
  409f74:	97ffffa7 	bl	409e10 <cmd_print_switches_help>
	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
  409f78:	f9472e80 	ldr	x0, [x20, #3672]
  409f7c:	90000085 	adrp	x5, 419000 <__func__.2+0xa80>
  409f80:	90000084 	adrp	x4, 419000 <__func__.2+0xa80>
  409f84:	90000082 	adrp	x2, 419000 <__func__.2+0xa80>
  409f88:	911524a5 	add	x5, x5, #0x549
  409f8c:	9114c084 	add	x4, x4, #0x530
  409f90:	f9400000 	ldr	x0, [x0]
  409f94:	91156c42 	add	x2, x2, #0x55b
  409f98:	528003a3 	mov	w3, #0x1d                  	// #29
  409f9c:	52800021 	mov	w1, #0x1                   	// #1
  409fa0:	97ffdd78 	bl	401580 <__fprintf_chk@plt>
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
  409fa4:	f9400660 	ldr	x0, [x19, #8]
  409fa8:	b5000280 	cbnz	x0, 409ff8 <cmd_print_long_help+0xcc>
				      &toprint[printed_right]);
			printed_right += ret - 1;
		}
		count++;
	}
	fprintf(stdout, "\n");
  409fac:	f9472e94 	ldr	x20, [x20, #3672]
  409fb0:	52800021 	mov	w1, #0x1                   	// #1
  409fb4:	90000082 	adrp	x2, 419000 <__func__.2+0xa80>
  409fb8:	912e7042 	add	x2, x2, #0xb9c
  409fbc:	f9400280 	ldr	x0, [x20]
  409fc0:	97ffdd70 	bl	401580 <__fprintf_chk@plt>
  409fc4:	f9400280 	ldr	x0, [x20]
  409fc8:	52800021 	mov	w1, #0x1                   	// #1
  409fcc:	90000082 	adrp	x2, 419000 <__func__.2+0xa80>
  409fd0:	9115dc42 	add	x2, x2, #0x577
  409fd4:	97ffdd6b 	bl	401580 <__fprintf_chk@plt>
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
  409fd8:	90000140 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  409fdc:	f9475c00 	ldr	x0, [x0, #3768]
  409fe0:	f94057e2 	ldr	x2, [sp, #168]
  409fe4:	f9400001 	ldr	x1, [x0]
  409fe8:	eb010042 	subs	x2, x2, x1
  409fec:	d2800001 	mov	x1, #0x0                   	// #0
  409ff0:	54000600 	b.eq	40a0b0 <cmd_print_long_help+0x184>  // b.none
  409ff4:	97ffdd4b 	bl	401520 <__stack_chk_fail@plt>
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
  409ff8:	910183f5 	add	x21, sp, #0x60
  409ffc:	aa1303e1 	mov	x1, x19
  40a000:	aa1503e0 	mov	x0, x21
  40a004:	97fffe40 	bl	409904 <cmd_gen_switch_syntax.constprop.0>
		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
  40a008:	f9472e96 	ldr	x22, [x20, #3672]
  40a00c:	aa1503e4 	mov	x4, x21
  40a010:	aa1703e2 	mov	x2, x23
  40a014:	528003a3 	mov	w3, #0x1d                  	// #29
  40a018:	52800021 	mov	w1, #0x1                   	// #1
  40a01c:	f000007b 	adrp	x27, 419000 <__func__.2+0xa80>
  40a020:	f94002c0 	ldr	x0, [x22]
  40a024:	f000007c 	adrp	x28, 419000 <__func__.2+0xa80>
  40a028:	9115cf9c 	add	x28, x28, #0x573
  40a02c:	97ffdd55 	bl	401580 <__fprintf_chk@plt>
  40a030:	2a0003f5 	mov	w21, w0
		toprint = args_struct[count].descript;
  40a034:	f9401a7a 	ldr	x26, [x19, #48]
		total_to_print = strlen(toprint);
  40a038:	aa1a03e0 	mov	x0, x26
  40a03c:	97ffdccd 	bl	401370 <strlen@plt>
  40a040:	2a0003f9 	mov	w25, w0
  40a044:	aa1a03e4 	mov	x4, x26
  40a048:	f94002c0 	ldr	x0, [x22]
  40a04c:	9115b762 	add	x2, x27, #0x56d
  40a050:	52800c83 	mov	w3, #0x64                  	// #100
  40a054:	52800021 	mov	w1, #0x1                   	// #1
  40a058:	4b150063 	sub	w3, w3, w21
  40a05c:	97ffdd49 	bl	401580 <__fprintf_chk@plt>
		printed_right += ret - 1;
  40a060:	51000415 	sub	w21, w0, #0x1
		while (printed_right < total_to_print) {
  40a064:	6b1902bf 	cmp	w21, w25
  40a068:	5400006b 	b.lt	40a074 <cmd_print_long_help+0x148>  // b.tstop
		count++;
  40a06c:	9100e273 	add	x19, x19, #0x38
  40a070:	17ffffcd 	b	409fa4 <cmd_print_long_help+0x78>
  40a074:	f94002c0 	ldr	x0, [x22]
  40a078:	aa1803e4 	mov	x4, x24
  40a07c:	aa1c03e2 	mov	x2, x28
  40a080:	528003c3 	mov	w3, #0x1e                  	// #30
  40a084:	52800021 	mov	w1, #0x1                   	// #1
  40a088:	97ffdd3e 	bl	401580 <__fprintf_chk@plt>
  40a08c:	f94002c0 	ldr	x0, [x22]
  40a090:	8b35c344 	add	x4, x26, w21, sxtw
  40a094:	9115b762 	add	x2, x27, #0x56d
  40a098:	528008c3 	mov	w3, #0x46                  	// #70
  40a09c:	52800021 	mov	w1, #0x1                   	// #1
  40a0a0:	97ffdd38 	bl	401580 <__fprintf_chk@plt>
			printed_right += ret - 1;
  40a0a4:	51000400 	sub	w0, w0, #0x1
  40a0a8:	0b0002b5 	add	w21, w21, w0
  40a0ac:	17ffffee 	b	40a064 <cmd_print_long_help+0x138>
}
  40a0b0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a0b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a0b8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a0bc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40a0c0:	a94573fb 	ldp	x27, x28, [sp, #80]
  40a0c4:	a8cb7bfd 	ldp	x29, x30, [sp], #176
  40a0c8:	d65f03c0 	ret

000000000040a0cc <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
  40a0cc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a0d0:	910003fd 	mov	x29, sp
  40a0d4:	a90153f3 	stp	x19, x20, [sp, #16]
  40a0d8:	aa0003f4 	mov	x20, x0
  40a0dc:	aa0103f3 	mov	x19, x1
  40a0e0:	f90013f5 	str	x21, [sp, #32]
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
  40a0e4:	97fffe7f 	bl	409ae0 <cmd_is_help_option>
  40a0e8:	340000a0 	cbz	w0, 40a0fc <cmd_parse_one_arg+0x30>
		cmd_print_long_help(args_struct);
  40a0ec:	aa1303e0 	mov	x0, x19
  40a0f0:	97ffff8f 	bl	409f2c <cmd_print_long_help>
		posix_exit(0);
  40a0f4:	52800000 	mov	w0, #0x0                   	// #0
  40a0f8:	97fffd12 	bl	409540 <posix_exit>
	}

	while (args_struct[count].option != NULL) {
  40a0fc:	f9400661 	ldr	x1, [x19, #8]
  40a100:	b50000c1 	cbnz	x1, 40a118 <cmd_parse_one_arg+0x4c>
						    &args_struct[count]);
			return true;
		}
		count++;
	}
	return false;
  40a104:	52800000 	mov	w0, #0x0                   	// #0
}
  40a108:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a10c:	f94013f5 	ldr	x21, [sp, #32]
  40a110:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a114:	d65f03c0 	ret
		if (args_struct[count].manual) {
  40a118:	39400260 	ldrb	w0, [x19]
  40a11c:	350003e0 	cbnz	w0, 40a198 <cmd_parse_one_arg+0xcc>
				    !args_struct[count].is_switch);
  40a120:	39400a62 	ldrb	w2, [x19, #2]
		ret = cmd_is_option(argv, args_struct[count].option,
  40a124:	aa1403e0 	mov	x0, x20
  40a128:	52000042 	eor	w2, w2, #0x1
  40a12c:	97fffe36 	bl	409a04 <cmd_is_option>
  40a130:	2a0003f5 	mov	w21, w0
		if (ret) {
  40a134:	34000320 	cbz	w0, 40a198 <cmd_parse_one_arg+0xcc>
	if (arg_element->dest != NULL) {
  40a138:	f9401261 	ldr	x1, [x19, #32]
  40a13c:	b4000101 	cbz	x1, 40a15c <cmd_parse_one_arg+0x90>
		if (arg_element->is_switch) {
  40a140:	39400a60 	ldrb	w0, [x19, #2]
			if (arg_element->type == 'b') {
  40a144:	39406262 	ldrb	w2, [x19, #24]
		if (arg_element->is_switch) {
  40a148:	34000200 	cbz	w0, 40a188 <cmd_parse_one_arg+0xbc>
			if (arg_element->type == 'b') {
  40a14c:	7101885f 	cmp	w2, #0x62
  40a150:	54000141 	b.ne	40a178 <cmd_parse_one_arg+0xac>  // b.any
				*(bool *)arg_element->dest = true;
  40a154:	52800020 	mov	w0, #0x1                   	// #1
  40a158:	39000020 	strb	w0, [x1]
	if (arg_element->call_when_found) {
  40a15c:	f9401662 	ldr	x2, [x19, #40]
  40a160:	b4000082 	cbz	x2, 40a170 <cmd_parse_one_arg+0xa4>
		arg_element->call_when_found(argv, offset);
  40a164:	2a1503e1 	mov	w1, w21
  40a168:	aa1403e0 	mov	x0, x20
  40a16c:	d63f0040 	blr	x2
			return true;
  40a170:	52800020 	mov	w0, #0x1                   	// #1
  40a174:	17ffffe5 	b	40a108 <cmd_parse_one_arg+0x3c>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
  40a178:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a17c:	91171c00 	add	x0, x0, #0x5c7
  40a180:	97fffd46 	bl	409698 <posix_print_error_and_exit>
  40a184:	17fffff6 	b	40a15c <cmd_parse_one_arg+0x90>
			cmd_read_option_value(&argv[offset],
  40a188:	f9400663 	ldr	x3, [x19, #8]
  40a18c:	8b35c280 	add	x0, x20, w21, sxtw
  40a190:	97fffe75 	bl	409b64 <cmd_read_option_value>
  40a194:	17fffff2 	b	40a15c <cmd_parse_one_arg+0x90>
  40a198:	9100e273 	add	x19, x19, #0x38
  40a19c:	17ffffd8 	b	40a0fc <cmd_parse_one_arg+0x30>

000000000040a1a0 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
  40a1a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a1a4:	910003fd 	mov	x29, sp
  40a1a8:	f9000bf3 	str	x19, [sp, #16]
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
  40a1ac:	b0000153 	adrp	x19, 433000 <obj_0x28+0x18>
  40a1b0:	f9477a60 	ldr	x0, [x19, #3824]
  40a1b4:	b4000060 	cbz	x0, 40a1c0 <native_cleanup_cmd_line+0x20>
		free(args_struct);
  40a1b8:	97ffdd06 	bl	4015d0 <free@plt>
		args_struct = NULL;
  40a1bc:	f9077a7f 	str	xzr, [x19, #3824]
	}
}
  40a1c0:	f9400bf3 	ldr	x19, [sp, #16]
  40a1c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a1c8:	d65f03c0 	ret

000000000040a1cc <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
  40a1cc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40a1d0:	910003fd 	mov	x29, sp
  40a1d4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a1d8:	aa0003f5 	mov	x21, x0
  40a1dc:	91002000 	add	x0, x0, #0x8
  40a1e0:	a90153f3 	stp	x19, x20, [sp, #16]
	int count = 0;
  40a1e4:	52800013 	mov	w19, #0x0                   	// #0
{
  40a1e8:	a90363f7 	stp	x23, x24, [sp, #48]
  40a1ec:	f90023f9 	str	x25, [sp, #64]

	while (args[count].option != NULL) {
  40a1f0:	f8438401 	ldr	x1, [x0], #56
  40a1f4:	2a1303f7 	mov	w23, w19
		count++;
  40a1f8:	11000673 	add	w19, w19, #0x1
	while (args[count].option != NULL) {
  40a1fc:	b5ffffa1 	cbnz	x1, 40a1f0 <native_add_command_line_opts+0x24>
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
  40a200:	d0000156 	adrp	x22, 434000 <ztest_thread+0xb8>
  40a204:	d0000159 	adrp	x25, 434000 <ztest_thread+0xb8>
  40a208:	b0000158 	adrp	x24, 433000 <obj_0x28+0x18>
  40a20c:	b94e02c0 	ldr	w0, [x22, #3584]
  40a210:	b94df721 	ldr	w1, [x25, #3572]
  40a214:	0b000260 	add	w0, w19, w0
  40a218:	6b01001f 	cmp	w0, w1
  40a21c:	540001cb 	b.lt	40a254 <native_add_command_line_opts+0x88>  // b.tstop
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
  40a220:	7100527f 	cmp	w19, #0x14
  40a224:	52800294 	mov	w20, #0x14                  	// #20
  40a228:	1a94a274 	csel	w20, w19, w20, ge  // ge = tcont
  40a22c:	0b010294 	add	w20, w20, w1
		struct args_struct_t *new_args_struct = realloc(args_struct,
  40a230:	52800701 	mov	w1, #0x38                  	// #56
  40a234:	f9477b00 	ldr	x0, [x24, #3824]
  40a238:	9b217e81 	smull	x1, w20, w1
  40a23c:	97ffdcb1 	bl	401500 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
  40a240:	b90df734 	str	w20, [x25, #3572]
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
  40a244:	b5000260 	cbnz	x0, 40a290 <native_add_command_line_opts+0xc4>
			posix_print_error_and_exit("Could not allocate memory");
  40a248:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a24c:	91184800 	add	x0, x0, #0x612
  40a250:	97fffd12 	bl	409698 <posix_print_error_and_exit>
			args_struct = new_args_struct;
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
  40a254:	b94e02d4 	ldr	w20, [x22, #3584]
  40a258:	52800700 	mov	w0, #0x38                  	// #56
  40a25c:	f9477b03 	ldr	x3, [x24, #3824]
  return __builtin___memcpy_chk (__dest, __src, __len,
  40a260:	9b207e62 	smull	x2, w19, w0
  40a264:	aa1503e1 	mov	x1, x21
  40a268:	9b200e80 	smaddl	x0, w20, w0, x3
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
  40a26c:	0b170294 	add	w20, w20, w23
  40a270:	97ffdc30 	bl	401330 <memcpy@plt>
  40a274:	b90e02d4 	str	w20, [x22, #3584]
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
  40a278:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a27c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a280:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a284:	f94023f9 	ldr	x25, [sp, #64]
  40a288:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40a28c:	d65f03c0 	ret
			args_struct = new_args_struct;
  40a290:	f9077b00 	str	x0, [x24, #3824]
  40a294:	17fffff0 	b	40a254 <native_add_command_line_opts+0x88>

000000000040a298 <native_add_testargs_option>:
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
  40a298:	90000140 	adrp	x0, 432000 <__dso_handle>
  40a29c:	911c4000 	add	x0, x0, #0x710
  40a2a0:	17ffffcb 	b	40a1cc <native_add_command_line_opts>

000000000040a2a4 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
  40a2a4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40a2a8:	910003fd 	mov	x29, sp
  40a2ac:	a90153f3 	stp	x19, x20, [sp, #16]
  40a2b0:	aa0103f4 	mov	x20, x1
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
  40a2b4:	d2800033 	mov	x19, #0x1                   	// #1
{
  40a2b8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a2bc:	2a0003f5 	mov	w21, w0
  40a2c0:	a90363f7 	stp	x23, x24, [sp, #48]
	cmd_args_set_defaults(args_struct);
  40a2c4:	b0000158 	adrp	x24, 433000 <obj_0x28+0x18>
{
  40a2c8:	a9046bf9 	stp	x25, x26, [sp, #64]
	native_add_tracing_options();
  40a2cc:	97fffd8b 	bl	4098f8 <native_add_tracing_options>
	native_add_testargs_option();
  40a2d0:	97fffff2 	bl	40a298 <native_add_testargs_option>
	s_argv = argv;
  40a2d4:	b0000140 	adrp	x0, 433000 <obj_0x28+0x18>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40a2d8:	f0000079 	adrp	x25, 419000 <__func__.2+0xa80>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40a2dc:	f000007a 	adrp	x26, 419000 <__func__.2+0xa80>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40a2e0:	9118b339 	add	x25, x25, #0x62c
	s_argv = argv;
  40a2e4:	f9077c14 	str	x20, [x0, #3832]
	s_argc = argc;
  40a2e8:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40a2ec:	9118d75a 	add	x26, x26, #0x635
	s_argc = argc;
  40a2f0:	b90df815 	str	w21, [x0, #3576]
	cmd_args_set_defaults(args_struct);
  40a2f4:	f9477b00 	ldr	x0, [x24, #3824]
  40a2f8:	97fffe8c 	bl	409d28 <cmd_args_set_defaults>
	for (i = 1; i < argc; i++) {
  40a2fc:	2a1303f6 	mov	w22, w19
  40a300:	6b1302bf 	cmp	w21, w19
  40a304:	540001cd 	b.le	40a33c <native_handle_cmd_line+0x98>
		if ((cmd_is_option(argv[i], "testargs", 0))) {
  40a308:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  40a30c:	aa1903e1 	mov	x1, x25
  40a310:	52800002 	mov	w2, #0x0                   	// #0
  40a314:	91000677 	add	x23, x19, #0x1
  40a318:	97fffdbb 	bl	409a04 <cmd_is_option>
  40a31c:	340001c0 	cbz	w0, 40a354 <native_handle_cmd_line+0xb0>
			test_argc = argc - i - 1;
  40a320:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40a324:	4b1602b6 	sub	w22, w21, w22
  40a328:	510006d6 	sub	w22, w22, #0x1
			test_argv = &argv[i+1];
  40a32c:	8b170e97 	add	x23, x20, x23, lsl #3
			test_argc = argc - i - 1;
  40a330:	b90dfc16 	str	w22, [x0, #3580]
			test_argv = &argv[i+1];
  40a334:	b0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  40a338:	f9078017 	str	x23, [x0, #3840]
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
			cmd_print_switches_help(args_struct);
			print_invalid_opt_error(argv[i]);
		}
	}
}
  40a33c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a340:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a344:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a348:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40a34c:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40a350:	d65f03c0 	ret
		if (!cmd_parse_one_arg(argv[i], args_struct)) {
  40a354:	f9477b01 	ldr	x1, [x24, #3824]
  40a358:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  40a35c:	97ffff5c 	bl	40a0cc <cmd_parse_one_arg>
  40a360:	72001c1f 	tst	w0, #0xff
  40a364:	540000c1 	b.ne	40a37c <native_handle_cmd_line+0xd8>  // b.any
			cmd_print_switches_help(args_struct);
  40a368:	f9477b00 	ldr	x0, [x24, #3824]
  40a36c:	97fffea9 	bl	409e10 <cmd_print_switches_help>
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
  40a370:	f8737a81 	ldr	x1, [x20, x19, lsl #3]
  40a374:	aa1a03e0 	mov	x0, x26
  40a378:	97fffcc8 	bl	409698 <posix_print_error_and_exit>
	for (i = 1; i < argc; i++) {
  40a37c:	aa1703f3 	mov	x19, x23
  40a380:	17ffffdf 	b	40a2fc <native_handle_cmd_line+0x58>

000000000040a384 <hw_counter_init>:
/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
	hw_counter_timer = NEVER;
  40a384:	f0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40a388:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40a38c:	f947d421 	ldr	x1, [x1, #4008]
  40a390:	f9000020 	str	x0, [x1]
	counter_target = NEVER;
  40a394:	b0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  40a398:	f9078820 	str	x0, [x1, #3856]
	counter_value = 0;
  40a39c:	b0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  40a3a0:	f9078c3f 	str	xzr, [x1, #3864]
	counter_running = false;
  40a3a4:	f0000141 	adrp	x1, 435000 <stdout_buff+0xc1>
  40a3a8:	3901943f 	strb	wzr, [x1, #101]
	counter_period = NEVER;
  40a3ac:	b0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  40a3b0:	f9078420 	str	x0, [x1, #3848]
}
  40a3b4:	d65f03c0 	ret

000000000040a3b8 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
  40a3b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!counter_running) {
  40a3bc:	f0000140 	adrp	x0, 435000 <stdout_buff+0xc1>
{
  40a3c0:	910003fd 	mov	x29, sp
	if (!counter_running) {
  40a3c4:	39419400 	ldrb	w0, [x0, #101]
{
  40a3c8:	f9000bf3 	str	x19, [sp, #16]
  40a3cc:	f0000133 	adrp	x19, 431000 <__FRAME_END__+0x10804>
	if (!counter_running) {
  40a3d0:	350000e0 	cbnz	w0, 40a3ec <hw_counter_triggered+0x34>
		hw_counter_timer = NEVER;
  40a3d4:	f947d673 	ldr	x19, [x19, #4008]
  40a3d8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  40a3dc:	f9000260 	str	x0, [x19]
	counter_value = counter_value + 1;

	if (counter_value == counter_target) {
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
	}
}
  40a3e0:	f9400bf3 	ldr	x19, [sp, #16]
  40a3e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a3e8:	d65f03c0 	ret
	hw_counter_timer = hwm_get_time() + counter_period;
  40a3ec:	97fff9e7 	bl	408b88 <hwm_get_time>
  40a3f0:	b0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  40a3f4:	f947d673 	ldr	x19, [x19, #4008]
  40a3f8:	f9478421 	ldr	x1, [x1, #3848]
  40a3fc:	8b000021 	add	x1, x1, x0
  40a400:	f9000261 	str	x1, [x19]
	counter_value = counter_value + 1;
  40a404:	b0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  40a408:	f9478c20 	ldr	x0, [x1, #3864]
  40a40c:	91000400 	add	x0, x0, #0x1
  40a410:	f9078c20 	str	x0, [x1, #3864]
	if (counter_value == counter_target) {
  40a414:	b0000141 	adrp	x1, 433000 <obj_0x28+0x18>
  40a418:	f9478821 	ldr	x1, [x1, #3856]
  40a41c:	eb01001f 	cmp	x0, x1
  40a420:	54fffe01 	b.ne	40a3e0 <hw_counter_triggered+0x28>  // b.any
}
  40a424:	f9400bf3 	ldr	x19, [sp, #16]
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  40a428:	52800040 	mov	w0, #0x2                   	// #2
}
  40a42c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
  40a430:	17fffc18 	b	409490 <hw_irq_ctrl_set_irq>

000000000040a434 <receive_pool_free>:

/*
 * Wake every context that is waiting for a buffer
 */
static void receive_pool_free(struct net_buf *buf)
{
  40a434:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a438:	910003fd 	mov	x29, sp
  40a43c:	f9000bf3 	str	x19, [sp, #16]
  40a440:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40a444:	39404800 	ldrb	w0, [x0, #18]
  40a448:	940003cf 	bl	40b384 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40a44c:	aa1303e1 	mov	x1, x19
  40a450:	940023be 	bl	413348 <k_queue_prepend>
	return list->head;
  40a454:	b0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  40a458:	f9479413 	ldr	x19, [x0, #3880]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.alloc_list, ctx_node) {
  40a45c:	b5000093 	cbnz	x19, 40a46c <receive_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  40a460:	f9400bf3 	ldr	x19, [sp, #16]
  40a464:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a468:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  40a46c:	91004260 	add	x0, x19, #0x10
  40a470:	9400270b 	bl	41409c <k_work_submit>
	return node->next;
  40a474:	f9400273 	ldr	x19, [x19]
  40a478:	17fffff9 	b	40a45c <receive_pool_free+0x28>

000000000040a47c <receive_ff_sf_pool_free>:

static void receive_ff_sf_pool_free(struct net_buf *buf)
{
  40a47c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40a480:	910003fd 	mov	x29, sp
  40a484:	f9000bf3 	str	x19, [sp, #16]
  40a488:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40a48c:	39404800 	ldrb	w0, [x0, #18]
  40a490:	940003bd 	bl	40b384 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40a494:	aa1303e1 	mov	x1, x19
  40a498:	940023ac 	bl	413348 <k_queue_prepend>
	return list->head;
  40a49c:	b0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  40a4a0:	f9479c13 	ldr	x19, [x0, #3896]
	struct isotp_recv_ctx *ctx;
	sys_snode_t *ctx_node;

	net_buf_destroy(buf);

	SYS_SLIST_FOR_EACH_NODE(&global_ctx.ff_sf_alloc_list, ctx_node) {
  40a4a4:	b5000093 	cbnz	x19, 40a4b4 <receive_ff_sf_pool_free+0x38>
		ctx = CONTAINER_OF(ctx_node, struct isotp_recv_ctx, alloc_node);
		k_work_submit(&ctx->work);
	}
}
  40a4a8:	f9400bf3 	ldr	x19, [sp, #16]
  40a4ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40a4b0:	d65f03c0 	ret
		k_work_submit(&ctx->work);
  40a4b4:	91004260 	add	x0, x19, #0x10
  40a4b8:	940026f9 	bl	41409c <k_work_submit>
	return node->next;
  40a4bc:	f9400273 	ldr	x19, [x19]
  40a4c0:	17fffff9 	b	40a4a4 <receive_ff_sf_pool_free+0x28>

000000000040a4c4 <z_impl_entropy_get_entropy.constprop.0>:

static inline int z_impl_entropy_get_entropy(const struct device *dev,
					     uint8_t *buffer,
					     uint16_t length)
{
	const struct entropy_driver_api *api =
  40a4c4:	f0000123 	adrp	x3, 431000 <__FRAME_END__+0x10804>
static inline int z_impl_entropy_get_entropy(const struct device *dev,
  40a4c8:	aa0003e4 	mov	x4, x0
  40a4cc:	12003c22 	and	w2, w1, #0xffff
	const struct entropy_driver_api *api =
  40a4d0:	f9473c60 	ldr	x0, [x3, #3704]
		(const struct entropy_driver_api *)dev->api;

	__ASSERT(api->get_entropy != NULL,
  40a4d4:	f9400801 	ldr	x1, [x0, #16]
  40a4d8:	f9400023 	ldr	x3, [x1]
  40a4dc:	b5000303 	cbnz	x3, 40a53c <z_impl_entropy_get_entropy.constprop.0+0x78>
static inline int z_impl_entropy_get_entropy(const struct device *dev,
  40a4e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT(api->get_entropy != NULL,
  40a4e4:	f0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40a4e8:	911cac21 	add	x1, x1, #0x72b
static inline int z_impl_entropy_get_entropy(const struct device *dev,
  40a4ec:	910003fd 	mov	x29, sp
  40a4f0:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT(api->get_entropy != NULL,
  40a4f4:	f0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40a4f8:	911bde73 	add	x19, x19, #0x6f7
  40a4fc:	528009a3 	mov	w3, #0x4d                  	// #77
  40a500:	aa1303e2 	mov	x2, x19
  40a504:	d0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40a508:	91178000 	add	x0, x0, #0x5e0
  40a50c:	97fff247 	bl	406e28 <assert_print>
  40a510:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a514:	911d2c00 	add	x0, x0, #0x74b
  40a518:	97fff244 	bl	406e28 <assert_print>
  40a51c:	aa1303e0 	mov	x0, x19
  40a520:	528009a1 	mov	w1, #0x4d                  	// #77
  40a524:	97fff26b 	bl	406ed0 <assert_post_action>
  40a528:	d0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40a52c:	aa1303e1 	mov	x1, x19
  40a530:	91187800 	add	x0, x0, #0x61e
  40a534:	528009a2 	mov	w2, #0x4d                  	// #77
  40a538:	97fffc58 	bl	409698 <posix_print_error_and_exit>
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
  40a53c:	aa0403e1 	mov	x1, x4
  40a540:	aa0303f0 	mov	x16, x3
  40a544:	d61f0200 	br	x16

000000000040a548 <z_impl_sys_rand32_get>:
static const struct device *const entropy_dev =
	DEVICE_DT_GET(DT_CHOSEN(zephyr_entropy));

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
uint32_t z_impl_sys_rand32_get(void)
{
  40a548:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a54c:	f0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40a550:	910003fd 	mov	x29, sp
  40a554:	f9475c00 	ldr	x0, [x0, #3768]
  40a558:	a90153f3 	stp	x19, x20, [sp, #16]
  40a55c:	f9400001 	ldr	x1, [x0]
  40a560:	f90017e1 	str	x1, [sp, #40]
  40a564:	d2800001 	mov	x1, #0x0                   	// #0
  40a568:	f0000134 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  40a56c:	f9473e94 	ldr	x20, [x20, #3704]
  40a570:	aa1403e0 	mov	x0, x20
  40a574:	94001b9e 	bl	4113ec <z_device_is_ready>
	uint32_t random_num;
	int ret;

	__ASSERT(device_is_ready(entropy_dev), "Entropy device %s not ready",
  40a578:	72001c1f 	tst	w0, #0xff
  40a57c:	540002c1 	b.ne	40a5d4 <z_impl_sys_rand32_get+0x8c>  // b.any
  40a580:	f0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40a584:	911dc673 	add	x19, x19, #0x771
  40a588:	aa1303e2 	mov	x2, x19
  40a58c:	528002a3 	mov	w3, #0x15                  	// #21
  40a590:	f0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40a594:	d0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40a598:	911ea821 	add	x1, x1, #0x7aa
  40a59c:	91178000 	add	x0, x0, #0x5e0
  40a5a0:	97fff222 	bl	406e28 <assert_print>
  40a5a4:	f9400281 	ldr	x1, [x20]
  40a5a8:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a5ac:	911f1c00 	add	x0, x0, #0x7c7
  40a5b0:	97fff21e 	bl	406e28 <assert_print>
  40a5b4:	aa1303e0 	mov	x0, x19
  40a5b8:	528002a1 	mov	w1, #0x15                  	// #21
  40a5bc:	97fff245 	bl	406ed0 <assert_post_action>
  40a5c0:	d0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40a5c4:	aa1303e1 	mov	x1, x19
  40a5c8:	91187800 	add	x0, x0, #0x61e
  40a5cc:	528002a2 	mov	w2, #0x15                  	// #21
  40a5d0:	97fffc32 	bl	409698 <posix_print_error_and_exit>
		union { uintptr_t x; uint16_t val; } parm2 = { .val = length };
		return (int) arch_syscall_invoke3(parm0.x, parm1.x, parm2.x, K_SYSCALL_ENTROPY_GET_ENTROPY);
	}
#endif
	compiler_barrier();
	return z_impl_entropy_get_entropy(dev, buffer, length);
  40a5d4:	52800081 	mov	w1, #0x4                   	// #4
  40a5d8:	910093e0 	add	x0, sp, #0x24
  40a5dc:	97ffffba 	bl	40a4c4 <z_impl_entropy_get_entropy.constprop.0>
		 entropy_dev->name);

	ret = entropy_get_entropy(entropy_dev, (uint8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
  40a5e0:	36f80060 	tbz	w0, #31, 40a5ec <z_impl_sys_rand32_get+0xa4>
	return sys_clock_cycle_get_32();
  40a5e4:	94000876 	bl	40c7bc <sys_clock_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
  40a5e8:	b90027e0 	str	w0, [sp, #36]
	}

	return random_num;
}
  40a5ec:	f0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
	return random_num;
  40a5f0:	b94027e0 	ldr	w0, [sp, #36]
}
  40a5f4:	f9475c21 	ldr	x1, [x1, #3768]
  40a5f8:	f94017e3 	ldr	x3, [sp, #40]
  40a5fc:	f9400022 	ldr	x2, [x1]
  40a600:	eb020063 	subs	x3, x3, x2
  40a604:	d2800002 	mov	x2, #0x0                   	// #0
  40a608:	54000040 	b.eq	40a610 <z_impl_sys_rand32_get+0xc8>  // b.none
  40a60c:	97ffdbc5 	bl	401520 <__stack_chk_fail@plt>
  40a610:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a614:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a618:	d65f03c0 	ret

000000000040a61c <get_friendly_phase_name>:
 * @param phase an enum ztest_phase value describing the desired test phase
 * @returns a string name for `phase`
 */
static inline const char *get_friendly_phase_name(enum ztest_phase phase)
{
	switch (phase) {
  40a61c:	7100141f 	cmp	w0, #0x5
  40a620:	540002c8 	b.hi	40a678 <get_friendly_phase_name+0x5c>  // b.pmore
  40a624:	b0000061 	adrp	x1, 417000 <z_abort_timeout+0x38>
  40a628:	913ac021 	add	x1, x1, #0xeb0
  40a62c:	38604821 	ldrb	w1, [x1, w0, uxtw]
  40a630:	10000060 	adr	x0, 40a63c <get_friendly_phase_name+0x20>
  40a634:	8b218801 	add	x1, x0, w1, sxtb #2
  40a638:	d61f0020 	br	x1
  40a63c:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a640:	911fac00 	add	x0, x0, #0x7eb
	case TEST_PHASE_FRAMEWORK:
		return "framework";
	default:
		return "(unknown)";
	}
}
  40a644:	d65f03c0 	ret
		return "test";
  40a648:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a64c:	91282800 	add	x0, x0, #0xa0a
  40a650:	17fffffd 	b	40a644 <get_friendly_phase_name+0x28>
		return "after";
  40a654:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a658:	911fc800 	add	x0, x0, #0x7f2
  40a65c:	17fffffa 	b	40a644 <get_friendly_phase_name+0x28>
		return "teardown";
  40a660:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a664:	911fe000 	add	x0, x0, #0x7f8
  40a668:	17fffff7 	b	40a644 <get_friendly_phase_name+0x28>
		return "framework";
  40a66c:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a670:	91200400 	add	x0, x0, #0x801
  40a674:	17fffff4 	b	40a644 <get_friendly_phase_name+0x28>
		return "(unknown)";
  40a678:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a67c:	91202c00 	add	x0, x0, #0x80b
  40a680:	17fffff1 	b	40a644 <get_friendly_phase_name+0x28>
		return "setup";
  40a684:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a688:	911f9400 	add	x0, x0, #0x7e5
  40a68c:	17ffffee 	b	40a644 <get_friendly_phase_name+0x28>

000000000040a690 <ztest_find_test_suite>:
}

#endif /* !KERNEL */

static struct ztest_suite_node *ztest_find_test_suite(const char *name)
{
  40a690:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40a694:	910003fd 	mov	x29, sp
  40a698:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_suite_node *node;

	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40a69c:	f0000133 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  40a6a0:	f0000134 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  40a6a4:	f946fa73 	ldr	x19, [x19, #3568]
{
  40a6a8:	f90013f5 	str	x21, [sp, #32]
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40a6ac:	f9471a94 	ldr	x20, [x20, #3632]
{
  40a6b0:	aa0003f5 	mov	x21, x0
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40a6b4:	eb14027f 	cmp	x19, x20
  40a6b8:	540000e3 	b.cc	40a6d4 <ztest_find_test_suite+0x44>  // b.lo, b.ul, b.last
		if (strcmp(name, node->name) == 0) {
			return node;
		}
	}

	return NULL;
  40a6bc:	d2800013 	mov	x19, #0x0                   	// #0
}
  40a6c0:	aa1303e0 	mov	x0, x19
  40a6c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a6c8:	f94013f5 	ldr	x21, [sp, #32]
  40a6cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a6d0:	d65f03c0 	ret
		if (strcmp(name, node->name) == 0) {
  40a6d4:	f9400261 	ldr	x1, [x19]
  40a6d8:	aa1503e0 	mov	x0, x21
  40a6dc:	97ffdbad 	bl	401590 <strcmp@plt>
  40a6e0:	34ffff00 	cbz	w0, 40a6c0 <ztest_find_test_suite+0x30>
	for (node = _ztest_suite_node_list_start; node < _ztest_suite_node_list_end; ++node) {
  40a6e4:	9100e273 	add	x19, x19, #0x38
  40a6e8:	17fffff3 	b	40a6b4 <ztest_find_test_suite+0x24>

000000000040a6ec <test_cb>:
{
  40a6ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40a6f0:	910003fd 	mov	x29, sp
  40a6f4:	a90153f3 	stp	x19, x20, [sp, #16]
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40a6f8:	f0000133 	adrp	x19, 431000 <__FRAME_END__+0x10804>
{
  40a6fc:	aa0203f4 	mov	x20, x2
  40a700:	a90363f7 	stp	x23, x24, [sp, #48]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40a704:	f0000137 	adrp	x23, 431000 <__FRAME_END__+0x10804>
	test_result = ZTEST_RESULT_PENDING;
  40a708:	d0000158 	adrp	x24, 434000 <ztest_thread+0xb8>
	for (struct ztest_test_rule *rule = _ztest_test_rule_list_start;
  40a70c:	f9476273 	ldr	x19, [x19, #3776]
{
  40a710:	a9025bf5 	stp	x21, x22, [sp, #32]
  40a714:	aa0003f6 	mov	x22, x0
	     rule < _ztest_test_rule_list_end; ++rule) {
  40a718:	f947daf7 	ldr	x23, [x23, #4016]
{
  40a71c:	aa0103f5 	mov	x21, x1
	test_result = ZTEST_RESULT_PENDING;
  40a720:	b90e0f1f 	str	wzr, [x24, #3596]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40a724:	eb17027f 	cmp	x19, x23
  40a728:	54000263 	b.cc	40a774 <test_cb+0x88>  // b.lo, b.ul, b.last
	if (suite->before) {
  40a72c:	f9400ac1 	ldr	x1, [x22, #16]
  40a730:	b4000061 	cbz	x1, 40a73c <test_cb+0x50>
		suite->before(/*data=*/c);
  40a734:	aa1403e0 	mov	x0, x20
  40a738:	d63f0020 	blr	x1
	phase = TEST_PHASE_TEST;
  40a73c:	f0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40a740:	52800042 	mov	w2, #0x2                   	// #2
  40a744:	f9400aa1 	ldr	x1, [x21, #16]
  40a748:	f947d000 	ldr	x0, [x0, #4000]
  40a74c:	b9000002 	str	w2, [x0]
	test->test(data);
  40a750:	aa1403e0 	mov	x0, x20
  40a754:	d63f0020 	blr	x1
	test_result = ZTEST_RESULT_PASS;
  40a758:	52800020 	mov	w0, #0x1                   	// #1
  40a75c:	b90e0f00 	str	w0, [x24, #3596]
}
  40a760:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a764:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40a768:	a94363f7 	ldp	x23, x24, [sp, #48]
  40a76c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40a770:	d65f03c0 	ret
		if (is_before && rule->before_each) {
  40a774:	f9400262 	ldr	x2, [x19]
  40a778:	b4000082 	cbz	x2, 40a788 <test_cb+0x9c>
			rule->before_each(test, data);
  40a77c:	aa1403e1 	mov	x1, x20
  40a780:	aa1503e0 	mov	x0, x21
  40a784:	d63f0040 	blr	x2
	     rule < _ztest_test_rule_list_end; ++rule) {
  40a788:	91004273 	add	x19, x19, #0x10
  40a78c:	17ffffe6 	b	40a724 <test_cb+0x38>

000000000040a790 <test_finalize>:
{
  40a790:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a794:	910003fd 	mov	x29, sp
	z_impl_k_thread_abort(thread);
  40a798:	b0000140 	adrp	x0, 433000 <obj_0x28+0x18>
  40a79c:	913d2000 	add	x0, x0, #0xf48
  40a7a0:	97fff755 	bl	4084f4 <z_impl_k_thread_abort>
	return z_impl_z_current_get();
  40a7a4:	94002f44 	bl	4164b4 <z_impl_z_current_get>
}
  40a7a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	z_impl_k_thread_abort(thread);
  40a7ac:	17fff752 	b	4084f4 <z_impl_k_thread_abort>

000000000040a7b0 <ztest_test_fail>:
	switch (phase) {
  40a7b0:	f0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40a7b4:	f947d000 	ldr	x0, [x0, #4000]
  40a7b8:	b9400000 	ldr	w0, [x0]
  40a7bc:	34000200 	cbz	w0, 40a7fc <ztest_test_fail+0x4c>
  40a7c0:	51000401 	sub	w1, w0, #0x1
  40a7c4:	7100043f 	cmp	w1, #0x1
  40a7c8:	54000229 	b.ls	40a80c <ztest_test_fail+0x5c>  // b.plast
{
  40a7cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40a7d0:	910003fd 	mov	x29, sp
		PRINT(" ERROR: cannot fail in test phase '%s()', bailing\n",
  40a7d4:	97ffff92 	bl	40a61c <get_friendly_phase_name>
  40a7d8:	aa0003e1 	mov	x1, x0
  40a7dc:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a7e0:	91205400 	add	x0, x0, #0x815
  40a7e4:	97ffebbd 	bl	4056d8 <printk>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40a7e8:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40a7ec:	52800041 	mov	w1, #0x2                   	// #2
}
  40a7f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40a7f4:	b90e1001 	str	w1, [x0, #3600]
}
  40a7f8:	d65f03c0 	ret
		test_result = ZTEST_RESULT_SUITE_FAIL;
  40a7fc:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40a800:	528000a1 	mov	w1, #0x5                   	// #5
  40a804:	b90e0c01 	str	w1, [x0, #3596]
		break;
  40a808:	d65f03c0 	ret
		test_result = ZTEST_RESULT_FAIL;
  40a80c:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40a810:	52800041 	mov	w1, #0x2                   	// #2
  40a814:	b90e0c01 	str	w1, [x0, #3596]
		test_finalize();
  40a818:	17ffffde 	b	40a790 <test_finalize>

000000000040a81c <z_ztest_get_next_test>:

struct ztest_unit_test *z_ztest_get_next_test(const char *suite, struct ztest_unit_test *prev)
{
  40a81c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40a820:	f100003f 	cmp	x1, #0x0
{
  40a824:	910003fd 	mov	x29, sp
  40a828:	a90153f3 	stp	x19, x20, [sp, #16]
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40a82c:	f0000133 	adrp	x19, 431000 <__FRAME_END__+0x10804>

	for (; test < _ztest_unit_test_list_end; ++test) {
  40a830:	f0000134 	adrp	x20, 431000 <__FRAME_END__+0x10804>
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40a834:	f946ce73 	ldr	x19, [x19, #3480]
{
  40a838:	f90013f5 	str	x21, [sp, #32]
	for (; test < _ztest_unit_test_list_end; ++test) {
  40a83c:	f9472694 	ldr	x20, [x20, #3656]
{
  40a840:	aa0003f5 	mov	x21, x0
	struct ztest_unit_test *test = (prev == NULL) ? _ztest_unit_test_list_start : prev + 1;
  40a844:	9100a020 	add	x0, x1, #0x28
  40a848:	9a800273 	csel	x19, x19, x0, eq  // eq = none
	for (; test < _ztest_unit_test_list_end; ++test) {
  40a84c:	eb14027f 	cmp	x19, x20
  40a850:	540000e3 	b.cc	40a86c <z_ztest_get_next_test+0x50>  // b.lo, b.ul, b.last
		if (strcmp(suite, test->test_suite_name) == 0) {
			return test;
		}
	}
	return NULL;
  40a854:	d2800013 	mov	x19, #0x0                   	// #0
}
  40a858:	aa1303e0 	mov	x0, x19
  40a85c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40a860:	f94013f5 	ldr	x21, [sp, #32]
  40a864:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40a868:	d65f03c0 	ret
		if (strcmp(suite, test->test_suite_name) == 0) {
  40a86c:	f9400261 	ldr	x1, [x19]
  40a870:	aa1503e0 	mov	x0, x21
  40a874:	97ffdb47 	bl	401590 <strcmp@plt>
  40a878:	34ffff00 	cbz	w0, 40a858 <z_ztest_get_next_test+0x3c>
	for (; test < _ztest_unit_test_list_end; ++test) {
  40a87c:	9100a273 	add	x19, x19, #0x28
  40a880:	17fffff3 	b	40a84c <z_ztest_get_next_test+0x30>

000000000040a884 <z_ztest_run_test_suite_ptr>:
	}
}
#endif /* CONFIG_ZTEST_SHUFFLE */

static int z_ztest_run_test_suite_ptr(struct ztest_suite_node *suite)
{
  40a884:	d10203ff 	sub	sp, sp, #0x80
  40a888:	a9017bfd 	stp	x29, x30, [sp, #16]
  40a88c:	910043fd 	add	x29, sp, #0x10
  40a890:	a90253f3 	stp	x19, x20, [sp, #32]
  40a894:	a9035bf5 	stp	x21, x22, [sp, #48]
  40a898:	a90463f7 	stp	x23, x24, [sp, #64]
  40a89c:	a9056bf9 	stp	x25, x26, [sp, #80]
  40a8a0:	a90673fb 	stp	x27, x28, [sp, #96]

	if (test_status < 0) {
		return test_status;
	}

	if (suite == NULL) {
  40a8a4:	b50001c0 	cbnz	x0, 40a8dc <z_ztest_run_test_suite_ptr+0x58>
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40a8a8:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40a8ac:	52800041 	mov	w1, #0x2                   	// #2
		return -1;
  40a8b0:	12800016 	mov	w22, #0xffffffff            	// #-1
		test_status = ZTEST_STATUS_CRITICAL_ERROR;
  40a8b4:	b90e1001 	str	w1, [x0, #3600]
	if (suite->teardown != NULL) {
		suite->teardown(data);
	}

	return fail;
}
  40a8b8:	2a1603e0 	mov	w0, w22
  40a8bc:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40a8c0:	a94253f3 	ldp	x19, x20, [sp, #32]
  40a8c4:	a9435bf5 	ldp	x21, x22, [sp, #48]
  40a8c8:	a94463f7 	ldp	x23, x24, [sp, #64]
  40a8cc:	a9456bf9 	ldp	x25, x26, [sp, #80]
  40a8d0:	a94673fb 	ldp	x27, x28, [sp, #96]
  40a8d4:	910203ff 	add	sp, sp, #0x80
  40a8d8:	d65f03c0 	ret
  40a8dc:	aa0003f4 	mov	x20, x0
	TC_SUITE_START(suite->name);
  40a8e0:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a8e4:	91215c00 	add	x0, x0, #0x857
	phase = TEST_PHASE_SETUP;
  40a8e8:	f0000135 	adrp	x21, 431000 <__FRAME_END__+0x10804>
	test_result = ZTEST_RESULT_PENDING;
  40a8ec:	d0000158 	adrp	x24, 434000 <ztest_thread+0xb8>
	TC_SUITE_START(suite->name);
  40a8f0:	f9400281 	ldr	x1, [x20]
  40a8f4:	97ffeb79 	bl	4056d8 <printk>
  40a8f8:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a8fc:	9121b400 	add	x0, x0, #0x86d
  40a900:	97ffeb76 	bl	4056d8 <printk>
	test_result = ZTEST_RESULT_PENDING;
  40a904:	b90e0f1f 	str	wzr, [x24, #3596]
	current_test_failed_assumption = false;
  40a908:	f0000140 	adrp	x0, 435000 <stdout_buff+0xc1>
  40a90c:	3901981f 	strb	wzr, [x0, #102]
	phase = TEST_PHASE_SETUP;
  40a910:	f947d2a0 	ldr	x0, [x21, #4000]
  40a914:	b900001f 	str	wzr, [x0]
	if (test_result != ZTEST_RESULT_SUITE_FAIL && suite->setup != NULL) {
  40a918:	f9400680 	ldr	x0, [x20, #8]
  40a91c:	b4000340 	cbz	x0, 40a984 <z_ztest_run_test_suite_ptr+0x100>
		data = suite->setup();
  40a920:	d63f0000 	blr	x0
  40a924:	aa0003f7 	mov	x23, x0
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40a928:	f0000139 	adrp	x25, 431000 <__FRAME_END__+0x10804>
	tc_start_time = k_cycle_get_32();
}

static inline void get_test_duration_ms(void)
{
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40a92c:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
		fail = 0;
  40a930:	52800016 	mov	w22, #0x0                   	// #0
  40a934:	91382000 	add	x0, x0, #0xe08
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40a938:	f9479b39 	ldr	x25, [x25, #3888]
	struct ztest_unit_test *test = NULL;
  40a93c:	d2800013 	mov	x19, #0x0                   	// #0
  40a940:	f9003fe0 	str	x0, [sp, #120]
		while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40a944:	f9400280 	ldr	x0, [x20]
  40a948:	aa1303e1 	mov	x1, x19
  40a94c:	97ffffb4 	bl	40a81c <z_ztest_get_next_test>
  40a950:	aa0003f3 	mov	x19, x0
  40a954:	b50001c0 	cbnz	x0, 40a98c <z_ztest_run_test_suite_ptr+0x108>
		if (test_status == ZTEST_STATUS_OK && fail != 0) {
  40a958:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40a95c:	b94e1001 	ldr	w1, [x0, #3600]
  40a960:	35001881 	cbnz	w1, 40ac70 <z_ztest_run_test_suite_ptr+0x3ec>
  40a964:	34001896 	cbz	w22, 40ac74 <z_ztest_run_test_suite_ptr+0x3f0>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  40a968:	52800021 	mov	w1, #0x1                   	// #1
  40a96c:	b90e1001 	str	w1, [x0, #3600]
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  40a970:	f9400281 	ldr	x1, [x20]
  40a974:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a978:	9123cc00 	add	x0, x0, #0x8f3
  40a97c:	97ffeb57 	bl	4056d8 <printk>
  40a980:	140000c2 	b	40ac88 <z_ztest_run_test_suite_ptr+0x404>
	void *data = NULL;
  40a984:	d2800017 	mov	x23, #0x0                   	// #0
  40a988:	17ffffe8 	b	40a928 <z_ztest_run_test_suite_ptr+0xa4>
			if (ztest_api.should_test_run(suite->name, test->name)) {
  40a98c:	f9400280 	ldr	x0, [x20]
  40a990:	f9400661 	ldr	x1, [x19, #8]
  40a994:	f9400b22 	ldr	x2, [x25, #16]
  40a998:	d63f0040 	blr	x2
  40a99c:	72001c1f 	tst	w0, #0xff
  40a9a0:	54001600 	b.eq	40ac60 <z_ztest_run_test_suite_ptr+0x3dc>  // b.none
				test->stats->run_count++;
  40a9a4:	f9401261 	ldr	x1, [x19, #32]
  40a9a8:	b9400020 	ldr	w0, [x1]
  40a9ac:	11000400 	add	w0, w0, #0x1
  40a9b0:	b9000020 	str	w0, [x1]
	TC_START(test->name);
  40a9b4:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40a9b8:	9122c800 	add	x0, x0, #0x8b2
  40a9bc:	f9400661 	ldr	x1, [x19, #8]
  40a9c0:	97ffeb46 	bl	4056d8 <printk>
	phase = TEST_PHASE_BEFORE;
  40a9c4:	f947d2a0 	ldr	x0, [x21, #4000]
  40a9c8:	52800021 	mov	w1, #0x1                   	// #1
  40a9cc:	b9000001 	str	w1, [x0]
  40a9d0:	9400077b 	bl	40c7bc <sys_clock_cycle_get_32>
	tc_start_time = k_cycle_get_32();
  40a9d4:	d0000141 	adrp	x1, 434000 <ztest_thread+0xb8>
  40a9d8:	92800007 	mov	x7, #0xffffffffffffffff    	// #-1
  40a9dc:	b90e0820 	str	w0, [x1, #3592]
		k_thread_create(&ztest_thread, ztest_thread_stack,
  40a9e0:	b9401a60 	ldr	w0, [x19, #24]
  40a9e4:	321d0000 	orr	w0, w0, #0x8
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40a9e8:	f0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40a9ec:	b90003e0 	str	w0, [sp]
  40a9f0:	f90007e7 	str	x7, [sp, #8]
  40a9f4:	b000015a 	adrp	x26, 433000 <obj_0x28+0x18>
  40a9f8:	f947f021 	ldr	x1, [x1, #4064]
  40a9fc:	913d235b 	add	x27, x26, #0xf48
  40aa00:	aa1703e6 	mov	x6, x23
  40aa04:	aa1303e5 	mov	x5, x19
  40aa08:	aa1403e4 	mov	x4, x20
  40aa0c:	aa1b03e0 	mov	x0, x27
  40aa10:	d2808002 	mov	x2, #0x400                 	// #1024
  40aa14:	90000003 	adrp	x3, 40a000 <cmd_print_long_help+0xd4>
  40aa18:	911bb063 	add	x3, x3, #0x6ec
  40aa1c:	94001e1e 	bl	412294 <z_impl_k_thread_create>
		if (test->name != NULL) {
  40aa20:	f9400661 	ldr	x1, [x19, #8]
  40aa24:	b4000061 	cbz	x1, 40aa30 <z_ztest_run_test_suite_ptr+0x1ac>
	return z_impl_k_thread_name_set(thread, str);
  40aa28:	aa1b03e0 	mov	x0, x27
  40aa2c:	94001da5 	bl	4120c0 <z_impl_k_thread_name_set>
		if (test_result != ZTEST_RESULT_SUITE_SKIP &&
  40aa30:	b94e0f00 	ldr	w0, [x24, #3596]
  40aa34:	51001000 	sub	w0, w0, #0x4
  40aa38:	7100041f 	cmp	w0, #0x1
  40aa3c:	540000e9 	b.ls	40aa58 <z_ztest_run_test_suite_ptr+0x1d4>  // b.plast
	z_impl_k_thread_start(thread);
  40aa40:	913d235b 	add	x27, x26, #0xf48
  40aa44:	aa1b03e0 	mov	x0, x27
  40aa48:	94001db1 	bl	41210c <z_impl_k_thread_start>
	return z_impl_k_thread_join(thread, timeout);
  40aa4c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40aa50:	aa1b03e0 	mov	x0, x27
  40aa54:	94002f52 	bl	41679c <z_impl_k_thread_join>
	phase = TEST_PHASE_AFTER;
  40aa58:	f947d2a0 	ldr	x0, [x21, #4000]
  40aa5c:	52800061 	mov	w1, #0x3                   	// #3
  40aa60:	b9000001 	str	w1, [x0]
	if (suite->after != NULL) {
  40aa64:	f9400e81 	ldr	x1, [x20, #24]
  40aa68:	b4000061 	cbz	x1, 40aa74 <z_ztest_run_test_suite_ptr+0x1f0>
		suite->after(data);
  40aa6c:	aa1703e0 	mov	x0, x23
  40aa70:	d63f0020 	blr	x1
	void *data = NULL;
  40aa74:	f0000122 	adrp	x2, 431000 <__FRAME_END__+0x10804>
	     rule < _ztest_test_rule_list_end; ++rule) {
  40aa78:	f0000123 	adrp	x3, 431000 <__FRAME_END__+0x10804>
	void *data = NULL;
  40aa7c:	f947605c 	ldr	x28, [x2, #3776]
	     rule < _ztest_test_rule_list_end; ++rule) {
  40aa80:	f947d87b 	ldr	x27, [x3, #4016]
  40aa84:	14000007 	b	40aaa0 <z_ztest_run_test_suite_ptr+0x21c>
		} else if (!is_before && rule->after_each) {
  40aa88:	f9400784 	ldr	x4, [x28, #8]
  40aa8c:	b4000084 	cbz	x4, 40aa9c <z_ztest_run_test_suite_ptr+0x218>
			rule->after_each(test, data);
  40aa90:	aa1703e1 	mov	x1, x23
  40aa94:	aa1303e0 	mov	x0, x19
  40aa98:	d63f0080 	blr	x4
	     rule < _ztest_test_rule_list_end; ++rule) {
  40aa9c:	9100439c 	add	x28, x28, #0x10
  40aaa0:	eb1b039f 	cmp	x28, x27
  40aaa4:	54ffff23 	b.cc	40aa88 <z_ztest_run_test_suite_ptr+0x204>  // b.lo, b.ul, b.last
  40aaa8:	94000745 	bl	40c7bc <sys_clock_cycle_get_32>
	uint32_t spend_cycle = k_cycle_get_32() - tc_start_time;
  40aaac:	f9403fe1 	ldr	x1, [sp, #120]
  40aab0:	b9400022 	ldr	w2, [x1]
  40aab4:	4b020001 	sub	w1, w0, w2
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_cyc_to_ms_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_cyc, Z_HZ_ms, Z_CCYC, true, true, false);
  40aab8:	4b020000 	sub	w0, w0, w2
		t += off;
  40aabc:	910f9c00 	add	x0, x0, #0x3e7
		if (result32 && (t < BIT64(32))) {
  40aac0:	b2407fe2 	mov	x2, #0xffffffff            	// #4294967295
  40aac4:	eb02001f 	cmp	x0, x2
  40aac8:	54000528 	b.hi	40ab6c <z_ztest_run_test_suite_ptr+0x2e8>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
  40aacc:	110f9c21 	add	w1, w1, #0x3e7
  40aad0:	52807d00 	mov	w0, #0x3e8                 	// #1000
  40aad4:	1ac00820 	udiv	w0, w1, w0

	tc_spend_time = k_cyc_to_ms_ceil32(spend_cycle);
  40aad8:	d0000141 	adrp	x1, 434000 <ztest_thread+0xb8>
  40aadc:	b90e0420 	str	w0, [x1, #3588]
	if (tc_spend_time > test->stats->duration_worst_ms) {
  40aae0:	f9401261 	ldr	x1, [x19, #32]
  40aae4:	b9401022 	ldr	w2, [x1, #16]
  40aae8:	6b00005f 	cmp	w2, w0
  40aaec:	54000042 	b.cs	40aaf4 <z_ztest_run_test_suite_ptr+0x270>  // b.hs, b.nlast
		test->stats->duration_worst_ms = tc_spend_time;
  40aaf0:	b9001020 	str	w0, [x1, #16]
	phase = TEST_PHASE_FRAMEWORK;
  40aaf4:	f947d2a0 	ldr	x0, [x21, #4000]
  40aaf8:	528000a1 	mov	w1, #0x5                   	// #5
  40aafc:	b9000001 	str	w1, [x0]
	if (test_result == ZTEST_RESULT_FAIL || test_result == ZTEST_RESULT_SUITE_FAIL ||
  40ab00:	b94e0f00 	ldr	w0, [x24, #3596]
  40ab04:	7100081f 	cmp	w0, #0x2
  40ab08:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40ab0c:	f0000141 	adrp	x1, 435000 <stdout_buff+0xc1>
  40ab10:	54000060 	b.eq	40ab1c <z_ztest_run_test_suite_ptr+0x298>  // b.none
  40ab14:	39419c22 	ldrb	w2, [x1, #103]
  40ab18:	34000302 	cbz	w2, 40ab78 <z_ztest_run_test_suite_ptr+0x2f4>
		failed_expectation = false;
  40ab1c:	39019c3f 	strb	wzr, [x1, #103]
		ret = TC_FAIL;
  40ab20:	5280003b 	mov	w27, #0x1                   	// #1
	z_impl_k_thread_abort(thread);
  40ab24:	913d2340 	add	x0, x26, #0xf48
  40ab28:	97fff673 	bl	4084f4 <z_impl_k_thread_abort>
	for (struct ztest_expected_result_entry *expectation =
  40ab2c:	f0000123 	adrp	x3, 431000 <__FRAME_END__+0x10804>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40ab30:	f0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40ab34:	f940067a 	ldr	x26, [x19, #8]
	for (struct ztest_expected_result_entry *expectation =
  40ab38:	f947707c 	ldr	x28, [x3, #3808]
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40ab3c:	f9477c00 	ldr	x0, [x0, #3832]
  40ab40:	f9003be0 	str	x0, [sp, #112]
  40ab44:	f9403be0 	ldr	x0, [sp, #112]
  40ab48:	eb00039f 	cmp	x28, x0
  40ab4c:	54000203 	b.cc	40ab8c <z_ztest_run_test_suite_ptr+0x308>  // b.lo, b.ul, b.last
	switch (result) {
  40ab50:	7100077f 	cmp	w27, #0x1
  40ab54:	54000440 	b.eq	40abdc <z_ztest_run_test_suite_ptr+0x358>  // b.none
  40ab58:	71000b7f 	cmp	w27, #0x2
  40ab5c:	54000760 	b.eq	40ac48 <z_ztest_run_test_suite_ptr+0x3c4>  // b.none
	for (struct ztest_expected_result_entry *expectation =
  40ab60:	f0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40ab64:	91212021 	add	x1, x1, #0x848
  40ab68:	1400001f 	b	40abe4 <z_ztest_run_test_suite_ptr+0x360>
			return t / ((uint64_t)from_hz / to_hz);
  40ab6c:	d2807d01 	mov	x1, #0x3e8                 	// #1000
  40ab70:	9ac10800 	udiv	x0, x0, x1
  40ab74:	17ffffd9 	b	40aad8 <z_ztest_run_test_suite_ptr+0x254>
	} else if (test_result == ZTEST_RESULT_SKIP || test_result == ZTEST_RESULT_SUITE_SKIP) {
  40ab78:	51000c00 	sub	w0, w0, #0x3
  40ab7c:	7100041f 	cmp	w0, #0x1
  40ab80:	1a9f87e5 	cset	w5, ls  // ls = plast
  40ab84:	531f78bb 	lsl	w27, w5, #1
  40ab88:	17ffffe7 	b	40ab24 <z_ztest_run_test_suite_ptr+0x2a0>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40ab8c:	f9400780 	ldr	x0, [x28, #8]
  40ab90:	aa1a03e1 	mov	x1, x26
  40ab94:	97ffda7f 	bl	401590 <strcmp@plt>
  40ab98:	35000160 	cbnz	w0, 40abc4 <z_ztest_run_test_suite_ptr+0x340>
		    strcmp(expectation->test_suite_name, test->test_suite_name) == 0) {
  40ab9c:	f9400261 	ldr	x1, [x19]
  40aba0:	f9400380 	ldr	x0, [x28]
  40aba4:	97ffda7b 	bl	401590 <strcmp@plt>
		if (strcmp(expectation->test_name, test->name) == 0 &&
  40aba8:	350000e0 	cbnz	w0, 40abc4 <z_ztest_run_test_suite_ptr+0x340>
			expected_result = expectation->expected_result;
  40abac:	b9401380 	ldr	w0, [x28, #16]
	if (expected_result == ZTEST_EXPECTED_RESULT_FAIL) {
  40abb0:	340000e0 	cbz	w0, 40abcc <z_ztest_run_test_suite_ptr+0x348>
	if (expected_result == ZTEST_EXPECTED_RESULT_SKIP) {
  40abb4:	7100041f 	cmp	w0, #0x1
  40abb8:	54fffcc1 	b.ne	40ab50 <z_ztest_run_test_suite_ptr+0x2cc>  // b.any
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  40abbc:	71000b7f 	cmp	w27, #0x2
  40abc0:	14000004 	b	40abd0 <z_ztest_run_test_suite_ptr+0x34c>
	     expectation < _ztest_expected_result_entry_list_end; ++expectation) {
  40abc4:	9100639c 	add	x28, x28, #0x18
  40abc8:	17ffffdf 	b	40ab44 <z_ztest_run_test_suite_ptr+0x2c0>
		return (ret == TC_FAIL) ? TC_PASS : TC_FAIL;
  40abcc:	7100077f 	cmp	w27, #0x1
		return (ret == TC_SKIP) ? TC_PASS : TC_FAIL;
  40abd0:	1a9f07fb 	cset	w27, ne  // ne = any
  40abd4:	7100077f 	cmp	w27, #0x1
  40abd8:	54fffc41 	b.ne	40ab60 <z_ztest_run_test_suite_ptr+0x2dc>  // b.any
		return TC_FAIL_STR;
  40abdc:	f0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40abe0:	91213421 	add	x1, x1, #0x84d
	Z_TC_END_RESULT(ret, test->name);
  40abe4:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40abe8:	aa1a03e2 	mov	x2, x26
  40abec:	b94e0404 	ldr	w4, [x0, #3588]
  40abf0:	52807d00 	mov	w0, #0x3e8                 	// #1000
  40abf4:	1ac00883 	udiv	w3, w4, w0
  40abf8:	1b009064 	msub	w4, w3, w0, w4
  40abfc:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40ac00:	9122f800 	add	x0, x0, #0x8be
  40ac04:	97ffeab5 	bl	4056d8 <printk>
  40ac08:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40ac0c:	9121b400 	add	x0, x0, #0x86d
  40ac10:	97ffeab2 	bl	4056d8 <printk>
	if (ret == TC_SKIP && current_test_failed_assumption) {
  40ac14:	71000b7f 	cmp	w27, #0x2
  40ac18:	f9401260 	ldr	x0, [x19, #32]
  40ac1c:	54000461 	b.ne	40aca8 <z_ztest_run_test_suite_ptr+0x424>  // b.any
  40ac20:	f0000141 	adrp	x1, 435000 <stdout_buff+0xc1>
  40ac24:	39419821 	ldrb	w1, [x1, #102]
  40ac28:	34000081 	cbz	w1, 40ac38 <z_ztest_run_test_suite_ptr+0x3b4>
		test_status = 1;
  40ac2c:	d0000141 	adrp	x1, 434000 <ztest_thread+0xb8>
  40ac30:	52800022 	mov	w2, #0x1                   	// #1
  40ac34:	b90e1022 	str	w2, [x1, #3600]
					test->stats->skip_count++;
  40ac38:	b9400401 	ldr	w1, [x0, #4]
  40ac3c:	11000421 	add	w1, w1, #0x1
  40ac40:	b9000401 	str	w1, [x0, #4]
				if (tc_result == TC_FAIL) {
  40ac44:	14000007 	b	40ac60 <z_ztest_run_test_suite_ptr+0x3dc>
		return TC_SKIP_STR;
  40ac48:	f0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40ac4c:	91214821 	add	x1, x1, #0x852
  40ac50:	17ffffe5 	b	40abe4 <z_ztest_run_test_suite_ptr+0x360>
					test->stats->pass_count++;
  40ac54:	b9400c01 	ldr	w1, [x0, #12]
  40ac58:	11000421 	add	w1, w1, #0x1
  40ac5c:	b9000c01 	str	w1, [x0, #12]
			if ((fail && FAIL_FAST) || test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40ac60:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40ac64:	b94e1000 	ldr	w0, [x0, #3600]
  40ac68:	7100081f 	cmp	w0, #0x2
  40ac6c:	54ffe6c1 	b.ne	40a944 <z_ztest_run_test_suite_ptr+0xc0>  // b.any
	TC_SUITE_END(suite->name, (fail > 0 ? TC_FAIL : TC_PASS));
  40ac70:	35ffe816 	cbnz	w22, 40a970 <z_ztest_run_test_suite_ptr+0xec>
  40ac74:	f9400281 	ldr	x1, [x20]
  40ac78:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40ac7c:	52800016 	mov	w22, #0x0                   	// #0
  40ac80:	91236c00 	add	x0, x0, #0x8db
  40ac84:	97ffea95 	bl	4056d8 <printk>
	phase = TEST_PHASE_TEARDOWN;
  40ac88:	f947d2b5 	ldr	x21, [x21, #4000]
  40ac8c:	52800080 	mov	w0, #0x4                   	// #4
	if (suite->teardown != NULL) {
  40ac90:	f9401281 	ldr	x1, [x20, #32]
	phase = TEST_PHASE_TEARDOWN;
  40ac94:	b90002a0 	str	w0, [x21]
	if (suite->teardown != NULL) {
  40ac98:	b4ffe101 	cbz	x1, 40a8b8 <z_ztest_run_test_suite_ptr+0x34>
		suite->teardown(data);
  40ac9c:	aa1703e0 	mov	x0, x23
  40aca0:	d63f0020 	blr	x1
  40aca4:	17ffff05 	b	40a8b8 <z_ztest_run_test_suite_ptr+0x34>
				if (tc_result == TC_PASS) {
  40aca8:	34fffd7b 	cbz	w27, 40ac54 <z_ztest_run_test_suite_ptr+0x3d0>
					test->stats->fail_count++;
  40acac:	b9400801 	ldr	w1, [x0, #8]
					fail++;
  40acb0:	110006d6 	add	w22, w22, #0x1
					test->stats->fail_count++;
  40acb4:	11000421 	add	w1, w1, #0x1
  40acb8:	b9000801 	str	w1, [x0, #8]
					fail++;
  40acbc:	17ffffe9 	b	40ac60 <z_ztest_run_test_suite_ptr+0x3dc>

000000000040acc0 <z_impl_ztest_run_test_suites>:

	return count;
}

int z_impl_ztest_run_test_suites(const void *state)
{
  40acc0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40acc4:	910003fd 	mov	x29, sp
  40acc8:	f90023f9 	str	x25, [sp, #64]
	int count = 0;

	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40accc:	d0000159 	adrp	x25, 434000 <ztest_thread+0xb8>
{
  40acd0:	a90363f7 	stp	x23, x24, [sp, #48]
  40acd4:	aa0003f7 	mov	x23, x0
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40acd8:	b94e1320 	ldr	w0, [x25, #3600]
{
  40acdc:	a90153f3 	stp	x19, x20, [sp, #16]
  40ace0:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (test_status == ZTEST_STATUS_CRITICAL_ERROR) {
  40ace4:	7100081f 	cmp	w0, #0x2
  40ace8:	540007a0 	b.eq	40addc <z_impl_ztest_run_test_suites+0x11c>  // b.none
		    (test_status == ZTEST_STATUS_HAS_FAILURE && FAIL_FAST)) {
			break;
		}
	}
#else
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40acec:	f0000133 	adrp	x19, 431000 <__FRAME_END__+0x10804>
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40acf0:	f0000136 	adrp	x22, 431000 <__FRAME_END__+0x10804>
		if (ztest_api.should_suite_run(state, ptr)) {
  40acf4:	f0000138 	adrp	x24, 431000 <__FRAME_END__+0x10804>
	int count = 0;
  40acf8:	52800015 	mov	w21, #0x0                   	// #0
	for (struct ztest_suite_node *ptr = _ztest_suite_node_list_start;
  40acfc:	f946fa73 	ldr	x19, [x19, #3568]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40ad00:	f9471ad6 	ldr	x22, [x22, #3632]
		if (ztest_api.should_suite_run(state, ptr)) {
  40ad04:	f9479b18 	ldr	x24, [x24, #3888]
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40ad08:	eb16027f 	cmp	x19, x22
  40ad0c:	54000103 	b.cc	40ad2c <z_impl_ztest_run_test_suites+0x6c>  // b.lo, b.ul, b.last
		}
	}
#endif

	return count;
}
  40ad10:	2a1503e0 	mov	w0, w21
  40ad14:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ad18:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ad1c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ad20:	f94023f9 	ldr	x25, [sp, #64]
  40ad24:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40ad28:	d65f03c0 	ret
		if (ztest_api.should_suite_run(state, ptr)) {
  40ad2c:	f9400702 	ldr	x2, [x24, #8]
  40ad30:	aa1303e1 	mov	x1, x19
  40ad34:	aa1703e0 	mov	x0, x23
	struct ztest_suite_stats *stats = ptr->stats;
  40ad38:	f9401a74 	ldr	x20, [x19, #48]
		if (ztest_api.should_suite_run(state, ptr)) {
  40ad3c:	d63f0040 	blr	x2
  40ad40:	72001c1f 	tst	w0, #0xff
  40ad44:	54000420 	b.eq	40adc8 <z_impl_ztest_run_test_suites+0x108>  // b.none
	struct ztest_unit_test *test = NULL;
  40ad48:	d2800001 	mov	x1, #0x0                   	// #0
  40ad4c:	1400000b 	b	40ad78 <z_impl_ztest_run_test_suites+0xb8>
		test->stats->run_count = 0;
  40ad50:	f9401020 	ldr	x0, [x1, #32]
  40ad54:	b900001f 	str	wzr, [x0]
		test->stats->skip_count = 0;
  40ad58:	f9401020 	ldr	x0, [x1, #32]
  40ad5c:	b900041f 	str	wzr, [x0, #4]
		test->stats->fail_count = 0;
  40ad60:	f9401020 	ldr	x0, [x1, #32]
  40ad64:	b900081f 	str	wzr, [x0, #8]
		test->stats->pass_count = 0;
  40ad68:	f9401020 	ldr	x0, [x1, #32]
  40ad6c:	b9000c1f 	str	wzr, [x0, #12]
		test->stats->duration_worst_ms = 0;
  40ad70:	f9401020 	ldr	x0, [x1, #32]
  40ad74:	b900101f 	str	wzr, [x0, #16]
	while (((test = z_ztest_get_next_test(suite->name, test)) != NULL)) {
  40ad78:	f9400260 	ldr	x0, [x19]
  40ad7c:	97fffea8 	bl	40a81c <z_ztest_get_next_test>
  40ad80:	aa0003e1 	mov	x1, x0
  40ad84:	b5fffe60 	cbnz	x0, 40ad50 <z_impl_ztest_run_test_suites+0x90>
			int fail = z_ztest_run_test_suite_ptr(ptr);
  40ad88:	aa1303e0 	mov	x0, x19
  40ad8c:	97fffebe 	bl	40a884 <z_ztest_run_test_suite_ptr>
			stats->fail_count += (fail != 0) ? 1 : 0;
  40ad90:	7100001f 	cmp	w0, #0x0
  40ad94:	b9400a80 	ldr	w0, [x20, #8]
			stats->run_count++;
  40ad98:	b9400281 	ldr	w1, [x20]
			stats->fail_count += (fail != 0) ? 1 : 0;
  40ad9c:	1a800400 	cinc	w0, w0, ne  // ne = any
  40ada0:	b9000a80 	str	w0, [x20, #8]
			stats->run_count++;
  40ada4:	11000421 	add	w1, w1, #0x1
			count++;
  40ada8:	52800020 	mov	w0, #0x1                   	// #1
			stats->run_count++;
  40adac:	b9000281 	str	w1, [x20]
		count += __ztest_run_test_suite(ptr, state);
  40adb0:	0b0002b5 	add	w21, w21, w0
		if (test_status == ZTEST_STATUS_CRITICAL_ERROR ||
  40adb4:	b94e1320 	ldr	w0, [x25, #3600]
  40adb8:	7100081f 	cmp	w0, #0x2
  40adbc:	54fffaa0 	b.eq	40ad10 <z_impl_ztest_run_test_suites+0x50>  // b.none
	     ptr < _ztest_suite_node_list_end; ++ptr) {
  40adc0:	9100e273 	add	x19, x19, #0x38
  40adc4:	17ffffd1 	b	40ad08 <z_impl_ztest_run_test_suites+0x48>
			stats->skip_count++;
  40adc8:	b9400680 	ldr	w0, [x20, #4]
  40adcc:	11000400 	add	w0, w0, #0x1
  40add0:	b9000680 	str	w0, [x20, #4]
	int count = 0;
  40add4:	52800000 	mov	w0, #0x0                   	// #0
  40add8:	17fffff6 	b	40adb0 <z_impl_ztest_run_test_suites+0xf0>
		return count;
  40addc:	52800015 	mov	w21, #0x0                   	// #0
  40ade0:	17ffffcc 	b	40ad10 <z_impl_ztest_run_test_suites+0x50>

000000000040ade4 <ztest_verify_all_test_suites_ran>:

void ztest_verify_all_test_suites_ran(void)
{
  40ade4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40ade8:	910003fd 	mov	x29, sp
  40adec:	a90153f3 	stp	x19, x20, [sp, #16]
	bool all_tests_run = true;
	struct ztest_suite_node *suite;
	struct ztest_unit_test *test;

	if (IS_ENABLED(CONFIG_ZTEST_VERIFY_RUN_ALL)) {
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40adf0:	f0000133 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  40adf4:	f0000134 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  40adf8:	f946fa73 	ldr	x19, [x19, #3568]
{
  40adfc:	a9025bf5 	stp	x21, x22, [sp, #32]
		     ++suite) {
			if (suite->stats->run_count < 1) {
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40ae00:	f0000076 	adrp	x22, 419000 <__func__.2+0xa80>
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40ae04:	f9471a94 	ldr	x20, [x20, #3632]
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40ae08:	912426d6 	add	x22, x22, #0x909
	bool all_tests_run = true;
  40ae0c:	52800035 	mov	w21, #0x1                   	// #1
{
  40ae10:	a90363f7 	stp	x23, x24, [sp, #48]
  40ae14:	f90023f9 	str	x25, [sp, #64]
		for (suite = _ztest_suite_node_list_start; suite < _ztest_suite_node_list_end;
  40ae18:	eb14027f 	cmp	x19, x20
  40ae1c:	54000383 	b.cc	40ae8c <ztest_verify_all_test_suites_ran+0xa8>  // b.lo, b.ul, b.last
				all_tests_run = false;
			}
		}

		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40ae20:	f0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40ae24:	f0000133 	adrp	x19, 431000 <__FRAME_END__+0x10804>
			suite = ztest_find_test_suite(test->test_suite_name);
			if (suite == NULL) {
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40ae28:	f0000076 	adrp	x22, 419000 <__func__.2+0xa80>
  40ae2c:	aa0003f8 	mov	x24, x0
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40ae30:	f946ce74 	ldr	x20, [x19, #3480]
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40ae34:	9124bad6 	add	x22, x22, #0x92e
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40ae38:	f9472419 	ldr	x25, [x0, #3656]
  40ae3c:	eb19029f 	cmp	x20, x25
  40ae40:	54000383 	b.cc	40aeb0 <ztest_verify_all_test_suites_ran+0xcc>  // b.lo, b.ul, b.last
				      test->name, test->test_suite_name);
				all_tests_run = false;
			}
		}

		if (!all_tests_run) {
  40ae44:	35000095 	cbnz	w21, 40ae54 <ztest_verify_all_test_suites_ran+0x70>
			test_status = ZTEST_STATUS_HAS_FAILURE;
  40ae48:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40ae4c:	52800021 	mov	w1, #0x1                   	// #1
  40ae50:	b90e1001 	str	w1, [x0, #3600]
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40ae54:	f946ce73 	ldr	x19, [x19, #3480]
	}

	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
		    test->stats->run_count) {
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40ae58:	f0000075 	adrp	x21, 419000 <__func__.2+0xa80>
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40ae5c:	f9472718 	ldr	x24, [x24, #3656]
			test_status = 1;
  40ae60:	d0000156 	adrp	x22, 434000 <ztest_thread+0xb8>
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40ae64:	9125c2b5 	add	x21, x21, #0x970
			test_status = 1;
  40ae68:	913842d6 	add	x22, x22, #0xe10
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40ae6c:	eb18027f 	cmp	x19, x24
  40ae70:	54000363 	b.cc	40aedc <ztest_verify_all_test_suites_ran+0xf8>  // b.lo, b.ul, b.last
		}
	}
}
  40ae74:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ae78:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ae7c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ae80:	f94023f9 	ldr	x25, [sp, #64]
  40ae84:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40ae88:	d65f03c0 	ret
			if (suite->stats->run_count < 1) {
  40ae8c:	f9401a60 	ldr	x0, [x19, #48]
  40ae90:	b9400000 	ldr	w0, [x0]
  40ae94:	350000a0 	cbnz	w0, 40aea8 <ztest_verify_all_test_suites_ran+0xc4>
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40ae98:	f9400261 	ldr	x1, [x19]
  40ae9c:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  40aea0:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test suite '%s' did not run.\n", suite->name);
  40aea4:	97ffea0d 	bl	4056d8 <printk>
		     ++suite) {
  40aea8:	9100e273 	add	x19, x19, #0x38
  40aeac:	17ffffdb 	b	40ae18 <ztest_verify_all_test_suites_ran+0x34>
			suite = ztest_find_test_suite(test->test_suite_name);
  40aeb0:	f9400297 	ldr	x23, [x20]
  40aeb4:	aa1703e0 	mov	x0, x23
  40aeb8:	97fffdf6 	bl	40a690 <ztest_find_test_suite>
			if (suite == NULL) {
  40aebc:	b50000c0 	cbnz	x0, 40aed4 <ztest_verify_all_test_suites_ran+0xf0>
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40aec0:	f9400681 	ldr	x1, [x20, #8]
  40aec4:	aa1703e2 	mov	x2, x23
  40aec8:	aa1603e0 	mov	x0, x22
				all_tests_run = false;
  40aecc:	52800015 	mov	w21, #0x0                   	// #0
				PRINT("ERROR: Test '%s' assigned to test suite '%s' which doesn't "
  40aed0:	97ffea02 	bl	4056d8 <printk>
		for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40aed4:	9100a294 	add	x20, x20, #0x28
  40aed8:	17ffffd9 	b	40ae3c <ztest_verify_all_test_suites_ran+0x58>
		if (test->stats->fail_count + test->stats->pass_count + test->stats->skip_count !=
  40aedc:	f9401262 	ldr	x2, [x19, #32]
  40aee0:	29410041 	ldp	w1, w0, [x2, #8]
  40aee4:	0b000021 	add	w1, w1, w0
  40aee8:	b9400440 	ldr	w0, [x2, #4]
  40aeec:	0b000021 	add	w1, w1, w0
  40aef0:	b9400040 	ldr	w0, [x2]
  40aef4:	6b00003f 	cmp	w1, w0
  40aef8:	540000c0 	b.eq	40af10 <ztest_verify_all_test_suites_ran+0x12c>  // b.none
			PRINT("Bad stats for %s.%s\n", test->test_suite_name, test->name);
  40aefc:	a9400a61 	ldp	x1, x2, [x19]
  40af00:	aa1503e0 	mov	x0, x21
  40af04:	97ffe9f5 	bl	4056d8 <printk>
			test_status = 1;
  40af08:	52800020 	mov	w0, #0x1                   	// #1
  40af0c:	b90002c0 	str	w0, [x22]
	for (test = _ztest_unit_test_list_start; test < _ztest_unit_test_list_end; ++test) {
  40af10:	9100a273 	add	x19, x19, #0x28
  40af14:	17ffffd6 	b	40ae6c <ztest_verify_all_test_suites_ran+0x88>

000000000040af18 <ztest_run_all>:

void ztest_run_all(const void *state) { ztest_api.run_all(state); }
  40af18:	f0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40af1c:	f9479821 	ldr	x1, [x1, #3888]
  40af20:	f9400021 	ldr	x1, [x1]
  40af24:	aa0103f0 	mov	x16, x1
  40af28:	d61f0200 	br	x16

000000000040af2c <test_main>:

void __weak test_main(void)
{
  40af2c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ztest_run_all(NULL);
  40af30:	d2800000 	mov	x0, #0x0                   	// #0
{
  40af34:	910003fd 	mov	x29, sp
	ztest_run_all(NULL);
  40af38:	97fffff8 	bl	40af18 <ztest_run_all>

	ztest_verify_all_test_suites_ran();
}
  40af3c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	ztest_verify_all_test_suites_ran();
  40af40:	17ffffa9 	b	40ade4 <ztest_verify_all_test_suites_ran>

000000000040af44 <_posix_zephyr_main>:

	return test_status;
}
#else
int main(void)
{
  40af44:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40af48:	910003fd 	mov	x29, sp
  40af4c:	a90153f3 	stp	x19, x20, [sp, #16]
	k_mem_domain_add_partition(&k_mem_domain_default, &z_malloc_partition);
#endif
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
  40af50:	97fffff7 	bl	40af2c <test_main>
	if (test_status) {
  40af54:	d0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
  40af58:	f0000074 	adrp	x20, 419000 <__func__.2+0xa80>
  40af5c:	f0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40af60:	b94e1001 	ldr	w1, [x0, #3600]
  40af64:	f0000060 	adrp	x0, 419000 <__func__.2+0xa80>
		TC_END_REPORT(TC_FAIL);
  40af68:	9121b400 	add	x0, x0, #0x86d
	if (test_status) {
  40af6c:	34000261 	cbz	w1, 40afb8 <_posix_zephyr_main+0x74>
		TC_END_REPORT(TC_FAIL);
  40af70:	97ffe9da 	bl	4056d8 <printk>
  40af74:	91261680 	add	x0, x20, #0x985
  40af78:	97ffe9d8 	bl	4056d8 <printk>
  40af7c:	9126d660 	add	x0, x19, #0x9b5
  40af80:	f0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40af84:	9126b821 	add	x1, x1, #0x9ae
  40af88:	97ffe9d4 	bl	4056d8 <printk>
		(void) arch_syscall_invoke0(K_SYSCALL_LOG_PANIC);
		return;
	}
#endif
	compiler_barrier();
	z_impl_log_panic();
  40af8c:	97fff098 	bl	4071ec <z_impl_log_panic>
  40af90:	52800020 	mov	w0, #0x1                   	// #1
		TC_END_REPORT(TC_PASS);
  40af94:	97fff96b 	bl	409540 <posix_exit>
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke0(K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process();
  40af98:	97fff0da 	bl	407300 <z_impl_log_process>
		while (LOG_PROCESS()) {
  40af9c:	72001c1f 	tst	w0, #0xff
  40afa0:	54ffffc1 	b.ne	40af98 <_posix_zephyr_main+0x54>  // b.any
	z_impl_log_panic();
  40afa4:	97fff092 	bl	4071ec <z_impl_log_panic>
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
	return 0;
}
  40afa8:	52800000 	mov	w0, #0x0                   	// #0
  40afac:	a94153f3 	ldp	x19, x20, [sp, #16]
  40afb0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40afb4:	d65f03c0 	ret
		TC_END_REPORT(TC_PASS);
  40afb8:	97ffe9c8 	bl	4056d8 <printk>
  40afbc:	91261680 	add	x0, x20, #0x985
  40afc0:	97ffe9c6 	bl	4056d8 <printk>
  40afc4:	9126d660 	add	x0, x19, #0x9b5
  40afc8:	f0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40afcc:	91272c21 	add	x1, x1, #0x9cb
  40afd0:	97ffe9c2 	bl	4056d8 <printk>
  40afd4:	97fff086 	bl	4071ec <z_impl_log_panic>
  40afd8:	52800000 	mov	w0, #0x0                   	// #0
  40afdc:	17ffffee 	b	40af94 <_posix_zephyr_main+0x50>

000000000040afe0 <add_test_filter_option>:
		  "\'suiteA::test1,suiteA::test2,suiteB::*\'. An * can be used "
		  "as a wildcard to run all tests within a suite." },
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(test_filter_s);
  40afe0:	90000140 	adrp	x0, 432000 <__dso_handle>
  40afe4:	911e0000 	add	x0, x0, #0x780
  40afe8:	17fffc79 	b	40a1cc <native_add_command_line_opts>

000000000040afec <z_ztest_testargs_contains>:
 * @param test_name
 * @return true
 * @return false
 */
static bool z_ztest_testargs_contains(const char *suite_name, const char *test_name)
{
  40afec:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40aff0:	910003fd 	mov	x29, sp
  40aff4:	a90363f7 	stp	x23, x24, [sp, #48]
  40aff8:	aa0003f7 	mov	x23, x0
  40affc:	f0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40b000:	a90153f3 	stp	x19, x20, [sp, #16]
  40b004:	aa0103f4 	mov	x20, x1
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
		test_arg = strtok_r(NULL, ":", &last_arg);

		found = !strcmp(suite_arg, suite_name);
		if (test_name) {
			found &= !strcmp(test_arg, "*") ||
  40b008:	d0000078 	adrp	x24, 419000 <__func__.2+0xa80>
{
  40b00c:	f9475c00 	ldr	x0, [x0, #3768]
  40b010:	a9025bf5 	stp	x21, x22, [sp, #32]
			found &= !strcmp(test_arg, "*") ||
  40b014:	91275b18 	add	x24, x24, #0x9d6
{
  40b018:	a9046bf9 	stp	x25, x26, [sp, #64]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40b01c:	d0000075 	adrp	x21, 419000 <__func__.2+0xa80>
  40b020:	9115aeb5 	add	x21, x21, #0x56b
{
  40b024:	a90573fb 	stp	x27, x28, [sp, #80]
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40b028:	9101c3fb 	add	x27, sp, #0x70
	bool found = false;
  40b02c:	52800013 	mov	w19, #0x0                   	// #0
{
  40b030:	f9400001 	ldr	x1, [x0]
  40b034:	f9003fe1 	str	x1, [sp, #120]
  40b038:	d2800001 	mov	x1, #0x0                   	// #0
	char *test_args_local = strdup(test_args);
  40b03c:	b0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40b040:	9101a3f9 	add	x25, sp, #0x68
  40b044:	d000007a 	adrp	x26, 419000 <__func__.2+0xa80>
	char *test_args_local = strdup(test_args);
  40b048:	f9400400 	ldr	x0, [x0, #8]
  40b04c:	97ffd931 	bl	401510 <strdup@plt>
  40b050:	aa0003f6 	mov	x22, x0
	suite_test_pair = strtok_r(test_args_local, ",", &last_suite_test_pair);
  40b054:	aa1903e2 	mov	x2, x25
  40b058:	913e5741 	add	x1, x26, #0xf95
  40b05c:	97ffd8f9 	bl	401440 <strtok_r@plt>
	while (suite_test_pair && !found) {
  40b060:	f100001f 	cmp	x0, #0x0
  40b064:	52000261 	eor	w1, w19, #0x1
  40b068:	1a9f07e2 	cset	w2, ne  // ne = any
  40b06c:	6a01005f 	tst	w2, w1
  40b070:	54000161 	b.ne	40b09c <z_ztest_testargs_contains+0xb0>  // b.any
		}

		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
	}

	free(test_args_local);
  40b074:	aa1603e0 	mov	x0, x22
  40b078:	97ffd956 	bl	4015d0 <free@plt>
	return found;
}
  40b07c:	d0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40b080:	f9475c00 	ldr	x0, [x0, #3768]
  40b084:	f9403fe2 	ldr	x2, [sp, #120]
  40b088:	f9400001 	ldr	x1, [x0]
  40b08c:	eb010042 	subs	x2, x2, x1
  40b090:	d2800001 	mov	x1, #0x0                   	// #0
  40b094:	54000440 	b.eq	40b11c <z_ztest_testargs_contains+0x130>  // b.none
  40b098:	97ffd922 	bl	401520 <__stack_chk_fail@plt>
		suite_arg = strtok_r(suite_test_pair, ":", &last_arg);
  40b09c:	aa1b03e2 	mov	x2, x27
  40b0a0:	aa1503e1 	mov	x1, x21
  40b0a4:	97ffd8e7 	bl	401440 <strtok_r@plt>
  40b0a8:	aa0003f3 	mov	x19, x0
		test_arg = strtok_r(NULL, ":", &last_arg);
  40b0ac:	aa1b03e2 	mov	x2, x27
  40b0b0:	aa1503e1 	mov	x1, x21
  40b0b4:	d2800000 	mov	x0, #0x0                   	// #0
  40b0b8:	97ffd8e2 	bl	401440 <strtok_r@plt>
		found = !strcmp(suite_arg, suite_name);
  40b0bc:	aa1703e1 	mov	x1, x23
		test_arg = strtok_r(NULL, ":", &last_arg);
  40b0c0:	aa0003fc 	mov	x28, x0
		found = !strcmp(suite_arg, suite_name);
  40b0c4:	aa1303e0 	mov	x0, x19
  40b0c8:	97ffd932 	bl	401590 <strcmp@plt>
  40b0cc:	7100001f 	cmp	w0, #0x0
  40b0d0:	1a9f17f3 	cset	w19, eq  // eq = none
		if (test_name) {
  40b0d4:	b4000174 	cbz	x20, 40b100 <z_ztest_testargs_contains+0x114>
			found &= !strcmp(test_arg, "*") ||
  40b0d8:	aa1803e1 	mov	x1, x24
  40b0dc:	aa1c03e0 	mov	x0, x28
  40b0e0:	97ffd92c 	bl	401590 <strcmp@plt>
  40b0e4:	34000180 	cbz	w0, 40b114 <z_ztest_testargs_contains+0x128>
				 !strcmp(test_arg, test_name);
  40b0e8:	aa1403e1 	mov	x1, x20
  40b0ec:	aa1c03e0 	mov	x0, x28
  40b0f0:	97ffd928 	bl	401590 <strcmp@plt>
			found &= !strcmp(test_arg, "*") ||
  40b0f4:	7100001f 	cmp	w0, #0x0
  40b0f8:	1a9f17e0 	cset	w0, eq  // eq = none
  40b0fc:	0a000273 	and	w19, w19, w0
		suite_test_pair = strtok_r(NULL, ",", &last_suite_test_pair);
  40b100:	aa1903e2 	mov	x2, x25
  40b104:	913e5741 	add	x1, x26, #0xf95
  40b108:	d2800000 	mov	x0, #0x0                   	// #0
  40b10c:	97ffd8cd 	bl	401440 <strtok_r@plt>
  40b110:	17ffffd4 	b	40b060 <z_ztest_testargs_contains+0x74>
			found &= !strcmp(test_arg, "*") ||
  40b114:	52800020 	mov	w0, #0x1                   	// #1
  40b118:	17fffff9 	b	40b0fc <z_ztest_testargs_contains+0x110>
}
  40b11c:	2a1303e0 	mov	w0, w19
  40b120:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b124:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b128:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b12c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40b130:	a94573fb 	ldp	x27, x28, [sp, #80]
  40b134:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40b138:	d65f03c0 	ret

000000000040b13c <z_ztest_should_test_run>:
 */
bool z_ztest_should_test_run(const char *suite, const char *test)
{
	bool run_test = false;

	run_test = (test_args == NULL ||
  40b13c:	b0000142 	adrp	x2, 434000 <ztest_thread+0xb8>
  40b140:	f9400442 	ldr	x2, [x2, #8]
  40b144:	b4000102 	cbz	x2, 40b164 <z_ztest_should_test_run+0x28>
{
  40b148:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40b14c:	910003fd 	mov	x29, sp
		    z_ztest_testargs_contains(suite, test));
  40b150:	97ffffa7 	bl	40afec <z_ztest_testargs_contains>
  40b154:	12001c00 	and	w0, w0, #0xff

	return run_test;
}
  40b158:	12000000 	and	w0, w0, #0x1
  40b15c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40b160:	d65f03c0 	ret
	run_test = (test_args == NULL ||
  40b164:	52800020 	mov	w0, #0x1                   	// #1
}
  40b168:	12000000 	and	w0, w0, #0x1
  40b16c:	d65f03c0 	ret

000000000040b170 <z_ztest_should_suite_run>:
 * @param suite Pointer to ztest_suite_node
 * @return true
 * @return false
 */
bool z_ztest_should_suite_run(const void *state, struct ztest_suite_node *suite)
{
  40b170:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b174:	910003fd 	mov	x29, sp
  40b178:	a90153f3 	stp	x19, x20, [sp, #16]
  40b17c:	aa0003f4 	mov	x20, x0
	bool run_suite = true;

	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40b180:	b0000140 	adrp	x0, 434000 <ztest_thread+0xb8>
{
  40b184:	aa0103f3 	mov	x19, x1
	if (test_args != NULL && !z_ztest_testargs_contains(suite->name, NULL)) {
  40b188:	f9400400 	ldr	x0, [x0, #8]
  40b18c:	b40001a0 	cbz	x0, 40b1c0 <z_ztest_should_suite_run+0x50>
  40b190:	f9400260 	ldr	x0, [x19]
  40b194:	d2800001 	mov	x1, #0x0                   	// #0
  40b198:	97ffff95 	bl	40afec <z_ztest_testargs_contains>
  40b19c:	72001c00 	ands	w0, w0, #0xff
  40b1a0:	54000101 	b.ne	40b1c0 <z_ztest_should_suite_run+0x50>  // b.any
  40b1a4:	f9401a62 	ldr	x2, [x19, #48]
		run_suite = false;
		suite->stats->run_count++;
  40b1a8:	b9400041 	ldr	w1, [x2]
  40b1ac:	11000421 	add	w1, w1, #0x1
  40b1b0:	b9000041 	str	w1, [x2]
	} else if (suite->predicate != NULL) {
		run_suite = suite->predicate(state);
	}

	return run_suite;
}
  40b1b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b1b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b1bc:	d65f03c0 	ret
	} else if (suite->predicate != NULL) {
  40b1c0:	f9401661 	ldr	x1, [x19, #40]
  40b1c4:	b40000c1 	cbz	x1, 40b1dc <z_ztest_should_suite_run+0x6c>
		run_suite = suite->predicate(state);
  40b1c8:	aa1403e0 	mov	x0, x20
  40b1cc:	aa0103f0 	mov	x16, x1
}
  40b1d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b1d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
		run_suite = suite->predicate(state);
  40b1d8:	d61f0200 	br	x16
	bool run_suite = true;
  40b1dc:	52800020 	mov	w0, #0x1                   	// #1
  40b1e0:	17fffff5 	b	40b1b4 <z_ztest_should_suite_run+0x44>

000000000040b1e4 <ztest_relative_filename>:
{
  40b1e4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  40b1e8:	910003fd 	mov	x29, sp
  40b1ec:	a90153f3 	stp	x19, x20, [sp, #16]
  40b1f0:	aa0003f3 	mov	x19, x0
  40b1f4:	d0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40b1f8:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b1fc:	f9475c00 	ldr	x0, [x0, #3768]
  40b200:	f9400001 	ldr	x1, [x0]
  40b204:	f9007fe1 	str	x1, [sp, #248]
  40b208:	d2800001 	mov	x1, #0x0                   	// #0
		       "destination buffer");

__fortify_function __wur char *
__NTH (getcwd (char *__buf, size_t __size))
{
  return __glibc_fortify (getcwd, __size, sizeof (char),
  40b20c:	9100c3e0 	add	x0, sp, #0x30
  40b210:	d2801901 	mov	x1, #0xc8                  	// #200
  40b214:	97ffd84f 	bl	401350 <getcwd@plt>
	if (cwd && strlen(file) > strlen(cwd) && !strncmp(file, cwd, strlen(cwd))) {
  40b218:	b4000220 	cbz	x0, 40b25c <ztest_relative_filename+0x78>
  40b21c:	aa0003f5 	mov	x21, x0
  40b220:	aa1303e0 	mov	x0, x19
  40b224:	97ffd853 	bl	401370 <strlen@plt>
  40b228:	aa0003f6 	mov	x22, x0
  40b22c:	aa1503e0 	mov	x0, x21
  40b230:	97ffd850 	bl	401370 <strlen@plt>
  40b234:	aa0003f4 	mov	x20, x0
  40b238:	eb0002df 	cmp	x22, x0
  40b23c:	54000109 	b.ls	40b25c <ztest_relative_filename+0x78>  // b.plast
  40b240:	aa0003e2 	mov	x2, x0
  40b244:	aa1503e1 	mov	x1, x21
  40b248:	aa1303e0 	mov	x0, x19
  40b24c:	97ffd88d 	bl	401480 <strncmp@plt>
  40b250:	35000060 	cbnz	w0, 40b25c <ztest_relative_filename+0x78>
		return file + strlen(cwd) + 1; /* move past the trailing '/' */
  40b254:	91000694 	add	x20, x20, #0x1
  40b258:	8b140273 	add	x19, x19, x20
}
  40b25c:	d0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40b260:	f9475c00 	ldr	x0, [x0, #3768]
  40b264:	f9407fe2 	ldr	x2, [sp, #248]
  40b268:	f9400001 	ldr	x1, [x0]
  40b26c:	eb010042 	subs	x2, x2, x1
  40b270:	d2800001 	mov	x1, #0x0                   	// #0
  40b274:	54000040 	b.eq	40b27c <ztest_relative_filename+0x98>  // b.none
  40b278:	97ffd8aa 	bl	401520 <__stack_chk_fail@plt>
  40b27c:	aa1303e0 	mov	x0, x19
  40b280:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b284:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b288:	a8d07bfd 	ldp	x29, x30, [sp], #256
  40b28c:	d65f03c0 	ret

000000000040b290 <z_ztest_get_list_test>:
}
  40b290:	d0000140 	adrp	x0, 435000 <stdout_buff+0xc1>
  40b294:	3941a000 	ldrb	w0, [x0, #104]
  40b298:	d65f03c0 	ret

000000000040b29c <z_ztest_list_tests>:
{
  40b29c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40b2a0:	910003fd 	mov	x29, sp
  40b2a4:	a90363f7 	stp	x23, x24, [sp, #48]
	if (list_once) {
  40b2a8:	f0000138 	adrp	x24, 432000 <__dso_handle>
  40b2ac:	39696300 	ldrb	w0, [x24, #2648]
{
  40b2b0:	a90153f3 	stp	x19, x20, [sp, #16]
  40b2b4:	a9025bf5 	stp	x21, x22, [sp, #32]
	int test_count = 0;
  40b2b8:	52800015 	mov	w21, #0x0                   	// #0
	if (list_once) {
  40b2bc:	350002e0 	cbnz	w0, 40b318 <z_ztest_list_tests+0x7c>
}
  40b2c0:	2a1503e0 	mov	w0, w21
  40b2c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b2c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b2cc:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b2d0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40b2d4:	d65f03c0 	ret
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40b2d8:	a9400a61 	ldp	x1, x2, [x19]
  40b2dc:	aa1703e0 	mov	x0, x23
				test_count++;
  40b2e0:	110006b5 	add	w21, w21, #0x1
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40b2e4:	97ffe8fd 	bl	4056d8 <printk>
			while ((test = z_ztest_get_next_test(ptr->name, test)) != NULL) {
  40b2e8:	f9400280 	ldr	x0, [x20]
  40b2ec:	aa1303e1 	mov	x1, x19
  40b2f0:	97fffd4b 	bl	40a81c <z_ztest_get_next_test>
  40b2f4:	aa0003f3 	mov	x19, x0
  40b2f8:	b5ffff00 	cbnz	x0, 40b2d8 <z_ztest_list_tests+0x3c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40b2fc:	9100e294 	add	x20, x20, #0x38
  40b300:	eb16029f 	cmp	x20, x22
  40b304:	54000063 	b.cc	40b310 <z_ztest_list_tests+0x74>  // b.lo, b.ul, b.last
		list_once = false;
  40b308:	3929631f 	strb	wzr, [x24, #2648]
	return test_count;
  40b30c:	17ffffed 	b	40b2c0 <z_ztest_list_tests+0x24>
			test = NULL;
  40b310:	d2800013 	mov	x19, #0x0                   	// #0
  40b314:	17fffff5 	b	40b2e8 <z_ztest_list_tests+0x4c>
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40b318:	d0000134 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  40b31c:	d0000136 	adrp	x22, 431000 <__FRAME_END__+0x10804>
				TC_PRINT("%s::%s\n", test->test_suite_name, test->name);
  40b320:	d0000077 	adrp	x23, 419000 <__func__.2+0xa80>
  40b324:	912762f7 	add	x23, x23, #0x9d8
		for (ptr = _ztest_suite_node_list_start; ptr < _ztest_suite_node_list_end; ++ptr) {
  40b328:	f946fa94 	ldr	x20, [x20, #3568]
  40b32c:	f9471ad6 	ldr	x22, [x22, #3632]
  40b330:	17fffff4 	b	40b300 <z_ztest_list_tests+0x64>

000000000040b334 <z_ztest_run_all>:
{
  40b334:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b338:	910003fd 	mov	x29, sp
  40b33c:	f9000bf3 	str	x19, [sp, #16]
  40b340:	aa0003f3 	mov	x19, x0
	if (z_ztest_get_list_test()) {
  40b344:	97ffffd3 	bl	40b290 <z_ztest_get_list_test>
  40b348:	72001c1f 	tst	w0, #0xff
  40b34c:	54000080 	b.eq	40b35c <z_ztest_run_all+0x28>  // b.none
}
  40b350:	f9400bf3 	ldr	x19, [sp, #16]
  40b354:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_ztest_list_tests();
  40b358:	17ffffd1 	b	40b29c <z_ztest_list_tests>
		union { uintptr_t x; const void * val; } parm0 = { .val = state };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_ZTEST_RUN_TEST_SUITES);
	}
#endif
	compiler_barrier();
	return z_impl_ztest_run_test_suites(state);
  40b35c:	aa1303e0 	mov	x0, x19
}
  40b360:	f9400bf3 	ldr	x19, [sp, #16]
  40b364:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b368:	17fffe56 	b	40acc0 <z_impl_ztest_run_test_suites>

000000000040b36c <generic_data_ref>:

	net_buf_simple_reset(&buf->b);
}

static uint8_t *generic_data_ref(struct net_buf *buf, uint8_t *data)
{
  40b36c:	aa0103e0 	mov	x0, x1
	uint8_t *ref_count;

	ref_count = data - sizeof(void *);
	(*ref_count)++;
  40b370:	385f8021 	ldurb	w1, [x1, #-8]
  40b374:	11000421 	add	w1, w1, #0x1
  40b378:	381f8001 	sturb	w1, [x0, #-8]

	return data;
}
  40b37c:	d65f03c0 	ret

000000000040b380 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
  40b380:	d65f03c0 	ret

000000000040b384 <net_buf_pool_get>:
}
  40b384:	d0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40b388:	52800c02 	mov	w2, #0x60                  	// #96
  40b38c:	f947a421 	ldr	x1, [x1, #3912]
  40b390:	9b220400 	smaddl	x0, w0, w2, x1
  40b394:	d65f03c0 	ret

000000000040b398 <mem_pool_data_unref>:
{
  40b398:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b39c:	910003fd 	mov	x29, sp
  40b3a0:	f9000bf3 	str	x19, [sp, #16]
  40b3a4:	aa0103f3 	mov	x19, x1
	struct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);
  40b3a8:	39404800 	ldrb	w0, [x0, #18]
  40b3ac:	97fffff6 	bl	40b384 <net_buf_pool_get>
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40b3b0:	f9402800 	ldr	x0, [x0, #80]
	if (--(*ref_count)) {
  40b3b4:	385f8262 	ldurb	w2, [x19, #-8]
  40b3b8:	51000442 	sub	w2, w2, #0x1
  40b3bc:	12001c42 	and	w2, w2, #0xff
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40b3c0:	f9400400 	ldr	x0, [x0, #8]
	if (--(*ref_count)) {
  40b3c4:	381f8262 	sturb	w2, [x19, #-8]
  40b3c8:	350000a2 	cbnz	w2, 40b3dc <mem_pool_data_unref+0x44>
	k_heap_free(pool, ref_count);
  40b3cc:	d1002261 	sub	x1, x19, #0x8
}
  40b3d0:	f9400bf3 	ldr	x19, [sp, #16]
  40b3d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_heap_free(pool, ref_count);
  40b3d8:	140019fa 	b	411bc0 <k_heap_free>
}
  40b3dc:	f9400bf3 	ldr	x19, [sp, #16]
  40b3e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b3e4:	d65f03c0 	ret

000000000040b3e8 <mem_pool_data_alloc>:
{
  40b3e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b3ec:	910003fd 	mov	x29, sp
  40b3f0:	a90153f3 	stp	x19, x20, [sp, #16]
  40b3f4:	aa0103f4 	mov	x20, x1
  40b3f8:	aa0203f3 	mov	x19, x2
	struct net_buf_pool *buf_pool = net_buf_pool_get(buf->pool_id);
  40b3fc:	39404800 	ldrb	w0, [x0, #18]
  40b400:	97ffffe1 	bl	40b384 <net_buf_pool_get>
	struct k_heap *pool = buf_pool->alloc->alloc_data;
  40b404:	f9402800 	ldr	x0, [x0, #80]
	void *b = k_heap_alloc(pool, sizeof(void *) + *size, timeout);
  40b408:	aa1303e2 	mov	x2, x19
  40b40c:	f9400281 	ldr	x1, [x20]
  40b410:	f9400400 	ldr	x0, [x0, #8]
  40b414:	91002021 	add	x1, x1, #0x8
  40b418:	940019e6 	bl	411bb0 <k_heap_alloc>
	if (b == NULL) {
  40b41c:	b4000060 	cbz	x0, 40b428 <mem_pool_data_alloc+0x40>
	*ref_count = 1U;
  40b420:	52800021 	mov	w1, #0x1                   	// #1
  40b424:	38008401 	strb	w1, [x0], #8
}
  40b428:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b42c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b430:	d65f03c0 	ret

000000000040b434 <data_alloc>:
};

#endif /* CONFIG_HEAP_MEM_POOL_SIZE > 0 */

static uint8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)
{
  40b434:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40b438:	910003fd 	mov	x29, sp
  40b43c:	a90153f3 	stp	x19, x20, [sp, #16]
  40b440:	aa0003f3 	mov	x19, x0
  40b444:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b448:	39404800 	ldrb	w0, [x0, #18]
{
  40b44c:	f90013f5 	str	x21, [sp, #32]
  40b450:	aa0203f5 	mov	x21, x2
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b454:	97ffffcc 	bl	40b384 <net_buf_pool_get>

	return pool->alloc->cb->alloc(buf, size, timeout);
  40b458:	f9402800 	ldr	x0, [x0, #80]
  40b45c:	aa1503e2 	mov	x2, x21
  40b460:	aa1403e1 	mov	x1, x20
}
  40b464:	f94013f5 	ldr	x21, [sp, #32]
	return pool->alloc->cb->alloc(buf, size, timeout);
  40b468:	f9400000 	ldr	x0, [x0]
  40b46c:	f9400003 	ldr	x3, [x0]
  40b470:	aa1303e0 	mov	x0, x19
}
  40b474:	a94153f3 	ldp	x19, x20, [sp, #16]
	return pool->alloc->cb->alloc(buf, size, timeout);
  40b478:	aa0303f0 	mov	x16, x3
}
  40b47c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return pool->alloc->cb->alloc(buf, size, timeout);
  40b480:	d61f0200 	br	x16

000000000040b484 <net_buf_destroy>:
{
  40b484:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b488:	910003fd 	mov	x29, sp
  40b48c:	f9000bf3 	str	x19, [sp, #16]
  40b490:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b494:	39404800 	ldrb	w0, [x0, #18]
  40b498:	97ffffbb 	bl	40b384 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
  40b49c:	aa1303e1 	mov	x1, x19
}
  40b4a0:	f9400bf3 	ldr	x19, [sp, #16]
  40b4a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_lifo_put(&pool->free, buf);
  40b4a8:	14001fa8 	b	413348 <k_queue_prepend>

000000000040b4ac <net_buf_id>:
{
  40b4ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b4b0:	910003fd 	mov	x29, sp
  40b4b4:	f9000bf3 	str	x19, [sp, #16]
  40b4b8:	aa0003f3 	mov	x19, x0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b4bc:	39404800 	ldrb	w0, [x0, #18]
  40b4c0:	97ffffb1 	bl	40b384 <net_buf_pool_get>
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40b4c4:	f9402c01 	ldr	x1, [x0, #88]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40b4c8:	39411000 	ldrb	w0, [x0, #68]
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
  40b4cc:	cb010273 	sub	x19, x19, x1
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40b4d0:	9100dc00 	add	x0, x0, #0x37
  40b4d4:	927df000 	and	x0, x0, #0xfffffffffffffff8
}
  40b4d8:	9ac00a60 	udiv	x0, x19, x0
  40b4dc:	f9400bf3 	ldr	x19, [sp, #16]
  40b4e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b4e4:	d65f03c0 	ret

000000000040b4e8 <fixed_data_alloc>:
{
  40b4e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40b4ec:	910003fd 	mov	x29, sp
  40b4f0:	a90153f3 	stp	x19, x20, [sp, #16]
  40b4f4:	aa0003f3 	mov	x19, x0
  40b4f8:	aa0103f4 	mov	x20, x1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b4fc:	39404800 	ldrb	w0, [x0, #18]
{
  40b500:	f90013f5 	str	x21, [sp, #32]
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b504:	97ffffa0 	bl	40b384 <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40b508:	f9402800 	ldr	x0, [x0, #80]
  40b50c:	f9400401 	ldr	x1, [x0, #8]
	*size = MIN(fixed->data_size, *size);
  40b510:	f9400280 	ldr	x0, [x20]
  40b514:	f9400022 	ldr	x2, [x1]
  40b518:	eb02001f 	cmp	x0, x2
  40b51c:	9a829000 	csel	x0, x0, x2, ls  // ls = plast
  40b520:	f9000280 	str	x0, [x20]
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
  40b524:	aa1303e0 	mov	x0, x19
  40b528:	a9405035 	ldp	x21, x20, [x1]
  40b52c:	97ffffe0 	bl	40b4ac <net_buf_id>
  40b530:	93407c00 	sxtw	x0, w0
}
  40b534:	9b155000 	madd	x0, x0, x21, x20
  40b538:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b53c:	f94013f5 	ldr	x21, [sp, #32]
  40b540:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b544:	d65f03c0 	ret

000000000040b548 <net_buf_reset>:
{
  40b548:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40b54c:	910003fd 	mov	x29, sp
  40b550:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(buf->flags == 0U);
  40b554:	39404401 	ldrb	w1, [x0, #17]
  40b558:	34000241 	cbz	w1, 40b5a0 <net_buf_reset+0x58>
  40b55c:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40b560:	912ac273 	add	x19, x19, #0xab0
  40b564:	aa1303e2 	mov	x2, x19
  40b568:	52800b43 	mov	w3, #0x5a                  	// #90
  40b56c:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40b570:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b574:	912b5021 	add	x1, x1, #0xad4
  40b578:	91178000 	add	x0, x0, #0x5e0
  40b57c:	97ffee2b 	bl	406e28 <assert_print>
  40b580:	aa1303e0 	mov	x0, x19
  40b584:	52800b41 	mov	w1, #0x5a                  	// #90
  40b588:	97ffee52 	bl	406ed0 <assert_post_action>
  40b58c:	52800b42 	mov	w2, #0x5a                  	// #90
	__ASSERT_NO_MSG(buf->frags == NULL);
  40b590:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b594:	aa1303e1 	mov	x1, x19
  40b598:	91187800 	add	x0, x0, #0x61e
  40b59c:	97fff83f 	bl	409698 <posix_print_error_and_exit>
  40b5a0:	f9400401 	ldr	x1, [x0, #8]
  40b5a4:	b40001e1 	cbz	x1, 40b5e0 <net_buf_reset+0x98>
  40b5a8:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40b5ac:	912ac273 	add	x19, x19, #0xab0
  40b5b0:	aa1303e2 	mov	x2, x19
  40b5b4:	52800b63 	mov	w3, #0x5b                  	// #91
  40b5b8:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40b5bc:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b5c0:	912b9421 	add	x1, x1, #0xae5
  40b5c4:	91178000 	add	x0, x0, #0x5e0
  40b5c8:	97ffee18 	bl	406e28 <assert_print>
  40b5cc:	aa1303e0 	mov	x0, x19
  40b5d0:	52800b61 	mov	w1, #0x5b                  	// #91
  40b5d4:	97ffee3f 	bl	406ed0 <assert_post_action>
  40b5d8:	52800b62 	mov	w2, #0x5b                  	// #91
  40b5dc:	17ffffed 	b	40b590 <net_buf_reset+0x48>
	buf->data = buf->__buf;
  40b5e0:	f9401401 	ldr	x1, [x0, #40]
  40b5e4:	f9000c01 	str	x1, [x0, #24]
	buf->len  = 0U;
  40b5e8:	7900401f 	strh	wzr, [x0, #32]
}
  40b5ec:	f9400bf3 	ldr	x19, [sp, #16]
  40b5f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40b5f4:	d65f03c0 	ret

000000000040b5f8 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
  40b5f8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40b5fc:	910003fd 	mov	x29, sp
  40b600:	a90153f3 	stp	x19, x20, [sp, #16]
  40b604:	aa0003f4 	mov	x20, x0
	uint64_t end = sys_clock_timeout_end_calc(timeout);
  40b608:	aa0203e0 	mov	x0, x2
{
  40b60c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40b610:	aa0203f5 	mov	x21, x2
  40b614:	a90363f7 	stp	x23, x24, [sp, #48]
  40b618:	f90023f9 	str	x25, [sp, #64]
  40b61c:	f9002fe1 	str	x1, [sp, #88]
	uint64_t end = sys_clock_timeout_end_calc(timeout);
  40b620:	94002f7a 	bl	417408 <sys_clock_timeout_end_calc>
	struct net_buf *buf;
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(pool);
  40b624:	b5000254 	cbnz	x20, 40b66c <net_buf_alloc_len+0x74>
  40b628:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40b62c:	912ac273 	add	x19, x19, #0xab0
  40b630:	aa1303e2 	mov	x2, x19
  40b634:	52801f03 	mov	w3, #0xf8                  	// #248
  40b638:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40b63c:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b640:	912bfc21 	add	x1, x1, #0xaff
  40b644:	91178000 	add	x0, x0, #0x5e0
  40b648:	97ffedf8 	bl	406e28 <assert_print>
  40b64c:	aa1303e0 	mov	x0, x19
  40b650:	52801f01 	mov	w1, #0xf8                  	// #248
  40b654:	97ffee1f 	bl	406ed0 <assert_post_action>
  40b658:	52801f02 	mov	w2, #0xf8                  	// #248
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  40b65c:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b660:	aa1303e1 	mov	x1, x19
  40b664:	91187800 	add	x0, x0, #0x61e
  40b668:	97fff80c 	bl	409698 <posix_print_error_and_exit>
  40b66c:	aa0003f7 	mov	x23, x0
	NET_BUF_DBG("%s():%d: pool %p size %zu", func, line, pool, size);

	/* We need to prevent race conditions
	 * when accessing pool->uninit_count.
	 */
	key = k_spin_lock(&pool->lock);
  40b670:	9100e296 	add	x22, x20, #0x38
	return posix_irq_lock();
  40b674:	97fff6f3 	bl	409240 <posix_irq_lock>
  40b678:	2a0003f8 	mov	w24, w0
  40b67c:	aa1603e0 	mov	x0, x22
  40b680:	94001b97 	bl	4124dc <z_spin_lock_valid>
  40b684:	72001c1f 	tst	w0, #0xff
  40b688:	54000261 	b.ne	40b6d4 <net_buf_alloc_len+0xdc>  // b.any
  40b68c:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40b690:	912c1273 	add	x19, x19, #0xb04
  40b694:	aa1303e2 	mov	x2, x19
  40b698:	52801283 	mov	w3, #0x94                  	// #148
  40b69c:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40b6a0:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b6a4:	912cc421 	add	x1, x1, #0xb31
  40b6a8:	91178000 	add	x0, x0, #0x5e0
  40b6ac:	97ffeddf 	bl	406e28 <assert_print>
  40b6b0:	aa1603e1 	mov	x1, x22
  40b6b4:	d0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40b6b8:	912d1800 	add	x0, x0, #0xb46
  40b6bc:	97ffeddb 	bl	406e28 <assert_print>
  40b6c0:	aa1303e0 	mov	x0, x19
  40b6c4:	52801281 	mov	w1, #0x94                  	// #148
  40b6c8:	97ffee02 	bl	406ed0 <assert_post_action>
  40b6cc:	52801282 	mov	w2, #0x94                  	// #148
  40b6d0:	17ffffe3 	b	40b65c <net_buf_alloc_len+0x64>
		arch_spin_relax();
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
  40b6d4:	aa1603e0 	mov	x0, x22
  40b6d8:	94001b99 	bl	41253c <z_spin_lock_set_owner>

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
  40b6dc:	79408680 	ldrh	w0, [x20, #66]
  40b6e0:	340009e0 	cbz	w0, 40b81c <net_buf_alloc_len+0x224>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
  40b6e4:	79408281 	ldrh	w1, [x20, #64]
  40b6e8:	6b00003f 	cmp	w1, w0
  40b6ec:	54000609 	b.ls	40b7ac <net_buf_alloc_len+0x1b4>  // b.plast
	return z_impl_k_queue_get(queue, timeout);
  40b6f0:	d2800001 	mov	x1, #0x0                   	// #0
  40b6f4:	aa1403e0 	mov	x0, x20
  40b6f8:	94001f19 	bl	41335c <z_impl_k_queue_get>
  40b6fc:	aa0003f3 	mov	x19, x0
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
  40b700:	b4000560 	cbz	x0, 40b7ac <net_buf_alloc_len+0x1b4>
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  40b704:	aa1603e0 	mov	x0, x22
  40b708:	94001b80 	bl	412508 <z_spin_unlock_valid>
  40b70c:	72001c1f 	tst	w0, #0xff
  40b710:	54000261 	b.ne	40b75c <net_buf_alloc_len+0x164>  // b.any
  40b714:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40b718:	912c1273 	add	x19, x19, #0xb04
  40b71c:	aa1303e2 	mov	x2, x19
  40b720:	52801863 	mov	w3, #0xc3                  	// #195
  40b724:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40b728:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b72c:	912d7821 	add	x1, x1, #0xb5e
  40b730:	91178000 	add	x0, x0, #0x5e0
  40b734:	97ffedbd 	bl	406e28 <assert_print>
  40b738:	aa1603e1 	mov	x1, x22
  40b73c:	d0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40b740:	912dd400 	add	x0, x0, #0xb75
  40b744:	97ffedb9 	bl	406e28 <assert_print>
  40b748:	aa1303e0 	mov	x0, x19
  40b74c:	52801861 	mov	w1, #0xc3                  	// #195
  40b750:	97ffede0 	bl	406ed0 <assert_post_action>
  40b754:	52801862 	mov	w2, #0xc3                  	// #195
  40b758:	17ffffc1 	b	40b65c <net_buf_alloc_len+0x64>
	posix_irq_unlock(key);
  40b75c:	2a1803e0 	mov	w0, w24
  40b760:	97fff6ba 	bl	409248 <posix_irq_unlock>
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
  40b764:	f9402ff4 	ldr	x20, [sp, #88]
  40b768:	b4000a74 	cbz	x20, 40b8b4 <net_buf_alloc_len+0x2bc>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
  40b76c:	b40000d5 	cbz	x21, 40b784 <net_buf_alloc_len+0x18c>
  40b770:	b10006bf 	cmn	x21, #0x1
  40b774:	54000080 	b.eq	40b784 <net_buf_alloc_len+0x18c>  // b.none
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			int64_t remaining = end - sys_clock_tick_get();
  40b778:	94002eda 	bl	4172e0 <sys_clock_tick_get>

			if (remaining <= 0) {
  40b77c:	eb0002f5 	subs	x21, x23, x0
  40b780:	9a9f52b5 	csel	x21, x21, xzr, pl  // pl = nfrst
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
  40b784:	aa1503e2 	mov	x2, x21
  40b788:	910163e1 	add	x1, sp, #0x58
  40b78c:	aa1303e0 	mov	x0, x19
  40b790:	97ffff29 	bl	40b434 <data_alloc>
  40b794:	f9001660 	str	x0, [x19, #40]
		if (!buf->__buf) {
  40b798:	b5000660 	cbnz	x0, 40b864 <net_buf_alloc_len+0x26c>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
  40b79c:	aa1303e0 	mov	x0, x19
			return NULL;
  40b7a0:	d2800013 	mov	x19, #0x0                   	// #0
			net_buf_destroy(buf);
  40b7a4:	97ffff38 	bl	40b484 <net_buf_destroy>
			return NULL;
  40b7a8:	14000028 	b	40b848 <net_buf_alloc_len+0x250>
		uninit_count = pool->uninit_count--;
  40b7ac:	79408699 	ldrh	w25, [x20, #66]
  40b7b0:	51000720 	sub	w0, w25, #0x1
  40b7b4:	79008680 	strh	w0, [x20, #66]
  40b7b8:	aa1603e0 	mov	x0, x22
  40b7bc:	94001b53 	bl	412508 <z_spin_unlock_valid>
  40b7c0:	72001c1f 	tst	w0, #0xff
  40b7c4:	54fffa80 	b.eq	40b714 <net_buf_alloc_len+0x11c>  // b.none
  40b7c8:	2a1803e0 	mov	w0, w24
  40b7cc:	97fff69f 	bl	409248 <posix_irq_unlock>
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40b7d0:	79408280 	ldrh	w0, [x20, #64]
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40b7d4:	39411293 	ldrb	w19, [x20, #68]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40b7d8:	4b190000 	sub	w0, w0, w25
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40b7dc:	9100de73 	add	x19, x19, #0x37
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
  40b7e0:	f9402e81 	ldr	x1, [x20, #88]
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
  40b7e4:	93407c00 	sxtw	x0, w0
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
  40b7e8:	927df273 	and	x19, x19, #0xfffffffffffffff8
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
  40b7ec:	9b000673 	madd	x19, x19, x0, x1
	return pool - TYPE_SECTION_START(net_buf_pool);
  40b7f0:	d0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40b7f4:	b201f3e1 	mov	x1, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
  40b7f8:	f947a400 	ldr	x0, [x0, #3912]
  40b7fc:	f2955561 	movk	x1, #0xaaab
  40b800:	cb000280 	sub	x0, x20, x0
  40b804:	9345fc00 	asr	x0, x0, #5
  40b808:	9b017c00 	mul	x0, x0, x1
	buf->pool_id = pool_id(pool);
  40b80c:	39004a60 	strb	w0, [x19, #18]
	buf->user_data_size = pool->user_data_size;
  40b810:	39411280 	ldrb	w0, [x20, #68]
  40b814:	39004e60 	strb	w0, [x19, #19]
		goto success;
  40b818:	17ffffd3 	b	40b764 <net_buf_alloc_len+0x16c>
  40b81c:	aa1603e0 	mov	x0, x22
  40b820:	94001b3a 	bl	412508 <z_spin_unlock_valid>
  40b824:	72001c1f 	tst	w0, #0xff
  40b828:	54fff760 	b.eq	40b714 <net_buf_alloc_len+0x11c>  // b.none
  40b82c:	2a1803e0 	mov	w0, w24
  40b830:	97fff686 	bl	409248 <posix_irq_unlock>
  40b834:	aa1503e1 	mov	x1, x21
  40b838:	aa1403e0 	mov	x0, x20
  40b83c:	94001ec8 	bl	41335c <z_impl_k_queue_get>
  40b840:	aa0003f3 	mov	x19, x0
	if (!buf) {
  40b844:	b5fff900 	cbnz	x0, 40b764 <net_buf_alloc_len+0x16c>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
  40b848:	aa1303e0 	mov	x0, x19
  40b84c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b850:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40b854:	a94363f7 	ldp	x23, x24, [sp, #48]
  40b858:	f94023f9 	ldr	x25, [sp, #64]
  40b85c:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40b860:	d65f03c0 	ret
		NET_BUF_ASSERT(req_size <= size);
  40b864:	f9402fe0 	ldr	x0, [sp, #88]
  40b868:	eb00029f 	cmp	x20, x0
  40b86c:	54000269 	b.ls	40b8b8 <net_buf_alloc_len+0x2c0>  // b.plast
  40b870:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40b874:	912ac273 	add	x19, x19, #0xab0
  40b878:	aa1303e2 	mov	x2, x19
  40b87c:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40b880:	912e2821 	add	x1, x1, #0xb8a
  40b884:	52802b23 	mov	w3, #0x159                 	// #345
  40b888:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b88c:	91178000 	add	x0, x0, #0x5e0
  40b890:	97ffed66 	bl	406e28 <assert_print>
  40b894:	d0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40b898:	912e6c00 	add	x0, x0, #0xb9b
  40b89c:	97ffed63 	bl	406e28 <assert_print>
  40b8a0:	aa1303e0 	mov	x0, x19
  40b8a4:	52802b21 	mov	w1, #0x159                 	// #345
  40b8a8:	97ffed8a 	bl	406ed0 <assert_post_action>
  40b8ac:	52802b22 	mov	w2, #0x159                 	// #345
  40b8b0:	17ffff6b 	b	40b65c <net_buf_alloc_len+0x64>
		buf->__buf = NULL;
  40b8b4:	f900167f 	str	xzr, [x19, #40]
	buf->ref   = 1U;
  40b8b8:	52800020 	mov	w0, #0x1                   	// #1
  40b8bc:	79002260 	strh	w0, [x19, #16]
	buf->size  = size;
  40b8c0:	f9402fe0 	ldr	x0, [sp, #88]
	buf->frags = NULL;
  40b8c4:	f900067f 	str	xzr, [x19, #8]
	buf->size  = size;
  40b8c8:	79004660 	strh	w0, [x19, #34]
	net_buf_reset(buf);
  40b8cc:	aa1303e0 	mov	x0, x19
  40b8d0:	97ffff1e 	bl	40b548 <net_buf_reset>
	return buf;
  40b8d4:	17ffffdd 	b	40b848 <net_buf_alloc_len+0x250>

000000000040b8d8 <net_buf_alloc_fixed>:
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
  40b8d8:	f9402802 	ldr	x2, [x0, #80]

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
  40b8dc:	f9400443 	ldr	x3, [x2, #8]
  40b8e0:	aa0103e2 	mov	x2, x1
  40b8e4:	f9400061 	ldr	x1, [x3]
  40b8e8:	17ffff44 	b	40b5f8 <net_buf_alloc_len>

000000000040b8ec <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
  40b8ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40b8f0:	910003fd 	mov	x29, sp
  40b8f4:	a90153f3 	stp	x19, x20, [sp, #16]
  40b8f8:	f90013f5 	str	x21, [sp, #32]
	__ASSERT_NO_MSG(buf);
  40b8fc:	b5000240 	cbnz	x0, 40b944 <net_buf_unref+0x58>
  40b900:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40b904:	912ac273 	add	x19, x19, #0xab0
  40b908:	aa1303e2 	mov	x2, x19
  40b90c:	52803ba3 	mov	w3, #0x1dd                 	// #477
  40b910:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40b914:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b918:	912eb821 	add	x1, x1, #0xbae
  40b91c:	91178000 	add	x0, x0, #0x5e0
  40b920:	97ffed42 	bl	406e28 <assert_print>
  40b924:	aa1303e0 	mov	x0, x19
  40b928:	52803ba1 	mov	w1, #0x1dd                 	// #477
  40b92c:	97ffed69 	bl	406ed0 <assert_post_action>
  40b930:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40b934:	aa1303e1 	mov	x1, x19
  40b938:	91187800 	add	x0, x0, #0x61e
  40b93c:	52803ba2 	mov	w2, #0x1dd                 	// #477
  40b940:	97fff756 	bl	409698 <posix_print_error_and_exit>
  40b944:	aa0003f4 	mov	x20, x0
		}
#endif
		NET_BUF_DBG("buf %p ref %u pool_id %u frags %p", buf, buf->ref,
			    buf->pool_id, buf->frags);

		if (--buf->ref > 0) {
  40b948:	39404280 	ldrb	w0, [x20, #16]
  40b94c:	aa1403f3 	mov	x19, x20
		struct net_buf *frags = buf->frags;
  40b950:	f9400694 	ldr	x20, [x20, #8]
		if (--buf->ref > 0) {
  40b954:	51000400 	sub	w0, w0, #0x1
  40b958:	12001c00 	and	w0, w0, #0xff
  40b95c:	39004260 	strb	w0, [x19, #16]
  40b960:	350002e0 	cbnz	w0, 40b9bc <net_buf_unref+0xd0>
			return;
		}

		if (buf->__buf) {
  40b964:	f9401675 	ldr	x21, [x19, #40]
  40b968:	b4000195 	cbz	x21, 40b998 <net_buf_unref+0xac>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
  40b96c:	39404a60 	ldrb	w0, [x19, #18]
  40b970:	97fffe85 	bl	40b384 <net_buf_pool_get>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
  40b974:	39404661 	ldrb	w1, [x19, #17]
  40b978:	370000e1 	tbnz	w1, #0, 40b994 <net_buf_unref+0xa8>
	pool->alloc->cb->unref(buf, data);
  40b97c:	f9402800 	ldr	x0, [x0, #80]
  40b980:	aa1503e1 	mov	x1, x21
  40b984:	f9400000 	ldr	x0, [x0]
  40b988:	f9400802 	ldr	x2, [x0, #16]
  40b98c:	aa1303e0 	mov	x0, x19
  40b990:	d63f0040 	blr	x2
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
  40b994:	f900167f 	str	xzr, [x19, #40]
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
  40b998:	39404a60 	ldrb	w0, [x19, #18]
		buf->frags = NULL;
  40b99c:	f900067f 	str	xzr, [x19, #8]
		buf->data = NULL;
  40b9a0:	f9000e7f 	str	xzr, [x19, #24]
		pool = net_buf_pool_get(buf->pool_id);
  40b9a4:	97fffe78 	bl	40b384 <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
  40b9a8:	f9402401 	ldr	x1, [x0, #72]
			pool->destroy(buf);
  40b9ac:	aa1303e0 	mov	x0, x19
		if (pool->destroy) {
  40b9b0:	b40000e1 	cbz	x1, 40b9cc <net_buf_unref+0xe0>
			pool->destroy(buf);
  40b9b4:	d63f0020 	blr	x1
	while (buf) {
  40b9b8:	b5fffc94 	cbnz	x20, 40b948 <net_buf_unref+0x5c>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
  40b9bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40b9c0:	f94013f5 	ldr	x21, [sp, #32]
  40b9c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40b9c8:	d65f03c0 	ret
			net_buf_destroy(buf);
  40b9cc:	97fffeae 	bl	40b484 <net_buf_destroy>
  40b9d0:	17fffffa 	b	40b9b8 <net_buf_unref+0xcc>

000000000040b9d4 <net_buf_ref>:

struct net_buf *net_buf_ref(struct net_buf *buf)
{
	__ASSERT_NO_MSG(buf);
  40b9d4:	b50002a0 	cbnz	x0, 40ba28 <net_buf_ref+0x54>
{
  40b9d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT_NO_MSG(buf);
  40b9dc:	52804183 	mov	w3, #0x20c                 	// #524
  40b9e0:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
{
  40b9e4:	910003fd 	mov	x29, sp
  40b9e8:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(buf);
  40b9ec:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40b9f0:	912ac273 	add	x19, x19, #0xab0
  40b9f4:	912eb821 	add	x1, x1, #0xbae
  40b9f8:	aa1303e2 	mov	x2, x19
  40b9fc:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40ba00:	91178000 	add	x0, x0, #0x5e0
  40ba04:	97ffed09 	bl	406e28 <assert_print>
  40ba08:	aa1303e0 	mov	x0, x19
  40ba0c:	52804181 	mov	w1, #0x20c                 	// #524
  40ba10:	97ffed30 	bl	406ed0 <assert_post_action>
  40ba14:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40ba18:	aa1303e1 	mov	x1, x19
  40ba1c:	91187800 	add	x0, x0, #0x61e
  40ba20:	52804182 	mov	w2, #0x20c                 	// #524
  40ba24:	97fff71d 	bl	409698 <posix_print_error_and_exit>

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
  40ba28:	39404002 	ldrb	w2, [x0, #16]
  40ba2c:	11000442 	add	w2, w2, #0x1
  40ba30:	39004002 	strb	w2, [x0, #16]
	return buf;
}
  40ba34:	d65f03c0 	ret

000000000040ba38 <net_buf_frag_last>:
	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
	__ASSERT_NO_MSG(buf);
  40ba38:	b50002a0 	cbnz	x0, 40ba8c <net_buf_frag_last+0x54>
{
  40ba3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT_NO_MSG(buf);
  40ba40:	52804923 	mov	w3, #0x249                 	// #585
  40ba44:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
{
  40ba48:	910003fd 	mov	x29, sp
  40ba4c:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(buf);
  40ba50:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40ba54:	912ac273 	add	x19, x19, #0xab0
  40ba58:	912eb821 	add	x1, x1, #0xbae
  40ba5c:	aa1303e2 	mov	x2, x19
  40ba60:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40ba64:	91178000 	add	x0, x0, #0x5e0
  40ba68:	97ffecf0 	bl	406e28 <assert_print>
  40ba6c:	aa1303e0 	mov	x0, x19
  40ba70:	52804921 	mov	w1, #0x249                 	// #585
  40ba74:	97ffed17 	bl	406ed0 <assert_post_action>
  40ba78:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40ba7c:	aa1303e1 	mov	x1, x19
  40ba80:	91187800 	add	x0, x0, #0x61e
  40ba84:	52804922 	mov	w2, #0x249                 	// #585
  40ba88:	97fff704 	bl	409698 <posix_print_error_and_exit>
  40ba8c:	aa0003e1 	mov	x1, x0

	while (buf->frags) {
  40ba90:	aa0103e0 	mov	x0, x1
  40ba94:	f9400421 	ldr	x1, [x1, #8]
  40ba98:	b5ffffc1 	cbnz	x1, 40ba90 <net_buf_frag_last+0x58>
		buf = buf->frags;
	}

	return buf;
}
  40ba9c:	d65f03c0 	ret

000000000040baa0 <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
  40baa0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40baa4:	910003fd 	mov	x29, sp
  40baa8:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT_NO_MSG(parent);
  40baac:	b5000240 	cbnz	x0, 40baf4 <net_buf_frag_insert+0x54>
  40bab0:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40bab4:	912ac273 	add	x19, x19, #0xab0
  40bab8:	aa1303e2 	mov	x2, x19
  40babc:	52804a83 	mov	w3, #0x254                 	// #596
  40bac0:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40bac4:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40bac8:	912e7821 	add	x1, x1, #0xb9e
  40bacc:	91178000 	add	x0, x0, #0x5e0
  40bad0:	97ffecd6 	bl	406e28 <assert_print>
  40bad4:	aa1303e0 	mov	x0, x19
  40bad8:	52804a81 	mov	w1, #0x254                 	// #596
  40badc:	97ffecfd 	bl	406ed0 <assert_post_action>
  40bae0:	52804a82 	mov	w2, #0x254                 	// #596
	__ASSERT_NO_MSG(frag);
  40bae4:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40bae8:	aa1303e1 	mov	x1, x19
  40baec:	91187800 	add	x0, x0, #0x61e
  40baf0:	97fff6ea 	bl	409698 <posix_print_error_and_exit>
  40baf4:	aa0103f4 	mov	x20, x1
  40baf8:	b50001e1 	cbnz	x1, 40bb34 <net_buf_frag_insert+0x94>
  40bafc:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40bb00:	912ac273 	add	x19, x19, #0xab0
  40bb04:	aa1303e2 	mov	x2, x19
  40bb08:	52804aa3 	mov	w3, #0x255                 	// #597
  40bb0c:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40bb10:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40bb14:	912e9421 	add	x1, x1, #0xba5
  40bb18:	91178000 	add	x0, x0, #0x5e0
  40bb1c:	97ffecc3 	bl	406e28 <assert_print>
  40bb20:	aa1303e0 	mov	x0, x19
  40bb24:	52804aa1 	mov	w1, #0x255                 	// #597
  40bb28:	97ffecea 	bl	406ed0 <assert_post_action>
  40bb2c:	52804aa2 	mov	w2, #0x255                 	// #597
  40bb30:	17ffffed 	b	40bae4 <net_buf_frag_insert+0x44>
  40bb34:	aa0003f3 	mov	x19, x0

	if (parent->frags) {
  40bb38:	f9400400 	ldr	x0, [x0, #8]
  40bb3c:	b40000a0 	cbz	x0, 40bb50 <net_buf_frag_insert+0xb0>
		net_buf_frag_last(frag)->frags = parent->frags;
  40bb40:	aa0103e0 	mov	x0, x1
  40bb44:	97ffffbd 	bl	40ba38 <net_buf_frag_last>
  40bb48:	f9400661 	ldr	x1, [x19, #8]
  40bb4c:	f9000401 	str	x1, [x0, #8]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
  40bb50:	f9000674 	str	x20, [x19, #8]
}
  40bb54:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bb58:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40bb5c:	d65f03c0 	ret

000000000040bb60 <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
  40bb60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40bb64:	910003fd 	mov	x29, sp
  40bb68:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT_NO_MSG(frag);
  40bb6c:	b5000241 	cbnz	x1, 40bbb4 <net_buf_frag_add+0x54>
  40bb70:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40bb74:	912ac273 	add	x19, x19, #0xab0
  40bb78:	aa1303e2 	mov	x2, x19
  40bb7c:	52804c03 	mov	w3, #0x260                 	// #608
  40bb80:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40bb84:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40bb88:	912e9421 	add	x1, x1, #0xba5
  40bb8c:	91178000 	add	x0, x0, #0x5e0
  40bb90:	97ffeca6 	bl	406e28 <assert_print>
  40bb94:	aa1303e0 	mov	x0, x19
  40bb98:	52804c01 	mov	w1, #0x260                 	// #608
  40bb9c:	97ffeccd 	bl	406ed0 <assert_post_action>
  40bba0:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40bba4:	aa1303e1 	mov	x1, x19
  40bba8:	91187800 	add	x0, x0, #0x61e
  40bbac:	52804c02 	mov	w2, #0x260                 	// #608
  40bbb0:	97fff6ba 	bl	409698 <posix_print_error_and_exit>
  40bbb4:	aa0003f4 	mov	x20, x0
  40bbb8:	aa0103f3 	mov	x19, x1

	if (!head) {
  40bbbc:	b50000a0 	cbnz	x0, 40bbd0 <net_buf_frag_add+0x70>
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);

	return head;
}
  40bbc0:	a94153f3 	ldp	x19, x20, [sp, #16]
		return net_buf_ref(frag);
  40bbc4:	aa0103e0 	mov	x0, x1
}
  40bbc8:	a8c27bfd 	ldp	x29, x30, [sp], #32
		return net_buf_ref(frag);
  40bbcc:	17ffff82 	b	40b9d4 <net_buf_ref>
	net_buf_frag_insert(net_buf_frag_last(head), frag);
  40bbd0:	97ffff9a 	bl	40ba38 <net_buf_frag_last>
  40bbd4:	aa1303e1 	mov	x1, x19
  40bbd8:	97ffffb2 	bl	40baa0 <net_buf_frag_insert>
}
  40bbdc:	aa1403e0 	mov	x0, x20
  40bbe0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bbe4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40bbe8:	d65f03c0 	ret

000000000040bbec <net_buf_linearize>:
	return next_frag;
}

size_t net_buf_linearize(void *dst, size_t dst_len, struct net_buf *src,
			 size_t offset, size_t len)
{
  40bbec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40bbf0:	910003fd 	mov	x29, sp
  40bbf4:	a90153f3 	stp	x19, x20, [sp, #16]
  40bbf8:	aa0103f4 	mov	x20, x1
  40bbfc:	aa0203f3 	mov	x19, x2
  40bc00:	f9001bf7 	str	x23, [sp, #48]
  40bc04:	aa0003f7 	mov	x23, x0
  40bc08:	a9025bf5 	stp	x21, x22, [sp, #32]
	len = MIN(len, dst_len);

	frag = src;

	/* find the right fragment to start copying from */
	while (frag && offset >= frag->len) {
  40bc0c:	b4000433 	cbz	x19, 40bc90 <net_buf_linearize+0xa4>
  40bc10:	79404260 	ldrh	w0, [x19, #32]
  40bc14:	eb03001f 	cmp	x0, x3
  40bc18:	540001a9 	b.ls	40bc4c <net_buf_linearize+0x60>  // b.plast
	len = MIN(len, dst_len);
  40bc1c:	eb04029f 	cmp	x20, x4
  40bc20:	d2800016 	mov	x22, #0x0                   	// #0
  40bc24:	9a849294 	csel	x20, x20, x4, ls  // ls = plast
		frag = frag->frags;
	}

	/* traverse the fragment chain until len bytes are copied */
	copied = 0;
	while (frag && len > 0) {
  40bc28:	f100027f 	cmp	x19, #0x0
  40bc2c:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
  40bc30:	54000141 	b.ne	40bc58 <net_buf_linearize+0x6c>  // b.any
		/* after the first iteration, this value will be 0 */
		offset = 0;
	}

	return copied;
}
  40bc34:	aa1603e0 	mov	x0, x22
  40bc38:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bc3c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40bc40:	f9401bf7 	ldr	x23, [sp, #48]
  40bc44:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40bc48:	d65f03c0 	ret
		offset -= frag->len;
  40bc4c:	cb000063 	sub	x3, x3, x0
		frag = frag->frags;
  40bc50:	f9400673 	ldr	x19, [x19, #8]
  40bc54:	17ffffee 	b	40bc0c <net_buf_linearize+0x20>
		to_copy = MIN(len, frag->len - offset);
  40bc58:	79404275 	ldrh	w21, [x19, #32]
  40bc5c:	8b1602e0 	add	x0, x23, x22
		memcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);
  40bc60:	f9400e61 	ldr	x1, [x19, #24]
		to_copy = MIN(len, frag->len - offset);
  40bc64:	cb0302b5 	sub	x21, x21, x3
  40bc68:	eb1402bf 	cmp	x21, x20
  40bc6c:	9a9492b5 	csel	x21, x21, x20, ls  // ls = plast
  40bc70:	8b030021 	add	x1, x1, x3
  40bc74:	aa1503e2 	mov	x2, x21
		copied += to_copy;
  40bc78:	8b1502d6 	add	x22, x22, x21
  40bc7c:	97ffd5ad 	bl	401330 <memcpy@plt>
		len -= to_copy;
  40bc80:	cb150294 	sub	x20, x20, x21
		offset = 0;
  40bc84:	d2800003 	mov	x3, #0x0                   	// #0
		frag = frag->frags;
  40bc88:	f9400673 	ldr	x19, [x19, #8]
		offset = 0;
  40bc8c:	17ffffe7 	b	40bc28 <net_buf_linearize+0x3c>
  40bc90:	d2800016 	mov	x22, #0x0                   	// #0
	return copied;
  40bc94:	17ffffe8 	b	40bc34 <net_buf_linearize+0x48>

000000000040bc98 <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
  40bc98:	f9400001 	ldr	x1, [x0]
  40bc9c:	f9400800 	ldr	x0, [x0, #16]
}
  40bca0:	cb000020 	sub	x0, x1, x0
  40bca4:	d65f03c0 	ret

000000000040bca8 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
  40bca8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40bcac:	910003fd 	mov	x29, sp
  40bcb0:	a90153f3 	stp	x19, x20, [sp, #16]
  40bcb4:	aa0003f3 	mov	x19, x0
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
  40bcb8:	79401414 	ldrh	w20, [x0, #10]
  40bcbc:	97fffff7 	bl	40bc98 <net_buf_simple_headroom>
  40bcc0:	79401261 	ldrh	w1, [x19, #8]
  40bcc4:	cb010294 	sub	x20, x20, x1
}
  40bcc8:	cb000280 	sub	x0, x20, x0
  40bccc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bcd0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40bcd4:	d65f03c0 	ret

000000000040bcd8 <net_buf_simple_add>:
{
  40bcd8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40bcdc:	910003fd 	mov	x29, sp
  40bce0:	a90153f3 	stp	x19, x20, [sp, #16]
  40bce4:	aa0103f4 	mov	x20, x1
  40bce8:	aa0003f3 	mov	x19, x0
  40bcec:	f90013f5 	str	x21, [sp, #32]
	return buf->data + buf->len;
  40bcf0:	79401001 	ldrh	w1, [x0, #8]
  40bcf4:	f9400015 	ldr	x21, [x0]
  40bcf8:	8b0102b5 	add	x21, x21, x1
	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
  40bcfc:	97ffffeb 	bl	40bca8 <net_buf_simple_tailroom>
  40bd00:	eb14001f 	cmp	x0, x20
  40bd04:	54000242 	b.cs	40bd4c <net_buf_simple_add+0x74>  // b.hs, b.nlast
  40bd08:	d0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40bd0c:	912eca73 	add	x19, x19, #0xbb2
  40bd10:	aa1303e2 	mov	x2, x19
  40bd14:	528007c3 	mov	w3, #0x3e                  	// #62
  40bd18:	d0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40bd1c:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40bd20:	912fb021 	add	x1, x1, #0xbec
  40bd24:	91178000 	add	x0, x0, #0x5e0
  40bd28:	97ffec40 	bl	406e28 <assert_print>
  40bd2c:	aa1303e0 	mov	x0, x19
  40bd30:	528007c1 	mov	w1, #0x3e                  	// #62
  40bd34:	97ffec67 	bl	406ed0 <assert_post_action>
  40bd38:	b0000060 	adrp	x0, 418000 <table.0+0x1d8>
  40bd3c:	aa1303e1 	mov	x1, x19
  40bd40:	91187800 	add	x0, x0, #0x61e
  40bd44:	528007c2 	mov	w2, #0x3e                  	// #62
  40bd48:	97fff654 	bl	409698 <posix_print_error_and_exit>
	buf->len += len;
  40bd4c:	79401260 	ldrh	w0, [x19, #8]
  40bd50:	0b140000 	add	w0, w0, w20
  40bd54:	79001260 	strh	w0, [x19, #8]
}
  40bd58:	aa1503e0 	mov	x0, x21
  40bd5c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bd60:	f94013f5 	ldr	x21, [sp, #32]
  40bd64:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40bd68:	d65f03c0 	ret

000000000040bd6c <net_buf_simple_add_mem>:
{
  40bd6c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40bd70:	910003fd 	mov	x29, sp
  40bd74:	a90153f3 	stp	x19, x20, [sp, #16]
  40bd78:	aa0103f4 	mov	x20, x1
  40bd7c:	aa0203f3 	mov	x19, x2
	return memcpy(net_buf_simple_add(buf, len), mem, len);
  40bd80:	aa0203e1 	mov	x1, x2
  40bd84:	97ffffd5 	bl	40bcd8 <net_buf_simple_add>
  40bd88:	aa1303e2 	mov	x2, x19
  40bd8c:	aa1403e1 	mov	x1, x20
}
  40bd90:	a94153f3 	ldp	x19, x20, [sp, #16]
  40bd94:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40bd98:	17ffd566 	b	401330 <memcpy@plt>

000000000040bd9c <can_tx_default_cb>:
	struct k_sem done;
	int status;
};

static void can_tx_default_cb(const struct device *dev, int error, void *user_data)
{
  40bd9c:	aa0203e0 	mov	x0, x2
	struct can_tx_default_cb_ctx *ctx = user_data;

	ctx->status = error;
  40bda0:	b9002841 	str	w1, [x2, #40]
	z_impl_k_sem_give(sem);
  40bda4:	14001dd5 	b	4134f8 <z_impl_k_sem_give>

000000000040bda8 <z_impl_can_send>:
}

int z_impl_can_send(const struct device *dev, const struct can_frame *frame,
		    k_timeout_t timeout, can_tx_callback_t callback,
		    void *user_data)
{
  40bda8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40bdac:	d0000125 	adrp	x5, 431000 <__FRAME_END__+0x10804>
  40bdb0:	910003fd 	mov	x29, sp
  40bdb4:	f9475ca5 	ldr	x5, [x5, #3768]
  40bdb8:	a90153f3 	stp	x19, x20, [sp, #16]
  40bdbc:	d0000133 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  40bdc0:	a9025bf5 	stp	x21, x22, [sp, #32]
  40bdc4:	a90363f7 	stp	x23, x24, [sp, #48]
  40bdc8:	f94000a6 	ldr	x6, [x5]
  40bdcc:	f9003fe6 	str	x6, [sp, #120]
  40bdd0:	d2800006 	mov	x6, #0x0                   	// #0
	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
  40bdd4:	f9400818 	ldr	x24, [x0, #16]

	if (callback == NULL) {
  40bdd8:	b5000423 	cbnz	x3, 40be5c <z_impl_can_send+0xb4>
  40bddc:	aa0003f4 	mov	x20, x0
  40bde0:	aa0103f6 	mov	x22, x1
  40bde4:	aa0203f7 	mov	x23, x2
	return z_impl_k_sem_init(sem, initial_count, limit);
  40bde8:	910123f5 	add	x21, sp, #0x48
  40bdec:	52800022 	mov	w2, #0x1                   	// #1
  40bdf0:	52800001 	mov	w1, #0x0                   	// #0
  40bdf4:	aa1503e0 	mov	x0, x21
  40bdf8:	94001db5 	bl	4134cc <z_impl_k_sem_init>
		struct can_tx_default_cb_ctx ctx;
		int err;

		k_sem_init(&ctx.done, 0, 1);

		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
  40bdfc:	f9401705 	ldr	x5, [x24, #40]
  40be00:	90000003 	adrp	x3, 40b000 <z_ztest_testargs_contains+0x14>
  40be04:	aa1503e4 	mov	x4, x21
  40be08:	91367063 	add	x3, x3, #0xd9c
  40be0c:	aa1703e2 	mov	x2, x23
  40be10:	aa1603e1 	mov	x1, x22
  40be14:	aa1403e0 	mov	x0, x20
  40be18:	d63f00a0 	blr	x5
		if (err != 0) {
  40be1c:	350000a0 	cbnz	w0, 40be30 <z_impl_can_send+0x88>
	return z_impl_k_sem_take(sem, timeout);
  40be20:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40be24:	aa1503e0 	mov	x0, x21
  40be28:	94001deb 	bl	4135d4 <z_impl_k_sem_take>
			return err;
		}

		k_sem_take(&ctx.done, K_FOREVER);

		return ctx.status;
  40be2c:	b94073e0 	ldr	w0, [sp, #112]
	}

	return api->send(dev, frame, timeout, callback, user_data);
}
  40be30:	f9475e73 	ldr	x19, [x19, #3768]
  40be34:	f9403fe1 	ldr	x1, [sp, #120]
  40be38:	f9400262 	ldr	x2, [x19]
  40be3c:	eb020021 	subs	x1, x1, x2
  40be40:	d2800002 	mov	x2, #0x0                   	// #0
  40be44:	54000181 	b.ne	40be74 <z_impl_can_send+0xcc>  // b.any
  40be48:	a94153f3 	ldp	x19, x20, [sp, #16]
  40be4c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40be50:	a94363f7 	ldp	x23, x24, [sp, #48]
  40be54:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40be58:	d65f03c0 	ret
	return api->send(dev, frame, timeout, callback, user_data);
  40be5c:	f9475e73 	ldr	x19, [x19, #3768]
  40be60:	f9403fe5 	ldr	x5, [sp, #120]
  40be64:	f9400266 	ldr	x6, [x19]
  40be68:	eb0600a5 	subs	x5, x5, x6
  40be6c:	d2800006 	mov	x6, #0x0                   	// #0
  40be70:	54000040 	b.eq	40be78 <z_impl_can_send+0xd0>  // b.none
}
  40be74:	97ffd5ab 	bl	401520 <__stack_chk_fail@plt>
  40be78:	a94153f3 	ldp	x19, x20, [sp, #16]
  40be7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	return api->send(dev, frame, timeout, callback, user_data);
  40be80:	f9401705 	ldr	x5, [x24, #40]
}
  40be84:	a94363f7 	ldp	x23, x24, [sp, #48]
	return api->send(dev, frame, timeout, callback, user_data);
  40be88:	aa0503f0 	mov	x16, x5
}
  40be8c:	a8c87bfd 	ldp	x29, x30, [sp], #128
	return api->send(dev, frame, timeout, callback, user_data);
  40be90:	d61f0200 	br	x16

000000000040be94 <can_loopback_get_capabilities>:

static int can_loopback_get_capabilities(const struct device *dev, can_mode_t *cap)
{
	ARG_UNUSED(dev);

	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK;
  40be94:	52800020 	mov	w0, #0x1                   	// #1
  40be98:	b9000020 	str	w0, [x1]
#if CONFIG_CAN_FD_MODE
	*cap |= CAN_MODE_FD;
#endif /* CONFIG_CAN_FD_MODE */

	return 0;
}
  40be9c:	52800000 	mov	w0, #0x0                   	// #0
  40bea0:	d65f03c0 	ret

000000000040bea4 <can_loopback_start>:

static int can_loopback_start(const struct device *dev)
{
	struct can_loopback_data *data = dev->data;
  40bea4:	f9401000 	ldr	x0, [x0, #32]

	if (data->started) {
  40bea8:	39552001 	ldrb	w1, [x0, #1352]
  40beac:	350000a1 	cbnz	w1, 40bec0 <can_loopback_start+0x1c>
		return -EALREADY;
	}

	data->started = true;
  40beb0:	52800021 	mov	w1, #0x1                   	// #1
  40beb4:	39152001 	strb	w1, [x0, #1352]

	return 0;
  40beb8:	52800000 	mov	w0, #0x0                   	// #0
}
  40bebc:	d65f03c0 	ret
		return -EALREADY;
  40bec0:	12800e20 	mov	w0, #0xffffff8e            	// #-114
  40bec4:	17fffffe 	b	40bebc <can_loopback_start+0x18>

000000000040bec8 <can_loopback_set_timing>:
{
	struct can_loopback_data *data = dev->data;

	ARG_UNUSED(timing);

	if (data->started) {
  40bec8:	f9401000 	ldr	x0, [x0, #32]
  40becc:	39552000 	ldrb	w0, [x0, #1352]
		return -EBUSY;
  40bed0:	7100001f 	cmp	w0, #0x0
	}

	return 0;
}
  40bed4:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  40bed8:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40bedc:	d65f03c0 	ret

000000000040bee0 <can_loopback_get_state>:
static int can_loopback_get_state(const struct device *dev, enum can_state *state,
				  struct can_bus_err_cnt *err_cnt)
{
	struct can_loopback_data *data = dev->data;

	if (state != NULL) {
  40bee0:	b40000e1 	cbz	x1, 40befc <can_loopback_get_state+0x1c>
		if (data->started) {
  40bee4:	f9401000 	ldr	x0, [x0, #32]
  40bee8:	39552000 	ldrb	w0, [x0, #1352]
			*state = CAN_STATE_ERROR_ACTIVE;
  40beec:	7100001f 	cmp	w0, #0x0
  40bef0:	52800080 	mov	w0, #0x4                   	// #4
  40bef4:	1a8013e0 	csel	w0, wzr, w0, ne  // ne = any
  40bef8:	b9000020 	str	w0, [x1]
		} else {
			*state = CAN_STATE_STOPPED;
		}
	}

	if (err_cnt) {
  40befc:	b4000042 	cbz	x2, 40bf04 <can_loopback_get_state+0x24>
		err_cnt->tx_err_cnt = 0;
  40bf00:	7900005f 	strh	wzr, [x2]
		err_cnt->rx_err_cnt = 0;
	}

	return 0;
}
  40bf04:	52800000 	mov	w0, #0x0                   	// #0
  40bf08:	d65f03c0 	ret

000000000040bf0c <can_loopback_set_state_change_callback>:
						   void *user_data)
{
	ARG_UNUSED(dev);
	ARG_UNUSED(cb);
	ARG_UNUSED(user_data);
}
  40bf0c:	d65f03c0 	ret

000000000040bf10 <can_loopback_get_core_clock>:

static int can_loopback_get_core_clock(const struct device *dev, uint32_t *rate)
{
	/* Return 16MHz as an realistic value for the testcases */
	*rate = 16000000;
  40bf10:	52848000 	mov	w0, #0x2400                	// #9216
  40bf14:	72a01e80 	movk	w0, #0xf4, lsl #16
  40bf18:	b9000020 	str	w0, [x1]
	return 0;
}
  40bf1c:	52800000 	mov	w0, #0x0                   	// #0
  40bf20:	d65f03c0 	ret

000000000040bf24 <can_loopback_get_max_filters>:
static int can_loopback_get_max_filters(const struct device *dev, bool ide)
{
	ARG_UNUSED(ide);

	return CONFIG_CAN_MAX_FILTER;
}
  40bf24:	52800200 	mov	w0, #0x10                  	// #16
  40bf28:	d65f03c0 	ret

000000000040bf2c <can_loopback_stop>:
	struct can_loopback_data *data = dev->data;
  40bf2c:	f9401000 	ldr	x0, [x0, #32]
	if (!data->started) {
  40bf30:	39552001 	ldrb	w1, [x0, #1352]
  40bf34:	34000121 	cbz	w1, 40bf58 <can_loopback_stop+0x2c>
{
  40bf38:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40bf3c:	910003fd 	mov	x29, sp
	data->started = false;
  40bf40:	3915201f 	strb	wzr, [x0, #1352]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MSGQ_PURGE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_msgq_purge(msgq);
  40bf44:	91088000 	add	x0, x0, #0x220
  40bf48:	94001b00 	bl	412b48 <z_impl_k_msgq_purge>
	return 0;
  40bf4c:	52800000 	mov	w0, #0x0                   	// #0
}
  40bf50:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40bf54:	d65f03c0 	ret
		return -EALREADY;
  40bf58:	12800e20 	mov	w0, #0xffffff8e            	// #-114
}
  40bf5c:	d65f03c0 	ret

000000000040bf60 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40bf60:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40bf64:	d0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40bf68:	12001c42 	and	w2, w2, #0xff
  40bf6c:	910003fd 	mov	x29, sp
  40bf70:	f9475c00 	ldr	x0, [x0, #3768]
  40bf74:	3d8023e0 	str	q0, [sp, #128]
  40bf78:	3d8027e1 	str	q1, [sp, #144]
  40bf7c:	3d802be2 	str	q2, [sp, #160]
  40bf80:	3d802fe3 	str	q3, [sp, #176]
  40bf84:	3d8033e4 	str	q4, [sp, #192]
  40bf88:	3d8037e5 	str	q5, [sp, #208]
  40bf8c:	3d803be6 	str	q6, [sp, #224]
  40bf90:	3d803fe7 	str	q7, [sp, #240]
  40bf94:	f90087e7 	str	x7, [sp, #264]
  40bf98:	f9400003 	ldr	x3, [x0]
  40bf9c:	f9003fe3 	str	x3, [sp, #120]
  40bfa0:	d2800003 	mov	x3, #0x0                   	// #0
	va_start(ap, fmt);
  40bfa4:	910443e0 	add	x0, sp, #0x110
  40bfa8:	a90383e0 	stp	x0, x0, [sp, #56]
  40bfac:	910403e0 	add	x0, sp, #0x100
  40bfb0:	9100e3e3 	add	x3, sp, #0x38
  40bfb4:	f90027e0 	str	x0, [sp, #72]
  40bfb8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40bfbc:	b90053e0 	str	w0, [sp, #80]
  40bfc0:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40bfc4:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40bfc8:	910163e0 	add	x0, sp, #0x58
  40bfcc:	ad400460 	ldp	q0, q1, [x3]
  40bfd0:	ad000400 	stp	q0, q1, [x0]
  40bfd4:	ad400400 	ldp	q0, q1, [x0]
  40bfd8:	910043e7 	add	x7, sp, #0x10
  40bfdc:	52800000 	mov	w0, #0x0                   	// #0
  40bfe0:	52800005 	mov	w5, #0x0                   	// #0
  40bfe4:	d2800004 	mov	x4, #0x0                   	// #0
  40bfe8:	d2800003 	mov	x3, #0x0                   	// #0
  40bfec:	ad0004e0 	stp	q0, q1, [x7]
  40bff0:	97ffed6e 	bl	4075a8 <z_impl_z_log_msg_runtime_vcreate>
}
  40bff4:	d0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40bff8:	f9475c00 	ldr	x0, [x0, #3768]
  40bffc:	f9403fe2 	ldr	x2, [sp, #120]
  40c000:	f9400001 	ldr	x1, [x0]
  40c004:	eb010042 	subs	x2, x2, x1
  40c008:	d2800001 	mov	x1, #0x0                   	// #0
  40c00c:	54000040 	b.eq	40c014 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40c010:	97ffd544 	bl	401520 <__stack_chk_fail@plt>
  40c014:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40c018:	d65f03c0 	ret

000000000040c01c <can_loopback_send>:
{
  40c01c:	d10183ff 	sub	sp, sp, #0x60
  40c020:	b0000125 	adrp	x5, 431000 <__FRAME_END__+0x10804>
  40c024:	a9017bfd 	stp	x29, x30, [sp, #16]
  40c028:	910043fd 	add	x29, sp, #0x10
  40c02c:	f9475ca5 	ldr	x5, [x5, #3768]
  40c030:	f90013f3 	str	x19, [sp, #32]
  40c034:	f94000a6 	ldr	x6, [x5]
  40c038:	f9002fe6 	str	x6, [sp, #88]
  40c03c:	d2800006 	mov	x6, #0x0                   	// #0
	struct can_loopback_data *data = dev->data;
  40c040:	f9401000 	ldr	x0, [x0, #32]
	__ASSERT_NO_MSG(callback != NULL);
  40c044:	b5000243 	cbnz	x3, 40c08c <can_loopback_send+0x70>
  40c048:	b0000073 	adrp	x19, 419000 <__func__.2+0xa80>
  40c04c:	9130aa73 	add	x19, x19, #0xc2a
  40c050:	aa1303e2 	mov	x2, x19
  40c054:	52800d83 	mov	w3, #0x6c                  	// #108
  40c058:	b0000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40c05c:	90000060 	adrp	x0, 418000 <table.0+0x1d8>
  40c060:	91316021 	add	x1, x1, #0xc58
  40c064:	91178000 	add	x0, x0, #0x5e0
  40c068:	97ffeb70 	bl	406e28 <assert_print>
  40c06c:	aa1303e0 	mov	x0, x19
  40c070:	52800d81 	mov	w1, #0x6c                  	// #108
  40c074:	97ffeb97 	bl	406ed0 <assert_post_action>
  40c078:	90000060 	adrp	x0, 418000 <table.0+0x1d8>
  40c07c:	aa1303e1 	mov	x1, x19
  40c080:	91187800 	add	x0, x0, #0x61e
  40c084:	52800d82 	mov	w2, #0x6c                  	// #108
  40c088:	97fff584 	bl	409698 <posix_print_error_and_exit>
	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0) {
  40c08c:	39401425 	ldrb	w5, [x1, #5]
  40c090:	39401427 	ldrb	w7, [x1, #5]
  40c094:	f27e14bf 	tst	x5, #0xfc
  40c098:	54000280 	b.eq	40c0e8 <can_loopback_send+0xcc>  // b.none
		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
  40c09c:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40c0a0:	52800000 	mov	w0, #0x0                   	// #0
  40c0a4:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40c0a8:	52800005 	mov	w5, #0x0                   	// #0
  40c0ac:	f9473421 	ldr	x1, [x1, #3688]
  40c0b0:	9131c0c6 	add	x6, x6, #0xc70
  40c0b4:	d2800004 	mov	x4, #0x0                   	// #0
  40c0b8:	d2800003 	mov	x3, #0x0                   	// #0
  40c0bc:	52800022 	mov	w2, #0x1                   	// #1
  40c0c0:	97ffffa8 	bl	40bf60 <z_log_msg_runtime_create.constprop.0>
		return -ENOTSUP;
  40c0c4:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40c0c8:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40c0cc:	f9475c21 	ldr	x1, [x1, #3768]
  40c0d0:	f9402fe3 	ldr	x3, [sp, #88]
  40c0d4:	f9400022 	ldr	x2, [x1]
  40c0d8:	eb020063 	subs	x3, x3, x2
  40c0dc:	d2800002 	mov	x2, #0x0                   	// #0
  40c0e0:	54000420 	b.eq	40c164 <can_loopback_send+0x148>  // b.none
  40c0e4:	97ffd50f 	bl	401520 <__stack_chk_fail@plt>
	if (frame->dlc > max_dlc) {
  40c0e8:	39401027 	ldrb	w7, [x1, #4]
  40c0ec:	710020ff 	cmp	w7, #0x8
  40c0f0:	540001e9 	b.ls	40c12c <can_loopback_send+0x110>  // b.plast
		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, max_dlc);
  40c0f4:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40c0f8:	52800100 	mov	w0, #0x8                   	// #8
  40c0fc:	b90003e0 	str	w0, [sp]
  40c100:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40c104:	f9473421 	ldr	x1, [x1, #3688]
  40c108:	52800000 	mov	w0, #0x0                   	// #0
  40c10c:	91324cc6 	add	x6, x6, #0xc93
  40c110:	52800005 	mov	w5, #0x0                   	// #0
  40c114:	d2800004 	mov	x4, #0x0                   	// #0
  40c118:	d2800003 	mov	x3, #0x0                   	// #0
  40c11c:	52800022 	mov	w2, #0x1                   	// #1
  40c120:	97ffff90 	bl	40bf60 <z_log_msg_runtime_create.constprop.0>
		return -EINVAL;
  40c124:	128002a0 	mov	w0, #0xffffffea            	// #-22
  40c128:	17ffffe8 	b	40c0c8 <can_loopback_send+0xac>
	if (!data->started) {
  40c12c:	39552005 	ldrb	w5, [x0, #1352]
  40c130:	34000165 	cbz	w5, 40c15c <can_loopback_send+0x140>
	loopback_frame.frame = *frame;
  40c134:	a9401c26 	ldp	x6, x7, [x1]
  40c138:	a9039fe6 	stp	x6, x7, [sp, #56]
	loopback_frame.cb_arg = user_data;
  40c13c:	a90493e3 	stp	x3, x4, [sp, #72]
	return z_impl_k_msgq_put(msgq, data, timeout);
  40c140:	9100e3e1 	add	x1, sp, #0x38
  40c144:	91088000 	add	x0, x0, #0x220
  40c148:	9400192d 	bl	4125fc <z_impl_k_msgq_put>
		return -EAGAIN;
  40c14c:	7100001f 	cmp	w0, #0x0
  40c150:	12800140 	mov	w0, #0xfffffff5            	// #-11
  40c154:	1a80a3e0 	csel	w0, wzr, w0, ge  // ge = tcont
  40c158:	17ffffdc 	b	40c0c8 <can_loopback_send+0xac>
		return -ENETDOWN;
  40c15c:	12800c60 	mov	w0, #0xffffff9c            	// #-100
  40c160:	17ffffda 	b	40c0c8 <can_loopback_send+0xac>
}
  40c164:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40c168:	f94013f3 	ldr	x19, [sp, #32]
  40c16c:	910183ff 	add	sp, sp, #0x60
  40c170:	d65f03c0 	ret

000000000040c174 <can_loopback_set_mode>:
	struct can_loopback_data *data = dev->data;
  40c174:	f9401000 	ldr	x0, [x0, #32]
{
  40c178:	2a0103e7 	mov	w7, w1
	if (data->started) {
  40c17c:	39552001 	ldrb	w1, [x0, #1352]
  40c180:	350002c1 	cbnz	w1, 40c1d8 <can_loopback_set_mode+0x64>
	if ((mode & ~(CAN_MODE_LOOPBACK)) != 0) {
  40c184:	f27f78ff 	tst	x7, #0xfffffffe
  40c188:	54000200 	b.eq	40c1c8 <can_loopback_set_mode+0x54>  // b.none
{
  40c18c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40c190:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40c194:	52800005 	mov	w5, #0x0                   	// #0
{
  40c198:	910003fd 	mov	x29, sp
		LOG_ERR("unsupported mode: 0x%08x", mode);
  40c19c:	f9473421 	ldr	x1, [x1, #3688]
  40c1a0:	d2800004 	mov	x4, #0x0                   	// #0
  40c1a4:	d2800003 	mov	x3, #0x0                   	// #0
  40c1a8:	52800022 	mov	w2, #0x1                   	// #1
  40c1ac:	52800000 	mov	w0, #0x0                   	// #0
  40c1b0:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40c1b4:	9132c8c6 	add	x6, x6, #0xcb2
  40c1b8:	97ffff6a 	bl	40bf60 <z_log_msg_runtime_create.constprop.0>
  40c1bc:	12800bc0 	mov	w0, #0xffffffa1            	// #-95
}
  40c1c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40c1c4:	d65f03c0 	ret
	data->loopback = (mode & CAN_MODE_LOOPBACK) != 0;
  40c1c8:	120000e7 	and	w7, w7, #0x1
  40c1cc:	39152407 	strb	w7, [x0, #1353]
	return 0;
  40c1d0:	52800000 	mov	w0, #0x0                   	// #0
  40c1d4:	d65f03c0 	ret
		return -EBUSY;
  40c1d8:	128001e0 	mov	w0, #0xfffffff0            	// #-16
}
  40c1dc:	d65f03c0 	ret

000000000040c1e0 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
  40c1e0:	14001b45 	b	412ef4 <z_impl_k_mutex_unlock>

000000000040c1e4 <can_loopback_remove_rx_filter>:
{
  40c1e4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40c1e8:	910003fd 	mov	x29, sp
  40c1ec:	a90153f3 	stp	x19, x20, [sp, #16]
  40c1f0:	2a0103f3 	mov	w19, w1
  40c1f4:	f90013f5 	str	x21, [sp, #32]
	struct can_loopback_data *data = dev->data;
  40c1f8:	f9401015 	ldr	x21, [x0, #32]
	if (filter_id >= ARRAY_SIZE(data->filters)) {
  40c1fc:	71003c3f 	cmp	w1, #0xf
  40c200:	540001e9 	b.ls	40c23c <can_loopback_remove_rx_filter+0x58>  // b.plast
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40c204:	2a0103e7 	mov	w7, w1
  40c208:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
}
  40c20c:	a94153f3 	ldp	x19, x20, [sp, #16]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40c210:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
}
  40c214:	f94013f5 	ldr	x21, [sp, #32]
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40c218:	91332cc6 	add	x6, x6, #0xccb
}
  40c21c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		LOG_ERR("filter ID %d out-of-bounds", filter_id);
  40c220:	52800005 	mov	w5, #0x0                   	// #0
  40c224:	f9473421 	ldr	x1, [x1, #3688]
  40c228:	d2800004 	mov	x4, #0x0                   	// #0
  40c22c:	d2800003 	mov	x3, #0x0                   	// #0
  40c230:	52800022 	mov	w2, #0x1                   	// #1
  40c234:	52800000 	mov	w0, #0x0                   	// #0
  40c238:	17ffff4a 	b	40bf60 <z_log_msg_runtime_create.constprop.0>
	k_mutex_lock(&data->mtx, K_FOREVER);
  40c23c:	910802b4 	add	x20, x21, #0x200
	data->filters[filter_id].rx_cb = NULL;
  40c240:	937b7e73 	sbfiz	x19, x19, #5, #32
	return z_impl_k_mutex_lock(mutex, timeout);
  40c244:	aa1403e0 	mov	x0, x20
  40c248:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40c24c:	94001a7e 	bl	412c44 <z_impl_k_mutex_lock>
	k_mutex_unlock(&data->mtx);
  40c250:	aa1403e0 	mov	x0, x20
	data->filters[filter_id].rx_cb = NULL;
  40c254:	f8336abf 	str	xzr, [x21, x19]
}
  40c258:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c25c:	f94013f5 	ldr	x21, [sp, #32]
  40c260:	a8c37bfd 	ldp	x29, x30, [sp], #48
	k_mutex_unlock(&data->mtx);
  40c264:	17ffffdf 	b	40c1e0 <k_mutex_unlock.isra.0>

000000000040c268 <can_loopback_init>:
	},
#endif /* CONFIG_CAN_FD_MODE */
};

static int can_loopback_init(const struct device *dev)
{
  40c268:	d10103ff 	sub	sp, sp, #0x40
  40c26c:	a9017bfd 	stp	x29, x30, [sp, #16]
  40c270:	910043fd 	add	x29, sp, #0x10
  40c274:	a90253f3 	stp	x19, x20, [sp, #32]
  40c278:	aa0003f4 	mov	x20, x0
	struct can_loopback_data *data = dev->data;
  40c27c:	f9401013 	ldr	x19, [x0, #32]
{
  40c280:	f9001bf5 	str	x21, [sp, #48]
	k_tid_t tx_tid;

	k_mutex_init(&data->mtx);
  40c284:	91080275 	add	x21, x19, #0x200
	return z_impl_k_mutex_init(mutex);
  40c288:	aa1503e0 	mov	x0, x21
  40c28c:	94001a69 	bl	412c30 <z_impl_k_mutex_init>

	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40c290:	aa1303e0 	mov	x0, x19
		data->filters[i].rx_cb = NULL;
  40c294:	f802041f 	str	xzr, [x0], #32
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40c298:	eb15001f 	cmp	x0, x21
  40c29c:	54ffffc1 	b.ne	40c294 <can_loopback_init+0x2c>  // b.any
	}

	k_msgq_init(&data->tx_msgq, data->msgq_buffer, sizeof(struct can_loopback_frame),
  40c2a0:	910a2261 	add	x1, x19, #0x288
  40c2a4:	91088260 	add	x0, x19, #0x220
  40c2a8:	52800203 	mov	w3, #0x10                  	// #16
  40c2ac:	d2800402 	mov	x2, #0x20                  	// #32
  40c2b0:	940018c6 	bl	4125c8 <k_msgq_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  40c2b4:	b90003ff 	str	wzr, [sp]
  40c2b8:	91154261 	add	x1, x19, #0x550
  40c2bc:	f90007ff 	str	xzr, [sp, #8]
  40c2c0:	aa1403e4 	mov	x4, x20
  40c2c4:	91122260 	add	x0, x19, #0x488
  40c2c8:	52800047 	mov	w7, #0x2                   	// #2
  40c2cc:	d2800006 	mov	x6, #0x0                   	// #0
  40c2d0:	d2800005 	mov	x5, #0x0                   	// #0
  40c2d4:	90000003 	adrp	x3, 40c000 <z_log_msg_runtime_create.constprop.0+0xa0>
  40c2d8:	d2802002 	mov	x2, #0x100                 	// #256
  40c2dc:	910d5063 	add	x3, x3, #0x354
  40c2e0:	940017ed 	bl	412294 <z_impl_k_thread_create>
	tx_tid = k_thread_create(&data->tx_thread_data, data->tx_thread_stack,
				 K_KERNEL_STACK_SIZEOF(data->tx_thread_stack),
				 tx_thread, (void *)dev, NULL, NULL,
				 CONFIG_CAN_LOOPBACK_TX_THREAD_PRIORITY,
				 0, K_NO_WAIT);
	if (!tx_tid) {
  40c2e4:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40c2e8:	b50001e0 	cbnz	x0, 40c324 <can_loopback_init+0xbc>
		LOG_ERR("ERROR spawning tx thread");
  40c2ec:	f9473421 	ldr	x1, [x1, #3688]
  40c2f0:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40c2f4:	52800005 	mov	w5, #0x0                   	// #0
  40c2f8:	913398c6 	add	x6, x6, #0xce6
  40c2fc:	d2800004 	mov	x4, #0x0                   	// #0
  40c300:	d2800003 	mov	x3, #0x0                   	// #0
  40c304:	52800022 	mov	w2, #0x1                   	// #1
  40c308:	97ffff16 	bl	40bf60 <z_log_msg_runtime_create.constprop.0>
		return -1;
  40c30c:	12800000 	mov	w0, #0xffffffff            	// #-1
	}

	LOG_INF("Init of %s done", dev->name);

	return 0;
}
  40c310:	a9417bfd 	ldp	x29, x30, [sp, #16]
  40c314:	a94253f3 	ldp	x19, x20, [sp, #32]
  40c318:	f9401bf5 	ldr	x21, [sp, #48]
  40c31c:	910103ff 	add	sp, sp, #0x40
  40c320:	d65f03c0 	ret
	LOG_INF("Init of %s done", dev->name);
  40c324:	f9473421 	ldr	x1, [x1, #3688]
  40c328:	52800000 	mov	w0, #0x0                   	// #0
  40c32c:	f9400287 	ldr	x7, [x20]
  40c330:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40c334:	52800005 	mov	w5, #0x0                   	// #0
  40c338:	9133fcc6 	add	x6, x6, #0xcff
  40c33c:	d2800004 	mov	x4, #0x0                   	// #0
  40c340:	d2800003 	mov	x3, #0x0                   	// #0
  40c344:	52800062 	mov	w2, #0x3                   	// #3
  40c348:	97ffff06 	bl	40bf60 <z_log_msg_runtime_create.constprop.0>
	return 0;
  40c34c:	52800000 	mov	w0, #0x0                   	// #0
  40c350:	17fffff0 	b	40c310 <can_loopback_init+0xa8>

000000000040c354 <tx_thread>:
{
  40c354:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  40c358:	910003fd 	mov	x29, sp
  40c35c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c360:	aa0003f5 	mov	x21, x0
  40c364:	b0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40c368:	a90153f3 	stp	x19, x20, [sp, #16]
  40c36c:	a90363f7 	stp	x23, x24, [sp, #48]
	return z_impl_k_msgq_get(msgq, data, timeout);
  40c370:	9101a3f7 	add	x23, sp, #0x68
  40c374:	a9046bf9 	stp	x25, x26, [sp, #64]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40c378:	910163f9 	add	x25, sp, #0x58
{
  40c37c:	f9475c00 	ldr	x0, [x0, #3768]
	struct can_loopback_data *data = dev->data;
  40c380:	f94012b4 	ldr	x20, [x21, #32]
{
  40c384:	f9400001 	ldr	x1, [x0]
  40c388:	f90047e1 	str	x1, [sp, #136]
  40c38c:	d2800001 	mov	x1, #0x0                   	// #0
		ret = k_msgq_get(&data->tx_msgq, &frame, K_FOREVER);
  40c390:	91088298 	add	x24, x20, #0x220
  40c394:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  40c398:	aa1703e1 	mov	x1, x23
  40c39c:	aa1803e0 	mov	x0, x24
  40c3a0:	9400193d 	bl	412894 <z_impl_k_msgq_get>
		if (ret < 0) {
  40c3a4:	37ffff80 	tbnz	w0, #31, 40c394 <tx_thread+0x40>
		frame.cb(dev, 0, frame.cb_arg);
  40c3a8:	a9478be3 	ldp	x3, x2, [sp, #120]
  40c3ac:	aa1503e0 	mov	x0, x21
  40c3b0:	52800001 	mov	w1, #0x0                   	// #0
  40c3b4:	d63f0060 	blr	x3
		if (!data->loopback) {
  40c3b8:	39552680 	ldrb	w0, [x20, #1353]
  40c3bc:	34fffec0 	cbz	w0, 40c394 <tx_thread+0x40>
		k_mutex_lock(&data->mtx, K_FOREVER);
  40c3c0:	9108029a 	add	x26, x20, #0x200
	return z_impl_k_mutex_lock(mutex, timeout);
  40c3c4:	aa1403f3 	mov	x19, x20
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40c3c8:	52800016 	mov	w22, #0x0                   	// #0
  40c3cc:	aa1a03e0 	mov	x0, x26
  40c3d0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40c3d4:	94001a1c 	bl	412c44 <z_impl_k_mutex_lock>
			if (filter->rx_cb != NULL &&
  40c3d8:	f9400260 	ldr	x0, [x19]
  40c3dc:	b40000c0 	cbz	x0, 40c3f4 <tx_thread+0xa0>
 * @return true if the CAN frame matches the CAN filter, false otherwise
 */
static inline bool can_frame_matches_filter(const struct can_frame *frame,
					    const struct can_filter *filter)
{
	if ((frame->flags & CAN_FRAME_IDE) != 0 && (filter->flags & CAN_FILTER_IDE) == 0) {
  40c3e0:	3941b7e0 	ldrb	w0, [sp, #109]
  40c3e4:	39406261 	ldrb	w1, [x19, #24]
  40c3e8:	12000022 	and	w2, w1, #0x1
  40c3ec:	36000120 	tbz	w0, #0, 40c410 <tx_thread+0xbc>
  40c3f0:	35000122 	cbnz	w2, 40c414 <tx_thread+0xc0>
		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40c3f4:	110006d6 	add	w22, w22, #0x1
  40c3f8:	91008273 	add	x19, x19, #0x20
  40c3fc:	710042df 	cmp	w22, #0x10
  40c400:	54fffec1 	b.ne	40c3d8 <tx_thread+0x84>  // b.any
		k_mutex_unlock(&data->mtx);
  40c404:	aa1a03e0 	mov	x0, x26
  40c408:	97ffff76 	bl	40c1e0 <k_mutex_unlock.isra.0>
  40c40c:	17ffffe2 	b	40c394 <tx_thread+0x40>
		/* Extended (29-bit) ID frame, standard (11-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_IDE) == 0 && (filter->flags & CAN_FILTER_IDE) != 0) {
  40c410:	35ffff22 	cbnz	w2, 40c3f4 <tx_thread+0xa0>
		/* Standard (11-bit) ID frame, extended (29-bit) filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_RTR) == 0 && (filter->flags & CAN_FILTER_DATA) == 0) {
  40c414:	37080280 	tbnz	w0, #1, 40c464 <tx_thread+0x110>
  40c418:	3617fee1 	tbz	w1, #2, 40c3f4 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
		/* Remote transmission request (RTR) frame, non-RTR filter */
		return false;
	}

	if ((frame->flags & CAN_FRAME_FDF) != 0 && (filter->flags & CAN_FILTER_FDF) == 0) {
  40c41c:	121d0021 	and	w1, w1, #0x8
  40c420:	36100260 	tbz	w0, #2, 40c46c <tx_thread+0x118>
  40c424:	34fffe81 	cbz	w1, 40c3f4 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
		/* Classic frame, CAN-FD format filter */
		return false;
	}

	if ((frame->id ^ filter->id) & filter->mask) {
  40c428:	937b7ec0 	sbfiz	x0, x22, #5, #32
  40c42c:	8b000280 	add	x0, x20, x0
  40c430:	f94037e1 	ldr	x1, [sp, #104]
  40c434:	f9400800 	ldr	x0, [x0, #16]
  40c438:	4a010001 	eor	w1, w0, w1
  40c43c:	d360f000 	ubfx	x0, x0, #32, #29
  40c440:	6a00003f 	tst	w1, w0
  40c444:	54fffd81 	b.ne	40c3f4 <tx_thread+0xa0>  // b.any
	struct can_frame frame_tmp = *frame;
  40c448:	a94687e0 	ldp	x0, x1, [sp, #104]
  40c44c:	a90587e0 	stp	x0, x1, [sp, #88]
	filter->rx_cb(dev, &frame_tmp, filter->cb_arg);
  40c450:	a9400a63 	ldp	x3, x2, [x19]
  40c454:	aa1903e1 	mov	x1, x25
  40c458:	aa1503e0 	mov	x0, x21
  40c45c:	d63f0060 	blr	x3
}
  40c460:	17ffffe5 	b	40c3f4 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_RTR) != 0 && (filter->flags & CAN_FILTER_RTR) == 0) {
  40c464:	370ffdc1 	tbnz	w1, #1, 40c41c <tx_thread+0xc8>
  40c468:	17ffffe3 	b	40c3f4 <tx_thread+0xa0>
	if ((frame->flags & CAN_FRAME_FDF) == 0 && (filter->flags & CAN_FILTER_FDF) != 0) {
  40c46c:	34fffde1 	cbz	w1, 40c428 <tx_thread+0xd4>
  40c470:	17ffffe1 	b	40c3f4 <tx_thread+0xa0>

000000000040c474 <can_loopback_add_rx_filter>:
{
  40c474:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40c478:	910003fd 	mov	x29, sp
  40c47c:	a90153f3 	stp	x19, x20, [sp, #16]
  40c480:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c484:	a90363f7 	stp	x23, x24, [sp, #48]
  40c488:	f90023f9 	str	x25, [sp, #64]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA | CAN_FILTER_RTR)) != 0) {
  40c48c:	39402073 	ldrb	w19, [x3, #8]
  40c490:	39402067 	ldrb	w7, [x3, #8]
  40c494:	f27df273 	ands	x19, x19, #0xfffffffffffffff8
	struct can_loopback_data *data = dev->data;
  40c498:	f9401016 	ldr	x22, [x0, #32]
	if ((filter->flags & ~(CAN_FILTER_IDE | CAN_FILTER_DATA | CAN_FILTER_RTR)) != 0) {
  40c49c:	54000260 	b.eq	40c4e8 <can_loopback_add_rx_filter+0x74>  // b.none
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40c4a0:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
		return -ENOTSUP;
  40c4a4:	12800bd5 	mov	w21, #0xffffffa1            	// #-95
		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
  40c4a8:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40c4ac:	52800005 	mov	w5, #0x0                   	// #0
  40c4b0:	f9473421 	ldr	x1, [x1, #3688]
  40c4b4:	91343cc6 	add	x6, x6, #0xd0f
  40c4b8:	d2800004 	mov	x4, #0x0                   	// #0
  40c4bc:	d2800003 	mov	x3, #0x0                   	// #0
  40c4c0:	52800022 	mov	w2, #0x1                   	// #1
  40c4c4:	52800000 	mov	w0, #0x0                   	// #0
  40c4c8:	97fffea6 	bl	40bf60 <z_log_msg_runtime_create.constprop.0>
}
  40c4cc:	2a1503e0 	mov	w0, w21
  40c4d0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c4d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c4d8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c4dc:	f94023f9 	ldr	x25, [sp, #64]
  40c4e0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40c4e4:	d65f03c0 	ret
  40c4e8:	aa0103f9 	mov	x25, x1
  40c4ec:	aa0203f8 	mov	x24, x2
  40c4f0:	aa0303f4 	mov	x20, x3
	k_mutex_lock(&data->mtx, K_FOREVER);
  40c4f4:	910802d7 	add	x23, x22, #0x200
  40c4f8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
  40c4fc:	aa1703e0 	mov	x0, x23
  40c500:	940019d1 	bl	412c44 <z_impl_k_mutex_lock>
		if (filters[i].rx_cb == NULL) {
  40c504:	d37bea60 	lsl	x0, x19, #5
  40c508:	2a1303f5 	mov	w21, w19
  40c50c:	f8606ac0 	ldr	x0, [x22, x0]
  40c510:	b4000240 	cbz	x0, 40c558 <can_loopback_add_rx_filter+0xe4>
	for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
  40c514:	91000673 	add	x19, x19, #0x1
  40c518:	f100427f 	cmp	x19, #0x10
  40c51c:	54ffff41 	b.ne	40c504 <can_loopback_add_rx_filter+0x90>  // b.any
		LOG_ERR("No free filter left");
  40c520:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40c524:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40c528:	9134ccc6 	add	x6, x6, #0xd33
  40c52c:	52800005 	mov	w5, #0x0                   	// #0
  40c530:	f9473421 	ldr	x1, [x1, #3688]
  40c534:	d2800004 	mov	x4, #0x0                   	// #0
  40c538:	d2800003 	mov	x3, #0x0                   	// #0
  40c53c:	52800022 	mov	w2, #0x1                   	// #1
  40c540:	52800000 	mov	w0, #0x0                   	// #0
	return -ENOSPC;
  40c544:	12800375 	mov	w21, #0xffffffe4            	// #-28
		LOG_ERR("No free filter left");
  40c548:	97fffe86 	bl	40bf60 <z_log_msg_runtime_create.constprop.0>
		k_mutex_unlock(&data->mtx);
  40c54c:	aa1703e0 	mov	x0, x23
  40c550:	97ffff24 	bl	40c1e0 <k_mutex_unlock.isra.0>
		return filter_id;
  40c554:	17ffffde 	b	40c4cc <can_loopback_add_rx_filter+0x58>
	loopback_filter->rx_cb = cb;
  40c558:	937b7e61 	sbfiz	x1, x19, #5, #32
  40c55c:	8b0102c0 	add	x0, x22, x1
  40c560:	f8216ad9 	str	x25, [x22, x1]
	loopback_filter->cb_arg = cb_arg;
  40c564:	f9000418 	str	x24, [x0, #8]
	loopback_filter->filter = *filter;
  40c568:	f9400281 	ldr	x1, [x20]
  40c56c:	f9000801 	str	x1, [x0, #16]
  40c570:	b9400a81 	ldr	w1, [x20, #8]
  40c574:	b9001801 	str	w1, [x0, #24]
	k_mutex_unlock(&data->mtx);
  40c578:	aa1703e0 	mov	x0, x23
  40c57c:	97ffff19 	bl	40c1e0 <k_mutex_unlock.isra.0>
	return filter_id;
  40c580:	17ffffd3 	b	40c4cc <can_loopback_add_rx_filter+0x58>

000000000040c584 <posix_arch_console_init>:
		stdout_buff[0] = 0;
	}
}

static int posix_arch_console_init(void)
{
  40c584:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#ifdef CONFIG_PRINTK
	extern void __printk_hook_install(int (*fn)(int));
	__printk_hook_install(print_char);
  40c588:	90000000 	adrp	x0, 40c000 <z_log_msg_runtime_create.constprop.0+0xa0>
  40c58c:	91169000 	add	x0, x0, #0x5a4
{
  40c590:	910003fd 	mov	x29, sp
	__printk_hook_install(print_char);
  40c594:	97ffe444 	bl	4056a4 <__printk_hook_install>
#ifdef CONFIG_STDOUT_CONSOLE
	extern void __stdout_hook_install(int (*fn)(int));
	__stdout_hook_install(print_char);
#endif
	return 0;
}
  40c598:	52800000 	mov	w0, #0x0                   	// #0
  40c59c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40c5a0:	d65f03c0 	ret

000000000040c5a4 <print_char>:
{
  40c5a4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if ((c != '\n') && (c != '\r')) {
  40c5a8:	7100281f 	cmp	w0, #0xa
  40c5ac:	7a4d1804 	ccmp	w0, #0xd, #0x4, ne  // ne = any
{
  40c5b0:	910003fd 	mov	x29, sp
  40c5b4:	a90153f3 	stp	x19, x20, [sp, #16]
  40c5b8:	2a0003f3 	mov	w19, w0
  40c5bc:	90000154 	adrp	x20, 434000 <ztest_thread+0xb8>
  40c5c0:	f90013f5 	str	x21, [sp, #32]
	if ((c != '\n') && (c != '\r')) {
  40c5c4:	54000320 	b.eq	40c628 <print_char+0x84>  // b.none
		stdout_buff[n_pend++] = c;
  40c5c8:	b94e1682 	ldr	w2, [x20, #3604]
  40c5cc:	b0000140 	adrp	x0, 435000 <stdout_buff+0xc1>
  40c5d0:	9101a400 	add	x0, x0, #0x69
  40c5d4:	11000441 	add	w1, w2, #0x1
  40c5d8:	b90e1681 	str	w1, [x20, #3604]
  40c5dc:	3822c813 	strb	w19, [x0, w2, sxtw]
		stdout_buff[n_pend] = 0;
  40c5e0:	3821c81f 	strb	wzr, [x0, w1, sxtw]
	int printnow = 0;
  40c5e4:	52800000 	mov	w0, #0x0                   	// #0
	if (n_pend >= _STDOUT_BUF_SIZE - 1) {
  40c5e8:	b94e1681 	ldr	w1, [x20, #3604]
  40c5ec:	7103f83f 	cmp	w1, #0xfe
  40c5f0:	5400004c 	b.gt	40c5f8 <print_char+0x54>
	if (printnow) {
  40c5f4:	34000100 	cbz	w0, 40c614 <print_char+0x70>
		posix_print_trace("%s\n", stdout_buff);
  40c5f8:	b0000155 	adrp	x21, 435000 <stdout_buff+0xc1>
  40c5fc:	b0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40c600:	9101a6a1 	add	x1, x21, #0x69
  40c604:	9122e800 	add	x0, x0, #0x8ba
  40c608:	97fff48a 	bl	409830 <posix_print_trace>
		n_pend = 0;
  40c60c:	b90e169f 	str	wzr, [x20, #3604]
		stdout_buff[0] = 0;
  40c610:	3901a6bf 	strb	wzr, [x21, #105]
}
  40c614:	2a1303e0 	mov	w0, w19
  40c618:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c61c:	f94013f5 	ldr	x21, [sp, #32]
  40c620:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40c624:	d65f03c0 	ret
		printnow = 1;
  40c628:	52800020 	mov	w0, #0x1                   	// #1
  40c62c:	17ffffef 	b	40c5e8 <print_char+0x44>

000000000040c630 <entropy_native_posix_get_entropy>:
static unsigned int seed = 0x5678;

static int entropy_native_posix_get_entropy(const struct device *dev,
					    uint8_t *buffer,
					    uint16_t length)
{
  40c630:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40c634:	b0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40c638:	910003fd 	mov	x29, sp
  40c63c:	f9475c00 	ldr	x0, [x0, #3768]
  40c640:	a90153f3 	stp	x19, x20, [sp, #16]
  40c644:	aa0103f4 	mov	x20, x1
  40c648:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c64c:	12003c53 	and	w19, w2, #0xffff
		 * Note that only 1 thread (Zephyr thread or HW models), runs at
		 * a time, therefore there is no need to use random_r()
		 */
		long int value = random();

		size_t to_copy = MIN(length, sizeof(long int));
  40c650:	52800116 	mov	w22, #0x8                   	// #8
{
  40c654:	a90363f7 	stp	x23, x24, [sp, #48]
  40c658:	910103f7 	add	x23, sp, #0x40
  40c65c:	f9400001 	ldr	x1, [x0]
  40c660:	f90027e1 	str	x1, [sp, #72]
  40c664:	d2800001 	mov	x1, #0x0                   	// #0
	while (length) {
  40c668:	35000133 	cbnz	w19, 40c68c <entropy_native_posix_get_entropy+0x5c>
		buffer += to_copy;
		length -= to_copy;
	}

	return 0;
}
  40c66c:	b0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40c670:	f9475c00 	ldr	x0, [x0, #3768]
  40c674:	f94027e2 	ldr	x2, [sp, #72]
  40c678:	f9400001 	ldr	x1, [x0]
  40c67c:	eb010042 	subs	x2, x2, x1
  40c680:	d2800001 	mov	x1, #0x0                   	// #0
  40c684:	54000200 	b.eq	40c6c4 <entropy_native_posix_get_entropy+0x94>  // b.none
  40c688:	97ffd3a6 	bl	401520 <__stack_chk_fail@plt>
		long int value = random();
  40c68c:	97ffd389 	bl	4014b0 <random@plt>
  40c690:	f90023e0 	str	x0, [sp, #64]
		size_t to_copy = MIN(length, sizeof(long int));
  40c694:	7100227f 	cmp	w19, #0x8
  40c698:	aa1403e0 	mov	x0, x20
  40c69c:	1a969275 	csel	w21, w19, w22, ls  // ls = plast
  40c6a0:	aa1703e1 	mov	x1, x23
  40c6a4:	12003eb8 	and	w24, w21, #0xffff
  40c6a8:	92403eb5 	and	x21, x21, #0xffff
		length -= to_copy;
  40c6ac:	4b180273 	sub	w19, w19, w24
  40c6b0:	aa1503e2 	mov	x2, x21
  40c6b4:	12003e73 	and	w19, w19, #0xffff
		buffer += to_copy;
  40c6b8:	8b150294 	add	x20, x20, x21
  40c6bc:	97ffd31d 	bl	401330 <memcpy@plt>
		length -= to_copy;
  40c6c0:	17ffffea 	b	40c668 <entropy_native_posix_get_entropy+0x38>
}
  40c6c4:	52800000 	mov	w0, #0x0                   	// #0
  40c6c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c6cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c6d0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c6d4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40c6d8:	d65f03c0 	ret

000000000040c6dc <entropy_native_posix_get_entropy_isr>:

	/*
	 * entropy_native_posix_get_entropy() is also safe for ISRs
	 * and always produces data.
	 */
	return entropy_native_posix_get_entropy(dev, buf, len);
  40c6dc:	17ffffd5 	b	40c630 <entropy_native_posix_get_entropy>

000000000040c6e0 <entropy_native_posix_init>:
}

static int entropy_native_posix_init(const struct device *dev)
{
  40c6e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(dev);
	srandom(seed);
  40c6e4:	d0000120 	adrp	x0, 432000 <__dso_handle>
{
  40c6e8:	910003fd 	mov	x29, sp
	srandom(seed);
  40c6ec:	b94a4400 	ldr	w0, [x0, #2628]
  40c6f0:	97ffd3dc 	bl	401660 <srandom@plt>
	posix_print_warning("WARNING: "
  40c6f4:	b0000060 	adrp	x0, 419000 <__func__.2+0xa80>
  40c6f8:	91358800 	add	x0, x0, #0xd62
  40c6fc:	97fff41b 	bl	409768 <posix_print_warning>
			    "Using a test - not safe - entropy source\n");
	return 0;
}
  40c700:	52800000 	mov	w0, #0x0                   	// #0
  40c704:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40c708:	d65f03c0 	ret

000000000040c70c <add_fake_entropy_option>:
		"A 32-bit integer seed value for the entropy device, such as "
		"97229 (decimal), 0x17BCD (hex), or 0275715 (octal)"},
		ARG_TABLE_ENDMARKER
	};

	native_add_command_line_opts(entropy_options);
  40c70c:	d0000120 	adrp	x0, 432000 <__dso_handle>
  40c710:	9120a000 	add	x0, x0, #0x828
  40c714:	17fff6ae 	b	40a1cc <native_add_command_line_opts>

000000000040c718 <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
  40c718:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40c71c:	910003fd 	mov	x29, sp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
  40c720:	97fff11a 	bl	408b88 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40c724:	90000142 	adrp	x2, 434000 <ztest_thread+0xb8>
  40c728:	90000141 	adrp	x1, 434000 <ztest_thread+0xb8>

	last_tick_time += elapsed_ticks*tick_period;
	sys_clock_announce(elapsed_ticks);
}
  40c72c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
  40c730:	f9433043 	ldr	x3, [x2, #1632]
  40c734:	f9433424 	ldr	x4, [x1, #1640]
  40c738:	cb030000 	sub	x0, x0, x3
  40c73c:	9ac40800 	udiv	x0, x0, x4
	last_tick_time += elapsed_ticks*tick_period;
  40c740:	93407c01 	sxtw	x1, w0
  40c744:	9b040c21 	madd	x1, x1, x4, x3
  40c748:	f9033041 	str	x1, [x2, #1632]
	sys_clock_announce(elapsed_ticks);
  40c74c:	14002a68 	b	4170ec <sys_clock_announce>

000000000040c750 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(void)
{
  40c750:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40c754:	d284e200 	mov	x0, #0x2710                	// #10000
{
  40c758:	910003fd 	mov	x29, sp
  40c75c:	f9000bf3 	str	x19, [sp, #16]
	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
  40c760:	90000153 	adrp	x19, 434000 <ztest_thread+0xb8>
  40c764:	f9033660 	str	x0, [x19, #1640]

	last_tick_time = hwm_get_time();
  40c768:	97fff108 	bl	408b88 <hwm_get_time>
  40c76c:	90000141 	adrp	x1, 434000 <ztest_thread+0xb8>
  40c770:	f9033020 	str	x0, [x1, #1632]
	hwtimer_enable(tick_period);
  40c774:	f9433660 	ldr	x0, [x19, #1640]
  40c778:	97fff198 	bl	408dd8 <hwtimer_enable>

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
  40c77c:	d2800003 	mov	x3, #0x0                   	// #0
  40c780:	52800001 	mov	w1, #0x0                   	// #0
  40c784:	52800000 	mov	w0, #0x0                   	// #0
  40c788:	90000002 	adrp	x2, 40c000 <z_log_msg_runtime_create.constprop.0+0xa0>
  40c78c:	911c6042 	add	x2, x2, #0x718
  40c790:	97fff2b2 	bl	409258 <posix_isr_declare>
  40c794:	52800002 	mov	w2, #0x0                   	// #0
  40c798:	52800021 	mov	w1, #0x1                   	// #1
  40c79c:	52800000 	mov	w0, #0x0                   	// #0
  40c7a0:	97fff2b8 	bl	409280 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
  40c7a4:	52800000 	mov	w0, #0x0                   	// #0
  40c7a8:	97ffee24 	bl	408038 <arch_irq_enable>

	return 0;
}
  40c7ac:	52800000 	mov	w0, #0x0                   	// #0
  40c7b0:	f9400bf3 	ldr	x19, [sp, #16]
  40c7b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40c7b8:	d65f03c0 	ret

000000000040c7bc <sys_clock_cycle_get_32>:
{
  40c7bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40c7c0:	910003fd 	mov	x29, sp
	return hwm_get_time();
  40c7c4:	97fff0f1 	bl	408b88 <hwm_get_time>
}
  40c7c8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40c7cc:	d65f03c0 	ret

000000000040c7d0 <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
  40c7d0:	3100041f 	cmn	w0, #0x1
  40c7d4:	540000c0 	b.eq	40c7ec <sys_clock_set_timeout+0x1c>  // b.none
		silent_ticks = ticks - 1;
  40c7d8:	51000401 	sub	w1, w0, #0x1
  40c7dc:	7100001f 	cmp	w0, #0x0
  40c7e0:	93407c21 	sxtw	x1, w1
  40c7e4:	9a9fc020 	csel	x0, x1, xzr, gt
	hwtimer_set_silent_ticks(silent_ticks);
  40c7e8:	17fff1f0 	b	408fa8 <hwtimer_set_silent_ticks>
		silent_ticks = INT64_MAX;
  40c7ec:	92f00000 	mov	x0, #0x7fffffffffffffff    	// #9223372036854775807
  40c7f0:	17fffffe 	b	40c7e8 <sys_clock_set_timeout+0x18>

000000000040c7f4 <sys_clock_elapsed>:
{
  40c7f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  40c7f8:	910003fd 	mov	x29, sp
	return (hwm_get_time() - last_tick_time)/tick_period;
  40c7fc:	97fff0e3 	bl	408b88 <hwm_get_time>
  40c800:	90000141 	adrp	x1, 434000 <ztest_thread+0xb8>
}
  40c804:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return (hwm_get_time() - last_tick_time)/tick_period;
  40c808:	f9433021 	ldr	x1, [x1, #1632]
  40c80c:	cb010000 	sub	x0, x0, x1
  40c810:	90000141 	adrp	x1, 434000 <ztest_thread+0xb8>
  40c814:	f9433421 	ldr	x1, [x1, #1640]
}
  40c818:	9ac10800 	udiv	x0, x0, x1
  40c81c:	d65f03c0 	ret

000000000040c820 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  40c820:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  40c824:	b0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40c828:	910003fd 	mov	x29, sp
  40c82c:	f9475c00 	ldr	x0, [x0, #3768]
  40c830:	3d8023e0 	str	q0, [sp, #128]
  40c834:	3d8027e1 	str	q1, [sp, #144]
  40c838:	3d802be2 	str	q2, [sp, #160]
  40c83c:	3d802fe3 	str	q3, [sp, #176]
  40c840:	3d8033e4 	str	q4, [sp, #192]
  40c844:	3d8037e5 	str	q5, [sp, #208]
  40c848:	3d803be6 	str	q6, [sp, #224]
  40c84c:	3d803fe7 	str	q7, [sp, #240]
  40c850:	f90087e7 	str	x7, [sp, #264]
  40c854:	f9400002 	ldr	x2, [x0]
  40c858:	f9003fe2 	str	x2, [sp, #120]
  40c85c:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  40c860:	910443e0 	add	x0, sp, #0x110
  40c864:	a90383e0 	stp	x0, x0, [sp, #56]
  40c868:	910403e0 	add	x0, sp, #0x100
  40c86c:	9100e3e2 	add	x2, sp, #0x38
  40c870:	f90027e0 	str	x0, [sp, #72]
  40c874:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  40c878:	b90053e0 	str	w0, [sp, #80]
  40c87c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40c880:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  40c884:	910163e0 	add	x0, sp, #0x58
  40c888:	ad400440 	ldp	q0, q1, [x2]
  40c88c:	ad000400 	stp	q0, q1, [x0]
  40c890:	ad400400 	ldp	q0, q1, [x0]
  40c894:	910043e7 	add	x7, sp, #0x10
  40c898:	52800022 	mov	w2, #0x1                   	// #1
  40c89c:	52800000 	mov	w0, #0x0                   	// #0
  40c8a0:	52800005 	mov	w5, #0x0                   	// #0
  40c8a4:	d2800004 	mov	x4, #0x0                   	// #0
  40c8a8:	d2800003 	mov	x3, #0x0                   	// #0
  40c8ac:	ad0004e0 	stp	q0, q1, [x7]
  40c8b0:	97ffeb3e 	bl	4075a8 <z_impl_z_log_msg_runtime_vcreate>
}
  40c8b4:	b0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40c8b8:	f9475c00 	ldr	x0, [x0, #3768]
  40c8bc:	f9403fe2 	ldr	x2, [sp, #120]
  40c8c0:	f9400001 	ldr	x1, [x0]
  40c8c4:	eb010042 	subs	x2, x2, x1
  40c8c8:	d2800001 	mov	x1, #0x0                   	// #0
  40c8cc:	54000040 	b.eq	40c8d4 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  40c8d0:	97ffd314 	bl	401520 <__stack_chk_fail@plt>
  40c8d4:	a8d17bfd 	ldp	x29, x30, [sp], #272
  40c8d8:	d65f03c0 	ret

000000000040c8dc <thingset_init_global>:

void thingset_init_global(struct thingset_context *ts)
{
    /* duplicates are checked at compile-time */

    ts->data_objects = TYPE_SECTION_START(thingset_data_object);
  40c8dc:	b0000122 	adrp	x2, 431000 <__FRAME_END__+0x10804>
    STRUCT_SECTION_COUNT(thingset_data_object, &ts->num_objects);
  40c8e0:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
    ts->data_objects = TYPE_SECTION_START(thingset_data_object);
  40c8e4:	f947e042 	ldr	x2, [x2, #4032]
    STRUCT_SECTION_COUNT(thingset_data_object, &ts->num_objects);
  40c8e8:	f947ac21 	ldr	x1, [x1, #3928]
  40c8ec:	cb020021 	sub	x1, x1, x2
  40c8f0:	d345fc21 	lsr	x1, x1, #5
  40c8f4:	a9000402 	stp	x2, x1, [x0]
    ts->auth_flags = THINGSET_USR_MASK;
  40c8f8:	52800221 	mov	w1, #0x11                  	// #17
  40c8fc:	390ea001 	strb	w1, [x0, #936]
	return z_impl_k_sem_init(sem, initial_count, limit);
  40c900:	52800022 	mov	w2, #0x1                   	// #1
  40c904:	91004000 	add	x0, x0, #0x10
  40c908:	2a0203e1 	mov	w1, w2
  40c90c:	14001af0 	b	4134cc <z_impl_k_sem_init>

000000000040c910 <thingset_process_message>:
    k_sem_init(&ts->lock, 1, 1);
}

int thingset_process_message(struct thingset_context *ts, const uint8_t *msg, size_t msg_len,
                             uint8_t *rsp, size_t rsp_size)
{
  40c910:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    int ret;

    if (msg == NULL || msg_len < 1) {
  40c914:	f100003f 	cmp	x1, #0x0
  40c918:	fa401844 	ccmp	x2, #0x0, #0x4, ne  // ne = any
{
  40c91c:	910003fd 	mov	x29, sp
  40c920:	a90153f3 	stp	x19, x20, [sp, #16]
  40c924:	a9025bf5 	stp	x21, x22, [sp, #32]
  40c928:	a90363f7 	stp	x23, x24, [sp, #48]
    if (msg == NULL || msg_len < 1) {
  40c92c:	540005c0 	b.eq	40c9e4 <thingset_process_message+0xd4>  // b.none
        return -THINGSET_ERR_BAD_REQUEST;
    }

    if (rsp == NULL || rsp_size < 4) {
  40c930:	f100007f 	cmp	x3, #0x0
  40c934:	aa0303f6 	mov	x22, x3
  40c938:	aa0403f5 	mov	x21, x4
  40c93c:	fa431880 	ccmp	x4, #0x3, #0x0, ne  // ne = any
  40c940:	54000269 	b.ls	40c98c <thingset_process_message+0x7c>  // b.plast
  40c944:	aa0003f3 	mov	x19, x0
  40c948:	aa0103f4 	mov	x20, x1
  40c94c:	aa0203f7 	mov	x23, x2
        /* response buffer with at least 4 bytes required to fit minimum response */
        return -THINGSET_ERR_INTERNAL_SERVER_ERR;
    }

    if (k_sem_take(&ts->lock, K_MSEC(THINGSET_CONTEXT_LOCK_TIMEOUT_MS)) != 0) {
  40c950:	91004018 	add	x24, x0, #0x10
	return z_impl_k_sem_take(sem, timeout);
  40c954:	d2800c81 	mov	x1, #0x64                  	// #100
  40c958:	aa1803e0 	mov	x0, x24
  40c95c:	94001b1e 	bl	4135d4 <z_impl_k_sem_take>
  40c960:	340001a0 	cbz	w0, 40c994 <thingset_process_message+0x84>
        LOG_ERR("ThingSet context lock timed out");
  40c964:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40c968:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40c96c:	52800005 	mov	w5, #0x0                   	// #0
  40c970:	91383cc6 	add	x6, x6, #0xe0f
  40c974:	f947c421 	ldr	x1, [x1, #3976]
  40c978:	d2800004 	mov	x4, #0x0                   	// #0
  40c97c:	d2800003 	mov	x3, #0x0                   	// #0
  40c980:	52800022 	mov	w2, #0x1                   	// #1
  40c984:	52800000 	mov	w0, #0x0                   	// #0
  40c988:	97ffffa6 	bl	40c820 <z_log_msg_runtime_create.constprop.0>
        return -THINGSET_ERR_INTERNAL_SERVER_ERR;
  40c98c:	128017f3 	mov	w19, #0xffffff40            	// #-192
  40c990:	1400000d 	b	40c9c4 <thingset_process_message+0xb4>
        return -THINGSET_ERR_INTERNAL_SERVER_ERR;
    }

    ts->msg = msg;
    ts->msg_len = msg_len;
  40c994:	a903de74 	stp	x20, x23, [x19, #56]
    ts->msg_pos = 0;
  40c998:	f900267f 	str	xzr, [x19, #72]

    ts->rsp = rsp;
    ts->rsp_size = rsp_size;
  40c99c:	a905d676 	stp	x22, x21, [x19, #88]
    ts->rsp_pos = 0;
  40c9a0:	f900367f 	str	xzr, [x19, #104]

    if (ts->msg[0] >= 0x20) {
  40c9a4:	39400280 	ldrb	w0, [x20]
  40c9a8:	71007c1f 	cmp	w0, #0x1f
        ret = thingset_txt_process(ts);
  40c9ac:	aa1303e0 	mov	x0, x19
    if (ts->msg[0] >= 0x20) {
  40c9b0:	54000169 	b.ls	40c9dc <thingset_process_message+0xcc>  // b.plast
        ret = thingset_txt_process(ts);
  40c9b4:	94000dce 	bl	4100ec <thingset_txt_process>
    }
    else {
        ret = thingset_bin_process(ts);
  40c9b8:	2a0003f3 	mov	w19, w0
	z_impl_k_sem_give(sem);
  40c9bc:	aa1803e0 	mov	x0, x24
  40c9c0:	94001ace 	bl	4134f8 <z_impl_k_sem_give>
    }

    k_sem_give(&ts->lock);

    return ret;
}
  40c9c4:	2a1303e0 	mov	w0, w19
  40c9c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40c9cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40c9d0:	a94363f7 	ldp	x23, x24, [sp, #48]
  40c9d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40c9d8:	d65f03c0 	ret
        ret = thingset_bin_process(ts);
  40c9dc:	940004a5 	bl	40dc70 <thingset_bin_process>
  40c9e0:	17fffff6 	b	40c9b8 <thingset_process_message+0xa8>
        return -THINGSET_ERR_BAD_REQUEST;
  40c9e4:	128013f3 	mov	w19, #0xffffff60            	// #-160
  40c9e8:	17fffff7 	b	40c9c4 <thingset_process_message+0xb4>

000000000040c9ec <thingset_export_item>:
    return ret;
}

int thingset_export_item(struct thingset_context *ts, uint8_t *buf, size_t buf_size,
                         const struct thingset_data_object *obj, enum thingset_data_format format)
{
  40c9ec:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40c9f0:	910003fd 	mov	x29, sp
  40c9f4:	a90153f3 	stp	x19, x20, [sp, #16]
  40c9f8:	aa0003f3 	mov	x19, x0
  40c9fc:	2a0403f4 	mov	w20, w4
  40ca00:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ca04:	aa0203f6 	mov	x22, x2
  40ca08:	aa0303f5 	mov	x21, x3
  40ca0c:	a90363f7 	stp	x23, x24, [sp, #48]
  40ca10:	aa0103f7 	mov	x23, x1
    int ret;

    if (k_sem_take(&ts->lock, K_MSEC(THINGSET_CONTEXT_LOCK_TIMEOUT_MS)) != 0) {
  40ca14:	91004018 	add	x24, x0, #0x10
	return z_impl_k_sem_take(sem, timeout);
  40ca18:	d2800c81 	mov	x1, #0x64                  	// #100
  40ca1c:	aa1803e0 	mov	x0, x24
  40ca20:	94001aed 	bl	4135d4 <z_impl_k_sem_take>
  40ca24:	34000240 	cbz	w0, 40ca6c <thingset_export_item+0x80>
        LOG_ERR("ThingSet context lock timed out");
  40ca28:	b0000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
        return -THINGSET_ERR_INTERNAL_SERVER_ERR;
  40ca2c:	128017f4 	mov	w20, #0xffffff40            	// #-192
        LOG_ERR("ThingSet context lock timed out");
  40ca30:	b0000066 	adrp	x6, 419000 <__func__.2+0xa80>
  40ca34:	52800005 	mov	w5, #0x0                   	// #0
  40ca38:	f947c421 	ldr	x1, [x1, #3976]
  40ca3c:	91383cc6 	add	x6, x6, #0xe0f
  40ca40:	d2800004 	mov	x4, #0x0                   	// #0
  40ca44:	d2800003 	mov	x3, #0x0                   	// #0
  40ca48:	52800022 	mov	w2, #0x1                   	// #1
  40ca4c:	52800000 	mov	w0, #0x0                   	// #0
  40ca50:	97ffff74 	bl	40c820 <z_log_msg_runtime_create.constprop.0>

out:
    k_sem_give(&ts->lock);

    return ret;
}
  40ca54:	2a1403e0 	mov	w0, w20
  40ca58:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ca5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ca60:	a94363f7 	ldp	x23, x24, [sp, #48]
  40ca64:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40ca68:	d65f03c0 	ret
    ts->rsp_size = buf_size;
  40ca6c:	a905da77 	stp	x23, x22, [x19, #88]
    ts->rsp_pos = 0;
  40ca70:	f900367f 	str	xzr, [x19, #104]
    switch (format) {
  40ca74:	71000a9f 	cmp	w20, #0x2
  40ca78:	540000e0 	b.eq	40ca94 <thingset_export_item+0xa8>  // b.none
  40ca7c:	71001a9f 	cmp	w20, #0x6
  40ca80:	54000280 	b.eq	40cad0 <thingset_export_item+0xe4>  // b.none
  40ca84:	12801814 	mov	w20, #0xffffff3f            	// #-193
	z_impl_k_sem_give(sem);
  40ca88:	aa1803e0 	mov	x0, x24
  40ca8c:	94001a9b 	bl	4134f8 <z_impl_k_sem_give>
}
  40ca90:	17fffff1 	b	40ca54 <thingset_export_item+0x68>
            thingset_txt_setup(ts);
  40ca94:	aa1303e0 	mov	x0, x19
  40ca98:	94000d91 	bl	4100dc <thingset_txt_setup>
    ret = ts->api->serialize_value(ts, obj);
  40ca9c:	f9403a60 	ldr	x0, [x19, #112]
  40caa0:	aa1503e1 	mov	x1, x21
  40caa4:	f9400802 	ldr	x2, [x0, #16]
  40caa8:	aa1303e0 	mov	x0, x19
  40caac:	d63f0040 	blr	x2
  40cab0:	2a0003f4 	mov	w20, w0
    ts->api->serialize_finish(ts);
  40cab4:	f9403a60 	ldr	x0, [x19, #112]
  40cab8:	f9402c01 	ldr	x1, [x0, #88]
  40cabc:	aa1303e0 	mov	x0, x19
  40cac0:	d63f0020 	blr	x1
    if (ret == 0) {
  40cac4:	35fffe34 	cbnz	w20, 40ca88 <thingset_export_item+0x9c>
        ret = ts->rsp_pos;
  40cac8:	b9406a74 	ldr	w20, [x19, #104]
  40cacc:	17ffffef 	b	40ca88 <thingset_export_item+0x9c>
            ts->endpoint.use_ids = true;
  40cad0:	52800020 	mov	w0, #0x1                   	// #1
  40cad4:	390f1260 	strb	w0, [x19, #964]
            thingset_bin_setup(ts, 0);
  40cad8:	d2800001 	mov	x1, #0x0                   	// #0
  40cadc:	aa1303e0 	mov	x0, x19
  40cae0:	9400044c 	bl	40dc10 <thingset_bin_setup>
            break;
  40cae4:	17ffffee 	b	40ca9c <thingset_export_item+0xb0>

000000000040cae8 <thingset_iterate_subsets>:
{
    if (start_obj == NULL) {
        start_obj = ts->data_objects;
    }

    struct thingset_data_object *end_obj = ts->data_objects + ts->num_objects;
  40cae8:	a9400c04 	ldp	x4, x3, [x0]
        start_obj = ts->data_objects;
  40caec:	f100005f 	cmp	x2, #0x0
{
  40caf0:	12003c21 	and	w1, w1, #0xffff
    struct thingset_data_object *end_obj = ts->data_objects + ts->num_objects;
  40caf4:	8b031483 	add	x3, x4, x3, lsl #5
    for (struct thingset_data_object *obj = start_obj; obj < end_obj; obj++) {
  40caf8:	9a841040 	csel	x0, x2, x4, ne  // ne = any
  40cafc:	eb03001f 	cmp	x0, x3
  40cb00:	54000063 	b.cc	40cb0c <thingset_iterate_subsets+0x24>  // b.lo, b.ul, b.last
        if (obj->subsets & subset) {
            return obj;
        }
    }

    return NULL;
  40cb04:	d2800000 	mov	x0, #0x0                   	// #0
}
  40cb08:	d65f03c0 	ret
        if (obj->subsets & subset) {
  40cb0c:	f9400c02 	ldr	x2, [x0, #24]
  40cb10:	6a42643f 	tst	w1, w2, lsr #25
  40cb14:	54ffffa1 	b.ne	40cb08 <thingset_iterate_subsets+0x20>  // b.any
    for (struct thingset_data_object *obj = start_obj; obj < end_obj; obj++) {
  40cb18:	91008000 	add	x0, x0, #0x20
  40cb1c:	17fffff8 	b	40cafc <thingset_iterate_subsets+0x14>

000000000040cb20 <thingset_get_child_by_name>:
}

struct thingset_data_object *thingset_get_child_by_name(struct thingset_context *ts,
                                                        uint16_t parent_id, const char *name,
                                                        size_t len)
{
  40cb20:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40cb24:	910003fd 	mov	x29, sp
  40cb28:	a90153f3 	stp	x19, x20, [sp, #16]
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cb2c:	52800014 	mov	w20, #0x0                   	// #0
{
  40cb30:	a9025bf5 	stp	x21, x22, [sp, #32]
  40cb34:	aa0003f5 	mov	x21, x0
  40cb38:	aa0303f6 	mov	x22, x3
  40cb3c:	a90363f7 	stp	x23, x24, [sp, #48]
  40cb40:	aa0203f7 	mov	x23, x2
  40cb44:	a9046bf9 	stp	x25, x26, [sp, #64]
  40cb48:	12003c3a 	and	w26, w1, #0xffff
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cb4c:	f9400419 	ldr	x25, [x0, #8]
  40cb50:	2a1403f3 	mov	w19, w20
  40cb54:	eb34433f 	cmp	x25, w20, uxtw
  40cb58:	54000128 	b.hi	40cb7c <thingset_get_child_by_name+0x5c>  // b.pmore
        {
            return &(ts->data_objects[i]);
        }
    }

    return NULL;
  40cb5c:	d2800013 	mov	x19, #0x0                   	// #0
}
  40cb60:	aa1303e0 	mov	x0, x19
  40cb64:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cb68:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40cb6c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40cb70:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40cb74:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40cb78:	d65f03c0 	ret
        if (ts->data_objects[i].parent_id == parent_id
  40cb7c:	f94002a0 	ldr	x0, [x21]
  40cb80:	d37bea61 	lsl	x1, x19, #5
  40cb84:	8b131413 	add	x19, x0, x19, lsl #5
  40cb88:	78616800 	ldrh	w0, [x0, x1]
  40cb8c:	6b1a001f 	cmp	w0, w26
  40cb90:	54000161 	b.ne	40cbbc <thingset_get_child_by_name+0x9c>  // b.any
            && strncmp(ts->data_objects[i].name, name, len) == 0
  40cb94:	f9400678 	ldr	x24, [x19, #8]
  40cb98:	aa1603e2 	mov	x2, x22
  40cb9c:	aa1703e1 	mov	x1, x23
  40cba0:	aa1803e0 	mov	x0, x24
  40cba4:	97ffd237 	bl	401480 <strncmp@plt>
  40cba8:	350000a0 	cbnz	w0, 40cbbc <thingset_get_child_by_name+0x9c>
            && strlen(ts->data_objects[i].name) == len)
  40cbac:	aa1803e0 	mov	x0, x24
  40cbb0:	97ffd1f0 	bl	401370 <strlen@plt>
  40cbb4:	eb16001f 	cmp	x0, x22
  40cbb8:	54fffd40 	b.eq	40cb60 <thingset_get_child_by_name+0x40>  // b.none
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cbbc:	11000694 	add	w20, w20, #0x1
  40cbc0:	17ffffe4 	b	40cb50 <thingset_get_child_by_name+0x30>

000000000040cbc4 <thingset_get_object_by_id>:

struct thingset_data_object *thingset_get_object_by_id(struct thingset_context *ts, uint16_t id)
{
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cbc4:	f9400405 	ldr	x5, [x0, #8]
{
  40cbc8:	aa0003e4 	mov	x4, x0
  40cbcc:	12003c21 	and	w1, w1, #0xffff
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cbd0:	52800003 	mov	w3, #0x0                   	// #0
  40cbd4:	2a0303e2 	mov	w2, w3
  40cbd8:	eb2340bf 	cmp	x5, w3, uxtw
  40cbdc:	54000068 	b.hi	40cbe8 <thingset_get_object_by_id+0x24>  // b.pmore
        if (ts->data_objects[i].id == id) {
            return &(ts->data_objects[i]);
        }
    }

    return NULL;
  40cbe0:	d2800000 	mov	x0, #0x0                   	// #0
}
  40cbe4:	d65f03c0 	ret
        if (ts->data_objects[i].id == id) {
  40cbe8:	f9400080 	ldr	x0, [x4]
  40cbec:	8b021400 	add	x0, x0, x2, lsl #5
  40cbf0:	79400402 	ldrh	w2, [x0, #2]
  40cbf4:	6b01005f 	cmp	w2, w1
  40cbf8:	54ffff60 	b.eq	40cbe4 <thingset_get_object_by_id+0x20>  // b.none
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40cbfc:	11000463 	add	w3, w3, #0x1
  40cc00:	17fffff5 	b	40cbd4 <thingset_get_object_by_id+0x10>

000000000040cc04 <thingset_endpoint_by_path>:

int thingset_endpoint_by_path(struct thingset_context *ts, struct thingset_endpoint *endpoint,
                              const char *path, size_t path_len)
{
  40cc04:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  40cc08:	910003fd 	mov	x29, sp
  40cc0c:	a90153f3 	stp	x19, x20, [sp, #16]
  40cc10:	a9025bf5 	stp	x21, x22, [sp, #32]
  40cc14:	aa0103f6 	mov	x22, x1
  40cc18:	a90363f7 	stp	x23, x24, [sp, #48]
  40cc1c:	a9046bf9 	stp	x25, x26, [sp, #64]
  40cc20:	a90573fb 	stp	x27, x28, [sp, #80]
  40cc24:	aa0003fc 	mov	x28, x0
    struct thingset_data_object *object = NULL;
    const char *start = path;
    const char *end;
    uint16_t parent = 0;

    endpoint->index = THINGSET_ENDPOINT_INDEX_NONE;
  40cc28:	12800000 	mov	w0, #0xffffffff            	// #-1
  40cc2c:	b9000820 	str	w0, [x1, #8]
    endpoint->use_ids = false;
  40cc30:	3900303f 	strb	wzr, [x1, #12]

    if (path_len == 0) {
  40cc34:	b5000183 	cbnz	x3, 40cc64 <thingset_endpoint_by_path+0x60>
        endpoint->object = &root_object;
  40cc38:	d0000120 	adrp	x0, 432000 <__dso_handle>
  40cc3c:	9122e000 	add	x0, x0, #0x8b8
  40cc40:	f9000020 	str	x0, [x1]
        return 0;
  40cc44:	52800000 	mov	w0, #0x0                   	// #0
    if (object == NULL) {
        return -THINGSET_ERR_NOT_FOUND;
    }

    return 0;
}
  40cc48:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cc4c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40cc50:	a94363f7 	ldp	x23, x24, [sp, #48]
  40cc54:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40cc58:	a94573fb 	ldp	x27, x28, [sp, #80]
  40cc5c:	a8c77bfd 	ldp	x29, x30, [sp], #112
  40cc60:	d65f03c0 	ret
    if (start[0] == '/') {
  40cc64:	39400040 	ldrb	w0, [x2]
  40cc68:	aa0203f5 	mov	x21, x2
  40cc6c:	7100bc1f 	cmp	w0, #0x2f
  40cc70:	54000800 	b.eq	40cd70 <thingset_endpoint_by_path+0x16c>  // b.none
        else if (end == path + path_len - 1) {
  40cc74:	d1000479 	sub	x25, x3, #0x1
  40cc78:	aa0303fb 	mov	x27, x3
  40cc7c:	aa0203f4 	mov	x20, x2
        if (end == NULL || end >= path + path_len) {
  40cc80:	8b03005a 	add	x26, x2, x3
        else if (end == path + path_len - 1) {
  40cc84:	8b190059 	add	x25, x2, x25
  40cc88:	52800158 	mov	w24, #0xa                   	// #10
    struct thingset_data_object *object = NULL;
  40cc8c:	d2800013 	mov	x19, #0x0                   	// #0
    uint16_t parent = 0;
  40cc90:	52800004 	mov	w4, #0x0                   	// #0
        end = strchr(start, '/');
  40cc94:	aa1403e0 	mov	x0, x20
  40cc98:	528005e1 	mov	w1, #0x2f                  	// #47
  40cc9c:	b9006fe4 	str	w4, [sp, #108]
  40cca0:	97ffd25c 	bl	401610 <strchr@plt>
        if (end == NULL || end >= path + path_len) {
  40cca4:	b9406fe4 	ldr	w4, [sp, #108]
        end = strchr(start, '/');
  40cca8:	aa0003f7 	mov	x23, x0
        if (end == NULL || end >= path + path_len) {
  40ccac:	b4000060 	cbz	x0, 40ccb8 <thingset_endpoint_by_path+0xb4>
  40ccb0:	eb1a001f 	cmp	x0, x26
  40ccb4:	54000423 	b.cc	40cd38 <thingset_endpoint_by_path+0x134>  // b.lo, b.ul, b.last
            if (object != NULL && object->type == THINGSET_TYPE_RECORDS && start[0] >= '0'
  40ccb8:	39400280 	ldrb	w0, [x20]
  40ccbc:	b4000273 	cbz	x19, 40cd08 <thingset_endpoint_by_path+0x104>
  40ccc0:	b9401a61 	ldr	w1, [x19, #24]
  40ccc4:	12001021 	and	w1, w1, #0x1f
  40ccc8:	7100383f 	cmp	w1, #0xe
  40cccc:	540001e1 	b.ne	40cd08 <thingset_endpoint_by_path+0x104>  // b.any
  40ccd0:	7100bc1f 	cmp	w0, #0x2f
  40ccd4:	540001a9 	b.ls	40cd08 <thingset_endpoint_by_path+0x104>  // b.plast
                && start[0] <= '9')
  40ccd8:	7100e41f 	cmp	w0, #0x39
  40ccdc:	540001e8 	b.hi	40cd18 <thingset_endpoint_by_path+0x114>  // b.pmore
                endpoint->index = strtoul(start, NULL, 0);
  40cce0:	aa1403e0 	mov	x0, x20
  40cce4:	52800002 	mov	w2, #0x0                   	// #0
  40cce8:	d2800001 	mov	x1, #0x0                   	// #0
  40ccec:	97ffd19d 	bl	401360 <strtoul@plt>
                endpoint->index = THINGSET_ENDPOINT_INDEX_NEW;
  40ccf0:	b9000ac0 	str	w0, [x22, #8]
        return -THINGSET_ERR_NOT_FOUND;
  40ccf4:	f100027f 	cmp	x19, #0x0
  40ccf8:	12801460 	mov	w0, #0xffffff5c            	// #-164
  40ccfc:	1a8013e0 	csel	w0, wzr, w0, ne  // ne = any
    endpoint->object = object;
  40cd00:	f90002d3 	str	x19, [x22]
    if (object == NULL) {
  40cd04:	17ffffd1 	b	40cc48 <thingset_endpoint_by_path+0x44>
            else if (start[0] == '-') {
  40cd08:	7100b41f 	cmp	w0, #0x2d
  40cd0c:	54000061 	b.ne	40cd18 <thingset_endpoint_by_path+0x114>  // b.any
                endpoint->index = THINGSET_ENDPOINT_INDEX_NEW;
  40cd10:	12800020 	mov	w0, #0xfffffffe            	// #-2
  40cd14:	17fffff7 	b	40ccf0 <thingset_endpoint_by_path+0xec>
                object = thingset_get_child_by_name(ts, parent, start, path + path_len - start);
  40cd18:	8b1b02a3 	add	x3, x21, x27
  40cd1c:	aa1403e2 	mov	x2, x20
  40cd20:	cb140063 	sub	x3, x3, x20
  40cd24:	2a0403e1 	mov	w1, w4
  40cd28:	aa1c03e0 	mov	x0, x28
            object = thingset_get_child_by_name(ts, parent, start, end - start);
  40cd2c:	97ffff7d 	bl	40cb20 <thingset_get_child_by_name>
  40cd30:	aa0003f3 	mov	x19, x0
            break;
  40cd34:	17fffff0 	b	40ccf4 <thingset_endpoint_by_path+0xf0>
            object = thingset_get_child_by_name(ts, parent, start, end - start);
  40cd38:	cb140003 	sub	x3, x0, x20
  40cd3c:	aa1403e2 	mov	x2, x20
  40cd40:	2a0403e1 	mov	w1, w4
  40cd44:	aa1c03e0 	mov	x0, x28
        else if (end == path + path_len - 1) {
  40cd48:	eb1902ff 	cmp	x23, x25
  40cd4c:	54ffff00 	b.eq	40cd2c <thingset_endpoint_by_path+0x128>  // b.none
            object = thingset_get_child_by_name(ts, parent, start, end - start);
  40cd50:	97ffff74 	bl	40cb20 <thingset_get_child_by_name>
  40cd54:	aa0003f3 	mov	x19, x0
            if (object) {
  40cd58:	b4fffce0 	cbz	x0, 40ccf4 <thingset_endpoint_by_path+0xf0>
                parent = object->id;
  40cd5c:	79400404 	ldrh	w4, [x0, #2]
                start = end + 1;
  40cd60:	910006f4 	add	x20, x23, #0x1
    for (int i = 0; i < 10; i++) {
  40cd64:	71000718 	subs	w24, w24, #0x1
  40cd68:	54fff961 	b.ne	40cc94 <thingset_endpoint_by_path+0x90>  // b.any
  40cd6c:	17ffffe2 	b	40ccf4 <thingset_endpoint_by_path+0xf0>
        return -THINGSET_ERR_NOT_A_GATEWAY;
  40cd70:	12801880 	mov	w0, #0xffffff3b            	// #-197
  40cd74:	17ffffb5 	b	40cc48 <thingset_endpoint_by_path+0x44>

000000000040cd78 <thingset_endpoint_by_id>:

int thingset_endpoint_by_id(struct thingset_context *ts, struct thingset_endpoint *endpoint,
                            uint16_t id)
{
  40cd78:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40cd7c:	910003fd 	mov	x29, sp
  40cd80:	a90153f3 	stp	x19, x20, [sp, #16]
  40cd84:	aa0103f3 	mov	x19, x1
    struct thingset_data_object *object;
    endpoint->index = THINGSET_ENDPOINT_INDEX_NONE;
  40cd88:	12800001 	mov	w1, #0xffffffff            	// #-1
  40cd8c:	b9000a61 	str	w1, [x19, #8]
    endpoint->use_ids = true;
  40cd90:	52800021 	mov	w1, #0x1                   	// #1
  40cd94:	39003261 	strb	w1, [x19, #12]

    if (id == 0) {
  40cd98:	72003c41 	ands	w1, w2, #0xffff
{
  40cd9c:	f90013f5 	str	x21, [sp, #32]
    if (id == 0) {
  40cda0:	540000c1 	b.ne	40cdb8 <thingset_endpoint_by_id+0x40>  // b.any
        endpoint->object = &root_object;
  40cda4:	d0000120 	adrp	x0, 432000 <__dso_handle>
  40cda8:	9122e000 	add	x0, x0, #0x8b8
        return 0;
    }
    else if (id == THINGSET_ID_PATHS) {
        endpoint->object = &paths_object;
  40cdac:	f9000260 	str	x0, [x19]
    if (object != NULL) {
        /* check that the found endpoint is not part of a record (cannot be queried like this) */
        struct thingset_data_object *parent = thingset_get_object_by_id(ts, object->parent_id);
        if (parent == NULL || parent->type != THINGSET_TYPE_RECORDS) {
            endpoint->object = object;
            return 0;
  40cdb0:	52800000 	mov	w0, #0x0                   	// #0
  40cdb4:	1400000b 	b	40cde0 <thingset_endpoint_by_id+0x68>
    else if (id == THINGSET_ID_PATHS) {
  40cdb8:	71005c3f 	cmp	w1, #0x17
  40cdbc:	54000081 	b.ne	40cdcc <thingset_endpoint_by_id+0x54>  // b.any
        endpoint->object = &paths_object;
  40cdc0:	d0000120 	adrp	x0, 432000 <__dso_handle>
  40cdc4:	91226000 	add	x0, x0, #0x898
  40cdc8:	17fffff9 	b	40cdac <thingset_endpoint_by_id+0x34>
  40cdcc:	aa0003f5 	mov	x21, x0
    object = thingset_get_object_by_id(ts, id);
  40cdd0:	97ffff7d 	bl	40cbc4 <thingset_get_object_by_id>
  40cdd4:	aa0003f4 	mov	x20, x0
    if (object != NULL) {
  40cdd8:	b50000c0 	cbnz	x0, 40cdf0 <thingset_endpoint_by_id+0x78>
        }
    }

    return -THINGSET_ERR_NOT_FOUND;
  40cddc:	12801460 	mov	w0, #0xffffff5c            	// #-164
}
  40cde0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40cde4:	f94013f5 	ldr	x21, [sp, #32]
  40cde8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40cdec:	d65f03c0 	ret
        struct thingset_data_object *parent = thingset_get_object_by_id(ts, object->parent_id);
  40cdf0:	79400001 	ldrh	w1, [x0]
  40cdf4:	aa1503e0 	mov	x0, x21
  40cdf8:	97ffff73 	bl	40cbc4 <thingset_get_object_by_id>
        if (parent == NULL || parent->type != THINGSET_TYPE_RECORDS) {
  40cdfc:	b40000a0 	cbz	x0, 40ce10 <thingset_endpoint_by_id+0x98>
  40ce00:	b9401800 	ldr	w0, [x0, #24]
  40ce04:	12001000 	and	w0, w0, #0x1f
  40ce08:	7100381f 	cmp	w0, #0xe
  40ce0c:	54fffe80 	b.eq	40cddc <thingset_endpoint_by_id+0x64>  // b.none
            endpoint->object = object;
  40ce10:	f9000274 	str	x20, [x19]
  40ce14:	17ffffe7 	b	40cdb0 <thingset_endpoint_by_id+0x38>

000000000040ce18 <thingset_get_path>:

int thingset_get_path(struct thingset_context *ts, char *buf, size_t size,
                      const struct thingset_data_object *obj)
{
  40ce18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40ce1c:	910003fd 	mov	x29, sp
  40ce20:	a90153f3 	stp	x19, x20, [sp, #16]
  40ce24:	aa0103f4 	mov	x20, x1
  40ce28:	aa0203f3 	mov	x19, x2
  40ce2c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ce30:	aa0303f6 	mov	x22, x3
    int pos = 0;
    if (obj->parent_id != 0) {
  40ce34:	79400061 	ldrh	w1, [x3]
  40ce38:	34000361 	cbz	w1, 40cea4 <thingset_get_path+0x8c>
  40ce3c:	aa0003f5 	mov	x21, x0
        struct thingset_data_object *parent_obj = thingset_get_object_by_id(ts, obj->parent_id);
  40ce40:	97ffff61 	bl	40cbc4 <thingset_get_object_by_id>
  40ce44:	aa0003e3 	mov	x3, x0
        if (parent_obj == NULL) {
  40ce48:	b4000320 	cbz	x0, 40ceac <thingset_get_path+0x94>

        /*
         * Recursive implementation acceptable because the depth is automatically limited by actual
         * data structure nesting depth.
         */
        pos = thingset_get_path(ts, buf, size, parent_obj);
  40ce4c:	aa1303e2 	mov	x2, x19
  40ce50:	aa1403e1 	mov	x1, x20
  40ce54:	aa1503e0 	mov	x0, x21
  40ce58:	97fffff0 	bl	40ce18 <thingset_get_path>
        if (pos < 0) {
  40ce5c:	37f801c0 	tbnz	w0, #31, 40ce94 <thingset_get_path+0x7c>
            /* propagate errors back */
            return pos;
        }
        buf[pos++] = '/';
  40ce60:	11000415 	add	w21, w0, #0x1
  40ce64:	528005e1 	mov	w1, #0x2f                  	// #47
  40ce68:	3820ca81 	strb	w1, [x20, w0, sxtw]
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40ce6c:	f94006c3 	ldr	x3, [x22, #8]
  40ce70:	cb35c261 	sub	x1, x19, w21, sxtw
  40ce74:	8b35c280 	add	x0, x20, w21, sxtw
  40ce78:	90000062 	adrp	x2, 418000 <table.0+0x1d8>
  40ce7c:	9103dc42 	add	x2, x2, #0xf7
  40ce80:	97ffd164 	bl	401410 <snprintf@plt>
    }

    pos += snprintf(buf + pos, size - pos, "%s", obj->name);
  40ce84:	0b0002a0 	add	w0, w21, w0

    if (pos < size) {
        return pos;
    }
    else {
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40ce88:	12801c01 	mov	w1, #0xffffff1f            	// #-225
  40ce8c:	eb20c27f 	cmp	x19, w0, sxtw
  40ce90:	1a818000 	csel	w0, w0, w1, hi  // hi = pmore
    }
}
  40ce94:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ce98:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40ce9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40cea0:	d65f03c0 	ret
    int pos = 0;
  40cea4:	52800015 	mov	w21, #0x0                   	// #0
  40cea8:	17fffff1 	b	40ce6c <thingset_get_path+0x54>
            return -THINGSET_ERR_NOT_FOUND;
  40ceac:	12801460 	mov	w0, #0xffffff5c            	// #-164
  40ceb0:	17fffff9 	b	40ce94 <thingset_get_path+0x7c>

000000000040ceb4 <bin_serialize_finish>:
    return zcbor_list_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
}

static void bin_serialize_finish(struct thingset_context *ts)
{
    ts->rsp_pos = ts->encoder->payload - ts->rsp;
  40ceb4:	f9402c02 	ldr	x2, [x0, #88]
  40ceb8:	f9403c01 	ldr	x1, [x0, #120]
  40cebc:	cb020023 	sub	x3, x1, x2
  40cec0:	f9003403 	str	x3, [x0, #104]
    if (ts->rsp_pos == 2 && ts->rsp[1] == 0xF6) {
  40cec4:	f100087f 	cmp	x3, #0x2
  40cec8:	54000101 	b.ne	40cee8 <bin_serialize_finish+0x34>  // b.any
  40cecc:	39400442 	ldrb	w2, [x2, #1]
  40ced0:	7103d85f 	cmp	w2, #0xf6
  40ced4:	540000a1 	b.ne	40cee8 <bin_serialize_finish+0x34>  // b.any
        /* message with empty payload */
        ts->rsp[ts->rsp_pos++] = 0xF6;
  40ced8:	d2800062 	mov	x2, #0x3                   	// #3
  40cedc:	f9003402 	str	x2, [x0, #104]
  40cee0:	12800120 	mov	w0, #0xfffffff6            	// #-10
  40cee4:	39000020 	strb	w0, [x1]
    }
}
  40cee8:	d65f03c0 	ret

000000000040ceec <bin_deserialize_finish>:
    return err;
}

static int bin_deserialize_finish(struct thingset_context *ts)
{
    return ts->decoder->payload_end == ts->decoder->payload ? 0 : -THINGSET_ERR_BAD_REQUEST;
  40ceec:	f940a801 	ldr	x1, [x0, #336]
  40cef0:	f9409c00 	ldr	x0, [x0, #312]
  40cef4:	eb00003f 	cmp	x1, x0
}
  40cef8:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40cefc:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40cf00:	d65f03c0 	ret

000000000040cf04 <bin_serialize_response>:
{
  40cf04:	a9aa7bfd 	stp	x29, x30, [sp, #-352]!
  40cf08:	910003fd 	mov	x29, sp
  40cf0c:	a90153f3 	stp	x19, x20, [sp, #16]
  40cf10:	aa0003f3 	mov	x19, x0
  40cf14:	b0000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40cf18:	a9025bf5 	stp	x21, x22, [sp, #32]
  40cf1c:	12001c34 	and	w20, w1, #0xff
  40cf20:	aa0203f5 	mov	x21, x2
  40cf24:	f9475c00 	ldr	x0, [x0, #3768]
  40cf28:	f9001bf7 	str	x23, [sp, #48]
  40cf2c:	3d802fe0 	str	q0, [sp, #176]
    zcbor_update_state(ts->encoder, ts->rsp + 1, ts->rsp_size - 1);
  40cf30:	9101e276 	add	x22, x19, #0x78
{
  40cf34:	3d8033e1 	str	q1, [sp, #192]
  40cf38:	3d8037e2 	str	q2, [sp, #208]
  40cf3c:	3d803be3 	str	q3, [sp, #224]
  40cf40:	3d803fe4 	str	q4, [sp, #240]
  40cf44:	3d8043e5 	str	q5, [sp, #256]
  40cf48:	3d8047e6 	str	q6, [sp, #272]
  40cf4c:	3d804be7 	str	q7, [sp, #288]
  40cf50:	a91393e3 	stp	x3, x4, [sp, #312]
  40cf54:	a9149be5 	stp	x5, x6, [sp, #328]
  40cf58:	f900afe7 	str	x7, [sp, #344]
  40cf5c:	f9400001 	ldr	x1, [x0]
  40cf60:	f90057e1 	str	x1, [sp, #168]
  40cf64:	d2800001 	mov	x1, #0x0                   	// #0
    ts->rsp[0] = code;
  40cf68:	f9402e60 	ldr	x0, [x19, #88]
  40cf6c:	39000014 	strb	w20, [x0]
    zcbor_update_state(ts->encoder, ts->rsp + 1, ts->rsp_size - 1);
  40cf70:	aa1603e0 	mov	x0, x22
  40cf74:	a9458a61 	ldp	x1, x2, [x19, #88]
  40cf78:	d1000442 	sub	x2, x2, #0x1
  40cf7c:	91000421 	add	x1, x1, #0x1
  40cf80:	94000d40 	bl	410480 <zcbor_update_state>
    zcbor_nil_put(ts->encoder, NULL);
  40cf84:	aa1603e0 	mov	x0, x22
  40cf88:	d2800001 	mov	x1, #0x0                   	// #0
  40cf8c:	940010e6 	bl	411324 <zcbor_nil_put>
    if (THINGSET_ERROR(code)) {
  40cf90:	71027e9f 	cmp	w20, #0x9f
  40cf94:	54000429 	b.ls	40d018 <bin_serialize_response+0x114>  // b.plast
        if (msg != NULL) {
  40cf98:	b4000415 	cbz	x21, 40d018 <bin_serialize_response+0x114>
            va_start(vargs, msg);
  40cf9c:	910583e0 	add	x0, sp, #0x160
  40cfa0:	a90683e0 	stp	x0, x0, [sp, #104]
  40cfa4:	9104c3e0 	add	x0, sp, #0x130
  40cfa8:	f9003fe0 	str	x0, [sp, #120]
  40cfac:	128004e0 	mov	w0, #0xffffffd8            	// #-40
  40cfb0:	b90083e0 	str	w0, [sp, #128]
  40cfb4:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40cfb8:	b90087e0 	str	w0, [sp, #132]
  40cfbc:	9101a3e0 	add	x0, sp, #0x68
            uint8_t *msg_buf_start = ts->encoder->payload_mut + 2;
  40cfc0:	f9403e74 	ldr	x20, [x19, #120]
  40cfc4:	910223f7 	add	x23, sp, #0x88
  40cfc8:	ad400400 	ldp	q0, q1, [x0]
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40cfcc:	910103e5 	add	x5, sp, #0x40
            size_t msg_buf_size = ts->encoder->payload_end - msg_buf_start;
  40cfd0:	f9404a73 	ldr	x19, [x19, #144]
            uint8_t *msg_buf_start = ts->encoder->payload_mut + 2;
  40cfd4:	91000a94 	add	x20, x20, #0x2
            size_t msg_buf_size = ts->encoder->payload_end - msg_buf_start;
  40cfd8:	ad0006e0 	stp	q0, q1, [x23]
  40cfdc:	aa1503e4 	mov	x4, x21
  40cfe0:	cb140273 	sub	x19, x19, x20
  40cfe4:	aa1303e1 	mov	x1, x19
  40cfe8:	aa1403e0 	mov	x0, x20
  40cfec:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40cff0:	52800022 	mov	w2, #0x1                   	// #1
  40cff4:	ad0004a0 	stp	q0, q1, [x5]
  40cff8:	97ffd116 	bl	401450 <__vsnprintf_chk@plt>
            if (ret >= 0 && ret < msg_buf_size) {
  40cffc:	37f800e0 	tbnz	w0, #31, 40d018 <bin_serialize_response+0x114>
  40d000:	eb20c27f 	cmp	x19, w0, sxtw
  40d004:	540000a9 	b.ls	40d018 <bin_serialize_response+0x114>  // b.plast
}
static inline bool zcbor_tstr_encode_ptr(zcbor_state_t *state, const char *ptr, size_t len)
{
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };

	return zcbor_tstr_encode(state, &zs);
  40d008:	aa1703e1 	mov	x1, x23
  40d00c:	aa1603e0 	mov	x0, x22
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };
  40d010:	a908cff4 	stp	x20, x19, [sp, #136]
	return zcbor_tstr_encode(state, &zs);
  40d014:	940010b1 	bl	4112d8 <zcbor_tstr_encode>
}
  40d018:	90000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40d01c:	f9475c00 	ldr	x0, [x0, #3768]
  40d020:	f94057e2 	ldr	x2, [sp, #168]
  40d024:	f9400001 	ldr	x1, [x0]
  40d028:	eb010042 	subs	x2, x2, x1
  40d02c:	d2800001 	mov	x1, #0x0                   	// #0
  40d030:	54000040 	b.eq	40d038 <bin_serialize_response+0x134>  // b.none
  40d034:	97ffd13b 	bl	401520 <__stack_chk_fail@plt>
  40d038:	52800000 	mov	w0, #0x0                   	// #0
  40d03c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d040:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d044:	f9401bf7 	ldr	x23, [sp, #48]
  40d048:	a8d67bfd 	ldp	x29, x30, [sp], #352
  40d04c:	d65f03c0 	ret

000000000040d050 <bin_deserialize_payload_reset>:
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg_payload,
  40d050:	a9438c01 	ldp	x1, x3, [x0, #56]
  40d054:	d2800024 	mov	x4, #0x1                   	// #1
  40d058:	f9402802 	ldr	x2, [x0, #80]
  40d05c:	9104e000 	add	x0, x0, #0x138
                           ts->msg_len - (ts->msg_payload - ts->msg), 1);
  40d060:	cb010041 	sub	x1, x2, x1
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg_payload,
  40d064:	cb010063 	sub	x3, x3, x1
  40d068:	d2800081 	mov	x1, #0x4                   	// #4
  40d06c:	14000f35 	b	410d40 <zcbor_new_decode_state>

000000000040d070 <bin_deserialize_list_start>:
{
  40d070:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_list_start_decode(ts->decoder) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d074:	9104e000 	add	x0, x0, #0x138
{
  40d078:	910003fd 	mov	x29, sp
    return zcbor_list_start_decode(ts->decoder) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d07c:	94000ea3 	bl	410b08 <zcbor_list_start_decode>
  40d080:	72001c1f 	tst	w0, #0xff
}
  40d084:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d088:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40d08c:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40d090:	d65f03c0 	ret

000000000040d094 <bin_deserialize_string>:
{
  40d094:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    if (zcbor_tstr_decode(ts->decoder, &str) == true) {
  40d098:	9104e000 	add	x0, x0, #0x138
{
  40d09c:	910003fd 	mov	x29, sp
  40d0a0:	a90153f3 	stp	x19, x20, [sp, #16]
  40d0a4:	aa0103f4 	mov	x20, x1
  40d0a8:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d0ac:	aa0203f3 	mov	x19, x2
  40d0b0:	f9475c21 	ldr	x1, [x1, #3768]
  40d0b4:	f9400022 	ldr	x2, [x1]
  40d0b8:	f9001fe2 	str	x2, [sp, #56]
  40d0bc:	d2800002 	mov	x2, #0x0                   	// #0
    if (zcbor_tstr_decode(ts->decoder, &str) == true) {
  40d0c0:	9100a3e1 	add	x1, sp, #0x28
  40d0c4:	94000e8f 	bl	410b00 <zcbor_tstr_decode>
  40d0c8:	72001c1f 	tst	w0, #0xff
  40d0cc:	540001c0 	b.eq	40d104 <bin_deserialize_string+0x70>  // b.none
        *str_start = str.value;
  40d0d0:	f94017e0 	ldr	x0, [sp, #40]
  40d0d4:	f9000280 	str	x0, [x20]
        *str_len = str.len;
  40d0d8:	f9401be0 	ldr	x0, [sp, #48]
  40d0dc:	f9000260 	str	x0, [x19]
        return 0;
  40d0e0:	52800000 	mov	w0, #0x0                   	// #0
}
  40d0e4:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d0e8:	f9475c21 	ldr	x1, [x1, #3768]
  40d0ec:	f9401fe3 	ldr	x3, [sp, #56]
  40d0f0:	f9400022 	ldr	x2, [x1]
  40d0f4:	eb020063 	subs	x3, x3, x2
  40d0f8:	d2800002 	mov	x2, #0x0                   	// #0
  40d0fc:	54000080 	b.eq	40d10c <bin_deserialize_string+0x78>  // b.none
  40d100:	97ffd108 	bl	401520 <__stack_chk_fail@plt>
        return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d104:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40d108:	17fffff7 	b	40d0e4 <bin_deserialize_string+0x50>
}
  40d10c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d110:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40d114:	d65f03c0 	ret

000000000040d118 <bin_deserialize_simple_value>:
{
  40d118:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40d11c:	910003fd 	mov	x29, sp
  40d120:	a90153f3 	stp	x19, x20, [sp, #16]
  40d124:	aa0103f4 	mov	x20, x1
  40d128:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d12c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d130:	2a0303f5 	mov	w21, w3
  40d134:	f9475c21 	ldr	x1, [x1, #3768]
  40d138:	f9400023 	ldr	x3, [x1]
  40d13c:	f90027e3 	str	x3, [sp, #72]
  40d140:	d2800003 	mov	x3, #0x0                   	// #0
    if (ts->decoder->payload_end == ts->decoder->payload) {
  40d144:	f9409c01 	ldr	x1, [x0, #312]
  40d148:	f940a803 	ldr	x3, [x0, #336]
  40d14c:	eb01007f 	cmp	x3, x1
  40d150:	540009c0 	b.eq	40d288 <bin_deserialize_simple_value+0x170>  // b.none
    switch (type) {
  40d154:	71002c5f 	cmp	w2, #0xb
  40d158:	54000188 	b.hi	40d188 <bin_deserialize_simple_value+0x70>  // b.pmore
  40d15c:	d0000041 	adrp	x1, 417000 <z_abort_timeout+0x38>
  40d160:	913ae021 	add	x1, x1, #0xeb8
  40d164:	38624821 	ldrb	w1, [x1, w2, uxtw]
  40d168:	10000062 	adr	x2, 40d174 <bin_deserialize_simple_value+0x5c>
  40d16c:	8b218841 	add	x1, x2, w1, sxtb #2
  40d170:	d61f0020 	br	x1
            success = zcbor_uint32_decode(ts->decoder, data.u32);
  40d174:	aa1403e1 	mov	x1, x20
  40d178:	9104e000 	add	x0, x0, #0x138
  40d17c:	94000e5f 	bl	410af8 <zcbor_uint32_decode>
            success = zcbor_bool_decode(ts->decoder, data.b);
  40d180:	12001c00 	and	w0, w0, #0xff
    return success ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d184:	35000360 	cbnz	w0, 40d1f0 <bin_deserialize_simple_value+0xd8>
    switch (type) {
  40d188:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40d18c:	1400001a 	b	40d1f4 <bin_deserialize_simple_value+0xdc>
            success = zcbor_int32_decode(ts->decoder, data.i32);
  40d190:	aa1403e1 	mov	x1, x20
  40d194:	9104e000 	add	x0, x0, #0x138
  40d198:	94000e45 	bl	410aac <zcbor_int32_decode>
  40d19c:	17fffff9 	b	40d180 <bin_deserialize_simple_value+0x68>
            success = zcbor_uint_decode(ts->decoder, data.u16, 2);
  40d1a0:	d2800042 	mov	x2, #0x2                   	// #2
            success = zcbor_uint_decode(ts->decoder, data.u8, 1);
  40d1a4:	aa1403e1 	mov	x1, x20
  40d1a8:	9104e000 	add	x0, x0, #0x138
  40d1ac:	94000e42 	bl	410ab4 <zcbor_uint_decode>
  40d1b0:	17fffff4 	b	40d180 <bin_deserialize_simple_value+0x68>
            success = zcbor_int_decode(ts->decoder, data.i16, 2);
  40d1b4:	d2800042 	mov	x2, #0x2                   	// #2
            success = zcbor_int_decode(ts->decoder, data.i8, 1);
  40d1b8:	aa1403e1 	mov	x1, x20
  40d1bc:	9104e000 	add	x0, x0, #0x138
  40d1c0:	94000e0a 	bl	4109e8 <zcbor_int_decode>
  40d1c4:	17ffffef 	b	40d180 <bin_deserialize_simple_value+0x68>
            success = zcbor_uint_decode(ts->decoder, data.u8, 1);
  40d1c8:	d2800022 	mov	x2, #0x1                   	// #1
  40d1cc:	17fffff6 	b	40d1a4 <bin_deserialize_simple_value+0x8c>
            success = zcbor_int_decode(ts->decoder, data.i8, 1);
  40d1d0:	d2800022 	mov	x2, #0x1                   	// #1
  40d1d4:	17fffff9 	b	40d1b8 <bin_deserialize_simple_value+0xa0>
            success = zcbor_float32_decode(ts->decoder, data.f32);
  40d1d8:	9104e013 	add	x19, x0, #0x138
  40d1dc:	aa1403e1 	mov	x1, x20
  40d1e0:	aa1303e0 	mov	x0, x19
  40d1e4:	94000ec7 	bl	410d00 <zcbor_float32_decode>
            if (!success) {
  40d1e8:	72001c1f 	tst	w0, #0xff
  40d1ec:	54000140 	b.eq	40d214 <bin_deserialize_simple_value+0xfc>  // b.none
    return success ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d1f0:	52800000 	mov	w0, #0x0                   	// #0
}
  40d1f4:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d1f8:	f9475c21 	ldr	x1, [x1, #3768]
  40d1fc:	f94027e3 	ldr	x3, [sp, #72]
  40d200:	f9400022 	ldr	x2, [x1]
  40d204:	eb020063 	subs	x3, x3, x2
  40d208:	d2800002 	mov	x2, #0x0                   	// #0
  40d20c:	54000420 	b.eq	40d290 <bin_deserialize_simple_value+0x178>  // b.none
  40d210:	97ffd0c4 	bl	401520 <__stack_chk_fail@plt>
                if (zcbor_int32_decode(ts->decoder, &tmp) == true) {
  40d214:	9100e3e1 	add	x1, sp, #0x38
  40d218:	aa1303e0 	mov	x0, x19
  40d21c:	94000e24 	bl	410aac <zcbor_int32_decode>
  40d220:	72001c1f 	tst	w0, #0xff
  40d224:	54fffb20 	b.eq	40d188 <bin_deserialize_simple_value+0x70>  // b.none
                    *data.f32 = tmp;
  40d228:	bd403be0 	ldr	s0, [sp, #56]
  40d22c:	5e21d800 	scvtf	s0, s0
  40d230:	bd000280 	str	s0, [x20]
  40d234:	17ffffef 	b	40d1f0 <bin_deserialize_simple_value+0xd8>
            success = zcbor_bool_decode(ts->decoder, data.b);
  40d238:	aa1403e1 	mov	x1, x20
  40d23c:	9104e000 	add	x0, x0, #0x138
  40d240:	94000e8a 	bl	410c68 <zcbor_bool_decode>
  40d244:	17ffffcf 	b	40d180 <bin_deserialize_simple_value+0x68>
  40d248:	12001c96 	and	w22, w4, #0xff
            success = zcbor_tstr_decode(ts->decoder, &str);
  40d24c:	9100e3e1 	add	x1, sp, #0x38
  40d250:	9104e000 	add	x0, x0, #0x138
  40d254:	94000e2b 	bl	410b00 <zcbor_tstr_decode>
            if (success && str.len < detail) {
  40d258:	72001c1f 	tst	w0, #0xff
  40d25c:	54fff960 	b.eq	40d188 <bin_deserialize_simple_value+0x70>  // b.none
  40d260:	f94023f3 	ldr	x19, [sp, #64]
  40d264:	eb35c27f 	cmp	x19, w21, sxtw
  40d268:	54fff902 	b.cs	40d188 <bin_deserialize_simple_value+0x70>  // b.hs, b.nlast
                if (!check_only) {
  40d26c:	35fffc36 	cbnz	w22, 40d1f0 <bin_deserialize_simple_value+0xd8>

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len,
  40d270:	f9401fe1 	ldr	x1, [sp, #56]
  40d274:	aa1303e2 	mov	x2, x19
  40d278:	aa1403e0 	mov	x0, x20
  40d27c:	97ffd0fd 	bl	401670 <strncpy@plt>
                    data.str[str.len] = '\0';
  40d280:	38336a9f 	strb	wzr, [x20, x19]
    return success ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d284:	17ffffdb 	b	40d1f0 <bin_deserialize_simple_value+0xd8>
        return -THINGSET_ERR_DESERIALIZATION_FINISHED;
  40d288:	12801de0 	mov	w0, #0xffffff10            	// #-240
  40d28c:	17ffffda 	b	40d1f4 <bin_deserialize_simple_value+0xdc>
}
  40d290:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d294:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d298:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40d29c:	d65f03c0 	ret

000000000040d2a0 <bin_deserialize_child>:
{
  40d2a0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  40d2a4:	910003fd 	mov	x29, sp
  40d2a8:	a90153f3 	stp	x19, x20, [sp, #16]
  40d2ac:	aa0003f3 	mov	x19, x0
  40d2b0:	90000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40d2b4:	f90013f5 	str	x21, [sp, #32]
  40d2b8:	aa0103f4 	mov	x20, x1
  40d2bc:	f9475c00 	ldr	x0, [x0, #3768]
  40d2c0:	f9400001 	ldr	x1, [x0]
  40d2c4:	f90027e1 	str	x1, [sp, #72]
  40d2c8:	d2800001 	mov	x1, #0x0                   	// #0
    if (ts->decoder->payload_end == ts->decoder->payload) {
  40d2cc:	f9409e60 	ldr	x0, [x19, #312]
  40d2d0:	f940aa61 	ldr	x1, [x19, #336]
  40d2d4:	eb00003f 	cmp	x1, x0
  40d2d8:	540005e0 	b.eq	40d394 <bin_deserialize_child+0xf4>  // b.none
    if (zcbor_tstr_decode(ts->decoder, &name) == true) {
  40d2dc:	9104e275 	add	x21, x19, #0x138
  40d2e0:	9100e3e1 	add	x1, sp, #0x38
  40d2e4:	aa1503e0 	mov	x0, x21
  40d2e8:	94000e06 	bl	410b00 <zcbor_tstr_decode>
  40d2ec:	72001c1f 	tst	w0, #0xff
  40d2f0:	54000260 	b.eq	40d33c <bin_deserialize_child+0x9c>  // b.none
        *object = thingset_get_child_by_name(ts, ts->endpoint.object->id, name.value, name.len);
  40d2f4:	f941de60 	ldr	x0, [x19, #952]
  40d2f8:	a9438fe2 	ldp	x2, x3, [sp, #56]
  40d2fc:	79400401 	ldrh	w1, [x0, #2]
  40d300:	aa1303e0 	mov	x0, x19
  40d304:	97fffe07 	bl	40cb20 <thingset_get_child_by_name>
  40d308:	f9000280 	str	x0, [x20]
        if (*object == NULL) {
  40d30c:	b4000140 	cbz	x0, 40d334 <bin_deserialize_child+0x94>
    return 0;
  40d310:	52800000 	mov	w0, #0x0                   	// #0
}
  40d314:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d318:	f9475c21 	ldr	x1, [x1, #3768]
  40d31c:	f94027e3 	ldr	x3, [sp, #72]
  40d320:	f9400022 	ldr	x2, [x1]
  40d324:	eb020063 	subs	x3, x3, x2
  40d328:	d2800002 	mov	x2, #0x0                   	// #0
  40d32c:	54000380 	b.eq	40d39c <bin_deserialize_child+0xfc>  // b.none
  40d330:	97ffd07c 	bl	401520 <__stack_chk_fail@plt>
            return -THINGSET_ERR_NOT_FOUND;
  40d334:	12801460 	mov	w0, #0xffffff5c            	// #-164
  40d338:	17fffff7 	b	40d314 <bin_deserialize_child+0x74>
    else if (zcbor_uint32_decode(ts->decoder, &id) == true && id <= UINT16_MAX) {
  40d33c:	9100d3e1 	add	x1, sp, #0x34
  40d340:	aa1503e0 	mov	x0, x21
  40d344:	94000ded 	bl	410af8 <zcbor_uint32_decode>
  40d348:	72001c1f 	tst	w0, #0xff
  40d34c:	54000200 	b.eq	40d38c <bin_deserialize_child+0xec>  // b.none
  40d350:	b94037e1 	ldr	w1, [sp, #52]
  40d354:	529fffe0 	mov	w0, #0xffff                	// #65535
  40d358:	6b00003f 	cmp	w1, w0
  40d35c:	54000188 	b.hi	40d38c <bin_deserialize_child+0xec>  // b.pmore
        *object = thingset_get_object_by_id(ts, id);
  40d360:	aa1303e0 	mov	x0, x19
  40d364:	97fffe18 	bl	40cbc4 <thingset_get_object_by_id>
  40d368:	f9000280 	str	x0, [x20]
        if (*object == NULL) {
  40d36c:	b4fffe40 	cbz	x0, 40d334 <bin_deserialize_child+0x94>
        else if (ts->endpoint.object->id != THINGSET_ID_PATHS
  40d370:	f941de61 	ldr	x1, [x19, #952]
  40d374:	79400421 	ldrh	w1, [x1, #2]
  40d378:	71005c3f 	cmp	w1, #0x17
  40d37c:	54fffca0 	b.eq	40d310 <bin_deserialize_child+0x70>  // b.none
                 && (*object)->parent_id != ts->endpoint.object->id)
  40d380:	79400000 	ldrh	w0, [x0]
  40d384:	6b01001f 	cmp	w0, w1
  40d388:	54fffc40 	b.eq	40d310 <bin_deserialize_child+0x70>  // b.none
            return -THINGSET_ERR_BAD_REQUEST;
  40d38c:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40d390:	17ffffe1 	b	40d314 <bin_deserialize_child+0x74>
        return -THINGSET_ERR_DESERIALIZATION_FINISHED;
  40d394:	12801de0 	mov	w0, #0xffffff10            	// #-240
  40d398:	17ffffdf 	b	40d314 <bin_deserialize_child+0x74>
}
  40d39c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d3a0:	f94013f5 	ldr	x21, [sp, #32]
  40d3a4:	a8c57bfd 	ldp	x29, x30, [sp], #80
  40d3a8:	d65f03c0 	ret

000000000040d3ac <bin_deserialize_map_start>:
{
  40d3ac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_map_start_decode(ts->decoder) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d3b0:	9104e000 	add	x0, x0, #0x138
{
  40d3b4:	910003fd 	mov	x29, sp
    return zcbor_map_start_decode(ts->decoder) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d3b8:	94000dd6 	bl	410b10 <zcbor_map_start_decode>
  40d3bc:	72001c1f 	tst	w0, #0xff
}
  40d3c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d3c4:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40d3c8:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40d3cc:	d65f03c0 	ret

000000000040d3d0 <bin_deserialize_null>:
{
  40d3d0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_nil_expect(ts->decoder, NULL) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d3d4:	d2800001 	mov	x1, #0x0                   	// #0
  40d3d8:	9104e000 	add	x0, x0, #0x138
{
  40d3dc:	910003fd 	mov	x29, sp
    return zcbor_nil_expect(ts->decoder, NULL) ? 0 : -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40d3e0:	94000e20 	bl	410c60 <zcbor_nil_expect>
  40d3e4:	72001c1f 	tst	w0, #0xff
}
  40d3e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d3ec:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40d3f0:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40d3f4:	d65f03c0 	ret

000000000040d3f8 <bin_serialize_report_header>:
{
  40d3f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    ts->rsp[0] = THINGSET_BIN_REPORT;
  40d3fc:	528003e2 	mov	w2, #0x1f                  	// #31
    if (zcbor_uint32_put(ts->encoder, ts->endpoint.object->id)) {
  40d400:	9101e000 	add	x0, x0, #0x78
{
  40d404:	910003fd 	mov	x29, sp
    ts->rsp[0] = THINGSET_BIN_REPORT;
  40d408:	f85e0001 	ldur	x1, [x0, #-32]
  40d40c:	39000022 	strb	w2, [x1]
    if (zcbor_uint32_put(ts->encoder, ts->endpoint.object->id)) {
  40d410:	f941a001 	ldr	x1, [x0, #832]
  40d414:	79400421 	ldrh	w1, [x1, #2]
  40d418:	94000fa8 	bl	4112b8 <zcbor_uint32_put>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d41c:	72001c1f 	tst	w0, #0xff
}
  40d420:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d424:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40d428:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40d42c:	d65f03c0 	ret

000000000040d430 <bin_serialize_map_start>:
{
  40d430:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_map_start_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d434:	d2801fe1 	mov	x1, #0xff                  	// #255
  40d438:	9101e000 	add	x0, x0, #0x78
{
  40d43c:	910003fd 	mov	x29, sp
    return zcbor_map_start_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d440:	94000faa 	bl	4112e8 <zcbor_map_start_encode>
  40d444:	72001c1f 	tst	w0, #0xff
}
  40d448:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d44c:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40d450:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40d454:	d65f03c0 	ret

000000000040d458 <bin_serialize_map_end>:
{
  40d458:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_map_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d45c:	d2801fe1 	mov	x1, #0xff                  	// #255
  40d460:	9101e000 	add	x0, x0, #0x78
{
  40d464:	910003fd 	mov	x29, sp
    return zcbor_map_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d468:	94000fa4 	bl	4112f8 <zcbor_map_end_encode>
  40d46c:	72001c1f 	tst	w0, #0xff
}
  40d470:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d474:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40d478:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40d47c:	d65f03c0 	ret

000000000040d480 <bin_serialize_list_end>:
{
  40d480:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_list_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d484:	d2801fe1 	mov	x1, #0xff                  	// #255
  40d488:	9101e000 	add	x0, x0, #0x78
{
  40d48c:	910003fd 	mov	x29, sp
    return zcbor_list_end_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d490:	94000f98 	bl	4112f0 <zcbor_list_end_encode>
  40d494:	72001c1f 	tst	w0, #0xff
}
  40d498:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d49c:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40d4a0:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40d4a4:	d65f03c0 	ret

000000000040d4a8 <bin_serialize_list_start>:
{
  40d4a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return zcbor_list_start_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d4ac:	d2801fe1 	mov	x1, #0xff                  	// #255
  40d4b0:	9101e000 	add	x0, x0, #0x78
{
  40d4b4:	910003fd 	mov	x29, sp
    return zcbor_list_start_encode(ts->encoder, UINT8_MAX) ? 0 : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d4b8:	94000f8a 	bl	4112e0 <zcbor_list_start_encode>
  40d4bc:	72001c1f 	tst	w0, #0xff
}
  40d4c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  40d4c4:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40d4c8:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  40d4cc:	d65f03c0 	ret

000000000040d4d0 <bin_serialize_key_value>:
{
  40d4d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40d4d4:	910003fd 	mov	x29, sp
  40d4d8:	a90153f3 	stp	x19, x20, [sp, #16]
  40d4dc:	aa0003f3 	mov	x19, x0
  40d4e0:	aa0103f4 	mov	x20, x1
    int err = ts->api->serialize_key(ts, object);
  40d4e4:	f9403802 	ldr	x2, [x0, #112]
  40d4e8:	f9400442 	ldr	x2, [x2, #8]
  40d4ec:	d63f0040 	blr	x2
    if (err != 0) {
  40d4f0:	35000120 	cbnz	w0, 40d514 <bin_serialize_key_value+0x44>
    return ts->api->serialize_value(ts, object);
  40d4f4:	f9403a60 	ldr	x0, [x19, #112]
  40d4f8:	aa1403e1 	mov	x1, x20
  40d4fc:	f9400802 	ldr	x2, [x0, #16]
  40d500:	aa1303e0 	mov	x0, x19
}
  40d504:	a94153f3 	ldp	x19, x20, [sp, #16]
    return ts->api->serialize_value(ts, object);
  40d508:	aa0203f0 	mov	x16, x2
}
  40d50c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    return ts->api->serialize_value(ts, object);
  40d510:	d61f0200 	br	x16
}
  40d514:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d518:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40d51c:	d65f03c0 	ret

000000000040d520 <bin_serialize_subsets>:
{
  40d520:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40d524:	910003fd 	mov	x29, sp
  40d528:	a9025bf5 	stp	x21, x22, [sp, #32]
    success = zcbor_map_start_encode(ts->encoder, UINT8_MAX);
  40d52c:	9101e016 	add	x22, x0, #0x78
{
  40d530:	a90153f3 	stp	x19, x20, [sp, #16]
  40d534:	aa0003f3 	mov	x19, x0
    success = zcbor_map_start_encode(ts->encoder, UINT8_MAX);
  40d538:	aa1603e0 	mov	x0, x22
{
  40d53c:	f9001bf7 	str	x23, [sp, #48]
  40d540:	12003c37 	and	w23, w1, #0xffff
    success = zcbor_map_start_encode(ts->encoder, UINT8_MAX);
  40d544:	d2801fe1 	mov	x1, #0xff                  	// #255
  40d548:	94000f68 	bl	4112e8 <zcbor_map_start_encode>
  40d54c:	12001c15 	and	w21, w0, #0xff
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40d550:	52800014 	mov	w20, #0x0                   	// #0
  40d554:	f9400660 	ldr	x0, [x19, #8]
  40d558:	2a1403e1 	mov	w1, w20
  40d55c:	eb34401f 	cmp	x0, w20, uxtw
  40d560:	54000108 	b.hi	40d580 <bin_serialize_subsets+0x60>  // b.pmore
    success = success && zcbor_map_end_encode(ts->encoder, UINT8_MAX);
  40d564:	35000215 	cbnz	w21, 40d5a4 <bin_serialize_subsets+0x84>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d568:	12801c00 	mov	w0, #0xffffff1f            	// #-225
}
  40d56c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d570:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d574:	f9401bf7 	ldr	x23, [sp, #48]
  40d578:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40d57c:	d65f03c0 	ret
        if (ts->data_objects[i].subsets & subsets) {
  40d580:	f9400260 	ldr	x0, [x19]
  40d584:	8b011401 	add	x1, x0, x1, lsl #5
  40d588:	f9400c20 	ldr	x0, [x1, #24]
  40d58c:	6a4066ff 	tst	w23, w0, lsr #25
  40d590:	54000060 	b.eq	40d59c <bin_serialize_subsets+0x7c>  // b.none
            bin_serialize_key_value(ts, &ts->data_objects[i]);
  40d594:	aa1303e0 	mov	x0, x19
  40d598:	97ffffce 	bl	40d4d0 <bin_serialize_key_value>
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40d59c:	11000694 	add	w20, w20, #0x1
  40d5a0:	17ffffed 	b	40d554 <bin_serialize_subsets+0x34>
    success = success && zcbor_map_end_encode(ts->encoder, UINT8_MAX);
  40d5a4:	aa1603e0 	mov	x0, x22
  40d5a8:	d2801fe1 	mov	x1, #0xff                  	// #255
  40d5ac:	94000f53 	bl	4112f8 <zcbor_map_end_encode>
    if (success) {
  40d5b0:	72001c1f 	tst	w0, #0xff
  40d5b4:	54fffda0 	b.eq	40d568 <bin_serialize_subsets+0x48>  // b.none
        return 0;
  40d5b8:	52800000 	mov	w0, #0x0                   	// #0
  40d5bc:	17ffffec 	b	40d56c <bin_serialize_subsets+0x4c>

000000000040d5c0 <bin_deserialize_value>:
{
  40d5c0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
  40d5c4:	910003fd 	mov	x29, sp
  40d5c8:	a90153f3 	stp	x19, x20, [sp, #16]
  40d5cc:	aa0103f4 	mov	x20, x1
  40d5d0:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d5d4:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d5d8:	aa0003f6 	mov	x22, x0
  40d5dc:	f9475c21 	ldr	x1, [x1, #3768]
  40d5e0:	a90363f7 	stp	x23, x24, [sp, #48]
  40d5e4:	12001c57 	and	w23, w2, #0xff
  40d5e8:	a9046bf9 	stp	x25, x26, [sp, #64]
        bin_deserialize_simple_value(ts, object->data, object->type, object->detail, check_only);
  40d5ec:	2a1703e4 	mov	w4, w23
{
  40d5f0:	f9400022 	ldr	x2, [x1]
  40d5f4:	f90037e2 	str	x2, [sp, #104]
  40d5f8:	d2800002 	mov	x2, #0x0                   	// #0
        bin_deserialize_simple_value(ts, object->data, object->type, object->detail, check_only);
  40d5fc:	a9410a81 	ldp	x1, x2, [x20, #16]
  40d600:	93454043 	sbfx	x3, x2, #5, #12
  40d604:	12001042 	and	w2, w2, #0x1f
  40d608:	13003c63 	sxth	w3, w3
  40d60c:	97fffec3 	bl	40d118 <bin_deserialize_simple_value>
  40d610:	2a0003f3 	mov	w19, w0
    if (err == -THINGSET_ERR_UNSUPPORTED_FORMAT && object->type == THINGSET_TYPE_ARRAY) {
  40d614:	3102bc1f 	cmn	w0, #0xaf
  40d618:	540005c1 	b.ne	40d6d0 <bin_deserialize_value+0x110>  // b.any
  40d61c:	b9401a80 	ldr	w0, [x20, #24]
  40d620:	12001000 	and	w0, w0, #0x1f
  40d624:	7100341f 	cmp	w0, #0xd
  40d628:	54000541 	b.ne	40d6d0 <bin_deserialize_value+0x110>  // b.any
        success = zcbor_list_start_decode(ts->decoder);
  40d62c:	9104e2d9 	add	x25, x22, #0x138
  40d630:	aa1903e0 	mov	x0, x25
  40d634:	f9400a94 	ldr	x20, [x20, #16]
  40d638:	94000d34 	bl	410b08 <zcbor_list_start_decode>
        if (!success) {
  40d63c:	72001c1f 	tst	w0, #0xff
  40d640:	54000480 	b.eq	40d6d0 <bin_deserialize_value+0x110>  // b.none
/**
 * Helper function to determine the size of above ThingSet types in bytes
 */
static inline size_t thingset_type_size(uint8_t type)
{
    uint8_t sizes[] = { sizeof(bool),    sizeof(uint8_t),  sizeof(int8_t),  sizeof(uint16_t),
  40d644:	90000061 	adrp	x1, 419000 <__func__.2+0xa80>
  40d648:	9138fc21 	add	x1, x1, #0xe3f
        size_t type_size = thingset_type_size(array->element_type);
  40d64c:	b9400a80 	ldr	w0, [x20, #8]
  40d650:	910163e2 	add	x2, sp, #0x58
  40d654:	f9400023 	ldr	x3, [x1]
  40d658:	f9002fe3 	str	x3, [sp, #88]
  40d65c:	b8407021 	ldur	w1, [x1, #7]
  40d660:	b805f3e1 	stur	w1, [sp, #95]
                        sizeof(int16_t), sizeof(uint32_t), sizeof(int32_t), sizeof(uint64_t),
                        sizeof(int64_t), sizeof(float),    sizeof(int32_t) };
    return type < sizeof(sizes) ? sizes[type] : 0;
  40d664:	12001c01 	and	w1, w0, #0xff
  40d668:	7100283f 	cmp	w1, #0xa
  40d66c:	54000428 	b.hi	40d6f0 <bin_deserialize_value+0x130>  // b.pmore
  40d670:	92401c00 	and	x0, x0, #0xff
  40d674:	3860685a 	ldrb	w26, [x2, x0]
        int index = 0;
  40d678:	d2800018 	mov	x24, #0x0                   	// #0
  40d67c:	52800015 	mov	w21, #0x0                   	// #0
            err = bin_deserialize_simple_value(ts, data, array->element_type, array->decimals,
  40d680:	79c01a83 	ldrsh	w3, [x20, #12]
  40d684:	2a1703e4 	mov	w4, w23
  40d688:	b9400a82 	ldr	w2, [x20, #8]
  40d68c:	aa1603e0 	mov	x0, x22
            union thingset_data_pointer data = { .u8 = array->elements.u8 + index * type_size };
  40d690:	f9400281 	ldr	x1, [x20]
            err = bin_deserialize_simple_value(ts, data, array->element_type, array->decimals,
  40d694:	8b180021 	add	x1, x1, x24
  40d698:	97fffea0 	bl	40d118 <bin_deserialize_simple_value>
  40d69c:	2a0003f3 	mov	w19, w0
            if (err != 0) {
  40d6a0:	350000c0 	cbnz	w0, 40d6b8 <bin_deserialize_value+0xf8>
        } while (index < array->num_elements);
  40d6a4:	79402280 	ldrh	w0, [x20, #16]
            index++;
  40d6a8:	110006b5 	add	w21, w21, #0x1
        } while (index < array->num_elements);
  40d6ac:	8b1a0318 	add	x24, x24, x26
  40d6b0:	6b0002bf 	cmp	w21, w0
  40d6b4:	54fffe6b 	b.lt	40d680 <bin_deserialize_value+0xc0>  // b.tstop
        if (!check_only) {
  40d6b8:	35000057 	cbnz	w23, 40d6c0 <bin_deserialize_value+0x100>
            array->num_elements = index;
  40d6bc:	79002295 	strh	w21, [x20, #16]
        success = zcbor_list_end_decode(ts->decoder);
  40d6c0:	aa1903e0 	mov	x0, x25
  40d6c4:	94000d2e 	bl	410b7c <zcbor_list_end_decode>
            err = 0;
  40d6c8:	72001c1f 	tst	w0, #0xff
  40d6cc:	1a9f0273 	csel	w19, w19, wzr, eq  // eq = none
}
  40d6d0:	90000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40d6d4:	f9475c00 	ldr	x0, [x0, #3768]
  40d6d8:	f94037e2 	ldr	x2, [sp, #104]
  40d6dc:	f9400001 	ldr	x1, [x0]
  40d6e0:	eb010042 	subs	x2, x2, x1
  40d6e4:	d2800001 	mov	x1, #0x0                   	// #0
  40d6e8:	54000080 	b.eq	40d6f8 <bin_deserialize_value+0x138>  // b.none
  40d6ec:	97ffcf8d 	bl	401520 <__stack_chk_fail@plt>
  40d6f0:	d280001a 	mov	x26, #0x0                   	// #0
  40d6f4:	17ffffe1 	b	40d678 <bin_deserialize_value+0xb8>
  40d6f8:	2a1303e0 	mov	w0, w19
  40d6fc:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d700:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40d704:	a94363f7 	ldp	x23, x24, [sp, #48]
  40d708:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40d70c:	a8c77bfd 	ldp	x29, x30, [sp], #112
  40d710:	d65f03c0 	ret

000000000040d714 <bin_serialize_key>:
{
  40d714:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40d718:	90000122 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  40d71c:	910003fd 	mov	x29, sp
  40d720:	f9475c42 	ldr	x2, [x2, #3768]
  40d724:	a90153f3 	stp	x19, x20, [sp, #16]
        if (zcbor_uint32_put(ts->encoder, object->id) == false) {
  40d728:	9101e013 	add	x19, x0, #0x78
    if (ts->endpoint.use_ids) {
  40d72c:	394f1000 	ldrb	w0, [x0, #964]
{
  40d730:	f9400043 	ldr	x3, [x2]
  40d734:	f9001fe3 	str	x3, [sp, #56]
  40d738:	d2800003 	mov	x3, #0x0                   	// #0
    if (ts->endpoint.use_ids) {
  40d73c:	34000220 	cbz	w0, 40d780 <bin_serialize_key+0x6c>
        if (zcbor_uint32_put(ts->encoder, object->id) == false) {
  40d740:	79400421 	ldrh	w1, [x1, #2]
  40d744:	aa1303e0 	mov	x0, x19
  40d748:	94000edc 	bl	4112b8 <zcbor_uint32_put>
  40d74c:	72001c1f 	tst	w0, #0xff
  40d750:	54000141 	b.ne	40d778 <bin_serialize_key+0x64>  // b.any
            return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d754:	12801c00 	mov	w0, #0xffffff1f            	// #-225
}
  40d758:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d75c:	f9475c21 	ldr	x1, [x1, #3768]
  40d760:	f9401fe3 	ldr	x3, [sp, #56]
  40d764:	f9400022 	ldr	x2, [x1]
  40d768:	eb020063 	subs	x3, x3, x2
  40d76c:	d2800002 	mov	x2, #0x0                   	// #0
  40d770:	54000180 	b.eq	40d7a0 <bin_serialize_key+0x8c>  // b.none
  40d774:	97ffcf6b 	bl	401520 <__stack_chk_fail@plt>
    return 0;
  40d778:	52800000 	mov	w0, #0x0                   	// #0
  40d77c:	17fffff7 	b	40d758 <bin_serialize_key+0x44>
  40d780:	f9400434 	ldr	x20, [x1, #8]
        if (zcbor_tstr_put_term(ts->encoder, object->name) == false) {
  40d784:	aa1403e0 	mov	x0, x20
  40d788:	97ffcefa 	bl	401370 <strlen@plt>
  40d78c:	9100a3e1 	add	x1, sp, #0x28
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };
  40d790:	a90283f4 	stp	x20, x0, [sp, #40]
	return zcbor_tstr_encode(state, &zs);
  40d794:	aa1303e0 	mov	x0, x19
  40d798:	94000ed0 	bl	4112d8 <zcbor_tstr_encode>
  40d79c:	17ffffec 	b	40d74c <bin_serialize_key+0x38>
}
  40d7a0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d7a4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40d7a8:	d65f03c0 	ret

000000000040d7ac <bin_serialize_simple_value>:
{
  40d7ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40d7b0:	910003fd 	mov	x29, sp
  40d7b4:	a90153f3 	stp	x19, x20, [sp, #16]
  40d7b8:	aa0003f4 	mov	x20, x0
  40d7bc:	90000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40d7c0:	aa0103f3 	mov	x19, x1
  40d7c4:	f9475c00 	ldr	x0, [x0, #3768]
  40d7c8:	f9400001 	ldr	x1, [x0]
  40d7cc:	f9001fe1 	str	x1, [sp, #56]
  40d7d0:	d2800001 	mov	x1, #0x0                   	// #0
    switch (type) {
  40d7d4:	71002c5f 	cmp	w2, #0xb
  40d7d8:	540006a8 	b.hi	40d8ac <bin_serialize_simple_value+0x100>  // b.pmore
  40d7dc:	d0000040 	adrp	x0, 417000 <z_abort_timeout+0x38>
  40d7e0:	913b1000 	add	x0, x0, #0xec4
  40d7e4:	38624800 	ldrb	w0, [x0, w2, uxtw]
  40d7e8:	10000062 	adr	x2, 40d7f4 <bin_serialize_simple_value+0x48>
  40d7ec:	8b208840 	add	x0, x2, w0, sxtb #2
  40d7f0:	d61f0000 	br	x0
            success = zcbor_uint32_put(encoder, *data.u32);
  40d7f4:	b9400261 	ldr	w1, [x19]
            success = zcbor_uint32_put(encoder, *data.u8);
  40d7f8:	aa1403e0 	mov	x0, x20
  40d7fc:	94000eaf 	bl	4112b8 <zcbor_uint32_put>
  40d800:	12001c00 	and	w0, w0, #0xff
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d804:	7100001f 	cmp	w0, #0x0
  40d808:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40d80c:	1a8013e0 	csel	w0, wzr, w0, ne  // ne = any
}
  40d810:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d814:	f9475c21 	ldr	x1, [x1, #3768]
  40d818:	f9401fe3 	ldr	x3, [sp, #56]
  40d81c:	f9400022 	ldr	x2, [x1]
  40d820:	eb020063 	subs	x3, x3, x2
  40d824:	d2800002 	mov	x2, #0x0                   	// #0
  40d828:	54000460 	b.eq	40d8b4 <bin_serialize_simple_value+0x108>  // b.none
  40d82c:	97ffcf3d 	bl	401520 <__stack_chk_fail@plt>
            success = zcbor_int32_put(encoder, *data.i32);
  40d830:	b9400261 	ldr	w1, [x19]
                success = zcbor_int32_put(encoder, lroundf(*data.f32));
  40d834:	aa1403e0 	mov	x0, x20
  40d838:	94000e98 	bl	411298 <zcbor_int32_put>
  40d83c:	17fffff1 	b	40d800 <bin_serialize_simple_value+0x54>
            success = zcbor_uint32_put(encoder, *data.u16);
  40d840:	79400261 	ldrh	w1, [x19]
  40d844:	17ffffed 	b	40d7f8 <bin_serialize_simple_value+0x4c>
            success = zcbor_int32_put(encoder, *data.i16);
  40d848:	79c00261 	ldrsh	w1, [x19]
  40d84c:	17fffffa 	b	40d834 <bin_serialize_simple_value+0x88>
            success = zcbor_uint32_put(encoder, *data.u8);
  40d850:	39400261 	ldrb	w1, [x19]
  40d854:	17ffffe9 	b	40d7f8 <bin_serialize_simple_value+0x4c>
            success = zcbor_int32_put(encoder, *data.i8);
  40d858:	39c00261 	ldrsb	w1, [x19]
  40d85c:	17fffff6 	b	40d834 <bin_serialize_simple_value+0x88>
                success = zcbor_int32_put(encoder, lroundf(*data.f32));
  40d860:	bd400260 	ldr	s0, [x19]
            if (detail == 0) { /* round to 0 decimals: use int */
  40d864:	35000083 	cbnz	w3, 40d874 <bin_serialize_simple_value+0xc8>
                success = zcbor_int32_put(encoder, lroundf(*data.f32));
  40d868:	97ffcefe 	bl	401460 <lroundf@plt>
  40d86c:	2a0003e1 	mov	w1, w0
  40d870:	17fffff1 	b	40d834 <bin_serialize_simple_value+0x88>
                success = zcbor_float32_put(encoder, *data.f32);
  40d874:	aa1403e0 	mov	x0, x20
  40d878:	94000eb4 	bl	411348 <zcbor_float32_put>
  40d87c:	17ffffe1 	b	40d800 <bin_serialize_simple_value+0x54>
            success = zcbor_bool_put(encoder, *data.b);
  40d880:	39400261 	ldrb	w1, [x19]
  40d884:	aa1403e0 	mov	x0, x20
  40d888:	94000ea9 	bl	41132c <zcbor_bool_put>
  40d88c:	17ffffdd 	b	40d800 <bin_serialize_simple_value+0x54>
            success = zcbor_tstr_put_term(encoder, data.str);
  40d890:	aa1303e0 	mov	x0, x19
  40d894:	97ffceb7 	bl	401370 <strlen@plt>
  40d898:	9100a3e1 	add	x1, sp, #0x28
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };
  40d89c:	a90283f3 	stp	x19, x0, [sp, #40]
	return zcbor_tstr_encode(state, &zs);
  40d8a0:	aa1403e0 	mov	x0, x20
  40d8a4:	94000e8d 	bl	4112d8 <zcbor_tstr_encode>
  40d8a8:	17ffffd6 	b	40d800 <bin_serialize_simple_value+0x54>
    switch (type) {
  40d8ac:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40d8b0:	17ffffd8 	b	40d810 <bin_serialize_simple_value+0x64>
}
  40d8b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d8b8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40d8bc:	d65f03c0 	ret

000000000040d8c0 <bin_serialize_path>:
{
  40d8c0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40d8c4:	90000122 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  40d8c8:	910003fd 	mov	x29, sp
  40d8cc:	f9475c42 	ldr	x2, [x2, #3768]
  40d8d0:	a90153f3 	stp	x19, x20, [sp, #16]
  40d8d4:	aa0003f3 	mov	x19, x0
    uint8_t *buf_path_start = ts->encoder->payload_mut + 2;
  40d8d8:	f9403c14 	ldr	x20, [x0, #120]
{
  40d8dc:	f9400043 	ldr	x3, [x2]
  40d8e0:	f9001fe3 	str	x3, [sp, #56]
  40d8e4:	d2800003 	mov	x3, #0x0                   	// #0
    size_t buf_path_size = ts->encoder->payload_end - buf_path_start;
  40d8e8:	f9404802 	ldr	x2, [x0, #144]
    uint8_t *buf_path_start = ts->encoder->payload_mut + 2;
  40d8ec:	91000a94 	add	x20, x20, #0x2
    int path_len = thingset_get_path(ts, (char *)buf_path_start, buf_path_size, object);
  40d8f0:	aa0103e3 	mov	x3, x1
  40d8f4:	aa1403e1 	mov	x1, x20
  40d8f8:	cb140042 	sub	x2, x2, x20
  40d8fc:	97fffd47 	bl	40ce18 <thingset_get_path>
    if (path_len < 0) {
  40d900:	37f80140 	tbnz	w0, #31, 40d928 <bin_serialize_path+0x68>
    return zcbor_tstr_encode_ptr(ts->encoder, buf_path_start, path_len)
  40d904:	93407c00 	sxtw	x0, w0
  40d908:	9100a3e1 	add	x1, sp, #0x28
  40d90c:	a90283f4 	stp	x20, x0, [sp, #40]
  40d910:	9101e260 	add	x0, x19, #0x78
  40d914:	94000e71 	bl	4112d8 <zcbor_tstr_encode>
  40d918:	2a0003e1 	mov	w1, w0
               : -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d91c:	52800000 	mov	w0, #0x0                   	// #0
  40d920:	72001c3f 	tst	w1, #0xff
  40d924:	54000041 	b.ne	40d92c <bin_serialize_path+0x6c>  // b.any
  40d928:	12801c00 	mov	w0, #0xffffff1f            	// #-225
}
  40d92c:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d930:	f9475c21 	ldr	x1, [x1, #3768]
  40d934:	f9401fe3 	ldr	x3, [sp, #56]
  40d938:	f9400022 	ldr	x2, [x1]
  40d93c:	eb020063 	subs	x3, x3, x2
  40d940:	d2800002 	mov	x2, #0x0                   	// #0
  40d944:	54000040 	b.eq	40d94c <bin_serialize_path+0x8c>  // b.none
  40d948:	97ffcef6 	bl	401520 <__stack_chk_fail@plt>
  40d94c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40d950:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40d954:	d65f03c0 	ret

000000000040d958 <bin_serialize_value>:
{
  40d958:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40d95c:	910003fd 	mov	x29, sp
  40d960:	a9025bf5 	stp	x21, x22, [sp, #32]
  40d964:	aa0003f5 	mov	x21, x0
  40d968:	90000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40d96c:	a90153f3 	stp	x19, x20, [sp, #16]
  40d970:	aa0103f4 	mov	x20, x1
    err = bin_serialize_simple_value(ts->encoder, object->data, object->type, object->detail);
  40d974:	9101e2b3 	add	x19, x21, #0x78
{
  40d978:	f9475c00 	ldr	x0, [x0, #3768]
  40d97c:	a90363f7 	stp	x23, x24, [sp, #48]
  40d980:	f90023f9 	str	x25, [sp, #64]
  40d984:	f9400001 	ldr	x1, [x0]
  40d988:	f9003fe1 	str	x1, [sp, #120]
  40d98c:	d2800001 	mov	x1, #0x0                   	// #0
    err = bin_serialize_simple_value(ts->encoder, object->data, object->type, object->detail);
  40d990:	aa1303e0 	mov	x0, x19
  40d994:	a9410a81 	ldp	x1, x2, [x20, #16]
  40d998:	93454043 	sbfx	x3, x2, #5, #12
  40d99c:	12001042 	and	w2, w2, #0x1f
  40d9a0:	13003c63 	sxth	w3, w3
  40d9a4:	97ffff82 	bl	40d7ac <bin_serialize_simple_value>
    if (err == 0) {
  40d9a8:	35000140 	cbnz	w0, 40d9d0 <bin_serialize_value+0x78>
        return 0;
  40d9ac:	52800000 	mov	w0, #0x0                   	// #0
}
  40d9b0:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40d9b4:	f9475c21 	ldr	x1, [x1, #3768]
  40d9b8:	f9403fe3 	ldr	x3, [sp, #120]
  40d9bc:	f9400022 	ldr	x2, [x1]
  40d9c0:	eb020063 	subs	x3, x3, x2
  40d9c4:	d2800002 	mov	x2, #0x0                   	// #0
  40d9c8:	54001140 	b.eq	40dbf0 <bin_serialize_value+0x298>  // b.none
  40d9cc:	97ffced5 	bl	401520 <__stack_chk_fail@plt>
    if (object->type == THINGSET_TYPE_GROUP) {
  40d9d0:	b9401a80 	ldr	w0, [x20, #24]
  40d9d4:	12001000 	and	w0, w0, #0x1f
  40d9d8:	71003c1f 	cmp	w0, #0xf
  40d9dc:	54000101 	b.ne	40d9fc <bin_serialize_value+0xa4>  // b.any
        success = zcbor_nil_put(ts->encoder, NULL);
  40d9e0:	aa1303e0 	mov	x0, x19
  40d9e4:	d2800001 	mov	x1, #0x0                   	// #0
  40d9e8:	94000e4f 	bl	411324 <zcbor_nil_put>
        success = zcbor_uint32_put(ts->encoder, object->data.records->num_records);
  40d9ec:	12001c00 	and	w0, w0, #0xff
    if (success) {
  40d9f0:	35fffde0 	cbnz	w0, 40d9ac <bin_serialize_value+0x54>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40d9f4:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40d9f8:	17ffffee 	b	40d9b0 <bin_serialize_value+0x58>
    else if (object->type == THINGSET_TYPE_RECORDS) {
  40d9fc:	51003400 	sub	w0, w0, #0xd
  40da00:	7100141f 	cmp	w0, #0x5
  40da04:	54000f28 	b.hi	40dbe8 <bin_serialize_value+0x290>  // b.pmore
  40da08:	d0000041 	adrp	x1, 417000 <z_abort_timeout+0x38>
  40da0c:	913b4021 	add	x1, x1, #0xed0
  40da10:	38604821 	ldrb	w1, [x1, w0, uxtw]
  40da14:	10000060 	adr	x0, 40da20 <bin_serialize_value+0xc8>
  40da18:	8b218801 	add	x1, x0, w1, sxtb #2
  40da1c:	d61f0020 	br	x1
        success = zcbor_uint32_put(ts->encoder, object->data.records->num_records);
  40da20:	f9400a80 	ldr	x0, [x20, #16]
  40da24:	79402401 	ldrh	w1, [x0, #18]
  40da28:	aa1303e0 	mov	x0, x19
  40da2c:	94000e23 	bl	4112b8 <zcbor_uint32_put>
  40da30:	17ffffef 	b	40d9ec <bin_serialize_value+0x94>
        success = zcbor_list_start_encode(ts->encoder, UINT8_MAX);
  40da34:	aa1303e0 	mov	x0, x19
  40da38:	d2801fe1 	mov	x1, #0xff                  	// #255
  40da3c:	910163f9 	add	x25, sp, #0x58
  40da40:	94000e28 	bl	4112e0 <zcbor_list_start_encode>
  40da44:	12001c17 	and	w23, w0, #0xff
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40da48:	52800016 	mov	w22, #0x0                   	// #0
  40da4c:	f94006a0 	ldr	x0, [x21, #8]
  40da50:	2a1603e1 	mov	w1, w22
  40da54:	eb36401f 	cmp	x0, w22, uxtw
  40da58:	54000108 	b.hi	40da78 <bin_serialize_value+0x120>  // b.pmore
        success = success && zcbor_list_end_encode(ts->encoder, UINT8_MAX);
  40da5c:	34000437 	cbz	w23, 40dae0 <bin_serialize_value+0x188>
        success = success && zcbor_list_end_encode(ts->encoder, UINT8_MAX);
  40da60:	d2801fe1 	mov	x1, #0xff                  	// #255
        success = success && zcbor_list_end_encode(ts->encoder, array->num_elements);
  40da64:	aa1303e0 	mov	x0, x19
  40da68:	94000e22 	bl	4112f0 <zcbor_list_end_encode>
  40da6c:	12001c00 	and	w0, w0, #0xff
  40da70:	12000000 	and	w0, w0, #0x1
  40da74:	17ffffdf 	b	40d9f0 <bin_serialize_value+0x98>
            if (ts->data_objects[i].parent_id == object->id) {
  40da78:	f94002a0 	ldr	x0, [x21]
  40da7c:	d37be822 	lsl	x2, x1, #5
  40da80:	8b011401 	add	x1, x0, x1, lsl #5
  40da84:	78626802 	ldrh	w2, [x0, x2]
  40da88:	79400680 	ldrh	w0, [x20, #2]
  40da8c:	6b00005f 	cmp	w2, w0
  40da90:	54000101 	b.ne	40dab0 <bin_serialize_value+0x158>  // b.any
                zcbor_tstr_put_term(ts->encoder, ts->data_objects[i].name);
  40da94:	f9400438 	ldr	x24, [x1, #8]
  40da98:	aa1803e0 	mov	x0, x24
  40da9c:	97ffce35 	bl	401370 <strlen@plt>
  40daa0:	aa1903e1 	mov	x1, x25
	const struct zcbor_string zs = { .value = (const uint8_t *)ptr, .len = len };
  40daa4:	a90583f8 	stp	x24, x0, [sp, #88]
	return zcbor_tstr_encode(state, &zs);
  40daa8:	aa1303e0 	mov	x0, x19
  40daac:	94000e0b 	bl	4112d8 <zcbor_tstr_encode>
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40dab0:	110006d6 	add	w22, w22, #0x1
  40dab4:	17ffffe6 	b	40da4c <bin_serialize_value+0xf4>
        success = zcbor_list_start_encode(ts->encoder, UINT8_MAX);
  40dab8:	aa1303e0 	mov	x0, x19
  40dabc:	d2801fe1 	mov	x1, #0xff                  	// #255
  40dac0:	94000e08 	bl	4112e0 <zcbor_list_start_encode>
  40dac4:	12001c02 	and	w2, w0, #0xff
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40dac8:	52800016 	mov	w22, #0x0                   	// #0
  40dacc:	f94006a0 	ldr	x0, [x21, #8]
  40dad0:	2a1603e1 	mov	w1, w22
  40dad4:	eb36401f 	cmp	x0, w22, uxtw
  40dad8:	54000088 	b.hi	40dae8 <bin_serialize_value+0x190>  // b.pmore
        success = success && zcbor_list_end_encode(ts->encoder, UINT8_MAX);
  40dadc:	35fffc22 	cbnz	w2, 40da60 <bin_serialize_value+0x108>
        success = success && zcbor_list_end_encode(ts->encoder, array->num_elements);
  40dae0:	52800000 	mov	w0, #0x0                   	// #0
  40dae4:	17ffffe3 	b	40da70 <bin_serialize_value+0x118>
            if (ts->data_objects[i].subsets & object->data.subset) {
  40dae8:	f94002a0 	ldr	x0, [x21]
  40daec:	8b011401 	add	x1, x0, x1, lsl #5
  40daf0:	b9401280 	ldr	w0, [x20, #16]
  40daf4:	f9400c23 	ldr	x3, [x1, #24]
  40daf8:	6a43641f 	tst	w0, w3, lsr #25
  40dafc:	54000120 	b.eq	40db20 <bin_serialize_value+0x1c8>  // b.none
                if (ts->endpoint.use_ids) {
  40db00:	394f12a0 	ldrb	w0, [x21, #964]
  40db04:	34000160 	cbz	w0, 40db30 <bin_serialize_value+0x1d8>
                    success = success && zcbor_uint32_put(ts->encoder, ts->data_objects[i].id);
  40db08:	34000102 	cbz	w2, 40db28 <bin_serialize_value+0x1d0>
  40db0c:	79400421 	ldrh	w1, [x1, #2]
  40db10:	aa1303e0 	mov	x0, x19
  40db14:	94000de9 	bl	4112b8 <zcbor_uint32_put>
  40db18:	12001c02 	and	w2, w0, #0xff
  40db1c:	12000042 	and	w2, w2, #0x1
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40db20:	110006d6 	add	w22, w22, #0x1
  40db24:	17ffffea 	b	40dacc <bin_serialize_value+0x174>
                    success = success && zcbor_uint32_put(ts->encoder, ts->data_objects[i].id);
  40db28:	52800002 	mov	w2, #0x0                   	// #0
  40db2c:	17fffffc 	b	40db1c <bin_serialize_value+0x1c4>
                    success = success && (bin_serialize_path(ts, &ts->data_objects[i]) == 0);
  40db30:	340000c2 	cbz	w2, 40db48 <bin_serialize_value+0x1f0>
  40db34:	aa1503e0 	mov	x0, x21
  40db38:	97ffff62 	bl	40d8c0 <bin_serialize_path>
  40db3c:	7100001f 	cmp	w0, #0x0
  40db40:	1a9f17e2 	cset	w2, eq  // eq = none
  40db44:	17fffff7 	b	40db20 <bin_serialize_value+0x1c8>
  40db48:	52800002 	mov	w2, #0x0                   	// #0
  40db4c:	17fffff5 	b	40db20 <bin_serialize_value+0x1c8>
        struct thingset_array *array = object->data.array;
  40db50:	f9400a94 	ldr	x20, [x20, #16]
        success = zcbor_list_start_encode(ts->encoder, array->num_elements);
  40db54:	aa1303e0 	mov	x0, x19
  40db58:	79402281 	ldrh	w1, [x20, #16]
  40db5c:	94000de1 	bl	4112e0 <zcbor_list_start_encode>
  40db60:	12001c15 	and	w21, w0, #0xff
    uint8_t sizes[] = { sizeof(bool),    sizeof(uint8_t),  sizeof(int8_t),  sizeof(uint16_t),
  40db64:	90000062 	adrp	x2, 419000 <__func__.2+0xa80>
  40db68:	9138fc42 	add	x2, x2, #0xe3f
        size_t type_size = thingset_type_size(array->element_type);
  40db6c:	b9400a81 	ldr	w1, [x20, #8]
  40db70:	9101a3e0 	add	x0, sp, #0x68
  40db74:	f9400043 	ldr	x3, [x2]
  40db78:	f90037e3 	str	x3, [sp, #104]
  40db7c:	b8407042 	ldur	w2, [x2, #7]
  40db80:	b806f3e2 	stur	w2, [sp, #111]
    return type < sizeof(sizes) ? sizes[type] : 0;
  40db84:	12001c22 	and	w2, w1, #0xff
  40db88:	7100285f 	cmp	w2, #0xa
  40db8c:	54000168 	b.hi	40dbb8 <bin_serialize_value+0x260>  // b.pmore
  40db90:	92401c21 	and	x1, x1, #0xff
  40db94:	38616818 	ldrb	w24, [x0, x1]
        for (int i = 0; i < array->num_elements; i++) {
  40db98:	d2800017 	mov	x23, #0x0                   	// #0
  40db9c:	52800016 	mov	w22, #0x0                   	// #0
  40dba0:	79402281 	ldrh	w1, [x20, #16]
  40dba4:	6b16003f 	cmp	w1, w22
  40dba8:	540000cc 	b.gt	40dbc0 <bin_serialize_value+0x268>
        success = success && zcbor_list_end_encode(ts->encoder, array->num_elements);
  40dbac:	34fff9b5 	cbz	w21, 40dae0 <bin_serialize_value+0x188>
  40dbb0:	92403c21 	and	x1, x1, #0xffff
  40dbb4:	17ffffac 	b	40da64 <bin_serialize_value+0x10c>
  40dbb8:	d2800018 	mov	x24, #0x0                   	// #0
  40dbbc:	17fffff7 	b	40db98 <bin_serialize_value+0x240>
                bin_serialize_simple_value(ts->encoder, data, array->element_type, array->decimals);
  40dbc0:	79c01a83 	ldrsh	w3, [x20, #12]
  40dbc4:	aa1303e0 	mov	x0, x19
  40dbc8:	b9400a82 	ldr	w2, [x20, #8]
            union thingset_data_pointer data = { .u8 = array->elements.u8 + i * type_size };
  40dbcc:	f9400281 	ldr	x1, [x20]
                bin_serialize_simple_value(ts->encoder, data, array->element_type, array->decimals);
  40dbd0:	8b170021 	add	x1, x1, x23
            if (err != 0) {
  40dbd4:	8b1802f7 	add	x23, x23, x24
                bin_serialize_simple_value(ts->encoder, data, array->element_type, array->decimals);
  40dbd8:	97fffef5 	bl	40d7ac <bin_serialize_simple_value>
            if (err != 0) {
  40dbdc:	35ffeea0 	cbnz	w0, 40d9b0 <bin_serialize_value+0x58>
        for (int i = 0; i < array->num_elements; i++) {
  40dbe0:	110006d6 	add	w22, w22, #0x1
  40dbe4:	17ffffef 	b	40dba0 <bin_serialize_value+0x248>
    if (object->type == THINGSET_TYPE_GROUP) {
  40dbe8:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40dbec:	17ffff71 	b	40d9b0 <bin_serialize_value+0x58>
}
  40dbf0:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dbf4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40dbf8:	a94363f7 	ldp	x23, x24, [sp, #48]
  40dbfc:	f94023f9 	ldr	x25, [sp, #64]
  40dc00:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40dc04:	d65f03c0 	ret

000000000040dc08 <thingset_bin_desire>:
}
  40dc08:	12801800 	mov	w0, #0xffffff3f            	// #-193
  40dc0c:	d65f03c0 	ret

000000000040dc10 <thingset_bin_setup>:
    .deserialize_value = bin_deserialize_value,
    .deserialize_finish = bin_deserialize_finish,
};

inline void thingset_bin_setup(struct thingset_context *ts, size_t rsp_buf_offset)
{
  40dc10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    ts->api = &bin_api;

    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg + 1, ts->msg_len - 1,
  40dc14:	d2800024 	mov	x4, #0x1                   	// #1
{
  40dc18:	910003fd 	mov	x29, sp
  40dc1c:	a90153f3 	stp	x19, x20, [sp, #16]
  40dc20:	aa0003f3 	mov	x19, x0
    ts->api = &bin_api;
  40dc24:	b0000120 	adrp	x0, 432000 <__dso_handle>
  40dc28:	91236000 	add	x0, x0, #0x8d8
{
  40dc2c:	aa0103f4 	mov	x20, x1
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg + 1, ts->msg_len - 1,
  40dc30:	a9438e62 	ldp	x2, x3, [x19, #56]
    ts->api = &bin_api;
  40dc34:	f9003a60 	str	x0, [x19, #112]
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg + 1, ts->msg_len - 1,
  40dc38:	d2800081 	mov	x1, #0x4                   	// #4
  40dc3c:	9104e260 	add	x0, x19, #0x138
  40dc40:	8b040042 	add	x2, x2, x4
  40dc44:	d1000463 	sub	x3, x3, #0x1
  40dc48:	94000c3e 	bl	410d40 <zcbor_new_decode_state>
                           1);

    zcbor_new_encode_state(ts->encoder, ZCBOR_ARRAY_SIZE(ts->encoder), ts->rsp + rsp_buf_offset,
  40dc4c:	a9458e62 	ldp	x2, x3, [x19, #88]
  40dc50:	9101e260 	add	x0, x19, #0x78
  40dc54:	d2800024 	mov	x4, #0x1                   	// #1
  40dc58:	d2800081 	mov	x1, #0x4                   	// #4
  40dc5c:	cb140063 	sub	x3, x3, x20
  40dc60:	8b140042 	add	x2, x2, x20
                           ts->rsp_size - rsp_buf_offset, 1);
}
  40dc64:	a94153f3 	ldp	x19, x20, [sp, #16]
  40dc68:	a8c27bfd 	ldp	x29, x30, [sp], #32
    zcbor_new_encode_state(ts->encoder, ZCBOR_ARRAY_SIZE(ts->encoder), ts->rsp + rsp_buf_offset,
  40dc6c:	14000dbe 	b	411364 <zcbor_new_encode_state>

000000000040dc70 <thingset_bin_process>:

    return ts->api->deserialize_finish(ts);
}

int thingset_bin_process(struct thingset_context *ts)
{
  40dc70:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  40dc74:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40dc78:	910003fd 	mov	x29, sp
  40dc7c:	f9475c21 	ldr	x1, [x1, #3768]
  40dc80:	a90153f3 	stp	x19, x20, [sp, #16]
  40dc84:	aa0003f3 	mov	x19, x0
  40dc88:	f9400022 	ldr	x2, [x1]
  40dc8c:	f9001fe2 	str	x2, [sp, #56]
  40dc90:	d2800002 	mov	x2, #0x0                   	// #0
    if (zcbor_tstr_decode(ts->decoder, &path) == true) {
  40dc94:	9104e274 	add	x20, x19, #0x138
    int ret;

    thingset_bin_setup(ts, 1);
  40dc98:	d2800021 	mov	x1, #0x1                   	// #1
  40dc9c:	97ffffdd 	bl	40dc10 <thingset_bin_setup>
    if (zcbor_tstr_decode(ts->decoder, &path) == true) {
  40dca0:	9100a3e1 	add	x1, sp, #0x28
  40dca4:	aa1403e0 	mov	x0, x20
  40dca8:	94000b96 	bl	410b00 <zcbor_tstr_decode>
  40dcac:	72001c1f 	tst	w0, #0xff
  40dcb0:	54000460 	b.eq	40dd3c <thingset_bin_process+0xcc>  // b.none
        err = thingset_endpoint_by_path(ts, &ts->endpoint, path.value, path.len);
  40dcb4:	a9428fe2 	ldp	x2, x3, [sp, #40]
  40dcb8:	910ee261 	add	x1, x19, #0x3b8
  40dcbc:	aa1303e0 	mov	x0, x19
  40dcc0:	97fffbd1 	bl	40cc04 <thingset_endpoint_by_path>
    if (err != 0) {
  40dcc4:	35000580 	cbnz	w0, 40dd74 <thingset_bin_process+0x104>
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg_payload,
  40dcc8:	a9438e60 	ldp	x0, x3, [x19, #56]
  40dccc:	d2800024 	mov	x4, #0x1                   	// #1
    ts->msg_payload = ts->decoder->payload;
  40dcd0:	f9409e62 	ldr	x2, [x19, #312]
  40dcd4:	f9002a62 	str	x2, [x19, #80]
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg_payload,
  40dcd8:	d2800081 	mov	x1, #0x4                   	// #4
                           ts->msg_len - (ts->msg_payload - ts->msg), 1);
  40dcdc:	cb000040 	sub	x0, x2, x0
    zcbor_new_decode_state(ts->decoder, ZCBOR_ARRAY_SIZE(ts->decoder), ts->msg_payload,
  40dce0:	cb000063 	sub	x3, x3, x0
  40dce4:	aa1403e0 	mov	x0, x20
  40dce8:	94000c16 	bl	410d40 <zcbor_new_decode_state>
    if (ret != 0) {
        ts->api->serialize_finish(ts);
        return ts->rsp_pos;
    }

    ts->api->serialize_response(ts, THINGSET_STATUS_CONTENT, NULL);
  40dcec:	f9403a60 	ldr	x0, [x19, #112]
  40dcf0:	d2800002 	mov	x2, #0x0                   	// #0
  40dcf4:	12800f41 	mov	w1, #0xffffff85            	// #-123
  40dcf8:	f9400003 	ldr	x3, [x0]
  40dcfc:	aa1303e0 	mov	x0, x19
  40dd00:	d63f0060 	blr	x3

    /* requests ordered with expected highest probability first */
    switch (ts->msg[0]) {
  40dd04:	f9401e60 	ldr	x0, [x19, #56]
  40dd08:	39400000 	ldrb	w0, [x0]
  40dd0c:	71001c1f 	cmp	w0, #0x7
  40dd10:	540005a8 	b.hi	40ddc4 <thingset_bin_process+0x154>  // b.pmore
  40dd14:	340005c0 	cbz	w0, 40ddcc <thingset_bin_process+0x15c>
  40dd18:	51000400 	sub	w0, w0, #0x1
  40dd1c:	7100181f 	cmp	w0, #0x6
  40dd20:	54000568 	b.hi	40ddcc <thingset_bin_process+0x15c>  // b.pmore
  40dd24:	d0000041 	adrp	x1, 417000 <z_abort_timeout+0x38>
  40dd28:	913b6021 	add	x1, x1, #0xed8
  40dd2c:	38604821 	ldrb	w1, [x1, w0, uxtw]
  40dd30:	10000060 	adr	x0, 40dd3c <thingset_bin_process+0xcc>
  40dd34:	8b218801 	add	x1, x0, w1, sxtb #2
  40dd38:	d61f0020 	br	x1
    else if (zcbor_uint32_decode(ts->decoder, &id) == true && id <= UINT16_MAX) {
  40dd3c:	910093e1 	add	x1, sp, #0x24
  40dd40:	aa1403e0 	mov	x0, x20
  40dd44:	94000b6d 	bl	410af8 <zcbor_uint32_decode>
  40dd48:	72001c1f 	tst	w0, #0xff
  40dd4c:	54000120 	b.eq	40dd70 <thingset_bin_process+0x100>  // b.none
  40dd50:	b94027e2 	ldr	w2, [sp, #36]
  40dd54:	529fffe0 	mov	w0, #0xffff                	// #65535
  40dd58:	6b00005f 	cmp	w2, w0
  40dd5c:	540000a8 	b.hi	40dd70 <thingset_bin_process+0x100>  // b.pmore
        err = thingset_endpoint_by_id(ts, &ts->endpoint, id);
  40dd60:	910ee261 	add	x1, x19, #0x3b8
  40dd64:	aa1303e0 	mov	x0, x19
  40dd68:	97fffc04 	bl	40cd78 <thingset_endpoint_by_id>
  40dd6c:	17ffffd6 	b	40dcc4 <thingset_bin_process+0x54>
    int err = -THINGSET_ERR_NOT_FOUND;
  40dd70:	12801460 	mov	w0, #0xffffff5c            	// #-164
        ts->api->serialize_response(ts, -err, "Invalid endpoint");
  40dd74:	f9403a61 	ldr	x1, [x19, #112]
  40dd78:	90000062 	adrp	x2, 419000 <__func__.2+0xa80>
  40dd7c:	91392c42 	add	x2, x2, #0xe4b
  40dd80:	f9400023 	ldr	x3, [x1]
  40dd84:	4b0003e1 	neg	w1, w0
  40dd88:	aa1303e0 	mov	x0, x19
  40dd8c:	d63f0060 	blr	x3
        default:
            return -THINGSET_ERR_BAD_REQUEST;
    }

    if (ts->msg[0] != THINGSET_BIN_DESIRE) {
        ts->api->serialize_finish(ts);
  40dd90:	f9403a60 	ldr	x0, [x19, #112]
  40dd94:	f9402c01 	ldr	x1, [x0, #88]
  40dd98:	aa1303e0 	mov	x0, x19
  40dd9c:	d63f0020 	blr	x1
        return ts->rsp_pos;
  40dda0:	b9406a60 	ldr	w0, [x19, #104]
    }
    else {
        ts->rsp_pos = 0;
        return ret;
    }
}
  40dda4:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40dda8:	f9475c21 	ldr	x1, [x1, #3768]
  40ddac:	f9401fe3 	ldr	x3, [sp, #56]
  40ddb0:	f9400022 	ldr	x2, [x1]
  40ddb4:	eb020063 	subs	x3, x3, x2
  40ddb8:	d2800002 	mov	x2, #0x0                   	// #0
  40ddbc:	54000400 	b.eq	40de3c <thingset_bin_process+0x1cc>  // b.none
  40ddc0:	97ffcdd8 	bl	401520 <__stack_chk_fail@plt>
    switch (ts->msg[0]) {
  40ddc4:	7100741f 	cmp	w0, #0x1d
  40ddc8:	54000340 	b.eq	40de30 <thingset_bin_process+0x1c0>  // b.none
  40ddcc:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40ddd0:	17fffff5 	b	40dda4 <thingset_bin_process+0x134>
            ret = thingset_common_get(ts);
  40ddd4:	aa1303e0 	mov	x0, x19
  40ddd8:	940000d5 	bl	40e12c <thingset_common_get>
    if (ts->msg[0] != THINGSET_BIN_DESIRE) {
  40dddc:	f9401e61 	ldr	x1, [x19, #56]
  40dde0:	39400021 	ldrb	w1, [x1]
  40dde4:	7100743f 	cmp	w1, #0x1d
  40dde8:	54fffd41 	b.ne	40dd90 <thingset_bin_process+0x120>  // b.any
        ts->rsp_pos = 0;
  40ddec:	f900367f 	str	xzr, [x19, #104]
        return ret;
  40ddf0:	17ffffed 	b	40dda4 <thingset_bin_process+0x134>
            ret = thingset_common_fetch(ts);
  40ddf4:	aa1303e0 	mov	x0, x19
  40ddf8:	940000fe 	bl	40e1f0 <thingset_common_fetch>
            break;
  40ddfc:	17fffff8 	b	40dddc <thingset_bin_process+0x16c>
            ret = thingset_common_update(ts);
  40de00:	aa1303e0 	mov	x0, x19
  40de04:	940001b8 	bl	40e4e4 <thingset_common_update>
            break;
  40de08:	17fffff5 	b	40dddc <thingset_bin_process+0x16c>
            ret = thingset_common_exec(ts);
  40de0c:	aa1303e0 	mov	x0, x19
  40de10:	94000257 	bl	40e76c <thingset_common_exec>
            break;
  40de14:	17fffff2 	b	40dddc <thingset_bin_process+0x16c>
            ret = thingset_common_create(ts);
  40de18:	aa1303e0 	mov	x0, x19
  40de1c:	9400038a 	bl	40ec44 <thingset_common_create>
            break;
  40de20:	17ffffef 	b	40dddc <thingset_bin_process+0x16c>
            ret = thingset_common_delete(ts);
  40de24:	aa1303e0 	mov	x0, x19
  40de28:	94000389 	bl	40ec4c <thingset_common_delete>
            break;
  40de2c:	17ffffec 	b	40dddc <thingset_bin_process+0x16c>
            ret = thingset_bin_desire(ts);
  40de30:	aa1303e0 	mov	x0, x19
  40de34:	97ffff75 	bl	40dc08 <thingset_bin_desire>
            break;
  40de38:	17ffffe9 	b	40dddc <thingset_bin_process+0x16c>
}
  40de3c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40de40:	a8c47bfd 	ldp	x29, x30, [sp], #64
  40de44:	d65f03c0 	ret

000000000040de48 <thingset_common_serialize_group>:
#include <stdlib.h>
#include <string.h>

int thingset_common_serialize_group(struct thingset_context *ts,
                                    const struct thingset_data_object *object)
{
  40de48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40de4c:	910003fd 	mov	x29, sp
  40de50:	a90153f3 	stp	x19, x20, [sp, #16]
  40de54:	aa0103f4 	mov	x20, x1
  40de58:	aa0003f3 	mov	x19, x0
  40de5c:	f90013f5 	str	x21, [sp, #32]
    int err;

    err = ts->api->serialize_map_start(ts);
  40de60:	f9403801 	ldr	x1, [x0, #112]
  40de64:	f9401421 	ldr	x1, [x1, #40]
  40de68:	d63f0020 	blr	x1
    if (err != 0) {
  40de6c:	35000580 	cbnz	w0, 40df1c <thingset_common_serialize_group+0xd4>
        return err;
    }

    if (object->data.group_callback != NULL) {
  40de70:	f9400a81 	ldr	x1, [x20, #16]
  40de74:	b4000041 	cbz	x1, 40de7c <thingset_common_serialize_group+0x34>
        object->data.group_callback(THINGSET_CALLBACK_PRE_READ);
  40de78:	d63f0020 	blr	x1
{
  40de7c:	52800015 	mov	w21, #0x0                   	// #0
    }

    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40de80:	f9400660 	ldr	x0, [x19, #8]
  40de84:	2a1503e1 	mov	w1, w21
  40de88:	eb35401f 	cmp	x0, w21, uxtw
  40de8c:	540001a8 	b.hi	40dec0 <thingset_common_serialize_group+0x78>  // b.pmore
                return err;
            }
        }
    }

    if (object->data.group_callback != NULL) {
  40de90:	f9400a81 	ldr	x1, [x20, #16]
  40de94:	b4000061 	cbz	x1, 40dea0 <thingset_common_serialize_group+0x58>
        object->data.group_callback(THINGSET_CALLBACK_POST_READ);
  40de98:	52800020 	mov	w0, #0x1                   	// #1
  40de9c:	d63f0020 	blr	x1
    }

    return ts->api->serialize_map_end(ts);
  40dea0:	f9403a60 	ldr	x0, [x19, #112]
}
  40dea4:	f94013f5 	ldr	x21, [sp, #32]
    return ts->api->serialize_map_end(ts);
  40dea8:	f9401801 	ldr	x1, [x0, #48]
  40deac:	aa1303e0 	mov	x0, x19
}
  40deb0:	a94153f3 	ldp	x19, x20, [sp, #16]
    return ts->api->serialize_map_end(ts);
  40deb4:	aa0103f0 	mov	x16, x1
}
  40deb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    return ts->api->serialize_map_end(ts);
  40debc:	d61f0200 	br	x16
        if (ts->data_objects[i].parent_id == object->id
  40dec0:	f9400260 	ldr	x0, [x19]
  40dec4:	d37be822 	lsl	x2, x1, #5
  40dec8:	8b011401 	add	x1, x0, x1, lsl #5
  40decc:	78626802 	ldrh	w2, [x0, x2]
  40ded0:	79400680 	ldrh	w0, [x20, #2]
  40ded4:	6b00005f 	cmp	w2, w0
  40ded8:	54000060 	b.eq	40dee4 <thingset_common_serialize_group+0x9c>  // b.none
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40dedc:	110006b5 	add	w21, w21, #0x1
  40dee0:	17ffffe8 	b	40de80 <thingset_common_serialize_group+0x38>
            && (ts->data_objects[i].access & THINGSET_READ_MASK))
  40dee4:	f9400c20 	ldr	x0, [x1, #24]
  40dee8:	720f0c1f 	tst	w0, #0x1e0000
  40deec:	54ffff80 	b.eq	40dedc <thingset_common_serialize_group+0x94>  // b.none
            err = ts->api->serialize_key_value(ts, &ts->data_objects[i]);
  40def0:	f9403a60 	ldr	x0, [x19, #112]
  40def4:	f9401002 	ldr	x2, [x0, #32]
  40def8:	aa1303e0 	mov	x0, x19
  40defc:	d63f0040 	blr	x2
  40df00:	2a0003e2 	mov	w2, w0
            if (err != 0) {
  40df04:	34fffec0 	cbz	w0, 40dedc <thingset_common_serialize_group+0x94>
}
  40df08:	2a0203e0 	mov	w0, w2
  40df0c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40df10:	f94013f5 	ldr	x21, [sp, #32]
  40df14:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40df18:	d65f03c0 	ret
  40df1c:	2a0003e2 	mov	w2, w0
  40df20:	17fffffa 	b	40df08 <thingset_common_serialize_group+0xc0>

000000000040df24 <thingset_common_serialize_record>:

int thingset_common_serialize_record(struct thingset_context *ts,
                                     const struct thingset_data_object *object, int record_index)
{
  40df24:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  40df28:	910003fd 	mov	x29, sp
  40df2c:	a90363f7 	stp	x23, x24, [sp, #48]
  40df30:	aa0103f7 	mov	x23, x1
  40df34:	90000121 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40df38:	a90153f3 	stp	x19, x20, [sp, #16]
  40df3c:	a9025bf5 	stp	x21, x22, [sp, #32]
  40df40:	2a0203f5 	mov	w21, w2
  40df44:	a9046bf9 	stp	x25, x26, [sp, #64]
    struct thingset_records *records = object->data.records;
  40df48:	f9400af9 	ldr	x25, [x23, #16]
{
  40df4c:	f9475c21 	ldr	x1, [x1, #3768]
  40df50:	f9400022 	ldr	x2, [x1]
  40df54:	f90047e2 	str	x2, [sp, #136]
  40df58:	d2800002 	mov	x2, #0x0                   	// #0
    size_t record_offset;
    int err;

    if (record_index >= records->num_records) {
  40df5c:	79402721 	ldrh	w1, [x25, #18]
  40df60:	6b15003f 	cmp	w1, w21
  40df64:	54000c8d 	b.le	40e0f4 <thingset_common_serialize_record+0x1d0>
        return -THINGSET_ERR_NOT_FOUND;
    }

    err = ts->api->serialize_map_start(ts);
  40df68:	f9403801 	ldr	x1, [x0, #112]
  40df6c:	aa0003f3 	mov	x19, x0
  40df70:	f9401421 	ldr	x1, [x1, #40]
  40df74:	d63f0020 	blr	x1
    if (err != 0) {
  40df78:	35000c00 	cbnz	w0, 40e0f8 <thingset_common_serialize_record+0x1d4>
        return err;
    }

    if (object->detail == THINGSET_DETAIL_DYN_RECORDS) {
  40df7c:	b9401ae0 	ldr	w0, [x23, #24]
  40df80:	321b2fe1 	mov	w1, #0x1ffe0               	// #131040
  40df84:	121b2c00 	and	w0, w0, #0x1ffe0
  40df88:	6b01001f 	cmp	w0, w1
  40df8c:	540003a0 	b.eq	40e000 <thingset_common_serialize_record+0xdc>  // b.none
        record_offset = 0;
    }
    else {
        record_offset = record_index * records->record_size;
  40df90:	f9400720 	ldr	x0, [x25, #8]
  40df94:	93407eb6 	sxtw	x22, w21
  40df98:	9b007ed6 	mul	x22, x22, x0
    }

    if (records->callback != NULL) {
  40df9c:	f9400f22 	ldr	x2, [x25, #24]
  40dfa0:	b4000082 	cbz	x2, 40dfb0 <thingset_common_serialize_record+0x8c>
        records->callback(THINGSET_CALLBACK_PRE_READ, record_index);
  40dfa4:	2a1503e1 	mov	w1, w21
  40dfa8:	52800000 	mov	w0, #0x0                   	// #0
  40dfac:	d63f0040 	blr	x2
    }

    /* record item definitions are expected to start behind record data object */
    const struct thingset_data_object *item = object + 1;
  40dfb0:	910082f4 	add	x20, x23, #0x20
  40dfb4:	9101a3fa 	add	x26, sp, #0x68
                arr->element_type,
                arr->decimals,
                arr->max_elements,
                arr->num_elements,
            };
            struct thingset_data_object item_offset = {
  40dfb8:	910143f8 	add	x24, sp, #0x50
    while (item < &ts->data_objects[ts->num_objects]) {
  40dfbc:	a9400261 	ldp	x1, x0, [x19]
  40dfc0:	8b001420 	add	x0, x1, x0, lsl #5
  40dfc4:	eb00029f 	cmp	x20, x0
  40dfc8:	54000203 	b.cc	40e008 <thingset_common_serialize_record+0xe4>  // b.lo, b.ul, b.last
        }

        item++;
    }

    if (records->callback != NULL) {
  40dfcc:	f9400f22 	ldr	x2, [x25, #24]
  40dfd0:	b4000082 	cbz	x2, 40dfe0 <thingset_common_serialize_record+0xbc>
        records->callback(THINGSET_CALLBACK_POST_READ, record_index);
  40dfd4:	2a1503e1 	mov	w1, w21
  40dfd8:	52800020 	mov	w0, #0x1                   	// #1
  40dfdc:	d63f0040 	blr	x2
    }

    return ts->api->serialize_map_end(ts);
  40dfe0:	90000120 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40dfe4:	f9475c00 	ldr	x0, [x0, #3768]
  40dfe8:	f94047e2 	ldr	x2, [sp, #136]
  40dfec:	f9400001 	ldr	x1, [x0]
  40dff0:	eb010042 	subs	x2, x2, x1
  40dff4:	d2800001 	mov	x1, #0x0                   	// #0
  40dff8:	540006a0 	b.eq	40e0cc <thingset_common_serialize_record+0x1a8>  // b.none
}
  40dffc:	97ffcd49 	bl	401520 <__stack_chk_fail@plt>
        record_offset = 0;
  40e000:	d2800016 	mov	x22, #0x0                   	// #0
  40e004:	17ffffe6 	b	40df9c <thingset_common_serialize_record+0x78>
        if (item->parent_id != object->id) {
  40e008:	79400280 	ldrh	w0, [x20]
  40e00c:	794006e5 	ldrh	w5, [x23, #2]
  40e010:	6b0000bf 	cmp	w5, w0
  40e014:	540004a1 	b.ne	40e0a8 <thingset_common_serialize_record+0x184>  // b.any
            err = ts->api->serialize_key_value(ts, &item_offset);
  40e018:	f9403a66 	ldr	x6, [x19, #112]
                { .array = &arr_offset }, item->type, item->detail,
  40e01c:	f9400e83 	ldr	x3, [x20, #24]
        uint8_t *record_ptr = (uint8_t *)records->records + record_offset;
  40e020:	f9400322 	ldr	x2, [x25]
                { .array = &arr_offset }, item->type, item->detail,
  40e024:	12001060 	and	w0, w3, #0x1f
            err = ts->api->serialize_key_value(ts, &item_offset);
  40e028:	f94010c7 	ldr	x7, [x6, #32]
                { .array = &arr_offset }, item->type, item->detail,
  40e02c:	93454063 	sbfx	x3, x3, #5, #12
        if (item->type == THINGSET_TYPE_ARRAY) {
  40e030:	b9401a86 	ldr	w6, [x20, #24]
        uint8_t *record_ptr = (uint8_t *)records->records + record_offset;
  40e034:	8b160042 	add	x2, x2, x22
                item->parent_id,          item->id,   item->name,
  40e038:	79400688 	ldrh	w8, [x20, #2]
                { .array = &arr_offset }, item->type, item->detail,
  40e03c:	13003c63 	sxth	w3, w3
        if (item->type == THINGSET_TYPE_ARRAY) {
  40e040:	120010c6 	and	w6, w6, #0x1f
            struct thingset_array *arr = item->data.array;
  40e044:	a9409281 	ldp	x1, x4, [x20, #8]
        if (item->type == THINGSET_TYPE_ARRAY) {
  40e048:	710034df 	cmp	w6, #0xd
  40e04c:	54000321 	b.ne	40e0b0 <thingset_common_serialize_record+0x18c>  // b.any
                { .u8 = record_ptr + arr->elements.offset },
  40e050:	f9400086 	ldr	x6, [x4]
  40e054:	8b060042 	add	x2, x2, x6
            struct thingset_array arr_offset = {
  40e058:	f9002be2 	str	x2, [sp, #80]
                arr->element_type,
  40e05c:	b9400882 	ldr	w2, [x4, #8]
            struct thingset_array arr_offset = {
  40e060:	b9005be2 	str	w2, [sp, #88]
                arr->decimals,
  40e064:	79c01882 	ldrsh	w2, [x4, #12]
            struct thingset_array arr_offset = {
  40e068:	7900bbe2 	strh	w2, [sp, #92]
                arr->max_elements,
  40e06c:	79401c82 	ldrh	w2, [x4, #14]
            struct thingset_array arr_offset = {
  40e070:	7900bfe2 	strh	w2, [sp, #94]
                arr->num_elements,
  40e074:	79402082 	ldrh	w2, [x4, #16]
            struct thingset_data_object item_offset = {
  40e078:	a906ffff 	stp	xzr, xzr, [sp, #104]
  40e07c:	a907ffff 	stp	xzr, xzr, [sp, #120]
            struct thingset_array arr_offset = {
  40e080:	7900c3e2 	strh	w2, [sp, #96]
            struct thingset_data_object item_offset = {
  40e084:	7900d3e5 	strh	w5, [sp, #104]
  40e088:	7900d7e8 	strh	w8, [sp, #106]
  40e08c:	a90763e1 	stp	x1, x24, [sp, #112]
            struct thingset_data_object item_offset = {
  40e090:	331b2c60 	bfi	w0, w3, #5, #12
  40e094:	b90083e0 	str	w0, [sp, #128]
            err = ts->api->serialize_key_value(ts, &item_offset);
  40e098:	aa1a03e1 	mov	x1, x26
  40e09c:	aa1303e0 	mov	x0, x19
  40e0a0:	d63f00e0 	blr	x7
        if (err != 0) {
  40e0a4:	350002a0 	cbnz	w0, 40e0f8 <thingset_common_serialize_record+0x1d4>
  40e0a8:	91008294 	add	x20, x20, #0x20
  40e0ac:	17ffffc4 	b	40dfbc <thingset_common_serialize_record+0x98>
            struct thingset_data_object item_offset = {
  40e0b0:	a906ffff 	stp	xzr, xzr, [sp, #104]
                item->parent_id, item->id,     item->name, { .u8 = record_ptr + item->data.offset },
  40e0b4:	8b040042 	add	x2, x2, x4
            struct thingset_data_object item_offset = {
  40e0b8:	a907ffff 	stp	xzr, xzr, [sp, #120]
  40e0bc:	7900d3e5 	strh	w5, [sp, #104]
  40e0c0:	7900d7e8 	strh	w8, [sp, #106]
  40e0c4:	a9070be1 	stp	x1, x2, [sp, #112]
  40e0c8:	17fffff2 	b	40e090 <thingset_common_serialize_record+0x16c>
    return ts->api->serialize_map_end(ts);
  40e0cc:	f9403a60 	ldr	x0, [x19, #112]
}
  40e0d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    return ts->api->serialize_map_end(ts);
  40e0d4:	f9401801 	ldr	x1, [x0, #48]
  40e0d8:	aa1303e0 	mov	x0, x19
}
  40e0dc:	a94153f3 	ldp	x19, x20, [sp, #16]
    return ts->api->serialize_map_end(ts);
  40e0e0:	aa0103f0 	mov	x16, x1
}
  40e0e4:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e0e8:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40e0ec:	a8c97bfd 	ldp	x29, x30, [sp], #144
    return ts->api->serialize_map_end(ts);
  40e0f0:	d61f0200 	br	x16
        return -THINGSET_ERR_NOT_FOUND;
  40e0f4:	12801460 	mov	w0, #0xffffff5c            	// #-164
}
  40e0f8:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40e0fc:	f9475c21 	ldr	x1, [x1, #3768]
  40e100:	f94047e3 	ldr	x3, [sp, #136]
  40e104:	f9400022 	ldr	x2, [x1]
  40e108:	eb020063 	subs	x3, x3, x2
  40e10c:	d2800002 	mov	x2, #0x0                   	// #0
  40e110:	54fff761 	b.ne	40dffc <thingset_common_serialize_record+0xd8>  // b.any
  40e114:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e118:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e11c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40e120:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40e124:	a8c97bfd 	ldp	x29, x30, [sp], #144
  40e128:	d65f03c0 	ret

000000000040e12c <thingset_common_get>:

int thingset_common_get(struct thingset_context *ts)
{
  40e12c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    int err;

    ts->api->serialize_response(ts, THINGSET_STATUS_CONTENT, NULL);
  40e130:	d2800002 	mov	x2, #0x0                   	// #0
{
  40e134:	910003fd 	mov	x29, sp
  40e138:	f9000bf3 	str	x19, [sp, #16]
  40e13c:	aa0003f3 	mov	x19, x0
    ts->api->serialize_response(ts, THINGSET_STATUS_CONTENT, NULL);
  40e140:	f9403801 	ldr	x1, [x0, #112]
  40e144:	f9400023 	ldr	x3, [x1]
  40e148:	12800f41 	mov	w1, #0xffffff85            	// #-123
  40e14c:	d63f0060 	blr	x3

    switch (ts->endpoint.object->type) {
  40e150:	f941de61 	ldr	x1, [x19, #952]
  40e154:	f9400c20 	ldr	x0, [x1, #24]
  40e158:	12001000 	and	w0, w0, #0x1f
  40e15c:	71003c1f 	cmp	w0, #0xf
  40e160:	540002e0 	b.eq	40e1bc <thingset_common_get+0x90>  // b.none
  40e164:	54000108 	b.hi	40e184 <thingset_common_get+0x58>  // b.pmore
  40e168:	7100381f 	cmp	w0, #0xe
  40e16c:	54000360 	b.eq	40e1d8 <thingset_common_get+0xac>  // b.none
                err = thingset_common_serialize_record(ts, ts->endpoint.object, ts->endpoint.index);
                break;
            }
            /* fallthrough */
        default:
            err = ts->api->serialize_value(ts, ts->endpoint.object);
  40e170:	f9403a60 	ldr	x0, [x19, #112]
  40e174:	f9400802 	ldr	x2, [x0, #16]
  40e178:	aa1303e0 	mov	x0, x19
  40e17c:	d63f0040 	blr	x2
            break;
  40e180:	14000011 	b	40e1c4 <thingset_common_get+0x98>
    switch (ts->endpoint.object->type) {
  40e184:	11003c00 	add	w0, w0, #0xf
  40e188:	12001000 	and	w0, w0, #0x1f
  40e18c:	7100041f 	cmp	w0, #0x1
  40e190:	54ffff08 	b.hi	40e170 <thingset_common_get+0x44>  // b.pmore
  40e194:	128013e0 	mov	w0, #0xffffff60            	// #-160

    if (err == 0) {
        return ts->rsp_pos;
    }
    else {
        return ts->api->serialize_response(ts, -err, NULL);
  40e198:	f9403a61 	ldr	x1, [x19, #112]
  40e19c:	d2800002 	mov	x2, #0x0                   	// #0
  40e1a0:	f9400023 	ldr	x3, [x1]
  40e1a4:	4b0003e1 	neg	w1, w0
  40e1a8:	aa1303e0 	mov	x0, x19
    }
}
  40e1ac:	f9400bf3 	ldr	x19, [sp, #16]
        return ts->api->serialize_response(ts, -err, NULL);
  40e1b0:	aa0303f0 	mov	x16, x3
}
  40e1b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
        return ts->api->serialize_response(ts, -err, NULL);
  40e1b8:	d61f0200 	br	x16
            err = thingset_common_serialize_group(ts, ts->endpoint.object);
  40e1bc:	aa1303e0 	mov	x0, x19
  40e1c0:	97ffff22 	bl	40de48 <thingset_common_serialize_group>
    if (err == 0) {
  40e1c4:	35fffea0 	cbnz	w0, 40e198 <thingset_common_get+0x6c>
        return ts->rsp_pos;
  40e1c8:	f9403660 	ldr	x0, [x19, #104]
}
  40e1cc:	f9400bf3 	ldr	x19, [sp, #16]
  40e1d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40e1d4:	d65f03c0 	ret
            if (ts->endpoint.index != THINGSET_ENDPOINT_INDEX_NONE) {
  40e1d8:	b943c262 	ldr	w2, [x19, #960]
  40e1dc:	3100045f 	cmn	w2, #0x1
  40e1e0:	54fffc80 	b.eq	40e170 <thingset_common_get+0x44>  // b.none
                err = thingset_common_serialize_record(ts, ts->endpoint.object, ts->endpoint.index);
  40e1e4:	aa1303e0 	mov	x0, x19
  40e1e8:	97ffff4f 	bl	40df24 <thingset_common_serialize_record>
                break;
  40e1ec:	17fffff6 	b	40e1c4 <thingset_common_get+0x98>

000000000040e1f0 <thingset_common_fetch>:

int thingset_common_fetch(struct thingset_context *ts)
{
  40e1f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  40e1f4:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40e1f8:	910003fd 	mov	x29, sp
  40e1fc:	f9475c21 	ldr	x1, [x1, #3768]
  40e200:	a90153f3 	stp	x19, x20, [sp, #16]
  40e204:	aa0003f3 	mov	x19, x0
  40e208:	f9400022 	ldr	x2, [x1]
  40e20c:	f90017e2 	str	x2, [sp, #40]
  40e210:	d2800002 	mov	x2, #0x0                   	// #0
    int err;

    /* initialize response with success message */
    ts->api->serialize_response(ts, THINGSET_STATUS_CONTENT, NULL);
  40e214:	f9403801 	ldr	x1, [x0, #112]
  40e218:	f9400023 	ldr	x3, [x1]
  40e21c:	12800f41 	mov	w1, #0xffffff85            	// #-123
  40e220:	d63f0060 	blr	x3

    ts->api->serialize_list_start(ts);
  40e224:	f9403a60 	ldr	x0, [x19, #112]
  40e228:	f9401c01 	ldr	x1, [x0, #56]
  40e22c:	aa1303e0 	mov	x0, x19
  40e230:	d63f0020 	blr	x1

    if (ts->api->deserialize_null(ts) == 0) {
  40e234:	f9403a60 	ldr	x0, [x19, #112]
  40e238:	f9403801 	ldr	x1, [x0, #112]
  40e23c:	aa1303e0 	mov	x0, x19
  40e240:	d63f0020 	blr	x1
  40e244:	34000920 	cbz	w0, 40e368 <thingset_common_fetch+0x178>
                    return ts->api->serialize_response(ts, -err, NULL);
                }
            }
        }
    }
    else if (ts->api->deserialize_list_start(ts) == 0) {
  40e248:	f9403a60 	ldr	x0, [x19, #112]
  40e24c:	f9403c01 	ldr	x1, [x0, #120]
  40e250:	aa1303e0 	mov	x0, x19
  40e254:	d63f0020 	blr	x1
  40e258:	350012c0 	cbnz	w0, 40e4b0 <thingset_common_fetch+0x2c0>
        if (ts->endpoint.object->type != THINGSET_TYPE_GROUP) {
  40e25c:	f941de61 	ldr	x1, [x19, #952]
  40e260:	b9401822 	ldr	w2, [x1, #24]
  40e264:	12001042 	and	w2, w2, #0x1f
  40e268:	71003c5f 	cmp	w2, #0xf
  40e26c:	54000820 	b.eq	40e370 <thingset_common_fetch+0x180>  // b.none
            return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "%s is not a group",
  40e270:	f0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40e274:	f9475c00 	ldr	x0, [x0, #3768]
  40e278:	f94017e3 	ldr	x3, [sp, #40]
  40e27c:	f9400002 	ldr	x2, [x0]
  40e280:	eb020063 	subs	x3, x3, x2
  40e284:	d2800002 	mov	x2, #0x0                   	// #0
  40e288:	54000441 	b.ne	40e310 <thingset_common_fetch+0x120>  // b.any
  40e28c:	f9403a60 	ldr	x0, [x19, #112]
  40e290:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e294:	f9400423 	ldr	x3, [x1, #8]
  40e298:	91397042 	add	x2, x2, #0xe5c
  40e29c:	f9400004 	ldr	x4, [x0]
  40e2a0:	aa1303e0 	mov	x0, x19
    }

    ts->api->serialize_list_end(ts);

    return 0;
}
  40e2a4:	a94153f3 	ldp	x19, x20, [sp, #16]
            return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "%s is not a group",
  40e2a8:	aa0403f0 	mov	x16, x4
}
  40e2ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
            return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "%s is not a group",
  40e2b0:	12800be1 	mov	w1, #0xffffffa0            	// #-96
  40e2b4:	d61f0200 	br	x16
            if ((ts->data_objects[i].access & THINGSET_READ_MASK)
  40e2b8:	f9400260 	ldr	x0, [x19]
  40e2bc:	d37be823 	lsl	x3, x1, #5
  40e2c0:	8b011401 	add	x1, x0, x1, lsl #5
  40e2c4:	f9400c24 	ldr	x4, [x1, #24]
  40e2c8:	720f0c9f 	tst	w4, #0x1e0000
  40e2cc:	54000360 	b.eq	40e338 <thingset_common_fetch+0x148>  // b.none
                && (ts->data_objects[i].parent_id == ts->endpoint.object->id))
  40e2d0:	f941de64 	ldr	x4, [x19, #952]
  40e2d4:	78636803 	ldrh	w3, [x0, x3]
  40e2d8:	79400480 	ldrh	w0, [x4, #2]
  40e2dc:	6b00007f 	cmp	w3, w0
  40e2e0:	540002c1 	b.ne	40e338 <thingset_common_fetch+0x148>  // b.any
                err = ts->api->serialize_key(ts, &ts->data_objects[i]);
  40e2e4:	f9400442 	ldr	x2, [x2, #8]
  40e2e8:	aa1303e0 	mov	x0, x19
  40e2ec:	d63f0040 	blr	x2
                if (err != 0) {
  40e2f0:	34000240 	cbz	w0, 40e338 <thingset_common_fetch+0x148>
                    return ts->api->serialize_response(ts, -err, NULL);
  40e2f4:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40e2f8:	f9475c21 	ldr	x1, [x1, #3768]
  40e2fc:	f94017e3 	ldr	x3, [sp, #40]
  40e300:	f9400022 	ldr	x2, [x1]
  40e304:	eb020063 	subs	x3, x3, x2
  40e308:	d2800002 	mov	x2, #0x0                   	// #0
  40e30c:	54000040 	b.eq	40e314 <thingset_common_fetch+0x124>  // b.none
}
  40e310:	97ffcc84 	bl	401520 <__stack_chk_fail@plt>
                    return ts->api->serialize_response(ts, -err, NULL);
  40e314:	f9403a61 	ldr	x1, [x19, #112]
  40e318:	d2800002 	mov	x2, #0x0                   	// #0
  40e31c:	f9400023 	ldr	x3, [x1]
  40e320:	4b0003e1 	neg	w1, w0
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Invalid payload");
  40e324:	aa1303e0 	mov	x0, x19
  40e328:	aa0303f0 	mov	x16, x3
}
  40e32c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e330:	a8c37bfd 	ldp	x29, x30, [sp], #48
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Invalid payload");
  40e334:	d61f0200 	br	x16
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40e338:	11000694 	add	w20, w20, #0x1
  40e33c:	f9400660 	ldr	x0, [x19, #8]
  40e340:	2a1403e1 	mov	w1, w20
                err = ts->api->serialize_key(ts, &ts->data_objects[i]);
  40e344:	f9403a62 	ldr	x2, [x19, #112]
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40e348:	eb34401f 	cmp	x0, w20, uxtw
  40e34c:	54fffb68 	b.hi	40e2b8 <thingset_common_fetch+0xc8>  // b.pmore
    ts->api->serialize_list_end(ts);
  40e350:	f9403a60 	ldr	x0, [x19, #112]
  40e354:	f9402001 	ldr	x1, [x0, #64]
  40e358:	aa1303e0 	mov	x0, x19
  40e35c:	d63f0020 	blr	x1
    return 0;
  40e360:	52800000 	mov	w0, #0x0                   	// #0
  40e364:	1400002c 	b	40e414 <thingset_common_fetch+0x224>
        for (unsigned int i = 0; i < ts->num_objects; i++) {
  40e368:	52800014 	mov	w20, #0x0                   	// #0
  40e36c:	17fffff4 	b	40e33c <thingset_common_fetch+0x14c>
        if (ts->endpoint.object->data.group_callback != NULL) {
  40e370:	f9400821 	ldr	x1, [x1, #16]
  40e374:	b4000041 	cbz	x1, 40e37c <thingset_common_fetch+0x18c>
            ts->endpoint.object->data.group_callback(THINGSET_CALLBACK_PRE_READ);
  40e378:	d63f0020 	blr	x1
        while ((err = ts->api->deserialize_child(ts, &object))
  40e37c:	910083f4 	add	x20, sp, #0x20
  40e380:	f9403a60 	ldr	x0, [x19, #112]
  40e384:	aa1403e1 	mov	x1, x20
  40e388:	f9404402 	ldr	x2, [x0, #136]
  40e38c:	aa1303e0 	mov	x0, x19
  40e390:	d63f0040 	blr	x2
               != -THINGSET_ERR_DESERIALIZATION_FINISHED)
  40e394:	3103c01f 	cmn	w0, #0xf0
  40e398:	540000e1 	b.ne	40e3b4 <thingset_common_fetch+0x1c4>  // b.any
        if (ts->endpoint.object->data.group_callback != NULL) {
  40e39c:	f941de60 	ldr	x0, [x19, #952]
  40e3a0:	f9400801 	ldr	x1, [x0, #16]
  40e3a4:	b4fffd61 	cbz	x1, 40e350 <thingset_common_fetch+0x160>
            ts->endpoint.object->data.group_callback(THINGSET_CALLBACK_POST_READ);
  40e3a8:	52800020 	mov	w0, #0x1                   	// #1
  40e3ac:	d63f0020 	blr	x1
  40e3b0:	17ffffe8 	b	40e350 <thingset_common_fetch+0x160>
            if (err != 0) {
  40e3b4:	f9403a62 	ldr	x2, [x19, #112]
  40e3b8:	340000e0 	cbz	w0, 40e3d4 <thingset_common_fetch+0x1e4>
                return ts->api->serialize_response(ts, -err, NULL);
  40e3bc:	f9400043 	ldr	x3, [x2]
                return ts->api->serialize_response(ts, -err, NULL);
  40e3c0:	4b0003e1 	neg	w1, w0
  40e3c4:	d2800002 	mov	x2, #0x0                   	// #0
  40e3c8:	aa1303e0 	mov	x0, x19
  40e3cc:	d63f0060 	blr	x3
  40e3d0:	14000011 	b	40e414 <thingset_common_fetch+0x224>
            if (object->type == THINGSET_TYPE_GROUP && ts->endpoint.object->id != THINGSET_ID_PATHS)
  40e3d4:	f94013e1 	ldr	x1, [sp, #32]
  40e3d8:	b9401820 	ldr	w0, [x1, #24]
  40e3dc:	12001000 	and	w0, w0, #0x1f
  40e3e0:	71003c1f 	cmp	w0, #0xf
  40e3e4:	540002c1 	b.ne	40e43c <thingset_common_fetch+0x24c>  // b.any
  40e3e8:	f941de60 	ldr	x0, [x19, #952]
  40e3ec:	79400400 	ldrh	w0, [x0, #2]
  40e3f0:	71005c1f 	cmp	w0, #0x17
  40e3f4:	54000240 	b.eq	40e43c <thingset_common_fetch+0x24c>  // b.none
                return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "%s is a group",
  40e3f8:	f9400044 	ldr	x4, [x2]
  40e3fc:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e400:	9139b842 	add	x2, x2, #0xe6e
  40e404:	f9400423 	ldr	x3, [x1, #8]
  40e408:	12800be1 	mov	w1, #0xffffffa0            	// #-96
                    return ts->api->serialize_response(ts, THINGSET_ERR_FORBIDDEN,
  40e40c:	aa1303e0 	mov	x0, x19
  40e410:	d63f0080 	blr	x4
}
  40e414:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40e418:	f9475c21 	ldr	x1, [x1, #3768]
  40e41c:	f94017e3 	ldr	x3, [sp, #40]
  40e420:	f9400022 	ldr	x2, [x1]
  40e424:	eb020063 	subs	x3, x3, x2
  40e428:	d2800002 	mov	x2, #0x0                   	// #0
  40e42c:	54fff721 	b.ne	40e310 <thingset_common_fetch+0x120>  // b.any
  40e430:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e434:	a8c37bfd 	ldp	x29, x30, [sp], #48
  40e438:	d65f03c0 	ret
            if ((object->access & THINGSET_READ_MASK & ts->auth_flags) == 0) {
  40e43c:	f9400c20 	ldr	x0, [x1, #24]
  40e440:	394ea263 	ldrb	w3, [x19, #936]
  40e444:	53115000 	ubfx	w0, w0, #17, #4
  40e448:	6a03001f 	tst	w0, w3
  40e44c:	54000181 	b.ne	40e47c <thingset_common_fetch+0x28c>  // b.any
                return ts->api->serialize_response(ts, -err, NULL);
  40e450:	f9400044 	ldr	x4, [x2]
                                                   object->name);
  40e454:	f9400423 	ldr	x3, [x1, #8]
                if (object->access & THINGSET_READ_MASK) {
  40e458:	340000a0 	cbz	w0, 40e46c <thingset_common_fetch+0x27c>
                    return ts->api->serialize_response(ts, THINGSET_ERR_UNAUTHORIZED,
  40e45c:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e460:	12800bc1 	mov	w1, #0xffffffa1            	// #-95
  40e464:	9139f042 	add	x2, x2, #0xe7c
  40e468:	17ffffe9 	b	40e40c <thingset_common_fetch+0x21c>
                    return ts->api->serialize_response(ts, THINGSET_ERR_FORBIDDEN,
  40e46c:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e470:	12800b81 	mov	w1, #0xffffffa3            	// #-93
  40e474:	913a6c42 	add	x2, x2, #0xe9b
  40e478:	17ffffe5 	b	40e40c <thingset_common_fetch+0x21c>
            if (ts->endpoint.object->id == THINGSET_ID_PATHS) {
  40e47c:	f941de60 	ldr	x0, [x19, #952]
  40e480:	79400400 	ldrh	w0, [x0, #2]
  40e484:	71005c1f 	cmp	w0, #0x17
  40e488:	54000101 	b.ne	40e4a8 <thingset_common_fetch+0x2b8>  // b.any
                err = ts->api->serialize_path(ts, object);
  40e48c:	f9400c42 	ldr	x2, [x2, #24]
                err = ts->api->serialize_value(ts, object);
  40e490:	aa1303e0 	mov	x0, x19
  40e494:	d63f0040 	blr	x2
            if (err != 0) {
  40e498:	34fff740 	cbz	w0, 40e380 <thingset_common_fetch+0x190>
                return ts->api->serialize_response(ts, -err, NULL);
  40e49c:	f9403a61 	ldr	x1, [x19, #112]
  40e4a0:	f9400023 	ldr	x3, [x1]
  40e4a4:	17ffffc7 	b	40e3c0 <thingset_common_fetch+0x1d0>
                err = ts->api->serialize_value(ts, object);
  40e4a8:	f9400842 	ldr	x2, [x2, #16]
  40e4ac:	17fffff9 	b	40e490 <thingset_common_fetch+0x2a0>
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Invalid payload");
  40e4b0:	f0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40e4b4:	f9475c00 	ldr	x0, [x0, #3768]
  40e4b8:	f94017e2 	ldr	x2, [sp, #40]
  40e4bc:	f9400001 	ldr	x1, [x0]
  40e4c0:	eb010042 	subs	x2, x2, x1
  40e4c4:	d2800001 	mov	x1, #0x0                   	// #0
  40e4c8:	54fff241 	b.ne	40e310 <thingset_common_fetch+0x120>  // b.any
  40e4cc:	f9403a60 	ldr	x0, [x19, #112]
  40e4d0:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e4d4:	12800be1 	mov	w1, #0xffffffa0            	// #-96
  40e4d8:	913ac042 	add	x2, x2, #0xeb0
  40e4dc:	f9400003 	ldr	x3, [x0]
  40e4e0:	17ffff91 	b	40e324 <thingset_common_fetch+0x134>

000000000040e4e4 <thingset_common_update>:

int thingset_common_update(struct thingset_context *ts)
{
  40e4e4:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40e4e8:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40e4ec:	910003fd 	mov	x29, sp
  40e4f0:	f9475c21 	ldr	x1, [x1, #3768]
  40e4f4:	a90153f3 	stp	x19, x20, [sp, #16]
  40e4f8:	aa0003f3 	mov	x19, x0
  40e4fc:	a9025bf5 	stp	x21, x22, [sp, #32]
  40e500:	f9001bf7 	str	x23, [sp, #48]
  40e504:	f9400022 	ldr	x2, [x1]
  40e508:	f9003fe2 	str	x2, [sp, #120]
  40e50c:	d2800002 	mov	x2, #0x0                   	// #0
    const struct thingset_data_object *object;
    bool updated = false;
    int err;

    err = ts->api->deserialize_map_start(ts);
  40e510:	f9403801 	ldr	x1, [x0, #112]
  40e514:	f9404021 	ldr	x1, [x1, #128]
  40e518:	d63f0020 	blr	x1
    if (err != 0) {
  40e51c:	35000620 	cbnz	w0, 40e5e0 <thingset_common_update+0xfc>
         */
        uint8_t dummy_data[8];
        uint8_t *data = object->type == THINGSET_TYPE_BYTES || object->type == THINGSET_TYPE_ARRAY
                            ? object->data.u8
                            : dummy_data;
        struct thingset_data_object dummy_object = {
  40e520:	f0000054 	adrp	x20, 419000 <__func__.2+0xa80>
    while ((err = ts->api->deserialize_child(ts, &object))
  40e524:	910123f5 	add	x21, sp, #0x48
                            : dummy_data;
  40e528:	9101c3f6 	add	x22, sp, #0x70
        struct thingset_data_object dummy_object = {
  40e52c:	913bb294 	add	x20, x20, #0xeec
            0, 0, "Dummy", { .u8 = data }, object->type, object->detail
        };

        err = ts->api->deserialize_value(ts, &dummy_object, true);
  40e530:	910143f7 	add	x23, sp, #0x50
    while ((err = ts->api->deserialize_child(ts, &object))
  40e534:	f9403a60 	ldr	x0, [x19, #112]
  40e538:	aa1503e1 	mov	x1, x21
  40e53c:	f9404402 	ldr	x2, [x0, #136]
  40e540:	aa1303e0 	mov	x0, x19
  40e544:	d63f0040 	blr	x2
           != -THINGSET_ERR_DESERIALIZATION_FINISHED)
  40e548:	3103c01f 	cmn	w0, #0xf0
  40e54c:	f9403a62 	ldr	x2, [x19, #112]
  40e550:	54000701 	b.ne	40e630 <thingset_common_update+0x14c>  // b.any
        if (err != 0) {
            return ts->api->serialize_response(ts, -err, NULL);
        }
    }

    ts->api->deserialize_payload_reset(ts);
  40e554:	f9403041 	ldr	x1, [x2, #96]
  40e558:	aa1303e0 	mov	x0, x19
  40e55c:	d63f0020 	blr	x1
    ts->api->deserialize_map_start(ts);
  40e560:	f9403a60 	ldr	x0, [x19, #112]
  40e564:	f9404001 	ldr	x1, [x0, #128]
  40e568:	aa1303e0 	mov	x0, x19
  40e56c:	d63f0020 	blr	x1

    if (ts->endpoint.object->data.group_callback != NULL) {
  40e570:	f941de60 	ldr	x0, [x19, #952]
  40e574:	f9400801 	ldr	x1, [x0, #16]
  40e578:	b4000061 	cbz	x1, 40e584 <thingset_common_update+0xa0>
        ts->endpoint.object->data.group_callback(THINGSET_CALLBACK_PRE_WRITE);
  40e57c:	52800040 	mov	w0, #0x2                   	// #2
  40e580:	d63f0020 	blr	x1
        if (err != 0) {
            return ts->api->serialize_response(ts, -err, NULL);
        }

        if (ts->update_subsets & object->subsets) {
            updated = true;
  40e584:	52800014 	mov	w20, #0x0                   	// #0
  40e588:	52800036 	mov	w22, #0x1                   	// #1
    while ((err = ts->api->deserialize_child(ts, &object))
  40e58c:	f9403a60 	ldr	x0, [x19, #112]
  40e590:	aa1503e1 	mov	x1, x21
  40e594:	f9404402 	ldr	x2, [x0, #136]
  40e598:	aa1303e0 	mov	x0, x19
  40e59c:	d63f0040 	blr	x2
           != -THINGSET_ERR_DESERIALIZATION_FINISHED)
  40e5a0:	3103c01f 	cmn	w0, #0xf0
  40e5a4:	54000ca1 	b.ne	40e738 <thingset_common_update+0x254>  // b.any
        }
    }

    if (updated && ts->update_cb != NULL) {
  40e5a8:	34000094 	cbz	w20, 40e5b8 <thingset_common_update+0xd4>
  40e5ac:	f941da60 	ldr	x0, [x19, #944]
  40e5b0:	b4000040 	cbz	x0, 40e5b8 <thingset_common_update+0xd4>
        ts->update_cb();
  40e5b4:	d63f0000 	blr	x0
    }

    if (ts->endpoint.object->data.group_callback != NULL) {
  40e5b8:	f941de60 	ldr	x0, [x19, #952]
  40e5bc:	f9400801 	ldr	x1, [x0, #16]
  40e5c0:	b4000061 	cbz	x1, 40e5cc <thingset_common_update+0xe8>
        ts->endpoint.object->data.group_callback(THINGSET_CALLBACK_POST_WRITE);
  40e5c4:	52800060 	mov	w0, #0x3                   	// #3
  40e5c8:	d63f0020 	blr	x1
    }

    return ts->api->serialize_response(ts, THINGSET_STATUS_CHANGED, NULL);
  40e5cc:	f9403a60 	ldr	x0, [x19, #112]
  40e5d0:	d2800002 	mov	x2, #0x0                   	// #0
  40e5d4:	12800f61 	mov	w1, #0xffffff84            	// #-124
  40e5d8:	f9400003 	ldr	x3, [x0]
  40e5dc:	14000019 	b	40e640 <thingset_common_update+0x15c>
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Map with data required");
  40e5e0:	f0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40e5e4:	f9475c00 	ldr	x0, [x0, #3768]
  40e5e8:	f9403fe2 	ldr	x2, [sp, #120]
  40e5ec:	f9400001 	ldr	x1, [x0]
  40e5f0:	eb010042 	subs	x2, x2, x1
  40e5f4:	d2800001 	mov	x1, #0x0                   	// #0
  40e5f8:	54000040 	b.eq	40e600 <thingset_common_update+0x11c>  // b.none
}
  40e5fc:	97ffcbc9 	bl	401520 <__stack_chk_fail@plt>
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Map with data required");
  40e600:	f9403a60 	ldr	x0, [x19, #112]
  40e604:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
}
  40e608:	a9425bf5 	ldp	x21, x22, [sp, #32]
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Map with data required");
  40e60c:	913b0042 	add	x2, x2, #0xec0
  40e610:	f9400003 	ldr	x3, [x0]
  40e614:	aa1303e0 	mov	x0, x19
}
  40e618:	a94153f3 	ldp	x19, x20, [sp, #16]
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Map with data required");
  40e61c:	aa0303f0 	mov	x16, x3
}
  40e620:	f9401bf7 	ldr	x23, [sp, #48]
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Map with data required");
  40e624:	12800be1 	mov	w1, #0xffffffa0            	// #-96
}
  40e628:	a8c87bfd 	ldp	x29, x30, [sp], #128
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Map with data required");
  40e62c:	d61f0200 	br	x16
        if (err != 0) {
  40e630:	340000e0 	cbz	w0, 40e64c <thingset_common_update+0x168>
            return ts->api->serialize_response(ts, -err, NULL);
  40e634:	f9400043 	ldr	x3, [x2]
            return ts->api->serialize_response(ts, -err, NULL);
  40e638:	4b0003e1 	neg	w1, w0
  40e63c:	d2800002 	mov	x2, #0x0                   	// #0
    return ts->api->serialize_response(ts, THINGSET_STATUS_CHANGED, NULL);
  40e640:	aa1303e0 	mov	x0, x19
  40e644:	d63f0060 	blr	x3
  40e648:	14000010 	b	40e688 <thingset_common_update+0x1a4>
        if ((object->access & THINGSET_WRITE_MASK & ts->auth_flags) == 0) {
  40e64c:	f94027e1 	ldr	x1, [sp, #72]
  40e650:	394ea263 	ldrb	w3, [x19, #936]
  40e654:	f9400c20 	ldr	x0, [x1, #24]
  40e658:	d3516000 	ubfx	x0, x0, #17, #8
  40e65c:	121c0c00 	and	w0, w0, #0xf0
  40e660:	6a03001f 	tst	w0, w3
  40e664:	54000321 	b.ne	40e6c8 <thingset_common_update+0x1e4>  // b.any
            return ts->api->serialize_response(ts, -err, NULL);
  40e668:	f9400044 	ldr	x4, [x2]
                                                   "Authentication required for %s", object->name);
  40e66c:	f9400423 	ldr	x3, [x1, #8]
            if (object->access & THINGSET_WRITE_MASK) {
  40e670:	34000240 	cbz	w0, 40e6b8 <thingset_common_update+0x1d4>
                return ts->api->serialize_response(ts, THINGSET_ERR_UNAUTHORIZED,
  40e674:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e678:	9139f042 	add	x2, x2, #0xe7c
  40e67c:	12800bc1 	mov	w1, #0xffffffa1            	// #-95
                return ts->api->serialize_response(ts, THINGSET_ERR_FORBIDDEN,
  40e680:	aa1303e0 	mov	x0, x19
  40e684:	d63f0080 	blr	x4
}
  40e688:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40e68c:	f9475c21 	ldr	x1, [x1, #3768]
  40e690:	f9403fe3 	ldr	x3, [sp, #120]
  40e694:	f9400022 	ldr	x2, [x1]
  40e698:	eb020063 	subs	x3, x3, x2
  40e69c:	d2800002 	mov	x2, #0x0                   	// #0
  40e6a0:	54fffae1 	b.ne	40e5fc <thingset_common_update+0x118>  // b.any
  40e6a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e6a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40e6ac:	f9401bf7 	ldr	x23, [sp, #48]
  40e6b0:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40e6b4:	d65f03c0 	ret
                return ts->api->serialize_response(ts, THINGSET_ERR_FORBIDDEN,
  40e6b8:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e6bc:	12800b81 	mov	w1, #0xffffffa3            	// #-93
  40e6c0:	913b5c42 	add	x2, x2, #0xed7
  40e6c4:	17ffffef 	b	40e680 <thingset_common_update+0x19c>
        uint8_t *data = object->type == THINGSET_TYPE_BYTES || object->type == THINGSET_TYPE_ARRAY
  40e6c8:	b9401820 	ldr	w0, [x1, #24]
  40e6cc:	121f0c00 	and	w0, w0, #0x1e
                            : dummy_data;
  40e6d0:	7100301f 	cmp	w0, #0xc
  40e6d4:	540002e1 	b.ne	40e730 <thingset_common_update+0x24c>  // b.any
  40e6d8:	f9400820 	ldr	x0, [x1, #16]
        struct thingset_data_object dummy_object = {
  40e6dc:	a9057fff 	stp	xzr, xzr, [sp, #80]
  40e6e0:	a9067fff 	stp	xzr, xzr, [sp, #96]
            0, 0, "Dummy", { .u8 = data }, object->type, object->detail
  40e6e4:	f9400c23 	ldr	x3, [x1, #24]
        struct thingset_data_object dummy_object = {
  40e6e8:	a90583f4 	stp	x20, x0, [sp, #88]
  40e6ec:	b9406be0 	ldr	w0, [sp, #104]
  40e6f0:	33001060 	bfxil	w0, w3, #0, #5
  40e6f4:	b9006be0 	str	w0, [sp, #104]
            0, 0, "Dummy", { .u8 = data }, object->type, object->detail
  40e6f8:	f9400c21 	ldr	x1, [x1, #24]
  40e6fc:	93454021 	sbfx	x1, x1, #5, #12
  40e700:	13003c21 	sxth	w1, w1
        struct thingset_data_object dummy_object = {
  40e704:	331b2c20 	bfi	w0, w1, #5, #12
  40e708:	b9006be0 	str	w0, [sp, #104]
        err = ts->api->deserialize_value(ts, &dummy_object, true);
  40e70c:	aa1703e1 	mov	x1, x23
  40e710:	aa1303e0 	mov	x0, x19
  40e714:	f9404843 	ldr	x3, [x2, #144]
  40e718:	52800022 	mov	w2, #0x1                   	// #1
  40e71c:	d63f0060 	blr	x3
        if (err != 0) {
  40e720:	34fff0a0 	cbz	w0, 40e534 <thingset_common_update+0x50>
            return ts->api->serialize_response(ts, -err, NULL);
  40e724:	f9403a61 	ldr	x1, [x19, #112]
  40e728:	f9400023 	ldr	x3, [x1]
  40e72c:	17ffffc3 	b	40e638 <thingset_common_update+0x154>
                            : dummy_data;
  40e730:	aa1603e0 	mov	x0, x22
  40e734:	17ffffea 	b	40e6dc <thingset_common_update+0x1f8>
        err = ts->api->deserialize_value(ts, object, false);
  40e738:	f9403a60 	ldr	x0, [x19, #112]
  40e73c:	52800002 	mov	w2, #0x0                   	// #0
  40e740:	f94027e1 	ldr	x1, [sp, #72]
  40e744:	f9404803 	ldr	x3, [x0, #144]
  40e748:	aa1303e0 	mov	x0, x19
  40e74c:	d63f0060 	blr	x3
        if (err != 0) {
  40e750:	35fffea0 	cbnz	w0, 40e724 <thingset_common_update+0x240>
        if (ts->update_subsets & object->subsets) {
  40e754:	f94027e0 	ldr	x0, [sp, #72]
  40e758:	f9400c01 	ldr	x1, [x0, #24]
  40e75c:	394ea660 	ldrb	w0, [x19, #937]
            updated = true;
  40e760:	6a41641f 	tst	w0, w1, lsr #25
  40e764:	1a960294 	csel	w20, w20, w22, eq  // eq = none
  40e768:	17ffff89 	b	40e58c <thingset_common_update+0xa8>

000000000040e76c <thingset_common_exec>:

int thingset_common_exec(struct thingset_context *ts)
{
  40e76c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40e770:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40e774:	910003fd 	mov	x29, sp
  40e778:	f9475c21 	ldr	x1, [x1, #3768]
  40e77c:	a90153f3 	stp	x19, x20, [sp, #16]
  40e780:	aa0003f3 	mov	x19, x0
  40e784:	f90013f5 	str	x21, [sp, #32]
  40e788:	f9400022 	ldr	x2, [x1]
  40e78c:	f9002fe2 	str	x2, [sp, #88]
  40e790:	d2800002 	mov	x2, #0x0                   	// #0
    int err;

    err = ts->api->deserialize_list_start(ts);
  40e794:	f9403801 	ldr	x1, [x0, #112]
  40e798:	f9403c21 	ldr	x1, [x1, #120]
  40e79c:	d63f0020 	blr	x1
    if (err != 0) {
  40e7a0:	34000280 	cbz	w0, 40e7f0 <thingset_common_exec+0x84>
        err = ts->api->deserialize_finish(ts);
  40e7a4:	f9403a60 	ldr	x0, [x19, #112]
  40e7a8:	f9404c01 	ldr	x1, [x0, #152]
  40e7ac:	aa1303e0 	mov	x0, x19
  40e7b0:	d63f0020 	blr	x1
        if (err != 0) {
  40e7b4:	340001e0 	cbz	w0, 40e7f0 <thingset_common_exec+0x84>
            return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Invalid parameters");
  40e7b8:	f0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40e7bc:	f9475c00 	ldr	x0, [x0, #3768]
  40e7c0:	f9402fe2 	ldr	x2, [sp, #88]
  40e7c4:	f9400001 	ldr	x1, [x0]
  40e7c8:	eb010042 	subs	x2, x2, x1
  40e7cc:	d2800001 	mov	x1, #0x0                   	// #0
  40e7d0:	54000040 	b.eq	40e7d8 <thingset_common_exec+0x6c>  // b.none
    else {
        ts->endpoint.object->data.void_fn();
    }

    return 0;
}
  40e7d4:	97ffcb53 	bl	401520 <__stack_chk_fail@plt>
            return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Invalid parameters");
  40e7d8:	f9403a60 	ldr	x0, [x19, #112]
  40e7dc:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e7e0:	913bc842 	add	x2, x2, #0xef2
  40e7e4:	f9400003 	ldr	x3, [x0]
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Too many parameters");
  40e7e8:	12800be1 	mov	w1, #0xffffffa0            	// #-96
  40e7ec:	1400001a 	b	40e854 <thingset_common_exec+0xe8>
    if ((ts->endpoint.object->access & THINGSET_WRITE_MASK)
  40e7f0:	f941de62 	ldr	x2, [x19, #952]
            return ts->api->serialize_response(ts, THINGSET_ERR_UNAUTHORIZED,
  40e7f4:	f9403a63 	ldr	x3, [x19, #112]
    if ((ts->endpoint.object->access & THINGSET_WRITE_MASK)
  40e7f8:	f9400c40 	ldr	x0, [x2, #24]
  40e7fc:	d3516000 	ubfx	x0, x0, #17, #8
  40e800:	721c0c00 	ands	w0, w0, #0xf0
  40e804:	54000340 	b.eq	40e86c <thingset_common_exec+0x100>  // b.none
            || ts->endpoint.object->type == THINGSET_TYPE_FN_I32))
  40e808:	b9401841 	ldr	w1, [x2, #24]
  40e80c:	12001021 	and	w1, w1, #0x1f
  40e810:	51004421 	sub	w1, w1, #0x11
        && (ts->endpoint.object->type == THINGSET_TYPE_FN_VOID
  40e814:	7100043f 	cmp	w1, #0x1
  40e818:	540002a8 	b.hi	40e86c <thingset_common_exec+0x100>  // b.pmore
        if ((ts->endpoint.object->access & THINGSET_WRITE_MASK & ts->auth_flags) == 0) {
  40e81c:	394ea261 	ldrb	w1, [x19, #936]
  40e820:	6a01001f 	tst	w0, w1
  40e824:	54000c41 	b.ne	40e9ac <thingset_common_exec+0x240>  // b.any
            return ts->api->serialize_response(ts, THINGSET_ERR_UNAUTHORIZED,
  40e828:	f0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40e82c:	f9475c00 	ldr	x0, [x0, #3768]
  40e830:	f9402fe2 	ldr	x2, [sp, #88]
  40e834:	f9400001 	ldr	x1, [x0]
  40e838:	eb010042 	subs	x2, x2, x1
  40e83c:	d2800001 	mov	x1, #0x0                   	// #0
  40e840:	54fffca1 	b.ne	40e7d4 <thingset_common_exec+0x68>  // b.any
  40e844:	f9400063 	ldr	x3, [x3]
  40e848:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e84c:	913c1442 	add	x2, x2, #0xf05
  40e850:	12800bc1 	mov	w1, #0xffffffa1            	// #-95
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Too many parameters");
  40e854:	aa1303e0 	mov	x0, x19
  40e858:	aa0303f0 	mov	x16, x3
}
  40e85c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40e860:	f94013f5 	ldr	x21, [sp, #32]
  40e864:	a8c67bfd 	ldp	x29, x30, [sp], #96
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Too many parameters");
  40e868:	d61f0200 	br	x16
        return ts->api->serialize_response(ts, THINGSET_ERR_FORBIDDEN, "%s is not executable",
  40e86c:	f0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40e870:	f9475c00 	ldr	x0, [x0, #3768]
  40e874:	f9402fe4 	ldr	x4, [sp, #88]
  40e878:	f9400001 	ldr	x1, [x0]
  40e87c:	eb010084 	subs	x4, x4, x1
  40e880:	d2800001 	mov	x1, #0x0                   	// #0
  40e884:	54fffa81 	b.ne	40e7d4 <thingset_common_exec+0x68>  // b.any
  40e888:	aa1303e0 	mov	x0, x19
  40e88c:	12800b81 	mov	w1, #0xffffffa3            	// #-93
  40e890:	f9400064 	ldr	x4, [x3]
  40e894:	f9400443 	ldr	x3, [x2, #8]
  40e898:	aa0403f0 	mov	x16, x4
}
  40e89c:	a94153f3 	ldp	x19, x20, [sp, #16]
        return ts->api->serialize_response(ts, THINGSET_ERR_FORBIDDEN, "%s is not executable",
  40e8a0:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
}
  40e8a4:	f94013f5 	ldr	x21, [sp, #32]
        return ts->api->serialize_response(ts, THINGSET_ERR_FORBIDDEN, "%s is not executable",
  40e8a8:	913c7442 	add	x2, x2, #0xf1d
}
  40e8ac:	a8c67bfd 	ldp	x29, x30, [sp], #96
        return ts->api->serialize_response(ts, THINGSET_ERR_FORBIDDEN, "%s is not executable",
  40e8b0:	d61f0200 	br	x16
        if (ts->data_objects[i].parent_id == ts->endpoint.object->id) {
  40e8b4:	f9400262 	ldr	x2, [x19]
  40e8b8:	d37be823 	lsl	x3, x1, #5
  40e8bc:	f941de64 	ldr	x4, [x19, #952]
  40e8c0:	78636843 	ldrh	w3, [x2, x3]
  40e8c4:	8b011441 	add	x1, x2, x1, lsl #5
  40e8c8:	79400482 	ldrh	w2, [x4, #2]
  40e8cc:	6b02007f 	cmp	w3, w2
  40e8d0:	54000401 	b.ne	40e950 <thingset_common_exec+0x1e4>  // b.any
            err = ts->api->deserialize_value(ts, &ts->data_objects[i], false);
  40e8d4:	f9404803 	ldr	x3, [x0, #144]
  40e8d8:	52800002 	mov	w2, #0x0                   	// #0
  40e8dc:	aa1303e0 	mov	x0, x19
  40e8e0:	d63f0060 	blr	x3
            if (err == -THINGSET_ERR_DESERIALIZATION_FINISHED) {
  40e8e4:	3103c01f 	cmn	w0, #0xf0
  40e8e8:	540001a1 	b.ne	40e91c <thingset_common_exec+0x1b0>  // b.any
                return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST,
  40e8ec:	f0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40e8f0:	f9475c00 	ldr	x0, [x0, #3768]
  40e8f4:	f9402fe2 	ldr	x2, [sp, #88]
  40e8f8:	f9400001 	ldr	x1, [x0]
  40e8fc:	eb010042 	subs	x2, x2, x1
  40e900:	d2800001 	mov	x1, #0x0                   	// #0
  40e904:	54fff681 	b.ne	40e7d4 <thingset_common_exec+0x68>  // b.any
  40e908:	f9403a60 	ldr	x0, [x19, #112]
  40e90c:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e910:	913cc842 	add	x2, x2, #0xf32
  40e914:	f9400003 	ldr	x3, [x0]
  40e918:	17ffffb4 	b	40e7e8 <thingset_common_exec+0x7c>
            else if (err != 0) {
  40e91c:	340001a0 	cbz	w0, 40e950 <thingset_common_exec+0x1e4>
                return ts->api->serialize_response(ts, -err, NULL);
  40e920:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40e924:	f9475c21 	ldr	x1, [x1, #3768]
  40e928:	f9402fe3 	ldr	x3, [sp, #88]
  40e92c:	f9400022 	ldr	x2, [x1]
  40e930:	eb020063 	subs	x3, x3, x2
  40e934:	d2800002 	mov	x2, #0x0                   	// #0
  40e938:	54fff4e1 	b.ne	40e7d4 <thingset_common_exec+0x68>  // b.any
  40e93c:	f9403a61 	ldr	x1, [x19, #112]
  40e940:	d2800002 	mov	x2, #0x0                   	// #0
  40e944:	f9400023 	ldr	x3, [x1]
  40e948:	4b0003e1 	neg	w1, w0
  40e94c:	17ffffc2 	b	40e854 <thingset_common_exec+0xe8>
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40e950:	11000694 	add	w20, w20, #0x1
  40e954:	f9400662 	ldr	x2, [x19, #8]
  40e958:	2a1403e1 	mov	w1, w20
            err = ts->api->deserialize_value(ts, &ts->data_objects[i], false);
  40e95c:	f9403a60 	ldr	x0, [x19, #112]
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40e960:	eb34405f 	cmp	x2, w20, uxtw
  40e964:	54fffa88 	b.hi	40e8b4 <thingset_common_exec+0x148>  // b.pmore
    err = ts->api->deserialize_finish(ts);
  40e968:	f9404c01 	ldr	x1, [x0, #152]
  40e96c:	f0000115 	adrp	x21, 431000 <__FRAME_END__+0x10804>
  40e970:	aa1303e0 	mov	x0, x19
  40e974:	d63f0020 	blr	x1
  40e978:	2a0003f4 	mov	w20, w0
    if (err != 0) {
  40e97c:	340001c0 	cbz	w0, 40e9b4 <thingset_common_exec+0x248>
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Too many parameters");
  40e980:	f9475eb5 	ldr	x21, [x21, #3768]
  40e984:	f9402fe0 	ldr	x0, [sp, #88]
  40e988:	f94002a1 	ldr	x1, [x21]
  40e98c:	eb010000 	subs	x0, x0, x1
  40e990:	d2800001 	mov	x1, #0x0                   	// #0
  40e994:	54fff201 	b.ne	40e7d4 <thingset_common_exec+0x68>  // b.any
  40e998:	f9403a60 	ldr	x0, [x19, #112]
  40e99c:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40e9a0:	913d2042 	add	x2, x2, #0xf48
  40e9a4:	f9400003 	ldr	x3, [x0]
  40e9a8:	17ffff90 	b	40e7e8 <thingset_common_exec+0x7c>
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40e9ac:	52800014 	mov	w20, #0x0                   	// #0
  40e9b0:	17ffffe9 	b	40e954 <thingset_common_exec+0x1e8>
    ts->api->serialize_response(ts, THINGSET_STATUS_CHANGED, NULL);
  40e9b4:	f9403a60 	ldr	x0, [x19, #112]
  40e9b8:	12800f61 	mov	w1, #0xffffff84            	// #-124
  40e9bc:	d2800002 	mov	x2, #0x0                   	// #0
  40e9c0:	f9400003 	ldr	x3, [x0]
  40e9c4:	aa1303e0 	mov	x0, x19
  40e9c8:	d63f0060 	blr	x3
    if (ts->endpoint.object->type == THINGSET_TYPE_FN_I32) {
  40e9cc:	f941de60 	ldr	x0, [x19, #952]
  40e9d0:	b9401801 	ldr	w1, [x0, #24]
        int32_t ret = ts->endpoint.object->data.i32_fn();
  40e9d4:	f9400800 	ldr	x0, [x0, #16]
    if (ts->endpoint.object->type == THINGSET_TYPE_FN_I32) {
  40e9d8:	12001021 	and	w1, w1, #0x1f
  40e9dc:	7100483f 	cmp	w1, #0x12
  40e9e0:	54000461 	b.ne	40ea6c <thingset_common_exec+0x300>  // b.any
        int32_t ret = ts->endpoint.object->data.i32_fn();
  40e9e4:	d63f0000 	blr	x0
        struct thingset_data_object ret_object = THINGSET_ITEM_INT32(0, 0, "", &ret, 0, 0);
  40e9e8:	2906ffe0 	stp	w0, wzr, [sp, #52]
  40e9ec:	f0000040 	adrp	x0, 419000 <__func__.2+0xa80>
  40e9f0:	91392800 	add	x0, x0, #0xe4a
  40e9f4:	f90023e0 	str	x0, [sp, #64]
  40e9f8:	9100d3e0 	add	x0, sp, #0x34
  40e9fc:	f90027e0 	str	x0, [sp, #72]
  40ea00:	528000c0 	mov	w0, #0x6                   	// #6
  40ea04:	b90053e0 	str	w0, [sp, #80]
        err = ts->api->serialize_value(ts, &ret_object);
  40ea08:	9100e3e1 	add	x1, sp, #0x38
  40ea0c:	f9403a60 	ldr	x0, [x19, #112]
  40ea10:	f9400802 	ldr	x2, [x0, #16]
  40ea14:	aa1303e0 	mov	x0, x19
  40ea18:	d63f0040 	blr	x2
  40ea1c:	2a0003f4 	mov	w20, w0
        if (err != 0) {
  40ea20:	34000100 	cbz	w0, 40ea40 <thingset_common_exec+0x2d4>
            return ts->api->serialize_response(ts, THINGSET_ERR_RESPONSE_TOO_LARGE, NULL);
  40ea24:	f9403a60 	ldr	x0, [x19, #112]
  40ea28:	d2800002 	mov	x2, #0x0                   	// #0
  40ea2c:	128003c1 	mov	w1, #0xffffffe1            	// #-31
  40ea30:	f9400003 	ldr	x3, [x0]
  40ea34:	aa1303e0 	mov	x0, x19
  40ea38:	d63f0060 	blr	x3
  40ea3c:	2a0003f4 	mov	w20, w0
}
  40ea40:	f9475eb5 	ldr	x21, [x21, #3768]
  40ea44:	f9402fe0 	ldr	x0, [sp, #88]
  40ea48:	f94002a1 	ldr	x1, [x21]
  40ea4c:	eb010000 	subs	x0, x0, x1
  40ea50:	d2800001 	mov	x1, #0x0                   	// #0
  40ea54:	54ffec01 	b.ne	40e7d4 <thingset_common_exec+0x68>  // b.any
  40ea58:	2a1403e0 	mov	w0, w20
  40ea5c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40ea60:	f94013f5 	ldr	x21, [sp, #32]
  40ea64:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40ea68:	d65f03c0 	ret
        ts->endpoint.object->data.void_fn();
  40ea6c:	d63f0000 	blr	x0
  40ea70:	17fffff4 	b	40ea40 <thingset_common_exec+0x2d4>

000000000040ea74 <thingset_common_create_delete>:

int thingset_common_create_delete(struct thingset_context *ts, bool create)
{
  40ea74:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40ea78:	910003fd 	mov	x29, sp
  40ea7c:	f90013f5 	str	x21, [sp, #32]
  40ea80:	12001c35 	and	w21, w1, #0xff
  40ea84:	f0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40ea88:	a90153f3 	stp	x19, x20, [sp, #16]
  40ea8c:	f0000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  40ea90:	f9475c21 	ldr	x1, [x1, #3768]
  40ea94:	f9400022 	ldr	x2, [x1]
  40ea98:	f9002fe2 	str	x2, [sp, #88]
  40ea9c:	d2800002 	mov	x2, #0x0                   	// #0
    if (ts->endpoint.object->id == 0) {
  40eaa0:	f941dc02 	ldr	x2, [x0, #952]
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Endpoint item required");
  40eaa4:	f9403801 	ldr	x1, [x0, #112]
    if (ts->endpoint.object->id == 0) {
  40eaa8:	79400443 	ldrh	w3, [x2, #2]
  40eaac:	35000223 	cbnz	w3, 40eaf0 <thingset_common_create_delete+0x7c>
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Endpoint item required");
  40eab0:	f9475e94 	ldr	x20, [x20, #3768]
  40eab4:	f9402fe2 	ldr	x2, [sp, #88]
  40eab8:	f9400283 	ldr	x3, [x20]
  40eabc:	eb030042 	subs	x2, x2, x3
  40eac0:	d2800003 	mov	x3, #0x0                   	// #0
  40eac4:	54000040 	b.eq	40eacc <thingset_common_create_delete+0x58>  // b.none
        return ts->api->serialize_response(ts, THINGSET_ERR_NOT_FOUND, NULL);
#endif /* CONFIG_THINGSET_IMMUTABLE_OBJECTS */
    }

    return ts->api->serialize_response(ts, THINGSET_ERR_METHOD_NOT_ALLOWED, NULL);
}
  40eac8:	97ffca96 	bl	401520 <__stack_chk_fail@plt>
        return ts->api->serialize_response(ts, THINGSET_ERR_BAD_REQUEST, "Endpoint item required");
  40eacc:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40ead0:	913d7042 	add	x2, x2, #0xf5c
  40ead4:	f9400023 	ldr	x3, [x1]
  40ead8:	12800be1 	mov	w1, #0xffffffa0            	// #-96
}
  40eadc:	a94153f3 	ldp	x19, x20, [sp, #16]
    return ts->api->serialize_response(ts, THINGSET_ERR_METHOD_NOT_ALLOWED, NULL);
  40eae0:	aa0303f0 	mov	x16, x3
}
  40eae4:	f94013f5 	ldr	x21, [sp, #32]
  40eae8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    return ts->api->serialize_response(ts, THINGSET_ERR_METHOD_NOT_ALLOWED, NULL);
  40eaec:	d61f0200 	br	x16
    if (ts->endpoint.object->type == THINGSET_TYPE_ARRAY) {
  40eaf0:	b9401842 	ldr	w2, [x2, #24]
  40eaf4:	12001042 	and	w2, w2, #0x1f
  40eaf8:	7100345f 	cmp	w2, #0xd
  40eafc:	54000181 	b.ne	40eb2c <thingset_common_create_delete+0xb8>  // b.any
        return ts->api->serialize_response(ts, THINGSET_ERR_NOT_IMPLEMENTED,
  40eb00:	f9475e94 	ldr	x20, [x20, #3768]
  40eb04:	f9402fe2 	ldr	x2, [sp, #88]
  40eb08:	f9400283 	ldr	x3, [x20]
  40eb0c:	eb030042 	subs	x2, x2, x3
  40eb10:	d2800003 	mov	x3, #0x0                   	// #0
  40eb14:	54fffda1 	b.ne	40eac8 <thingset_common_create_delete+0x54>  // b.any
  40eb18:	f0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40eb1c:	913dcc42 	add	x2, x2, #0xf73
  40eb20:	f9400023 	ldr	x3, [x1]
  40eb24:	128007c1 	mov	w1, #0xffffffc1            	// #-63
  40eb28:	17ffffed 	b	40eadc <thingset_common_create_delete+0x68>
    else if (ts->endpoint.object->type == THINGSET_TYPE_SUBSET) {
  40eb2c:	7100405f 	cmp	w2, #0x10
  40eb30:	54000761 	b.ne	40ec1c <thingset_common_create_delete+0x1a8>  // b.any
        int err = ts->api->deserialize_string(ts, &str_start, &str_len);
  40eb34:	f9403423 	ldr	x3, [x1, #104]
  40eb38:	aa0003f3 	mov	x19, x0
  40eb3c:	910103e2 	add	x2, sp, #0x40
  40eb40:	9100e3e1 	add	x1, sp, #0x38
  40eb44:	d63f0060 	blr	x3
        if (err != 0) {
  40eb48:	34000220 	cbz	w0, 40eb8c <thingset_common_create_delete+0x118>
            return ts->api->serialize_response(ts, THINGSET_ERR_UNSUPPORTED_FORMAT, NULL);
  40eb4c:	f9403a60 	ldr	x0, [x19, #112]
  40eb50:	d2800002 	mov	x2, #0x0                   	// #0
  40eb54:	12800a01 	mov	w1, #0xffffffaf            	// #-81
  40eb58:	f9400003 	ldr	x3, [x0]
        return ts->api->serialize_response(ts, THINGSET_ERR_NOT_FOUND, NULL);
  40eb5c:	aa1303e0 	mov	x0, x19
  40eb60:	d63f0060 	blr	x3
}
  40eb64:	f9475e94 	ldr	x20, [x20, #3768]
  40eb68:	f9402fe1 	ldr	x1, [sp, #88]
  40eb6c:	f9400282 	ldr	x2, [x20]
  40eb70:	eb020021 	subs	x1, x1, x2
  40eb74:	d2800002 	mov	x2, #0x0                   	// #0
  40eb78:	54fffa81 	b.ne	40eac8 <thingset_common_create_delete+0x54>  // b.any
  40eb7c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40eb80:	f94013f5 	ldr	x21, [sp, #32]
  40eb84:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40eb88:	d65f03c0 	ret
        int ret = thingset_endpoint_by_path(ts, &element, str_start, str_len);
  40eb8c:	a9438fe2 	ldp	x2, x3, [sp, #56]
  40eb90:	910123e1 	add	x1, sp, #0x48
  40eb94:	aa1303e0 	mov	x0, x19
  40eb98:	97fff81b 	bl	40cc04 <thingset_endpoint_by_path>
        if (ret >= 0 && element.index == THINGSET_ENDPOINT_INDEX_NONE) {
  40eb9c:	37f80360 	tbnz	w0, #31, 40ec08 <thingset_common_create_delete+0x194>
  40eba0:	b94053e0 	ldr	w0, [sp, #80]
  40eba4:	3100041f 	cmn	w0, #0x1
  40eba8:	54000301 	b.ne	40ec08 <thingset_common_create_delete+0x194>  // b.any
                element.object->subsets |= ts->endpoint.object->data.subset;
  40ebac:	f94027e2 	ldr	x2, [sp, #72]
  40ebb0:	f941de60 	ldr	x0, [x19, #952]
  40ebb4:	f9400c43 	ldr	x3, [x2, #24]
  40ebb8:	39404001 	ldrb	w1, [x0, #16]
  40ebbc:	b9401840 	ldr	w0, [x2, #24]
  40ebc0:	53197c63 	lsr	w3, w3, #25
            if (create) {
  40ebc4:	34000135 	cbz	w21, 40ebe8 <thingset_common_create_delete+0x174>
                element.object->subsets |= ts->endpoint.object->data.subset;
  40ebc8:	2a030021 	orr	w1, w1, w3
  40ebcc:	33071820 	bfi	w0, w1, #25, #7
  40ebd0:	b9001840 	str	w0, [x2, #24]
                return ts->api->serialize_response(ts, THINGSET_STATUS_CREATED, NULL);
  40ebd4:	12800fc1 	mov	w1, #0xffffff81            	// #-127
  40ebd8:	d2800002 	mov	x2, #0x0                   	// #0
  40ebdc:	f9403a60 	ldr	x0, [x19, #112]
  40ebe0:	f9400003 	ldr	x3, [x0]
  40ebe4:	17ffffde 	b	40eb5c <thingset_common_create_delete+0xe8>
                element.object->subsets &= ~ts->endpoint.object->data.subset;
  40ebe8:	0a210061 	bic	w1, w3, w1
  40ebec:	33071820 	bfi	w0, w1, #25, #7
  40ebf0:	b9001840 	str	w0, [x2, #24]
                return ts->api->serialize_response(ts, THINGSET_STATUS_DELETED, NULL);
  40ebf4:	12800fa1 	mov	w1, #0xffffff82            	// #-126
  40ebf8:	d2800002 	mov	x2, #0x0                   	// #0
  40ebfc:	f9403a60 	ldr	x0, [x19, #112]
  40ec00:	f9400003 	ldr	x3, [x0]
  40ec04:	17ffffd6 	b	40eb5c <thingset_common_create_delete+0xe8>
        return ts->api->serialize_response(ts, THINGSET_ERR_NOT_FOUND, NULL);
  40ec08:	f9403a60 	ldr	x0, [x19, #112]
  40ec0c:	d2800002 	mov	x2, #0x0                   	// #0
  40ec10:	12800b61 	mov	w1, #0xffffffa4            	// #-92
  40ec14:	f9400003 	ldr	x3, [x0]
  40ec18:	17ffffd1 	b	40eb5c <thingset_common_create_delete+0xe8>
    return ts->api->serialize_response(ts, THINGSET_ERR_METHOD_NOT_ALLOWED, NULL);
  40ec1c:	f9475e94 	ldr	x20, [x20, #3768]
  40ec20:	f9402fe2 	ldr	x2, [sp, #88]
  40ec24:	f9400283 	ldr	x3, [x20]
  40ec28:	eb030042 	subs	x2, x2, x3
  40ec2c:	d2800003 	mov	x3, #0x0                   	// #0
  40ec30:	54fff4c1 	b.ne	40eac8 <thingset_common_create_delete+0x54>  // b.any
  40ec34:	d2800002 	mov	x2, #0x0                   	// #0
  40ec38:	f9400023 	ldr	x3, [x1]
  40ec3c:	12800b41 	mov	w1, #0xffffffa5            	// #-91
  40ec40:	17ffffa7 	b	40eadc <thingset_common_create_delete+0x68>

000000000040ec44 <thingset_common_create>:

int thingset_common_create(struct thingset_context *ts)
{
    return thingset_common_create_delete(ts, true);
  40ec44:	52800021 	mov	w1, #0x1                   	// #1
  40ec48:	17ffff8b 	b	40ea74 <thingset_common_create_delete>

000000000040ec4c <thingset_common_delete>:
}

int thingset_common_delete(struct thingset_context *ts)
{
    return thingset_common_create_delete(ts, false);
  40ec4c:	52800001 	mov	w1, #0x0                   	// #0
  40ec50:	17ffff89 	b	40ea74 <thingset_common_create_delete>

000000000040ec54 <txt_serialize_path>:
                              const struct thingset_data_object *object)
{
    /* not used for text mode */

    return -THINGSET_ERR_INTERNAL_SERVER_ERR;
}
  40ec54:	128017e0 	mov	w0, #0xffffff40            	// #-192
  40ec58:	d65f03c0 	ret

000000000040ec5c <txt_serialize_end>:
    }
}

static inline int txt_serialize_end(struct thingset_context *ts, char c)
{
    if (ts->rsp_size > ts->rsp_pos + 3) {
  40ec5c:	a9460804 	ldp	x4, x2, [x0, #96]
{
  40ec60:	12001c21 	and	w1, w1, #0xff
    if (ts->rsp_size > ts->rsp_pos + 3) {
  40ec64:	91000c43 	add	x3, x2, #0x3
  40ec68:	eb03009f 	cmp	x4, x3
  40ec6c:	54000269 	b.ls	40ecb8 <txt_serialize_end+0x5c>  // b.plast
        if (ts->rsp[ts->rsp_pos - 1] == ',') {
  40ec70:	f9402c03 	ldr	x3, [x0, #88]
  40ec74:	d1000442 	sub	x2, x2, #0x1
  40ec78:	38626864 	ldrb	w4, [x3, x2]
  40ec7c:	7100b09f 	cmp	w4, #0x2c
  40ec80:	54000041 	b.ne	40ec88 <txt_serialize_end+0x2c>  // b.any
            ts->rsp_pos--;
  40ec84:	f9003402 	str	x2, [x0, #104]
        }
        ts->rsp[ts->rsp_pos++] = c;
  40ec88:	f9403402 	ldr	x2, [x0, #104]
  40ec8c:	91000444 	add	x4, x2, #0x1
  40ec90:	f9003404 	str	x4, [x0, #104]
  40ec94:	38226861 	strb	w1, [x3, x2]
        ts->rsp[ts->rsp_pos++] = ',';
  40ec98:	f9402c02 	ldr	x2, [x0, #88]
  40ec9c:	f9403401 	ldr	x1, [x0, #104]
  40eca0:	91000423 	add	x3, x1, #0x1
  40eca4:	f9003403 	str	x3, [x0, #104]
  40eca8:	52800580 	mov	w0, #0x2c                  	// #44
  40ecac:	38216840 	strb	w0, [x2, x1]
        return 0;
  40ecb0:	52800000 	mov	w0, #0x0                   	// #0
    }
    else {
        ts->rsp_pos = 0;
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
    }
}
  40ecb4:	d65f03c0 	ret
        ts->rsp_pos = 0;
  40ecb8:	f900341f 	str	xzr, [x0, #104]
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40ecbc:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40ecc0:	17fffffd 	b	40ecb4 <txt_serialize_end+0x58>

000000000040ecc4 <txt_serialize_map_start>:
    if (ts->rsp_size > ts->rsp_pos + 2) {
  40ecc4:	a9460403 	ldp	x3, x1, [x0, #96]
  40ecc8:	91000822 	add	x2, x1, #0x2
  40eccc:	eb02007f 	cmp	x3, x2
  40ecd0:	54000109 	b.ls	40ecf0 <txt_serialize_map_start+0x2c>  // b.plast
        ts->rsp[ts->rsp_pos++] = c;
  40ecd4:	f9402c02 	ldr	x2, [x0, #88]
  40ecd8:	91000423 	add	x3, x1, #0x1
  40ecdc:	f9003403 	str	x3, [x0, #104]
  40ece0:	52800f60 	mov	w0, #0x7b                  	// #123
  40ece4:	38216840 	strb	w0, [x2, x1]
        return 0;
  40ece8:	52800000 	mov	w0, #0x0                   	// #0

static int txt_serialize_map_start(struct thingset_context *ts)
{
    return txt_serialize_start(ts, '{');
}
  40ecec:	d65f03c0 	ret
        ts->rsp_pos = 0;
  40ecf0:	f900341f 	str	xzr, [x0, #104]
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40ecf4:	12801c00 	mov	w0, #0xffffff1f            	// #-225
    return txt_serialize_start(ts, '{');
  40ecf8:	17fffffd 	b	40ecec <txt_serialize_map_start+0x28>

000000000040ecfc <txt_serialize_map_end>:

static int txt_serialize_map_end(struct thingset_context *ts)
{
    return txt_serialize_end(ts, '}');
  40ecfc:	52800fa1 	mov	w1, #0x7d                  	// #125
  40ed00:	17ffffd7 	b	40ec5c <txt_serialize_end>

000000000040ed04 <txt_serialize_list_end>:
    return txt_serialize_start(ts, '[');
}

static int txt_serialize_list_end(struct thingset_context *ts)
{
    return txt_serialize_end(ts, ']');
  40ed04:	52800ba1 	mov	w1, #0x5d                  	// #93
  40ed08:	17ffffd5 	b	40ec5c <txt_serialize_end>

000000000040ed0c <txt_serialize_finish>:
}

static void txt_serialize_finish(struct thingset_context *ts)
{
    /* remove the trailing comma or space (in case of no payload) and terminate string */
    ts->rsp_pos--;
  40ed0c:	f9403401 	ldr	x1, [x0, #104]
  40ed10:	d1000421 	sub	x1, x1, #0x1
  40ed14:	f9003401 	str	x1, [x0, #104]
    ts->rsp[ts->rsp_pos] = '\0';
  40ed18:	f9402c00 	ldr	x0, [x0, #88]
  40ed1c:	3821681f 	strb	wzr, [x0, x1]
}
  40ed20:	d65f03c0 	ret

000000000040ed24 <thingset_txt_desire>:
}

int thingset_txt_desire(struct thingset_context *ts)
{
    return -THINGSET_ERR_NOT_IMPLEMENTED;
}
  40ed24:	12801800 	mov	w0, #0xffffff3f            	// #-193
  40ed28:	d65f03c0 	ret

000000000040ed2c <txt_deserialize_string>:
}

static int txt_deserialize_string(struct thingset_context *ts, const char **str_start,
                                  size_t *str_len)
{
    if (ts->tok_pos < ts->tok_count) {
  40ed2c:	f941cc04 	ldr	x4, [x0, #920]
  40ed30:	f941d003 	ldr	x3, [x0, #928]
  40ed34:	eb04007f 	cmp	x3, x4
  40ed38:	540002a2 	b.cs	40ed8c <txt_deserialize_string+0x60>  // b.hs, b.nlast
        if (ts->tokens[ts->tok_pos].type == JSMN_STRING) {
  40ed3c:	8b031003 	add	x3, x0, x3, lsl #4
  40ed40:	b9407864 	ldr	w4, [x3, #120]
  40ed44:	7100109f 	cmp	w4, #0x4
  40ed48:	54000261 	b.ne	40ed94 <txt_deserialize_string+0x68>  // b.any
            *str_start = ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40ed4c:	b9807c64 	ldrsw	x4, [x3, #124]
  40ed50:	f9402803 	ldr	x3, [x0, #80]
  40ed54:	8b040063 	add	x3, x3, x4
  40ed58:	f9000023 	str	x3, [x1]
            *str_len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40ed5c:	f941d003 	ldr	x3, [x0, #928]
  40ed60:	8b031003 	add	x3, x0, x3, lsl #4
  40ed64:	b9408061 	ldr	w1, [x3, #128]
  40ed68:	b9407c63 	ldr	w3, [x3, #124]
  40ed6c:	4b030021 	sub	w1, w1, w3
  40ed70:	93407c21 	sxtw	x1, w1
  40ed74:	f9000041 	str	x1, [x2]
            ts->tok_pos++;
  40ed78:	f941d001 	ldr	x1, [x0, #928]
  40ed7c:	91000421 	add	x1, x1, #0x1
  40ed80:	f901d001 	str	x1, [x0, #928]
            return 0;
  40ed84:	52800000 	mov	w0, #0x0                   	// #0
        }
    }
    else {
        return -THINGSET_ERR_BAD_REQUEST;
    }
}
  40ed88:	d65f03c0 	ret
        return -THINGSET_ERR_BAD_REQUEST;
  40ed8c:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40ed90:	17fffffe 	b	40ed88 <txt_deserialize_string+0x5c>
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40ed94:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40ed98:	17fffffc 	b	40ed88 <txt_deserialize_string+0x5c>

000000000040ed9c <txt_deserialize_list_start>:
    }
}

static int txt_deserialize_list_start(struct thingset_context *ts)
{
    if (ts->tok_pos < ts->tok_count) {
  40ed9c:	f941cc02 	ldr	x2, [x0, #920]
  40eda0:	f941d001 	ldr	x1, [x0, #928]
  40eda4:	eb02003f 	cmp	x1, x2
  40eda8:	54000122 	b.cs	40edcc <txt_deserialize_list_start+0x30>  // b.hs, b.nlast
        if (ts->tokens[ts->tok_pos].type == JSMN_ARRAY) {
  40edac:	8b011002 	add	x2, x0, x1, lsl #4
  40edb0:	b9407842 	ldr	w2, [x2, #120]
  40edb4:	7100085f 	cmp	w2, #0x2
  40edb8:	540000e1 	b.ne	40edd4 <txt_deserialize_list_start+0x38>  // b.any
            ts->tok_pos++;
  40edbc:	91000421 	add	x1, x1, #0x1
  40edc0:	f901d001 	str	x1, [x0, #928]
            return 0;
  40edc4:	52800000 	mov	w0, #0x0                   	// #0
        }
    }
    else {
        return -THINGSET_ERR_BAD_REQUEST;
    }
}
  40edc8:	d65f03c0 	ret
        return -THINGSET_ERR_BAD_REQUEST;
  40edcc:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40edd0:	17fffffe 	b	40edc8 <txt_deserialize_list_start+0x2c>
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40edd4:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40edd8:	17fffffc 	b	40edc8 <txt_deserialize_list_start+0x2c>

000000000040eddc <txt_deserialize_map_start>:

static int txt_deserialize_map_start(struct thingset_context *ts)
{
    if (ts->tok_pos < ts->tok_count) {
  40eddc:	f941cc02 	ldr	x2, [x0, #920]
  40ede0:	f941d001 	ldr	x1, [x0, #928]
  40ede4:	eb02003f 	cmp	x1, x2
  40ede8:	54000122 	b.cs	40ee0c <txt_deserialize_map_start+0x30>  // b.hs, b.nlast
        if (ts->tokens[ts->tok_pos].type == JSMN_OBJECT) {
  40edec:	8b011002 	add	x2, x0, x1, lsl #4
  40edf0:	b9407842 	ldr	w2, [x2, #120]
  40edf4:	7100045f 	cmp	w2, #0x1
  40edf8:	540000e1 	b.ne	40ee14 <txt_deserialize_map_start+0x38>  // b.any
            ts->tok_pos++;
  40edfc:	91000421 	add	x1, x1, #0x1
  40ee00:	f901d001 	str	x1, [x0, #928]
            return 0;
  40ee04:	52800000 	mov	w0, #0x0                   	// #0
        }
    }
    else {
        return -THINGSET_ERR_BAD_REQUEST;
    }
}
  40ee08:	d65f03c0 	ret
        return -THINGSET_ERR_BAD_REQUEST;
  40ee0c:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40ee10:	17fffffe 	b	40ee08 <txt_deserialize_map_start+0x2c>
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40ee14:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40ee18:	17fffffc 	b	40ee08 <txt_deserialize_map_start+0x2c>

000000000040ee1c <txt_deserialize_finish>:

static int txt_deserialize_finish(struct thingset_context *ts)
{
    return ts->tok_count == ts->tok_pos ? 0 : -THINGSET_ERR_BAD_REQUEST;
  40ee1c:	f941cc01 	ldr	x1, [x0, #920]
  40ee20:	f941d000 	ldr	x0, [x0, #928]
  40ee24:	eb00003f 	cmp	x1, x0
}
  40ee28:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40ee2c:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  40ee30:	d65f03c0 	ret

000000000040ee34 <thingset_txt_get_fetch>:
    if (ts->tok_count == 0) {
  40ee34:	f941cc01 	ldr	x1, [x0, #920]
  40ee38:	b5000041 	cbnz	x1, 40ee40 <thingset_txt_get_fetch+0xc>
        return thingset_common_get(ts);
  40ee3c:	17fffcbc 	b	40e12c <thingset_common_get>
        return thingset_common_fetch(ts);
  40ee40:	17fffcec 	b	40e1f0 <thingset_common_fetch>

000000000040ee44 <txt_deserialize_value>:
{
  40ee44:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  40ee48:	910003fd 	mov	x29, sp
  40ee4c:	a90153f3 	stp	x19, x20, [sp, #16]
  40ee50:	aa0103f3 	mov	x19, x1
  40ee54:	aa0003f4 	mov	x20, x0
  40ee58:	a9025bf5 	stp	x21, x22, [sp, #32]
  40ee5c:	a90363f7 	stp	x23, x24, [sp, #48]
  40ee60:	a9046bf9 	stp	x25, x26, [sp, #64]
    if (ts->tok_pos >= ts->tok_count) {
  40ee64:	f941cc01 	ldr	x1, [x0, #920]
{
  40ee68:	f9002bfb 	str	x27, [sp, #80]
    if (ts->tok_pos >= ts->tok_count) {
  40ee6c:	f941d000 	ldr	x0, [x0, #928]
  40ee70:	eb01001f 	cmp	x0, x1
  40ee74:	54000ec2 	b.cs	40f04c <txt_deserialize_value+0x208>  // b.hs, b.nlast
    const char *buf = ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40ee78:	8b001280 	add	x0, x20, x0, lsl #4
  40ee7c:	f9402a99 	ldr	x25, [x20, #80]
    size_t len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40ee80:	294fdc18 	ldp	w24, w23, [x0, #124]
    if (ts->tokens[ts->tok_pos].type != JSMN_PRIMITIVE
  40ee84:	b9407800 	ldr	w0, [x0, #120]
        && ts->tokens[ts->tok_pos].type != JSMN_STRING)
  40ee88:	7100201f 	cmp	w0, #0x8
    const char *buf = ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40ee8c:	93407f1b 	sxtw	x27, w24
    if (ts->tokens[ts->tok_pos].type != JSMN_PRIMITIVE
  40ee90:	7a441804 	ccmp	w0, #0x4, #0x4, ne  // ne = any
    const char *buf = ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40ee94:	8b38c335 	add	x21, x25, w24, sxtw
    if (ts->tokens[ts->tok_pos].type != JSMN_PRIMITIVE
  40ee98:	54000060 	b.eq	40eea4 <txt_deserialize_value+0x60>  // b.none
    switch (object->type) {
  40ee9c:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40eea0:	1400005d 	b	40f014 <txt_deserialize_value+0x1d0>
  40eea4:	12001c5a 	and	w26, w2, #0xff
    errno = 0;
  40eea8:	97ffc9fe 	bl	4016a0 <__errno_location@plt>
  40eeac:	b900001f 	str	wzr, [x0]
  40eeb0:	aa0003f6 	mov	x22, x0
    switch (object->type) {
  40eeb4:	f9400e61 	ldr	x1, [x19, #24]
  40eeb8:	12001023 	and	w3, w1, #0x1f
  40eebc:	71002c7f 	cmp	w3, #0xb
  40eec0:	54fffee8 	b.hi	40ee9c <txt_deserialize_value+0x58>  // b.pmore
  40eec4:	b0000040 	adrp	x0, 417000 <z_abort_timeout+0x38>
  40eec8:	913b8000 	add	x0, x0, #0xee0
  40eecc:	38634800 	ldrb	w0, [x0, w3, uxtw]
  40eed0:	10000063 	adr	x3, 40eedc <txt_deserialize_value+0x98>
  40eed4:	8b208860 	add	x0, x3, w0, sxtb #2
  40eed8:	d61f0000 	br	x0
            *object->data.f32 = strtod(buf, NULL);
  40eedc:	aa1503e0 	mov	x0, x21
  40eee0:	d2800001 	mov	x1, #0x0                   	// #0
  40eee4:	97ffc937 	bl	4013c0 <strtod@plt>
  40eee8:	1e624000 	fcvt	s0, d0
  40eeec:	f9400a60 	ldr	x0, [x19, #16]
  40eef0:	bd000000 	str	s0, [x0]
    if (errno == ERANGE) {
  40eef4:	b94002c0 	ldr	w0, [x22]
  40eef8:	7100881f 	cmp	w0, #0x22
  40eefc:	54000841 	b.ne	40f004 <txt_deserialize_value+0x1c0>  // b.any
  40ef00:	17ffffe7 	b	40ee9c <txt_deserialize_value+0x58>
            *object->data.u32 = strtoul(buf, NULL, 0);
  40ef04:	aa1503e0 	mov	x0, x21
  40ef08:	52800002 	mov	w2, #0x0                   	// #0
  40ef0c:	d2800001 	mov	x1, #0x0                   	// #0
  40ef10:	97ffc914 	bl	401360 <strtoul@plt>
            *object->data.i32 = strtol(buf, NULL, 0);
  40ef14:	f9400a61 	ldr	x1, [x19, #16]
  40ef18:	b9000020 	str	w0, [x1]
            break;
  40ef1c:	17fffff6 	b	40eef4 <txt_deserialize_value+0xb0>
            *object->data.i32 = strtol(buf, NULL, 0);
  40ef20:	aa1503e0 	mov	x0, x21
  40ef24:	52800002 	mov	w2, #0x0                   	// #0
  40ef28:	d2800001 	mov	x1, #0x0                   	// #0
  40ef2c:	97ffc9a5 	bl	4015c0 <strtol@plt>
  40ef30:	17fffff9 	b	40ef14 <txt_deserialize_value+0xd0>
            *object->data.u16 = strtoul(buf, NULL, 0);
  40ef34:	aa1503e0 	mov	x0, x21
  40ef38:	52800002 	mov	w2, #0x0                   	// #0
  40ef3c:	d2800001 	mov	x1, #0x0                   	// #0
  40ef40:	97ffc908 	bl	401360 <strtoul@plt>
            *object->data.i16 = strtol(buf, NULL, 0);
  40ef44:	f9400a61 	ldr	x1, [x19, #16]
  40ef48:	79000020 	strh	w0, [x1]
            break;
  40ef4c:	17ffffea 	b	40eef4 <txt_deserialize_value+0xb0>
            *object->data.i16 = strtol(buf, NULL, 0);
  40ef50:	aa1503e0 	mov	x0, x21
  40ef54:	52800002 	mov	w2, #0x0                   	// #0
  40ef58:	d2800001 	mov	x1, #0x0                   	// #0
  40ef5c:	97ffc999 	bl	4015c0 <strtol@plt>
  40ef60:	17fffff9 	b	40ef44 <txt_deserialize_value+0x100>
            *object->data.u8 = strtoul(buf, NULL, 0);
  40ef64:	aa1503e0 	mov	x0, x21
  40ef68:	52800002 	mov	w2, #0x0                   	// #0
  40ef6c:	d2800001 	mov	x1, #0x0                   	// #0
  40ef70:	97ffc8fc 	bl	401360 <strtoul@plt>
            *object->data.i8 = strtol(buf, NULL, 0);
  40ef74:	f9400a61 	ldr	x1, [x19, #16]
  40ef78:	39000020 	strb	w0, [x1]
            break;
  40ef7c:	17ffffde 	b	40eef4 <txt_deserialize_value+0xb0>
            *object->data.i8 = strtol(buf, NULL, 0);
  40ef80:	aa1503e0 	mov	x0, x21
  40ef84:	52800002 	mov	w2, #0x0                   	// #0
  40ef88:	d2800001 	mov	x1, #0x0                   	// #0
  40ef8c:	97ffc98d 	bl	4015c0 <strtol@plt>
  40ef90:	17fffff9 	b	40ef74 <txt_deserialize_value+0x130>
            if (buf[0] == 't' || buf[0] == '1') {
  40ef94:	387b6b20 	ldrb	w0, [x25, x27]
  40ef98:	52800621 	mov	w1, #0x31                  	// #49
  40ef9c:	7101d01f 	cmp	w0, #0x74
  40efa0:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40efa4:	540000a1 	b.ne	40efb8 <txt_deserialize_value+0x174>  // b.any
                *object->data.b = true;
  40efa8:	f9400a60 	ldr	x0, [x19, #16]
  40efac:	52800021 	mov	w1, #0x1                   	// #1
  40efb0:	39000001 	strb	w1, [x0]
  40efb4:	17ffffd0 	b	40eef4 <txt_deserialize_value+0xb0>
            else if (buf[0] == 'f' || buf[0] == '0') {
  40efb8:	7101981f 	cmp	w0, #0x66
  40efbc:	52800601 	mov	w1, #0x30                  	// #48
  40efc0:	7a411004 	ccmp	w0, w1, #0x4, ne  // ne = any
  40efc4:	54fff6c1 	b.ne	40ee9c <txt_deserialize_value+0x58>  // b.any
                *object->data.b = false;
  40efc8:	f9400a60 	ldr	x0, [x19, #16]
  40efcc:	3900001f 	strb	wzr, [x0]
  40efd0:	17ffffc9 	b	40eef4 <txt_deserialize_value+0xb0>
            if (ts->tokens[ts->tok_pos].type != JSMN_STRING || (unsigned int)object->detail <= len)
  40efd4:	f941d280 	ldr	x0, [x20, #928]
  40efd8:	8b001280 	add	x0, x20, x0, lsl #4
  40efdc:	b9407800 	ldr	w0, [x0, #120]
  40efe0:	7100101f 	cmp	w0, #0x4
  40efe4:	54000381 	b.ne	40f054 <txt_deserialize_value+0x210>  // b.any
  40efe8:	d371c021 	lsl	x1, x1, #15
    size_t len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40efec:	4b1802e0 	sub	w0, w23, w24
            if (ts->tokens[ts->tok_pos].type != JSMN_STRING || (unsigned int)object->detail <= len)
  40eff0:	13147c21 	asr	w1, w1, #20
    size_t len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40eff4:	93407c17 	sxtw	x23, w0
            if (ts->tokens[ts->tok_pos].type != JSMN_STRING || (unsigned int)object->detail <= len)
  40eff8:	eb20c03f 	cmp	x1, w0, sxtw
  40effc:	540002c9 	b.ls	40f054 <txt_deserialize_value+0x210>  // b.plast
            if (!check_only) {
  40f000:	3400019a 	cbz	w26, 40f030 <txt_deserialize_value+0x1ec>
    ts->tok_pos++;
  40f004:	f941d280 	ldr	x0, [x20, #928]
  40f008:	91000400 	add	x0, x0, #0x1
  40f00c:	f901d280 	str	x0, [x20, #928]
    return 0;
  40f010:	52800000 	mov	w0, #0x0                   	// #0
}
  40f014:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f018:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f01c:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f020:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40f024:	f9402bfb 	ldr	x27, [sp, #80]
  40f028:	a8c67bfd 	ldp	x29, x30, [sp], #96
  40f02c:	d65f03c0 	ret
  40f030:	f9400a60 	ldr	x0, [x19, #16]
  40f034:	aa1703e2 	mov	x2, x23
  40f038:	aa1503e1 	mov	x1, x21
  40f03c:	97ffc98d 	bl	401670 <strncpy@plt>
                object->data.str[len] = '\0';
  40f040:	f9400a60 	ldr	x0, [x19, #16]
  40f044:	3837681f 	strb	wzr, [x0, x23]
  40f048:	17ffffab 	b	40eef4 <txt_deserialize_value+0xb0>
        return -THINGSET_ERR_DESERIALIZATION_FINISHED;
  40f04c:	12801de0 	mov	w0, #0xffffff10            	// #-240
  40f050:	17fffff1 	b	40f014 <txt_deserialize_value+0x1d0>
                return -THINGSET_ERR_REQUEST_TOO_LARGE;
  40f054:	12801580 	mov	w0, #0xffffff53            	// #-173
  40f058:	17ffffef 	b	40f014 <txt_deserialize_value+0x1d0>

000000000040f05c <txt_deserialize_child>:
{
  40f05c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40f060:	910003fd 	mov	x29, sp
  40f064:	a90153f3 	stp	x19, x20, [sp, #16]
  40f068:	aa0103f4 	mov	x20, x1
    if (ts->tok_pos >= ts->tok_count) {
  40f06c:	f941cc01 	ldr	x1, [x0, #920]
  40f070:	f941d003 	ldr	x3, [x0, #928]
  40f074:	eb01007f 	cmp	x3, x1
  40f078:	540002e2 	b.cs	40f0d4 <txt_deserialize_child+0x78>  // b.hs, b.nlast
  40f07c:	8b031003 	add	x3, x0, x3, lsl #4
  40f080:	aa0003f3 	mov	x19, x0
    if (ts->tokens[ts->tok_pos].type != JSMN_STRING) {
  40f084:	b9407861 	ldr	w1, [x3, #120]
  40f088:	7100103f 	cmp	w1, #0x4
  40f08c:	54000281 	b.ne	40f0dc <txt_deserialize_child+0x80>  // b.any
    size_t name_len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40f090:	294f8c61 	ldp	w1, w3, [x3, #124]
    const char *name = (char *)ts->msg_payload + ts->tokens[ts->tok_pos].start;
  40f094:	f9402802 	ldr	x2, [x0, #80]
    size_t name_len = ts->tokens[ts->tok_pos].end - ts->tokens[ts->tok_pos].start;
  40f098:	4b010063 	sub	w3, w3, w1
    *object = thingset_get_child_by_name(ts, ts->endpoint.object->id, name, name_len);
  40f09c:	f941dc04 	ldr	x4, [x0, #952]
  40f0a0:	93407c63 	sxtw	x3, w3
  40f0a4:	8b21c042 	add	x2, x2, w1, sxtw
  40f0a8:	79400481 	ldrh	w1, [x4, #2]
  40f0ac:	97fff69d 	bl	40cb20 <thingset_get_child_by_name>
  40f0b0:	f9000280 	str	x0, [x20]
    if (*object == NULL) {
  40f0b4:	b4000180 	cbz	x0, 40f0e4 <txt_deserialize_child+0x88>
    ts->tok_pos++;
  40f0b8:	f941d260 	ldr	x0, [x19, #928]
  40f0bc:	91000400 	add	x0, x0, #0x1
  40f0c0:	f901d260 	str	x0, [x19, #928]
    return 0;
  40f0c4:	52800000 	mov	w0, #0x0                   	// #0
}
  40f0c8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f0cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f0d0:	d65f03c0 	ret
        return -THINGSET_ERR_DESERIALIZATION_FINISHED;
  40f0d4:	12801de0 	mov	w0, #0xffffff10            	// #-240
  40f0d8:	17fffffc 	b	40f0c8 <txt_deserialize_child+0x6c>
        return -THINGSET_ERR_BAD_REQUEST;
  40f0dc:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40f0e0:	17fffffa 	b	40f0c8 <txt_deserialize_child+0x6c>
        return -THINGSET_ERR_NOT_FOUND;
  40f0e4:	12801460 	mov	w0, #0xffffff5c            	// #-164
  40f0e8:	17fffff8 	b	40f0c8 <txt_deserialize_child+0x6c>

000000000040f0ec <txt_deserialize_null>:
{
  40f0ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40f0f0:	910003fd 	mov	x29, sp
  40f0f4:	a90153f3 	stp	x19, x20, [sp, #16]
  40f0f8:	aa0003f3 	mov	x19, x0
    if (ts->tok_pos < ts->tok_count) {
  40f0fc:	f941d014 	ldr	x20, [x0, #928]
  40f100:	f941cc00 	ldr	x0, [x0, #920]
  40f104:	eb00029f 	cmp	x20, x0
  40f108:	54000262 	b.cs	40f154 <txt_deserialize_null+0x68>  // b.hs, b.nlast
        if (token->type == JSMN_PRIMITIVE
  40f10c:	8b141261 	add	x1, x19, x20, lsl #4
  40f110:	b9407820 	ldr	w0, [x1, #120]
  40f114:	7100201f 	cmp	w0, #0x8
  40f118:	54000221 	b.ne	40f15c <txt_deserialize_null+0x70>  // b.any
            && strncmp(ts->msg_payload + token->start, "null", token->end - token->start) == 0)
  40f11c:	294f8820 	ldp	w0, w2, [x1, #124]
  40f120:	d0000041 	adrp	x1, 419000 <__func__.2+0xa80>
  40f124:	f9402a63 	ldr	x3, [x19, #80]
  40f128:	4b000042 	sub	w2, w2, w0
  40f12c:	913e3021 	add	x1, x1, #0xf8c
  40f130:	93407c42 	sxtw	x2, w2
  40f134:	8b20c060 	add	x0, x3, w0, sxtw
  40f138:	97ffc8d2 	bl	401480 <strncmp@plt>
  40f13c:	35000100 	cbnz	w0, 40f15c <txt_deserialize_null+0x70>
            ts->tok_pos++;
  40f140:	91000694 	add	x20, x20, #0x1
  40f144:	f901d274 	str	x20, [x19, #928]
}
  40f148:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f14c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f150:	d65f03c0 	ret
        return -THINGSET_ERR_BAD_REQUEST;
  40f154:	128013e0 	mov	w0, #0xffffff60            	// #-160
  40f158:	17fffffc 	b	40f148 <txt_deserialize_null+0x5c>
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40f15c:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40f160:	17fffffa 	b	40f148 <txt_deserialize_null+0x5c>

000000000040f164 <txt_serialize_name>:
{
  40f164:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40f168:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f16c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f170:	910003fd 	mov	x29, sp
  40f174:	f9000bf3 	str	x19, [sp, #16]
  40f178:	aa0003f3 	mov	x19, x0
  40f17c:	913e4484 	add	x4, x4, #0xf91
  40f180:	52800022 	mov	w2, #0x1                   	// #1
  40f184:	f9400425 	ldr	x5, [x1, #8]
    int len = snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos, "\"%s\",", object->name);
  40f188:	a9459e66 	ldp	x6, x7, [x19, #88]
  40f18c:	f9403400 	ldr	x0, [x0, #104]
  40f190:	cb0000e1 	sub	x1, x7, x0
  40f194:	8b0000c0 	add	x0, x6, x0
  40f198:	97ffc8a6 	bl	401430 <__snprintf_chk@plt>
    if (len >= 0 && len < ts->rsp_size - ts->rsp_pos) {
  40f19c:	37f80180 	tbnz	w0, #31, 40f1cc <txt_serialize_name+0x68>
  40f1a0:	a9460e62 	ldp	x2, x3, [x19, #96]
  40f1a4:	93407c01 	sxtw	x1, w0
  40f1a8:	cb030042 	sub	x2, x2, x3
  40f1ac:	eb20c05f 	cmp	x2, w0, sxtw
  40f1b0:	540000e9 	b.ls	40f1cc <txt_serialize_name+0x68>  // b.plast
        ts->rsp_pos += len;
  40f1b4:	8b030021 	add	x1, x1, x3
        return 0;
  40f1b8:	52800000 	mov	w0, #0x0                   	// #0
  40f1bc:	f9003661 	str	x1, [x19, #104]
}
  40f1c0:	f9400bf3 	ldr	x19, [sp, #16]
  40f1c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f1c8:	d65f03c0 	ret
        ts->rsp_pos = 0;
  40f1cc:	d2800001 	mov	x1, #0x0                   	// #0
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40f1d0:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40f1d4:	17fffffa 	b	40f1bc <txt_serialize_name+0x58>

000000000040f1d8 <txt_serialize_report_header>:
{
  40f1d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40f1dc:	aa0103e5 	mov	x5, x1
  40f1e0:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f1e4:	910003fd 	mov	x29, sp
  40f1e8:	f9000bf3 	str	x19, [sp, #16]
  40f1ec:	aa0003f3 	mov	x19, x0
  40f1f0:	52800022 	mov	w2, #0x1                   	// #1
  40f1f4:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f1f8:	a9458400 	ldp	x0, x1, [x0, #88]
  40f1fc:	913e5c84 	add	x4, x4, #0xf97
  40f200:	97ffc88c 	bl	401430 <__snprintf_chk@plt>
    ts->rsp_pos = snprintf(ts->rsp, ts->rsp_size, "#%s ", path);
  40f204:	93407c00 	sxtw	x0, w0
    if (ts->rsp_pos < 0 || ts->rsp_pos > ts->rsp_size) {
  40f208:	f9403261 	ldr	x1, [x19, #96]
    ts->rsp_pos = snprintf(ts->rsp, ts->rsp_size, "#%s ", path);
  40f20c:	f9003660 	str	x0, [x19, #104]
        return 0;
  40f210:	eb01001f 	cmp	x0, x1
}
  40f214:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40f218:	1a9f8000 	csel	w0, w0, wzr, hi  // hi = pmore
  40f21c:	f9400bf3 	ldr	x19, [sp, #16]
  40f220:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f224:	d65f03c0 	ret

000000000040f228 <json_serialize_simple_value>:
    switch (type) {
  40f228:	71002c7f 	cmp	w3, #0xb
  40f22c:	54000a28 	b.hi	40f370 <json_serialize_simple_value+0x148>  // b.pmore
{
  40f230:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40f234:	910003fd 	mov	x29, sp
  40f238:	f9000bf3 	str	x19, [sp, #16]
  40f23c:	aa0103f3 	mov	x19, x1
    switch (type) {
  40f240:	90000041 	adrp	x1, 417000 <z_abort_timeout+0x38>
  40f244:	913bb021 	add	x1, x1, #0xeec
  40f248:	38634821 	ldrb	w1, [x1, w3, uxtw]
  40f24c:	10000063 	adr	x3, 40f258 <json_serialize_simple_value+0x30>
  40f250:	8b218861 	add	x1, x3, w1, sxtb #2
  40f254:	d61f0020 	br	x1
  40f258:	b9400045 	ldr	w5, [x2]
  40f25c:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f260:	913e7084 	add	x4, x4, #0xf9c
  40f264:	14000004 	b	40f274 <json_serialize_simple_value+0x4c>
  40f268:	b9400045 	ldr	w5, [x2]
  40f26c:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f270:	913e8084 	add	x4, x4, #0xfa0
  40f274:	aa1303e1 	mov	x1, x19
  40f278:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f27c:	52800022 	mov	w2, #0x1                   	// #1
  40f280:	97ffc86c 	bl	401430 <__snprintf_chk@plt>
    if (pos >= 0 && pos < size) {
  40f284:	37f80720 	tbnz	w0, #31, 40f368 <json_serialize_simple_value+0x140>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40f288:	eb20c27f 	cmp	x19, w0, sxtw
  40f28c:	12801c01 	mov	w1, #0xffffff1f            	// #-225
  40f290:	1a818000 	csel	w0, w0, w1, hi  // hi = pmore
}
  40f294:	f9400bf3 	ldr	x19, [sp, #16]
  40f298:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40f29c:	d65f03c0 	ret
  40f2a0:	79400045 	ldrh	w5, [x2]
  40f2a4:	17ffffee 	b	40f25c <json_serialize_simple_value+0x34>
  40f2a8:	79c00045 	ldrsh	w5, [x2]
  40f2ac:	17fffff0 	b	40f26c <json_serialize_simple_value+0x44>
  40f2b0:	39400045 	ldrb	w5, [x2]
  40f2b4:	17ffffea 	b	40f25c <json_serialize_simple_value+0x34>
  40f2b8:	39c00045 	ldrsb	w5, [x2]
  40f2bc:	17ffffec 	b	40f26c <json_serialize_simple_value+0x44>
            if (isnan(*data.f32) || isinf(*data.f32)) {
  40f2c0:	bd400040 	ldr	s0, [x2]
  40f2c4:	1e202000 	fcmp	s0, s0
  40f2c8:	540000c6 	b.vs	40f2e0 <json_serialize_simple_value+0xb8>
  40f2cc:	1e20c001 	fabs	s1, s0
  40f2d0:	12b01001 	mov	w1, #0x7f7fffff            	// #2139095039
  40f2d4:	1e270022 	fmov	s2, w1
  40f2d8:	1e222020 	fcmp	s1, s2
  40f2dc:	540000cd 	b.le	40f2f4 <json_serialize_simple_value+0xcc>
  40f2e0:	aa1303e1 	mov	x1, x19
  40f2e4:	d0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40f2e8:	913e9042 	add	x2, x2, #0xfa4
  40f2ec:	97ffc849 	bl	401410 <snprintf@plt>
                break;
  40f2f0:	17ffffe5 	b	40f284 <json_serialize_simple_value+0x5c>
  40f2f4:	1e22c000 	fcvt	d0, s0
  40f2f8:	2a0403e5 	mov	w5, w4
  40f2fc:	aa1303e1 	mov	x1, x19
  40f300:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f304:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f308:	913ea884 	add	x4, x4, #0xfaa
  40f30c:	52800022 	mov	w2, #0x1                   	// #1
  40f310:	97ffc848 	bl	401430 <__snprintf_chk@plt>
                break;
  40f314:	17ffffdc 	b	40f284 <json_serialize_simple_value+0x5c>
            pos = snprintf(buf, size, "%s,", *data.b == true ? "true" : "false");
  40f318:	39400042 	ldrb	w2, [x2]
  40f31c:	d0000041 	adrp	x1, 419000 <__func__.2+0xa80>
  40f320:	d0000045 	adrp	x5, 419000 <__func__.2+0xa80>
  40f324:	9112f021 	add	x1, x1, #0x4bc
  40f328:	7100005f 	cmp	w2, #0x0
  40f32c:	911308a5 	add	x5, x5, #0x4c2
  40f330:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f334:	9a8110a5 	csel	x5, x5, x1, ne  // ne = any
  40f338:	913ec084 	add	x4, x4, #0xfb0
  40f33c:	aa1303e1 	mov	x1, x19
  40f340:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f344:	52800022 	mov	w2, #0x1                   	// #1
  40f348:	97ffc83a 	bl	401430 <__snprintf_chk@plt>
            break;
  40f34c:	17ffffce 	b	40f284 <json_serialize_simple_value+0x5c>
  40f350:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f354:	aa0203e5 	mov	x5, x2
  40f358:	913e4484 	add	x4, x4, #0xf91
  40f35c:	17fffff8 	b	40f33c <json_serialize_simple_value+0x114>
    switch (type) {
  40f360:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40f364:	17ffffcc 	b	40f294 <json_serialize_simple_value+0x6c>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40f368:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40f36c:	17ffffca 	b	40f294 <json_serialize_simple_value+0x6c>
    switch (type) {
  40f370:	128015c0 	mov	w0, #0xffffff51            	// #-175
}
  40f374:	d65f03c0 	ret

000000000040f378 <txt_serialize_subsets>:
{
  40f378:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40f37c:	910003fd 	mov	x29, sp
  40f380:	a90153f3 	stp	x19, x20, [sp, #16]
  40f384:	aa0003f3 	mov	x19, x0
  40f388:	d0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40f38c:	a9025bf5 	stp	x21, x22, [sp, #32]
            else if (depth > 0 && parent_id != ancestors[depth - 1]->id) {
  40f390:	9101a3f6 	add	x22, sp, #0x68
    int depth = 0;
  40f394:	52800014 	mov	w20, #0x0                   	// #0
{
  40f398:	f9475c00 	ldr	x0, [x0, #3768]
  40f39c:	a90363f7 	stp	x23, x24, [sp, #48]
  40f3a0:	d0000057 	adrp	x23, 419000 <__func__.2+0xa80>
  40f3a4:	a9046bf9 	stp	x25, x26, [sp, #64]
  40f3a8:	12003c39 	and	w25, w1, #0xffff
  40f3ac:	913ed2f7 	add	x23, x23, #0xfb4
  40f3b0:	f9002bfb 	str	x27, [sp, #80]
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40f3b4:	52800018 	mov	w24, #0x0                   	// #0
{
  40f3b8:	f9400001 	ldr	x1, [x0]
  40f3bc:	f9003fe1 	str	x1, [sp, #120]
  40f3c0:	d2800001 	mov	x1, #0x0                   	// #0
    ts->rsp[ts->rsp_pos++] = '{';
  40f3c4:	f9402e61 	ldr	x1, [x19, #88]
  40f3c8:	f9403660 	ldr	x0, [x19, #104]
  40f3cc:	91000402 	add	x2, x0, #0x1
  40f3d0:	f9003662 	str	x2, [x19, #104]
  40f3d4:	52800f62 	mov	w2, #0x7b                  	// #123
  40f3d8:	38206822 	strb	w2, [x1, x0]
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40f3dc:	f9400661 	ldr	x1, [x19, #8]
  40f3e0:	2a1803e0 	mov	w0, w24
  40f3e4:	eb38403f 	cmp	x1, w24, uxtw
  40f3e8:	54000388 	b.hi	40f458 <txt_serialize_subsets+0xe0>  // b.pmore
    ts->rsp_pos--; /* overwrite internal comma */
  40f3ec:	f9403660 	ldr	x0, [x19, #104]
        ts->rsp[ts->rsp_pos++] = '}';
  40f3f0:	52800fa2 	mov	w2, #0x7d                  	// #125
    ts->rsp_pos--; /* overwrite internal comma */
  40f3f4:	d1000400 	sub	x0, x0, #0x1
  40f3f8:	f9003660 	str	x0, [x19, #104]
        ts->rsp[ts->rsp_pos++] = '}';
  40f3fc:	f9402e61 	ldr	x1, [x19, #88]
        depth--;
  40f400:	51000694 	sub	w20, w20, #0x1
        ts->rsp[ts->rsp_pos++] = '}';
  40f404:	f9403660 	ldr	x0, [x19, #104]
  40f408:	91000403 	add	x3, x0, #0x1
  40f40c:	f9003663 	str	x3, [x19, #104]
  40f410:	38206822 	strb	w2, [x1, x0]
    while (depth >= 0) {
  40f414:	3100069f 	cmn	w20, #0x1
  40f418:	54ffff21 	b.ne	40f3fc <txt_serialize_subsets+0x84>  // b.any
    ts->rsp[ts->rsp_pos++] = ',';
  40f41c:	f9402e61 	ldr	x1, [x19, #88]
  40f420:	f9403660 	ldr	x0, [x19, #104]
  40f424:	91000402 	add	x2, x0, #0x1
  40f428:	f9003662 	str	x2, [x19, #104]
  40f42c:	52800582 	mov	w2, #0x2c                  	// #44
  40f430:	38206822 	strb	w2, [x1, x0]
    return 0;
  40f434:	52800000 	mov	w0, #0x0                   	// #0
}
  40f438:	d0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40f43c:	f9475c21 	ldr	x1, [x1, #3768]
  40f440:	f9403fe3 	ldr	x3, [sp, #120]
  40f444:	f9400022 	ldr	x2, [x1]
  40f448:	eb020063 	subs	x3, x3, x2
  40f44c:	d2800002 	mov	x2, #0x0                   	// #0
  40f450:	54000f60 	b.eq	40f63c <txt_serialize_subsets+0x2c4>  // b.none
  40f454:	97ffc833 	bl	401520 <__stack_chk_fail@plt>
        if (ts->data_objects[i].subsets & subsets) {
  40f458:	f9400261 	ldr	x1, [x19]
  40f45c:	d37be81b 	lsl	x27, x0, #5
  40f460:	8b001420 	add	x0, x1, x0, lsl #5
  40f464:	f9400c00 	ldr	x0, [x0, #24]
  40f468:	6a40673f 	tst	w25, w0, lsr #25
  40f46c:	54000800 	b.eq	40f56c <txt_serialize_subsets+0x1f4>  // b.none
            const uint16_t parent_id = ts->data_objects[i].parent_id;
  40f470:	787b683a 	ldrh	w26, [x1, x27]
            if (depth > 0 && parent_id == ancestors[depth - 1]->id) {
  40f474:	340000d4 	cbz	w20, 40f48c <txt_serialize_subsets+0x114>
  40f478:	51000680 	sub	w0, w20, #0x1
  40f47c:	f860dad5 	ldr	x21, [x22, w0, sxtw #3]
  40f480:	794006a0 	ldrh	w0, [x21, #2]
  40f484:	6b1a001f 	cmp	w0, w26
  40f488:	540000e0 	b.eq	40f4a4 <txt_serialize_subsets+0x12c>  // b.none
            else if (parent_id != 0) {
  40f48c:	340007fa 	cbz	w26, 40f588 <txt_serialize_subsets+0x210>
                parent = thingset_get_object_by_id(ts, parent_id);
  40f490:	2a1a03e1 	mov	w1, w26
  40f494:	aa1303e0 	mov	x0, x19
  40f498:	97fff5cb 	bl	40cbc4 <thingset_get_object_by_id>
  40f49c:	aa0003f5 	mov	x21, x0
            if (depth > 0 && parent_id != ancestors[depth - 1]->id && parent != NULL
  40f4a0:	340002d4 	cbz	w20, 40f4f8 <txt_serialize_subsets+0x180>
  40f4a4:	51000681 	sub	w1, w20, #0x1
  40f4a8:	f861dac0 	ldr	x0, [x22, w1, sxtw #3]
  40f4ac:	79400400 	ldrh	w0, [x0, #2]
  40f4b0:	6b1a001f 	cmp	w0, w26
  40f4b4:	54000220 	b.eq	40f4f8 <txt_serialize_subsets+0x180>  // b.none
  40f4b8:	b4000215 	cbz	x21, 40f4f8 <txt_serialize_subsets+0x180>
                && parent->parent_id != ancestors[depth - 1]->id)
  40f4bc:	794002a2 	ldrh	w2, [x21]
  40f4c0:	6b00005f 	cmp	w2, w0
  40f4c4:	540001a0 	b.eq	40f4f8 <txt_serialize_subsets+0x180>  // b.none
                ts->rsp[ts->rsp_pos - 1] = '}'; /* overwrite comma */
  40f4c8:	f9402e60 	ldr	x0, [x19, #88]
                depth--;
  40f4cc:	2a0103f4 	mov	w20, w1
                ts->rsp[ts->rsp_pos - 1] = '}'; /* overwrite comma */
  40f4d0:	f9403662 	ldr	x2, [x19, #104]
  40f4d4:	8b020000 	add	x0, x0, x2
  40f4d8:	52800fa2 	mov	w2, #0x7d                  	// #125
  40f4dc:	381ff002 	sturb	w2, [x0, #-1]
                ts->rsp[ts->rsp_pos++] = ',';
  40f4e0:	f9402e62 	ldr	x2, [x19, #88]
  40f4e4:	f9403660 	ldr	x0, [x19, #104]
  40f4e8:	91000403 	add	x3, x0, #0x1
  40f4ec:	f9003663 	str	x3, [x19, #104]
  40f4f0:	52800583 	mov	w3, #0x2c                  	// #44
  40f4f4:	38206843 	strb	w3, [x2, x0]
            if (depth == 0 && parent != NULL) {
  40f4f8:	7100029f 	cmp	w20, #0x0
  40f4fc:	fa400aa4 	ccmp	x21, #0x0, #0x4, eq  // eq = none
  40f500:	540006e0 	b.eq	40f5dc <txt_serialize_subsets+0x264>  // b.none
                if (parent->parent_id != 0) {
  40f504:	794002a1 	ldrh	w1, [x21]
  40f508:	35000441 	cbnz	w1, 40f590 <txt_serialize_subsets+0x218>
                depth--;
  40f50c:	5280001a 	mov	w26, #0x0                   	// #0
                ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40f510:	a9458666 	ldp	x6, x1, [x19, #88]
  40f514:	aa1703e4 	mov	x4, x23
  40f518:	f94006a5 	ldr	x5, [x21, #8]
  40f51c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f520:	f9403660 	ldr	x0, [x19, #104]
  40f524:	52800022 	mov	w2, #0x1                   	// #1
                ancestors[depth++] = parent;
  40f528:	11000754 	add	w20, w26, #0x1
  40f52c:	cb000021 	sub	x1, x1, x0
  40f530:	8b0000c0 	add	x0, x6, x0
  40f534:	97ffc7bf 	bl	401430 <__snprintf_chk@plt>
  40f538:	f83adad5 	str	x21, [x22, w26, sxtw #3]
                ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40f53c:	f9403661 	ldr	x1, [x19, #104]
  40f540:	8b20c020 	add	x0, x1, w0, sxtw
  40f544:	f9003660 	str	x0, [x19, #104]
            ts->rsp_pos += ts->api->serialize_key_value(ts, &ts->data_objects[i]);
  40f548:	f9403a60 	ldr	x0, [x19, #112]
  40f54c:	f9400261 	ldr	x1, [x19]
  40f550:	f9401002 	ldr	x2, [x0, #32]
  40f554:	8b1b0021 	add	x1, x1, x27
  40f558:	aa1303e0 	mov	x0, x19
  40f55c:	d63f0040 	blr	x2
  40f560:	f9403661 	ldr	x1, [x19, #104]
  40f564:	8b20c020 	add	x0, x1, w0, sxtw
  40f568:	f9003660 	str	x0, [x19, #104]
        if (ts->rsp_pos >= ts->rsp_size - 1 - depth) {
  40f56c:	a9460660 	ldp	x0, x1, [x19, #96]
  40f570:	d1000400 	sub	x0, x0, #0x1
  40f574:	cb34c000 	sub	x0, x0, w20, sxtw
  40f578:	eb00003f 	cmp	x1, x0
  40f57c:	540005c2 	b.cs	40f634 <txt_serialize_subsets+0x2bc>  // b.hs, b.nlast
    for (unsigned int i = 0; i < ts->num_objects; i++) {
  40f580:	11000718 	add	w24, w24, #0x1
  40f584:	17ffff96 	b	40f3dc <txt_serialize_subsets+0x64>
            struct thingset_data_object *parent = NULL;
  40f588:	d2800015 	mov	x21, #0x0                   	// #0
  40f58c:	17ffffc5 	b	40f4a0 <txt_serialize_subsets+0x128>
                        thingset_get_object_by_id(ts, parent->parent_id);
  40f590:	aa1303e0 	mov	x0, x19
  40f594:	97fff58c 	bl	40cbc4 <thingset_get_object_by_id>
  40f598:	aa0003f4 	mov	x20, x0
                    if (grandparent != NULL) {
  40f59c:	b4fffb80 	cbz	x0, 40f50c <txt_serialize_subsets+0x194>
                        ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40f5a0:	a9458666 	ldp	x6, x1, [x19, #88]
  40f5a4:	aa1703e4 	mov	x4, x23
  40f5a8:	f9400685 	ldr	x5, [x20, #8]
  40f5ac:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f5b0:	f9403660 	ldr	x0, [x19, #104]
  40f5b4:	52800022 	mov	w2, #0x1                   	// #1
                        ancestors[depth++] = grandparent;
  40f5b8:	5280003a 	mov	w26, #0x1                   	// #1
  40f5bc:	cb000021 	sub	x1, x1, x0
  40f5c0:	8b0000c0 	add	x0, x6, x0
  40f5c4:	97ffc79b 	bl	401430 <__snprintf_chk@plt>
  40f5c8:	f90037f4 	str	x20, [sp, #104]
                        ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40f5cc:	f9403661 	ldr	x1, [x19, #104]
  40f5d0:	8b20c020 	add	x0, x1, w0, sxtw
  40f5d4:	f9003660 	str	x0, [x19, #104]
                        ancestors[depth++] = grandparent;
  40f5d8:	17ffffce 	b	40f510 <txt_serialize_subsets+0x198>
            else if (depth > 0 && parent_id != ancestors[depth - 1]->id) {
  40f5dc:	34fffb74 	cbz	w20, 40f548 <txt_serialize_subsets+0x1d0>
  40f5e0:	51000680 	sub	w0, w20, #0x1
  40f5e4:	f860dac0 	ldr	x0, [x22, w0, sxtw #3]
  40f5e8:	79400400 	ldrh	w0, [x0, #2]
  40f5ec:	6b1a001f 	cmp	w0, w26
  40f5f0:	54fffac0 	b.eq	40f548 <txt_serialize_subsets+0x1d0>  // b.none
                if (parent != NULL) {
  40f5f4:	b4fffab5 	cbz	x21, 40f548 <txt_serialize_subsets+0x1d0>
                    ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40f5f8:	a9458666 	ldp	x6, x1, [x19, #88]
  40f5fc:	aa1703e4 	mov	x4, x23
  40f600:	f94006a5 	ldr	x5, [x21, #8]
  40f604:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f608:	f9403660 	ldr	x0, [x19, #104]
  40f60c:	52800022 	mov	w2, #0x1                   	// #1
  40f610:	cb000021 	sub	x1, x1, x0
  40f614:	8b0000c0 	add	x0, x6, x0
  40f618:	97ffc786 	bl	401430 <__snprintf_chk@plt>
                    ancestors[depth++] = parent;
  40f61c:	f834dad5 	str	x21, [x22, w20, sxtw #3]
                    ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40f620:	f9403661 	ldr	x1, [x19, #104]
                    ancestors[depth++] = parent;
  40f624:	11000694 	add	w20, w20, #0x1
                    ts->rsp_pos += snprintf(ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos,
  40f628:	8b20c020 	add	x0, x1, w0, sxtw
  40f62c:	f9003660 	str	x0, [x19, #104]
                    ancestors[depth++] = parent;
  40f630:	17ffffc6 	b	40f548 <txt_serialize_subsets+0x1d0>
            return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40f634:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40f638:	17ffff80 	b	40f438 <txt_serialize_subsets+0xc0>
}
  40f63c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f640:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f644:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f648:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40f64c:	f9402bfb 	ldr	x27, [sp, #80]
  40f650:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40f654:	d65f03c0 	ret

000000000040f658 <txt_serialize_value>:
{
  40f658:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  40f65c:	910003fd 	mov	x29, sp
  40f660:	a9025bf5 	stp	x21, x22, [sp, #32]
  40f664:	aa0003f5 	mov	x21, x0
  40f668:	d0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40f66c:	a90153f3 	stp	x19, x20, [sp, #16]
  40f670:	a90363f7 	stp	x23, x24, [sp, #48]
  40f674:	aa0103f7 	mov	x23, x1
  40f678:	a9046bf9 	stp	x25, x26, [sp, #64]
    size_t size = ts->rsp_size - ts->rsp_pos;
  40f67c:	a945d2b6 	ldp	x22, x20, [x21, #88]
{
  40f680:	f9002bfb 	str	x27, [sp, #80]
  40f684:	f9475c00 	ldr	x0, [x0, #3768]
    int pos = json_serialize_simple_value(buf, size, object->data, object->type, object->detail);
  40f688:	a9410ee2 	ldp	x2, x3, [x23, #16]
{
  40f68c:	f9400001 	ldr	x1, [x0]
  40f690:	f9003fe1 	str	x1, [sp, #120]
  40f694:	d2800001 	mov	x1, #0x0                   	// #0
    char *buf = ts->rsp + ts->rsp_pos;
  40f698:	f94036a0 	ldr	x0, [x21, #104]
    size_t size = ts->rsp_size - ts->rsp_pos;
  40f69c:	cb000294 	sub	x20, x20, x0
    char *buf = ts->rsp + ts->rsp_pos;
  40f6a0:	8b0002d6 	add	x22, x22, x0
    int pos = json_serialize_simple_value(buf, size, object->data, object->type, object->detail);
  40f6a4:	93454064 	sbfx	x4, x3, #5, #12
  40f6a8:	aa1403e1 	mov	x1, x20
  40f6ac:	aa1603e0 	mov	x0, x22
  40f6b0:	12001063 	and	w3, w3, #0x1f
  40f6b4:	13003c84 	sxth	w4, w4
  40f6b8:	97fffedc 	bl	40f228 <json_serialize_simple_value>
    if (pos < 0) {
  40f6bc:	36f80160 	tbz	w0, #31, 40f6e8 <txt_serialize_value+0x90>
        if (object->type == THINGSET_TYPE_GROUP) {
  40f6c0:	b9401ae0 	ldr	w0, [x23, #24]
  40f6c4:	12001000 	and	w0, w0, #0x1f
  40f6c8:	71003c1f 	cmp	w0, #0xf
  40f6cc:	540002c1 	b.ne	40f724 <txt_serialize_value+0xcc>  // b.any
  40f6d0:	d0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40f6d4:	aa1403e1 	mov	x1, x20
  40f6d8:	913e9042 	add	x2, x2, #0xfa4
  40f6dc:	aa1603e0 	mov	x0, x22
  40f6e0:	97ffc74c 	bl	401410 <snprintf@plt>
    if (pos >= 0 && pos < size) {
  40f6e4:	37f81300 	tbnz	w0, #31, 40f944 <txt_serialize_value+0x2ec>
  40f6e8:	93407c01 	sxtw	x1, w0
  40f6ec:	eb20c29f 	cmp	x20, w0, sxtw
  40f6f0:	540012a9 	b.ls	40f944 <txt_serialize_value+0x2ec>  // b.plast
        ts->rsp_pos += pos;
  40f6f4:	f94036a0 	ldr	x0, [x21, #104]
  40f6f8:	8b000021 	add	x1, x1, x0
        return 0;
  40f6fc:	52800000 	mov	w0, #0x0                   	// #0
            ts->rsp_pos = 0;
  40f700:	f90036a1 	str	x1, [x21, #104]
}
  40f704:	d0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  40f708:	f9475c21 	ldr	x1, [x1, #3768]
  40f70c:	f9403fe3 	ldr	x3, [sp, #120]
  40f710:	f9400022 	ldr	x2, [x1]
  40f714:	eb020063 	subs	x3, x3, x2
  40f718:	d2800002 	mov	x2, #0x0                   	// #0
  40f71c:	54001200 	b.eq	40f95c <txt_serialize_value+0x304>  // b.none
  40f720:	97ffc780 	bl	401520 <__stack_chk_fail@plt>
        else if (object->type == THINGSET_TYPE_RECORDS) {
  40f724:	51003400 	sub	w0, w0, #0xd
  40f728:	7100141f 	cmp	w0, #0x5
  40f72c:	54001128 	b.hi	40f950 <txt_serialize_value+0x2f8>  // b.pmore
  40f730:	90000041 	adrp	x1, 417000 <z_abort_timeout+0x38>
  40f734:	913be021 	add	x1, x1, #0xef8
  40f738:	78605821 	ldrh	w1, [x1, w0, uxtw #1]
  40f73c:	10000060 	adr	x0, 40f748 <txt_serialize_value+0xf0>
  40f740:	8b21a801 	add	x1, x0, w1, sxth #2
  40f744:	d61f0020 	br	x1
            pos = snprintf(buf, size, "%d,", object->data.records->num_records);
  40f748:	f9400ae0 	ldr	x0, [x23, #16]
  40f74c:	aa1403e1 	mov	x1, x20
  40f750:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f754:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f758:	913eec84 	add	x4, x4, #0xfbb
  40f75c:	52800022 	mov	w2, #0x1                   	// #1
  40f760:	79402405 	ldrh	w5, [x0, #18]
  40f764:	aa1603e0 	mov	x0, x22
  40f768:	97ffc732 	bl	401430 <__snprintf_chk@plt>
  40f76c:	17ffffde 	b	40f6e4 <txt_serialize_value+0x8c>
  40f770:	aa1403e1 	mov	x1, x20
  40f774:	aa1603e0 	mov	x0, x22
  40f778:	d0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40f77c:	d0000059 	adrp	x25, 419000 <__func__.2+0xa80>
  40f780:	913efc42 	add	x2, x2, #0xfbf
  40f784:	913e4739 	add	x25, x25, #0xf91
  40f788:	97ffc722 	bl	401410 <snprintf@plt>
  40f78c:	2a0003f3 	mov	w19, w0
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40f790:	52800018 	mov	w24, #0x0                   	// #0
  40f794:	f94006a1 	ldr	x1, [x21, #8]
  40f798:	2a1803e0 	mov	w0, w24
  40f79c:	eb38403f 	cmp	x1, w24, uxtw
  40f7a0:	54000168 	b.hi	40f7cc <txt_serialize_value+0x174>  // b.pmore
                pos--; /* remove trailing comma */
  40f7a4:	7100067f 	cmp	w19, #0x1
  40f7a8:	1a9fd7e0 	cset	w0, gt
                pos--; /* remove trailing comma */
  40f7ac:	4b000273 	sub	w19, w19, w0
  40f7b0:	d0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40f7b4:	913f0442 	add	x2, x2, #0xfc1
  40f7b8:	cb33c281 	sub	x1, x20, w19, sxtw
  40f7bc:	8b33c2c0 	add	x0, x22, w19, sxtw
  40f7c0:	97ffc714 	bl	401410 <snprintf@plt>
            pos += snprintf(buf + pos, size - pos, "],");
  40f7c4:	0b000260 	add	w0, w19, w0
        else if (object->type == THINGSET_TYPE_ARRAY && object->data.array != NULL) {
  40f7c8:	17ffffc7 	b	40f6e4 <txt_serialize_value+0x8c>
                if (ts->data_objects[i].parent_id == object->id) {
  40f7cc:	f94002a1 	ldr	x1, [x21]
  40f7d0:	d37be802 	lsl	x2, x0, #5
  40f7d4:	8b001420 	add	x0, x1, x0, lsl #5
  40f7d8:	78626822 	ldrh	w2, [x1, x2]
  40f7dc:	794006e1 	ldrh	w1, [x23, #2]
  40f7e0:	6b01005f 	cmp	w2, w1
  40f7e4:	54000121 	b.ne	40f808 <txt_serialize_value+0x1b0>  // b.any
  40f7e8:	f9400405 	ldr	x5, [x0, #8]
  40f7ec:	cb33c281 	sub	x1, x20, w19, sxtw
  40f7f0:	8b33c2c0 	add	x0, x22, w19, sxtw
  40f7f4:	aa1903e4 	mov	x4, x25
  40f7f8:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f7fc:	52800022 	mov	w2, #0x1                   	// #1
  40f800:	97ffc70c 	bl	401430 <__snprintf_chk@plt>
                    pos += snprintf(buf + pos, size - pos, "\"%s\",", ts->data_objects[i].name);
  40f804:	0b000273 	add	w19, w19, w0
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40f808:	11000718 	add	w24, w24, #0x1
  40f80c:	17ffffe2 	b	40f794 <txt_serialize_value+0x13c>
  40f810:	aa1403e1 	mov	x1, x20
  40f814:	aa1603e0 	mov	x0, x22
  40f818:	d0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40f81c:	913efc42 	add	x2, x2, #0xfbf
  40f820:	97ffc6fc 	bl	401410 <snprintf@plt>
  40f824:	2a0003f3 	mov	w19, w0
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40f828:	52800019 	mov	w25, #0x0                   	// #0
                    buf[pos++] = '"';
  40f82c:	5280045a 	mov	w26, #0x22                  	// #34
                    buf[pos++] = ',';
  40f830:	5280059b 	mov	w27, #0x2c                  	// #44
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40f834:	f94006a1 	ldr	x1, [x21, #8]
  40f838:	2a1903e0 	mov	w0, w25
  40f83c:	eb39403f 	cmp	x1, w25, uxtw
  40f840:	54fffb29 	b.ls	40f7a4 <txt_serialize_value+0x14c>  // b.plast
                if (ts->data_objects[i].subsets & object->data.subset) {
  40f844:	f94002a2 	ldr	x2, [x21]
  40f848:	d37be801 	lsl	x1, x0, #5
  40f84c:	8b001440 	add	x0, x2, x0, lsl #5
  40f850:	f9400c02 	ldr	x2, [x0, #24]
  40f854:	b94012e0 	ldr	w0, [x23, #16]
  40f858:	6a42641f 	tst	w0, w2, lsr #25
  40f85c:	540001c0 	b.eq	40f894 <txt_serialize_value+0x23c>  // b.none
                    buf[pos++] = '"';
  40f860:	3833cada 	strb	w26, [x22, w19, sxtw]
  40f864:	11000678 	add	w24, w19, #0x1
                    pos += thingset_get_path(ts, buf + pos, size - pos, &ts->data_objects[i]);
  40f868:	aa1503e0 	mov	x0, x21
  40f86c:	f94002a3 	ldr	x3, [x21]
  40f870:	cb38c282 	sub	x2, x20, w24, sxtw
  40f874:	8b010063 	add	x3, x3, x1
  40f878:	8b38c2c1 	add	x1, x22, w24, sxtw
  40f87c:	97fff567 	bl	40ce18 <thingset_get_path>
  40f880:	0b000318 	add	w24, w24, w0
                    buf[pos++] = ',';
  40f884:	11000b13 	add	w19, w24, #0x2
                    buf[pos++] = '"';
  40f888:	3838cada 	strb	w26, [x22, w24, sxtw]
  40f88c:	11000718 	add	w24, w24, #0x1
                    buf[pos++] = ',';
  40f890:	3838cadb 	strb	w27, [x22, w24, sxtw]
            for (unsigned int i = 0; i < ts->num_objects; i++) {
  40f894:	11000739 	add	w25, w25, #0x1
  40f898:	17ffffe7 	b	40f834 <txt_serialize_value+0x1dc>
        else if (object->type == THINGSET_TYPE_ARRAY && object->data.array != NULL) {
  40f89c:	f9400af7 	ldr	x23, [x23, #16]
  40f8a0:	b4000597 	cbz	x23, 40f950 <txt_serialize_value+0x2f8>
  40f8a4:	aa1403e1 	mov	x1, x20
  40f8a8:	aa1603e0 	mov	x0, x22
  40f8ac:	d0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  40f8b0:	913efc42 	add	x2, x2, #0xfbf
  40f8b4:	97ffc6d7 	bl	401410 <snprintf@plt>
  40f8b8:	2a0003f3 	mov	w19, w0
    uint8_t sizes[] = { sizeof(bool),    sizeof(uint8_t),  sizeof(int8_t),  sizeof(uint16_t),
  40f8bc:	d0000041 	adrp	x1, 419000 <__func__.2+0xa80>
  40f8c0:	9138fc21 	add	x1, x1, #0xe3f
            size_t type_size = thingset_type_size(array->element_type);
  40f8c4:	b9400ae0 	ldr	w0, [x23, #8]
  40f8c8:	9101a3e2 	add	x2, sp, #0x68
  40f8cc:	f9400023 	ldr	x3, [x1]
  40f8d0:	f90037e3 	str	x3, [sp, #104]
  40f8d4:	b8407021 	ldur	w1, [x1, #7]
  40f8d8:	b806f3e1 	stur	w1, [sp, #111]
    return type < sizeof(sizes) ? sizes[type] : 0;
  40f8dc:	12001c01 	and	w1, w0, #0xff
  40f8e0:	7100283f 	cmp	w1, #0xa
  40f8e4:	54000168 	b.hi	40f910 <txt_serialize_value+0x2b8>  // b.pmore
  40f8e8:	92401c00 	and	x0, x0, #0xff
  40f8ec:	3860685a 	ldrb	w26, [x2, x0]
            for (int i = 0; i < array->num_elements; i++) {
  40f8f0:	d2800019 	mov	x25, #0x0                   	// #0
  40f8f4:	52800018 	mov	w24, #0x0                   	// #0
  40f8f8:	794022e0 	ldrh	w0, [x23, #16]
  40f8fc:	6b18001f 	cmp	w0, w24
  40f900:	540000cc 	b.gt	40f918 <txt_serialize_value+0x2c0>
                pos--; /* remove trailing comma */
  40f904:	7100001f 	cmp	w0, #0x0
  40f908:	1a9f07e0 	cset	w0, ne  // ne = any
  40f90c:	17ffffa8 	b	40f7ac <txt_serialize_value+0x154>
  40f910:	d280001a 	mov	x26, #0x0                   	// #0
  40f914:	17fffff7 	b	40f8f0 <txt_serialize_value+0x298>
                pos += json_serialize_simple_value(buf + pos, size - pos, data, array->element_type,
  40f918:	79c01ae4 	ldrsh	w4, [x23, #12]
  40f91c:	cb33c281 	sub	x1, x20, w19, sxtw
  40f920:	b9400ae3 	ldr	w3, [x23, #8]
  40f924:	8b33c2c0 	add	x0, x22, w19, sxtw
                union thingset_data_pointer data = { .u8 = array->elements.u8 + i * type_size };
  40f928:	f94002e2 	ldr	x2, [x23]
            for (int i = 0; i < array->num_elements; i++) {
  40f92c:	11000718 	add	w24, w24, #0x1
                pos += json_serialize_simple_value(buf + pos, size - pos, data, array->element_type,
  40f930:	8b190042 	add	x2, x2, x25
  40f934:	8b1a0339 	add	x25, x25, x26
  40f938:	97fffe3c 	bl	40f228 <json_serialize_simple_value>
  40f93c:	0b000273 	add	w19, w19, w0
            for (int i = 0; i < array->num_elements; i++) {
  40f940:	17ffffee 	b	40f8f8 <txt_serialize_value+0x2a0>
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40f944:	d2800001 	mov	x1, #0x0                   	// #0
  40f948:	12801c00 	mov	w0, #0xffffff1f            	// #-225
  40f94c:	17ffff6d 	b	40f700 <txt_serialize_value+0xa8>
  40f950:	d2800001 	mov	x1, #0x0                   	// #0
            return -THINGSET_ERR_UNSUPPORTED_FORMAT;
  40f954:	128015c0 	mov	w0, #0xffffff51            	// #-175
  40f958:	17ffff6a 	b	40f700 <txt_serialize_value+0xa8>
}
  40f95c:	a94153f3 	ldp	x19, x20, [sp, #16]
  40f960:	a9425bf5 	ldp	x21, x22, [sp, #32]
  40f964:	a94363f7 	ldp	x23, x24, [sp, #48]
  40f968:	a9446bf9 	ldp	x25, x26, [sp, #64]
  40f96c:	f9402bfb 	ldr	x27, [sp, #80]
  40f970:	a8c87bfd 	ldp	x29, x30, [sp], #128
  40f974:	d65f03c0 	ret

000000000040f978 <txt_serialize_response>:
{
  40f978:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
  40f97c:	910003fd 	mov	x29, sp
  40f980:	a90153f3 	stp	x19, x20, [sp, #16]
  40f984:	aa0003f3 	mov	x19, x0
  40f988:	d0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40f98c:	f90013f5 	str	x21, [sp, #32]
  40f990:	aa0203f4 	mov	x20, x2
  40f994:	f9475c00 	ldr	x0, [x0, #3768]
  40f998:	3d802be0 	str	q0, [sp, #160]
  40f99c:	3d802fe1 	str	q1, [sp, #176]
  40f9a0:	3d8033e2 	str	q2, [sp, #192]
  40f9a4:	3d8037e3 	str	q3, [sp, #208]
  40f9a8:	3d803be4 	str	q4, [sp, #224]
  40f9ac:	3d803fe5 	str	q5, [sp, #240]
  40f9b0:	3d8043e6 	str	q6, [sp, #256]
  40f9b4:	3d8047e7 	str	q7, [sp, #272]
  40f9b8:	a91293e3 	stp	x3, x4, [sp, #296]
  40f9bc:	d0000044 	adrp	x4, 419000 <__func__.2+0xa80>
  40f9c0:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  40f9c4:	a9139be5 	stp	x5, x6, [sp, #312]
  40f9c8:	12001c25 	and	w5, w1, #0xff
  40f9cc:	913f1084 	add	x4, x4, #0xfc4
  40f9d0:	f900a7e7 	str	x7, [sp, #328]
  40f9d4:	f9400002 	ldr	x2, [x0]
  40f9d8:	f9004fe2 	str	x2, [sp, #152]
  40f9dc:	d2800002 	mov	x2, #0x0                   	// #0
  40f9e0:	a9458660 	ldp	x0, x1, [x19, #88]
  40f9e4:	52800022 	mov	w2, #0x1                   	// #1
  40f9e8:	97ffc692 	bl	401430 <__snprintf_chk@plt>
    ts->rsp_pos = snprintf((char *)ts->rsp, ts->rsp_size, ":%.2X ", code);
  40f9ec:	93407c00 	sxtw	x0, w0
  40f9f0:	f9003660 	str	x0, [x19, #104]
    if (msg != NULL && ts->rsp_size > 7) {
  40f9f4:	b40005b4 	cbz	x20, 40faa8 <txt_serialize_response+0x130>
  40f9f8:	f9403261 	ldr	x1, [x19, #96]
  40f9fc:	f1001c3f 	cmp	x1, #0x7
  40fa00:	54000549 	b.ls	40faa8 <txt_serialize_response+0x130>  // b.plast
        ts->rsp[ts->rsp_pos++] = '"';
  40fa04:	f9402e61 	ldr	x1, [x19, #88]
  40fa08:	91000402 	add	x2, x0, #0x1
  40fa0c:	f9003662 	str	x2, [x19, #104]
  40fa10:	52800455 	mov	w21, #0x22                  	// #34
  40fa14:	910163e2 	add	x2, sp, #0x58
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
  40fa18:	9100c3e5 	add	x5, sp, #0x30
  40fa1c:	38206835 	strb	w21, [x1, x0]
        va_start(vargs, msg);
  40fa20:	910543e0 	add	x0, sp, #0x150
  40fa24:	a90583e0 	stp	x0, x0, [sp, #88]
  40fa28:	910483e0 	add	x0, sp, #0x120
  40fa2c:	aa1403e4 	mov	x4, x20
  40fa30:	f90037e0 	str	x0, [sp, #104]
  40fa34:	128004e0 	mov	w0, #0xffffffd8            	// #-40
  40fa38:	b90073e0 	str	w0, [sp, #112]
  40fa3c:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  40fa40:	b90077e0 	str	w0, [sp, #116]
  40fa44:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
            vsnprintf((char *)ts->rsp + ts->rsp_pos, ts->rsp_size - ts->rsp_pos, msg, vargs);
  40fa48:	a9458666 	ldp	x6, x1, [x19, #88]
  40fa4c:	ad400440 	ldp	q0, q1, [x2]
  40fa50:	9101e3e2 	add	x2, sp, #0x78
  40fa54:	f9403660 	ldr	x0, [x19, #104]
  40fa58:	ad000440 	stp	q0, q1, [x2]
  40fa5c:	52800022 	mov	w2, #0x1                   	// #1
  40fa60:	cb000021 	sub	x1, x1, x0
  40fa64:	8b0000c0 	add	x0, x6, x0
  40fa68:	ad0004a0 	stp	q0, q1, [x5]
  40fa6c:	97ffc679 	bl	401450 <__vsnprintf_chk@plt>
        ts->rsp_pos +=
  40fa70:	a9460662 	ldp	x2, x1, [x19, #96]
  40fa74:	8b20c020 	add	x0, x1, w0, sxtw
        if (ts->rsp_pos + 1 < ts->rsp_size) {
  40fa78:	91000401 	add	x1, x0, #0x1
  40fa7c:	eb02003f 	cmp	x1, x2
  40fa80:	54000242 	b.cs	40fac8 <txt_serialize_response+0x150>  // b.hs, b.nlast
            ts->rsp[ts->rsp_pos++] = '"';
  40fa84:	f9402e62 	ldr	x2, [x19, #88]
  40fa88:	f9003661 	str	x1, [x19, #104]
  40fa8c:	38206855 	strb	w21, [x2, x0]
        ts->rsp[ts->rsp_pos++] = ' ';
  40fa90:	f9402e61 	ldr	x1, [x19, #88]
  40fa94:	f9403660 	ldr	x0, [x19, #104]
  40fa98:	91000402 	add	x2, x0, #0x1
  40fa9c:	f9003662 	str	x2, [x19, #104]
  40faa0:	52800402 	mov	w2, #0x20                  	// #32
  40faa4:	38206822 	strb	w2, [x1, x0]
}
  40faa8:	d0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  40faac:	f9475c00 	ldr	x0, [x0, #3768]
  40fab0:	f9404fe2 	ldr	x2, [sp, #152]
  40fab4:	f9400001 	ldr	x1, [x0]
  40fab8:	eb010042 	subs	x2, x2, x1
  40fabc:	d2800001 	mov	x1, #0x0                   	// #0
  40fac0:	540000a0 	b.eq	40fad4 <txt_serialize_response+0x15c>  // b.none
  40fac4:	97ffc697 	bl	401520 <__stack_chk_fail@plt>
            ts->rsp_pos = 3;
  40fac8:	d2800060 	mov	x0, #0x3                   	// #3
  40facc:	f9003660 	str	x0, [x19, #104]
  40fad0:	17fffff0 	b	40fa90 <txt_serialize_response+0x118>
}
  40fad4:	52800000 	mov	w0, #0x0                   	// #0
  40fad8:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fadc:	f94013f5 	ldr	x21, [sp, #32]
  40fae0:	a8d57bfd 	ldp	x29, x30, [sp], #336
  40fae4:	d65f03c0 	ret

000000000040fae8 <txt_serialize_name_value>:
{
  40fae8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  40faec:	910003fd 	mov	x29, sp
  40faf0:	a90153f3 	stp	x19, x20, [sp, #16]
  40faf4:	aa0003f3 	mov	x19, x0
  40faf8:	aa0103f4 	mov	x20, x1
    err = txt_serialize_name(ts, object);
  40fafc:	97fffd9a 	bl	40f164 <txt_serialize_name>
    if (err != 0) {
  40fb00:	350001c0 	cbnz	w0, 40fb38 <txt_serialize_name_value+0x50>
    ts->rsp[ts->rsp_pos - 1] = ':'; /* replace comma with colon */
  40fb04:	f9402e60 	ldr	x0, [x19, #88]
  40fb08:	f9403661 	ldr	x1, [x19, #104]
  40fb0c:	8b010000 	add	x0, x0, x1
  40fb10:	52800741 	mov	w1, #0x3a                  	// #58
  40fb14:	381ff001 	sturb	w1, [x0, #-1]
    return ts->api->serialize_value(ts, object);
  40fb18:	aa1403e1 	mov	x1, x20
  40fb1c:	f9403a60 	ldr	x0, [x19, #112]
  40fb20:	f9400802 	ldr	x2, [x0, #16]
  40fb24:	aa1303e0 	mov	x0, x19
}
  40fb28:	a94153f3 	ldp	x19, x20, [sp, #16]
    return ts->api->serialize_value(ts, object);
  40fb2c:	aa0203f0 	mov	x16, x2
}
  40fb30:	a8c27bfd 	ldp	x29, x30, [sp], #32
    return ts->api->serialize_value(ts, object);
  40fb34:	d61f0200 	br	x16
}
  40fb38:	a94153f3 	ldp	x19, x20, [sp, #16]
  40fb3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  40fb40:	d65f03c0 	ret

000000000040fb44 <txt_serialize_list_start>:
    if (ts->rsp_size > ts->rsp_pos + 2) {
  40fb44:	a9460403 	ldp	x3, x1, [x0, #96]
  40fb48:	91000822 	add	x2, x1, #0x2
  40fb4c:	eb02007f 	cmp	x3, x2
  40fb50:	54000109 	b.ls	40fb70 <txt_serialize_list_start+0x2c>  // b.plast
        ts->rsp[ts->rsp_pos++] = c;
  40fb54:	f9402c02 	ldr	x2, [x0, #88]
  40fb58:	91000423 	add	x3, x1, #0x1
  40fb5c:	f9003403 	str	x3, [x0, #104]
  40fb60:	52800b60 	mov	w0, #0x5b                  	// #91
  40fb64:	38216840 	strb	w0, [x2, x1]
        return 0;
  40fb68:	52800000 	mov	w0, #0x0                   	// #0
}
  40fb6c:	d65f03c0 	ret
        ts->rsp_pos = 0;
  40fb70:	f900341f 	str	xzr, [x0, #104]
        return -THINGSET_ERR_RESPONSE_TOO_LARGE;
  40fb74:	12801c00 	mov	w0, #0xffffff1f            	// #-225
    return txt_serialize_start(ts, '[');
  40fb78:	17fffffd 	b	40fb6c <txt_serialize_list_start+0x28>

000000000040fb7c <jsmn_parse>:

/**
 * Parse JSON string and fill tokens.
 */
JSMN_API int jsmn_parse(jsmn_parser *parser, const char *js, const size_t len,
                        jsmntok_t *tokens, const unsigned int num_tokens) {
  40fb7c:	aa0003e5 	mov	x5, x0
    switch (js[parser->pos]) {
  40fb80:	d284c00a 	mov	x10, #0x2600                	// #9728
  int r;
  int i;
  jsmntok_t *token;
  int count = parser->toknext;
  40fb84:	b9400400 	ldr	w0, [x0, #4]
    switch (js[parser->pos]) {
  40fb88:	f2c2002a 	movk	x10, #0x1001, lsl #32
      switch (js[parser->pos]) {
  40fb8c:	d280882d 	mov	x13, #0x441                 	// #1089
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
    char c;
    jsmntype_t type;

    c = js[parser->pos];
    switch (c) {
  40fb90:	d284c00f 	mov	x15, #0x2600                	// #9728
    switch (js[parser->pos]) {
  40fb94:	f2e0800a 	movk	x10, #0x400, lsl #48
  tok->start = tok->end = -1;
  40fb98:	92800009 	mov	x9, #0xffffffffffffffff    	// #-1
  token->type = type;
  40fb9c:	5280010b 	mov	w11, #0x8                   	// #8
      switch (js[parser->pos]) {
  40fba0:	d280002c 	mov	x12, #0x1                   	// #1
  40fba4:	f2a0288d 	movk	x13, #0x144, lsl #16
  token->type = type;
  40fba8:	5280008e 	mov	w14, #0x4                   	// #4
    switch (c) {
  40fbac:	f2c0002f 	movk	x15, #0x1, lsl #32
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40fbb0:	b94000a6 	ldr	w6, [x5]
  40fbb4:	2a0603e7 	mov	w7, w6
  40fbb8:	eb26405f 	cmp	x2, w6, uxtw
  40fbbc:	54000069 	b.ls	40fbc8 <jsmn_parse+0x4c>  // b.plast
  40fbc0:	38676827 	ldrb	w7, [x1, x7]
  40fbc4:	350000e7 	cbnz	w7, 40fbe0 <jsmn_parse+0x64>
      return JSMN_ERROR_INVAL;
#endif
    }
  }

  if (tokens != NULL) {
  40fbc8:	b40000a3 	cbz	x3, 40fbdc <jsmn_parse+0x60>
    for (i = parser->toknext - 1; i >= 0; i--) {
  40fbcc:	b94004a1 	ldr	w1, [x5, #4]
  40fbd0:	51000421 	sub	w1, w1, #0x1
  40fbd4:	8b21d063 	add	x3, x3, w1, sxtw #4
  40fbd8:	36f82001 	tbz	w1, #31, 40ffd8 <jsmn_parse+0x45c>
      }
    }
  }

  return count;
}
  40fbdc:	d65f03c0 	ret
    switch (c) {
  40fbe0:	7100e8ff 	cmp	w7, #0x3a
  40fbe4:	540009e0 	b.eq	40fd20 <jsmn_parse+0x1a4>  // b.none
  40fbe8:	54000408 	b.hi	40fc68 <jsmn_parse+0xec>  // b.pmore
  40fbec:	710088ff 	cmp	w7, #0x22
  40fbf0:	54000da0 	b.eq	40fda4 <jsmn_parse+0x228>  // b.none
  40fbf4:	54000168 	b.hi	40fc20 <jsmn_parse+0xa4>  // b.pmore
  40fbf8:	510024e8 	sub	w8, w7, #0x9
  40fbfc:	12001d08 	and	w8, w8, #0xff
  40fc00:	71005d1f 	cmp	w8, #0x17
  40fc04:	54000128 	b.hi	40fc28 <jsmn_parse+0xac>  // b.pmore
  40fc08:	9ac725e7 	lsr	x7, x15, x7
  40fc0c:	360000e7 	tbz	w7, #0, 40fc28 <jsmn_parse+0xac>
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40fc10:	b94000a6 	ldr	w6, [x5]
  40fc14:	110004c6 	add	w6, w6, #0x1
  40fc18:	b90000a6 	str	w6, [x5]
  40fc1c:	17ffffe5 	b	40fbb0 <jsmn_parse+0x34>
    switch (c) {
  40fc20:	7100b0ff 	cmp	w7, #0x2c
  40fc24:	54001760 	b.eq	40ff10 <jsmn_parse+0x394>  // b.none
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40fc28:	b94000a7 	ldr	w7, [x5]
  40fc2c:	2a0703e8 	mov	w8, w7
  40fc30:	eb27405f 	cmp	x2, w7, uxtw
  40fc34:	54000129 	b.ls	40fc58 <jsmn_parse+0xdc>  // b.plast
  40fc38:	38686828 	ldrb	w8, [x1, x8]
  40fc3c:	340000e8 	cbz	w8, 40fc58 <jsmn_parse+0xdc>
    switch (js[parser->pos]) {
  40fc40:	7100e91f 	cmp	w8, #0x3a
  40fc44:	540019a8 	b.hi	40ff78 <jsmn_parse+0x3fc>  // b.pmore
  40fc48:	7100211f 	cmp	w8, #0x8
  40fc4c:	540019c9 	b.ls	40ff84 <jsmn_parse+0x408>  // b.plast
  40fc50:	9ac82550 	lsr	x16, x10, x8
  40fc54:	36001990 	tbz	w16, #0, 40ff84 <jsmn_parse+0x408>
  if (tokens == NULL) {
  40fc58:	b5001a43 	cbnz	x3, 40ffa0 <jsmn_parse+0x424>
  parser->pos--;
  40fc5c:	510004e7 	sub	w7, w7, #0x1
    parser->pos--;
  40fc60:	b90000a7 	str	w7, [x5]
  40fc64:	1400006d 	b	40fe18 <jsmn_parse+0x29c>
    switch (c) {
  40fc68:	7101ecff 	cmp	w7, #0x7b
  40fc6c:	540002a0 	b.eq	40fcc0 <jsmn_parse+0x144>  // b.none
  40fc70:	54000108 	b.hi	40fc90 <jsmn_parse+0x114>  // b.pmore
  40fc74:	71016cff 	cmp	w7, #0x5b
  40fc78:	54000240 	b.eq	40fcc0 <jsmn_parse+0x144>  // b.none
  40fc7c:	710174ff 	cmp	w7, #0x5d
  40fc80:	54fffd41 	b.ne	40fc28 <jsmn_parse+0xac>  // b.any
      if (tokens == NULL) {
  40fc84:	b4fffc63 	cbz	x3, 40fc10 <jsmn_parse+0x94>
      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
  40fc88:	52800050 	mov	w16, #0x2                   	// #2
  40fc8c:	14000005 	b	40fca0 <jsmn_parse+0x124>
    switch (c) {
  40fc90:	7101f4ff 	cmp	w7, #0x7d
  40fc94:	54fffca1 	b.ne	40fc28 <jsmn_parse+0xac>  // b.any
      if (tokens == NULL) {
  40fc98:	b4fffbc3 	cbz	x3, 40fc10 <jsmn_parse+0x94>
      type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
  40fc9c:	52800030 	mov	w16, #0x1                   	// #1
      for (i = parser->toknext - 1; i >= 0; i--) {
  40fca0:	b94004a7 	ldr	w7, [x5, #4]
  40fca4:	510004e7 	sub	w7, w7, #0x1
  40fca8:	8b27d068 	add	x8, x3, w7, sxtw #4
  40fcac:	36f80427 	tbz	w7, #31, 40fd30 <jsmn_parse+0x1b4>
      if (i == -1) {
  40fcb0:	310004ff 	cmn	w7, #0x1
  40fcb4:	54fffae1 	b.ne	40fc10 <jsmn_parse+0x94>  // b.any
            return JSMN_ERROR_INVAL;
  40fcb8:	12800020 	mov	w0, #0xfffffffe            	// #-2
  40fcbc:	17ffffc8 	b	40fbdc <jsmn_parse+0x60>
      count++;
  40fcc0:	11000400 	add	w0, w0, #0x1
      if (tokens == NULL) {
  40fcc4:	b4fffa63 	cbz	x3, 40fc10 <jsmn_parse+0x94>
  if (parser->toknext >= num_tokens) {
  40fcc8:	b94004a6 	ldr	w6, [x5, #4]
  40fccc:	6b06009f 	cmp	w4, w6
  40fcd0:	540008e9 	b.ls	40fdec <jsmn_parse+0x270>  // b.plast
  tok = &tokens[parser->toknext++];
  40fcd4:	110004c8 	add	w8, w6, #0x1
  40fcd8:	d37c7cc6 	ubfiz	x6, x6, #4, #32
  40fcdc:	8b060070 	add	x16, x3, x6
  40fce0:	b90004a8 	str	w8, [x5, #4]
  tok->start = tok->end = -1;
  40fce4:	f8004209 	stur	x9, [x16, #4]
  tok->size = 0;
  40fce8:	b9000e1f 	str	wzr, [x16, #12]
      if (parser->toksuper != -1) {
  40fcec:	b94008a8 	ldr	w8, [x5, #8]
  40fcf0:	3100051f 	cmn	w8, #0x1
  40fcf4:	540000a0 	b.eq	40fd08 <jsmn_parse+0x18c>  // b.none
        jsmntok_t *t = &tokens[parser->toksuper];
  40fcf8:	8b28d068 	add	x8, x3, w8, sxtw #4
        t->size++;
  40fcfc:	b9400d11 	ldr	w17, [x8, #12]
  40fd00:	11000631 	add	w17, w17, #0x1
  40fd04:	b9000d11 	str	w17, [x8, #12]
      token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
  40fd08:	7101ecff 	cmp	w7, #0x7b
  40fd0c:	1a9f07e7 	cset	w7, ne  // ne = any
  40fd10:	110004e7 	add	w7, w7, #0x1
  40fd14:	b8266867 	str	w7, [x3, x6]
      token->start = parser->pos;
  40fd18:	b94000a6 	ldr	w6, [x5]
  40fd1c:	b9000606 	str	w6, [x16, #4]
      parser->toksuper = parser->toknext - 1;
  40fd20:	b94004a6 	ldr	w6, [x5, #4]
  40fd24:	510004c6 	sub	w6, w6, #0x1
              parser->toksuper = i;
  40fd28:	b90008a6 	str	w6, [x5, #8]
              break;
  40fd2c:	17ffffb9 	b	40fc10 <jsmn_parse+0x94>
        if (token->start != -1 && token->end == -1) {
  40fd30:	b9400511 	ldr	w17, [x8, #4]
  40fd34:	3100063f 	cmn	w17, #0x1
  40fd38:	54000260 	b.eq	40fd84 <jsmn_parse+0x208>  // b.none
  40fd3c:	b9400911 	ldr	w17, [x8, #8]
  40fd40:	3100063f 	cmn	w17, #0x1
  40fd44:	54000201 	b.ne	40fd84 <jsmn_parse+0x208>  // b.any
          if (token->type != type) {
  40fd48:	b9400112 	ldr	w18, [x8]
  40fd4c:	6b10025f 	cmp	w18, w16
  40fd50:	54fffb41 	b.ne	40fcb8 <jsmn_parse+0x13c>  // b.any
          token->end = parser->pos + 1;
  40fd54:	110004c6 	add	w6, w6, #0x1
          parser->toksuper = -1;
  40fd58:	b90008b1 	str	w17, [x5, #8]
          token->end = parser->pos + 1;
  40fd5c:	b9000906 	str	w6, [x8, #8]
      if (i == -1) {
  40fd60:	8b27d066 	add	x6, x3, w7, sxtw #4
        if (token->start != -1 && token->end == -1) {
  40fd64:	b94004c8 	ldr	w8, [x6, #4]
  40fd68:	3100051f 	cmn	w8, #0x1
  40fd6c:	54000120 	b.eq	40fd90 <jsmn_parse+0x214>  // b.none
  40fd70:	b94008c8 	ldr	w8, [x6, #8]
  40fd74:	3100051f 	cmn	w8, #0x1
  40fd78:	540000c1 	b.ne	40fd90 <jsmn_parse+0x214>  // b.any
          parser->toksuper = i;
  40fd7c:	b90008a7 	str	w7, [x5, #8]
          break;
  40fd80:	17ffffa4 	b	40fc10 <jsmn_parse+0x94>
      for (i = parser->toknext - 1; i >= 0; i--) {
  40fd84:	510004e7 	sub	w7, w7, #0x1
  40fd88:	d1004108 	sub	x8, x8, #0x10
  40fd8c:	17ffffc8 	b	40fcac <jsmn_parse+0x130>
      for (; i >= 0; i--) {
  40fd90:	510004e7 	sub	w7, w7, #0x1
  40fd94:	d10040c6 	sub	x6, x6, #0x10
  40fd98:	310004ff 	cmn	w7, #0x1
  40fd9c:	54fffe41 	b.ne	40fd64 <jsmn_parse+0x1e8>  // b.any
  40fda0:	17ffff9c 	b	40fc10 <jsmn_parse+0x94>
  parser->pos++;
  40fda4:	110004c7 	add	w7, w6, #0x1
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40fda8:	2a0703f1 	mov	w17, w7
  parser->pos++;
  40fdac:	b90000a7 	str	w7, [x5]
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40fdb0:	2a0703e8 	mov	w8, w7
  40fdb4:	eb27405f 	cmp	x2, w7, uxtw
  40fdb8:	54000069 	b.ls	40fdc4 <jsmn_parse+0x248>  // b.plast
  40fdbc:	38686828 	ldrb	w8, [x1, x8]
  40fdc0:	35000088 	cbnz	w8, 40fdd0 <jsmn_parse+0x254>
  parser->pos = start;
  40fdc4:	b90000a6 	str	w6, [x5]
        return JSMN_ERROR_PART;
  40fdc8:	12800040 	mov	w0, #0xfffffffd            	// #-3
  40fdcc:	17ffff84 	b	40fbdc <jsmn_parse+0x60>
    if (c == '\"') {
  40fdd0:	7100891f 	cmp	w8, #0x22
  40fdd4:	54000361 	b.ne	40fe40 <jsmn_parse+0x2c4>  // b.any
      if (tokens == NULL) {
  40fdd8:	b4000203 	cbz	x3, 40fe18 <jsmn_parse+0x29c>
  if (parser->toknext >= num_tokens) {
  40fddc:	b94004a7 	ldr	w7, [x5, #4]
  40fde0:	6b07009f 	cmp	w4, w7
  40fde4:	54000088 	b.hi	40fdf4 <jsmn_parse+0x278>  // b.pmore
    parser->pos = start;
  40fde8:	b90000a6 	str	w6, [x5]
        return JSMN_ERROR_NOMEM;
  40fdec:	12800000 	mov	w0, #0xffffffff            	// #-1
  40fdf0:	17ffff7b 	b	40fbdc <jsmn_parse+0x60>
  tok = &tokens[parser->toknext++];
  40fdf4:	110004e6 	add	w6, w7, #0x1
  40fdf8:	d37c7ce7 	ubfiz	x7, x7, #4, #32
  40fdfc:	b90004a6 	str	w6, [x5, #4]
  40fe00:	8b070066 	add	x6, x3, x7
  tok->start = tok->end = -1;
  40fe04:	f80040c9 	stur	x9, [x6, #4]
  tok->size = 0;
  40fe08:	b9000cdf 	str	wzr, [x6, #12]
      jsmn_fill_token(token, JSMN_STRING, start + 1, parser->pos);
  40fe0c:	b94000a8 	ldr	w8, [x5]
  token->type = type;
  40fe10:	b827686e 	str	w14, [x3, x7]
  token->end = end;
  40fe14:	2900a0d1 	stp	w17, w8, [x6, #4]
      if (parser->toksuper != -1 && tokens != NULL) {
  40fe18:	b94008a6 	ldr	w6, [x5, #8]
      count++;
  40fe1c:	11000400 	add	w0, w0, #0x1
      if (parser->toksuper != -1 && tokens != NULL) {
  40fe20:	310004df 	cmn	w6, #0x1
  40fe24:	54ffef60 	b.eq	40fc10 <jsmn_parse+0x94>  // b.none
  40fe28:	b4ffef43 	cbz	x3, 40fc10 <jsmn_parse+0x94>
        tokens[parser->toksuper].size++;
  40fe2c:	8b26d066 	add	x6, x3, w6, sxtw #4
  40fe30:	b9400cc7 	ldr	w7, [x6, #12]
  40fe34:	110004e7 	add	w7, w7, #0x1
  40fe38:	b9000cc7 	str	w7, [x6, #12]
  40fe3c:	17ffff75 	b	40fc10 <jsmn_parse+0x94>
    if (c == '\\' && parser->pos + 1 < len) {
  40fe40:	7101711f 	cmp	w8, #0x5c
  40fe44:	540001e1 	b.ne	40fe80 <jsmn_parse+0x304>  // b.any
  40fe48:	110004e8 	add	w8, w7, #0x1
  40fe4c:	110004f0 	add	w16, w7, #0x1
  40fe50:	eb02011f 	cmp	x8, x2
  40fe54:	54000162 	b.cs	40fe80 <jsmn_parse+0x304>  // b.hs, b.nlast
      parser->pos++;
  40fe58:	b90000b0 	str	w16, [x5]
      switch (js[parser->pos]) {
  40fe5c:	38686828 	ldrb	w8, [x1, x8]
  40fe60:	7101d51f 	cmp	w8, #0x75
  40fe64:	54000428 	b.hi	40fee8 <jsmn_parse+0x36c>  // b.pmore
  40fe68:	71016d1f 	cmp	w8, #0x5b
  40fe6c:	54000108 	b.hi	40fe8c <jsmn_parse+0x310>  // b.pmore
  40fe70:	7100891f 	cmp	w8, #0x22
  40fe74:	54000060 	b.eq	40fe80 <jsmn_parse+0x304>  // b.none
  40fe78:	7100bd1f 	cmp	w8, #0x2f
  40fe7c:	54000361 	b.ne	40fee8 <jsmn_parse+0x36c>  // b.any
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40fe80:	b94000a7 	ldr	w7, [x5]
  40fe84:	110004e7 	add	w7, w7, #0x1
  40fe88:	17ffffc9 	b	40fdac <jsmn_parse+0x230>
      switch (js[parser->pos]) {
  40fe8c:	51017110 	sub	w16, w8, #0x5c
  40fe90:	9ad02190 	lsl	x16, x12, x16
  40fe94:	ea0d021f 	tst	x16, x13
  40fe98:	54ffff41 	b.ne	40fe80 <jsmn_parse+0x304>  // b.any
  40fe9c:	7101d51f 	cmp	w8, #0x75
  40fea0:	54000241 	b.ne	40fee8 <jsmn_parse+0x36c>  // b.any
        parser->pos++;
  40fea4:	110008e7 	add	w7, w7, #0x2
  40fea8:	52800092 	mov	w18, #0x4                   	// #4
  40feac:	b90000a7 	str	w7, [x5]
        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
  40feb0:	b94000a8 	ldr	w8, [x5]
  40feb4:	2a0803e7 	mov	w7, w8
  40feb8:	eb28405f 	cmp	x2, w8, uxtw
  40febc:	54000229 	b.ls	40ff00 <jsmn_parse+0x384>  // b.plast
  40fec0:	38676827 	ldrb	w7, [x1, x7]
  40fec4:	340001e7 	cbz	w7, 40ff00 <jsmn_parse+0x384>
          if (!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||   /* 0-9 */
  40fec8:	121a78f0 	and	w16, w7, #0xffffffdf
  40fecc:	5100c0e7 	sub	w7, w7, #0x30
  40fed0:	51010610 	sub	w16, w16, #0x41
  40fed4:	12001ce7 	and	w7, w7, #0xff
  40fed8:	12001e10 	and	w16, w16, #0xff
  40fedc:	7100161f 	cmp	w16, #0x5
  40fee0:	7a4988e0 	ccmp	w7, #0x9, #0x0, hi  // hi = pmore
  40fee4:	54000069 	b.ls	40fef0 <jsmn_parse+0x374>  // b.plast
      parser->pos = start;
  40fee8:	b90000a6 	str	w6, [x5]
      if (r < 0) {
  40feec:	17ffff73 	b	40fcb8 <jsmn_parse+0x13c>
          parser->pos++;
  40fef0:	11000508 	add	w8, w8, #0x1
  40fef4:	b90000a8 	str	w8, [x5]
        for (i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0';
  40fef8:	71000652 	subs	w18, w18, #0x1
  40fefc:	54fffda1 	b.ne	40feb0 <jsmn_parse+0x334>  // b.any
        parser->pos--;
  40ff00:	b94000a7 	ldr	w7, [x5]
  40ff04:	510004e7 	sub	w7, w7, #0x1
  40ff08:	b90000a7 	str	w7, [x5]
        break;
  40ff0c:	17ffffdd 	b	40fe80 <jsmn_parse+0x304>
      if (tokens != NULL && parser->toksuper != -1 &&
  40ff10:	b4ffe803 	cbz	x3, 40fc10 <jsmn_parse+0x94>
  40ff14:	b94008a6 	ldr	w6, [x5, #8]
  40ff18:	310004df 	cmn	w6, #0x1
  40ff1c:	54ffe7a0 	b.eq	40fc10 <jsmn_parse+0x94>  // b.none
          tokens[parser->toksuper].type != JSMN_ARRAY &&
  40ff20:	937c7cc6 	sbfiz	x6, x6, #4, #32
  40ff24:	b8666866 	ldr	w6, [x3, x6]
  40ff28:	510004c6 	sub	w6, w6, #0x1
  40ff2c:	710004df 	cmp	w6, #0x1
  40ff30:	54ffe709 	b.ls	40fc10 <jsmn_parse+0x94>  // b.plast
        for (i = parser->toknext - 1; i >= 0; i--) {
  40ff34:	b94004a6 	ldr	w6, [x5, #4]
  40ff38:	510004c6 	sub	w6, w6, #0x1
  40ff3c:	8b26d067 	add	x7, x3, w6, sxtw #4
  40ff40:	37ffe686 	tbnz	w6, #31, 40fc10 <jsmn_parse+0x94>
          if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
  40ff44:	b94000e8 	ldr	w8, [x7]
  40ff48:	51000508 	sub	w8, w8, #0x1
  40ff4c:	7100051f 	cmp	w8, #0x1
  40ff50:	540000e8 	b.hi	40ff6c <jsmn_parse+0x3f0>  // b.pmore
            if (tokens[i].start != -1 && tokens[i].end == -1) {
  40ff54:	b94004e8 	ldr	w8, [x7, #4]
  40ff58:	3100051f 	cmn	w8, #0x1
  40ff5c:	54000080 	b.eq	40ff6c <jsmn_parse+0x3f0>  // b.none
  40ff60:	b94008e8 	ldr	w8, [x7, #8]
  40ff64:	3100051f 	cmn	w8, #0x1
  40ff68:	54ffee00 	b.eq	40fd28 <jsmn_parse+0x1ac>  // b.none
        for (i = parser->toknext - 1; i >= 0; i--) {
  40ff6c:	510004c6 	sub	w6, w6, #0x1
  40ff70:	d10040e7 	sub	x7, x7, #0x10
  40ff74:	17fffff3 	b	40ff40 <jsmn_parse+0x3c4>
    switch (js[parser->pos]) {
  40ff78:	121a7910 	and	w16, w8, #0xffffffdf
  40ff7c:	7101761f 	cmp	w16, #0x5d
  40ff80:	54ffe6c0 	b.eq	40fc58 <jsmn_parse+0xdc>  // b.none
    if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
  40ff84:	51008108 	sub	w8, w8, #0x20
  40ff88:	12001d08 	and	w8, w8, #0xff
  40ff8c:	7101791f 	cmp	w8, #0x5e
  40ff90:	54fffac8 	b.hi	40fee8 <jsmn_parse+0x36c>  // b.pmore
  for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
  40ff94:	110004e7 	add	w7, w7, #0x1
  40ff98:	b90000a7 	str	w7, [x5]
  40ff9c:	17ffff23 	b	40fc28 <jsmn_parse+0xac>
  if (parser->toknext >= num_tokens) {
  40ffa0:	b94004a7 	ldr	w7, [x5, #4]
  40ffa4:	6b07009f 	cmp	w4, w7
  40ffa8:	54fff209 	b.ls	40fde8 <jsmn_parse+0x26c>  // b.plast
  tok = &tokens[parser->toknext++];
  40ffac:	110004e8 	add	w8, w7, #0x1
  40ffb0:	d37c7ce7 	ubfiz	x7, x7, #4, #32
  40ffb4:	b90004a8 	str	w8, [x5, #4]
  40ffb8:	8b070068 	add	x8, x3, x7
  tok->start = tok->end = -1;
  40ffbc:	f8004109 	stur	x9, [x8, #4]
  tok->size = 0;
  40ffc0:	b9000d1f 	str	wzr, [x8, #12]
  jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
  40ffc4:	b94000b0 	ldr	w16, [x5]
  token->type = type;
  40ffc8:	b827686b 	str	w11, [x3, x7]
  token->end = end;
  40ffcc:	2900c106 	stp	w6, w16, [x8, #4]
  parser->pos--;
  40ffd0:	b94000a7 	ldr	w7, [x5]
  40ffd4:	17ffff22 	b	40fc5c <jsmn_parse+0xe0>
      if (tokens[i].start != -1 && tokens[i].end == -1) {
  40ffd8:	b9400462 	ldr	w2, [x3, #4]
  40ffdc:	3100045f 	cmn	w2, #0x1
  40ffe0:	54000080 	b.eq	40fff0 <jsmn_parse+0x474>  // b.none
  40ffe4:	b9400862 	ldr	w2, [x3, #8]
  40ffe8:	3100045f 	cmn	w2, #0x1
  40ffec:	54ffeee0 	b.eq	40fdc8 <jsmn_parse+0x24c>  // b.none
    for (i = parser->toknext - 1; i >= 0; i--) {
  40fff0:	51000421 	sub	w1, w1, #0x1
  40fff4:	d1004063 	sub	x3, x3, #0x10
  40fff8:	17fffef8 	b	40fbd8 <jsmn_parse+0x5c>

000000000040fffc <jsmn_init>:
 * available.
 */
JSMN_API void jsmn_init(jsmn_parser *parser) {
  parser->pos = 0;
  parser->toknext = 0;
  parser->toksuper = -1;
  40fffc:	12800001 	mov	w1, #0xffffffff            	// #-1
  parser->pos = 0;
  410000:	f900001f 	str	xzr, [x0]
  parser->toksuper = -1;
  410004:	b9000801 	str	w1, [x0, #8]
}
  410008:	d65f03c0 	ret

000000000041000c <txt_parse_payload>:
{
  41000c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  410010:	910003fd 	mov	x29, sp
  410014:	a90153f3 	stp	x19, x20, [sp, #16]
  410018:	aa0003f3 	mov	x19, x0
  41001c:	b0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
    jsmn_init(&parser);
  410020:	9100a3f4 	add	x20, sp, #0x28
{
  410024:	f9475c00 	ldr	x0, [x0, #3768]
  410028:	f9400001 	ldr	x1, [x0]
  41002c:	f9001fe1 	str	x1, [sp, #56]
  410030:	d2800001 	mov	x1, #0x0                   	// #0
    ts->tok_pos = 0;
  410034:	f901d27f 	str	xzr, [x19, #928]
    ts->msg_payload = ts->msg + ts->msg_pos;
  410038:	f9401e60 	ldr	x0, [x19, #56]
  41003c:	f9402661 	ldr	x1, [x19, #72]
  410040:	8b010000 	add	x0, x0, x1
  410044:	f9002a60 	str	x0, [x19, #80]
    jsmn_init(&parser);
  410048:	aa1403e0 	mov	x0, x20
  41004c:	97ffffec 	bl	40fffc <jsmn_init>
    ret = jsmn_parse(&parser, ts->msg_payload, ts->msg_len - ts->msg_pos, ts->tokens,
  410050:	a9440262 	ldp	x2, x0, [x19, #64]
  410054:	9101e263 	add	x3, x19, #0x78
  410058:	f9402a61 	ldr	x1, [x19, #80]
  41005c:	52806404 	mov	w4, #0x320                 	// #800
  410060:	cb000042 	sub	x2, x2, x0
  410064:	aa1403e0 	mov	x0, x20
  410068:	97fffec5 	bl	40fb7c <jsmn_parse>
    if (ret == JSMN_ERROR_NOMEM) {
  41006c:	3100041f 	cmn	w0, #0x1
  410070:	54000161 	b.ne	41009c <txt_parse_payload+0x90>  // b.any
        return -THINGSET_ERR_REQUEST_TOO_LARGE;
  410074:	12801580 	mov	w0, #0xffffff53            	// #-173
        ts->rsp_pos = 0;
  410078:	f900367f 	str	xzr, [x19, #104]
}
  41007c:	b0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  410080:	f9475c21 	ldr	x1, [x1, #3768]
  410084:	f9401fe3 	ldr	x3, [sp, #56]
  410088:	f9400022 	ldr	x2, [x1]
  41008c:	eb020063 	subs	x3, x3, x2
  410090:	d2800002 	mov	x2, #0x0                   	// #0
  410094:	54000140 	b.eq	4100bc <txt_parse_payload+0xb0>  // b.none
  410098:	97ffc522 	bl	401520 <__stack_chk_fail@plt>
    else if (ret < 0) {
  41009c:	36f80080 	tbz	w0, #31, 4100ac <txt_parse_payload+0xa0>
        return -THINGSET_ERR_BAD_REQUEST;
  4100a0:	128013e0 	mov	w0, #0xffffff60            	// #-160
        ts->rsp_pos = 0;
  4100a4:	f900367f 	str	xzr, [x19, #104]
        return -THINGSET_ERR_BAD_REQUEST;
  4100a8:	17fffff5 	b	41007c <txt_parse_payload+0x70>
    ts->tok_count = ret;
  4100ac:	93407c00 	sxtw	x0, w0
  4100b0:	f901ce60 	str	x0, [x19, #920]
    return 0;
  4100b4:	52800000 	mov	w0, #0x0                   	// #0
  4100b8:	17fffff1 	b	41007c <txt_parse_payload+0x70>
}
  4100bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4100c0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4100c4:	d65f03c0 	ret

00000000004100c8 <txt_deserialize_payload_reset>:
    ts->msg_pos = ts->msg_payload - ts->msg;
  4100c8:	f9401c03 	ldr	x3, [x0, #56]
  4100cc:	f9402802 	ldr	x2, [x0, #80]
  4100d0:	cb030042 	sub	x2, x2, x3
  4100d4:	f9002402 	str	x2, [x0, #72]
    txt_parse_payload(ts);
  4100d8:	17ffffcd 	b	41000c <txt_parse_payload>

00000000004100dc <thingset_txt_setup>:
    .deserialize_finish = txt_deserialize_finish,
};

inline void thingset_txt_setup(struct thingset_context *ts)
{
    ts->api = &txt_api;
  4100dc:	d0000101 	adrp	x1, 432000 <__dso_handle>
  4100e0:	9125e021 	add	x1, x1, #0x978
  4100e4:	f9003801 	str	x1, [x0, #112]
}
  4100e8:	d65f03c0 	ret

00000000004100ec <thingset_txt_process>:

int thingset_txt_process(struct thingset_context *ts)
{
  4100ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4100f0:	910003fd 	mov	x29, sp
  4100f4:	a90153f3 	stp	x19, x20, [sp, #16]
  4100f8:	aa0003f3 	mov	x19, x0
    ts->api = &txt_api;
  4100fc:	d0000100 	adrp	x0, 432000 <__dso_handle>
{
  410100:	a9025bf5 	stp	x21, x22, [sp, #32]
    ts->api = &txt_api;
  410104:	9125e000 	add	x0, x0, #0x978

    thingset_txt_setup(ts);

    /* requests ordered with expected highest probability first */
    int (*request_fn)(struct thingset_context * ts);
    switch (ts->msg[0]) {
  410108:	f9401e75 	ldr	x21, [x19, #56]
    ts->api = &txt_api;
  41010c:	f9003a60 	str	x0, [x19, #112]
    switch (ts->msg[0]) {
  410110:	394002a0 	ldrb	w0, [x21]
  410114:	7100f41f 	cmp	w0, #0x3d
  410118:	540005c0 	b.eq	4101d0 <thingset_txt_process+0xe4>  // b.none
  41011c:	54000128 	b.hi	410140 <thingset_txt_process+0x54>  // b.pmore
  410120:	7100ac1f 	cmp	w0, #0x2b
  410124:	540005c0 	b.eq	4101dc <thingset_txt_process+0xf0>  // b.none
  410128:	7100b41f 	cmp	w0, #0x2d
  41012c:	540005e0 	b.eq	4101e8 <thingset_txt_process+0xfc>  // b.none
  410130:	7100841f 	cmp	w0, #0x21
  410134:	54000600 	b.eq	4101f4 <thingset_txt_process+0x108>  // b.none
  410138:	128013f5 	mov	w21, #0xffffff60            	// #-160
  41013c:	14000046 	b	410254 <thingset_txt_process+0x168>
  410140:	7100fc1f 	cmp	w0, #0x3f
  410144:	540005e0 	b.eq	410200 <thingset_txt_process+0x114>  // b.none
  410148:	7101001f 	cmp	w0, #0x40
  41014c:	54ffff61 	b.ne	410138 <thingset_txt_process+0x4c>  // b.any
            break;
        case THINGSET_TXT_DELETE:
            request_fn = thingset_common_delete;
            break;
        case THINGSET_TXT_DESIRE:
            request_fn = thingset_txt_desire;
  410150:	b0000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  410154:	f9479694 	ldr	x20, [x20, #3880]
    char *path_begin = (char *)ts->msg + 1;
  410158:	910006b5 	add	x21, x21, #0x1
    char *path_end = memchr(path_begin, ' ', ts->msg_len - 1);
  41015c:	f9402276 	ldr	x22, [x19, #64]
  410160:	52800401 	mov	w1, #0x20                  	// #32
  410164:	aa1503e0 	mov	x0, x21
  410168:	d10006c2 	sub	x2, x22, #0x1
        path_len = path_end - path_begin;
  41016c:	510006d6 	sub	w22, w22, #0x1
    char *path_end = memchr(path_begin, ' ', ts->msg_len - 1);
  410170:	97ffc534 	bl	401640 <memchr@plt>
        path_len = path_end - path_begin;
  410174:	cb150001 	sub	x1, x0, x21
  410178:	f100001f 	cmp	x0, #0x0
    int err = thingset_endpoint_by_path(ts, &ts->endpoint, path_begin, path_len);
  41017c:	aa1503e2 	mov	x2, x21
        path_len = path_end - path_begin;
  410180:	1a8102d6 	csel	w22, w22, w1, eq  // eq = none
    int err = thingset_endpoint_by_path(ts, &ts->endpoint, path_begin, path_len);
  410184:	aa1303e0 	mov	x0, x19
  410188:	910ee261 	add	x1, x19, #0x3b8
  41018c:	93407ec3 	sxtw	x3, w22
  410190:	97fff29d 	bl	40cc04 <thingset_endpoint_by_path>
  410194:	2a0003f5 	mov	w21, w0
    if (err != 0) {
  410198:	350003a0 	cbnz	w0, 41020c <thingset_txt_process+0x120>
    ts->msg_pos += path_len + 1;
  41019c:	f9402660 	ldr	x0, [x19, #72]
  4101a0:	110006d6 	add	w22, w22, #0x1
  4101a4:	8b36c016 	add	x22, x0, w22, sxtw
  4101a8:	f9002676 	str	x22, [x19, #72]
    if (ret != 0) {
        ts->api->serialize_response(ts, -ret, "Invalid endpoint");
        goto out;
    }

    ret = txt_parse_payload(ts);
  4101ac:	aa1303e0 	mov	x0, x19
  4101b0:	97ffff97 	bl	41000c <txt_parse_payload>
  4101b4:	2a0003f5 	mov	w21, w0
    if (ret != 0) {
  4101b8:	34000580 	cbz	w0, 410268 <thingset_txt_process+0x17c>
        ts->api->serialize_response(ts, -ret, "JSON parsing error");
  4101bc:	f9403a60 	ldr	x0, [x19, #112]
  4101c0:	b0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  4101c4:	913f2c42 	add	x2, x2, #0xfcb
  4101c8:	f9400003 	ldr	x3, [x0]
  4101cc:	14000014 	b	41021c <thingset_txt_process+0x130>
    switch (ts->msg[0]) {
  4101d0:	b0000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  4101d4:	f9472294 	ldr	x20, [x20, #3648]
  4101d8:	17ffffe0 	b	410158 <thingset_txt_process+0x6c>
            request_fn = thingset_common_create;
  4101dc:	b0000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  4101e0:	f9478e94 	ldr	x20, [x20, #3864]
  4101e4:	17ffffdd 	b	410158 <thingset_txt_process+0x6c>
            request_fn = thingset_common_delete;
  4101e8:	b0000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  4101ec:	f947b694 	ldr	x20, [x20, #3944]
  4101f0:	17ffffda 	b	410158 <thingset_txt_process+0x6c>
            request_fn = thingset_common_exec;
  4101f4:	b0000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  4101f8:	f9476a94 	ldr	x20, [x20, #3792]
  4101fc:	17ffffd7 	b	410158 <thingset_txt_process+0x6c>
            request_fn = thingset_txt_get_fetch;
  410200:	b0000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  410204:	f9479294 	ldr	x20, [x20, #3872]
  410208:	17ffffd4 	b	410158 <thingset_txt_process+0x6c>
        ts->api->serialize_response(ts, -ret, "Invalid endpoint");
  41020c:	f9403a60 	ldr	x0, [x19, #112]
  410210:	b0000042 	adrp	x2, 419000 <__func__.2+0xa80>
  410214:	91392c42 	add	x2, x2, #0xe4b
  410218:	f9400003 	ldr	x3, [x0]
        ts->api->serialize_response(ts, -ret, "JSON parsing error");
  41021c:	4b1503e1 	neg	w1, w21
  410220:	aa1303e0 	mov	x0, x19
  410224:	d63f0060 	blr	x3
    }

    ret = request_fn(ts);

out:
    if (ts->msg[0] != THINGSET_TXT_DESIRE) {
  410228:	f9401e60 	ldr	x0, [x19, #56]
  41022c:	39400000 	ldrb	w0, [x0]
  410230:	7101001f 	cmp	w0, #0x40
  410234:	54000220 	b.eq	410278 <thingset_txt_process+0x18c>  // b.none
        if (ts->rsp_pos > 0) {
  410238:	f9403660 	ldr	x0, [x19, #104]
  41023c:	b40000a0 	cbz	x0, 410250 <thingset_txt_process+0x164>
            ts->api->serialize_finish(ts);
  410240:	f9403a60 	ldr	x0, [x19, #112]
  410244:	f9402c01 	ldr	x1, [x0, #88]
  410248:	aa1303e0 	mov	x0, x19
  41024c:	d63f0020 	blr	x1
        }
        return ts->rsp_pos;
  410250:	b9406a75 	ldr	w21, [x19, #104]
    }
    else {
        ts->rsp_pos = 0;
        return ret;
    }
}
  410254:	2a1503e0 	mov	w0, w21
  410258:	a94153f3 	ldp	x19, x20, [sp, #16]
  41025c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410260:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410264:	d65f03c0 	ret
    ret = request_fn(ts);
  410268:	aa1303e0 	mov	x0, x19
  41026c:	d63f0280 	blr	x20
  410270:	2a0003f5 	mov	w21, w0
  410274:	17ffffed 	b	410228 <thingset_txt_process+0x13c>
        ts->rsp_pos = 0;
  410278:	f900367f 	str	xzr, [x19, #104]
        return ret;
  41027c:	17fffff6 	b	410254 <thingset_txt_process+0x168>

0000000000410280 <zcbor_check_error.isra.0>:
#ifdef ZCBOR_STOP_ON_ERROR
/** Check stored error and fail if present, but only if stop_on_error is true. */
static inline bool zcbor_check_error(const zcbor_state_t *state)
{
	struct zcbor_state_constant  *cs = state->constant_state;
	return !(cs && cs->stop_on_error && cs->error);
  410280:	b40000e0 	cbz	x0, 41029c <zcbor_check_error.isra.0+0x1c>
  410284:	39407001 	ldrb	w1, [x0, #28]
  410288:	340000a1 	cbz	w1, 41029c <zcbor_check_error.isra.0+0x1c>
  41028c:	b9401800 	ldr	w0, [x0, #24]
  410290:	7100001f 	cmp	w0, #0x0
  410294:	1a9f17e0 	cset	w0, eq  // eq = none
}
  410298:	d65f03c0 	ret
	return !(cs && cs->stop_on_error && cs->error);
  41029c:	52800020 	mov	w0, #0x1                   	// #1
  4102a0:	17fffffe 	b	410298 <zcbor_check_error.isra.0+0x18>

00000000004102a4 <zcbor_error>:
	}
}

/** Write the provided error to the error state. */
static inline void zcbor_error(zcbor_state_t *state, int err)
{
  4102a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4102a8:	2a0103e3 	mov	w3, w1
  4102ac:	910003fd 	mov	x29, sp
  4102b0:	f9401402 	ldr	x2, [x0, #40]
#ifdef ZCBOR_STOP_ON_ERROR
	if (zcbor_check_error(state))
  4102b4:	aa0203e0 	mov	x0, x2
  4102b8:	97fffff2 	bl	410280 <zcbor_check_error.isra.0>
  4102bc:	72001c1f 	tst	w0, #0xff
  4102c0:	54000060 	b.eq	4102cc <zcbor_error+0x28>  // b.none
#endif
	{
		if (state->constant_state) {
  4102c4:	b4000042 	cbz	x2, 4102cc <zcbor_error+0x28>
			state->constant_state->error = err;
  4102c8:	b9001843 	str	w3, [x2, #24]
		}
	}
}
  4102cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4102d0:	d65f03c0 	ret

00000000004102d4 <zcbor_new_backup>:

_Static_assert((sizeof(zcbor_state_t) >= sizeof(struct zcbor_state_constant)),
	"This code needs zcbor_state_t to be at least as large as zcbor_backups_t.");

bool zcbor_new_backup(zcbor_state_t *state, size_t new_elem_count)
{
  4102d4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4102d8:	aa0003e2 	mov	x2, x0
  4102dc:	aa0103e4 	mov	x4, x1
  4102e0:	910003fd 	mov	x29, sp
  4102e4:	f9401403 	ldr	x3, [x0, #40]
	ZCBOR_CHECK_ERROR();
  4102e8:	aa0303e0 	mov	x0, x3
  4102ec:	97ffffe5 	bl	410280 <zcbor_check_error.isra.0>
  4102f0:	72001c00 	ands	w0, w0, #0xff
  4102f4:	54000100 	b.eq	410314 <zcbor_new_backup+0x40>  // b.none

	if ((state->constant_state->current_backup)
  4102f8:	a9408465 	ldp	x5, x1, [x3, #8]
  4102fc:	eb0100bf 	cmp	x5, x1
  410300:	540000e3 	b.cc	41031c <zcbor_new_backup+0x48>  // b.lo, b.ul, b.last
		>= state->constant_state->num_backups) {
		ZCBOR_ERR(ZCBOR_ERR_NO_BACKUP_MEM);
  410304:	aa0203e0 	mov	x0, x2
  410308:	52800021 	mov	w1, #0x1                   	// #1
  41030c:	97ffffe6 	bl	4102a4 <zcbor_error>
  410310:	52800000 	mov	w0, #0x0                   	// #0
		sizeof(zcbor_state_t));

	state->elem_count = new_elem_count;

	return true;
}
  410314:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410318:	d65f03c0 	ret
	state->payload_moved = false;
  41031c:	3900845f 	strb	wzr, [x2, #33]
	memcpy(&state->constant_state->backup_list[i], state,
  410320:	d2800605 	mov	x5, #0x30                  	// #48
	(state->constant_state->current_backup)++;
  410324:	f9400461 	ldr	x1, [x3, #8]
  410328:	91000421 	add	x1, x1, #0x1
  41032c:	f9000461 	str	x1, [x3, #8]
	size_t i = (state->constant_state->current_backup) - 1;
  410330:	f9401441 	ldr	x1, [x2, #40]
  return __builtin___memcpy_chk (__dest, __src, __len,
  410334:	ad400440 	ldp	q0, q1, [x2]
  410338:	f9400423 	ldr	x3, [x1, #8]
	memcpy(&state->constant_state->backup_list[i], state,
  41033c:	f9400021 	ldr	x1, [x1]
	size_t i = (state->constant_state->current_backup) - 1;
  410340:	d1000463 	sub	x3, x3, #0x1
	memcpy(&state->constant_state->backup_list[i], state,
  410344:	9b050463 	madd	x3, x3, x5, x1
  410348:	ad000460 	stp	q0, q1, [x3]
  41034c:	3dc00840 	ldr	q0, [x2, #32]
  410350:	3d800860 	str	q0, [x3, #32]
	state->elem_count = new_elem_count;
  410354:	f9000844 	str	x4, [x2, #16]
	return true;
  410358:	17ffffef 	b	410314 <zcbor_new_backup+0x40>

000000000041035c <zcbor_process_backup>:


bool zcbor_process_backup(zcbor_state_t *state, uint32_t flags,
		size_t max_elem_count)
{
  41035c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410360:	aa0003e3 	mov	x3, x0
  410364:	2a0103e5 	mov	w5, w1
  410368:	910003fd 	mov	x29, sp
  41036c:	f9401406 	ldr	x6, [x0, #40]
	const uint8_t *payload = state->payload;
	const size_t elem_count = state->elem_count;

	ZCBOR_CHECK_ERROR();
  410370:	aa0603e0 	mov	x0, x6
  410374:	97ffffc3 	bl	410280 <zcbor_check_error.isra.0>
  410378:	72001c00 	ands	w0, w0, #0xff
  41037c:	54000420 	b.eq	410400 <zcbor_process_backup+0xa4>  // b.none

	if (state->constant_state->current_backup == 0) {
  410380:	f94004c4 	ldr	x4, [x6, #8]
	const uint8_t *payload = state->payload;
  410384:	f9400067 	ldr	x7, [x3]
	const size_t elem_count = state->elem_count;
  410388:	f9400868 	ldr	x8, [x3, #16]
	if (state->constant_state->current_backup == 0) {
  41038c:	b50000c4 	cbnz	x4, 4103a4 <zcbor_process_backup+0x48>
		zcbor_print("No backups available.\r\n");
		ZCBOR_ERR(ZCBOR_ERR_NO_BACKUP_ACTIVE);
  410390:	52800041 	mov	w1, #0x2                   	// #2
	}

	if (elem_count > max_elem_count) {
		zcbor_print("elem_count: %" PRIuFAST32 " (expected max %" PRIuFAST32 ")\r\n",
			elem_count, max_elem_count);
		ZCBOR_ERR(ZCBOR_ERR_HIGH_ELEM_COUNT);
  410394:	aa0303e0 	mov	x0, x3
  410398:	97ffffc3 	bl	4102a4 <zcbor_error>
	ZCBOR_CHECK_ERROR();
  41039c:	52800000 	mov	w0, #0x0                   	// #0
  4103a0:	14000018 	b	410400 <zcbor_process_backup+0xa4>
	if (flags & ZCBOR_FLAG_RESTORE) {
  4103a4:	36000185 	tbz	w5, #0, 4103d4 <zcbor_process_backup+0x78>
			if (state->constant_state->backup_list[i].payload_moved) {
  4103a8:	f94000c1 	ldr	x1, [x6]
		size_t i = state->constant_state->current_backup - 1;
  4103ac:	d1000484 	sub	x4, x4, #0x1
			if (state->constant_state->backup_list[i].payload_moved) {
  4103b0:	d2800606 	mov	x6, #0x30                  	// #48
  4103b4:	9b060484 	madd	x4, x4, x6, x1
		if (!(flags & ZCBOR_FLAG_TRANSFER_PAYLOAD)) {
  4103b8:	37100065 	tbnz	w5, #2, 4103c4 <zcbor_process_backup+0x68>
			if (state->constant_state->backup_list[i].payload_moved) {
  4103bc:	39408481 	ldrb	w1, [x4, #33]
  4103c0:	35fffee1 	cbnz	w1, 41039c <zcbor_process_backup+0x40>
  4103c4:	ad400480 	ldp	q0, q1, [x4]
  4103c8:	ad000460 	stp	q0, q1, [x3]
  4103cc:	3dc00880 	ldr	q0, [x4, #32]
  4103d0:	3d800860 	str	q0, [x3, #32]
	if (flags & ZCBOR_FLAG_CONSUME) {
  4103d4:	360800a5 	tbz	w5, #1, 4103e8 <zcbor_process_backup+0x8c>
		state->constant_state->current_backup--;
  4103d8:	f9401464 	ldr	x4, [x3, #40]
  4103dc:	f9400481 	ldr	x1, [x4, #8]
  4103e0:	d1000421 	sub	x1, x1, #0x1
  4103e4:	f9000481 	str	x1, [x4, #8]
	if (elem_count > max_elem_count) {
  4103e8:	eb02011f 	cmp	x8, x2
  4103ec:	54000069 	b.ls	4103f8 <zcbor_process_backup+0x9c>  // b.plast
		ZCBOR_ERR(ZCBOR_ERR_HIGH_ELEM_COUNT);
  4103f0:	52800081 	mov	w1, #0x4                   	// #4
  4103f4:	17ffffe8 	b	410394 <zcbor_process_backup+0x38>
	}

	if (flags & ZCBOR_FLAG_TRANSFER_PAYLOAD) {
  4103f8:	36100045 	tbz	w5, #2, 410400 <zcbor_process_backup+0xa4>
		state->payload = payload;
  4103fc:	f9000067 	str	x7, [x3]
	}

	return true;
}
  410400:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410404:	d65f03c0 	ret

0000000000410408 <zcbor_new_state>:
}

void zcbor_new_state(zcbor_state_t *state_array, size_t n_states,
		const uint8_t *payload, size_t payload_len, size_t elem_count)
{
	state_array[0].payload = payload;
  410408:	f9000002 	str	x2, [x0]
	state_array[0].payload_end = payload + payload_len;
  41040c:	8b030042 	add	x2, x2, x3
	state_array[0].elem_count = elem_count;
  410410:	f9000804 	str	x4, [x0, #16]
	state_array[0].payload_end = payload + payload_len;
  410414:	f9000c02 	str	x2, [x0, #24]
	state_array[0].indefinite_length_array = false;
  410418:	7900401f 	strh	wzr, [x0, #32]
	state_array[0].payload_moved = false;
	state_array[0].constant_state = NULL;

	if(n_states < 2) {
  41041c:	f100043f 	cmp	x1, #0x1
  410420:	54000068 	b.hi	41042c <zcbor_new_state+0x24>  // b.pmore
	state_array[0].constant_state = NULL;
  410424:	f900141f 	str	xzr, [x0, #40]
	state_array[0].constant_state->stop_on_error = false;
#endif
	if (n_states > 2) {
		state_array[0].constant_state->backup_list = &state_array[1];
	}
}
  410428:	d65f03c0 	ret
	state_array[0].constant_state = (struct zcbor_state_constant *)&state_array[n_states - 1];
  41042c:	d2800602 	mov	x2, #0x30                  	// #48
  410430:	9b027c22 	mul	x2, x1, x2
  410434:	d100c042 	sub	x2, x2, #0x30
  410438:	8b020003 	add	x3, x0, x2
  41043c:	f9001403 	str	x3, [x0, #40]
	state_array[0].constant_state->num_backups = n_states - 2;
  410440:	d1000823 	sub	x3, x1, #0x2
	state_array[0].constant_state->backup_list = NULL;
  410444:	f822681f 	str	xzr, [x0, x2]
	state_array[0].constant_state->num_backups = n_states - 2;
  410448:	f9401402 	ldr	x2, [x0, #40]
  41044c:	f9000843 	str	x3, [x2, #16]
	state_array[0].constant_state->current_backup = 0;
  410450:	f9401402 	ldr	x2, [x0, #40]
  410454:	f900045f 	str	xzr, [x2, #8]
	state_array[0].constant_state->error = ZCBOR_SUCCESS;
  410458:	f9401402 	ldr	x2, [x0, #40]
  41045c:	b900185f 	str	wzr, [x2, #24]
	state_array[0].constant_state->stop_on_error = false;
  410460:	f9401402 	ldr	x2, [x0, #40]
  410464:	3900705f 	strb	wzr, [x2, #28]
	if (n_states > 2) {
  410468:	f100083f 	cmp	x1, #0x2
  41046c:	54fffde0 	b.eq	410428 <zcbor_new_state+0x20>  // b.none
		state_array[0].constant_state->backup_list = &state_array[1];
  410470:	f9401401 	ldr	x1, [x0, #40]
  410474:	9100c000 	add	x0, x0, #0x30
  410478:	f9000020 	str	x0, [x1]
  41047c:	17ffffeb 	b	410428 <zcbor_new_state+0x20>

0000000000410480 <zcbor_update_state>:

void zcbor_update_state(zcbor_state_t *state,
		const uint8_t *payload, size_t payload_len)
{
	state->payload = payload;
  410480:	f9000001 	str	x1, [x0]
	state->payload_end = payload + payload_len;
  410484:	8b020021 	add	x1, x1, x2
	if (state->constant_state) {
  410488:	f9401402 	ldr	x2, [x0, #40]
	state->payload_end = payload + payload_len;
  41048c:	f9000c01 	str	x1, [x0, #24]
	if (state->constant_state) {
  410490:	b5000202 	cbnz	x2, 4104d0 <zcbor_update_state+0x50>

	update_backups(state, state->payload_end);
}
  410494:	d65f03c0 	ret
			state->constant_state->backup_list[i].payload_end = new_payload_end;
  410498:	f9400063 	ldr	x3, [x3]
  41049c:	9ba57c44 	umull	x4, w2, w5
		for (unsigned int i = 0; i < state->constant_state->current_backup; i++) {
  4104a0:	11000442 	add	w2, w2, #0x1
			state->constant_state->backup_list[i].payload_end = new_payload_end;
  4104a4:	8b040063 	add	x3, x3, x4
  4104a8:	f9000c61 	str	x1, [x3, #24]
			state->constant_state->backup_list[i].payload_moved = true;
  4104ac:	f9401403 	ldr	x3, [x0, #40]
  4104b0:	f9400063 	ldr	x3, [x3]
  4104b4:	8b040063 	add	x3, x3, x4
  4104b8:	39008466 	strb	w6, [x3, #33]
		for (unsigned int i = 0; i < state->constant_state->current_backup; i++) {
  4104bc:	f9401403 	ldr	x3, [x0, #40]
  4104c0:	f9400464 	ldr	x4, [x3, #8]
  4104c4:	eb22409f 	cmp	x4, w2, uxtw
  4104c8:	54fffe88 	b.hi	410498 <zcbor_update_state+0x18>  // b.pmore
  4104cc:	17fffff2 	b	410494 <zcbor_update_state+0x14>
  4104d0:	52800002 	mov	w2, #0x0                   	// #0
			state->constant_state->backup_list[i].payload_end = new_payload_end;
  4104d4:	52800605 	mov	w5, #0x30                  	// #48
			state->constant_state->backup_list[i].payload_moved = true;
  4104d8:	52800026 	mov	w6, #0x1                   	// #1
  4104dc:	17fffff8 	b	4104bc <zcbor_update_state+0x3c>

00000000004104e0 <zcbor_check_error.isra.0>:
	return !(cs && cs->stop_on_error && cs->error);
  4104e0:	b40000e0 	cbz	x0, 4104fc <zcbor_check_error.isra.0+0x1c>
  4104e4:	39407001 	ldrb	w1, [x0, #28]
  4104e8:	340000a1 	cbz	w1, 4104fc <zcbor_check_error.isra.0+0x1c>
  4104ec:	b9401800 	ldr	w0, [x0, #24]
  4104f0:	7100001f 	cmp	w0, #0x0
  4104f4:	1a9f17e0 	cset	w0, eq  // eq = none
}
  4104f8:	d65f03c0 	ret
	return !(cs && cs->stop_on_error && cs->error);
  4104fc:	52800020 	mov	w0, #0x1                   	// #1
  410500:	17fffffe 	b	4104f8 <zcbor_check_error.isra.0+0x18>

0000000000410504 <zcbor_error>:
{
  410504:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410508:	2a0103e3 	mov	w3, w1
  41050c:	910003fd 	mov	x29, sp
  410510:	f9401402 	ldr	x2, [x0, #40]
	if (zcbor_check_error(state))
  410514:	aa0203e0 	mov	x0, x2
  410518:	97fffff2 	bl	4104e0 <zcbor_check_error.isra.0>
  41051c:	72001c1f 	tst	w0, #0xff
  410520:	54000060 	b.eq	41052c <zcbor_error+0x28>  // b.none
		if (state->constant_state) {
  410524:	b4000042 	cbz	x2, 41052c <zcbor_error+0x28>
			state->constant_state->error = err;
  410528:	b9001843 	str	w3, [x2, #24]
}
  41052c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410530:	d65f03c0 	ret

0000000000410534 <initial_checks>:
	} \
} while(0)


static bool initial_checks(zcbor_state_t *state)
{
  410534:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410538:	aa0003e2 	mov	x2, x0
  41053c:	910003fd 	mov	x29, sp
	ZCBOR_CHECK_ERROR();
  410540:	f9401400 	ldr	x0, [x0, #40]
  410544:	97ffffe7 	bl	4104e0 <zcbor_check_error.isra.0>
  410548:	72001c00 	ands	w0, w0, #0xff
  41054c:	54000120 	b.eq	410570 <initial_checks+0x3c>  // b.none
	ZCBOR_CHECK_PAYLOAD();
  410550:	f9400043 	ldr	x3, [x2]
  410554:	f9400c41 	ldr	x1, [x2, #24]
  410558:	eb01007f 	cmp	x3, x1
  41055c:	540000a3 	b.cc	410570 <initial_checks+0x3c>  // b.lo, b.ul, b.last
  410560:	aa0203e0 	mov	x0, x2
  410564:	52800101 	mov	w1, #0x8                   	// #8
  410568:	97ffffe7 	bl	410504 <zcbor_error>
  41056c:	52800000 	mov	w0, #0x0                   	// #0
	return true;
}
  410570:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410574:	d65f03c0 	ret

0000000000410578 <type_check>:


static bool type_check(zcbor_state_t *state, zcbor_major_type_t exp_major_type)
{
  410578:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  41057c:	aa0003e4 	mov	x4, x0
  410580:	2a0103e5 	mov	w5, w1
  410584:	910003fd 	mov	x29, sp
	if (!initial_checks(state)) {
  410588:	97ffffeb 	bl	410534 <initial_checks>
  41058c:	72001c00 	ands	w0, w0, #0xff
  410590:	54000120 	b.eq	4105b4 <type_check+0x3c>  // b.none
		ZCBOR_FAIL();
	}
	zcbor_major_type_t major_type = MAJOR_TYPE(*state->payload);
  410594:	f9400081 	ldr	x1, [x4]
  410598:	39400021 	ldrb	w1, [x1]

	if (major_type != exp_major_type) {
  41059c:	6b4114bf 	cmp	w5, w1, lsr #5
  4105a0:	540000a0 	b.eq	4105b4 <type_check+0x3c>  // b.none
		ZCBOR_ERR(ZCBOR_ERR_WRONG_TYPE);
  4105a4:	aa0403e0 	mov	x0, x4
  4105a8:	52800141 	mov	w1, #0xa                   	// #10
  4105ac:	97ffffd6 	bl	410504 <zcbor_error>
  4105b0:	52800000 	mov	w0, #0x0                   	// #0
	}
	return true;
}
  4105b4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4105b8:	d65f03c0 	ret

00000000004105bc <err_restore>:
	} \
} while(0)

static void err_restore(zcbor_state_t *state, int err)
{
	state->payload = state->payload_bak;
  4105bc:	f9400403 	ldr	x3, [x0, #8]
  4105c0:	f9000003 	str	x3, [x0]
	state->elem_count++;
  4105c4:	f9400803 	ldr	x3, [x0, #16]
  4105c8:	91000463 	add	x3, x3, #0x1
  4105cc:	f9000803 	str	x3, [x0, #16]
	zcbor_error(state, err);
  4105d0:	17ffffcd 	b	410504 <zcbor_error>

00000000004105d4 <value_extract>:
 *          CBOR values are always big-endian, so this function converts from
 *          big to little-endian if necessary (@ref CONFIG_BIG_ENDIAN).
 */
static bool value_extract(zcbor_state_t *state,
		void *const result, size_t result_len)
{
  4105d4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4105d8:	910003fd 	mov	x29, sp
  4105dc:	a90153f3 	stp	x19, x20, [sp, #16]
  4105e0:	aa0003f3 	mov	x19, x0
  4105e4:	a9025bf5 	stp	x21, x22, [sp, #32]
  4105e8:	f9001bf7 	str	x23, [sp, #48]
	zcbor_trace();
	zcbor_assert_state(result_len != 0, "0-length result not supported.\r\n");
  4105ec:	b5000162 	cbnz	x2, 410618 <value_extract+0x44>
  4105f0:	528001c1 	mov	w1, #0xe                   	// #14
	} else {
		size_t len = additional_len(additional);

		FAIL_AND_DECR_IF(len > result_len, ZCBOR_ERR_INT_SIZE);
		FAIL_AND_DECR_IF(len == 0, ZCBOR_ERR_ADDITIONAL_INVAL); // additional_len() did not recognize the additional value.
		FAIL_AND_DECR_IF((state->payload + len) > state->payload_end,
  4105f4:	52800014 	mov	w20, #0x0                   	// #0
  4105f8:	aa1303e0 	mov	x0, x19
  4105fc:	97ffffc2 	bl	410504 <zcbor_error>
		(state->payload) += len;
	}

	(state->elem_count)--;
	return true;
}
  410600:	2a1403e0 	mov	w0, w20
  410604:	a94153f3 	ldp	x19, x20, [sp, #16]
  410608:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41060c:	f9401bf7 	ldr	x23, [sp, #48]
  410610:	a8c47bfd 	ldp	x29, x30, [sp], #64
  410614:	d65f03c0 	ret
  410618:	aa0103f6 	mov	x22, x1
	zcbor_assert_state(result != NULL, NULL);
  41061c:	b4fffea1 	cbz	x1, 4105f0 <value_extract+0x1c>
  410620:	aa0203f7 	mov	x23, x2
	INITIAL_CHECKS();
  410624:	97ffffc4 	bl	410534 <initial_checks>
  410628:	72001c14 	ands	w20, w0, #0xff
  41062c:	54fffea0 	b.eq	410600 <value_extract+0x2c>  // b.none
	ZCBOR_ERR_IF((state->elem_count == 0), ZCBOR_ERR_LOW_ELEM_COUNT);
  410630:	f9400a60 	ldr	x0, [x19, #16]
  410634:	b5000060 	cbnz	x0, 410640 <value_extract+0x6c>
  410638:	52800061 	mov	w1, #0x3                   	// #3
  41063c:	17ffffee 	b	4105f4 <value_extract+0x20>
	uint8_t additional = ADDITIONAL(*state->payload);
  410640:	f9400260 	ldr	x0, [x19]
  return __builtin___memset_chk (__dest, __ch, __len,
  410644:	aa1703e2 	mov	x2, x23
  410648:	52800001 	mov	w1, #0x0                   	// #0
  41064c:	39400015 	ldrb	w21, [x0]
	state->payload_bak = state->payload;
  410650:	f9000660 	str	x0, [x19, #8]
	(state->payload)++;
  410654:	91000400 	add	x0, x0, #0x1
  410658:	f9000260 	str	x0, [x19]
	uint8_t additional = ADDITIONAL(*state->payload);
  41065c:	120012b5 	and	w21, w21, #0x1f
  410660:	aa1603e0 	mov	x0, x22
  410664:	97ffc38b 	bl	401490 <memset@plt>
	if (additional <= ZCBOR_VALUE_IN_HEADER) {
  410668:	71005ebf 	cmp	w21, #0x17
  41066c:	540000c8 	b.hi	410684 <value_extract+0xb0>  // b.pmore
		u8_result[0] = additional;
  410670:	390002d5 	strb	w21, [x22]
	(state->elem_count)--;
  410674:	f9400a60 	ldr	x0, [x19, #16]
  410678:	d1000400 	sub	x0, x0, #0x1
  41067c:	f9000a60 	str	x0, [x19, #16]
	return true;
  410680:	17ffffe0 	b	410600 <value_extract+0x2c>
	if (ZCBOR_VALUE_IS_1_BYTE <= additional && additional <= ZCBOR_VALUE_IS_8_BYTES) {
  410684:	510062b5 	sub	w21, w21, #0x18
  410688:	12001ea0 	and	w0, w21, #0xff
		FAIL_AND_DECR_IF(len > result_len, ZCBOR_ERR_INT_SIZE);
  41068c:	f9400263 	ldr	x3, [x19]
	if (ZCBOR_VALUE_IS_1_BYTE <= additional && additional <= ZCBOR_VALUE_IS_8_BYTES) {
  410690:	71000c1f 	cmp	w0, #0x3
  410694:	54000128 	b.hi	4106b8 <value_extract+0xe4>  // b.pmore
		return 1U << (additional - ZCBOR_VALUE_IS_1_BYTE);
  410698:	52800024 	mov	w4, #0x1                   	// #1
  41069c:	1ad52084 	lsl	w4, w4, w21
		FAIL_AND_DECR_IF(len > result_len, ZCBOR_ERR_INT_SIZE);
  4106a0:	eb0402ff 	cmp	x23, x4
  4106a4:	54000122 	b.cs	4106c8 <value_extract+0xf4>  // b.hs, b.nlast
  4106a8:	d1000463 	sub	x3, x3, #0x1
  4106ac:	528000a1 	mov	w1, #0x5                   	// #5
  4106b0:	f9000263 	str	x3, [x19]
  4106b4:	17ffffd0 	b	4105f4 <value_extract+0x20>
		FAIL_AND_DECR_IF(len == 0, ZCBOR_ERR_ADDITIONAL_INVAL); // additional_len() did not recognize the additional value.
  4106b8:	d1000463 	sub	x3, x3, #0x1
  4106bc:	528000e1 	mov	w1, #0x7                   	// #7
  4106c0:	f9000263 	str	x3, [x19]
  4106c4:	17ffffcc 	b	4105f4 <value_extract+0x20>
		FAIL_AND_DECR_IF((state->payload + len) > state->payload_end,
  4106c8:	f9400e61 	ldr	x1, [x19, #24]
  4106cc:	8b040060 	add	x0, x3, x4
  4106d0:	eb00003f 	cmp	x1, x0
  4106d4:	540000a2 	b.cs	4106e8 <value_extract+0x114>  // b.hs, b.nlast
  4106d8:	d1000463 	sub	x3, x3, #0x1
  4106dc:	52800101 	mov	w1, #0x8                   	// #8
  4106e0:	f9000263 	str	x3, [x19]
  4106e4:	17ffffc4 	b	4105f4 <value_extract+0x20>
			u8_result[i] = (state->payload)[len - i - 1];
  4106e8:	d1000483 	sub	x3, x4, #0x1
		for (size_t i = 0; i < len; i++) {
  4106ec:	d2800000 	mov	x0, #0x0                   	// #0
			u8_result[i] = (state->payload)[len - i - 1];
  4106f0:	f9400262 	ldr	x2, [x19]
  4106f4:	cb000061 	sub	x1, x3, x0
  4106f8:	38616841 	ldrb	w1, [x2, x1]
  4106fc:	38206ac1 	strb	w1, [x22, x0]
		for (size_t i = 0; i < len; i++) {
  410700:	91000400 	add	x0, x0, #0x1
  410704:	eb04001f 	cmp	x0, x4
  410708:	54ffff43 	b.cc	4106f0 <value_extract+0x11c>  // b.lo, b.ul, b.last
		(state->payload) += len;
  41070c:	f9400260 	ldr	x0, [x19]
  410710:	8b040000 	add	x0, x0, x4
  410714:	f9000260 	str	x0, [x19]
  410718:	17ffffd7 	b	410674 <value_extract+0xa0>

000000000041071c <str_start_decode>:
#endif


static bool str_start_decode(zcbor_state_t *state,
		struct zcbor_string *result, zcbor_major_type_t exp_major_type)
{
  41071c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410720:	910003fd 	mov	x29, sp
  410724:	a90153f3 	stp	x19, x20, [sp, #16]
  410728:	aa0103f3 	mov	x19, x1
  41072c:	aa0003f4 	mov	x20, x0
  410730:	2a0203e1 	mov	w1, w2
	INITIAL_CHECKS_WITH_TYPE(exp_major_type);
  410734:	97ffff91 	bl	410578 <type_check>
  410738:	72001c1f 	tst	w0, #0xff
  41073c:	540000a1 	b.ne	410750 <str_start_decode+0x34>  // b.any
  410740:	52800000 	mov	w0, #0x0                   	// #0
		ZCBOR_FAIL();
	}

	result->value = state->payload;
	return true;
}
  410744:	a94153f3 	ldp	x19, x20, [sp, #16]
  410748:	a8c27bfd 	ldp	x29, x30, [sp], #32
  41074c:	d65f03c0 	ret
	if (!value_extract(state, &result->len, sizeof(result->len))) {
  410750:	d2800102 	mov	x2, #0x8                   	// #8
  410754:	aa1403e0 	mov	x0, x20
  410758:	8b020261 	add	x1, x19, x2
  41075c:	97ffff9e 	bl	4105d4 <value_extract>
  410760:	72001c00 	ands	w0, w0, #0xff
  410764:	54fffee0 	b.eq	410740 <str_start_decode+0x24>  // b.none
	result->value = state->payload;
  410768:	f9400281 	ldr	x1, [x20]
  41076c:	f9000261 	str	x1, [x19]
	return true;
  410770:	17fffff5 	b	410744 <str_start_decode+0x28>

0000000000410774 <str_start_decode_with_overflow_check>:

static bool str_start_decode_with_overflow_check(zcbor_state_t *state,
		struct zcbor_string *result, zcbor_major_type_t exp_major_type)
{
  410774:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  410778:	910003fd 	mov	x29, sp
  41077c:	a90153f3 	stp	x19, x20, [sp, #16]
  410780:	aa0003f3 	mov	x19, x0
  410784:	aa0103f4 	mov	x20, x1
	bool res = str_start_decode(state, result, exp_major_type);
  410788:	97ffffe5 	bl	41071c <str_start_decode>

	if (!res) {
  41078c:	72001c00 	ands	w0, w0, #0xff
  410790:	54000160 	b.eq	4107bc <str_start_decode_with_overflow_check+0x48>  // b.none
		ZCBOR_FAIL();
	}

	/* Casting to size_t is safe since str_start_decode() checks that
	 * payload_end is bigger that payload. */
	if (result->len > (size_t)(state->payload_end - state->payload)) {
  410794:	f9400261 	ldr	x1, [x19]
  410798:	f9400e62 	ldr	x2, [x19, #24]
  41079c:	cb010042 	sub	x2, x2, x1
  4107a0:	f9400681 	ldr	x1, [x20, #8]
  4107a4:	eb02003f 	cmp	x1, x2
  4107a8:	540000a9 	b.ls	4107bc <str_start_decode_with_overflow_check+0x48>  // b.plast
		zcbor_print("error: 0x%zu > 0x%zu\r\n",
			result->len,
			(state->payload_end - state->payload));
		ERR_RESTORE(ZCBOR_ERR_NO_PAYLOAD);
  4107ac:	aa1303e0 	mov	x0, x19
  4107b0:	52800101 	mov	w1, #0x8                   	// #8
  4107b4:	97ffff82 	bl	4105bc <err_restore>
  4107b8:	52800000 	mov	w0, #0x0                   	// #0
	}

	return true;
}
  4107bc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4107c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4107c4:	d65f03c0 	ret

00000000004107c8 <str_decode>:
}


static bool str_decode(zcbor_state_t *state, struct zcbor_string *result,
		zcbor_major_type_t exp_major_type)
{
  4107c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4107cc:	910003fd 	mov	x29, sp
  4107d0:	a90153f3 	stp	x19, x20, [sp, #16]
  4107d4:	aa0003f3 	mov	x19, x0
  4107d8:	aa0103f4 	mov	x20, x1
	if (!str_start_decode_with_overflow_check(state, result, exp_major_type)) {
  4107dc:	97ffffe6 	bl	410774 <str_start_decode_with_overflow_check>
  4107e0:	72001c1f 	tst	w0, #0xff
  4107e4:	540000a0 	b.eq	4107f8 <str_decode+0x30>  // b.none
		ZCBOR_FAIL();
	}

	state->payload += result->len;
  4107e8:	f9400262 	ldr	x2, [x19]
  4107ec:	f9400681 	ldr	x1, [x20, #8]
  4107f0:	8b010041 	add	x1, x2, x1
  4107f4:	f9000261 	str	x1, [x19]
	return true;
}
  4107f8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4107fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410800:	d65f03c0 	ret

0000000000410804 <array_end_expect>:
	return ret;
}


static bool array_end_expect(zcbor_state_t *state)
{
  410804:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410808:	aa0003e4 	mov	x4, x0
  41080c:	910003fd 	mov	x29, sp
	INITIAL_CHECKS();
  410810:	97ffff49 	bl	410534 <initial_checks>
  410814:	72001c00 	ands	w0, w0, #0xff
  410818:	54000120 	b.eq	41083c <array_end_expect+0x38>  // b.none
	ZCBOR_ERR_IF(*state->payload != 0xFF, ZCBOR_ERR_WRONG_TYPE);
  41081c:	f9400081 	ldr	x1, [x4]
  410820:	39400022 	ldrb	w2, [x1]
  410824:	7103fc5f 	cmp	w2, #0xff
  410828:	540000e0 	b.eq	410844 <array_end_expect+0x40>  // b.none
  41082c:	aa0403e0 	mov	x0, x4
  410830:	52800141 	mov	w1, #0xa                   	// #10
  410834:	97ffff34 	bl	410504 <zcbor_error>
  410838:	52800000 	mov	w0, #0x0                   	// #0

	state->payload++;
	return true;
}
  41083c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410840:	d65f03c0 	ret
	state->payload++;
  410844:	91000421 	add	x1, x1, #0x1
  410848:	f9000081 	str	x1, [x4]
	return true;
  41084c:	17fffffc 	b	41083c <array_end_expect+0x38>

0000000000410850 <list_map_end_decode>:

static bool list_map_end_decode(zcbor_state_t *state)
{
	size_t max_elem_count = 0;

	if (state->indefinite_length_array) {
  410850:	39408001 	ldrb	w1, [x0, #32]
{
  410854:	aa0003e5 	mov	x5, x0
	if (state->indefinite_length_array) {
  410858:	34000181 	cbz	w1, 410888 <list_map_end_decode+0x38>
{
  41085c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410860:	910003fd 	mov	x29, sp
		if (!array_end_expect(state)) {
  410864:	97ffffe8 	bl	410804 <array_end_expect>
  410868:	72001c1f 	tst	w0, #0xff
  41086c:	54000140 	b.eq	410894 <list_map_end_decode+0x44>  // b.none
			ZCBOR_FAIL();
		}
		max_elem_count = ZCBOR_MAX_ELEM_COUNT;
		state->indefinite_length_array = false;
  410870:	390080bf 	strb	wzr, [x5, #32]
		max_elem_count = ZCBOR_MAX_ELEM_COUNT;
  410874:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
	}
	if (!zcbor_process_backup(state,
  410878:	528000e1 	mov	w1, #0x7                   	// #7
  41087c:	aa0503e0 	mov	x0, x5
			max_elem_count)) {
		ZCBOR_FAIL();
	}

	return true;
}
  410880:	a8c17bfd 	ldp	x29, x30, [sp], #16
	if (!zcbor_process_backup(state,
  410884:	17fffeb6 	b	41035c <zcbor_process_backup>
	size_t max_elem_count = 0;
  410888:	d2800002 	mov	x2, #0x0                   	// #0
	if (!zcbor_process_backup(state,
  41088c:	528000e1 	mov	w1, #0x7                   	// #7
  410890:	17fffffd 	b	410884 <list_map_end_decode+0x34>
}
  410894:	52800000 	mov	w0, #0x0                   	// #0
  410898:	a8c17bfd 	ldp	x29, x30, [sp], #16
  41089c:	d65f03c0 	ret

00000000004108a0 <float_check>:
	return zcbor_simple_expect(state, (uint8_t)(!!result) + ZCBOR_BOOL_TO_SIMPLE);
}


static bool float_check(zcbor_state_t *state, uint8_t additional_val)
{
  4108a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4108a4:	aa0003e6 	mov	x6, x0
  4108a8:	12001c27 	and	w7, w1, #0xff
  4108ac:	910003fd 	mov	x29, sp
	INITIAL_CHECKS_WITH_TYPE(ZCBOR_MAJOR_TYPE_SIMPLE);
  4108b0:	528000e1 	mov	w1, #0x7                   	// #7
  4108b4:	97ffff31 	bl	410578 <type_check>
  4108b8:	72001c00 	ands	w0, w0, #0xff
  4108bc:	54000140 	b.eq	4108e4 <float_check+0x44>  // b.none
	ZCBOR_ERR_IF(ADDITIONAL(*state->payload) != additional_val, ZCBOR_ERR_FLOAT_SIZE);
  4108c0:	f94000c1 	ldr	x1, [x6]
  4108c4:	39400021 	ldrb	w1, [x1]
  4108c8:	12001021 	and	w1, w1, #0x1f
  4108cc:	6b0100ff 	cmp	w7, w1
  4108d0:	540000a0 	b.eq	4108e4 <float_check+0x44>  // b.none
  4108d4:	aa0603e0 	mov	x0, x6
  4108d8:	528000c1 	mov	w1, #0x6                   	// #6
  4108dc:	97ffff0a 	bl	410504 <zcbor_error>
  4108e0:	52800000 	mov	w0, #0x0                   	// #0
	return true;
}
  4108e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4108e8:	d65f03c0 	ret

00000000004108ec <list_map_start_decode>:
{
  4108ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4108f0:	b0000102 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  4108f4:	910003fd 	mov	x29, sp
  4108f8:	f9475c42 	ldr	x2, [x2, #3768]
  4108fc:	a90153f3 	stp	x19, x20, [sp, #16]
  410900:	aa0003f3 	mov	x19, x0
  410904:	f9400043 	ldr	x3, [x2]
  410908:	f90017e3 	str	x3, [sp, #40]
  41090c:	d2800003 	mov	x3, #0x0                   	// #0
	INITIAL_CHECKS_WITH_TYPE(exp_major_type);
  410910:	97ffff1a 	bl	410578 <type_check>
  410914:	72001c14 	ands	w20, w0, #0xff
  410918:	540001e0 	b.eq	410954 <list_map_start_decode+0x68>  // b.none
	if (ADDITIONAL(*state->payload) == ZCBOR_VALUE_IS_INDEFINITE_LENGTH) {
  41091c:	f9400261 	ldr	x1, [x19]
  410920:	39400020 	ldrb	w0, [x1]
  410924:	12001000 	and	w0, w0, #0x1f
  410928:	71007c1f 	cmp	w0, #0x1f
  41092c:	54000421 	b.ne	4109b0 <list_map_start_decode+0xc4>  // b.any
		new_elem_count = ZCBOR_LARGE_ELEM_COUNT;
  410930:	92800200 	mov	x0, #0xffffffffffffffef    	// #-17
  410934:	f90013e0 	str	x0, [sp, #32]
		ZCBOR_ERR_IF(state->elem_count == 0, ZCBOR_ERR_LOW_ELEM_COUNT);
  410938:	f9400a60 	ldr	x0, [x19, #16]
  41093c:	b50001c0 	cbnz	x0, 410974 <list_map_start_decode+0x88>
  410940:	aa1303e0 	mov	x0, x19
  410944:	52800061 	mov	w1, #0x3                   	// #3
  410948:	97fffeef 	bl	410504 <zcbor_error>
  41094c:	52800000 	mov	w0, #0x0                   	// #0
  410950:	2a0003f4 	mov	w20, w0
}
  410954:	b0000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  410958:	f9475c00 	ldr	x0, [x0, #3768]
  41095c:	f94017e2 	ldr	x2, [sp, #40]
  410960:	f9400001 	ldr	x1, [x0]
  410964:	eb010042 	subs	x2, x2, x1
  410968:	d2800001 	mov	x1, #0x0                   	// #0
  41096c:	54000360 	b.eq	4109d8 <list_map_start_decode+0xec>  // b.none
  410970:	97ffc2ec 	bl	401520 <__stack_chk_fail@plt>
		state->payload++;
  410974:	91000421 	add	x1, x1, #0x1
		state->elem_count--;
  410978:	d1000400 	sub	x0, x0, #0x1
		state->payload++;
  41097c:	f9000261 	str	x1, [x19]
		state->elem_count--;
  410980:	f9000a60 	str	x0, [x19, #16]
	if (!zcbor_new_backup(state, new_elem_count)) {
  410984:	f94013e1 	ldr	x1, [sp, #32]
  410988:	aa1303e0 	mov	x0, x19
  41098c:	97fffe52 	bl	4102d4 <zcbor_new_backup>
  410990:	72001c00 	ands	w0, w0, #0xff
  410994:	540001e1 	b.ne	4109d0 <list_map_start_decode+0xe4>  // b.any
		FAIL_RESTORE();
  410998:	f9400661 	ldr	x1, [x19, #8]
  41099c:	f9000261 	str	x1, [x19]
  4109a0:	f9400a61 	ldr	x1, [x19, #16]
  4109a4:	91000421 	add	x1, x1, #0x1
  4109a8:	f9000a61 	str	x1, [x19, #16]
  4109ac:	17ffffe9 	b	410950 <list_map_start_decode+0x64>
		if (!value_extract(state, &new_elem_count, sizeof(new_elem_count))) {
  4109b0:	910083e1 	add	x1, sp, #0x20
  4109b4:	aa1303e0 	mov	x0, x19
  4109b8:	d2800102 	mov	x2, #0x8                   	// #8
  4109bc:	97ffff06 	bl	4105d4 <value_extract>
  4109c0:	72001c00 	ands	w0, w0, #0xff
  4109c4:	54fffc60 	b.eq	410950 <list_map_start_decode+0x64>  // b.none
	bool indefinite_length_array = false;
  4109c8:	52800014 	mov	w20, #0x0                   	// #0
  4109cc:	17ffffee 	b	410984 <list_map_start_decode+0x98>
	state->indefinite_length_array = indefinite_length_array;
  4109d0:	39008274 	strb	w20, [x19, #32]
	return true;
  4109d4:	17ffffdf 	b	410950 <list_map_start_decode+0x64>
}
  4109d8:	2a1403e0 	mov	w0, w20
  4109dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4109e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4109e4:	d65f03c0 	ret

00000000004109e8 <zcbor_int_decode>:
{
  4109e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4109ec:	910003fd 	mov	x29, sp
  4109f0:	a90153f3 	stp	x19, x20, [sp, #16]
  4109f4:	aa0003f4 	mov	x20, x0
  4109f8:	aa0103f3 	mov	x19, x1
  4109fc:	a9025bf5 	stp	x21, x22, [sp, #32]
  410a00:	aa0203f5 	mov	x21, x2
	INITIAL_CHECKS();
  410a04:	97fffecc 	bl	410534 <initial_checks>
  410a08:	72001c1f 	tst	w0, #0xff
  410a0c:	540000c1 	b.ne	410a24 <zcbor_int_decode+0x3c>  // b.any
		ERR_RESTORE(ZCBOR_ERR_INT_SIZE);
  410a10:	52800000 	mov	w0, #0x0                   	// #0
}
  410a14:	a94153f3 	ldp	x19, x20, [sp, #16]
  410a18:	a9425bf5 	ldp	x21, x22, [sp, #32]
  410a1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410a20:	d65f03c0 	ret
	zcbor_major_type_t major_type = MAJOR_TYPE(*state->payload);
  410a24:	f9400280 	ldr	x0, [x20]
  410a28:	39400000 	ldrb	w0, [x0]
  410a2c:	53057c16 	lsr	w22, w0, #5
	if (major_type != ZCBOR_MAJOR_TYPE_PINT
  410a30:	7100fc1f 	cmp	w0, #0x3f
  410a34:	540000a9 	b.ls	410a48 <zcbor_int_decode+0x60>  // b.plast
		ZCBOR_ERR(ZCBOR_ERR_WRONG_TYPE);
  410a38:	aa1403e0 	mov	x0, x20
  410a3c:	52800141 	mov	w1, #0xa                   	// #10
  410a40:	97fffeb1 	bl	410504 <zcbor_error>
  410a44:	17fffff3 	b	410a10 <zcbor_int_decode+0x28>
	if (!value_extract(state, result_int, int_size)) {
  410a48:	aa1503e2 	mov	x2, x21
  410a4c:	aa1303e1 	mov	x1, x19
  410a50:	aa1403e0 	mov	x0, x20
  410a54:	97fffee0 	bl	4105d4 <value_extract>
  410a58:	72001c00 	ands	w0, w0, #0xff
  410a5c:	54fffda0 	b.eq	410a10 <zcbor_int_decode+0x28>  // b.none
	if (result_int8[int_size - 1] < 0) {
  410a60:	8b150261 	add	x1, x19, x21
  410a64:	38dff021 	ldursb	w1, [x1, #-1]
  410a68:	36f800a1 	tbz	w1, #31, 410a7c <zcbor_int_decode+0x94>
		ERR_RESTORE(ZCBOR_ERR_INT_SIZE);
  410a6c:	aa1403e0 	mov	x0, x20
  410a70:	528000a1 	mov	w1, #0x5                   	// #5
  410a74:	97fffed2 	bl	4105bc <err_restore>
  410a78:	17ffffe6 	b	410a10 <zcbor_int_decode+0x28>
	if (major_type == ZCBOR_MAJOR_TYPE_NINT) {
  410a7c:	710006df 	cmp	w22, #0x1
  410a80:	54fffca1 	b.ne	410a14 <zcbor_int_decode+0x2c>  // b.any
		for (unsigned int i = 0; i < int_size; i++) {
  410a84:	52800001 	mov	w1, #0x0                   	// #0
  410a88:	14000005 	b	410a9c <zcbor_int_decode+0xb4>
			result_uint8[i] = (uint8_t)~result_uint8[i];
  410a8c:	38636a62 	ldrb	w2, [x19, x3]
		for (unsigned int i = 0; i < int_size; i++) {
  410a90:	11000421 	add	w1, w1, #0x1
			result_uint8[i] = (uint8_t)~result_uint8[i];
  410a94:	2a2203e2 	mvn	w2, w2
  410a98:	38236a62 	strb	w2, [x19, x3]
		for (unsigned int i = 0; i < int_size; i++) {
  410a9c:	2a0103e3 	mov	w3, w1
  410aa0:	eb2142bf 	cmp	x21, w1, uxtw
  410aa4:	54ffff48 	b.hi	410a8c <zcbor_int_decode+0xa4>  // b.pmore
  410aa8:	17ffffdb 	b	410a14 <zcbor_int_decode+0x2c>

0000000000410aac <zcbor_int32_decode>:
	return zcbor_int_decode(state, result, sizeof(*result));
  410aac:	d2800082 	mov	x2, #0x4                   	// #4
  410ab0:	17ffffce 	b	4109e8 <zcbor_int_decode>

0000000000410ab4 <zcbor_uint_decode>:
{
  410ab4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410ab8:	aa0103e7 	mov	x7, x1
  410abc:	aa0003e6 	mov	x6, x0
  410ac0:	910003fd 	mov	x29, sp
  410ac4:	aa0203e8 	mov	x8, x2
	INITIAL_CHECKS_WITH_TYPE(ZCBOR_MAJOR_TYPE_PINT);
  410ac8:	52800001 	mov	w1, #0x0                   	// #0
  410acc:	97fffeab 	bl	410578 <type_check>
  410ad0:	72001c1f 	tst	w0, #0xff
  410ad4:	540000c0 	b.eq	410aec <zcbor_uint_decode+0x38>  // b.none
}
  410ad8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	if (!value_extract(state, result_uint, uint_size)) {
  410adc:	aa0803e2 	mov	x2, x8
  410ae0:	aa0703e1 	mov	x1, x7
  410ae4:	aa0603e0 	mov	x0, x6
  410ae8:	17fffebb 	b	4105d4 <value_extract>
}
  410aec:	52800000 	mov	w0, #0x0                   	// #0
  410af0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410af4:	d65f03c0 	ret

0000000000410af8 <zcbor_uint32_decode>:
	return zcbor_uint_decode(state, result, sizeof(*result));
  410af8:	d2800082 	mov	x2, #0x4                   	// #4
  410afc:	17ffffee 	b	410ab4 <zcbor_uint_decode>

0000000000410b00 <zcbor_tstr_decode>:
	return str_decode(state, result, ZCBOR_MAJOR_TYPE_TSTR);
  410b00:	52800062 	mov	w2, #0x3                   	// #3
  410b04:	17ffff31 	b	4107c8 <str_decode>

0000000000410b08 <zcbor_list_start_decode>:
	return list_map_start_decode(state, ZCBOR_MAJOR_TYPE_LIST);
  410b08:	52800081 	mov	w1, #0x4                   	// #4
  410b0c:	17ffff78 	b	4108ec <list_map_start_decode>

0000000000410b10 <zcbor_map_start_decode>:
{
  410b10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	bool ret = list_map_start_decode(state, ZCBOR_MAJOR_TYPE_MAP);
  410b14:	528000a1 	mov	w1, #0x5                   	// #5
{
  410b18:	910003fd 	mov	x29, sp
  410b1c:	f9000bf3 	str	x19, [sp, #16]
  410b20:	aa0003f3 	mov	x19, x0
	bool ret = list_map_start_decode(state, ZCBOR_MAJOR_TYPE_MAP);
  410b24:	97ffff72 	bl	4108ec <list_map_start_decode>
	if (ret && !state->indefinite_length_array) {
  410b28:	72001c00 	ands	w0, w0, #0xff
  410b2c:	54000240 	b.eq	410b74 <zcbor_map_start_decode+0x64>  // b.none
  410b30:	39408264 	ldrb	w4, [x19, #32]
  410b34:	35000104 	cbnz	w4, 410b54 <zcbor_map_start_decode+0x44>
		if (state->elem_count >= (ZCBOR_MAX_ELEM_COUNT / 2)) {
  410b38:	f9400a61 	ldr	x1, [x19, #16]
  410b3c:	b27ff7e2 	mov	x2, #0x7ffffffffffffffe    	// #9223372036854775806
  410b40:	eb02003f 	cmp	x1, x2
  410b44:	54000109 	b.ls	410b64 <zcbor_map_start_decode+0x54>  // b.plast
			ERR_RESTORE(ZCBOR_ERR_INT_SIZE);
  410b48:	aa1303e0 	mov	x0, x19
  410b4c:	528000a1 	mov	w1, #0x5                   	// #5
  410b50:	97fffe9b 	bl	4105bc <err_restore>
}
  410b54:	2a0403e0 	mov	w0, w4
  410b58:	f9400bf3 	ldr	x19, [sp, #16]
  410b5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  410b60:	d65f03c0 	ret
		state->elem_count *= 2;
  410b64:	d37ff821 	lsl	x1, x1, #1
  410b68:	2a0003e4 	mov	w4, w0
  410b6c:	f9000a61 	str	x1, [x19, #16]
  410b70:	17fffff9 	b	410b54 <zcbor_map_start_decode+0x44>
  410b74:	52800004 	mov	w4, #0x0                   	// #0
  410b78:	17fffff7 	b	410b54 <zcbor_map_start_decode+0x44>

0000000000410b7c <zcbor_list_end_decode>:
	return list_map_end_decode(state);
  410b7c:	17ffff35 	b	410850 <list_map_end_decode>

0000000000410b80 <zcbor_simple_decode>:
{
  410b80:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410b84:	aa0003e6 	mov	x6, x0
  410b88:	aa0103e7 	mov	x7, x1
  410b8c:	910003fd 	mov	x29, sp
	INITIAL_CHECKS_WITH_TYPE(ZCBOR_MAJOR_TYPE_SIMPLE);
  410b90:	528000e1 	mov	w1, #0x7                   	// #7
  410b94:	97fffe79 	bl	410578 <type_check>
  410b98:	72001c00 	ands	w0, w0, #0xff
  410b9c:	54000140 	b.eq	410bc4 <zcbor_simple_decode+0x44>  // b.none
	ZCBOR_ERR_IF(ADDITIONAL(*state->payload) > 24, ZCBOR_ERR_WRONG_TYPE);
  410ba0:	f94000c0 	ldr	x0, [x6]
  410ba4:	39400000 	ldrb	w0, [x0]
  410ba8:	12001000 	and	w0, w0, #0x1f
  410bac:	7100601f 	cmp	w0, #0x18
  410bb0:	540000e9 	b.ls	410bcc <zcbor_simple_decode+0x4c>  // b.plast
  410bb4:	aa0603e0 	mov	x0, x6
  410bb8:	52800141 	mov	w1, #0xa                   	// #10
  410bbc:	97fffe52 	bl	410504 <zcbor_error>
  410bc0:	52800000 	mov	w0, #0x0                   	// #0
}
  410bc4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410bc8:	d65f03c0 	ret
  410bcc:	a8c17bfd 	ldp	x29, x30, [sp], #16
	if (!value_extract(state, result, sizeof(*result))) {
  410bd0:	aa0703e1 	mov	x1, x7
  410bd4:	aa0603e0 	mov	x0, x6
  410bd8:	d2800022 	mov	x2, #0x1                   	// #1
  410bdc:	17fffe7e 	b	4105d4 <value_extract>

0000000000410be0 <zcbor_simple_expect>:
{
  410be0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410be4:	910003fd 	mov	x29, sp
  410be8:	a90153f3 	stp	x19, x20, [sp, #16]
  410bec:	12001c34 	and	w20, w1, #0xff
  410bf0:	b0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  410bf4:	aa0003f3 	mov	x19, x0
  410bf8:	f9475c21 	ldr	x1, [x1, #3768]
  410bfc:	f9400022 	ldr	x2, [x1]
  410c00:	f90017e2 	str	x2, [sp, #40]
  410c04:	d2800002 	mov	x2, #0x0                   	// #0
	if (!zcbor_simple_decode(state, &value)) {
  410c08:	91009fe1 	add	x1, sp, #0x27
  410c0c:	97ffffdd 	bl	410b80 <zcbor_simple_decode>
  410c10:	72001c00 	ands	w0, w0, #0xff
  410c14:	54000100 	b.eq	410c34 <zcbor_simple_expect+0x54>  // b.none
	if (value != result) {
  410c18:	39409fe1 	ldrb	w1, [sp, #39]
  410c1c:	6b14003f 	cmp	w1, w20
  410c20:	540000a0 	b.eq	410c34 <zcbor_simple_expect+0x54>  // b.none
		ERR_RESTORE(ZCBOR_ERR_WRONG_VALUE);
  410c24:	aa1303e0 	mov	x0, x19
  410c28:	52800161 	mov	w1, #0xb                   	// #11
  410c2c:	97fffe64 	bl	4105bc <err_restore>
  410c30:	52800000 	mov	w0, #0x0                   	// #0
}
  410c34:	b0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  410c38:	f9475c21 	ldr	x1, [x1, #3768]
  410c3c:	f94017e3 	ldr	x3, [sp, #40]
  410c40:	f9400022 	ldr	x2, [x1]
  410c44:	eb020063 	subs	x3, x3, x2
  410c48:	d2800002 	mov	x2, #0x0                   	// #0
  410c4c:	54000040 	b.eq	410c54 <zcbor_simple_expect+0x74>  // b.none
  410c50:	97ffc234 	bl	401520 <__stack_chk_fail@plt>
  410c54:	a94153f3 	ldp	x19, x20, [sp, #16]
  410c58:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410c5c:	d65f03c0 	ret

0000000000410c60 <zcbor_nil_expect>:
	return zcbor_simple_expect(state, 22);
  410c60:	528002c1 	mov	w1, #0x16                  	// #22
  410c64:	17ffffdf 	b	410be0 <zcbor_simple_expect>

0000000000410c68 <zcbor_bool_decode>:
{
  410c68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410c6c:	910003fd 	mov	x29, sp
  410c70:	a90153f3 	stp	x19, x20, [sp, #16]
  410c74:	aa0103f3 	mov	x19, x1
  410c78:	b0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  410c7c:	aa0003f4 	mov	x20, x0
  410c80:	f9475c21 	ldr	x1, [x1, #3768]
  410c84:	f9400022 	ldr	x2, [x1]
  410c88:	f90017e2 	str	x2, [sp, #40]
  410c8c:	d2800002 	mov	x2, #0x0                   	// #0
	if (!zcbor_simple_decode(state, &value)) {
  410c90:	91009fe1 	add	x1, sp, #0x27
  410c94:	97ffffbb 	bl	410b80 <zcbor_simple_decode>
  410c98:	72001c00 	ands	w0, w0, #0xff
  410c9c:	54000160 	b.eq	410cc8 <zcbor_bool_decode+0x60>  // b.none
	value -= ZCBOR_BOOL_TO_SIMPLE;
  410ca0:	39409fe2 	ldrb	w2, [sp, #39]
  410ca4:	51005042 	sub	w2, w2, #0x14
  410ca8:	12001c42 	and	w2, w2, #0xff
  410cac:	39009fe2 	strb	w2, [sp, #39]
	if (value > 1) {
  410cb0:	7100045f 	cmp	w2, #0x1
  410cb4:	540001a9 	b.ls	410ce8 <zcbor_bool_decode+0x80>  // b.plast
		ERR_RESTORE(ZCBOR_ERR_WRONG_TYPE);
  410cb8:	aa1403e0 	mov	x0, x20
  410cbc:	52800141 	mov	w1, #0xa                   	// #10
  410cc0:	97fffe3f 	bl	4105bc <err_restore>
  410cc4:	52800000 	mov	w0, #0x0                   	// #0
}
  410cc8:	b0000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  410ccc:	f9475c21 	ldr	x1, [x1, #3768]
  410cd0:	f94017e3 	ldr	x3, [sp, #40]
  410cd4:	f9400022 	ldr	x2, [x1]
  410cd8:	eb020063 	subs	x3, x3, x2
  410cdc:	d2800002 	mov	x2, #0x0                   	// #0
  410ce0:	540000a0 	b.eq	410cf4 <zcbor_bool_decode+0x8c>  // b.none
  410ce4:	97ffc20f 	bl	401520 <__stack_chk_fail@plt>
	*result = value;
  410ce8:	12000042 	and	w2, w2, #0x1
  410cec:	39000262 	strb	w2, [x19]
	return true;
  410cf0:	17fffff6 	b	410cc8 <zcbor_bool_decode+0x60>
}
  410cf4:	a94153f3 	ldp	x19, x20, [sp, #16]
  410cf8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410cfc:	d65f03c0 	ret

0000000000410d00 <zcbor_float32_decode>:
	return true;
}


bool zcbor_float32_decode(zcbor_state_t *state, float *result)
{
  410d00:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410d04:	aa0103e9 	mov	x9, x1
  410d08:	aa0003e8 	mov	x8, x0
  410d0c:	910003fd 	mov	x29, sp
	ZCBOR_FAIL_IF(!float_check(state, ZCBOR_VALUE_IS_4_BYTES));
  410d10:	52800341 	mov	w1, #0x1a                  	// #26
  410d14:	97fffee3 	bl	4108a0 <float_check>
  410d18:	72001c1f 	tst	w0, #0xff
  410d1c:	540000c0 	b.eq	410d34 <zcbor_float32_decode+0x34>  // b.none
	if (!value_extract(state, result, sizeof(*result))) {
		ZCBOR_FAIL();
	}

	return true;
}
  410d20:	a8c17bfd 	ldp	x29, x30, [sp], #16
	if (!value_extract(state, result, sizeof(*result))) {
  410d24:	aa0903e1 	mov	x1, x9
  410d28:	aa0803e0 	mov	x0, x8
  410d2c:	d2800082 	mov	x2, #0x4                   	// #4
  410d30:	17fffe29 	b	4105d4 <value_extract>
}
  410d34:	52800000 	mov	w0, #0x0                   	// #0
  410d38:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410d3c:	d65f03c0 	ret

0000000000410d40 <zcbor_new_decode_state>:


void zcbor_new_decode_state(zcbor_state_t *state_array, size_t n_states,
		const uint8_t *payload, size_t payload_len, size_t elem_count)
{
	zcbor_new_state(state_array, n_states, payload, payload_len, elem_count);
  410d40:	17fffdb2 	b	410408 <zcbor_new_state>

0000000000410d44 <get_result_len>:
	return true;
}


static size_t get_result_len(const void *const input, size_t max_result_len)
{
  410d44:	aa0003e2 	mov	x2, x0
	uint8_t *u8_result  = (uint8_t *)input;
	size_t len = max_result_len;

	for (; len > 0; len--) {
  410d48:	aa0103e0 	mov	x0, x1
  410d4c:	b5000041 	cbnz	x1, 410d54 <get_result_len+0x10>
		}
	}

	/* Round up to nearest power of 2. */
	return len <= 2 ? len : (uint8_t)(1 << log2ceil(len));
}
  410d50:	d65f03c0 	ret
		if (u8_result[len - 1] != 0) {
  410d54:	d1000401 	sub	x1, x0, #0x1
  410d58:	38616843 	ldrb	w3, [x2, x1]
  410d5c:	34ffff63 	cbz	w3, 410d48 <get_result_len+0x4>
	return len <= 2 ? len : (uint8_t)(1 << log2ceil(len));
  410d60:	f100081f 	cmp	x0, #0x2
  410d64:	54ffff69 	b.ls	410d50 <get_result_len+0xc>  // b.plast
	switch(val) {
  410d68:	d1000800 	sub	x0, x0, #0x2
  410d6c:	f100181f 	cmp	x0, #0x6
  410d70:	54000108 	b.hi	410d90 <get_result_len+0x4c>  // b.pmore
  410d74:	b0000041 	adrp	x1, 419000 <__func__.2+0xa80>
  410d78:	913f7821 	add	x1, x1, #0xfde
  410d7c:	38606821 	ldrb	w1, [x1, x0]
	return len <= 2 ? len : (uint8_t)(1 << log2ceil(len));
  410d80:	52800020 	mov	w0, #0x1                   	// #1
  410d84:	1ac12000 	lsl	w0, w0, w1
  410d88:	93407c00 	sxtw	x0, w0
  410d8c:	17fffff1 	b	410d50 <get_result_len+0xc>
  410d90:	52800001 	mov	w1, #0x0                   	// #0
  410d94:	17fffffb 	b	410d80 <get_result_len+0x3c>

0000000000410d98 <zcbor_check_error.isra.0>:
	return !(cs && cs->stop_on_error && cs->error);
  410d98:	b40000e0 	cbz	x0, 410db4 <zcbor_check_error.isra.0+0x1c>
  410d9c:	39407001 	ldrb	w1, [x0, #28]
  410da0:	340000a1 	cbz	w1, 410db4 <zcbor_check_error.isra.0+0x1c>
  410da4:	b9401800 	ldr	w0, [x0, #24]
  410da8:	7100001f 	cmp	w0, #0x0
  410dac:	1a9f17e0 	cset	w0, eq  // eq = none
}
  410db0:	d65f03c0 	ret
	return !(cs && cs->stop_on_error && cs->error);
  410db4:	52800020 	mov	w0, #0x1                   	// #1
  410db8:	17fffffe 	b	410db0 <zcbor_check_error.isra.0+0x18>

0000000000410dbc <zcbor_error>:
{
  410dbc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410dc0:	2a0103e3 	mov	w3, w1
  410dc4:	910003fd 	mov	x29, sp
  410dc8:	f9401402 	ldr	x2, [x0, #40]
	if (zcbor_check_error(state))
  410dcc:	aa0203e0 	mov	x0, x2
  410dd0:	97fffff2 	bl	410d98 <zcbor_check_error.isra.0>
  410dd4:	72001c1f 	tst	w0, #0xff
  410dd8:	54000060 	b.eq	410de4 <zcbor_error+0x28>  // b.none
		if (state->constant_state) {
  410ddc:	b4000042 	cbz	x2, 410de4 <zcbor_error+0x28>
			state->constant_state->error = err;
  410de0:	b9001843 	str	w3, [x2, #24]
}
  410de4:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410de8:	d65f03c0 	ret

0000000000410dec <value_encode_len>:
{
  410dec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410df0:	aa0003e4 	mov	x4, x0
  410df4:	2a0103e6 	mov	w6, w1
  410df8:	910003fd 	mov	x29, sp

static size_t get_encoded_len(const void *const result, size_t result_len)
{
	const uint8_t *u8_result  = (const uint8_t *)result;

	if ((result_len == 1) && (u8_result[0] <= ZCBOR_VALUE_IN_HEADER)) {
  410dfc:	f100047f 	cmp	x3, #0x1
  410e00:	54000081 	b.ne	410e10 <value_encode_len+0x24>  // b.any
  410e04:	39400040 	ldrb	w0, [x2]
  410e08:	71005c1f 	cmp	w0, #0x17
  410e0c:	9a9f97e3 	cset	x3, hi  // hi = pmore
	if ((state->payload + 1 + encoded_len) > state->payload_end) {
  410e10:	f9400087 	ldr	x7, [x4]
  410e14:	91000460 	add	x0, x3, #0x1
  410e18:	f9400c88 	ldr	x8, [x4, #24]
  410e1c:	8b0000e0 	add	x0, x7, x0
  410e20:	eb00011f 	cmp	x8, x0
  410e24:	540000e2 	b.cs	410e40 <value_encode_len+0x54>  // b.hs, b.nlast
		ZCBOR_ERR(ZCBOR_ERR_NO_PAYLOAD);
  410e28:	52800101 	mov	w1, #0x8                   	// #8
	zcbor_assert_state(additional < 32, NULL);
  410e2c:	aa0403e0 	mov	x0, x4
  410e30:	97ffffe3 	bl	410dbc <zcbor_error>
		ZCBOR_FAIL();
  410e34:	52800000 	mov	w0, #0x0                   	// #0
}
  410e38:	a8c17bfd 	ldp	x29, x30, [sp], #16
  410e3c:	d65f03c0 	ret
	if (!encode_header_byte(state, major_type,
  410e40:	39400045 	ldrb	w5, [x2]
	return len == 0 ? value0 : (uint8_t)(24 + log2ceil(len));
  410e44:	b4000123 	cbz	x3, 410e68 <value_encode_len+0x7c>
	switch(val) {
  410e48:	d1000861 	sub	x1, x3, #0x2
  410e4c:	f100183f 	cmp	x1, #0x6
  410e50:	54000208 	b.hi	410e90 <value_encode_len+0xa4>  // b.pmore
  410e54:	b0000040 	adrp	x0, 419000 <__func__.2+0xa80>
  410e58:	913f7800 	add	x0, x0, #0xfde
  410e5c:	38616805 	ldrb	w5, [x0, x1]
	return len == 0 ? value0 : (uint8_t)(24 + log2ceil(len));
  410e60:	110060a5 	add	w5, w5, #0x18
  410e64:	12001ca5 	and	w5, w5, #0xff
	ZCBOR_CHECK_ERROR();
  410e68:	f9401480 	ldr	x0, [x4, #40]
  410e6c:	97ffffcb 	bl	410d98 <zcbor_check_error.isra.0>
  410e70:	72001c00 	ands	w0, w0, #0xff
  410e74:	54fffe20 	b.eq	410e38 <value_encode_len+0x4c>  // b.none
	ZCBOR_CHECK_PAYLOAD();
  410e78:	eb0800ff 	cmp	x7, x8
  410e7c:	54fffd62 	b.cs	410e28 <value_encode_len+0x3c>  // b.hs, b.nlast
	zcbor_assert_state(additional < 32, NULL);
  410e80:	71007cbf 	cmp	w5, #0x1f
  410e84:	540000a9 	b.ls	410e98 <value_encode_len+0xac>  // b.plast
  410e88:	528001c1 	mov	w1, #0xe                   	// #14
  410e8c:	17ffffe8 	b	410e2c <value_encode_len+0x40>
	return len == 0 ? value0 : (uint8_t)(24 + log2ceil(len));
  410e90:	52800005 	mov	w5, #0x0                   	// #0
  410e94:	17fffff3 	b	410e60 <value_encode_len+0x74>
	*(state->payload_mut++) = (uint8_t)((major_type << 5) | (additional & 0x1F));
  410e98:	910004e1 	add	x1, x7, #0x1
  410e9c:	f9000081 	str	x1, [x4]
  410ea0:	2a0614a6 	orr	w6, w5, w6, lsl #5
  410ea4:	390000e6 	strb	w6, [x7]
	for (; encoded_len > 0; encoded_len--) {
  410ea8:	b50000a3 	cbnz	x3, 410ebc <value_encode_len+0xd0>
	state->elem_count++;
  410eac:	f9400881 	ldr	x1, [x4, #16]
  410eb0:	91000421 	add	x1, x1, #0x1
  410eb4:	f9000881 	str	x1, [x4, #16]
	return true;
  410eb8:	17ffffe0 	b	410e38 <value_encode_len+0x4c>
		*(state->payload_mut++) = u8_result[encoded_len - 1];
  410ebc:	f9400081 	ldr	x1, [x4]
  410ec0:	d1000463 	sub	x3, x3, #0x1
  410ec4:	91000425 	add	x5, x1, #0x1
  410ec8:	f9000085 	str	x5, [x4]
  410ecc:	38636845 	ldrb	w5, [x2, x3]
  410ed0:	39000025 	strb	w5, [x1]
	for (; encoded_len > 0; encoded_len--) {
  410ed4:	17fffff5 	b	410ea8 <value_encode_len+0xbc>

0000000000410ed8 <value_encode.part.0>:
	}
	return result_len;
}


static bool value_encode(zcbor_state_t *state, zcbor_major_type_t major_type,
  410ed8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  410edc:	aa0003e5 	mov	x5, x0
  410ee0:	2a0103e6 	mov	w6, w1
  410ee4:	910003fd 	mov	x29, sp
  410ee8:	aa0203e4 	mov	x4, x2
  410eec:	aa0303e1 	mov	x1, x3
		const void *const input, size_t max_result_len)
{
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");

	size_t result_len = get_result_len(input, max_result_len);
  410ef0:	aa0203e0 	mov	x0, x2
  410ef4:	97ffff94 	bl	410d44 <get_result_len>
	const void *const result = get_result(input, max_result_len, result_len);

	return value_encode_len(state, major_type, result, result_len);
}
  410ef8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return value_encode_len(state, major_type, result, result_len);
  410efc:	aa0003e3 	mov	x3, x0
  410f00:	aa0403e2 	mov	x2, x4
  410f04:	2a0603e1 	mov	w1, w6
  410f08:	aa0503e0 	mov	x0, x5
  410f0c:	17ffffb8 	b	410dec <value_encode_len>

0000000000410f10 <str_encode>:
}


static bool str_encode(zcbor_state_t *state,
		const struct zcbor_string *input, zcbor_major_type_t major_type)
{
  410f10:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410f14:	910003fd 	mov	x29, sp
  410f18:	a90153f3 	stp	x19, x20, [sp, #16]
  410f1c:	aa0003f3 	mov	x19, x0
  410f20:	f90013f5 	str	x21, [sp, #32]
	ZCBOR_CHECK_PAYLOAD(); /* To make the size_t cast below safe. */
  410f24:	f9400004 	ldr	x4, [x0]
  410f28:	f9400c07 	ldr	x7, [x0, #24]
  410f2c:	eb07009f 	cmp	x4, x7
  410f30:	54000143 	b.cc	410f58 <str_encode+0x48>  // b.lo, b.ul, b.last
  410f34:	52800015 	mov	w21, #0x0                   	// #0
  410f38:	aa1303e0 	mov	x0, x19
  410f3c:	52800101 	mov	w1, #0x8                   	// #8
  410f40:	97ffff9f 	bl	410dbc <zcbor_error>
		 * because of bstrx_cbor_start_encode/bstrx_cbor_end_encode. */
		memmove(state->payload_mut, input->value, input->len);
	}
	state->payload += input->len;
	return true;
}
  410f44:	2a1503e0 	mov	w0, w21
  410f48:	a94153f3 	ldp	x19, x20, [sp, #16]
  410f4c:	f94013f5 	ldr	x21, [sp, #32]
  410f50:	a8c37bfd 	ldp	x29, x30, [sp], #48
  410f54:	d65f03c0 	ret
  410f58:	aa0103f4 	mov	x20, x1
	if (input->len > (size_t)(state->payload_end - state->payload)) {
  410f5c:	cb0400e1 	sub	x1, x7, x4
  410f60:	f9400680 	ldr	x0, [x20, #8]
  410f64:	91000408 	add	x8, x0, #0x1
  410f68:	eb01001f 	cmp	x0, x1
  410f6c:	54fffe48 	b.hi	410f34 <str_encode+0x24>  // b.pmore
	if (input->value && ((get_result_len(&input->len, sizeof(input->len))
  410f70:	aa1403e5 	mov	x5, x20
  410f74:	2a0203e6 	mov	w6, w2
  410f78:	f84084a0 	ldr	x0, [x5], #8
  410f7c:	b4000100 	cbz	x0, 410f9c <str_encode+0x8c>
  410f80:	aa0503e0 	mov	x0, x5
  410f84:	d2800101 	mov	x1, #0x8                   	// #8
  410f88:	97ffff6f 	bl	410d44 <get_result_len>
			+ 1 + input->len + (size_t)state->payload)
  410f8c:	8b000084 	add	x4, x4, x0
  410f90:	8b080084 	add	x4, x4, x8
	if (input->value && ((get_result_len(&input->len, sizeof(input->len))
  410f94:	eb0400ff 	cmp	x7, x4
  410f98:	54fffce3 	b.cc	410f34 <str_encode+0x24>  // b.lo, b.ul, b.last
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  410f9c:	aa0503e2 	mov	x2, x5
  410fa0:	2a0603e1 	mov	w1, w6
  410fa4:	aa1303e0 	mov	x0, x19
  410fa8:	d2800103 	mov	x3, #0x8                   	// #8
  410fac:	97ffffcb 	bl	410ed8 <value_encode.part.0>
	if (!value_encode(state, major_type, &input->len, sizeof(input->len))) {
  410fb0:	72001c15 	ands	w21, w0, #0xff
  410fb4:	54fffc80 	b.eq	410f44 <str_encode+0x34>  // b.none
	if (state->payload_mut != input->value) {
  410fb8:	f9400260 	ldr	x0, [x19]
  410fbc:	f9400281 	ldr	x1, [x20]
  410fc0:	eb01001f 	cmp	x0, x1
  410fc4:	54000060 	b.eq	410fd0 <str_encode+0xc0>  // b.none
  return __builtin___memmove_chk (__dest, __src, __len,
  410fc8:	f9400682 	ldr	x2, [x20, #8]
  410fcc:	97ffc0dd 	bl	401340 <memmove@plt>
	state->payload += input->len;
  410fd0:	f9400260 	ldr	x0, [x19]
  410fd4:	f9400681 	ldr	x1, [x20, #8]
  410fd8:	8b010000 	add	x0, x0, x1
  410fdc:	f9000260 	str	x0, [x19]
	return true;
  410fe0:	17ffffd9 	b	410f44 <str_encode+0x34>

0000000000410fe4 <list_map_start_encode>:
}


static bool list_map_start_encode(zcbor_state_t *state, size_t max_num,
		zcbor_major_type_t major_type)
{
  410fe4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  410fe8:	910003fd 	mov	x29, sp
  410fec:	a90153f3 	stp	x19, x20, [sp, #16]
  410ff0:	aa0003f3 	mov	x19, x0
  410ff4:	2a0203f4 	mov	w20, w2
  410ff8:	f90017e1 	str	x1, [sp, #40]
#ifdef ZCBOR_CANONICAL
	if (!zcbor_new_backup(state, 0)) {
  410ffc:	d2800001 	mov	x1, #0x0                   	// #0
  411000:	97fffcb5 	bl	4102d4 <zcbor_new_backup>
  411004:	72001c1f 	tst	w0, #0xff
  411008:	540000a1 	b.ne	41101c <list_map_start_encode+0x38>  // b.any
		ZCBOR_FAIL();
  41100c:	52800000 	mov	w0, #0x0                   	// #0
	if (!encode_header_byte(state, major_type, ZCBOR_VALUE_IS_INDEFINITE_LENGTH)) {
		ZCBOR_FAIL();
	}
#endif
	return true;
}
  411010:	a94153f3 	ldp	x19, x20, [sp, #16]
  411014:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411018:	d65f03c0 	ret
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  41101c:	9100a3e2 	add	x2, sp, #0x28
  411020:	2a1403e1 	mov	w1, w20
  411024:	aa1303e0 	mov	x0, x19
  411028:	d2800103 	mov	x3, #0x8                   	// #8
  41102c:	97ffffab 	bl	410ed8 <value_encode.part.0>
	if (!value_encode(state, major_type, &max_num, sizeof(max_num))) {
  411030:	72001c00 	ands	w0, w0, #0xff
  411034:	54fffec0 	b.eq	41100c <list_map_start_encode+0x28>  // b.none
	state->elem_count--; /* Because of dummy header. */
  411038:	f9400a61 	ldr	x1, [x19, #16]
  41103c:	d1000421 	sub	x1, x1, #0x1
  411040:	f9000a61 	str	x1, [x19, #16]
	return true;
  411044:	17fffff3 	b	411010 <list_map_start_encode+0x2c>

0000000000411048 <list_map_end_encode>:
#endif


static bool list_map_end_encode(zcbor_state_t *state, size_t max_num,
			zcbor_major_type_t major_type)
{
  411048:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  41104c:	910003fd 	mov	x29, sp
  411050:	a90153f3 	stp	x19, x20, [sp, #16]
  411054:	aa0003f4 	mov	x20, x0
  411058:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  41105c:	a9025bf5 	stp	x21, x22, [sp, #32]
  411060:	2a0203f6 	mov	w22, w2
  411064:	f9475c00 	ldr	x0, [x0, #3768]
  411068:	a90363f7 	stp	x23, x24, [sp, #48]
  41106c:	f90027e1 	str	x1, [sp, #72]
#ifdef ZCBOR_CANONICAL
	size_t list_count = ((major_type == ZCBOR_MAJOR_TYPE_LIST) ?
					state->elem_count
					: (state->elem_count / 2));
  411070:	f9400a84 	ldr	x4, [x20, #16]
{
  411074:	f9400001 	ldr	x1, [x0]
  411078:	f9002fe1 	str	x1, [sp, #88]
  41107c:	d2800001 	mov	x1, #0x0                   	// #0
					: (state->elem_count / 2));
  411080:	7100105f 	cmp	w2, #0x4
  411084:	54000040 	b.eq	41108c <list_map_end_encode+0x44>  // b.none
  411088:	d341fc84 	lsr	x4, x4, #1
	size_t result_len = get_result_len(input, max_result_len);
  41108c:	910123e0 	add	x0, sp, #0x48
  411090:	d2800081 	mov	x1, #0x4                   	// #4
	size_t list_count = ((major_type == ZCBOR_MAJOR_TYPE_LIST) ?
  411094:	f9002be4 	str	x4, [sp, #80]
	size_t result_len = get_result_len(input, max_result_len);
  411098:	97ffff2b 	bl	410d44 <get_result_len>
  41109c:	aa0003f3 	mov	x19, x0

	const uint8_t *payload = state->payload;
  4110a0:	f9400297 	ldr	x23, [x20]
	if ((result_len == 1) && (u8_result[0] <= ZCBOR_VALUE_IN_HEADER)) {
  4110a4:	f100041f 	cmp	x0, #0x1
  4110a8:	54000081 	b.ne	4110b8 <list_map_end_encode+0x70>  // b.any
  4110ac:	394123e0 	ldrb	w0, [sp, #72]
  4110b0:	71005c1f 	cmp	w0, #0x17
  4110b4:	9a9f97f3 	cset	x19, hi  // hi = pmore
	size_t result_len = get_result_len(input, max_result_len);
  4110b8:	910143f8 	add	x24, sp, #0x50
  4110bc:	d2800081 	mov	x1, #0x4                   	// #4
  4110c0:	aa1803e0 	mov	x0, x24
  4110c4:	97ffff20 	bl	410d44 <get_result_len>
  4110c8:	aa0003f5 	mov	x21, x0
	if ((result_len == 1) && (u8_result[0] <= ZCBOR_VALUE_IN_HEADER)) {
  4110cc:	f100041f 	cmp	x0, #0x1
  4110d0:	54000081 	b.ne	4110e0 <list_map_end_encode+0x98>  // b.any
  4110d4:	12001c84 	and	w4, w4, #0xff
  4110d8:	71005c9f 	cmp	w4, #0x17
  4110dc:	9a9f97f5 	cset	x21, hi  // hi = pmore

	size_t max_header_len = get_encoded_len2(&max_num, 4);
	size_t header_len = get_encoded_len2(&list_count, 4);

	if (!zcbor_process_backup(state, ZCBOR_FLAG_RESTORE | ZCBOR_FLAG_CONSUME, 0xFFFFFFFF)) {
  4110e0:	aa1403e0 	mov	x0, x20
  4110e4:	b2407fe2 	mov	x2, #0xffffffff            	// #4294967295
  4110e8:	52800061 	mov	w1, #0x3                   	// #3
  4110ec:	97fffc9c 	bl	41035c <zcbor_process_backup>
  4110f0:	72001c1f 	tst	w0, #0xff
  4110f4:	54000141 	b.ne	41111c <list_map_end_encode+0xd4>  // b.any
	/** If max_num is smaller than the actual number of encoded elements,
	  * the value_encode() below will corrupt the data if the encoded
	  * header is larger than the previously encoded header. */
	if (header_len > max_header_len) {
		zcbor_print("max_num too small.\r\n");
		ZCBOR_ERR(ZCBOR_ERR_HIGH_ELEM_COUNT);
  4110f8:	52800016 	mov	w22, #0x0                   	// #0
	if (!encode_header_byte(state, ZCBOR_MAJOR_TYPE_SIMPLE, ZCBOR_VALUE_IS_INDEFINITE_LENGTH)) {
		ZCBOR_FAIL();
	}
#endif
	return true;
}
  4110fc:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  411100:	f9475c00 	ldr	x0, [x0, #3768]
  411104:	f9402fe2 	ldr	x2, [sp, #88]
  411108:	f9400001 	ldr	x1, [x0]
  41110c:	eb010042 	subs	x2, x2, x1
  411110:	d2800001 	mov	x1, #0x0                   	// #0
  411114:	540003a0 	b.eq	411188 <list_map_end_encode+0x140>  // b.none
  411118:	97ffc102 	bl	401520 <__stack_chk_fail@plt>
	if (header_len > max_header_len) {
  41111c:	eb15027f 	cmp	x19, x21
  411120:	540000a2 	b.cs	411134 <list_map_end_encode+0xec>  // b.hs, b.nlast
		ZCBOR_ERR(ZCBOR_ERR_HIGH_ELEM_COUNT);
  411124:	aa1403e0 	mov	x0, x20
  411128:	52800081 	mov	w1, #0x4                   	// #4
  41112c:	97ffff24 	bl	410dbc <zcbor_error>
  411130:	17fffff2 	b	4110f8 <list_map_end_encode+0xb0>
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  411134:	2a1603e1 	mov	w1, w22
  411138:	aa1803e2 	mov	x2, x24
  41113c:	aa1403e0 	mov	x0, x20
  411140:	d2800103 	mov	x3, #0x8                   	// #8
  411144:	97ffff65 	bl	410ed8 <value_encode.part.0>
	if (!(value_encode(state, major_type, &list_count, sizeof(list_count)))) {
  411148:	72001c16 	ands	w22, w0, #0xff
  41114c:	54fffd60 	b.eq	4110f8 <list_map_end_encode+0xb0>  // b.none
	if (max_header_len != header_len) {
  411150:	eb15027f 	cmp	x19, x21
  411154:	54000160 	b.eq	411180 <list_map_end_encode+0x138>  // b.none
		const uint8_t *start = state->payload + max_header_len - header_len;
  411158:	f9400280 	ldr	x0, [x20]
  41115c:	cb150261 	sub	x1, x19, x21
  411160:	8b010001 	add	x1, x0, x1
		size_t body_size = (size_t)payload - (size_t)start;
  411164:	cb0102f7 	sub	x23, x23, x1
  411168:	aa1703e2 	mov	x2, x23
  41116c:	97ffc075 	bl	401340 <memmove@plt>
		state->payload += body_size;
  411170:	f9400280 	ldr	x0, [x20]
  411174:	8b170000 	add	x0, x0, x23
  411178:	f9000280 	str	x0, [x20]
  41117c:	17ffffe0 	b	4110fc <list_map_end_encode+0xb4>
		state->payload = payload;
  411180:	f9000297 	str	x23, [x20]
  411184:	17ffffde 	b	4110fc <list_map_end_encode+0xb4>
}
  411188:	2a1603e0 	mov	w0, w22
  41118c:	a94153f3 	ldp	x19, x20, [sp, #16]
  411190:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411194:	a94363f7 	ldp	x23, x24, [sp, #48]
  411198:	a8c67bfd 	ldp	x29, x30, [sp], #96
  41119c:	d65f03c0 	ret

00000000004111a0 <zcbor_int_encode>:
{
  4111a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4111a4:	aa0103e4 	mov	x4, x1
  4111a8:	90000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4111ac:	910003fd 	mov	x29, sp
  4111b0:	f9475c21 	ldr	x1, [x1, #3768]
  4111b4:	aa0203e3 	mov	x3, x2
  4111b8:	f9400022 	ldr	x2, [x1]
  4111bc:	f9000fe2 	str	x2, [sp, #24]
  4111c0:	d2800002 	mov	x2, #0x0                   	// #0
	if (int_size > sizeof(int64_t)) {
  4111c4:	f100207f 	cmp	x3, #0x8
  4111c8:	54000189 	b.ls	4111f8 <zcbor_int_encode+0x58>  // b.plast
		ZCBOR_ERR(ZCBOR_ERR_INT_SIZE);
  4111cc:	528000a1 	mov	w1, #0x5                   	// #5
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  4111d0:	97fffefb 	bl	410dbc <zcbor_error>
		ZCBOR_FAIL();
  4111d4:	52800000 	mov	w0, #0x0                   	// #0
}
  4111d8:	90000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4111dc:	f9475c21 	ldr	x1, [x1, #3768]
  4111e0:	f9400fe3 	ldr	x3, [sp, #24]
  4111e4:	f9400022 	ldr	x2, [x1]
  4111e8:	eb020063 	subs	x3, x3, x2
  4111ec:	d2800002 	mov	x2, #0x0                   	// #0
  4111f0:	54000380 	b.eq	411260 <zcbor_int_encode+0xc0>  // b.none
  4111f4:	97ffc0cb 	bl	401520 <__stack_chk_fail@plt>
  4111f8:	aa0003e5 	mov	x5, x0
	if (input_int8[int_size - 1] < 0) {
  4111fc:	8b030080 	add	x0, x4, x3
  411200:	38dff000 	ldursb	w0, [x0, #-1]
  411204:	37f801e0 	tbnz	w0, #31, 411240 <zcbor_int_encode+0xa0>
		major_type = ZCBOR_MAJOR_TYPE_PINT;
  411208:	52800001 	mov	w1, #0x0                   	// #0
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  41120c:	b5000203 	cbnz	x3, 41124c <zcbor_int_encode+0xac>
  411210:	aa0503e0 	mov	x0, x5
  411214:	528001c1 	mov	w1, #0xe                   	// #14
  411218:	17ffffee 	b	4111d0 <zcbor_int_encode+0x30>
			input_buf[i] = (uint8_t)~input_uint8[i];
  41121c:	38616880 	ldrb	w0, [x4, x1]
  411220:	2a2003e0 	mvn	w0, w0
  411224:	38216840 	strb	w0, [x2, x1]
		for (unsigned int i = 0; i < int_size; i++) {
  411228:	91000421 	add	x1, x1, #0x1
  41122c:	eb01007f 	cmp	x3, x1
  411230:	54ffff61 	b.ne	41121c <zcbor_int_encode+0x7c>  // b.any
		input = input_buf;
  411234:	aa0203e4 	mov	x4, x2
		major_type = ZCBOR_MAJOR_TYPE_NINT;
  411238:	52800021 	mov	w1, #0x1                   	// #1
  41123c:	17fffff4 	b	41120c <zcbor_int_encode+0x6c>
  411240:	910043e2 	add	x2, sp, #0x10
  411244:	d2800001 	mov	x1, #0x0                   	// #0
  411248:	17fffff9 	b	41122c <zcbor_int_encode+0x8c>
  41124c:	aa0403e2 	mov	x2, x4
  411250:	aa0503e0 	mov	x0, x5
  411254:	97ffff21 	bl	410ed8 <value_encode.part.0>
  411258:	12001c00 	and	w0, w0, #0xff
  41125c:	17ffffdf 	b	4111d8 <zcbor_int_encode+0x38>
}
  411260:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411264:	d65f03c0 	ret

0000000000411268 <zcbor_uint_encode>:
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  411268:	b40000a2 	cbz	x2, 41127c <zcbor_uint_encode+0x14>
  41126c:	aa0203e3 	mov	x3, x2
  411270:	aa0103e2 	mov	x2, x1
  411274:	52800001 	mov	w1, #0x0                   	// #0
  411278:	17ffff18 	b	410ed8 <value_encode.part.0>
{
  41127c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  411280:	528001c1 	mov	w1, #0xe                   	// #14
{
  411284:	910003fd 	mov	x29, sp
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  411288:	97fffecd 	bl	410dbc <zcbor_error>
}
  41128c:	52800000 	mov	w0, #0x0                   	// #0
  411290:	a8c17bfd 	ldp	x29, x30, [sp], #16
  411294:	d65f03c0 	ret

0000000000411298 <zcbor_int32_put>:
{
  411298:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return zcbor_int_encode(state, &input, sizeof(input));
  41129c:	d2800082 	mov	x2, #0x4                   	// #4
{
  4112a0:	910003fd 	mov	x29, sp
  4112a4:	b9001fe1 	str	w1, [sp, #28]
	return zcbor_int_encode(state, &input, sizeof(input));
  4112a8:	910073e1 	add	x1, sp, #0x1c
  4112ac:	97ffffbd 	bl	4111a0 <zcbor_int_encode>
}
  4112b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4112b4:	d65f03c0 	ret

00000000004112b8 <zcbor_uint32_put>:
{
  4112b8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return zcbor_uint_encode(state, &input, sizeof(input));
  4112bc:	d2800082 	mov	x2, #0x4                   	// #4
{
  4112c0:	910003fd 	mov	x29, sp
  4112c4:	b9001fe1 	str	w1, [sp, #28]
	return zcbor_uint_encode(state, &input, sizeof(input));
  4112c8:	910073e1 	add	x1, sp, #0x1c
  4112cc:	97ffffe7 	bl	411268 <zcbor_uint_encode>
}
  4112d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4112d4:	d65f03c0 	ret

00000000004112d8 <zcbor_tstr_encode>:
	return str_encode(state, input, ZCBOR_MAJOR_TYPE_TSTR);
  4112d8:	52800062 	mov	w2, #0x3                   	// #3
  4112dc:	17ffff0d 	b	410f10 <str_encode>

00000000004112e0 <zcbor_list_start_encode>:
	return list_map_start_encode(state, max_num, ZCBOR_MAJOR_TYPE_LIST);
  4112e0:	52800082 	mov	w2, #0x4                   	// #4
  4112e4:	17ffff40 	b	410fe4 <list_map_start_encode>

00000000004112e8 <zcbor_map_start_encode>:
	return list_map_start_encode(state, max_num, ZCBOR_MAJOR_TYPE_MAP);
  4112e8:	528000a2 	mov	w2, #0x5                   	// #5
  4112ec:	17ffff3e 	b	410fe4 <list_map_start_encode>

00000000004112f0 <zcbor_list_end_encode>:


bool zcbor_list_end_encode(zcbor_state_t *state, size_t max_num)
{
	return list_map_end_encode(state, max_num, ZCBOR_MAJOR_TYPE_LIST);
  4112f0:	52800082 	mov	w2, #0x4                   	// #4
  4112f4:	17ffff55 	b	411048 <list_map_end_encode>

00000000004112f8 <zcbor_map_end_encode>:
}


bool zcbor_map_end_encode(zcbor_state_t *state, size_t max_num)
{
	return list_map_end_encode(state, max_num, ZCBOR_MAJOR_TYPE_MAP);
  4112f8:	528000a2 	mov	w2, #0x5                   	// #5
  4112fc:	17ffff53 	b	411048 <list_map_end_encode>

0000000000411300 <zcbor_simple_put>:
	return true;
}


bool zcbor_simple_put(zcbor_state_t *state, uint8_t input)
{
  411300:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	zcbor_assert_state(max_result_len != 0, "0-length result not supported.\r\n");
  411304:	d2800023 	mov	x3, #0x1                   	// #1
{
  411308:	910003fd 	mov	x29, sp
  41130c:	91007fe2 	add	x2, sp, #0x1f
  411310:	39007fe1 	strb	w1, [sp, #31]
  411314:	528000e1 	mov	w1, #0x7                   	// #7
  411318:	97fffef0 	bl	410ed8 <value_encode.part.0>
	return value_encode(state, ZCBOR_MAJOR_TYPE_SIMPLE, &input, sizeof(input));
}
  41131c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411320:	d65f03c0 	ret

0000000000411324 <zcbor_nil_put>:


bool zcbor_nil_put(zcbor_state_t *state, const void *unused)
{
	(void)unused;
	return zcbor_simple_put(state, 22);
  411324:	528002c1 	mov	w1, #0x16                  	// #22
  411328:	17fffff6 	b	411300 <zcbor_simple_put>

000000000041132c <zcbor_bool_put>:
	return zcbor_bool_put(state, *input);
}


bool zcbor_bool_put(zcbor_state_t *state, bool input)
{
  41132c:	12001c21 	and	w1, w1, #0xff
	return zcbor_simple_put(state, (!!input + ZCBOR_BOOL_TO_SIMPLE));
  411330:	11005021 	add	w1, w1, #0x14
  411334:	17fffff3 	b	411300 <zcbor_simple_put>

0000000000411338 <zcbor_float32_encode>:
}


bool zcbor_float32_encode(zcbor_state_t *state, const float *input)
{
	if (!value_encode_len(state, ZCBOR_MAJOR_TYPE_SIMPLE, input,
  411338:	aa0103e2 	mov	x2, x1
  41133c:	d2800083 	mov	x3, #0x4                   	// #4
  411340:	528000e1 	mov	w1, #0x7                   	// #7
  411344:	17fffeaa 	b	410dec <value_encode_len>

0000000000411348 <zcbor_float32_put>:
	return true;
}


bool zcbor_float32_put(zcbor_state_t *state, float input)
{
  411348:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  41134c:	910003fd 	mov	x29, sp
	return zcbor_float32_encode(state, &input);
  411350:	910073e1 	add	x1, sp, #0x1c
{
  411354:	bd001fe0 	str	s0, [sp, #28]
	return zcbor_float32_encode(state, &input);
  411358:	97fffff8 	bl	411338 <zcbor_float32_encode>
}
  41135c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411360:	d65f03c0 	ret

0000000000411364 <zcbor_new_encode_state>:


void zcbor_new_encode_state(zcbor_state_t *state_array, size_t n_states,
		uint8_t *payload, size_t payload_len, size_t elem_count)
{
	zcbor_new_state(state_array, n_states, payload, payload_len, elem_count);
  411364:	17fffc29 	b	410408 <zcbor_new_state>

0000000000411368 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	STRUCT_SECTION_FOREACH(device, dev) {
  411368:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  41136c:	90000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  411370:	f9475000 	ldr	x0, [x0, #3744]
  411374:	f9478021 	ldr	x1, [x1, #3840]
  411378:	eb01001f 	cmp	x0, x1
  41137c:	54000349 	b.ls	4113e4 <z_device_state_init+0x7c>  // b.plast
{
  411380:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	STRUCT_SECTION_FOREACH(device, dev) {
  411384:	b0000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  411388:	91002021 	add	x1, x1, #0x8
{
  41138c:	910003fd 	mov	x29, sp
  411390:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(device, dev) {
  411394:	90000053 	adrp	x19, 419000 <__func__.2+0xa80>
  411398:	913f9673 	add	x19, x19, #0xfe5
  41139c:	528002e3 	mov	w3, #0x17                  	// #23
  4113a0:	aa1303e2 	mov	x2, x19
  4113a4:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4113a8:	91178000 	add	x0, x0, #0x5e0
  4113ac:	97ffd69f 	bl	406e28 <assert_print>
  4113b0:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4113b4:	91248400 	add	x0, x0, #0x921
  4113b8:	97ffd69c 	bl	406e28 <assert_print>
  4113bc:	aa1303e0 	mov	x0, x19
  4113c0:	528002e1 	mov	w1, #0x17                  	// #23
  4113c4:	97ffd6c3 	bl	406ed0 <assert_post_action>
  4113c8:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4113cc:	aa1303e1 	mov	x1, x19
  4113d0:	91187800 	add	x0, x0, #0x61e
  4113d4:	528002e2 	mov	w2, #0x17                  	// #23
  4113d8:	97ffe0b0 	bl	409698 <posix_print_error_and_exit>
  4113dc:	9100c000 	add	x0, x0, #0x30
  4113e0:	17ffffe6 	b	411378 <z_device_state_init+0x10>
  4113e4:	54ffffc3 	b.cc	4113dc <z_device_state_init+0x74>  // b.lo, b.ul, b.last
  4113e8:	d65f03c0 	ret

00000000004113ec <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
  4113ec:	b4000100 	cbz	x0, 41140c <z_device_is_ready+0x20>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
  4113f0:	f9400c00 	ldr	x0, [x0, #24]
  4113f4:	39400401 	ldrb	w1, [x0, #1]
  4113f8:	360000a1 	tbz	w1, #0, 41140c <z_device_is_ready+0x20>
  4113fc:	39400000 	ldrb	w0, [x0]
  411400:	7100001f 	cmp	w0, #0x0
  411404:	1a9f17e0 	cset	w0, eq  // eq = none
}
  411408:	d65f03c0 	ret
		return false;
  41140c:	52800000 	mov	w0, #0x0                   	// #0
  411410:	17fffffe 	b	411408 <z_device_is_ready+0x1c>

0000000000411414 <z_log_msg_runtime_create.constprop.0>:
static inline void z_log_msg_runtime_create(uint8_t domain_id,
  411414:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  411418:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  41141c:	910003fd 	mov	x29, sp
  411420:	f9475c00 	ldr	x0, [x0, #3768]
  411424:	3d8023e0 	str	q0, [sp, #128]
  411428:	3d8027e1 	str	q1, [sp, #144]
  41142c:	3d802be2 	str	q2, [sp, #160]
  411430:	3d802fe3 	str	q3, [sp, #176]
  411434:	3d8033e4 	str	q4, [sp, #192]
  411438:	3d8037e5 	str	q5, [sp, #208]
  41143c:	3d803be6 	str	q6, [sp, #224]
  411440:	3d803fe7 	str	q7, [sp, #240]
  411444:	f90087e7 	str	x7, [sp, #264]
  411448:	f9400002 	ldr	x2, [x0]
  41144c:	f9003fe2 	str	x2, [sp, #120]
  411450:	d2800002 	mov	x2, #0x0                   	// #0
	va_start(ap, fmt);
  411454:	910443e0 	add	x0, sp, #0x110
  411458:	a90383e0 	stp	x0, x0, [sp, #56]
  41145c:	910403e0 	add	x0, sp, #0x100
  411460:	9100e3e2 	add	x2, sp, #0x38
  411464:	f90027e0 	str	x0, [sp, #72]
  411468:	128000e0 	mov	w0, #0xfffffff8            	// #-8
  41146c:	b90053e0 	str	w0, [sp, #80]
  411470:	12800fe0 	mov	w0, #0xffffff80            	// #-128
  411474:	b90057e0 	str	w0, [sp, #84]
	z_log_msg_runtime_vcreate(domain_id, source, level,
  411478:	910163e0 	add	x0, sp, #0x58
  41147c:	ad400440 	ldp	q0, q1, [x2]
  411480:	ad000400 	stp	q0, q1, [x0]
  411484:	ad400400 	ldp	q0, q1, [x0]
  411488:	910043e7 	add	x7, sp, #0x10
  41148c:	52800022 	mov	w2, #0x1                   	// #1
  411490:	52800000 	mov	w0, #0x0                   	// #0
  411494:	52800005 	mov	w5, #0x0                   	// #0
  411498:	d2800004 	mov	x4, #0x0                   	// #0
  41149c:	d2800003 	mov	x3, #0x0                   	// #0
  4114a0:	ad0004e0 	stp	q0, q1, [x7]
  4114a4:	97ffd841 	bl	4075a8 <z_impl_z_log_msg_runtime_vcreate>
}
  4114a8:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4114ac:	f9475c00 	ldr	x0, [x0, #3768]
  4114b0:	f9403fe2 	ldr	x2, [sp, #120]
  4114b4:	f9400001 	ldr	x1, [x0]
  4114b8:	eb010042 	subs	x2, x2, x1
  4114bc:	d2800001 	mov	x1, #0x0                   	// #0
  4114c0:	54000040 	b.eq	4114c8 <z_log_msg_runtime_create.constprop.0+0xb4>  // b.none
  4114c4:	97ffc017 	bl	401520 <__stack_chk_fail@plt>
  4114c8:	a8d17bfd 	ldp	x29, x30, [sp], #272
  4114cc:	d65f03c0 	ret

00000000004114d0 <coredump>:
#else

void coredump(unsigned int reason, const z_arch_esf_t *esf,
	      struct k_thread *thread)
{
}
  4114d0:	d65f03c0 	ret

00000000004114d4 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
  4114d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4114d8:	910003fd 	mov	x29, sp
  4114dc:	f9000bf3 	str	x19, [sp, #16]
  4114e0:	2a0003f3 	mov	w19, w0
  4114e4:	97ffd742 	bl	4071ec <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
  4114e8:	90000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4114ec:	b0000046 	adrp	x6, 41a000 <CSWTCH.25+0x22>
  4114f0:	910080c6 	add	x6, x6, #0x20
  4114f4:	52800005 	mov	w5, #0x0                   	// #0
  4114f8:	f946e421 	ldr	x1, [x1, #3528]
  4114fc:	d2800004 	mov	x4, #0x0                   	// #0
  411500:	d2800003 	mov	x3, #0x0                   	// #0
  411504:	52800022 	mov	w2, #0x1                   	// #1
  411508:	52800000 	mov	w0, #0x0                   	// #0
  41150c:	97ffffc2 	bl	411414 <z_log_msg_runtime_create.constprop.0>
	arch_system_halt(reason);
  411510:	2a1303e0 	mov	w0, w19
  411514:	97ffdabe 	bl	40800c <arch_system_halt>

0000000000411518 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
  411518:	d10143ff 	sub	sp, sp, #0x50
  41151c:	a9017bfd 	stp	x29, x30, [sp, #16]
  411520:	910043fd 	add	x29, sp, #0x10
  411524:	a90253f3 	stp	x19, x20, [sp, #32]
  411528:	2a0003f3 	mov	w19, w0
  41152c:	aa0103f4 	mov	x20, x1
  411530:	a9035bf5 	stp	x21, x22, [sp, #48]
  411534:	f90023f7 	str	x23, [sp, #64]
	return posix_irq_lock();
  411538:	97ffdf42 	bl	409240 <posix_irq_lock>
  41153c:	2a0003f5 	mov	w21, w0
	return z_impl_z_current_get();
  411540:	940013dd 	bl	4164b4 <z_impl_z_current_get>
  411544:	aa0003f6 	mov	x22, x0
	switch (reason) {
  411548:	7100127f 	cmp	w19, #0x4
  41154c:	54000848 	b.hi	411654 <z_fatal_error+0x13c>  // b.pmore
  411550:	d0000020 	adrp	x0, 417000 <z_abort_timeout+0x38>
  411554:	913c1000 	add	x0, x0, #0xf04
  411558:	38734800 	ldrb	w0, [x0, w19, uxtw]
  41155c:	10000061 	adr	x1, 411568 <z_fatal_error+0x50>
  411560:	8b208820 	add	x0, x1, w0, sxtb #2
  411564:	d61f0000 	br	x0
		return "Unhandled interrupt";
  411568:	b0000043 	adrp	x3, 41a000 <CSWTCH.25+0x22>
  41156c:	9100f463 	add	x3, x3, #0x3d
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
  411570:	90000117 	adrp	x23, 431000 <__FRAME_END__+0x10804>
  411574:	f90003e3 	str	x3, [sp]
  411578:	b9000bff 	str	wzr, [sp, #8]
  41157c:	b0000046 	adrp	x6, 41a000 <CSWTCH.25+0x22>
  411580:	f946e6e1 	ldr	x1, [x23, #3528]
  411584:	2a1303e7 	mov	w7, w19
  411588:	91023cc6 	add	x6, x6, #0x8f
  41158c:	52800005 	mov	w5, #0x0                   	// #0
  411590:	d2800004 	mov	x4, #0x0                   	// #0
  411594:	52800022 	mov	w2, #0x1                   	// #1
  411598:	52800000 	mov	w0, #0x0                   	// #0
  41159c:	d2800003 	mov	x3, #0x0                   	// #0
  4115a0:	97ffff9d 	bl	411414 <z_log_msg_runtime_create.constprop.0>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
  4115a4:	b40000d6 	cbz	x22, 4115bc <z_fatal_error+0xa4>
  4115a8:	aa1603e0 	mov	x0, x22
  4115ac:	940002d6 	bl	412104 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
  4115b0:	b4000060 	cbz	x0, 4115bc <z_fatal_error+0xa4>
  4115b4:	39400001 	ldrb	w1, [x0]
  4115b8:	35000061 	cbnz	w1, 4115c4 <z_fatal_error+0xac>
		thread_name = "unknown";
  4115bc:	b0000043 	adrp	x3, 41a000 <CSWTCH.25+0x22>
  4115c0:	91021c60 	add	x0, x3, #0x87
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
  4115c4:	f946e6e1 	ldr	x1, [x23, #3528]
  4115c8:	aa1603e7 	mov	x7, x22
  4115cc:	b0000046 	adrp	x6, 41a000 <CSWTCH.25+0x22>
  4115d0:	9102dcc6 	add	x6, x6, #0xb7
  4115d4:	f90003e0 	str	x0, [sp]
  4115d8:	52800005 	mov	w5, #0x0                   	// #0
  4115dc:	d2800004 	mov	x4, #0x0                   	// #0
  4115e0:	d2800003 	mov	x3, #0x0                   	// #0
  4115e4:	52800022 	mov	w2, #0x1                   	// #1
  4115e8:	52800000 	mov	w0, #0x0                   	// #0
  4115ec:	97ffff8a 	bl	411414 <z_log_msg_runtime_create.constprop.0>
		thread_name_get(thread));

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
  4115f0:	aa1603e2 	mov	x2, x22
  4115f4:	aa1403e1 	mov	x1, x20
  4115f8:	2a1303e0 	mov	w0, w19
  4115fc:	97ffffb5 	bl	4114d0 <coredump>
#endif

	k_sys_fatal_error_handler(reason, esf);
  411600:	aa1403e1 	mov	x1, x20
  411604:	2a1303e0 	mov	w0, w19
  411608:	97ffffb3 	bl	4114d4 <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
  41160c:	2a1503e0 	mov	w0, w21
  411610:	97ffdf0e 	bl	409248 <posix_irq_unlock>
	z_impl_k_thread_abort(thread);
  411614:	aa1603e0 	mov	x0, x22
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
  411618:	a9417bfd 	ldp	x29, x30, [sp, #16]
  41161c:	a94253f3 	ldp	x19, x20, [sp, #32]
  411620:	a9435bf5 	ldp	x21, x22, [sp, #48]
  411624:	f94023f7 	ldr	x23, [sp, #64]
  411628:	910143ff 	add	sp, sp, #0x50
  41162c:	17ffdbb2 	b	4084f4 <z_impl_k_thread_abort>
		return "Stack overflow";
  411630:	b0000043 	adrp	x3, 41a000 <CSWTCH.25+0x22>
  411634:	91014463 	add	x3, x3, #0x51
  411638:	17ffffce 	b	411570 <z_fatal_error+0x58>
		return "Kernel oops";
  41163c:	b0000043 	adrp	x3, 41a000 <CSWTCH.25+0x22>
  411640:	91018063 	add	x3, x3, #0x60
  411644:	17ffffcb 	b	411570 <z_fatal_error+0x58>
		return "Kernel panic";
  411648:	b0000043 	adrp	x3, 41a000 <CSWTCH.25+0x22>
  41164c:	9101b063 	add	x3, x3, #0x6c
  411650:	17ffffc8 	b	411570 <z_fatal_error+0x58>
		return "Unknown error";
  411654:	b0000043 	adrp	x3, 41a000 <CSWTCH.25+0x22>
  411658:	9101e463 	add	x3, x3, #0x79
  41165c:	17ffffc5 	b	411570 <z_fatal_error+0x58>
	switch (reason) {
  411660:	b0000043 	adrp	x3, 41a000 <CSWTCH.25+0x22>
  411664:	9100bc63 	add	x3, x3, #0x2f
  411668:	17ffffc2 	b	411570 <z_fatal_error+0x58>

000000000041166c <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
static void z_sys_init_run_level(enum init_level level)
{
  41166c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  411670:	90000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  411674:	91256021 	add	x1, x1, #0x958
{
  411678:	910003fd 	mov	x29, sp
  41167c:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  411680:	f8605833 	ldr	x19, [x1, w0, uxtw #3]
  411684:	11000400 	add	w0, w0, #0x1
{
  411688:	a9025bf5 	stp	x21, x22, [sp, #32]
						rc = -rc;
					}
					if (rc > UINT8_MAX) {
						rc = UINT8_MAX;
					}
					dev->state->init_res = rc;
  41168c:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  411690:	f8607835 	ldr	x21, [x1, x0, lsl #3]
  411694:	eb1302bf 	cmp	x21, x19
  411698:	540000a8 	b.hi	4116ac <z_sys_init_run_level+0x40>  // b.pmore
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
  41169c:	a94153f3 	ldp	x19, x20, [sp, #16]
  4116a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4116a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4116a8:	d65f03c0 	ret
		const struct device *dev = entry->dev;
  4116ac:	a9405261 	ldp	x1, x20, [x19]
		if (dev != NULL) {
  4116b0:	b4000234 	cbz	x20, 4116f4 <z_sys_init_run_level+0x88>
			if (entry->init_fn.dev != NULL) {
  4116b4:	b4000141 	cbz	x1, 4116dc <z_sys_init_run_level+0x70>
				rc = entry->init_fn.dev(dev);
  4116b8:	aa1403e0 	mov	x0, x20
  4116bc:	d63f0020 	blr	x1
				if (rc != 0) {
  4116c0:	7100001f 	cmp	w0, #0x0
  4116c4:	340000c0 	cbz	w0, 4116dc <z_sys_init_run_level+0x70>
					dev->state->init_res = rc;
  4116c8:	f9400e81 	ldr	x1, [x20, #24]
  4116cc:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
  4116d0:	7103fc1f 	cmp	w0, #0xff
  4116d4:	1a96d000 	csel	w0, w0, w22, le
  4116d8:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
  4116dc:	f9400e81 	ldr	x1, [x20, #24]
  4116e0:	39400420 	ldrb	w0, [x1, #1]
  4116e4:	32000000 	orr	w0, w0, #0x1
  4116e8:	39000420 	strb	w0, [x1, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
  4116ec:	91004273 	add	x19, x19, #0x10
  4116f0:	17ffffe9 	b	411694 <z_sys_init_run_level+0x28>
			(void)entry->init_fn.sys();
  4116f4:	d63f0020 	blr	x1
  4116f8:	17fffffd 	b	4116ec <z_sys_init_run_level+0x80>

00000000004116fc <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
  4116fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
  411700:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  411704:	52800021 	mov	w1, #0x1                   	// #1
{
  411708:	910003fd 	mov	x29, sp
	z_sys_post_kernel = true;
  41170c:	f946d400 	ldr	x0, [x0, #3496]
  411710:	39000001 	strb	w1, [x0]

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
  411714:	52800060 	mov	w0, #0x3                   	// #3
  411718:	97ffffd5 	bl	41166c <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
  41171c:	9400197c 	bl	417d0c <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
  411720:	52800080 	mov	w0, #0x4                   	// #4
  411724:	97ffffd2 	bl	41166c <z_sys_init_run_level>

	z_init_static_threads();
  411728:	9400030d 	bl	41235c <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
  41172c:	97ffe606 	bl	40af44 <_posix_zephyr_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
  411730:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  411734:	f947ec00 	ldr	x0, [x0, #4056]
  411738:	39406001 	ldrb	w1, [x0, #24]
  41173c:	121f7821 	and	w1, w1, #0xfffffffe
  411740:	39006001 	strb	w1, [x0, #24]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
  411744:	a8c17bfd 	ldp	x29, x30, [sp], #16
  411748:	d65f03c0 	ret

000000000041174c <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
  41174c:	d10143ff 	sub	sp, sp, #0x50
	z_setup_new_thread(thread, stack,
  411750:	52800504 	mov	w4, #0x28                  	// #40
  411754:	90000103 	adrp	x3, 431000 <__FRAME_END__+0x10804>
  411758:	528001e7 	mov	w7, #0xf                   	// #15
  41175c:	d2800006 	mov	x6, #0x0                   	// #0
  411760:	d2800005 	mov	x5, #0x0                   	// #0
{
  411764:	a9017bfd 	stp	x29, x30, [sp, #16]
  411768:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(thread, stack,
  41176c:	d2802002 	mov	x2, #0x100                 	// #256
  411770:	f9473863 	ldr	x3, [x3, #3696]
{
  411774:	a9035bf5 	stp	x21, x22, [sp, #48]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  411778:	90000116 	adrp	x22, 431000 <__FRAME_END__+0x10804>
{
  41177c:	f90023f7 	str	x23, [sp, #64]
	struct k_thread *thread = &z_idle_threads[i];
  411780:	90000117 	adrp	x23, 431000 <__FRAME_END__+0x10804>
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
  411784:	f94712d6 	ldr	x22, [x22, #3616]
{
  411788:	a90253f3 	stp	x19, x20, [sp, #32]
  41178c:	93407c13 	sxtw	x19, w0
	struct k_thread *thread = &z_idle_threads[i];
  411790:	f946e2f7 	ldr	x23, [x23, #3520]
  411794:	52801815 	mov	w21, #0xc0                  	// #192
	z_setup_new_thread(thread, stack,
  411798:	9b245a64 	smaddl	x4, w19, w4, x22
  41179c:	b0000040 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  4117a0:	91033c00 	add	x0, x0, #0xcf
  4117a4:	f90007e0 	str	x0, [sp, #8]
	struct k_thread *thread = &z_idle_threads[i];
  4117a8:	9b355e75 	smaddl	x21, w19, w21, x23
	z_setup_new_thread(thread, stack,
  4117ac:	52800020 	mov	w0, #0x1                   	// #1
  4117b0:	b90003e0 	str	w0, [sp]
	k_thread_stack_t *stack = z_idle_stacks[i];
  4117b4:	93787e61 	sbfiz	x1, x19, #8, #32
	z_setup_new_thread(thread, stack,
  4117b8:	d0000120 	adrp	x0, 437000 <_net_buf_isotp_rx_pool+0xb0>
  4117bc:	91274000 	add	x0, x0, #0x9d0
  4117c0:	8b010001 	add	x1, x0, x1
  4117c4:	aa1503e0 	mov	x0, x21
  4117c8:	94000259 	bl	41212c <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  4117cc:	d2801800 	mov	x0, #0xc0                  	// #192
  4117d0:	9b005e60 	madd	x0, x19, x0, x23
  4117d4:	39406401 	ldrb	w1, [x0, #25]
  4117d8:	121d7821 	and	w1, w1, #0xfffffffb
  4117dc:	39006401 	strb	w1, [x0, #25]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  4117e0:	d2800501 	mov	x1, #0x28                  	// #40
	_kernel.cpus[id].id = id;
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  4117e4:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  4117e8:	9b015a61 	madd	x1, x19, x1, x22
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  4117ec:	f946dc00 	ldr	x0, [x0, #3512]
	_kernel.cpus[id].id = id;
  4117f0:	39008033 	strb	w19, [x1, #32]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  4117f4:	91000673 	add	x19, x19, #0x1
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
  4117f8:	f9000c35 	str	x21, [x1, #24]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
  4117fc:	8b132c13 	add	x19, x0, x19, lsl #11
	_kernel.cpus[id].irq_stack =
  411800:	f9000433 	str	x19, [x1, #8]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
  411804:	90000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  411808:	d2800020 	mov	x0, #0x1                   	// #1
  41180c:	f9476c21 	ldr	x1, [x1, #3800]
  411810:	97ffc010 	bl	401850 <__aarch64_ldadd8_acq_rel>
	/*
	 * Increment number of CPUs active. The pm subsystem
	 * will keep track of this from here.
	 */
	atomic_inc(&_cpus_active);
}
  411814:	a9417bfd 	ldp	x29, x30, [sp, #16]
  411818:	a94253f3 	ldp	x19, x20, [sp, #32]
  41181c:	a9435bf5 	ldp	x21, x22, [sp, #48]
  411820:	f94023f7 	ldr	x23, [sp, #64]
  411824:	910143ff 	add	sp, sp, #0x50
  411828:	d65f03c0 	ret

000000000041182c <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
  41182c:	d10403ff 	sub	sp, sp, #0x100
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  411830:	52800000 	mov	w0, #0x0                   	// #0
{
  411834:	a9017bfd 	stp	x29, x30, [sp, #16]
  411838:	910043fd 	add	x29, sp, #0x10
  41183c:	a90253f3 	stp	x19, x20, [sp, #32]

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
  411840:	90000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
	_kernel.ready_q.cache = &z_main_thread;
  411844:	90000113 	adrp	x19, 431000 <__FRAME_END__+0x10804>
{
  411848:	f9001bf5 	str	x21, [sp, #48]
	z_sys_init_run_level(INIT_LEVEL_EARLY);
  41184c:	97ffff88 	bl	41166c <z_sys_init_run_level>

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
  411850:	97ffd65c 	bl	4071c0 <log_core_init>
	dummy_thread->resource_pool = NULL;
  411854:	f9007bff 	str	xzr, [sp, #240]
	_current_cpu->current = dummy_thread;
  411858:	f9471294 	ldr	x20, [x20, #3616]
	dummy_thread->base.user_options = K_ESSENTIAL;
  41185c:	52802020 	mov	w0, #0x101                 	// #257
  411860:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
  411864:	910103e0 	add	x0, sp, #0x40
  411868:	f9000a80 	str	x0, [x20, #16]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
  41186c:	97fffebf 	bl	411368 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
  411870:	52800020 	mov	w0, #0x1                   	// #1
  411874:	97ffff7e 	bl	41166c <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
  411878:	52800040 	mov	w0, #0x2                   	// #2
  41187c:	97ffff7c 	bl	41166c <z_sys_init_run_level>
	z_sched_init();
  411880:	940011ca 	bl	415fa8 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  411884:	90000101 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  411888:	b0000040 	adrp	x0, 41a000 <CSWTCH.25+0x22>
	_kernel.ready_q.cache = &z_main_thread;
  41188c:	f947ee73 	ldr	x19, [x19, #4056]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  411890:	91035000 	add	x0, x0, #0xd4
  411894:	f9477421 	ldr	x1, [x1, #3816]
	_kernel.ready_q.cache = &z_main_thread;
  411898:	f9001693 	str	x19, [x20, #40]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
  41189c:	f90007e0 	str	x0, [sp, #8]
  4118a0:	52800020 	mov	w0, #0x1                   	// #1
  4118a4:	b90003e0 	str	w0, [sp]
  4118a8:	90000014 	adrp	x20, 411000 <list_map_start_encode+0x1c>
  4118ac:	911bf294 	add	x20, x20, #0x6fc
  4118b0:	52800007 	mov	w7, #0x0                   	// #0
  4118b4:	aa1403e3 	mov	x3, x20
  4118b8:	d2800006 	mov	x6, #0x0                   	// #0
  4118bc:	d2800005 	mov	x5, #0x0                   	// #0
  4118c0:	d2800004 	mov	x4, #0x0                   	// #0
  4118c4:	d2804002 	mov	x2, #0x200                 	// #512
  4118c8:	aa1303e0 	mov	x0, x19
  4118cc:	94000218 	bl	41212c <z_setup_new_thread>
  4118d0:	aa0003f5 	mov	x21, x0
  4118d4:	39406660 	ldrb	w0, [x19, #25]
  4118d8:	121d7800 	and	w0, w0, #0xfffffffb
  4118dc:	39006660 	strb	w0, [x19, #25]
	z_ready_thread(&z_main_thread);
  4118e0:	aa1303e0 	mov	x0, x19
  4118e4:	94000e01 	bl	4150e8 <z_ready_thread>
	z_init_cpu(0);
  4118e8:	52800000 	mov	w0, #0x0                   	// #0
  4118ec:	97ffff98 	bl	41174c <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
  4118f0:	aa1403e2 	mov	x2, x20
  4118f4:	aa1503e1 	mov	x1, x21
  4118f8:	aa1303e0 	mov	x0, x19
  4118fc:	97ffdb3f 	bl	4085f8 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
  411900:	b0000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  411904:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411908:	91036421 	add	x1, x1, #0xd9
  41190c:	91187800 	add	x0, x0, #0x61e
  411910:	52803a82 	mov	w2, #0x1d4                 	// #468
  411914:	97ffdf61 	bl	409698 <posix_print_error_and_exit>

0000000000411918 <k_heap_init>:
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
  411918:	91006004 	add	x4, x0, #0x18
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
  41191c:	a9019004 	stp	x4, x4, [x0, #24]
#include <zephyr/sys/iterable_sections.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
  411920:	17ffd159 	b	405e84 <sys_heap_init>

0000000000411924 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
  411924:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  411928:	910003fd 	mov	x29, sp
  41192c:	a90153f3 	stp	x19, x20, [sp, #16]
	STRUCT_SECTION_FOREACH(k_heap, h) {
  411930:	90000113 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  411934:	90000114 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  411938:	f9473273 	ldr	x19, [x19, #3680]
  41193c:	f9471694 	ldr	x20, [x20, #3624]
  411940:	eb14027f 	cmp	x19, x20
  411944:	54000349 	b.ls	4119ac <statics_init+0x88>  // b.plast
  411948:	b0000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  41194c:	9103f673 	add	x19, x19, #0xfd
  411950:	aa1303e2 	mov	x2, x19
  411954:	b0000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  411958:	91047c21 	add	x1, x1, #0x11f
  41195c:	52800303 	mov	w3, #0x18                  	// #24
  411960:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411964:	91178000 	add	x0, x0, #0x5e0
  411968:	97ffd530 	bl	406e28 <assert_print>
  41196c:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411970:	91248400 	add	x0, x0, #0x921
  411974:	97ffd52d 	bl	406e28 <assert_print>
  411978:	aa1303e0 	mov	x0, x19
  41197c:	52800301 	mov	w1, #0x18                  	// #24
  411980:	97ffd554 	bl	406ed0 <assert_post_action>
  411984:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411988:	aa1303e1 	mov	x1, x19
  41198c:	91187800 	add	x0, x0, #0x61e
  411990:	52800302 	mov	w2, #0x18                  	// #24
  411994:	97ffdf41 	bl	409698 <posix_print_error_and_exit>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  411998:	a9408a61 	ldp	x1, x2, [x19, #8]
  41199c:	aa1303e0 	mov	x0, x19
	STRUCT_SECTION_FOREACH(k_heap, h) {
  4119a0:	9100c273 	add	x19, x19, #0x30
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
  4119a4:	97ffffdd 	bl	411918 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
  4119a8:	17ffffe6 	b	411940 <statics_init+0x1c>
  4119ac:	54ffff63 	b.cc	411998 <statics_init+0x74>  // b.lo, b.ul, b.last
		}
	}
	return 0;
}
  4119b0:	52800000 	mov	w0, #0x0                   	// #0
  4119b4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4119b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4119bc:	d65f03c0 	ret

00000000004119c0 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
  4119c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4119c4:	910003fd 	mov	x29, sp
  4119c8:	a90153f3 	stp	x19, x20, [sp, #16]
  4119cc:	a9025bf5 	stp	x21, x22, [sp, #32]
  4119d0:	aa0303f6 	mov	x22, x3
  4119d4:	aa0003f5 	mov	x21, x0
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  4119d8:	aa0303e0 	mov	x0, x3
{
  4119dc:	a90363f7 	stp	x23, x24, [sp, #48]
  4119e0:	aa0103f7 	mov	x23, x1
  4119e4:	aa0203f8 	mov	x24, x2
  4119e8:	a9046bf9 	stp	x25, x26, [sp, #64]
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
  4119ec:	94001687 	bl	417408 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  4119f0:	b10006df 	cmn	x22, #0x1
  4119f4:	92f00001 	mov	x1, #0x7fffffffffffffff    	// #9223372036854775807

	k_spinlock_key_t key = k_spin_lock(&h->lock);
  4119f8:	9100a2b3 	add	x19, x21, #0x28
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
  4119fc:	9a811019 	csel	x25, x0, x1, ne  // ne = any
	return posix_irq_lock();
  411a00:	97ffde10 	bl	409240 <posix_irq_lock>
  411a04:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411a08:	aa1303e0 	mov	x0, x19
  411a0c:	940002b4 	bl	4124dc <z_spin_lock_valid>
  411a10:	72001c1f 	tst	w0, #0xff
  411a14:	54000281 	b.ne	411a64 <k_heap_aligned_alloc+0xa4>  // b.any
  411a18:	90000054 	adrp	x20, 419000 <__func__.2+0xa80>
  411a1c:	912c1294 	add	x20, x20, #0xb04
  411a20:	aa1403e2 	mov	x2, x20
  411a24:	52801283 	mov	w3, #0x94                  	// #148
  411a28:	90000041 	adrp	x1, 419000 <__func__.2+0xa80>
  411a2c:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411a30:	912cc421 	add	x1, x1, #0xb31
  411a34:	91178000 	add	x0, x0, #0x5e0
  411a38:	97ffd4fc 	bl	406e28 <assert_print>
  411a3c:	aa1303e1 	mov	x1, x19
  411a40:	90000040 	adrp	x0, 419000 <__func__.2+0xa80>
  411a44:	912d1800 	add	x0, x0, #0xb46
  411a48:	97ffd4f8 	bl	406e28 <assert_print>
  411a4c:	aa1403e0 	mov	x0, x20
  411a50:	52801281 	mov	w1, #0x94                  	// #148
  411a54:	97ffd51f 	bl	406ed0 <assert_post_action>
  411a58:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411a5c:	aa1403e1 	mov	x1, x20
  411a60:	14000019 	b	411ac4 <k_heap_aligned_alloc+0x104>
	z_spin_lock_set_owner(l);
  411a64:	aa1303e0 	mov	x0, x19
  411a68:	940002b5 	bl	41253c <z_spin_lock_set_owner>
}
#endif

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
  411a6c:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  411a70:	f9471000 	ldr	x0, [x0, #3616]

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  411a74:	b9400000 	ldr	w0, [x0]
  411a78:	34000860 	cbz	w0, 411b84 <k_heap_aligned_alloc+0x1c4>
  411a7c:	b4000856 	cbz	x22, 411b84 <k_heap_aligned_alloc+0x1c4>
  411a80:	b0000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  411a84:	9103f673 	add	x19, x19, #0xfd
  411a88:	aa1303e2 	mov	x2, x19
  411a8c:	b0000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  411a90:	9104d421 	add	x1, x1, #0x135
  411a94:	52800983 	mov	w3, #0x4c                  	// #76
  411a98:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411a9c:	91178000 	add	x0, x0, #0x5e0
  411aa0:	97ffd4e2 	bl	406e28 <assert_print>
  411aa4:	90000040 	adrp	x0, 419000 <__func__.2+0xa80>
  411aa8:	912e6c00 	add	x0, x0, #0xb9b
  411aac:	97ffd4df 	bl	406e28 <assert_print>
  411ab0:	52800981 	mov	w1, #0x4c                  	// #76
  411ab4:	aa1303e0 	mov	x0, x19
  411ab8:	97ffd506 	bl	406ed0 <assert_post_action>
  411abc:	aa1303e1 	mov	x1, x19
  411ac0:	52800982 	mov	w2, #0x4c                  	// #76
  411ac4:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411ac8:	91187800 	add	x0, x0, #0x61e
  411acc:	97ffdef3 	bl	409698 <posix_print_error_and_exit>
	while (ret == NULL) {
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);

		now = sys_clock_tick_get();
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
		    (ret != NULL) || ((end - now) <= 0)) {
  411ad0:	cb030323 	sub	x3, x25, x3
  411ad4:	f100007f 	cmp	x3, #0x0
  411ad8:	540002ad 	b.le	411b2c <k_heap_aligned_alloc+0x16c>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  411adc:	2a1403e1 	mov	w1, w20
  411ae0:	aa1a03e2 	mov	x2, x26
  411ae4:	aa1303e0 	mov	x0, x19
  411ae8:	94000ec9 	bl	41560c <z_pend_curr>
  411aec:	97ffddd5 	bl	409240 <posix_irq_lock>
  411af0:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411af4:	aa1303e0 	mov	x0, x19
  411af8:	94000279 	bl	4124dc <z_spin_lock_valid>
  411afc:	72001c1f 	tst	w0, #0xff
  411b00:	54fff8c0 	b.eq	411a18 <k_heap_aligned_alloc+0x58>  // b.none
	z_spin_lock_set_owner(l);
  411b04:	aa1303e0 	mov	x0, x19
  411b08:	9400028d 	bl	41253c <z_spin_lock_set_owner>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
  411b0c:	aa1803e2 	mov	x2, x24
  411b10:	aa1703e1 	mov	x1, x23
  411b14:	aa1503e0 	mov	x0, x21
  411b18:	97ffd072 	bl	405ce0 <sys_heap_aligned_alloc>
  411b1c:	aa0003f6 	mov	x22, x0
		now = sys_clock_tick_get();
  411b20:	940015f0 	bl	4172e0 <sys_clock_tick_get>
  411b24:	aa0003e3 	mov	x3, x0
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
  411b28:	b4fffd56 	cbz	x22, 411ad0 <k_heap_aligned_alloc+0x110>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411b2c:	aa1303e0 	mov	x0, x19
  411b30:	94000276 	bl	412508 <z_spin_unlock_valid>
  411b34:	72001c1f 	tst	w0, #0xff
  411b38:	540002a1 	b.ne	411b8c <k_heap_aligned_alloc+0x1cc>  // b.any
  411b3c:	90000054 	adrp	x20, 419000 <__func__.2+0xa80>
  411b40:	912c1294 	add	x20, x20, #0xb04
  411b44:	aa1403e2 	mov	x2, x20
  411b48:	52801863 	mov	w3, #0xc3                  	// #195
  411b4c:	90000041 	adrp	x1, 419000 <__func__.2+0xa80>
  411b50:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411b54:	912d7821 	add	x1, x1, #0xb5e
  411b58:	91178000 	add	x0, x0, #0x5e0
  411b5c:	97ffd4b3 	bl	406e28 <assert_print>
  411b60:	aa1303e1 	mov	x1, x19
  411b64:	90000040 	adrp	x0, 419000 <__func__.2+0xa80>
  411b68:	912dd400 	add	x0, x0, #0xb75
  411b6c:	97ffd4af 	bl	406e28 <assert_print>
  411b70:	aa1403e0 	mov	x0, x20
  411b74:	52801861 	mov	w1, #0xc3                  	// #195
  411b78:	97ffd4d6 	bl	406ed0 <assert_post_action>
  411b7c:	52801862 	mov	w2, #0xc3                  	// #195
  411b80:	17ffffb7 	b	411a5c <k_heap_aligned_alloc+0x9c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
  411b84:	910062ba 	add	x26, x21, #0x18
  411b88:	17ffffe1 	b	411b0c <k_heap_aligned_alloc+0x14c>
	posix_irq_unlock(key);
  411b8c:	2a1403e0 	mov	w0, w20
  411b90:	97ffddae 	bl	409248 <posix_irq_unlock>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
  411b94:	aa1603e0 	mov	x0, x22
  411b98:	a94153f3 	ldp	x19, x20, [sp, #16]
  411b9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411ba0:	a94363f7 	ldp	x23, x24, [sp, #48]
  411ba4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  411ba8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  411bac:	d65f03c0 	ret

0000000000411bb0 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
  411bb0:	aa0203e3 	mov	x3, x2
  411bb4:	aa0103e2 	mov	x2, x1
  411bb8:	d2800101 	mov	x1, #0x8                   	// #8
  411bbc:	17ffff81 	b	4119c0 <k_heap_aligned_alloc>

0000000000411bc0 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
  411bc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411bc4:	910003fd 	mov	x29, sp
  411bc8:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&h->lock);
  411bcc:	9100a013 	add	x19, x0, #0x28
{
  411bd0:	aa0003f4 	mov	x20, x0
  411bd4:	a9025bf5 	stp	x21, x22, [sp, #32]
  411bd8:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  411bdc:	97ffdd99 	bl	409240 <posix_irq_lock>
  411be0:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411be4:	aa1303e0 	mov	x0, x19
  411be8:	9400023d 	bl	4124dc <z_spin_lock_valid>
  411bec:	72001c1f 	tst	w0, #0xff
  411bf0:	540002c1 	b.ne	411c48 <k_heap_free+0x88>  // b.any
  411bf4:	90000054 	adrp	x20, 419000 <__func__.2+0xa80>
  411bf8:	912c1294 	add	x20, x20, #0xb04
  411bfc:	aa1403e2 	mov	x2, x20
  411c00:	52801283 	mov	w3, #0x94                  	// #148
  411c04:	90000041 	adrp	x1, 419000 <__func__.2+0xa80>
  411c08:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411c0c:	912cc421 	add	x1, x1, #0xb31
  411c10:	91178000 	add	x0, x0, #0x5e0
  411c14:	97ffd485 	bl	406e28 <assert_print>
  411c18:	aa1303e1 	mov	x1, x19
  411c1c:	90000040 	adrp	x0, 419000 <__func__.2+0xa80>
  411c20:	912d1800 	add	x0, x0, #0xb46
  411c24:	97ffd481 	bl	406e28 <assert_print>
  411c28:	aa1403e0 	mov	x0, x20
  411c2c:	52801281 	mov	w1, #0x94                  	// #148
  411c30:	97ffd4a8 	bl	406ed0 <assert_post_action>
  411c34:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411c38:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411c3c:	aa1403e1 	mov	x1, x20
  411c40:	91187800 	add	x0, x0, #0x61e
  411c44:	97ffde95 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411c48:	aa1303e0 	mov	x0, x19
  411c4c:	9400023c 	bl	41253c <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
  411c50:	aa1603e1 	mov	x1, x22
  411c54:	aa1403e0 	mov	x0, x20
  411c58:	97ffcfb1 	bl	405b1c <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
  411c5c:	91006280 	add	x0, x20, #0x18
  411c60:	940010bd 	bl	415f54 <z_unpend_all>
  411c64:	340000e0 	cbz	w0, 411c80 <k_heap_free+0xc0>
		z_reschedule(&h->lock, key);
  411c68:	2a1503e1 	mov	w1, w21
  411c6c:	aa1303e0 	mov	x0, x19
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
  411c70:	a94153f3 	ldp	x19, x20, [sp, #16]
  411c74:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411c78:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&h->lock, key);
  411c7c:	14000ac0 	b	41477c <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411c80:	aa1303e0 	mov	x0, x19
  411c84:	94000221 	bl	412508 <z_spin_unlock_valid>
  411c88:	72001c1f 	tst	w0, #0xff
  411c8c:	54000261 	b.ne	411cd8 <k_heap_free+0x118>  // b.any
  411c90:	90000054 	adrp	x20, 419000 <__func__.2+0xa80>
  411c94:	912c1294 	add	x20, x20, #0xb04
  411c98:	aa1403e2 	mov	x2, x20
  411c9c:	52801863 	mov	w3, #0xc3                  	// #195
  411ca0:	90000041 	adrp	x1, 419000 <__func__.2+0xa80>
  411ca4:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411ca8:	912d7821 	add	x1, x1, #0xb5e
  411cac:	91178000 	add	x0, x0, #0x5e0
  411cb0:	97ffd45e 	bl	406e28 <assert_print>
  411cb4:	aa1303e1 	mov	x1, x19
  411cb8:	90000040 	adrp	x0, 419000 <__func__.2+0xa80>
  411cbc:	912dd400 	add	x0, x0, #0xb75
  411cc0:	97ffd45a 	bl	406e28 <assert_print>
  411cc4:	aa1403e0 	mov	x0, x20
  411cc8:	52801861 	mov	w1, #0xc3                  	// #195
  411ccc:	97ffd481 	bl	406ed0 <assert_post_action>
  411cd0:	52801862 	mov	w2, #0xc3                  	// #195
  411cd4:	17ffffd9 	b	411c38 <k_heap_free+0x78>
	posix_irq_unlock(key);
  411cd8:	2a1503e0 	mov	w0, w21
}
  411cdc:	a94153f3 	ldp	x19, x20, [sp, #16]
  411ce0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411ce4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  411ce8:	17ffdd58 	b	409248 <posix_irq_unlock>

0000000000411cec <create_free_list>:
{
	uint32_t j;
	char *p;

	/* blocks must be word aligned */
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
  411cec:	a9420402 	ldp	x2, x1, [x0, #32]
  411cf0:	aa020022 	orr	x2, x1, x2
  411cf4:	f240085f 	tst	x2, #0x7
  411cf8:	540001e1 	b.ne	411d34 <create_free_list+0x48>  // b.any
	}

	slab->free_list = NULL;
	p = slab->buffer;

	for (j = 0U; j < slab->num_blocks; j++) {
  411cfc:	52800002 	mov	w2, #0x0                   	// #0
	slab->free_list = NULL;
  411d00:	f900181f 	str	xzr, [x0, #48]
	for (j = 0U; j < slab->num_blocks; j++) {
  411d04:	b9401803 	ldr	w3, [x0, #24]
  411d08:	6b02007f 	cmp	w3, w2
  411d0c:	54000068 	b.hi	411d18 <create_free_list+0x2c>  // b.pmore
		*(char **)p = slab->free_list;
		slab->free_list = p;
		p += slab->block_size;
	}
	return 0;
  411d10:	52800000 	mov	w0, #0x0                   	// #0
}
  411d14:	d65f03c0 	ret
		*(char **)p = slab->free_list;
  411d18:	f9401803 	ldr	x3, [x0, #48]
  411d1c:	f9000023 	str	x3, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
  411d20:	11000442 	add	w2, w2, #0x1
		slab->free_list = p;
  411d24:	f9001801 	str	x1, [x0, #48]
		p += slab->block_size;
  411d28:	f9401003 	ldr	x3, [x0, #32]
  411d2c:	8b030021 	add	x1, x1, x3
	for (j = 0U; j < slab->num_blocks; j++) {
  411d30:	17fffff5 	b	411d04 <create_free_list+0x18>
		return -EINVAL;
  411d34:	128002a0 	mov	w0, #0xffffffea            	// #-22
  411d38:	17fffff7 	b	411d14 <create_free_list+0x28>

0000000000411d3c <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
  411d3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int rc = 0;

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  411d40:	90000104 	adrp	x4, 431000 <__FRAME_END__+0x10804>
  411d44:	90000105 	adrp	x5, 431000 <__FRAME_END__+0x10804>
{
  411d48:	910003fd 	mov	x29, sp
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  411d4c:	f947e884 	ldr	x4, [x4, #4048]
	int rc = 0;
  411d50:	52800000 	mov	w0, #0x0                   	// #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  411d54:	f946d8a5 	ldr	x5, [x5, #3504]
{
  411d58:	f9000bf3 	str	x19, [sp, #16]
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  411d5c:	eb05009f 	cmp	x4, x5
  411d60:	54000349 	b.ls	411dc8 <init_mem_slab_module+0x8c>  // b.plast
  411d64:	b0000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  411d68:	9105ee73 	add	x19, x19, #0x17b
  411d6c:	aa1303e2 	mov	x2, x19
  411d70:	b0000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  411d74:	91068021 	add	x1, x1, #0x1a0
  411d78:	528007a3 	mov	w3, #0x3d                  	// #61
  411d7c:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411d80:	91178000 	add	x0, x0, #0x5e0
  411d84:	97ffd429 	bl	406e28 <assert_print>
  411d88:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411d8c:	91248400 	add	x0, x0, #0x921
  411d90:	97ffd426 	bl	406e28 <assert_print>
  411d94:	aa1303e0 	mov	x0, x19
  411d98:	528007a1 	mov	w1, #0x3d                  	// #61
  411d9c:	97ffd44d 	bl	406ed0 <assert_post_action>
  411da0:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411da4:	aa1303e1 	mov	x1, x19
  411da8:	91187800 	add	x0, x0, #0x61e
  411dac:	528007a2 	mov	w2, #0x3d                  	// #61
  411db0:	97ffde3a 	bl	409698 <posix_print_error_and_exit>
		rc = create_free_list(slab);
  411db4:	aa0403e0 	mov	x0, x4
  411db8:	97ffffcd 	bl	411cec <create_free_list>
		if (rc < 0) {
  411dbc:	37f80080 	tbnz	w0, #31, 411dcc <init_mem_slab_module+0x90>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
  411dc0:	91010084 	add	x4, x4, #0x40
  411dc4:	17ffffe6 	b	411d5c <init_mem_slab_module+0x20>
  411dc8:	54ffff63 	b.cc	411db4 <init_mem_slab_module+0x78>  // b.lo, b.ul, b.last
		z_object_init(slab);
	}

out:
	return rc;
}
  411dcc:	f9400bf3 	ldr	x19, [sp, #16]
  411dd0:	a8c27bfd 	ldp	x29, x30, [sp], #32
  411dd4:	d65f03c0 	ret

0000000000411dd8 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
  411dd8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  411ddc:	910003fd 	mov	x29, sp
  411de0:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  411de4:	91004014 	add	x20, x0, #0x10
{
  411de8:	aa0003f3 	mov	x19, x0
  411dec:	a9025bf5 	stp	x21, x22, [sp, #32]
  411df0:	aa0103f5 	mov	x21, x1
  411df4:	f9001bf7 	str	x23, [sp, #48]
  411df8:	aa0203f7 	mov	x23, x2
	return posix_irq_lock();
  411dfc:	97ffdd11 	bl	409240 <posix_irq_lock>
  411e00:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411e04:	aa1403e0 	mov	x0, x20
  411e08:	940001b5 	bl	4124dc <z_spin_lock_valid>
  411e0c:	72001c1f 	tst	w0, #0xff
  411e10:	540002c1 	b.ne	411e68 <k_mem_slab_alloc+0x90>  // b.any
  411e14:	90000053 	adrp	x19, 419000 <__func__.2+0xa80>
  411e18:	912c1273 	add	x19, x19, #0xb04
  411e1c:	aa1303e2 	mov	x2, x19
  411e20:	52801283 	mov	w3, #0x94                  	// #148
  411e24:	90000041 	adrp	x1, 419000 <__func__.2+0xa80>
  411e28:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411e2c:	912cc421 	add	x1, x1, #0xb31
  411e30:	91178000 	add	x0, x0, #0x5e0
  411e34:	97ffd3fd 	bl	406e28 <assert_print>
  411e38:	aa1403e1 	mov	x1, x20
  411e3c:	90000040 	adrp	x0, 419000 <__func__.2+0xa80>
  411e40:	912d1800 	add	x0, x0, #0xb46
  411e44:	97ffd3f9 	bl	406e28 <assert_print>
  411e48:	aa1303e0 	mov	x0, x19
  411e4c:	52801281 	mov	w1, #0x94                  	// #148
  411e50:	97ffd420 	bl	406ed0 <assert_post_action>
  411e54:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411e58:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411e5c:	aa1303e1 	mov	x1, x19
  411e60:	91187800 	add	x0, x0, #0x61e
  411e64:	97ffde0d 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411e68:	aa1403e0 	mov	x0, x20
  411e6c:	940001b4 	bl	41253c <z_spin_lock_set_owner>
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
  411e70:	f9401a60 	ldr	x0, [x19, #48]
  411e74:	b40003c0 	cbz	x0, 411eec <k_mem_slab_alloc+0x114>
		/* take a free block */
		*mem = slab->free_list;
  411e78:	f90002a0 	str	x0, [x21]
		slab->free_list = *(char **)(slab->free_list);
  411e7c:	f9400000 	ldr	x0, [x0]
  411e80:	f9001a60 	str	x0, [x19, #48]
		slab->num_used++;
  411e84:	b9403a60 	ldr	w0, [x19, #56]
  411e88:	11000400 	add	w0, w0, #0x1
  411e8c:	b9003a60 	str	w0, [x19, #56]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
  411e90:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411e94:	aa1403e0 	mov	x0, x20
  411e98:	9400019c 	bl	412508 <z_spin_unlock_valid>
  411e9c:	72001c1f 	tst	w0, #0xff
  411ea0:	54000521 	b.ne	411f44 <k_mem_slab_alloc+0x16c>  // b.any
  411ea4:	90000053 	adrp	x19, 419000 <__func__.2+0xa80>
  411ea8:	912c1273 	add	x19, x19, #0xb04
  411eac:	aa1303e2 	mov	x2, x19
  411eb0:	52801863 	mov	w3, #0xc3                  	// #195
  411eb4:	90000041 	adrp	x1, 419000 <__func__.2+0xa80>
  411eb8:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411ebc:	912d7821 	add	x1, x1, #0xb5e
  411ec0:	91178000 	add	x0, x0, #0x5e0
  411ec4:	97ffd3d9 	bl	406e28 <assert_print>
  411ec8:	aa1403e1 	mov	x1, x20
  411ecc:	90000040 	adrp	x0, 419000 <__func__.2+0xa80>
  411ed0:	912dd400 	add	x0, x0, #0xb75
  411ed4:	97ffd3d5 	bl	406e28 <assert_print>
  411ed8:	aa1303e0 	mov	x0, x19
  411edc:	52801861 	mov	w1, #0xc3                  	// #195
  411ee0:	97ffd3fc 	bl	406ed0 <assert_post_action>
  411ee4:	52801862 	mov	w2, #0xc3                  	// #195
  411ee8:	17ffffdc 	b	411e58 <k_mem_slab_alloc+0x80>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
  411eec:	b5000097 	cbnz	x23, 411efc <k_mem_slab_alloc+0x124>
		   !IS_ENABLED(CONFIG_MULTITHREADING)) {
		/* don't wait for a free block to become available */
		*mem = NULL;
		result = -ENOMEM;
  411ef0:	12800173 	mov	w19, #0xfffffff4            	// #-12
		*mem = NULL;
  411ef4:	f90002bf 	str	xzr, [x21]
		result = -ENOMEM;
  411ef8:	17ffffe7 	b	411e94 <k_mem_slab_alloc+0xbc>
	} else {
		SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_mem_slab, alloc, slab, timeout);

		/* wait for a free block or timeout */
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
  411efc:	aa1303e2 	mov	x2, x19
  411f00:	aa1703e3 	mov	x3, x23
  411f04:	2a1603e1 	mov	w1, w22
  411f08:	aa1403e0 	mov	x0, x20
  411f0c:	94000dc0 	bl	41560c <z_pend_curr>
  411f10:	2a0003f3 	mov	w19, w0
		if (result == 0) {
  411f14:	350000c0 	cbnz	w0, 411f2c <k_mem_slab_alloc+0x154>
			*mem = _current->base.swap_data;
  411f18:	90000100 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  411f1c:	f9471000 	ldr	x0, [x0, #3616]
  411f20:	f9400800 	ldr	x0, [x0, #16]
  411f24:	f9401000 	ldr	x0, [x0, #32]
  411f28:	f90002a0 	str	x0, [x21]
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
  411f2c:	2a1303e0 	mov	w0, w19
  411f30:	a94153f3 	ldp	x19, x20, [sp, #16]
  411f34:	a9425bf5 	ldp	x21, x22, [sp, #32]
  411f38:	f9401bf7 	ldr	x23, [sp, #48]
  411f3c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  411f40:	d65f03c0 	ret
	posix_irq_unlock(key);
  411f44:	2a1603e0 	mov	w0, w22
  411f48:	97ffdcc0 	bl	409248 <posix_irq_unlock>
	return result;
  411f4c:	17fffff8 	b	411f2c <k_mem_slab_alloc+0x154>

0000000000411f50 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
  411f50:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  411f54:	910003fd 	mov	x29, sp
  411f58:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
  411f5c:	91004014 	add	x20, x0, #0x10
{
  411f60:	aa0003f3 	mov	x19, x0
  411f64:	a9025bf5 	stp	x21, x22, [sp, #32]
  411f68:	aa0103f5 	mov	x21, x1
	return posix_irq_lock();
  411f6c:	97ffdcb5 	bl	409240 <posix_irq_lock>
  411f70:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  411f74:	aa1403e0 	mov	x0, x20
  411f78:	94000159 	bl	4124dc <z_spin_lock_valid>
  411f7c:	72001c1f 	tst	w0, #0xff
  411f80:	540002c1 	b.ne	411fd8 <k_mem_slab_free+0x88>  // b.any
  411f84:	90000053 	adrp	x19, 419000 <__func__.2+0xa80>
  411f88:	912c1273 	add	x19, x19, #0xb04
  411f8c:	aa1303e2 	mov	x2, x19
  411f90:	52801283 	mov	w3, #0x94                  	// #148
  411f94:	90000041 	adrp	x1, 419000 <__func__.2+0xa80>
  411f98:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411f9c:	912cc421 	add	x1, x1, #0xb31
  411fa0:	91178000 	add	x0, x0, #0x5e0
  411fa4:	97ffd3a1 	bl	406e28 <assert_print>
  411fa8:	aa1403e1 	mov	x1, x20
  411fac:	90000040 	adrp	x0, 419000 <__func__.2+0xa80>
  411fb0:	912d1800 	add	x0, x0, #0xb46
  411fb4:	97ffd39d 	bl	406e28 <assert_print>
  411fb8:	aa1303e0 	mov	x0, x19
  411fbc:	52801281 	mov	w1, #0x94                  	// #148
  411fc0:	97ffd3c4 	bl	406ed0 <assert_post_action>
  411fc4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  411fc8:	f0000020 	adrp	x0, 418000 <table.0+0x1d8>
  411fcc:	aa1303e1 	mov	x1, x19
  411fd0:	91187800 	add	x0, x0, #0x61e
  411fd4:	97ffddb1 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  411fd8:	aa1403e0 	mov	x0, x20
  411fdc:	94000158 	bl	41253c <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
  411fe0:	f9401a60 	ldr	x0, [x19, #48]
  411fe4:	b50001c0 	cbnz	x0, 41201c <k_mem_slab_free+0xcc>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
  411fe8:	aa1303e0 	mov	x0, x19
  411fec:	94000f90 	bl	415e2c <z_unpend_first_thread>

		if (pending_thread != NULL) {
  411ff0:	b4000160 	cbz	x0, 41201c <k_mem_slab_free+0xcc>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
  411ff4:	f94002a1 	ldr	x1, [x21]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
  411ff8:	f9001001 	str	x1, [x0, #32]
	thread->callee_saved.retval = value;
  411ffc:	b9004c1f 	str	wzr, [x0, #76]
			z_ready_thread(pending_thread);
  412000:	94000c3a 	bl	4150e8 <z_ready_thread>
			z_reschedule(&slab->lock, key);
  412004:	2a1603e1 	mov	w1, w22
  412008:	aa1403e0 	mov	x0, x20
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
  41200c:	a94153f3 	ldp	x19, x20, [sp, #16]
  412010:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412014:	a8c37bfd 	ldp	x29, x30, [sp], #48
			z_reschedule(&slab->lock, key);
  412018:	140009d9 	b	41477c <z_reschedule>
	**(char ***) mem = slab->free_list;
  41201c:	f94002a0 	ldr	x0, [x21]
  412020:	f9401a61 	ldr	x1, [x19, #48]
  412024:	f9000001 	str	x1, [x0]
	slab->free_list = *(char **) mem;
  412028:	f94002a0 	ldr	x0, [x21]
  41202c:	f9001a60 	str	x0, [x19, #48]
	slab->num_used--;
  412030:	b9403a60 	ldr	w0, [x19, #56]
  412034:	51000400 	sub	w0, w0, #0x1
  412038:	b9003a60 	str	w0, [x19, #56]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41203c:	aa1403e0 	mov	x0, x20
  412040:	94000132 	bl	412508 <z_spin_unlock_valid>
  412044:	72001c1f 	tst	w0, #0xff
  412048:	54000261 	b.ne	412094 <k_mem_slab_free+0x144>  // b.any
  41204c:	f0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  412050:	912c1273 	add	x19, x19, #0xb04
  412054:	aa1303e2 	mov	x2, x19
  412058:	52801863 	mov	w3, #0xc3                  	// #195
  41205c:	f0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  412060:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412064:	912d7821 	add	x1, x1, #0xb5e
  412068:	91178000 	add	x0, x0, #0x5e0
  41206c:	97ffd36f 	bl	406e28 <assert_print>
  412070:	aa1403e1 	mov	x1, x20
  412074:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  412078:	912dd400 	add	x0, x0, #0xb75
  41207c:	97ffd36b 	bl	406e28 <assert_print>
  412080:	aa1303e0 	mov	x0, x19
  412084:	52801861 	mov	w1, #0xc3                  	// #195
  412088:	97ffd392 	bl	406ed0 <assert_post_action>
  41208c:	52801862 	mov	w2, #0xc3                  	// #195
  412090:	17ffffce 	b	411fc8 <k_mem_slab_free+0x78>
	posix_irq_unlock(key);
  412094:	2a1603e0 	mov	w0, w22
}
  412098:	a94153f3 	ldp	x19, x20, [sp, #16]
  41209c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4120a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4120a4:	17ffdc69 	b	409248 <posix_irq_unlock>

00000000004120a8 <k_is_in_isr>:
	return _kernel.cpus[0].nested != 0U;
  4120a8:	f00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4120ac:	f9471000 	ldr	x0, [x0, #3616]
  4120b0:	b9400000 	ldr	w0, [x0]
  4120b4:	7100001f 	cmp	w0, #0x0
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
  4120b8:	1a9f07e0 	cset	w0, ne  // ne = any
  4120bc:	d65f03c0 	ret

00000000004120c0 <z_impl_k_thread_name_set>:
	k_spin_unlock(&z_thread_monitor_lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
  4120c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4120c4:	910003fd 	mov	x29, sp
  4120c8:	f9000bf3 	str	x19, [sp, #16]
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
  4120cc:	b5000180 	cbnz	x0, 4120fc <z_impl_k_thread_name_set+0x3c>
		thread = _current;
  4120d0:	f00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4120d4:	f9471000 	ldr	x0, [x0, #3616]
  4120d8:	f9400813 	ldr	x19, [x0, #16]
  return __builtin___strncpy_chk (__dest, __src, __len,
  4120dc:	91022660 	add	x0, x19, #0x89
  4120e0:	d28003e2 	mov	x2, #0x1f                  	// #31
  4120e4:	97ffbd63 	bl	401670 <strncpy@plt>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  4120e8:	3902a27f 	strb	wzr, [x19, #168]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
  4120ec:	52800000 	mov	w0, #0x0                   	// #0
  4120f0:	f9400bf3 	ldr	x19, [sp, #16]
  4120f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4120f8:	d65f03c0 	ret
  4120fc:	aa0003f3 	mov	x19, x0
  412100:	17fffff7 	b	4120dc <z_impl_k_thread_name_set+0x1c>

0000000000412104 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
  412104:	91022400 	add	x0, x0, #0x89
  412108:	d65f03c0 	ret

000000000041210c <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
  41210c:	14000c38 	b	4151ec <z_sched_start>

0000000000412110 <z_init_thread_base>:

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
  412110:	f900081f 	str	xzr, [x0, #16]
	thread_base->user_options = (uint8_t)options;
  412114:	39006003 	strb	w3, [x0, #24]
	thread_base->thread_state = (uint8_t)initial_state;
  412118:	39006402 	strb	w2, [x0, #25]

	thread_base->prio = priority;
  41211c:	39006801 	strb	w1, [x0, #26]

	thread_base->sched_locked = 0U;
  412120:	39006c1f 	strb	wzr, [x0, #27]
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
  412124:	a902fc1f 	stp	xzr, xzr, [x0, #40]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
  412128:	d65f03c0 	ret

000000000041212c <z_setup_new_thread>:
{
  41212c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  412130:	910003fd 	mov	x29, sp
  412134:	a90153f3 	stp	x19, x20, [sp, #16]
  412138:	aa0003f3 	mov	x19, x0
  41213c:	aa0203f4 	mov	x20, x2
  412140:	a9025bf5 	stp	x21, x22, [sp, #32]
  412144:	aa0103f6 	mov	x22, x1
  412148:	2a0703f5 	mov	w21, w7
  41214c:	a90363f7 	stp	x23, x24, [sp, #48]
  412150:	aa0303f7 	mov	x23, x3
  412154:	aa0403f8 	mov	x24, x4
  412158:	a9046bf9 	stp	x25, x26, [sp, #64]
  41215c:	aa0503fa 	mov	x26, x5
  412160:	f9002bfb 	str	x27, [sp, #80]
  412164:	aa0603fb 	mov	x27, x6
  412168:	f94037f9 	ldr	x25, [sp, #104]
	Z_ASSERT_VALID_PRIO(prio, entry);
  41216c:	71003cff 	cmp	w7, #0xf
  412170:	540005a1 	b.ne	412224 <z_setup_new_thread+0xf8>  // b.any
  412174:	f00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  412178:	f9473800 	ldr	x0, [x0, #3696]
  41217c:	eb00007f 	cmp	x3, x0
  412180:	54000581 	b.ne	412230 <z_setup_new_thread+0x104>  // b.any
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  412184:	b94063e3 	ldr	w3, [sp, #96]
  412188:	91018260 	add	x0, x19, #0x60
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
  41218c:	91001e94 	add	x20, x20, #0x7
	list->tail = (sys_dnode_t *)list;
  412190:	a9060260 	stp	x0, x0, [x19, #96]
  412194:	927df294 	and	x20, x20, #0xfffffffffffffff8
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  412198:	2a1503e1 	mov	w1, w21
  41219c:	aa1303e0 	mov	x0, x19
  4121a0:	52800082 	mov	w2, #0x4                   	// #4
	stack_ptr = (char *)stack + stack_obj_size;
  4121a4:	8b1402d4 	add	x20, x22, x20
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
  4121a8:	97ffffda 	bl	412110 <z_init_thread_base>
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
  4121ac:	aa1b03e6 	mov	x6, x27
  4121b0:	aa1a03e5 	mov	x5, x26
  4121b4:	aa1803e4 	mov	x4, x24
  4121b8:	aa1703e3 	mov	x3, x23
  4121bc:	aa1403e2 	mov	x2, x20
  4121c0:	aa1603e1 	mov	x1, x22
  4121c4:	aa1303e0 	mov	x0, x19
  4121c8:	97ffd913 	bl	408614 <arch_new_thread>
	new_thread->init_data = NULL;
  4121cc:	f9002e7f 	str	xzr, [x19, #88]
	new_thread->no_wake_on_timeout = false;
  4121d0:	3902227f 	strb	wzr, [x19, #136]
	if (name != NULL) {
  4121d4:	b40005d9 	cbz	x25, 41228c <z_setup_new_thread+0x160>
  4121d8:	aa1903e1 	mov	x1, x25
  4121dc:	91022660 	add	x0, x19, #0x89
  4121e0:	d28003e2 	mov	x2, #0x1f                  	// #31
  4121e4:	97ffbd23 	bl	401670 <strncpy@plt>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
  4121e8:	3902a27f 	strb	wzr, [x19, #168]
	if (!_current) {
  4121ec:	f00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4121f0:	f9471000 	ldr	x0, [x0, #3616]
  4121f4:	f9400800 	ldr	x0, [x0, #16]
  4121f8:	b4000040 	cbz	x0, 412200 <z_setup_new_thread+0xd4>
	new_thread->resource_pool = _current->resource_pool;
  4121fc:	f9405800 	ldr	x0, [x0, #176]
	return stack_ptr;
  412200:	f9005a60 	str	x0, [x19, #176]
}
  412204:	aa1403e0 	mov	x0, x20
  412208:	a94153f3 	ldp	x19, x20, [sp, #16]
  41220c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412210:	a94363f7 	ldp	x23, x24, [sp, #48]
  412214:	a9446bf9 	ldp	x25, x26, [sp, #64]
  412218:	f9402bfb 	ldr	x27, [sp, #80]
  41221c:	a8c67bfd 	ldp	x29, x30, [sp], #96
  412220:	d65f03c0 	ret
	Z_ASSERT_VALID_PRIO(prio, entry);
  412224:	110040e0 	add	w0, w7, #0x10
  412228:	7100781f 	cmp	w0, #0x1e
  41222c:	54fffac9 	b.ls	412184 <z_setup_new_thread+0x58>  // b.plast
  412230:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412234:	9106f673 	add	x19, x19, #0x1bd
  412238:	aa1303e2 	mov	x2, x19
  41223c:	52804343 	mov	w3, #0x21a                 	// #538
  412240:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  412244:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412248:	91078021 	add	x1, x1, #0x1e0
  41224c:	91178000 	add	x0, x0, #0x5e0
  412250:	97ffd2f6 	bl	406e28 <assert_print>
  412254:	528001c2 	mov	w2, #0xe                   	// #14
  412258:	128001e3 	mov	w3, #0xfffffff0            	// #-16
  41225c:	2a1503e1 	mov	w1, w21
  412260:	90000040 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  412264:	91098000 	add	x0, x0, #0x260
  412268:	97ffd2f0 	bl	406e28 <assert_print>
  41226c:	aa1303e0 	mov	x0, x19
  412270:	52804341 	mov	w1, #0x21a                 	// #538
  412274:	97ffd317 	bl	406ed0 <assert_post_action>
  412278:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  41227c:	aa1303e1 	mov	x1, x19
  412280:	91187800 	add	x0, x0, #0x61e
  412284:	52804342 	mov	w2, #0x21a                 	// #538
  412288:	97ffdd04 	bl	409698 <posix_print_error_and_exit>
		new_thread->name[0] = '\0';
  41228c:	3902267f 	strb	wzr, [x19, #137]
  412290:	17ffffd7 	b	4121ec <z_setup_new_thread+0xc0>

0000000000412294 <z_impl_k_thread_create>:
{
  412294:	d100c3ff 	sub	sp, sp, #0x30
  412298:	f00000e8 	adrp	x8, 431000 <__FRAME_END__+0x10804>
  41229c:	a9017bfd 	stp	x29, x30, [sp, #16]
  4122a0:	910043fd 	add	x29, sp, #0x10
  4122a4:	f9471108 	ldr	x8, [x8, #3616]
  4122a8:	a90253f3 	stp	x19, x20, [sp, #32]
  4122ac:	f9401ff4 	ldr	x20, [sp, #56]
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
  4122b0:	b9400108 	ldr	w8, [x8]
  4122b4:	340002a8 	cbz	w8, 412308 <z_impl_k_thread_create+0x74>
  4122b8:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4122bc:	9106f673 	add	x19, x19, #0x1bd
  4122c0:	aa1303e2 	mov	x2, x19
  4122c4:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4122c8:	910a4421 	add	x1, x1, #0x291
  4122cc:	52805183 	mov	w3, #0x28c                 	// #652
  4122d0:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4122d4:	91178000 	add	x0, x0, #0x5e0
  4122d8:	97ffd2d4 	bl	406e28 <assert_print>
  4122dc:	90000040 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  4122e0:	910a8c00 	add	x0, x0, #0x2a3
  4122e4:	97ffd2d1 	bl	406e28 <assert_print>
  4122e8:	aa1303e0 	mov	x0, x19
  4122ec:	52805181 	mov	w1, #0x28c                 	// #652
  4122f0:	97ffd2f8 	bl	406ed0 <assert_post_action>
  4122f4:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4122f8:	aa1303e1 	mov	x1, x19
  4122fc:	91187800 	add	x0, x0, #0x61e
  412300:	52805182 	mov	w2, #0x28c                 	// #652
  412304:	97ffdce5 	bl	409698 <posix_print_error_and_exit>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
  412308:	b94033e8 	ldr	w8, [sp, #48]
  41230c:	aa0003f3 	mov	x19, x0
  412310:	b90003e8 	str	w8, [sp]
  412314:	f90007ff 	str	xzr, [sp, #8]
  412318:	97ffff85 	bl	41212c <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
  41231c:	b100069f 	cmn	x20, #0x1
  412320:	54000080 	b.eq	412330 <z_impl_k_thread_create+0x9c>  // b.none
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  412324:	b5000114 	cbnz	x20, 412344 <z_impl_k_thread_create+0xb0>
	z_impl_k_thread_start(thread);
  412328:	aa1303e0 	mov	x0, x19
  41232c:	97ffff78 	bl	41210c <z_impl_k_thread_start>
}
  412330:	aa1303e0 	mov	x0, x19
  412334:	a9417bfd 	ldp	x29, x30, [sp, #16]
  412338:	a94253f3 	ldp	x19, x20, [sp, #32]
  41233c:	9100c3ff 	add	sp, sp, #0x30
  412340:	d65f03c0 	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  412344:	f00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  412348:	aa1403e2 	mov	x2, x20
  41234c:	9100a260 	add	x0, x19, #0x28
  412350:	f9470421 	ldr	x1, [x1, #3592]
  412354:	9400128b 	bl	416d80 <z_add_timeout>
  412358:	17fffff6 	b	412330 <z_impl_k_thread_create+0x9c>

000000000041235c <z_init_static_threads>:
{
  41235c:	d10103ff 	sub	sp, sp, #0x40
	_FOREACH_STATIC_THREAD(thread_data) {
  412360:	f00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
{
  412364:	a9017bfd 	stp	x29, x30, [sp, #16]
  412368:	910043fd 	add	x29, sp, #0x10
  41236c:	a90253f3 	stp	x19, x20, [sp, #32]
  412370:	aa0003f4 	mov	x20, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  412374:	f947a813 	ldr	x19, [x0, #3920]
  412378:	f00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
{
  41237c:	a9035bf5 	stp	x21, x22, [sp, #48]
  412380:	aa0003f5 	mov	x21, x0
	_FOREACH_STATIC_THREAD(thread_data) {
  412384:	f946ec16 	ldr	x22, [x0, #3544]
  412388:	eb16027f 	cmp	x19, x22
  41238c:	54000469 	b.ls	412418 <z_init_static_threads+0xbc>  // b.plast
  412390:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412394:	9106f673 	add	x19, x19, #0x1bd
  412398:	aa1303e2 	mov	x2, x19
  41239c:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4123a0:	910b2021 	add	x1, x1, #0x2c8
  4123a4:	52805e63 	mov	w3, #0x2f3                 	// #755
  4123a8:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4123ac:	91178000 	add	x0, x0, #0x5e0
  4123b0:	97ffd29e 	bl	406e28 <assert_print>
  4123b4:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4123b8:	91248400 	add	x0, x0, #0x921
  4123bc:	97ffd29b 	bl	406e28 <assert_print>
  4123c0:	aa1303e0 	mov	x0, x19
  4123c4:	52805e61 	mov	w1, #0x2f3                 	// #755
  4123c8:	97ffd2c2 	bl	406ed0 <assert_post_action>
  4123cc:	52805e62 	mov	w2, #0x2f3                 	// #755
	_FOREACH_STATIC_THREAD(thread_data) {
  4123d0:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4123d4:	aa1303e1 	mov	x1, x19
  4123d8:	91187800 	add	x0, x0, #0x61e
  4123dc:	97ffdcaf 	bl	409698 <posix_print_error_and_exit>
		z_setup_new_thread(
  4123e0:	f9402660 	ldr	x0, [x19, #72]
  4123e4:	b9401262 	ldr	w2, [x19, #16]
  4123e8:	f90007e0 	str	x0, [sp, #8]
  4123ec:	b9403e60 	ldr	w0, [x19, #60]
  4123f0:	b90003e0 	str	w0, [sp]
  4123f4:	a9400660 	ldp	x0, x1, [x19]
  4123f8:	a9419263 	ldp	x3, x4, [x19, #24]
  4123fc:	a9429a65 	ldp	x5, x6, [x19, #40]
  412400:	b9403a67 	ldr	w7, [x19, #56]
  412404:	97ffff4a 	bl	41212c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
  412408:	f9400260 	ldr	x0, [x19]
  41240c:	f9002c13 	str	x19, [x0, #88]
	_FOREACH_STATIC_THREAD(thread_data) {
  412410:	91014273 	add	x19, x19, #0x50
  412414:	17ffffdd 	b	412388 <z_init_static_threads+0x2c>
  412418:	54fffe43 	b.cc	4123e0 <z_init_static_threads+0x84>  // b.lo, b.ul, b.last
	k_sched_lock();
  41241c:	94000929 	bl	4148c0 <k_sched_lock>
  412420:	d2800156 	mov	x22, #0xa                   	// #10
	_FOREACH_STATIC_THREAD(thread_data) {
  412424:	f947aa93 	ldr	x19, [x20, #3920]
  412428:	f946eeb4 	ldr	x20, [x21, #3544]
  41242c:	f00000f5 	adrp	x21, 431000 <__FRAME_END__+0x10804>
  412430:	f94706b5 	ldr	x21, [x21, #3592]
  412434:	eb14027f 	cmp	x19, x20
  412438:	54000469 	b.ls	4124c4 <z_init_static_threads+0x168>  // b.plast
  41243c:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412440:	9106f673 	add	x19, x19, #0x1bd
  412444:	aa1303e2 	mov	x2, x19
  412448:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  41244c:	910b2021 	add	x1, x1, #0x2c8
  412450:	52806243 	mov	w3, #0x312                 	// #786
  412454:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412458:	91178000 	add	x0, x0, #0x5e0
  41245c:	97ffd273 	bl	406e28 <assert_print>
  412460:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412464:	91248400 	add	x0, x0, #0x921
  412468:	97ffd270 	bl	406e28 <assert_print>
  41246c:	aa1303e0 	mov	x0, x19
  412470:	52806241 	mov	w1, #0x312                 	// #786
  412474:	97ffd297 	bl	406ed0 <assert_post_action>
  412478:	52806242 	mov	w2, #0x312                 	// #786
  41247c:	17ffffd5 	b	4123d0 <z_init_static_threads+0x74>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
  412480:	b9404262 	ldr	w2, [x19, #64]
  412484:	3100045f 	cmn	w2, #0x1
  412488:	54000100 	b.eq	4124a8 <z_init_static_threads+0x14c>  // b.none
					    K_MSEC(thread_data->init_delay));
  41248c:	7100005f 	cmp	w2, #0x0
  412490:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
  412494:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
  412498:	93407c43 	sxtw	x3, w2
		t += off;
  41249c:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  4124a0:	b5000083 	cbnz	x3, 4124b0 <z_init_static_threads+0x154>
  4124a4:	97ffff1a 	bl	41210c <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
  4124a8:	91014273 	add	x19, x19, #0x50
  4124ac:	17ffffe2 	b	412434 <z_init_static_threads+0xd8>
  4124b0:	9ad60842 	udiv	x2, x2, x22
  4124b4:	aa1503e1 	mov	x1, x21
  4124b8:	9100a000 	add	x0, x0, #0x28
  4124bc:	94001231 	bl	416d80 <z_add_timeout>
  4124c0:	17fffffa 	b	4124a8 <z_init_static_threads+0x14c>
  4124c4:	54fffde3 	b.cc	412480 <z_init_static_threads+0x124>  // b.lo, b.ul, b.last
}
  4124c8:	a9417bfd 	ldp	x29, x30, [sp, #16]
  4124cc:	a94253f3 	ldp	x19, x20, [sp, #32]
  4124d0:	a9435bf5 	ldp	x21, x22, [sp, #48]
  4124d4:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
  4124d8:	14000da2 	b	415b60 <k_sched_unlock>

00000000004124dc <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
  4124dc:	f9400000 	ldr	x0, [x0]

	if (thread_cpu != 0U) {
  4124e0:	b4000100 	cbz	x0, 412500 <z_spin_lock_valid+0x24>
		if ((thread_cpu & 3U) == _current_cpu->id) {
  4124e4:	f00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4124e8:	92400400 	and	x0, x0, #0x3
  4124ec:	f9471021 	ldr	x1, [x1, #3616]
  4124f0:	39408021 	ldrb	w1, [x1, #32]
  4124f4:	eb01001f 	cmp	x0, x1
  4124f8:	1a9f07e0 	cset	w0, ne  // ne = any
			return false;
		}
	}
	return true;
}
  4124fc:	d65f03c0 	ret
	return true;
  412500:	52800020 	mov	w0, #0x1                   	// #1
  412504:	17fffffe 	b	4124fc <z_spin_lock_valid+0x20>

0000000000412508 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
  412508:	f00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  41250c:	f9471021 	ldr	x1, [x1, #3616]
  412510:	39408022 	ldrb	w2, [x1, #32]
  412514:	f9400821 	ldr	x1, [x1, #16]
  412518:	aa020021 	orr	x1, x1, x2
  41251c:	f9400002 	ldr	x2, [x0]
  412520:	eb01005f 	cmp	x2, x1
  412524:	54000081 	b.ne	412534 <z_spin_unlock_valid+0x2c>  // b.any
		return false;
	}
	l->thread_cpu = 0;
  412528:	f900001f 	str	xzr, [x0]
	return true;
  41252c:	52800020 	mov	w0, #0x1                   	// #1
}
  412530:	d65f03c0 	ret
		return false;
  412534:	52800000 	mov	w0, #0x0                   	// #0
  412538:	17fffffe 	b	412530 <z_spin_unlock_valid+0x28>

000000000041253c <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
  41253c:	f00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  412540:	f9471021 	ldr	x1, [x1, #3616]
  412544:	39408022 	ldrb	w2, [x1, #32]
  412548:	f9400821 	ldr	x1, [x1, #16]
  41254c:	aa020021 	orr	x1, x1, x2
  412550:	f9000001 	str	x1, [x0]
}
  412554:	d65f03c0 	ret

0000000000412558 <idle>:
	sys_clock_idle_exit();
#endif
}

void idle(void *unused1, void *unused2, void *unused3)
{
  412558:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	__ASSERT_NO_MSG(_current->base.prio >= 0);
  41255c:	f00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
{
  412560:	910003fd 	mov	x29, sp
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  412564:	f9471000 	ldr	x0, [x0, #3616]
{
  412568:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(_current->base.prio >= 0);
  41256c:	f9400800 	ldr	x0, [x0, #16]
  412570:	39c06800 	ldrsb	w0, [x0, #26]
  412574:	36f80240 	tbz	w0, #31, 4125bc <idle+0x64>
  412578:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  41257c:	910bd673 	add	x19, x19, #0x2f5
  412580:	aa1303e2 	mov	x2, x19
  412584:	52800523 	mov	w3, #0x29                  	// #41
  412588:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  41258c:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412590:	910c5821 	add	x1, x1, #0x316
  412594:	91178000 	add	x0, x0, #0x5e0
  412598:	97ffd224 	bl	406e28 <assert_print>
  41259c:	aa1303e0 	mov	x0, x19
  4125a0:	52800521 	mov	w1, #0x29                  	// #41
  4125a4:	97ffd24b 	bl	406ed0 <assert_post_action>
  4125a8:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4125ac:	aa1303e1 	mov	x1, x19
  4125b0:	91187800 	add	x0, x0, #0x61e
  4125b4:	52800522 	mov	w2, #0x29                  	// #41
  4125b8:	97ffdc38 	bl	409698 <posix_print_error_and_exit>
	return posix_irq_lock();
  4125bc:	97ffdb21 	bl	409240 <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
  4125c0:	97ffd68d 	bl	407ff4 <arch_cpu_idle>
  4125c4:	17fffffe 	b	4125bc <idle+0x64>

00000000004125c8 <k_msgq_init>:

void k_msgq_init(struct k_msgq *msgq, char *buffer, size_t msg_size,
		 uint32_t max_msgs)
{
	msgq->msg_size = msg_size;
	msgq->max_msgs = max_msgs;
  4125c8:	b9002003 	str	w3, [x0, #32]
	msgq->buffer_start = buffer;
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  4125cc:	2a0303e3 	mov	w3, w3
	msgq->msg_size = msg_size;
  4125d0:	a901081f 	stp	xzr, x2, [x0, #16]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  4125d4:	9b020462 	madd	x2, x3, x2, x1
  4125d8:	a9000000 	stp	x0, x0, [x0]
	msgq->buffer_start = buffer;
  4125dc:	f9001401 	str	x1, [x0, #40]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
  4125e0:	f9001802 	str	x2, [x0, #48]
	msgq->read_ptr = buffer;
	msgq->write_ptr = buffer;
  4125e4:	a9038401 	stp	x1, x1, [x0, #56]
	msgq->used_msgs = 0;
	msgq->flags = 0;
	z_waitq_init(&msgq->wait_q);
	msgq->lock = (struct k_spinlock) {};
#ifdef CONFIG_POLL
	sys_dlist_init(&msgq->poll_events);
  4125e8:	91014001 	add	x1, x0, #0x50
	msgq->used_msgs = 0;
  4125ec:	b900481f 	str	wzr, [x0, #72]
  4125f0:	a9050401 	stp	x1, x1, [x0, #80]
	msgq->flags = 0;
  4125f4:	3901801f 	strb	wzr, [x0, #96]
#endif	/* CONFIG_POLL */

	SYS_PORT_TRACING_OBJ_INIT(k_msgq, msgq);

	z_object_init(msgq);
}
  4125f8:	d65f03c0 	ret

00000000004125fc <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
  4125fc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  412600:	910003fd 	mov	x29, sp
  412604:	a9025bf5 	stp	x21, x22, [sp, #32]
  412608:	aa0203f5 	mov	x21, x2
  41260c:	f00000e2 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  412610:	a90153f3 	stp	x19, x20, [sp, #16]
  412614:	aa0003f3 	mov	x19, x0
  412618:	f9471040 	ldr	x0, [x2, #3616]
  41261c:	a90363f7 	stp	x23, x24, [sp, #48]
  412620:	aa0103f7 	mov	x23, x1
  412624:	aa0203f8 	mov	x24, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  412628:	b9400000 	ldr	w0, [x0]
  41262c:	340002c0 	cbz	w0, 412684 <z_impl_k_msgq_put+0x88>
  412630:	b40002b5 	cbz	x21, 412684 <z_impl_k_msgq_put+0x88>
  412634:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412638:	910cfa73 	add	x19, x19, #0x33e
  41263c:	aa1303e2 	mov	x2, x19
  412640:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  412644:	9104d421 	add	x1, x1, #0x135
  412648:	52800ec3 	mov	w3, #0x76                  	// #118
  41264c:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412650:	91178000 	add	x0, x0, #0x5e0
  412654:	97ffd1f5 	bl	406e28 <assert_print>
  412658:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  41265c:	912e6c00 	add	x0, x0, #0xb9b
  412660:	97ffd1f2 	bl	406e28 <assert_print>
  412664:	aa1303e0 	mov	x0, x19
  412668:	52800ec1 	mov	w1, #0x76                  	// #118
  41266c:	97ffd219 	bl	406ed0 <assert_post_action>
  412670:	52800ec2 	mov	w2, #0x76                  	// #118
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412674:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412678:	aa1303e1 	mov	x1, x19
  41267c:	91187800 	add	x0, x0, #0x61e
  412680:	97ffdc06 	bl	409698 <posix_print_error_and_exit>
  412684:	97ffdaef 	bl	409240 <posix_irq_lock>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
  412688:	91004274 	add	x20, x19, #0x10
  41268c:	2a0003f6 	mov	w22, w0
  412690:	aa1403e0 	mov	x0, x20
  412694:	97ffff92 	bl	4124dc <z_spin_lock_valid>
  412698:	72001c1f 	tst	w0, #0xff
  41269c:	54000261 	b.ne	4126e8 <z_impl_k_msgq_put+0xec>  // b.any
  4126a0:	f0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  4126a4:	912c1273 	add	x19, x19, #0xb04
  4126a8:	aa1303e2 	mov	x2, x19
  4126ac:	52801283 	mov	w3, #0x94                  	// #148
  4126b0:	f0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4126b4:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4126b8:	912cc421 	add	x1, x1, #0xb31
  4126bc:	91178000 	add	x0, x0, #0x5e0
  4126c0:	97ffd1da 	bl	406e28 <assert_print>
  4126c4:	aa1403e1 	mov	x1, x20
  4126c8:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4126cc:	912d1800 	add	x0, x0, #0xb46
  4126d0:	97ffd1d6 	bl	406e28 <assert_print>
  4126d4:	aa1303e0 	mov	x0, x19
  4126d8:	52801281 	mov	w1, #0x94                  	// #148
  4126dc:	97ffd1fd 	bl	406ed0 <assert_post_action>
  4126e0:	52801282 	mov	w2, #0x94                  	// #148
  4126e4:	17ffffe4 	b	412674 <z_impl_k_msgq_put+0x78>
	z_spin_lock_set_owner(l);
  4126e8:	aa1403e0 	mov	x0, x20
  4126ec:	97ffff94 	bl	41253c <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
  4126f0:	b9402260 	ldr	w0, [x19, #32]
  4126f4:	b9404a61 	ldr	w1, [x19, #72]
  4126f8:	6b00003f 	cmp	w1, w0
  4126fc:	54000a82 	b.cs	41284c <z_impl_k_msgq_put+0x250>  // b.hs, b.nlast
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  412700:	aa1303e0 	mov	x0, x19
  412704:	94000dca 	bl	415e2c <z_unpend_first_thread>
  412708:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  41270c:	b4000240 	cbz	x0, 412754 <z_impl_k_msgq_put+0x158>
  return __builtin___memcpy_chk (__dest, __src, __len,
  412710:	f9400e62 	ldr	x2, [x19, #24]
  412714:	aa1703e1 	mov	x1, x23
  412718:	f9401000 	ldr	x0, [x0, #32]
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
			return 0;
  41271c:	52800013 	mov	w19, #0x0                   	// #0
  412720:	97ffbb04 	bl	401330 <memcpy@plt>
	thread->callee_saved.retval = value;
  412724:	b9004ebf 	str	wzr, [x21, #76]
			z_ready_thread(pending_thread);
  412728:	aa1503e0 	mov	x0, x21
  41272c:	94000a6f 	bl	4150e8 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  412730:	2a1603e1 	mov	w1, w22
  412734:	aa1403e0 	mov	x0, x20
  412738:	94000811 	bl	41477c <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  41273c:	2a1303e0 	mov	w0, w19
  412740:	a94153f3 	ldp	x19, x20, [sp, #16]
  412744:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412748:	a94363f7 	ldp	x23, x24, [sp, #48]
  41274c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412750:	d65f03c0 	ret
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  412754:	f9401661 	ldr	x1, [x19, #40]
  412758:	f9402260 	ldr	x0, [x19, #64]
  41275c:	eb01001f 	cmp	x0, x1
  412760:	54000083 	b.cc	412770 <z_impl_k_msgq_put+0x174>  // b.lo, b.ul, b.last
  412764:	f9401a61 	ldr	x1, [x19, #48]
  412768:	eb01001f 	cmp	x0, x1
  41276c:	540001e3 	b.cc	4127a8 <z_impl_k_msgq_put+0x1ac>  // b.lo, b.ul, b.last
  412770:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412774:	910cfa73 	add	x19, x19, #0x33e
  412778:	aa1303e2 	mov	x2, x19
  41277c:	52801203 	mov	w3, #0x90                  	// #144
  412780:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  412784:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412788:	910d8021 	add	x1, x1, #0x360
  41278c:	91178000 	add	x0, x0, #0x5e0
  412790:	97ffd1a6 	bl	406e28 <assert_print>
  412794:	aa1303e0 	mov	x0, x19
  412798:	52801201 	mov	w1, #0x90                  	// #144
  41279c:	97ffd1cd 	bl	406ed0 <assert_post_action>
  4127a0:	52801202 	mov	w2, #0x90                  	// #144
  4127a4:	17ffffb4 	b	412674 <z_impl_k_msgq_put+0x78>
  4127a8:	f9400e62 	ldr	x2, [x19, #24]
  4127ac:	aa1703e1 	mov	x1, x23
  4127b0:	97ffbae0 	bl	401330 <memcpy@plt>
			msgq->write_ptr += msgq->msg_size;
  4127b4:	f9400e60 	ldr	x0, [x19, #24]
  4127b8:	f9402262 	ldr	x2, [x19, #64]
  4127bc:	8b000042 	add	x2, x2, x0
  4127c0:	f9002262 	str	x2, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  4127c4:	f9401a60 	ldr	x0, [x19, #48]
  4127c8:	eb00005f 	cmp	x2, x0
  4127cc:	54000061 	b.ne	4127d8 <z_impl_k_msgq_put+0x1dc>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  4127d0:	f9401660 	ldr	x0, [x19, #40]
  4127d4:	f9002260 	str	x0, [x19, #64]
			msgq->used_msgs++;
  4127d8:	b9404a60 	ldr	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  4127dc:	52800201 	mov	w1, #0x10                  	// #16
			msgq->used_msgs++;
  4127e0:	11000400 	add	w0, w0, #0x1
  4127e4:	b9004a60 	str	w0, [x19, #72]
	z_handle_obj_poll_events(&msgq->poll_events, state);
  4127e8:	91014260 	add	x0, x19, #0x50
		result = 0;
  4127ec:	52800013 	mov	w19, #0x0                   	// #0
	z_handle_obj_poll_events(&msgq->poll_events, state);
  4127f0:	94001413 	bl	41783c <z_handle_obj_poll_events>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4127f4:	aa1403e0 	mov	x0, x20
  4127f8:	97ffff44 	bl	412508 <z_spin_unlock_valid>
  4127fc:	72001c1f 	tst	w0, #0xff
  412800:	54000441 	b.ne	412888 <z_impl_k_msgq_put+0x28c>  // b.any
  412804:	f0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  412808:	912c1273 	add	x19, x19, #0xb04
  41280c:	aa1303e2 	mov	x2, x19
  412810:	52801863 	mov	w3, #0xc3                  	// #195
  412814:	f0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  412818:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  41281c:	912d7821 	add	x1, x1, #0xb5e
  412820:	91178000 	add	x0, x0, #0x5e0
  412824:	97ffd181 	bl	406e28 <assert_print>
  412828:	aa1403e1 	mov	x1, x20
  41282c:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  412830:	912dd400 	add	x0, x0, #0xb75
  412834:	97ffd17d 	bl	406e28 <assert_print>
  412838:	aa1303e0 	mov	x0, x19
  41283c:	52801861 	mov	w1, #0xc3                  	// #195
  412840:	97ffd1a4 	bl	406ed0 <assert_post_action>
  412844:	52801862 	mov	w2, #0xc3                  	// #195
  412848:	17ffff8b 	b	412674 <z_impl_k_msgq_put+0x78>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  41284c:	b40001b5 	cbz	x21, 412880 <z_impl_k_msgq_put+0x284>
		_current->base.swap_data = (void *) data;
  412850:	f9471302 	ldr	x2, [x24, #3616]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  412854:	aa1503e3 	mov	x3, x21
  412858:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = (void *) data;
  41285c:	f9400840 	ldr	x0, [x2, #16]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  412860:	aa1303e2 	mov	x2, x19
		_current->base.swap_data = (void *) data;
  412864:	f9001017 	str	x23, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  412868:	aa1403e0 	mov	x0, x20
}
  41286c:	a94153f3 	ldp	x19, x20, [sp, #16]
  412870:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412874:	a94363f7 	ldp	x23, x24, [sp, #48]
  412878:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  41287c:	14000b64 	b	41560c <z_pend_curr>
		result = -ENOMSG;
  412880:	12800533 	mov	w19, #0xffffffd6            	// #-42
  412884:	17ffffdc 	b	4127f4 <z_impl_k_msgq_put+0x1f8>
	posix_irq_unlock(key);
  412888:	2a1603e0 	mov	w0, w22
  41288c:	97ffda6f 	bl	409248 <posix_irq_unlock>
	return result;
  412890:	17ffffab 	b	41273c <z_impl_k_msgq_put+0x140>

0000000000412894 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
  412894:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	return _kernel.cpus[0].nested != 0U;
  412898:	f00000e4 	adrp	x4, 431000 <__FRAME_END__+0x10804>
  41289c:	910003fd 	mov	x29, sp
  4128a0:	a90153f3 	stp	x19, x20, [sp, #16]
  4128a4:	aa0003f3 	mov	x19, x0
  4128a8:	f9471080 	ldr	x0, [x4, #3616]
  4128ac:	a9025bf5 	stp	x21, x22, [sp, #32]
  4128b0:	aa0403f5 	mov	x21, x4
  4128b4:	a90363f7 	stp	x23, x24, [sp, #48]
  4128b8:	aa0103f8 	mov	x24, x1
  4128bc:	aa0203f7 	mov	x23, x2
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
  4128c0:	b9400000 	ldr	w0, [x0]
  4128c4:	340002c0 	cbz	w0, 41291c <z_impl_k_msgq_get+0x88>
  4128c8:	b40002a2 	cbz	x2, 41291c <z_impl_k_msgq_get+0x88>
  4128cc:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4128d0:	910cfa73 	add	x19, x19, #0x33e
  4128d4:	aa1303e2 	mov	x2, x19
  4128d8:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4128dc:	9104d421 	add	x1, x1, #0x135
  4128e0:	52801a43 	mov	w3, #0xd2                  	// #210
  4128e4:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4128e8:	91178000 	add	x0, x0, #0x5e0
  4128ec:	97ffd14f 	bl	406e28 <assert_print>
  4128f0:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4128f4:	912e6c00 	add	x0, x0, #0xb9b
  4128f8:	97ffd14c 	bl	406e28 <assert_print>
  4128fc:	aa1303e0 	mov	x0, x19
  412900:	52801a41 	mov	w1, #0xd2                  	// #210
  412904:	97ffd173 	bl	406ed0 <assert_post_action>
  412908:	52801a42 	mov	w2, #0xd2                  	// #210
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41290c:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412910:	aa1303e1 	mov	x1, x19
  412914:	91187800 	add	x0, x0, #0x61e
  412918:	97ffdb60 	bl	409698 <posix_print_error_and_exit>
	return posix_irq_lock();
  41291c:	97ffda49 	bl	409240 <posix_irq_lock>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
  412920:	91004274 	add	x20, x19, #0x10
  412924:	2a0003f6 	mov	w22, w0
  412928:	aa1403e0 	mov	x0, x20
  41292c:	97fffeec 	bl	4124dc <z_spin_lock_valid>
  412930:	72001c1f 	tst	w0, #0xff
  412934:	54000261 	b.ne	412980 <z_impl_k_msgq_get+0xec>  // b.any
  412938:	f0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  41293c:	912c1273 	add	x19, x19, #0xb04
  412940:	aa1303e2 	mov	x2, x19
  412944:	52801283 	mov	w3, #0x94                  	// #148
  412948:	f0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  41294c:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412950:	912cc421 	add	x1, x1, #0xb31
  412954:	91178000 	add	x0, x0, #0x5e0
  412958:	97ffd134 	bl	406e28 <assert_print>
  41295c:	aa1403e1 	mov	x1, x20
  412960:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  412964:	912d1800 	add	x0, x0, #0xb46
  412968:	97ffd130 	bl	406e28 <assert_print>
  41296c:	aa1303e0 	mov	x0, x19
  412970:	52801281 	mov	w1, #0x94                  	// #148
  412974:	97ffd157 	bl	406ed0 <assert_post_action>
  412978:	52801282 	mov	w2, #0x94                  	// #148
  41297c:	17ffffe4 	b	41290c <z_impl_k_msgq_get+0x78>
	z_spin_lock_set_owner(l);
  412980:	aa1403e0 	mov	x0, x20
  412984:	97fffeee 	bl	41253c <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
  412988:	b9404a60 	ldr	w0, [x19, #72]
  41298c:	340008c0 	cbz	w0, 412aa4 <z_impl_k_msgq_get+0x210>
  412990:	f9400e62 	ldr	x2, [x19, #24]
  412994:	aa1803e0 	mov	x0, x24
  412998:	f9401e61 	ldr	x1, [x19, #56]
  41299c:	97ffba65 	bl	401330 <memcpy@plt>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
  4129a0:	f9400e61 	ldr	x1, [x19, #24]
  4129a4:	f9401e60 	ldr	x0, [x19, #56]
  4129a8:	8b010000 	add	x0, x0, x1
  4129ac:	f9001e60 	str	x0, [x19, #56]
		if (msgq->read_ptr == msgq->buffer_end) {
  4129b0:	f9401a61 	ldr	x1, [x19, #48]
  4129b4:	eb01001f 	cmp	x0, x1
  4129b8:	54000061 	b.ne	4129c4 <z_impl_k_msgq_get+0x130>  // b.any
			msgq->read_ptr = msgq->buffer_start;
  4129bc:	f9401660 	ldr	x0, [x19, #40]
  4129c0:	f9001e60 	str	x0, [x19, #56]
		}
		msgq->used_msgs--;
  4129c4:	b9404a60 	ldr	w0, [x19, #72]
  4129c8:	51000400 	sub	w0, w0, #0x1
  4129cc:	b9004a60 	str	w0, [x19, #72]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
  4129d0:	aa1303e0 	mov	x0, x19
  4129d4:	94000d16 	bl	415e2c <z_unpend_first_thread>
  4129d8:	aa0003f5 	mov	x21, x0
		if (pending_thread != NULL) {
  4129dc:	b40007e0 	cbz	x0, 412ad8 <z_impl_k_msgq_get+0x244>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			__ASSERT_NO_MSG(msgq->write_ptr >= msgq->buffer_start &&
  4129e0:	f9401661 	ldr	x1, [x19, #40]
  4129e4:	f9402260 	ldr	x0, [x19, #64]
  4129e8:	eb01001f 	cmp	x0, x1
  4129ec:	54000083 	b.cc	4129fc <z_impl_k_msgq_get+0x168>  // b.lo, b.ul, b.last
  4129f0:	f9401a61 	ldr	x1, [x19, #48]
  4129f4:	eb01001f 	cmp	x0, x1
  4129f8:	540001e3 	b.cc	412a34 <z_impl_k_msgq_get+0x1a0>  // b.lo, b.ul, b.last
  4129fc:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412a00:	910cfa73 	add	x19, x19, #0x33e
  412a04:	aa1303e2 	mov	x2, x19
  412a08:	52801d63 	mov	w3, #0xeb                  	// #235
  412a0c:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  412a10:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412a14:	910d8021 	add	x1, x1, #0x360
  412a18:	91178000 	add	x0, x0, #0x5e0
  412a1c:	97ffd103 	bl	406e28 <assert_print>
  412a20:	aa1303e0 	mov	x0, x19
  412a24:	52801d61 	mov	w1, #0xeb                  	// #235
  412a28:	97ffd12a 	bl	406ed0 <assert_post_action>
  412a2c:	52801d62 	mov	w2, #0xeb                  	// #235
  412a30:	17ffffb7 	b	41290c <z_impl_k_msgq_get+0x78>
  412a34:	f9400e62 	ldr	x2, [x19, #24]
  412a38:	f94012a1 	ldr	x1, [x21, #32]
  412a3c:	97ffba3d 	bl	401330 <memcpy@plt>
					msgq->write_ptr < msgq->buffer_end);
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
  412a40:	f9400e61 	ldr	x1, [x19, #24]
  412a44:	f9402260 	ldr	x0, [x19, #64]
  412a48:	8b010000 	add	x0, x0, x1
  412a4c:	f9002260 	str	x0, [x19, #64]
			if (msgq->write_ptr == msgq->buffer_end) {
  412a50:	f9401a61 	ldr	x1, [x19, #48]
  412a54:	eb01001f 	cmp	x0, x1
  412a58:	54000061 	b.ne	412a64 <z_impl_k_msgq_get+0x1d0>  // b.any
				msgq->write_ptr = msgq->buffer_start;
  412a5c:	f9401660 	ldr	x0, [x19, #40]
  412a60:	f9002260 	str	x0, [x19, #64]
			}
			msgq->used_msgs++;
  412a64:	b9404a60 	ldr	w0, [x19, #72]
  412a68:	11000400 	add	w0, w0, #0x1
  412a6c:	b9004a60 	str	w0, [x19, #72]
	thread->callee_saved.retval = value;
  412a70:	b9004ebf 	str	wzr, [x21, #76]

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
  412a74:	aa1503e0 	mov	x0, x21
			z_reschedule(&msgq->lock, key);

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
  412a78:	52800013 	mov	w19, #0x0                   	// #0
			z_ready_thread(pending_thread);
  412a7c:	9400099b 	bl	4150e8 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
  412a80:	2a1603e1 	mov	w1, w22
  412a84:	aa1403e0 	mov	x0, x20
  412a88:	9400073d 	bl	41477c <z_reschedule>
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
  412a8c:	2a1303e0 	mov	w0, w19
  412a90:	a94153f3 	ldp	x19, x20, [sp, #16]
  412a94:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412a98:	a94363f7 	ldp	x23, x24, [sp, #48]
  412a9c:	a8c47bfd 	ldp	x29, x30, [sp], #64
  412aa0:	d65f03c0 	ret
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  412aa4:	b4000497 	cbz	x23, 412b34 <z_impl_k_msgq_get+0x2a0>
		_current->base.swap_data = data;
  412aa8:	f94712a4 	ldr	x4, [x21, #3616]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  412aac:	aa1703e3 	mov	x3, x23
  412ab0:	aa1303e2 	mov	x2, x19
  412ab4:	2a1603e1 	mov	w1, w22
		_current->base.swap_data = data;
  412ab8:	f9400880 	ldr	x0, [x4, #16]
  412abc:	f9001018 	str	x24, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  412ac0:	aa1403e0 	mov	x0, x20
}
  412ac4:	a94153f3 	ldp	x19, x20, [sp, #16]
  412ac8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412acc:	a94363f7 	ldp	x23, x24, [sp, #48]
  412ad0:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
  412ad4:	14000ace 	b	41560c <z_pend_curr>
		result = 0;
  412ad8:	52800013 	mov	w19, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412adc:	aa1403e0 	mov	x0, x20
  412ae0:	97fffe8a 	bl	412508 <z_spin_unlock_valid>
  412ae4:	72001c1f 	tst	w0, #0xff
  412ae8:	540002a1 	b.ne	412b3c <z_impl_k_msgq_get+0x2a8>  // b.any
  412aec:	f0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  412af0:	912c1273 	add	x19, x19, #0xb04
  412af4:	aa1303e2 	mov	x2, x19
  412af8:	52801863 	mov	w3, #0xc3                  	// #195
  412afc:	f0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  412b00:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412b04:	912d7821 	add	x1, x1, #0xb5e
  412b08:	91178000 	add	x0, x0, #0x5e0
  412b0c:	97ffd0c7 	bl	406e28 <assert_print>
  412b10:	aa1403e1 	mov	x1, x20
  412b14:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  412b18:	912dd400 	add	x0, x0, #0xb75
  412b1c:	97ffd0c3 	bl	406e28 <assert_print>
  412b20:	aa1303e0 	mov	x0, x19
  412b24:	52801861 	mov	w1, #0xc3                  	// #195
  412b28:	97ffd0ea 	bl	406ed0 <assert_post_action>
  412b2c:	52801862 	mov	w2, #0xc3                  	// #195
  412b30:	17ffff77 	b	41290c <z_impl_k_msgq_get+0x78>
		result = -ENOMSG;
  412b34:	12800533 	mov	w19, #0xffffffd6            	// #-42
  412b38:	17ffffe9 	b	412adc <z_impl_k_msgq_get+0x248>
	posix_irq_unlock(key);
  412b3c:	2a1603e0 	mov	w0, w22
  412b40:	97ffd9c2 	bl	409248 <posix_irq_unlock>
	return result;
  412b44:	17ffffd2 	b	412a8c <z_impl_k_msgq_get+0x1f8>

0000000000412b48 <z_impl_k_msgq_purge>:
}
#include <syscalls/k_msgq_peek_at_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
  412b48:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412b4c:	910003fd 	mov	x29, sp
  412b50:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
  412b54:	91004014 	add	x20, x0, #0x10
{
  412b58:	aa0003f3 	mov	x19, x0
  412b5c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  412b60:	97ffd9b8 	bl	409240 <posix_irq_lock>
  412b64:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412b68:	aa1403e0 	mov	x0, x20
  412b6c:	97fffe5c 	bl	4124dc <z_spin_lock_valid>
  412b70:	72001c1f 	tst	w0, #0xff
  412b74:	540002c1 	b.ne	412bcc <z_impl_k_msgq_purge+0x84>  // b.any
  412b78:	f0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  412b7c:	912c1273 	add	x19, x19, #0xb04
  412b80:	aa1303e2 	mov	x2, x19
  412b84:	52801283 	mov	w3, #0x94                  	// #148
  412b88:	f0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  412b8c:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412b90:	912cc421 	add	x1, x1, #0xb31
  412b94:	91178000 	add	x0, x0, #0x5e0
  412b98:	97ffd0a4 	bl	406e28 <assert_print>
  412b9c:	aa1403e1 	mov	x1, x20
  412ba0:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  412ba4:	912d1800 	add	x0, x0, #0xb46
  412ba8:	97ffd0a0 	bl	406e28 <assert_print>
  412bac:	aa1303e0 	mov	x0, x19
  412bb0:	52801281 	mov	w1, #0x94                  	// #148
  412bb4:	97ffd0c7 	bl	406ed0 <assert_post_action>
  412bb8:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412bbc:	aa1303e1 	mov	x1, x19
  412bc0:	91187800 	add	x0, x0, #0x61e
  412bc4:	52801282 	mov	w2, #0x94                  	// #148
  412bc8:	97ffdab4 	bl	409698 <posix_print_error_and_exit>
  412bcc:	12800536 	mov	w22, #0xffffffd6            	// #-42
	z_spin_lock_set_owner(l);
  412bd0:	aa1403e0 	mov	x0, x20
  412bd4:	97fffe5a 	bl	41253c <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, purge, msgq);

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
  412bd8:	aa1303e0 	mov	x0, x19
  412bdc:	94000c94 	bl	415e2c <z_unpend_first_thread>
  412be0:	aa0003e2 	mov	x2, x0
  412be4:	b5000140 	cbnz	x0, 412c0c <z_impl_k_msgq_purge+0xc4>
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
	}

	msgq->used_msgs = 0;
	msgq->read_ptr = msgq->write_ptr;
  412be8:	f9402260 	ldr	x0, [x19, #64]
  412bec:	f9001e60 	str	x0, [x19, #56]
	msgq->used_msgs = 0;
  412bf0:	b9004a7f 	str	wzr, [x19, #72]

	z_reschedule(&msgq->lock, key);
  412bf4:	2a1503e1 	mov	w1, w21
  412bf8:	aa1403e0 	mov	x0, x20
}
  412bfc:	a94153f3 	ldp	x19, x20, [sp, #16]
  412c00:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412c04:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&msgq->lock, key);
  412c08:	140006dd 	b	41477c <z_reschedule>
  412c0c:	b9004c56 	str	w22, [x2, #76]
		z_ready_thread(pending_thread);
  412c10:	94000936 	bl	4150e8 <z_ready_thread>
  412c14:	17fffff1 	b	412bd8 <z_impl_k_msgq_purge+0x90>

0000000000412c18 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
  412c18:	39c06802 	ldrsb	w2, [x0, #26]
  412c1c:	6b01005f 	cmp	w2, w1
  412c20:	54000040 	b.eq	412c28 <adjust_owner_prio.isra.0+0x10>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
  412c24:	14000aea 	b	4157cc <z_set_prio>
	}
	return false;
}
  412c28:	52800000 	mov	w0, #0x0                   	// #0
  412c2c:	d65f03c0 	ret

0000000000412c30 <z_impl_k_mutex_init>:
  412c30:	a9000000 	stp	x0, x0, [x0]
	mutex->owner = NULL;
  412c34:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
  412c38:	b900181f 	str	wzr, [x0, #24]
}
  412c3c:	52800000 	mov	w0, #0x0                   	// #0
  412c40:	d65f03c0 	ret

0000000000412c44 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
  412c44:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  412c48:	910003fd 	mov	x29, sp
  412c4c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return _kernel.cpus[0].nested != 0U;
  412c50:	f00000f5 	adrp	x21, 431000 <__FRAME_END__+0x10804>
  412c54:	f90023f9 	str	x25, [sp, #64]
  412c58:	f94712b9 	ldr	x25, [x21, #3616]
  412c5c:	a90153f3 	stp	x19, x20, [sp, #16]
  412c60:	aa0003f3 	mov	x19, x0
  412c64:	a90363f7 	stp	x23, x24, [sp, #48]
	int new_prio;
	k_spinlock_key_t key;
	bool resched = false;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  412c68:	b9400320 	ldr	w0, [x25]
  412c6c:	340002a0 	cbz	w0, 412cc0 <z_impl_k_mutex_lock+0x7c>
  412c70:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412c74:	910eb273 	add	x19, x19, #0x3ac
  412c78:	aa1303e2 	mov	x2, x19
  412c7c:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  412c80:	910a4421 	add	x1, x1, #0x291
  412c84:	52800ca3 	mov	w3, #0x65                  	// #101
  412c88:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412c8c:	91178000 	add	x0, x0, #0x5e0
  412c90:	97ffd066 	bl	406e28 <assert_print>
  412c94:	90000040 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  412c98:	910f3800 	add	x0, x0, #0x3ce
  412c9c:	97ffd063 	bl	406e28 <assert_print>
  412ca0:	aa1303e0 	mov	x0, x19
  412ca4:	52800ca1 	mov	w1, #0x65                  	// #101
  412ca8:	97ffd08a 	bl	406ed0 <assert_post_action>
  412cac:	52800ca2 	mov	w2, #0x65                  	// #101
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412cb0:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412cb4:	aa1303e1 	mov	x1, x19
  412cb8:	91187800 	add	x0, x0, #0x61e
  412cbc:	97ffda77 	bl	409698 <posix_print_error_and_exit>
  412cc0:	aa0103f8 	mov	x24, x1
  412cc4:	d0000114 	adrp	x20, 434000 <ztest_thread+0xb8>
  412cc8:	97ffd95e 	bl	409240 <posix_irq_lock>
  412ccc:	9120e297 	add	x23, x20, #0x838
  412cd0:	2a0003f6 	mov	w22, w0
  412cd4:	aa1703e0 	mov	x0, x23
  412cd8:	97fffe01 	bl	4124dc <z_spin_lock_valid>
  412cdc:	72001c1f 	tst	w0, #0xff
  412ce0:	54000261 	b.ne	412d2c <z_impl_k_mutex_lock+0xe8>  // b.any
  412ce4:	f0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  412ce8:	912c1273 	add	x19, x19, #0xb04
  412cec:	aa1303e2 	mov	x2, x19
  412cf0:	52801283 	mov	w3, #0x94                  	// #148
  412cf4:	f0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  412cf8:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412cfc:	912cc421 	add	x1, x1, #0xb31
  412d00:	91178000 	add	x0, x0, #0x5e0
  412d04:	97ffd049 	bl	406e28 <assert_print>
  412d08:	9120e281 	add	x1, x20, #0x838
  412d0c:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  412d10:	912d1800 	add	x0, x0, #0xb46
  412d14:	97ffd045 	bl	406e28 <assert_print>
  412d18:	aa1303e0 	mov	x0, x19
  412d1c:	52801281 	mov	w1, #0x94                  	// #148
  412d20:	97ffd06c 	bl	406ed0 <assert_post_action>
  412d24:	52801282 	mov	w2, #0x94                  	// #148
  412d28:	17ffffe2 	b	412cb0 <z_impl_k_mutex_lock+0x6c>
	z_spin_lock_set_owner(l);
  412d2c:	aa1703e0 	mov	x0, x23
  412d30:	97fffe03 	bl	41253c <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
  412d34:	b9401a61 	ldr	w1, [x19, #24]
  412d38:	340001c1 	cbz	w1, 412d70 <z_impl_k_mutex_lock+0x12c>
  412d3c:	f9400a60 	ldr	x0, [x19, #16]
  412d40:	f9400b22 	ldr	x2, [x25, #16]
  412d44:	eb02001f 	cmp	x0, x2
  412d48:	540004e0 	b.eq	412de4 <z_impl_k_mutex_lock+0x1a0>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
  412d4c:	b5000638 	cbnz	x24, 412e10 <z_impl_k_mutex_lock+0x1cc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412d50:	aa1703e0 	mov	x0, x23
  412d54:	97fffded 	bl	412508 <z_spin_unlock_valid>
  412d58:	72001c1f 	tst	w0, #0xff
  412d5c:	54000200 	b.eq	412d9c <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  412d60:	2a1603e0 	mov	w0, w22
  412d64:	97ffd939 	bl	409248 <posix_irq_unlock>
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
  412d68:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  412d6c:	14000023 	b	412df8 <z_impl_k_mutex_lock+0x1b4>
					_current->base.prio :
  412d70:	f9400b20 	ldr	x0, [x25, #16]
  412d74:	39c06800 	ldrsb	w0, [x0, #26]
		mutex->owner = _current;
  412d78:	f94712b5 	ldr	x21, [x21, #3616]
		mutex->lock_count++;
  412d7c:	11000421 	add	w1, w1, #0x1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
  412d80:	29030261 	stp	w1, w0, [x19, #24]
		mutex->owner = _current;
  412d84:	f9400aa0 	ldr	x0, [x21, #16]
  412d88:	f9000a60 	str	x0, [x19, #16]
  412d8c:	9120e280 	add	x0, x20, #0x838
  412d90:	97fffdde 	bl	412508 <z_spin_unlock_valid>
  412d94:	72001c1f 	tst	w0, #0xff
  412d98:	540002a1 	b.ne	412dec <z_impl_k_mutex_lock+0x1a8>  // b.any
  412d9c:	f0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  412da0:	912c1273 	add	x19, x19, #0xb04
  412da4:	aa1303e2 	mov	x2, x19
  412da8:	52801863 	mov	w3, #0xc3                  	// #195
  412dac:	f0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  412db0:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412db4:	912d7821 	add	x1, x1, #0xb5e
  412db8:	91178000 	add	x0, x0, #0x5e0
  412dbc:	97ffd01b 	bl	406e28 <assert_print>
  412dc0:	9120e281 	add	x1, x20, #0x838
  412dc4:	f0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  412dc8:	912dd400 	add	x0, x0, #0xb75
  412dcc:	97ffd017 	bl	406e28 <assert_print>
  412dd0:	aa1303e0 	mov	x0, x19
  412dd4:	52801861 	mov	w1, #0xc3                  	// #195
  412dd8:	97ffd03e 	bl	406ed0 <assert_post_action>
  412ddc:	52801862 	mov	w2, #0xc3                  	// #195
  412de0:	17ffffb4 	b	412cb0 <z_impl_k_mutex_lock+0x6c>
					_current->base.prio :
  412de4:	b9401e60 	ldr	w0, [x19, #28]
  412de8:	17ffffe4 	b	412d78 <z_impl_k_mutex_lock+0x134>
  412dec:	2a1603e0 	mov	w0, w22
  412df0:	97ffd916 	bl	409248 <posix_irq_unlock>
		return 0;
  412df4:	52800000 	mov	w0, #0x0                   	// #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
  412df8:	a94153f3 	ldp	x19, x20, [sp, #16]
  412dfc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  412e00:	a94363f7 	ldp	x23, x24, [sp, #48]
  412e04:	f94023f9 	ldr	x25, [sp, #64]
  412e08:	a8c57bfd 	ldp	x29, x30, [sp], #80
  412e0c:	d65f03c0 	ret
	new_prio = new_prio_for_inheritance(_current->base.prio,
  412e10:	39c06842 	ldrsb	w2, [x2, #26]
  412e14:	39c06803 	ldrsb	w3, [x0, #26]
  412e18:	6b03005f 	cmp	w2, w3
  412e1c:	1a83d041 	csel	w1, w2, w3, le
  412e20:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  412e24:	3101fc3f 	cmn	w1, #0x7f
  412e28:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
  412e2c:	6b01007f 	cmp	w3, w1
  412e30:	5400050d 	b.le	412ed0 <z_impl_k_mutex_lock+0x28c>
		resched = adjust_owner_prio(mutex, new_prio);
  412e34:	97ffff79 	bl	412c18 <adjust_owner_prio.isra.0>
  412e38:	12001c17 	and	w23, w0, #0xff
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
  412e3c:	9120e299 	add	x25, x20, #0x838
  412e40:	aa1803e3 	mov	x3, x24
  412e44:	aa1303e2 	mov	x2, x19
  412e48:	2a1603e1 	mov	w1, w22
  412e4c:	aa1903e0 	mov	x0, x25
  412e50:	940009ef 	bl	41560c <z_pend_curr>
	if (got_mutex == 0) {
  412e54:	34fffd20 	cbz	w0, 412df8 <z_impl_k_mutex_lock+0x1b4>
	return posix_irq_lock();
  412e58:	97ffd8fa 	bl	409240 <posix_irq_lock>
  412e5c:	2a0003f5 	mov	w21, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412e60:	aa1903e0 	mov	x0, x25
  412e64:	97fffd9e 	bl	4124dc <z_spin_lock_valid>
  412e68:	72001c1f 	tst	w0, #0xff
  412e6c:	54fff3c0 	b.eq	412ce4 <z_impl_k_mutex_lock+0xa0>  // b.none
	z_spin_lock_set_owner(l);
  412e70:	aa1903e0 	mov	x0, x25
  412e74:	97fffdb2 	bl	41253c <z_spin_lock_set_owner>
	if (likely(mutex->owner != NULL)) {
  412e78:	f9400a60 	ldr	x0, [x19, #16]
  412e7c:	b40001e0 	cbz	x0, 412eb8 <z_impl_k_mutex_lock+0x274>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  412e80:	f9400262 	ldr	x2, [x19]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
  412e84:	b9401e61 	ldr	w1, [x19, #28]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  412e88:	eb02027f 	cmp	x19, x2
  412e8c:	54000100 	b.eq	412eac <z_impl_k_mutex_lock+0x268>  // b.none
  412e90:	b40000e2 	cbz	x2, 412eac <z_impl_k_mutex_lock+0x268>
  412e94:	39c06842 	ldrsb	w2, [x2, #26]
  412e98:	6b02003f 	cmp	w1, w2
  412e9c:	1a82d021 	csel	w1, w1, w2, le
  412ea0:	12800fc2 	mov	w2, #0xffffff81            	// #-127
  412ea4:	3101fc3f 	cmn	w1, #0x7f
  412ea8:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
		resched = adjust_owner_prio(mutex, new_prio) || resched;
  412eac:	97ffff5b 	bl	412c18 <adjust_owner_prio.isra.0>
  412eb0:	72001c1f 	tst	w0, #0xff
  412eb4:	54000041 	b.ne	412ebc <z_impl_k_mutex_lock+0x278>  // b.any
	if (resched) {
  412eb8:	34000117 	cbz	w23, 412ed8 <z_impl_k_mutex_lock+0x294>
		z_reschedule(&lock, key);
  412ebc:	2a1503e1 	mov	w1, w21
  412ec0:	9120e280 	add	x0, x20, #0x838
  412ec4:	9400062e 	bl	41477c <z_reschedule>
	return -EAGAIN;
  412ec8:	12800140 	mov	w0, #0xfffffff5            	// #-11
  412ecc:	17ffffcb 	b	412df8 <z_impl_k_mutex_lock+0x1b4>
	bool resched = false;
  412ed0:	52800017 	mov	w23, #0x0                   	// #0
  412ed4:	17ffffda 	b	412e3c <z_impl_k_mutex_lock+0x1f8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  412ed8:	9120e280 	add	x0, x20, #0x838
  412edc:	97fffd8b 	bl	412508 <z_spin_unlock_valid>
  412ee0:	72001c1f 	tst	w0, #0xff
  412ee4:	54fff5c0 	b.eq	412d9c <z_impl_k_mutex_lock+0x158>  // b.none
	posix_irq_unlock(key);
  412ee8:	2a1503e0 	mov	w0, w21
  412eec:	97ffd8d7 	bl	409248 <posix_irq_unlock>
  412ef0:	17fffff6 	b	412ec8 <z_impl_k_mutex_lock+0x284>

0000000000412ef4 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
  412ef4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  412ef8:	910003fd 	mov	x29, sp
  412efc:	a90153f3 	stp	x19, x20, [sp, #16]
  412f00:	aa0003f3 	mov	x19, x0
  412f04:	f00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  412f08:	f90013f5 	str	x21, [sp, #32]
  412f0c:	f9471000 	ldr	x0, [x0, #3616]
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");
  412f10:	b9400001 	ldr	w1, [x0]
  412f14:	340002a1 	cbz	w1, 412f68 <z_impl_k_mutex_unlock+0x74>
  412f18:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412f1c:	910eb273 	add	x19, x19, #0x3ac
  412f20:	aa1303e2 	mov	x2, x19
  412f24:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  412f28:	910a4421 	add	x1, x1, #0x291
  412f2c:	528019a3 	mov	w3, #0xcd                  	// #205
  412f30:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412f34:	91178000 	add	x0, x0, #0x5e0
  412f38:	97ffcfbc 	bl	406e28 <assert_print>
  412f3c:	90000040 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  412f40:	910f3800 	add	x0, x0, #0x3ce
  412f44:	97ffcfb9 	bl	406e28 <assert_print>
  412f48:	aa1303e0 	mov	x0, x19
  412f4c:	528019a1 	mov	w1, #0xcd                  	// #205
  412f50:	97ffcfe0 	bl	406ed0 <assert_post_action>
  412f54:	528019a2 	mov	w2, #0xcd                  	// #205
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  412f58:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412f5c:	aa1303e1 	mov	x1, x19
  412f60:	91187800 	add	x0, x0, #0x61e
  412f64:	97ffd9cd 	bl	409698 <posix_print_error_and_exit>
	CHECKIF(mutex->owner == NULL) {
  412f68:	f9400a61 	ldr	x1, [x19, #16]
  412f6c:	b4000c41 	cbz	x1, 4130f4 <z_impl_k_mutex_unlock+0x200>
	CHECKIF(mutex->owner != _current) {
  412f70:	f9400800 	ldr	x0, [x0, #16]
  412f74:	eb00003f 	cmp	x1, x0
  412f78:	54000c21 	b.ne	4130fc <z_impl_k_mutex_unlock+0x208>  // b.any
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
  412f7c:	b9401a60 	ldr	w0, [x19, #24]
  412f80:	350001e0 	cbnz	w0, 412fbc <z_impl_k_mutex_unlock+0xc8>
  412f84:	90000053 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  412f88:	910eb273 	add	x19, x19, #0x3ac
  412f8c:	aa1303e2 	mov	x2, x19
  412f90:	52801ca3 	mov	w3, #0xe5                  	// #229
  412f94:	90000041 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  412f98:	d0000020 	adrp	x0, 418000 <table.0+0x1d8>
  412f9c:	910fcc21 	add	x1, x1, #0x3f3
  412fa0:	91178000 	add	x0, x0, #0x5e0
  412fa4:	97ffcfa1 	bl	406e28 <assert_print>
  412fa8:	aa1303e0 	mov	x0, x19
  412fac:	52801ca1 	mov	w1, #0xe5                  	// #229
  412fb0:	97ffcfc8 	bl	406ed0 <assert_post_action>
  412fb4:	52801ca2 	mov	w2, #0xe5                  	// #229
  412fb8:	17ffffe8 	b	412f58 <z_impl_k_mutex_unlock+0x64>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
  412fbc:	7100041f 	cmp	w0, #0x1
  412fc0:	54000100 	b.eq	412fe0 <z_impl_k_mutex_unlock+0xec>  // b.none
		mutex->lock_count--;
  412fc4:	51000400 	sub	w0, w0, #0x1
  412fc8:	b9001a60 	str	w0, [x19, #24]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
  412fcc:	52800000 	mov	w0, #0x0                   	// #0
}
  412fd0:	a94153f3 	ldp	x19, x20, [sp, #16]
  412fd4:	f94013f5 	ldr	x21, [sp, #32]
  412fd8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  412fdc:	d65f03c0 	ret
	return posix_irq_lock();
  412fe0:	97ffd898 	bl	409240 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  412fe4:	d0000114 	adrp	x20, 434000 <ztest_thread+0xb8>
  412fe8:	9120e294 	add	x20, x20, #0x838
  412fec:	2a0003f5 	mov	w21, w0
  412ff0:	aa1403e0 	mov	x0, x20
  412ff4:	97fffd3a 	bl	4124dc <z_spin_lock_valid>
  412ff8:	72001c1f 	tst	w0, #0xff
  412ffc:	54000261 	b.ne	413048 <z_impl_k_mutex_unlock+0x154>  // b.any
  413000:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413004:	912c1273 	add	x19, x19, #0xb04
  413008:	aa1303e2 	mov	x2, x19
  41300c:	52801283 	mov	w3, #0x94                  	// #148
  413010:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413014:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413018:	912cc421 	add	x1, x1, #0xb31
  41301c:	91178000 	add	x0, x0, #0x5e0
  413020:	97ffcf82 	bl	406e28 <assert_print>
  413024:	aa1403e1 	mov	x1, x20
  413028:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  41302c:	912d1800 	add	x0, x0, #0xb46
  413030:	97ffcf7e 	bl	406e28 <assert_print>
  413034:	aa1303e0 	mov	x0, x19
  413038:	52801281 	mov	w1, #0x94                  	// #148
  41303c:	97ffcfa5 	bl	406ed0 <assert_post_action>
  413040:	52801282 	mov	w2, #0x94                  	// #148
  413044:	17ffffc5 	b	412f58 <z_impl_k_mutex_unlock+0x64>
	z_spin_lock_set_owner(l);
  413048:	aa1403e0 	mov	x0, x20
  41304c:	97fffd3c 	bl	41253c <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
  413050:	b9401e61 	ldr	w1, [x19, #28]
  413054:	f9400a60 	ldr	x0, [x19, #16]
  413058:	97fffef0 	bl	412c18 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
  41305c:	aa1303e0 	mov	x0, x19
  413060:	94000b73 	bl	415e2c <z_unpend_first_thread>
	mutex->owner = new_owner;
  413064:	f9000a60 	str	x0, [x19, #16]
	if (new_owner != NULL) {
  413068:	b4000120 	cbz	x0, 41308c <z_impl_k_mutex_unlock+0x198>
		mutex->owner_orig_prio = new_owner->base.prio;
  41306c:	39c06801 	ldrsb	w1, [x0, #26]
  413070:	b9001e61 	str	w1, [x19, #28]
	thread->callee_saved.retval = value;
  413074:	b9004c1f 	str	wzr, [x0, #76]
		z_ready_thread(new_owner);
  413078:	9400081c 	bl	4150e8 <z_ready_thread>
		z_reschedule(&lock, key);
  41307c:	2a1503e1 	mov	w1, w21
  413080:	aa1403e0 	mov	x0, x20
  413084:	940005be 	bl	41477c <z_reschedule>
  413088:	17ffffd1 	b	412fcc <z_impl_k_mutex_unlock+0xd8>
		mutex->lock_count = 0U;
  41308c:	b9001a7f 	str	wzr, [x19, #24]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413090:	aa1403e0 	mov	x0, x20
  413094:	97fffd1d 	bl	412508 <z_spin_unlock_valid>
  413098:	72001c1f 	tst	w0, #0xff
  41309c:	54000261 	b.ne	4130e8 <z_impl_k_mutex_unlock+0x1f4>  // b.any
  4130a0:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  4130a4:	912c1273 	add	x19, x19, #0xb04
  4130a8:	aa1303e2 	mov	x2, x19
  4130ac:	52801863 	mov	w3, #0xc3                  	// #195
  4130b0:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4130b4:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4130b8:	912d7821 	add	x1, x1, #0xb5e
  4130bc:	91178000 	add	x0, x0, #0x5e0
  4130c0:	97ffcf5a 	bl	406e28 <assert_print>
  4130c4:	aa1403e1 	mov	x1, x20
  4130c8:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4130cc:	912dd400 	add	x0, x0, #0xb75
  4130d0:	97ffcf56 	bl	406e28 <assert_print>
  4130d4:	aa1303e0 	mov	x0, x19
  4130d8:	52801861 	mov	w1, #0xc3                  	// #195
  4130dc:	97ffcf7d 	bl	406ed0 <assert_post_action>
  4130e0:	52801862 	mov	w2, #0xc3                  	// #195
  4130e4:	17ffff9d 	b	412f58 <z_impl_k_mutex_unlock+0x64>
	posix_irq_unlock(key);
  4130e8:	2a1503e0 	mov	w0, w21
  4130ec:	97ffd857 	bl	409248 <posix_irq_unlock>
  4130f0:	17ffffb7 	b	412fcc <z_impl_k_mutex_unlock+0xd8>
		return -EINVAL;
  4130f4:	128002a0 	mov	w0, #0xffffffea            	// #-22
  4130f8:	17ffffb6 	b	412fd0 <z_impl_k_mutex_unlock+0xdc>
		return -EPERM;
  4130fc:	12800000 	mov	w0, #0xffffffff            	// #-1
  413100:	17ffffb4 	b	412fd0 <z_impl_k_mutex_unlock+0xdc>

0000000000413104 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static int32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			    bool alloc, bool is_append)
{
  413104:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  413108:	910003fd 	mov	x29, sp
  41310c:	a90153f3 	stp	x19, x20, [sp, #16]
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  413110:	91004014 	add	x20, x0, #0x10
{
  413114:	aa0003f3 	mov	x19, x0
  413118:	a9025bf5 	stp	x21, x22, [sp, #32]
  41311c:	aa0103f5 	mov	x21, x1
  413120:	a90363f7 	stp	x23, x24, [sp, #48]
  413124:	aa0203f7 	mov	x23, x2
  413128:	12001c78 	and	w24, w3, #0xff
  41312c:	f90023f9 	str	x25, [sp, #64]
  413130:	12001c99 	and	w25, w4, #0xff
	return posix_irq_lock();
  413134:	97ffd843 	bl	409240 <posix_irq_lock>
  413138:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41313c:	aa1403e0 	mov	x0, x20
  413140:	97fffce7 	bl	4124dc <z_spin_lock_valid>
  413144:	72001c1f 	tst	w0, #0xff
  413148:	540002c1 	b.ne	4131a0 <queue_insert+0x9c>  // b.any
  41314c:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413150:	912c1273 	add	x19, x19, #0xb04
  413154:	aa1303e2 	mov	x2, x19
  413158:	52801283 	mov	w3, #0x94                  	// #148
  41315c:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413160:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413164:	912cc421 	add	x1, x1, #0xb31
  413168:	91178000 	add	x0, x0, #0x5e0
  41316c:	97ffcf2f 	bl	406e28 <assert_print>
  413170:	aa1403e1 	mov	x1, x20
  413174:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413178:	912d1800 	add	x0, x0, #0xb46
  41317c:	97ffcf2b 	bl	406e28 <assert_print>
  413180:	aa1303e0 	mov	x0, x19
  413184:	52801281 	mov	w1, #0x94                  	// #148
  413188:	97ffcf52 	bl	406ed0 <assert_post_action>
  41318c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413190:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413194:	aa1303e1 	mov	x1, x19
  413198:	91187800 	add	x0, x0, #0x61e
  41319c:	97ffd93f 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4131a0:	aa1403e0 	mov	x0, x20
  4131a4:	97fffce6 	bl	41253c <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, queue_insert, queue, alloc);

	if (is_append) {
  4131a8:	34000059 	cbz	w25, 4131b0 <queue_insert+0xac>
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
  4131ac:	f9400675 	ldr	x21, [x19, #8]
		prev = sys_sflist_peek_tail(&queue->data_q);
	}
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
  4131b0:	91006260 	add	x0, x19, #0x18
  4131b4:	94000b1e 	bl	415e2c <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
  4131b8:	b4000120 	cbz	x0, 4131dc <queue_insert+0xd8>
  4131bc:	f9001017 	str	x23, [x0, #32]
  4131c0:	b9004c1f 	str	wzr, [x0, #76]
	z_ready_thread(thread);
  4131c4:	940007c9 	bl	4150e8 <z_ready_thread>

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, queue_insert, queue, alloc, K_FOREVER);

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
  4131c8:	aa1403e0 	mov	x0, x20
  4131cc:	2a1603e1 	mov	w1, w22
  4131d0:	9400056b 	bl	41477c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, queue_insert, queue, alloc, 0);

	return 0;
  4131d4:	52800000 	mov	w0, #0x0                   	// #0
  4131d8:	1400001f 	b	413254 <queue_insert+0x150>
	if (alloc) {
  4131dc:	34000638 	cbz	w24, 4132a0 <queue_insert+0x19c>
	return z_thread_aligned_alloc(0, size);
  4131e0:	d2800201 	mov	x1, #0x10                  	// #16
  4131e4:	94001293 	bl	417c30 <z_thread_aligned_alloc>
  4131e8:	aa0003e3 	mov	x3, x0
		if (anode == NULL) {
  4131ec:	b5000400 	cbnz	x0, 41326c <queue_insert+0x168>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4131f0:	aa1403e0 	mov	x0, x20
  4131f4:	97fffcc5 	bl	412508 <z_spin_unlock_valid>
  4131f8:	72001c1f 	tst	w0, #0xff
  4131fc:	54000261 	b.ne	413248 <queue_insert+0x144>  // b.any
  413200:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413204:	912c1273 	add	x19, x19, #0xb04
  413208:	aa1303e2 	mov	x2, x19
  41320c:	52801863 	mov	w3, #0xc3                  	// #195
  413210:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413214:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413218:	912d7821 	add	x1, x1, #0xb5e
  41321c:	91178000 	add	x0, x0, #0x5e0
  413220:	97ffcf02 	bl	406e28 <assert_print>
  413224:	aa1403e1 	mov	x1, x20
  413228:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  41322c:	912dd400 	add	x0, x0, #0xb75
  413230:	97ffcefe 	bl	406e28 <assert_print>
  413234:	aa1303e0 	mov	x0, x19
  413238:	52801861 	mov	w1, #0xc3                  	// #195
  41323c:	97ffcf25 	bl	406ed0 <assert_post_action>
  413240:	52801862 	mov	w2, #0xc3                  	// #195
  413244:	17ffffd3 	b	413190 <queue_insert+0x8c>
	posix_irq_unlock(key);
  413248:	2a1603e0 	mov	w0, w22
  41324c:	97ffd7ff 	bl	409248 <posix_irq_unlock>
			return -ENOMEM;
  413250:	12800160 	mov	w0, #0xfffffff4            	// #-12
}
  413254:	a94153f3 	ldp	x19, x20, [sp, #16]
  413258:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41325c:	a94363f7 	ldp	x23, x24, [sp, #48]
  413260:	f94023f9 	ldr	x25, [sp, #64]
  413264:	a8c57bfd 	ldp	x29, x30, [sp], #80
  413268:	d65f03c0 	ret
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, uint8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
  41326c:	d2800020 	mov	x0, #0x1                   	// #1
		anode->data = data;
  413270:	a9005c60 	stp	x0, x23, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  413274:	f9400060 	ldr	x0, [x3]
	parent->next_and_flags = cur_flags | (unative_t)child;
  413278:	92400400 	and	x0, x0, #0x3
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
  41327c:	b5000195 	cbnz	x21, 4132ac <queue_insert+0x1a8>
	parent->next_and_flags = cur_flags | (unative_t)child;
  413280:	f9400261 	ldr	x1, [x19]
  413284:	aa000020 	orr	x0, x1, x0
  413288:	f9000060 	str	x0, [x3]
	list->head = node;
  41328c:	f9000263 	str	x3, [x19]
Z_GENLIST_PREPEND(sflist, sfnode)
  413290:	f9400660 	ldr	x0, [x19, #8]
  413294:	b50001a0 	cbnz	x0, 4132c8 <queue_insert+0x1c4>
	list->tail = node;
  413298:	f9000663 	str	x3, [x19, #8]
}
  41329c:	1400000b 	b	4132c8 <queue_insert+0x1c4>
}
  4132a0:	aa1703e3 	mov	x3, x23
	node->next_and_flags = flags;
  4132a4:	f90002ff 	str	xzr, [x23]
}
  4132a8:	17fffff3 	b	413274 <queue_insert+0x170>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  4132ac:	f94002a2 	ldr	x2, [x21]
Z_GENLIST_INSERT(sflist, sfnode)
  4132b0:	f27ef442 	ands	x2, x2, #0xfffffffffffffffc
  4132b4:	540001c1 	b.ne	4132ec <queue_insert+0x1e8>  // b.any
	parent->next_and_flags = cur_flags | (unative_t)child;
  4132b8:	f9000060 	str	x0, [x3]
	return list->tail;
  4132bc:	f9400661 	ldr	x1, [x19, #8]
Z_GENLIST_APPEND(sflist, sfnode)
  4132c0:	b50000c1 	cbnz	x1, 4132d8 <queue_insert+0x1d4>
	list->tail = node;
  4132c4:	a9000e63 	stp	x3, x3, [x19]
	z_handle_obj_poll_events(&queue->poll_events, state);
  4132c8:	9100a260 	add	x0, x19, #0x28
  4132cc:	52800081 	mov	w1, #0x4                   	// #4
  4132d0:	9400115b 	bl	41783c <z_handle_obj_poll_events>
  4132d4:	17ffffbd 	b	4131c8 <queue_insert+0xc4>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  4132d8:	f9400020 	ldr	x0, [x1]
	parent->next_and_flags = cur_flags | (unative_t)child;
  4132dc:	92400400 	and	x0, x0, #0x3
  4132e0:	aa000060 	orr	x0, x3, x0
  4132e4:	f9000020 	str	x0, [x1]
  4132e8:	17ffffec 	b	413298 <queue_insert+0x194>
  4132ec:	aa000042 	orr	x2, x2, x0
  4132f0:	f9000062 	str	x2, [x3]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  4132f4:	f94002a0 	ldr	x0, [x21]
	parent->next_and_flags = cur_flags | (unative_t)child;
  4132f8:	92400400 	and	x0, x0, #0x3
  4132fc:	aa000063 	orr	x3, x3, x0
  413300:	f90002a3 	str	x3, [x21]
}
  413304:	17fffff1 	b	4132c8 <queue_insert+0x1c4>

0000000000413308 <z_queue_node_peek>:
{
  413308:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  41330c:	910003fd 	mov	x29, sp
  413310:	f9000bf3 	str	x19, [sp, #16]
  413314:	aa0003f3 	mov	x19, x0
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
  413318:	b4000100 	cbz	x0, 413338 <z_queue_node_peek+0x30>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
  41331c:	f9400003 	ldr	x3, [x0]
  413320:	f240047f 	tst	x3, #0x3
  413324:	540000a0 	b.eq	413338 <z_queue_node_peek+0x30>  // b.none
  413328:	12001c21 	and	w1, w1, #0xff
		ret = anode->data;
  41332c:	f9400413 	ldr	x19, [x0, #8]
		if (needs_free) {
  413330:	34000041 	cbz	w1, 413338 <z_queue_node_peek+0x30>
			k_free(anode);
  413334:	9400123a 	bl	417c1c <k_free>
}
  413338:	aa1303e0 	mov	x0, x19
  41333c:	f9400bf3 	ldr	x19, [sp, #16]
  413340:	a8c27bfd 	ldp	x29, x30, [sp], #32
  413344:	d65f03c0 	ret

0000000000413348 <k_queue_prepend>:

void k_queue_prepend(struct k_queue *queue, void *data)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, prepend, queue);

	(void)queue_insert(queue, NULL, data, false, false);
  413348:	aa0103e2 	mov	x2, x1
  41334c:	52800004 	mov	w4, #0x0                   	// #0
  413350:	52800003 	mov	w3, #0x0                   	// #0
  413354:	d2800001 	mov	x1, #0x0                   	// #0
  413358:	17ffff6b 	b	413104 <queue_insert>

000000000041335c <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
  41335c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  413360:	910003fd 	mov	x29, sp
  413364:	a90153f3 	stp	x19, x20, [sp, #16]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
  413368:	91004014 	add	x20, x0, #0x10
{
  41336c:	a9025bf5 	stp	x21, x22, [sp, #32]
  413370:	aa0003f5 	mov	x21, x0
  413374:	f9001bf7 	str	x23, [sp, #48]
  413378:	aa0103f7 	mov	x23, x1
	return posix_irq_lock();
  41337c:	97ffd7b1 	bl	409240 <posix_irq_lock>
  413380:	2a0003f6 	mov	w22, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413384:	aa1403e0 	mov	x0, x20
  413388:	97fffc55 	bl	4124dc <z_spin_lock_valid>
  41338c:	72001c1f 	tst	w0, #0xff
  413390:	540002c1 	b.ne	4133e8 <z_impl_k_queue_get+0x8c>  // b.any
  413394:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413398:	912c1273 	add	x19, x19, #0xb04
  41339c:	aa1303e2 	mov	x2, x19
  4133a0:	52801283 	mov	w3, #0x94                  	// #148
  4133a4:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4133a8:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4133ac:	912cc421 	add	x1, x1, #0xb31
  4133b0:	91178000 	add	x0, x0, #0x5e0
  4133b4:	97ffce9d 	bl	406e28 <assert_print>
  4133b8:	aa1403e1 	mov	x1, x20
  4133bc:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4133c0:	912d1800 	add	x0, x0, #0xb46
  4133c4:	97ffce99 	bl	406e28 <assert_print>
  4133c8:	aa1303e0 	mov	x0, x19
  4133cc:	52801281 	mov	w1, #0x94                  	// #148
  4133d0:	97ffcec0 	bl	406ed0 <assert_post_action>
  4133d4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4133d8:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4133dc:	aa1303e1 	mov	x1, x19
  4133e0:	91187800 	add	x0, x0, #0x61e
  4133e4:	97ffd8ad 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4133e8:	aa1403e0 	mov	x0, x20
  4133ec:	97fffc54 	bl	41253c <z_spin_lock_set_owner>
	return list->head;
  4133f0:	f94002b3 	ldr	x19, [x21]
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
  4133f4:	b4000453 	cbz	x19, 41347c <z_impl_k_queue_get+0x120>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  4133f8:	f9400260 	ldr	x0, [x19]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  4133fc:	f94006a1 	ldr	x1, [x21, #8]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
  413400:	927ef400 	and	x0, x0, #0xfffffffffffffffc
	list->head = node;
  413404:	f90002a0 	str	x0, [x21]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
  413408:	eb01027f 	cmp	x19, x1
  41340c:	54000041 	b.ne	413414 <z_impl_k_queue_get+0xb8>  // b.any
	list->tail = node;
  413410:	f90006a0 	str	x0, [x21, #8]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
  413414:	aa1303e0 	mov	x0, x19
  413418:	52800021 	mov	w1, #0x1                   	// #1
  41341c:	97ffffbb 	bl	413308 <z_queue_node_peek>
  413420:	aa0003f3 	mov	x19, x0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413424:	aa1403e0 	mov	x0, x20
  413428:	97fffc38 	bl	412508 <z_spin_unlock_valid>
  41342c:	72001c1f 	tst	w0, #0xff
  413430:	540003e1 	b.ne	4134ac <z_impl_k_queue_get+0x150>  // b.any
  413434:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413438:	912c1273 	add	x19, x19, #0xb04
  41343c:	aa1303e2 	mov	x2, x19
  413440:	52801863 	mov	w3, #0xc3                  	// #195
  413444:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413448:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  41344c:	912d7821 	add	x1, x1, #0xb5e
  413450:	91178000 	add	x0, x0, #0x5e0
  413454:	97ffce75 	bl	406e28 <assert_print>
  413458:	aa1403e1 	mov	x1, x20
  41345c:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413460:	912dd400 	add	x0, x0, #0xb75
  413464:	97ffce71 	bl	406e28 <assert_print>
  413468:	aa1303e0 	mov	x0, x19
  41346c:	52801861 	mov	w1, #0xc3                  	// #195
  413470:	97ffce98 	bl	406ed0 <assert_post_action>
  413474:	52801862 	mov	w2, #0xc3                  	// #195
  413478:	17ffffd8 	b	4133d8 <z_impl_k_queue_get+0x7c>
		return data;
	}

	SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_queue, get, queue, timeout);

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  41347c:	b4fffd57 	cbz	x23, 413424 <z_impl_k_queue_get+0xc8>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout, NULL);

		return NULL;
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
  413480:	aa1703e3 	mov	x3, x23
  413484:	910062a2 	add	x2, x21, #0x18
  413488:	2a1603e1 	mov	w1, w22
  41348c:	aa1403e0 	mov	x0, x20
  413490:	9400085f 	bl	41560c <z_pend_curr>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
  413494:	35000100 	cbnz	w0, 4134b4 <z_impl_k_queue_get+0x158>
  413498:	d00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  41349c:	f9471000 	ldr	x0, [x0, #3616]
  4134a0:	f9400800 	ldr	x0, [x0, #16]
  4134a4:	f9401013 	ldr	x19, [x0, #32]
  4134a8:	14000003 	b	4134b4 <z_impl_k_queue_get+0x158>
	posix_irq_unlock(key);
  4134ac:	2a1603e0 	mov	w0, w22
  4134b0:	97ffd766 	bl	409248 <posix_irq_unlock>
}
  4134b4:	aa1303e0 	mov	x0, x19
  4134b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4134bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4134c0:	f9401bf7 	ldr	x23, [sp, #48]
  4134c4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4134c8:	d65f03c0 	ret

00000000004134cc <z_impl_k_sem_init>:
		      unsigned int limit)
{
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
  4134cc:	7100005f 	cmp	w2, #0x0
  4134d0:	7a411040 	ccmp	w2, w1, #0x0, ne  // ne = any
  4134d4:	540000e3 	b.cc	4134f0 <z_impl_k_sem_init+0x24>  // b.lo, b.ul, b.last
	list->tail = (sys_dnode_t *)list;
  4134d8:	a9000000 	stp	x0, x0, [x0]

		return -EINVAL;
	}

	sem->count = initial_count;
	sem->limit = limit;
  4134dc:	29020801 	stp	w1, w2, [x0, #16]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, init, sem, 0);

	z_waitq_init(&sem->wait_q);
#if defined(CONFIG_POLL)
	sys_dlist_init(&sem->poll_events);
  4134e0:	91006001 	add	x1, x0, #0x18
  4134e4:	a9018401 	stp	x1, x1, [x0, #24]
#endif
	z_object_init(sem);

	return 0;
  4134e8:	52800000 	mov	w0, #0x0                   	// #0
}
  4134ec:	d65f03c0 	ret
		return -EINVAL;
  4134f0:	128002a0 	mov	w0, #0xffffffea            	// #-22
  4134f4:	17fffffe 	b	4134ec <z_impl_k_sem_init+0x20>

00000000004134f8 <z_impl_k_sem_give>:
	return false;
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
  4134f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4134fc:	910003fd 	mov	x29, sp
  413500:	a90153f3 	stp	x19, x20, [sp, #16]
  413504:	aa0003f3 	mov	x19, x0
  413508:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  41350c:	97ffd74d 	bl	409240 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413510:	b0000116 	adrp	x22, 434000 <ztest_thread+0xb8>
  413514:	912102d5 	add	x21, x22, #0x840
  413518:	2a0003f4 	mov	w20, w0
  41351c:	aa1503e0 	mov	x0, x21
  413520:	97fffbef 	bl	4124dc <z_spin_lock_valid>
  413524:	72001c1f 	tst	w0, #0xff
  413528:	540002c1 	b.ne	413580 <z_impl_k_sem_give+0x88>  // b.any
  41352c:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413530:	912c1273 	add	x19, x19, #0xb04
  413534:	aa1303e2 	mov	x2, x19
  413538:	52801283 	mov	w3, #0x94                  	// #148
  41353c:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413540:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413544:	912cc421 	add	x1, x1, #0xb31
  413548:	91178000 	add	x0, x0, #0x5e0
  41354c:	97ffce37 	bl	406e28 <assert_print>
  413550:	aa1503e1 	mov	x1, x21
  413554:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413558:	912d1800 	add	x0, x0, #0xb46
  41355c:	97ffce33 	bl	406e28 <assert_print>
  413560:	aa1303e0 	mov	x0, x19
  413564:	52801281 	mov	w1, #0x94                  	// #148
  413568:	97ffce5a 	bl	406ed0 <assert_post_action>
  41356c:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413570:	aa1303e1 	mov	x1, x19
  413574:	91187800 	add	x0, x0, #0x61e
  413578:	52801282 	mov	w2, #0x94                  	// #148
  41357c:	97ffd847 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413580:	aa1503e0 	mov	x0, x21
  413584:	97fffbee 	bl	41253c <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool resched = true;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
  413588:	aa1303e0 	mov	x0, x19
  41358c:	94000a28 	bl	415e2c <z_unpend_first_thread>

	if (thread != NULL) {
  413590:	b4000120 	cbz	x0, 4135b4 <z_impl_k_sem_give+0xbc>
  413594:	b9004c1f 	str	wzr, [x0, #76]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
  413598:	940006d4 	bl	4150e8 <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		resched = handle_poll_events(sem);
	}

	if (resched) {
		z_reschedule(&lock, key);
  41359c:	2a1403e1 	mov	w1, w20
  4135a0:	912102c0 	add	x0, x22, #0x840
	} else {
		k_spin_unlock(&lock, key);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
  4135a4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4135a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4135ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule(&lock, key);
  4135b0:	14000473 	b	41477c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  4135b4:	29420262 	ldp	w2, w0, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  4135b8:	52800041 	mov	w1, #0x2                   	// #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  4135bc:	6b02001f 	cmp	w0, w2
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  4135c0:	91006260 	add	x0, x19, #0x18
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
  4135c4:	1a820442 	cinc	w2, w2, ne  // ne = any
  4135c8:	b9001262 	str	w2, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  4135cc:	9400109c 	bl	41783c <z_handle_obj_poll_events>
	return true;
  4135d0:	17fffff3 	b	41359c <z_impl_k_sem_give+0xa4>

00000000004135d4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
  4135d4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4135d8:	910003fd 	mov	x29, sp
  4135dc:	a9025bf5 	stp	x21, x22, [sp, #32]
  4135e0:	aa0003f5 	mov	x21, x0
	return _kernel.cpus[0].nested != 0U;
  4135e4:	d00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4135e8:	a90153f3 	stp	x19, x20, [sp, #16]
  4135ec:	aa0103f6 	mov	x22, x1
  4135f0:	f9471000 	ldr	x0, [x0, #3616]
  4135f4:	f9001bf7 	str	x23, [sp, #48]
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
  4135f8:	b9400000 	ldr	w0, [x0]
  4135fc:	34000280 	cbz	w0, 41364c <z_impl_k_sem_take+0x78>
  413600:	b4000261 	cbz	x1, 41364c <z_impl_k_sem_take+0x78>
  413604:	f0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  413608:	91102a73 	add	x19, x19, #0x40a
  41360c:	aa1303e2 	mov	x2, x19
  413610:	f0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  413614:	9110a821 	add	x1, x1, #0x42a
  413618:	52801003 	mov	w3, #0x80                  	// #128
  41361c:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413620:	91178000 	add	x0, x0, #0x5e0
  413624:	97ffce01 	bl	406e28 <assert_print>
  413628:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  41362c:	912e6c00 	add	x0, x0, #0xb9b
  413630:	97ffcdfe 	bl	406e28 <assert_print>
  413634:	aa1303e0 	mov	x0, x19
  413638:	52801001 	mov	w1, #0x80                  	// #128
  41363c:	97ffce25 	bl	406ed0 <assert_post_action>
  413640:	52801002 	mov	w2, #0x80                  	// #128
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413644:	aa1303e1 	mov	x1, x19
  413648:	1400001b 	b	4136b4 <z_impl_k_sem_take+0xe0>
  41364c:	97ffd6fd 	bl	409240 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413650:	b0000117 	adrp	x23, 434000 <ztest_thread+0xb8>
  413654:	912102f3 	add	x19, x23, #0x840
  413658:	2a0003f4 	mov	w20, w0
  41365c:	aa1303e0 	mov	x0, x19
  413660:	97fffb9f 	bl	4124dc <z_spin_lock_valid>
  413664:	72001c1f 	tst	w0, #0xff
  413668:	540002c1 	b.ne	4136c0 <z_impl_k_sem_take+0xec>  // b.any
  41366c:	d0000034 	adrp	x20, 419000 <__func__.2+0xa80>
  413670:	912c1294 	add	x20, x20, #0xb04
  413674:	aa1403e2 	mov	x2, x20
  413678:	52801283 	mov	w3, #0x94                  	// #148
  41367c:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413680:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413684:	912cc421 	add	x1, x1, #0xb31
  413688:	91178000 	add	x0, x0, #0x5e0
  41368c:	97ffcde7 	bl	406e28 <assert_print>
  413690:	aa1303e1 	mov	x1, x19
  413694:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413698:	912d1800 	add	x0, x0, #0xb46
  41369c:	97ffcde3 	bl	406e28 <assert_print>
  4136a0:	52801281 	mov	w1, #0x94                  	// #148
  4136a4:	aa1403e0 	mov	x0, x20
  4136a8:	97ffce0a 	bl	406ed0 <assert_post_action>
  4136ac:	aa1403e1 	mov	x1, x20
  4136b0:	52801282 	mov	w2, #0x94                  	// #148
  4136b4:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4136b8:	91187800 	add	x0, x0, #0x61e
  4136bc:	97ffd7f7 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4136c0:	aa1303e0 	mov	x0, x19
  4136c4:	97fffb9e 	bl	41253c <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
  4136c8:	b94012a0 	ldr	w0, [x21, #16]
  4136cc:	34000420 	cbz	w0, 413750 <z_impl_k_sem_take+0x17c>
		sem->count--;
  4136d0:	51000400 	sub	w0, w0, #0x1
  4136d4:	b90012a0 	str	w0, [x21, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4136d8:	aa1303e0 	mov	x0, x19
  4136dc:	97fffb8b 	bl	412508 <z_spin_unlock_valid>
  4136e0:	72001c1f 	tst	w0, #0xff
  4136e4:	54000261 	b.ne	413730 <z_impl_k_sem_take+0x15c>  // b.any
  4136e8:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  4136ec:	912c1273 	add	x19, x19, #0xb04
  4136f0:	aa1303e2 	mov	x2, x19
  4136f4:	52801863 	mov	w3, #0xc3                  	// #195
  4136f8:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4136fc:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413700:	912d7821 	add	x1, x1, #0xb5e
  413704:	91178000 	add	x0, x0, #0x5e0
  413708:	97ffcdc8 	bl	406e28 <assert_print>
  41370c:	912102e1 	add	x1, x23, #0x840
  413710:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413714:	912dd400 	add	x0, x0, #0xb75
  413718:	97ffcdc4 	bl	406e28 <assert_print>
  41371c:	aa1303e0 	mov	x0, x19
  413720:	52801861 	mov	w1, #0xc3                  	// #195
  413724:	97ffcdeb 	bl	406ed0 <assert_post_action>
  413728:	52801862 	mov	w2, #0xc3                  	// #195
  41372c:	17ffffc6 	b	413644 <z_impl_k_sem_take+0x70>
	posix_irq_unlock(key);
  413730:	2a1403e0 	mov	w0, w20
  413734:	97ffd6c5 	bl	409248 <posix_irq_unlock>
		k_spin_unlock(&lock, key);
		ret = 0;
  413738:	52800000 	mov	w0, #0x0                   	// #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
  41373c:	a94153f3 	ldp	x19, x20, [sp, #16]
  413740:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413744:	f9401bf7 	ldr	x23, [sp, #48]
  413748:	a8c47bfd 	ldp	x29, x30, [sp], #64
  41374c:	d65f03c0 	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  413750:	b5000136 	cbnz	x22, 413774 <z_impl_k_sem_take+0x1a0>
  413754:	aa1303e0 	mov	x0, x19
  413758:	97fffb6c 	bl	412508 <z_spin_unlock_valid>
  41375c:	72001c1f 	tst	w0, #0xff
  413760:	54fffc40 	b.eq	4136e8 <z_impl_k_sem_take+0x114>  // b.none
  413764:	2a1403e0 	mov	w0, w20
  413768:	97ffd6b8 	bl	409248 <posix_irq_unlock>
		ret = -EBUSY;
  41376c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
  413770:	17fffff3 	b	41373c <z_impl_k_sem_take+0x168>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  413774:	aa1603e3 	mov	x3, x22
  413778:	aa1503e2 	mov	x2, x21
  41377c:	2a1403e1 	mov	w1, w20
  413780:	aa1303e0 	mov	x0, x19
}
  413784:	a94153f3 	ldp	x19, x20, [sp, #16]
  413788:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41378c:	f9401bf7 	ldr	x23, [sp, #48]
  413790:	a8c47bfd 	ldp	x29, x30, [sp], #64
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
  413794:	1400079e 	b	41560c <z_pend_curr>

0000000000413798 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
  413798:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  41379c:	910003fd 	mov	x29, sp
  4137a0:	a90153f3 	stp	x19, x20, [sp, #16]
  4137a4:	aa0003f3 	mov	x19, x0
  4137a8:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  4137ac:	97ffd6a5 	bl	409240 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4137b0:	b0000116 	adrp	x22, 434000 <ztest_thread+0xb8>
  4137b4:	912102d5 	add	x21, x22, #0x840
  4137b8:	2a0003f4 	mov	w20, w0
  4137bc:	aa1503e0 	mov	x0, x21
  4137c0:	97fffb47 	bl	4124dc <z_spin_lock_valid>
  4137c4:	72001c1f 	tst	w0, #0xff
  4137c8:	540002c1 	b.ne	413820 <z_impl_k_sem_reset+0x88>  // b.any
  4137cc:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  4137d0:	912c1273 	add	x19, x19, #0xb04
  4137d4:	aa1303e2 	mov	x2, x19
  4137d8:	52801283 	mov	w3, #0x94                  	// #148
  4137dc:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4137e0:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  4137e4:	912cc421 	add	x1, x1, #0xb31
  4137e8:	91178000 	add	x0, x0, #0x5e0
  4137ec:	97ffcd8f 	bl	406e28 <assert_print>
  4137f0:	aa1503e1 	mov	x1, x21
  4137f4:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4137f8:	912d1800 	add	x0, x0, #0xb46
  4137fc:	97ffcd8b 	bl	406e28 <assert_print>
  413800:	aa1303e0 	mov	x0, x19
  413804:	52801281 	mov	w1, #0x94                  	// #148
  413808:	97ffcdb2 	bl	406ed0 <assert_post_action>
  41380c:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413810:	aa1303e1 	mov	x1, x19
  413814:	91187800 	add	x0, x0, #0x61e
  413818:	52801282 	mov	w2, #0x94                  	// #148
  41381c:	97ffd79f 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413820:	aa1503e0 	mov	x0, x21
	thread->callee_saved.retval = value;
  413824:	12800155 	mov	w21, #0xfffffff5            	// #-11
  413828:	97fffb45 	bl	41253c <z_spin_lock_set_owner>
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
  41382c:	aa1303e0 	mov	x0, x19
  413830:	9400097f 	bl	415e2c <z_unpend_first_thread>
		if (thread == NULL) {
  413834:	b4000080 	cbz	x0, 413844 <z_impl_k_sem_reset+0xac>
  413838:	b9004c15 	str	w21, [x0, #76]
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
  41383c:	9400062b 	bl	4150e8 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
  413840:	17fffffb 	b	41382c <z_impl_k_sem_reset+0x94>
	}
	sem->count = 0;
  413844:	b900127f 	str	wzr, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
  413848:	91006260 	add	x0, x19, #0x18
  41384c:	52800041 	mov	w1, #0x2                   	// #2
  413850:	94000ffb 	bl	41783c <z_handle_obj_poll_events>

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
  413854:	2a1403e1 	mov	w1, w20
  413858:	912102c0 	add	x0, x22, #0x840
}
  41385c:	a94153f3 	ldp	x19, x20, [sp, #16]
  413860:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413864:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&lock, key);
  413868:	140003c5 	b	41477c <z_reschedule>

000000000041386c <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
  41386c:	b9400002 	ldr	w2, [x0]
	*flagp &= ~BIT(bit);
  413870:	d2800023 	mov	x3, #0x1                   	// #1
  413874:	9ac12063 	lsl	x3, x3, x1
  413878:	0a230043 	bic	w3, w2, w3
  41387c:	b9000003 	str	w3, [x0]
	return (*flagp & BIT(bit)) != 0U;
  413880:	2a0203e0 	mov	w0, w2
  413884:	9ac12400 	lsr	x0, x0, x1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
  413888:	12000000 	and	w0, w0, #0x1
  41388c:	d65f03c0 	ret

0000000000413890 <unschedule_locked>:
 *
 * @return true if and only if work had been delayed so the timeout
 * was cancelled.
 */
static inline bool unschedule_locked(struct k_work_delayable *dwork)
{
  413890:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  413894:	aa0003e4 	mov	x4, x0
	/* If scheduled, try to cancel.  If it fails, that means the
	 * callback has been dequeued and will inevitably run (or has
	 * already run), so treat that as "undelayed" and return
	 * false.
	 */
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
  413898:	52800061 	mov	w1, #0x3                   	// #3
{
  41389c:	910003fd 	mov	x29, sp
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
  4138a0:	91006000 	add	x0, x0, #0x18
  4138a4:	97fffff2 	bl	41386c <flag_test_and_clear>
  4138a8:	72001c00 	ands	w0, w0, #0xff
  4138ac:	540000a0 	b.eq	4138c0 <unschedule_locked+0x30>  // b.none
		ret = z_abort_timeout(&dwork->timeout) == 0;
  4138b0:	91008080 	add	x0, x4, #0x20
  4138b4:	94000dc5 	bl	416fc8 <z_abort_timeout>
  4138b8:	7100001f 	cmp	w0, #0x0
  4138bc:	1a9f17e0 	cset	w0, eq  // eq = none
	}

	return ret;
}
  4138c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
  4138c4:	d65f03c0 	ret

00000000004138c8 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
  4138c8:	b40000a0 	cbz	x0, 4138dc <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
  4138cc:	91034000 	add	x0, x0, #0xd0
  4138d0:	d2800002 	mov	x2, #0x0                   	// #0
  4138d4:	52800001 	mov	w1, #0x0                   	// #0
  4138d8:	14000c42 	b	4169e0 <z_sched_wake>
}
  4138dc:	d65f03c0 	ret

00000000004138e0 <work_queue_main>:
{
  4138e0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4138e4:	910003fd 	mov	x29, sp
  4138e8:	a90153f3 	stp	x19, x20, [sp, #16]
  4138ec:	aa0003f3 	mov	x19, x0
  4138f0:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4138f4:	b0000115 	adrp	x21, 434000 <ztest_thread+0xb8>
  4138f8:	a90363f7 	stp	x23, x24, [sp, #48]
	return list->head;
  4138fc:	b0000118 	adrp	x24, 434000 <ztest_thread+0xb8>
	return list->tail;
  413900:	91214316 	add	x22, x24, #0x850
  413904:	a9046bf9 	stp	x25, x26, [sp, #64]
  413908:	97ffd64e 	bl	409240 <posix_irq_lock>
  41390c:	912122b4 	add	x20, x21, #0x848
  413910:	2a0003f7 	mov	w23, w0
  413914:	aa1403e0 	mov	x0, x20
  413918:	97fffaf1 	bl	4124dc <z_spin_lock_valid>
  41391c:	72001c1f 	tst	w0, #0xff
  413920:	540002c1 	b.ne	413978 <work_queue_main+0x98>  // b.any
  413924:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413928:	912c1273 	add	x19, x19, #0xb04
  41392c:	aa1303e2 	mov	x2, x19
  413930:	52801283 	mov	w3, #0x94                  	// #148
  413934:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413938:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  41393c:	912cc421 	add	x1, x1, #0xb31
  413940:	91178000 	add	x0, x0, #0x5e0
  413944:	97ffcd39 	bl	406e28 <assert_print>
  413948:	912122a1 	add	x1, x21, #0x848
  41394c:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413950:	912d1800 	add	x0, x0, #0xb46
  413954:	97ffcd35 	bl	406e28 <assert_print>
  413958:	aa1303e0 	mov	x0, x19
  41395c:	52801281 	mov	w1, #0x94                  	// #148
  413960:	97ffcd5c 	bl	406ed0 <assert_post_action>
  413964:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413968:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  41396c:	aa1303e1 	mov	x1, x19
  413970:	91187800 	add	x0, x0, #0x61e
  413974:	97ffd749 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413978:	aa1403e0 	mov	x0, x20
  41397c:	97fffaf0 	bl	41253c <z_spin_lock_set_owner>
	return list->head;
  413980:	f9406274 	ldr	x20, [x19, #192]
Z_GENLIST_GET(slist, snode)
  413984:	b50001b4 	cbnz	x20, 4139b8 <work_queue_main+0xd8>
		} else if (flag_test_and_clear(&queue->flags,
  413988:	9103c260 	add	x0, x19, #0xf0
  41398c:	52800041 	mov	w1, #0x2                   	// #2
  413990:	97ffffb7 	bl	41386c <flag_test_and_clear>
  413994:	72001c1f 	tst	w0, #0xff
  413998:	54000581 	b.ne	413a48 <work_queue_main+0x168>  // b.any
			(void)z_sched_wait(&lock, key, &queue->notifyq,
  41399c:	91034262 	add	x2, x19, #0xd0
  4139a0:	2a1703e1 	mov	w1, w23
  4139a4:	912122a0 	add	x0, x21, #0x848
  4139a8:	d2800004 	mov	x4, #0x0                   	// #0
  4139ac:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
  4139b0:	94000c62 	bl	416b38 <z_sched_wait>
			continue;
  4139b4:	17ffffd5 	b	413908 <work_queue_main+0x28>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  4139b8:	f9406661 	ldr	x1, [x19, #200]
	return node->next;
  4139bc:	f9400280 	ldr	x0, [x20]
	list->head = node;
  4139c0:	f9006260 	str	x0, [x19, #192]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
  4139c4:	eb01029f 	cmp	x20, x1
  4139c8:	54000041 	b.ne	4139d0 <work_queue_main+0xf0>  // b.any
	list->tail = node;
  4139cc:	f9006660 	str	x0, [x19, #200]
	*flagp |= BIT(bit);
  4139d0:	b940f260 	ldr	w0, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4139d4:	912122b9 	add	x25, x21, #0x848
  4139d8:	321f0000 	orr	w0, w0, #0x2
  4139dc:	b900f260 	str	w0, [x19, #240]
  4139e0:	aa1903e0 	mov	x0, x25
	*flagp &= ~BIT(bit);
  4139e4:	b9401a82 	ldr	w2, [x20, #24]
			handler = work->handler;
  4139e8:	f940069a 	ldr	x26, [x20, #8]
	*flagp &= ~BIT(bit);
  4139ec:	121d7842 	and	w2, w2, #0xfffffffb
  4139f0:	32000042 	orr	w2, w2, #0x1
  4139f4:	b9001a82 	str	w2, [x20, #24]
  4139f8:	97fffac4 	bl	412508 <z_spin_unlock_valid>
  4139fc:	72001c1f 	tst	w0, #0xff
  413a00:	54000600 	b.eq	413ac0 <work_queue_main+0x1e0>  // b.none
	posix_irq_unlock(key);
  413a04:	2a1703e0 	mov	w0, w23
  413a08:	97ffd610 	bl	409248 <posix_irq_unlock>
		__ASSERT_NO_MSG(handler != NULL);
  413a0c:	b50002fa 	cbnz	x26, 413a68 <work_queue_main+0x188>
  413a10:	f0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  413a14:	9111e273 	add	x19, x19, #0x478
  413a18:	aa1303e2 	mov	x2, x19
  413a1c:	52805363 	mov	w3, #0x29b                 	// #667
  413a20:	f0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  413a24:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413a28:	91126421 	add	x1, x1, #0x499
  413a2c:	91178000 	add	x0, x0, #0x5e0
  413a30:	97ffccfe 	bl	406e28 <assert_print>
  413a34:	aa1303e0 	mov	x0, x19
  413a38:	52805361 	mov	w1, #0x29b                 	// #667
  413a3c:	97ffcd25 	bl	406ed0 <assert_post_action>
  413a40:	52805362 	mov	w2, #0x29b                 	// #667
  413a44:	17ffffc9 	b	413968 <work_queue_main+0x88>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
  413a48:	91038274 	add	x20, x19, #0xe0
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
  413a4c:	aa1403e0 	mov	x0, x20
  413a50:	d2800002 	mov	x2, #0x0                   	// #0
  413a54:	52800021 	mov	w1, #0x1                   	// #1
  413a58:	94000be2 	bl	4169e0 <z_sched_wake>
  413a5c:	72001c1f 	tst	w0, #0xff
  413a60:	54ffff61 	b.ne	413a4c <work_queue_main+0x16c>  // b.any
  413a64:	17ffffce 	b	41399c <work_queue_main+0xbc>
		handler(work);
  413a68:	aa1403e0 	mov	x0, x20
  413a6c:	d63f0340 	blr	x26
	return posix_irq_lock();
  413a70:	97ffd5f4 	bl	409240 <posix_irq_lock>
  413a74:	2a0003f7 	mov	w23, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413a78:	aa1903e0 	mov	x0, x25
  413a7c:	97fffa98 	bl	4124dc <z_spin_lock_valid>
  413a80:	72001c1f 	tst	w0, #0xff
  413a84:	54fff500 	b.eq	413924 <work_queue_main+0x44>  // b.none
	z_spin_lock_set_owner(l);
  413a88:	aa1903e0 	mov	x0, x25
  413a8c:	97fffaac 	bl	41253c <z_spin_lock_set_owner>
	*flagp &= ~BIT(bit);
  413a90:	b9401a80 	ldr	w0, [x20, #24]
  413a94:	121f7801 	and	w1, w0, #0xfffffffe
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  413a98:	37080380 	tbnz	w0, #1, 413b08 <work_queue_main+0x228>
	*flagp &= ~BIT(bit);
  413a9c:	b9001a81 	str	w1, [x20, #24]
  413aa0:	b940f261 	ldr	w1, [x19, #240]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413aa4:	912122a0 	add	x0, x21, #0x848
  413aa8:	121e7821 	and	w1, w1, #0xfffffffd
  413aac:	b900f261 	str	w1, [x19, #240]
	return (*flagp & BIT(bit)) != 0U;
  413ab0:	d3482034 	ubfx	x20, x1, #8, #1
  413ab4:	97fffa95 	bl	412508 <z_spin_unlock_valid>
  413ab8:	72001c1f 	tst	w0, #0xff
  413abc:	54000641 	b.ne	413b84 <work_queue_main+0x2a4>  // b.any
  413ac0:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413ac4:	912c1273 	add	x19, x19, #0xb04
  413ac8:	aa1303e2 	mov	x2, x19
  413acc:	52801863 	mov	w3, #0xc3                  	// #195
  413ad0:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413ad4:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413ad8:	912d7821 	add	x1, x1, #0xb5e
  413adc:	91178000 	add	x0, x0, #0x5e0
  413ae0:	97ffccd2 	bl	406e28 <assert_print>
  413ae4:	912122a1 	add	x1, x21, #0x848
  413ae8:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413aec:	912dd400 	add	x0, x0, #0xb75
  413af0:	97ffccce 	bl	406e28 <assert_print>
  413af4:	aa1303e0 	mov	x0, x19
  413af8:	52801861 	mov	w1, #0xc3                  	// #195
  413afc:	97ffccf5 	bl	406ed0 <assert_post_action>
  413b00:	52801862 	mov	w2, #0xc3                  	// #195
  413b04:	17ffff99 	b	413968 <work_queue_main+0x88>
	*flagp &= ~BIT(bit);
  413b08:	121e7400 	and	w0, w0, #0xfffffffc
  413b0c:	b9001a80 	str	w0, [x20, #24]
	return list->head;
  413b10:	f9442b00 	ldr	x0, [x24, #2128]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  413b14:	b4fffc60 	cbz	x0, 413aa0 <work_queue_main+0x1c0>
	return node->next;
  413b18:	f940001a 	ldr	x26, [x0]
  413b1c:	d2800019 	mov	x25, #0x0                   	// #0
		if (wc->work == work) {
  413b20:	f9400402 	ldr	x2, [x0, #8]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
  413b24:	aa0003e1 	mov	x1, x0
		if (wc->work == work) {
  413b28:	eb02029f 	cmp	x20, x2
  413b2c:	54000161 	b.ne	413b58 <work_queue_main+0x278>  // b.any
  413b30:	f9400001 	ldr	x1, [x0]
Z_GENLIST_REMOVE(slist, snode)
  413b34:	b50001d9 	cbnz	x25, 413b6c <work_queue_main+0x28c>
  413b38:	f94006c2 	ldr	x2, [x22, #8]
	list->head = node;
  413b3c:	f90002c1 	str	x1, [x22]
Z_GENLIST_REMOVE(slist, snode)
  413b40:	eb00005f 	cmp	x2, x0
  413b44:	54000041 	b.ne	413b4c <work_queue_main+0x26c>  // b.any
	list->tail = node;
  413b48:	f90006c1 	str	x1, [x22, #8]
	parent->next = child;
  413b4c:	f801041f 	str	xzr, [x0], #16
	z_impl_k_sem_give(sem);
  413b50:	97fffe6a 	bl	4134f8 <z_impl_k_sem_give>
}
  413b54:	aa1903e1 	mov	x1, x25
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
  413b58:	b4fffa5a 	cbz	x26, 413aa0 <work_queue_main+0x1c0>
	return node->next;
  413b5c:	aa1a03e0 	mov	x0, x26
  413b60:	aa0103f9 	mov	x25, x1
  413b64:	f940035a 	ldr	x26, [x26]
  413b68:	17ffffee 	b	413b20 <work_queue_main+0x240>
	parent->next = child;
  413b6c:	f9000321 	str	x1, [x25]
Z_GENLIST_REMOVE(slist, snode)
  413b70:	f94006c1 	ldr	x1, [x22, #8]
  413b74:	eb00003f 	cmp	x1, x0
  413b78:	54fffea1 	b.ne	413b4c <work_queue_main+0x26c>  // b.any
	list->tail = node;
  413b7c:	f90006d9 	str	x25, [x22, #8]
}
  413b80:	17fffff3 	b	413b4c <work_queue_main+0x26c>
	posix_irq_unlock(key);
  413b84:	2a1703e0 	mov	w0, w23
  413b88:	97ffd5b0 	bl	409248 <posix_irq_unlock>
		if (yield) {
  413b8c:	35ffebf4 	cbnz	w20, 413908 <work_queue_main+0x28>
	z_impl_k_yield();
  413b90:	9400090a 	bl	415fb8 <z_impl_k_yield>
}
  413b94:	17ffff5d 	b	413908 <work_queue_main+0x28>

0000000000413b98 <submit_to_queue_locked>:
{
  413b98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  413b9c:	910003fd 	mov	x29, sp
  413ba0:	a90153f3 	stp	x19, x20, [sp, #16]
  413ba4:	aa0003f3 	mov	x19, x0
  413ba8:	aa0103f4 	mov	x20, x1
  413bac:	a9025bf5 	stp	x21, x22, [sp, #32]
	return (*flagp & BIT(bit)) != 0U;
  413bb0:	b9401800 	ldr	w0, [x0, #24]
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
  413bb4:	721f001f 	tst	w0, #0x2
  413bb8:	54000941 	b.ne	413ce0 <submit_to_queue_locked+0x148>  // b.any
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
  413bbc:	721e001f 	tst	w0, #0x4
  413bc0:	54000961 	b.ne	413cec <submit_to_queue_locked+0x154>  // b.any
		if (*queuep == NULL) {
  413bc4:	f9400020 	ldr	x0, [x1]
  413bc8:	b5000060 	cbnz	x0, 413bd4 <submit_to_queue_locked+0x3c>
			*queuep = work->queue;
  413bcc:	f9400a60 	ldr	x0, [x19, #16]
  413bd0:	f9000020 	str	x0, [x1]
	return (*flagp & BIT(bit)) != 0U;
  413bd4:	b9401a60 	ldr	w0, [x19, #24]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
  413bd8:	36000760 	tbz	w0, #0, 413cc4 <submit_to_queue_locked+0x12c>
			__ASSERT_NO_MSG(work->queue != NULL);
  413bdc:	f9400a60 	ldr	x0, [x19, #16]
  413be0:	b5000240 	cbnz	x0, 413c28 <submit_to_queue_locked+0x90>
  413be4:	f0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  413be8:	9111e273 	add	x19, x19, #0x478
  413bec:	aa1303e2 	mov	x2, x19
  413bf0:	528029c3 	mov	w3, #0x14e                 	// #334
  413bf4:	f0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  413bf8:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413bfc:	9112c021 	add	x1, x1, #0x4b0
  413c00:	91178000 	add	x0, x0, #0x5e0
  413c04:	97ffcc89 	bl	406e28 <assert_print>
  413c08:	aa1303e0 	mov	x0, x19
  413c0c:	528029c1 	mov	w1, #0x14e                 	// #334
  413c10:	97ffccb0 	bl	406ed0 <assert_post_action>
  413c14:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413c18:	aa1303e1 	mov	x1, x19
  413c1c:	91187800 	add	x0, x0, #0x61e
  413c20:	528029c2 	mov	w2, #0x14e                 	// #334
  413c24:	97ffd69d 	bl	409698 <posix_print_error_and_exit>
			ret = 2;
  413c28:	52800056 	mov	w22, #0x2                   	// #2
			*queuep = work->queue;
  413c2c:	f9000280 	str	x0, [x20]
		int rc = queue_submit_locked(*queuep, work);
  413c30:	f9400295 	ldr	x21, [x20]
	if (queue == NULL) {
  413c34:	b4000615 	cbz	x21, 413cf4 <submit_to_queue_locked+0x15c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  413c38:	d00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  413c3c:	f9471000 	ldr	x0, [x0, #3616]
  413c40:	f9400800 	ldr	x0, [x0, #16]
  413c44:	eb15001f 	cmp	x0, x21
  413c48:	54000421 	b.ne	413ccc <submit_to_queue_locked+0x134>  // b.any
  413c4c:	97fff917 	bl	4120a8 <k_is_in_isr>
  413c50:	12001c00 	and	w0, w0, #0xff
  413c54:	52000000 	eor	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  413c58:	b940f2a2 	ldr	w2, [x21, #240]
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  413c5c:	12000000 	and	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
  413c60:	d3420841 	ubfx	x1, x2, #2, #1
  413c64:	d3430c43 	ubfx	x3, x2, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
  413c68:	360004a2 	tbz	w2, #0, 413cfc <submit_to_queue_locked+0x164>
	} else if (draining && !chained) {
  413c6c:	52000000 	eor	w0, w0, #0x1
  413c70:	6a00003f 	tst	w1, w0
  413c74:	54000361 	b.ne	413ce0 <submit_to_queue_locked+0x148>  // b.any
	} else if (plugged && !draining) {
  413c78:	52000021 	eor	w1, w1, #0x1
  413c7c:	6a01007f 	tst	w3, w1
  413c80:	54000301 	b.ne	413ce0 <submit_to_queue_locked+0x148>  // b.any
	parent->next = child;
  413c84:	f900027f 	str	xzr, [x19]
	return list->tail;
  413c88:	f94066a0 	ldr	x0, [x21, #200]
Z_GENLIST_APPEND(slist, snode)
  413c8c:	b5000240 	cbnz	x0, 413cd4 <submit_to_queue_locked+0x13c>
	list->tail = node;
  413c90:	a90c4eb3 	stp	x19, x19, [x21, #192]
		(void)notify_queue_locked(queue);
  413c94:	aa1503e0 	mov	x0, x21
  413c98:	97ffff0c 	bl	4138c8 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
  413c9c:	b9401a60 	ldr	w0, [x19, #24]
  413ca0:	321e0000 	orr	w0, w0, #0x4
  413ca4:	b9001a60 	str	w0, [x19, #24]
			work->queue = *queuep;
  413ca8:	f9400280 	ldr	x0, [x20]
  413cac:	f9000a60 	str	x0, [x19, #16]
}
  413cb0:	2a1603e0 	mov	w0, w22
  413cb4:	a94153f3 	ldp	x19, x20, [sp, #16]
  413cb8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413cbc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  413cc0:	d65f03c0 	ret
		ret = 1;
  413cc4:	52800036 	mov	w22, #0x1                   	// #1
  413cc8:	17ffffda 	b	413c30 <submit_to_queue_locked+0x98>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
  413ccc:	52800000 	mov	w0, #0x0                   	// #0
  413cd0:	17ffffe2 	b	413c58 <submit_to_queue_locked+0xc0>
	parent->next = child;
  413cd4:	f9000013 	str	x19, [x0]
	list->tail = node;
  413cd8:	f90066b3 	str	x19, [x21, #200]
}
  413cdc:	17ffffee 	b	413c94 <submit_to_queue_locked+0xfc>
		ret = -EBUSY;
  413ce0:	128001f6 	mov	w22, #0xfffffff0            	// #-16
		*queuep = NULL;
  413ce4:	f900029f 	str	xzr, [x20]
	return ret;
  413ce8:	17fffff2 	b	413cb0 <submit_to_queue_locked+0x118>
	int ret = 0;
  413cec:	52800016 	mov	w22, #0x0                   	// #0
  413cf0:	17fffffd 	b	413ce4 <submit_to_queue_locked+0x14c>
		return -EINVAL;
  413cf4:	128002b6 	mov	w22, #0xffffffea            	// #-22
  413cf8:	17fffffb 	b	413ce4 <submit_to_queue_locked+0x14c>
		ret = -ENODEV;
  413cfc:	12800256 	mov	w22, #0xffffffed            	// #-19
  413d00:	17fffff9 	b	413ce4 <submit_to_queue_locked+0x14c>

0000000000413d04 <work_timeout>:
{
  413d04:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  413d08:	910003fd 	mov	x29, sp
  413d0c:	a90153f3 	stp	x19, x20, [sp, #16]
  413d10:	aa0003f4 	mov	x20, x0
  413d14:	d00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  413d18:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413d1c:	b0000113 	adrp	x19, 434000 <ztest_thread+0xb8>
  413d20:	91212276 	add	x22, x19, #0x848
  413d24:	f9475c00 	ldr	x0, [x0, #3768]
  413d28:	f9400001 	ldr	x1, [x0]
  413d2c:	f9001fe1 	str	x1, [sp, #56]
  413d30:	d2800001 	mov	x1, #0x0                   	// #0
	return posix_irq_lock();
  413d34:	97ffd543 	bl	409240 <posix_irq_lock>
  413d38:	2a0003f5 	mov	w21, w0
  413d3c:	aa1603e0 	mov	x0, x22
  413d40:	97fff9e7 	bl	4124dc <z_spin_lock_valid>
  413d44:	72001c1f 	tst	w0, #0xff
  413d48:	540002c1 	b.ne	413da0 <work_timeout+0x9c>  // b.any
  413d4c:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413d50:	912c1273 	add	x19, x19, #0xb04
  413d54:	aa1303e2 	mov	x2, x19
  413d58:	52801283 	mov	w3, #0x94                  	// #148
  413d5c:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413d60:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413d64:	912cc421 	add	x1, x1, #0xb31
  413d68:	91178000 	add	x0, x0, #0x5e0
  413d6c:	97ffcc2f 	bl	406e28 <assert_print>
  413d70:	aa1603e1 	mov	x1, x22
  413d74:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413d78:	912d1800 	add	x0, x0, #0xb46
  413d7c:	97ffcc2b 	bl	406e28 <assert_print>
  413d80:	aa1303e0 	mov	x0, x19
  413d84:	52801281 	mov	w1, #0x94                  	// #148
  413d88:	97ffcc52 	bl	406ed0 <assert_post_action>
  413d8c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413d90:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413d94:	aa1303e1 	mov	x1, x19
  413d98:	91187800 	add	x0, x0, #0x61e
  413d9c:	97ffd63f 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  413da0:	aa1603e0 	mov	x0, x22
  413da4:	97fff9e6 	bl	41253c <z_spin_lock_set_owner>
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
  413da8:	d1008284 	sub	x4, x20, #0x20
  413dac:	d1002280 	sub	x0, x20, #0x8
  413db0:	52800061 	mov	w1, #0x3                   	// #3
	struct k_work_q *queue = NULL;
  413db4:	f9001bff 	str	xzr, [sp, #48]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
  413db8:	97fffead 	bl	41386c <flag_test_and_clear>
  413dbc:	72001c1f 	tst	w0, #0xff
  413dc0:	540000c0 	b.eq	413dd8 <work_timeout+0xd4>  // b.none
		queue = dw->queue;
  413dc4:	f9401280 	ldr	x0, [x20, #32]
		(void)submit_to_queue_locked(wp, &queue);
  413dc8:	9100c3e1 	add	x1, sp, #0x30
		queue = dw->queue;
  413dcc:	f9001be0 	str	x0, [sp, #48]
		(void)submit_to_queue_locked(wp, &queue);
  413dd0:	aa0403e0 	mov	x0, x4
  413dd4:	97ffff71 	bl	413b98 <submit_to_queue_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413dd8:	91212274 	add	x20, x19, #0x848
  413ddc:	aa1403e0 	mov	x0, x20
  413de0:	97fff9ca 	bl	412508 <z_spin_unlock_valid>
  413de4:	72001c1f 	tst	w0, #0xff
  413de8:	54000261 	b.ne	413e34 <work_timeout+0x130>  // b.any
  413dec:	d0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  413df0:	912c1273 	add	x19, x19, #0xb04
  413df4:	aa1303e2 	mov	x2, x19
  413df8:	52801863 	mov	w3, #0xc3                  	// #195
  413dfc:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413e00:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413e04:	912d7821 	add	x1, x1, #0xb5e
  413e08:	91178000 	add	x0, x0, #0x5e0
  413e0c:	97ffcc07 	bl	406e28 <assert_print>
  413e10:	aa1403e1 	mov	x1, x20
  413e14:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413e18:	912dd400 	add	x0, x0, #0xb75
  413e1c:	97ffcc03 	bl	406e28 <assert_print>
  413e20:	aa1303e0 	mov	x0, x19
  413e24:	52801861 	mov	w1, #0xc3                  	// #195
  413e28:	97ffcc2a 	bl	406ed0 <assert_post_action>
  413e2c:	52801862 	mov	w2, #0xc3                  	// #195
  413e30:	17ffffd8 	b	413d90 <work_timeout+0x8c>
	posix_irq_unlock(key);
  413e34:	d00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  413e38:	f9475c00 	ldr	x0, [x0, #3768]
  413e3c:	f9401fe2 	ldr	x2, [sp, #56]
  413e40:	f9400001 	ldr	x1, [x0]
  413e44:	eb010042 	subs	x2, x2, x1
  413e48:	d2800001 	mov	x1, #0x0                   	// #0
  413e4c:	54000040 	b.eq	413e54 <work_timeout+0x150>  // b.none
  413e50:	97ffb5b4 	bl	401520 <__stack_chk_fail@plt>
  413e54:	2a1503e0 	mov	w0, w21
}
  413e58:	a94153f3 	ldp	x19, x20, [sp, #16]
  413e5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  413e60:	a8c47bfd 	ldp	x29, x30, [sp], #64
  413e64:	17ffd4f9 	b	409248 <posix_irq_unlock>

0000000000413e68 <k_work_init>:
{
  413e68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  413e6c:	910003fd 	mov	x29, sp
  413e70:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(work != NULL);
  413e74:	b5000240 	cbnz	x0, 413ebc <k_work_init+0x54>
  413e78:	f0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  413e7c:	9111e273 	add	x19, x19, #0x478
  413e80:	aa1303e2 	mov	x2, x19
  413e84:	52801123 	mov	w3, #0x89                  	// #137
  413e88:	f0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  413e8c:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413e90:	91143021 	add	x1, x1, #0x50c
  413e94:	91178000 	add	x0, x0, #0x5e0
  413e98:	97ffcbe4 	bl	406e28 <assert_print>
  413e9c:	aa1303e0 	mov	x0, x19
  413ea0:	52801121 	mov	w1, #0x89                  	// #137
  413ea4:	97ffcc0b 	bl	406ed0 <assert_post_action>
  413ea8:	52801122 	mov	w2, #0x89                  	// #137
	__ASSERT_NO_MSG(handler != NULL);
  413eac:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413eb0:	aa1303e1 	mov	x1, x19
  413eb4:	91187800 	add	x0, x0, #0x61e
  413eb8:	97ffd5f8 	bl	409698 <posix_print_error_and_exit>
  413ebc:	b50001e1 	cbnz	x1, 413ef8 <k_work_init+0x90>
  413ec0:	f0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  413ec4:	9111e273 	add	x19, x19, #0x478
  413ec8:	aa1303e2 	mov	x2, x19
  413ecc:	52801143 	mov	w3, #0x8a                  	// #138
  413ed0:	f0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  413ed4:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413ed8:	91126421 	add	x1, x1, #0x499
  413edc:	91178000 	add	x0, x0, #0x5e0
  413ee0:	97ffcbd2 	bl	406e28 <assert_print>
  413ee4:	aa1303e0 	mov	x0, x19
  413ee8:	52801141 	mov	w1, #0x8a                  	// #138
  413eec:	97ffcbf9 	bl	406ed0 <assert_post_action>
  413ef0:	52801142 	mov	w2, #0x8a                  	// #138
  413ef4:	17ffffee 	b	413eac <k_work_init+0x44>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
  413ef8:	a9007c1f 	stp	xzr, xzr, [x0]
  413efc:	f9000401 	str	x1, [x0, #8]
  413f00:	a9017c1f 	stp	xzr, xzr, [x0, #16]
}
  413f04:	f9400bf3 	ldr	x19, [sp, #16]
  413f08:	a8c27bfd 	ldp	x29, x30, [sp], #32
  413f0c:	d65f03c0 	ret

0000000000413f10 <z_work_submit_to_queue>:
{
  413f10:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  413f14:	910003fd 	mov	x29, sp
  413f18:	a90153f3 	stp	x19, x20, [sp, #16]
  413f1c:	f90013f5 	str	x21, [sp, #32]
  413f20:	f9001fe0 	str	x0, [sp, #56]
	__ASSERT_NO_MSG(work != NULL);
  413f24:	b5000241 	cbnz	x1, 413f6c <z_work_submit_to_queue+0x5c>
  413f28:	f0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  413f2c:	9111e273 	add	x19, x19, #0x478
  413f30:	aa1303e2 	mov	x2, x19
  413f34:	52802e83 	mov	w3, #0x174                 	// #372
  413f38:	f0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  413f3c:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413f40:	91143021 	add	x1, x1, #0x50c
  413f44:	91178000 	add	x0, x0, #0x5e0
  413f48:	97ffcbb8 	bl	406e28 <assert_print>
  413f4c:	52802e81 	mov	w1, #0x174                 	// #372
  413f50:	aa1303e0 	mov	x0, x19
  413f54:	97ffcbdf 	bl	406ed0 <assert_post_action>
  413f58:	aa1303e1 	mov	x1, x19
  413f5c:	52802e82 	mov	w2, #0x174                 	// #372
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  413f60:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413f64:	91187800 	add	x0, x0, #0x61e
  413f68:	97ffd5cc 	bl	409698 <posix_print_error_and_exit>
  413f6c:	aa0103f4 	mov	x20, x1
  413f70:	b0000113 	adrp	x19, 434000 <ztest_thread+0xb8>
	return posix_irq_lock();
  413f74:	97ffd4b3 	bl	409240 <posix_irq_lock>
  413f78:	91212273 	add	x19, x19, #0x848
  413f7c:	2a0003f5 	mov	w21, w0
  413f80:	aa1303e0 	mov	x0, x19
  413f84:	97fff956 	bl	4124dc <z_spin_lock_valid>
  413f88:	72001c1f 	tst	w0, #0xff
  413f8c:	54000281 	b.ne	413fdc <z_work_submit_to_queue+0xcc>  // b.any
  413f90:	d0000034 	adrp	x20, 419000 <__func__.2+0xa80>
  413f94:	912c1294 	add	x20, x20, #0xb04
  413f98:	aa1403e2 	mov	x2, x20
  413f9c:	52801283 	mov	w3, #0x94                  	// #148
  413fa0:	d0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  413fa4:	b0000020 	adrp	x0, 418000 <table.0+0x1d8>
  413fa8:	912cc421 	add	x1, x1, #0xb31
  413fac:	91178000 	add	x0, x0, #0x5e0
  413fb0:	97ffcb9e 	bl	406e28 <assert_print>
  413fb4:	aa1303e1 	mov	x1, x19
  413fb8:	d0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  413fbc:	912d1800 	add	x0, x0, #0xb46
  413fc0:	97ffcb9a 	bl	406e28 <assert_print>
  413fc4:	aa1403e0 	mov	x0, x20
  413fc8:	52801281 	mov	w1, #0x94                  	// #148
  413fcc:	97ffcbc1 	bl	406ed0 <assert_post_action>
  413fd0:	52801282 	mov	w2, #0x94                  	// #148
  413fd4:	aa1403e1 	mov	x1, x20
  413fd8:	17ffffe2 	b	413f60 <z_work_submit_to_queue+0x50>
	z_spin_lock_set_owner(l);
  413fdc:	aa1303e0 	mov	x0, x19
  413fe0:	97fff957 	bl	41253c <z_spin_lock_set_owner>
	int ret = submit_to_queue_locked(work, &queue);
  413fe4:	9100e3e1 	add	x1, sp, #0x38
  413fe8:	aa1403e0 	mov	x0, x20
  413fec:	97fffeeb 	bl	413b98 <submit_to_queue_locked>
  413ff0:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  413ff4:	aa1303e0 	mov	x0, x19
  413ff8:	97fff944 	bl	412508 <z_spin_unlock_valid>
  413ffc:	72001c1f 	tst	w0, #0xff
  414000:	54000261 	b.ne	41404c <z_work_submit_to_queue+0x13c>  // b.any
  414004:	b0000034 	adrp	x20, 419000 <__func__.2+0xa80>
  414008:	912c1294 	add	x20, x20, #0xb04
  41400c:	aa1403e2 	mov	x2, x20
  414010:	52801863 	mov	w3, #0xc3                  	// #195
  414014:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414018:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  41401c:	912d7821 	add	x1, x1, #0xb5e
  414020:	91178000 	add	x0, x0, #0x5e0
  414024:	97ffcb81 	bl	406e28 <assert_print>
  414028:	aa1303e1 	mov	x1, x19
  41402c:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414030:	912dd400 	add	x0, x0, #0xb75
  414034:	97ffcb7d 	bl	406e28 <assert_print>
  414038:	aa1403e0 	mov	x0, x20
  41403c:	52801861 	mov	w1, #0xc3                  	// #195
  414040:	97ffcba4 	bl	406ed0 <assert_post_action>
  414044:	52801862 	mov	w2, #0xc3                  	// #195
  414048:	17ffffe3 	b	413fd4 <z_work_submit_to_queue+0xc4>
	posix_irq_unlock(key);
  41404c:	2a1503e0 	mov	w0, w21
  414050:	97ffd47e 	bl	409248 <posix_irq_unlock>
}
  414054:	2a1403e0 	mov	w0, w20
  414058:	a94153f3 	ldp	x19, x20, [sp, #16]
  41405c:	f94013f5 	ldr	x21, [sp, #32]
  414060:	a8c47bfd 	ldp	x29, x30, [sp], #64
  414064:	d65f03c0 	ret

0000000000414068 <k_work_submit_to_queue>:
{
  414068:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  41406c:	910003fd 	mov	x29, sp
  414070:	f9000bf3 	str	x19, [sp, #16]
	int ret = z_work_submit_to_queue(queue, work);
  414074:	97ffffa7 	bl	413f10 <z_work_submit_to_queue>
  414078:	2a0003f3 	mov	w19, w0
	if (ret > 0) {
  41407c:	7100001f 	cmp	w0, #0x0
  414080:	5400006d 	b.le	41408c <k_work_submit_to_queue+0x24>
	return posix_irq_lock();
  414084:	97ffd46f 	bl	409240 <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
  414088:	94000201 	bl	41488c <z_reschedule_irqlock>
}
  41408c:	2a1303e0 	mov	w0, w19
  414090:	f9400bf3 	ldr	x19, [sp, #16]
  414094:	a8c27bfd 	ldp	x29, x30, [sp], #32
  414098:	d65f03c0 	ret

000000000041409c <k_work_submit>:
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
  41409c:	aa0003e1 	mov	x1, x0
  4140a0:	b00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4140a4:	f947f800 	ldr	x0, [x0, #4080]
  4140a8:	17fffff0 	b	414068 <k_work_submit_to_queue>

00000000004140ac <k_work_queue_init>:
{
  4140ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4140b0:	910003fd 	mov	x29, sp
  4140b4:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(queue != NULL);
  4140b8:	b5000240 	cbnz	x0, 414100 <k_work_queue_init+0x54>
  4140bc:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4140c0:	9111e273 	add	x19, x19, #0x478
  4140c4:	aa1303e2 	mov	x2, x19
  4140c8:	52805723 	mov	w3, #0x2b9                 	// #697
  4140cc:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4140d0:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4140d4:	9112d821 	add	x1, x1, #0x4b6
  4140d8:	91178000 	add	x0, x0, #0x5e0
  4140dc:	97ffcb53 	bl	406e28 <assert_print>
  4140e0:	aa1303e0 	mov	x0, x19
  4140e4:	52805721 	mov	w1, #0x2b9                 	// #697
  4140e8:	97ffcb7a 	bl	406ed0 <assert_post_action>
  4140ec:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4140f0:	aa1303e1 	mov	x1, x19
  4140f4:	91187800 	add	x0, x0, #0x61e
  4140f8:	52805722 	mov	w2, #0x2b9                 	// #697
  4140fc:	97ffd567 	bl	409698 <posix_print_error_and_exit>
	*queue = (struct k_work_q) {
  414100:	d2801f02 	mov	x2, #0xf8                  	// #248
  414104:	52800001 	mov	w1, #0x0                   	// #0
  414108:	97ffb4e2 	bl	401490 <memset@plt>
}
  41410c:	f9400bf3 	ldr	x19, [sp, #16]
  414110:	a8c27bfd 	ldp	x29, x30, [sp], #32
  414114:	d65f03c0 	ret

0000000000414118 <k_work_queue_start>:
{
  414118:	d100c3ff 	sub	sp, sp, #0x30
  41411c:	a9017bfd 	stp	x29, x30, [sp, #16]
  414120:	910043fd 	add	x29, sp, #0x10
  414124:	a90253f3 	stp	x19, x20, [sp, #32]
	__ASSERT_NO_MSG(queue);
  414128:	b5000240 	cbnz	x0, 414170 <k_work_queue_start+0x58>
  41412c:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414130:	9111e273 	add	x19, x19, #0x478
  414134:	aa1303e2 	mov	x2, x19
  414138:	52805903 	mov	w3, #0x2c8                 	// #712
  41413c:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  414140:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414144:	91132c21 	add	x1, x1, #0x4cb
  414148:	91178000 	add	x0, x0, #0x5e0
  41414c:	97ffcb37 	bl	406e28 <assert_print>
  414150:	aa1303e0 	mov	x0, x19
  414154:	52805901 	mov	w1, #0x2c8                 	// #712
  414158:	97ffcb5e 	bl	406ed0 <assert_post_action>
  41415c:	52805902 	mov	w2, #0x2c8                 	// #712
	__ASSERT_NO_MSG(stack);
  414160:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414164:	aa1303e1 	mov	x1, x19
  414168:	91187800 	add	x0, x0, #0x61e
  41416c:	97ffd54b 	bl	409698 <posix_print_error_and_exit>
  414170:	b50001e1 	cbnz	x1, 4141ac <k_work_queue_start+0x94>
  414174:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414178:	9111e273 	add	x19, x19, #0x478
  41417c:	aa1303e2 	mov	x2, x19
  414180:	52805923 	mov	w3, #0x2c9                 	// #713
  414184:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  414188:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  41418c:	91134421 	add	x1, x1, #0x4d1
  414190:	91178000 	add	x0, x0, #0x5e0
  414194:	97ffcb25 	bl	406e28 <assert_print>
  414198:	aa1303e0 	mov	x0, x19
  41419c:	52805921 	mov	w1, #0x2c9                 	// #713
  4141a0:	97ffcb4c 	bl	406ed0 <assert_post_action>
  4141a4:	52805922 	mov	w2, #0x2c9                 	// #713
  4141a8:	17ffffee 	b	414160 <k_work_queue_start+0x48>
  4141ac:	aa0003f3 	mov	x19, x0
	return (*flagp & BIT(bit)) != 0U;
  4141b0:	b940f000 	ldr	w0, [x0, #240]
	__ASSERT_NO_MSG(!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT));
  4141b4:	360001e0 	tbz	w0, #0, 4141f0 <k_work_queue_start+0xd8>
  4141b8:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4141bc:	9111e273 	add	x19, x19, #0x478
  4141c0:	aa1303e2 	mov	x2, x19
  4141c4:	52805943 	mov	w3, #0x2ca                 	// #714
  4141c8:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4141cc:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4141d0:	91135c21 	add	x1, x1, #0x4d7
  4141d4:	91178000 	add	x0, x0, #0x5e0
  4141d8:	97ffcb14 	bl	406e28 <assert_print>
  4141dc:	aa1303e0 	mov	x0, x19
  4141e0:	52805941 	mov	w1, #0x2ca                 	// #714
  4141e4:	97ffcb3b 	bl	406ed0 <assert_post_action>
  4141e8:	52805942 	mov	w2, #0x2ca                 	// #714
  4141ec:	17ffffdd 	b	414160 <k_work_queue_start+0x48>
  4141f0:	91034260 	add	x0, x19, #0xd0
	list->tail = NULL;
  4141f4:	a90c7e7f 	stp	xzr, xzr, [x19, #192]
  4141f8:	2a0303e7 	mov	w7, w3
  4141fc:	a90d0260 	stp	x0, x0, [x19, #208]
  414200:	91038260 	add	x0, x19, #0xe0
  414204:	aa0403f4 	mov	x20, x4
  414208:	a90e0260 	stp	x0, x0, [x19, #224]
	if ((cfg != NULL) && cfg->no_yield) {
  41420c:	b4000344 	cbz	x4, 414274 <k_work_queue_start+0x15c>
  414210:	39402080 	ldrb	w0, [x4, #8]
		flags |= K_WORK_QUEUE_NO_YIELD;
  414214:	7100001f 	cmp	w0, #0x0
  414218:	52802020 	mov	w0, #0x101                 	// #257
  41421c:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
	*flagp = flags;
  414220:	b900f260 	str	w0, [x19, #240]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
  414224:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
  414228:	b90003ff 	str	wzr, [sp]
  41422c:	f90007e0 	str	x0, [sp, #8]
  414230:	f0ffffe3 	adrp	x3, 413000 <z_impl_k_mutex_unlock+0x10c>
  414234:	aa1303e4 	mov	x4, x19
  414238:	91238063 	add	x3, x3, #0x8e0
  41423c:	aa1303e0 	mov	x0, x19
  414240:	d2800006 	mov	x6, #0x0                   	// #0
  414244:	d2800005 	mov	x5, #0x0                   	// #0
  414248:	97fff813 	bl	412294 <z_impl_k_thread_create>
	if ((cfg != NULL) && (cfg->name != NULL)) {
  41424c:	b40000b4 	cbz	x20, 414260 <k_work_queue_start+0x148>
  414250:	f9400281 	ldr	x1, [x20]
  414254:	b4000061 	cbz	x1, 414260 <k_work_queue_start+0x148>
	return z_impl_k_thread_name_set(thread, str);
  414258:	aa1303e0 	mov	x0, x19
  41425c:	97fff799 	bl	4120c0 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
  414260:	aa1303e0 	mov	x0, x19
}
  414264:	a9417bfd 	ldp	x29, x30, [sp, #16]
  414268:	a94253f3 	ldp	x19, x20, [sp, #32]
  41426c:	9100c3ff 	add	sp, sp, #0x30
  414270:	17fff7a7 	b	41210c <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
  414274:	52800020 	mov	w0, #0x1                   	// #1
  414278:	17ffffea 	b	414220 <k_work_queue_start+0x108>

000000000041427c <k_work_init_delayable>:
{
  41427c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  414280:	910003fd 	mov	x29, sp
  414284:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(dwork != NULL);
  414288:	b5000240 	cbnz	x0, 4142d0 <k_work_init_delayable+0x54>
  41428c:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414290:	9111e273 	add	x19, x19, #0x478
  414294:	aa1303e2 	mov	x2, x19
  414298:	52806803 	mov	w3, #0x340                 	// #832
  41429c:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4142a0:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4142a4:	91142c21 	add	x1, x1, #0x50b
  4142a8:	91178000 	add	x0, x0, #0x5e0
  4142ac:	97ffcadf 	bl	406e28 <assert_print>
  4142b0:	aa1303e0 	mov	x0, x19
  4142b4:	52806801 	mov	w1, #0x340                 	// #832
  4142b8:	97ffcb06 	bl	406ed0 <assert_post_action>
  4142bc:	52806802 	mov	w2, #0x340                 	// #832
	__ASSERT_NO_MSG(handler != NULL);
  4142c0:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4142c4:	aa1303e1 	mov	x1, x19
  4142c8:	91187800 	add	x0, x0, #0x61e
  4142cc:	97ffd4f3 	bl	409698 <posix_print_error_and_exit>
  4142d0:	b50001e1 	cbnz	x1, 41430c <k_work_init_delayable+0x90>
  4142d4:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4142d8:	9111e273 	add	x19, x19, #0x478
  4142dc:	aa1303e2 	mov	x2, x19
  4142e0:	52806823 	mov	w3, #0x341                 	// #833
  4142e4:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4142e8:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4142ec:	91126421 	add	x1, x1, #0x499
  4142f0:	91178000 	add	x0, x0, #0x5e0
  4142f4:	97ffcacd 	bl	406e28 <assert_print>
  4142f8:	aa1303e0 	mov	x0, x19
  4142fc:	52806821 	mov	w1, #0x341                 	// #833
  414300:	97ffcaf4 	bl	406ed0 <assert_post_action>
  414304:	52806822 	mov	w2, #0x341                 	// #833
  414308:	17ffffee 	b	4142c0 <k_work_init_delayable+0x44>
	*dwork = (struct k_work_delayable){
  41430c:	4f000400 	movi	v0.4s, #0x0
  414310:	f900201f 	str	xzr, [x0, #64]
  414314:	ad000000 	stp	q0, q0, [x0]
  414318:	f9000401 	str	x1, [x0, #8]
  41431c:	52802001 	mov	w1, #0x100                 	// #256
  414320:	b9001801 	str	w1, [x0, #24]
  414324:	ad010000 	stp	q0, q0, [x0, #32]
}
  414328:	f9400bf3 	ldr	x19, [sp, #16]
  41432c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  414330:	d65f03c0 	ret

0000000000414334 <k_work_reschedule_for_queue>:
}

int k_work_reschedule_for_queue(struct k_work_q *queue,
				 struct k_work_delayable *dwork,
				 k_timeout_t delay)
{
  414334:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  414338:	910003fd 	mov	x29, sp
  41433c:	a90153f3 	stp	x19, x20, [sp, #16]
  414340:	a9025bf5 	stp	x21, x22, [sp, #32]
  414344:	f9001bf7 	str	x23, [sp, #48]
  414348:	f90027e0 	str	x0, [sp, #72]
	__ASSERT_NO_MSG(dwork != NULL);
  41434c:	b5000241 	cbnz	x1, 414394 <k_work_reschedule_for_queue+0x60>
  414350:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414354:	9111e273 	add	x19, x19, #0x478
  414358:	aa1303e2 	mov	x2, x19
  41435c:	52807bc3 	mov	w3, #0x3de                 	// #990
  414360:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  414364:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414368:	91142c21 	add	x1, x1, #0x50b
  41436c:	91178000 	add	x0, x0, #0x5e0
  414370:	97ffcaae 	bl	406e28 <assert_print>
  414374:	aa1303e0 	mov	x0, x19
  414378:	52807bc1 	mov	w1, #0x3de                 	// #990
  41437c:	97ffcad5 	bl	406ed0 <assert_post_action>
  414380:	52807bc2 	mov	w2, #0x3de                 	// #990
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  414384:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414388:	aa1303e1 	mov	x1, x19
  41438c:	91187800 	add	x0, x0, #0x61e
  414390:	97ffd4c2 	bl	409698 <posix_print_error_and_exit>
  414394:	aa0103f3 	mov	x19, x1
  414398:	aa0203f5 	mov	x21, x2
  41439c:	90000114 	adrp	x20, 434000 <ztest_thread+0xb8>
  4143a0:	97ffd3a8 	bl	409240 <posix_irq_lock>
  4143a4:	91212297 	add	x23, x20, #0x848
  4143a8:	2a0003f6 	mov	w22, w0
  4143ac:	aa1703e0 	mov	x0, x23
  4143b0:	97fff84b 	bl	4124dc <z_spin_lock_valid>
  4143b4:	72001c1f 	tst	w0, #0xff
  4143b8:	54000261 	b.ne	414404 <k_work_reschedule_for_queue+0xd0>  // b.any
  4143bc:	b0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  4143c0:	912c1273 	add	x19, x19, #0xb04
  4143c4:	aa1303e2 	mov	x2, x19
  4143c8:	52801283 	mov	w3, #0x94                  	// #148
  4143cc:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4143d0:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4143d4:	912cc421 	add	x1, x1, #0xb31
  4143d8:	91178000 	add	x0, x0, #0x5e0
  4143dc:	97ffca93 	bl	406e28 <assert_print>
  4143e0:	aa1703e1 	mov	x1, x23
  4143e4:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4143e8:	912d1800 	add	x0, x0, #0xb46
  4143ec:	97ffca8f 	bl	406e28 <assert_print>
  4143f0:	aa1303e0 	mov	x0, x19
  4143f4:	52801281 	mov	w1, #0x94                  	// #148
  4143f8:	97ffcab6 	bl	406ed0 <assert_post_action>
  4143fc:	52801282 	mov	w2, #0x94                  	// #148
  414400:	17ffffe1 	b	414384 <k_work_reschedule_for_queue+0x50>
	z_spin_lock_set_owner(l);
  414404:	aa1703e0 	mov	x0, x23
  414408:	97fff84d 	bl	41253c <z_spin_lock_set_owner>

	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Remove any active scheduling. */
	(void)unschedule_locked(dwork);
  41440c:	aa1303e0 	mov	x0, x19
  414410:	97fffd20 	bl	413890 <unschedule_locked>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
  414414:	b5000395 	cbnz	x21, 414484 <k_work_reschedule_for_queue+0x150>
		return submit_to_queue_locked(work, queuep);
  414418:	aa1303e0 	mov	x0, x19
  41441c:	910123e1 	add	x1, sp, #0x48
  414420:	97fffdde 	bl	413b98 <submit_to_queue_locked>
  414424:	2a0003f3 	mov	w19, w0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414428:	91212294 	add	x20, x20, #0x848
  41442c:	aa1403e0 	mov	x0, x20
  414430:	97fff836 	bl	412508 <z_spin_unlock_valid>
  414434:	72001c1f 	tst	w0, #0xff
  414438:	540003e1 	b.ne	4144b4 <k_work_reschedule_for_queue+0x180>  // b.any
  41443c:	b0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  414440:	912c1273 	add	x19, x19, #0xb04
  414444:	aa1303e2 	mov	x2, x19
  414448:	52801863 	mov	w3, #0xc3                  	// #195
  41444c:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414450:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414454:	912d7821 	add	x1, x1, #0xb5e
  414458:	91178000 	add	x0, x0, #0x5e0
  41445c:	97ffca73 	bl	406e28 <assert_print>
  414460:	aa1403e1 	mov	x1, x20
  414464:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414468:	912dd400 	add	x0, x0, #0xb75
  41446c:	97ffca6f 	bl	406e28 <assert_print>
  414470:	aa1303e0 	mov	x0, x19
  414474:	52801861 	mov	w1, #0xc3                  	// #195
  414478:	97ffca96 	bl	406ed0 <assert_post_action>
  41447c:	52801862 	mov	w2, #0xc3                  	// #195
  414480:	17ffffc1 	b	414384 <k_work_reschedule_for_queue+0x50>
	*flagp |= BIT(bit);
  414484:	b9401a60 	ldr	w0, [x19, #24]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
  414488:	aa1503e2 	mov	x2, x21
  41448c:	f0ffffe1 	adrp	x1, 413000 <z_impl_k_mutex_unlock+0x10c>
  414490:	91341021 	add	x1, x1, #0xd04
	*flagp |= BIT(bit);
  414494:	321d0000 	orr	w0, w0, #0x8
  414498:	b9001a60 	str	w0, [x19, #24]
	dwork->queue = *queuep;
  41449c:	f94027e0 	ldr	x0, [sp, #72]
  4144a0:	f9002260 	str	x0, [x19, #64]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
  4144a4:	91008260 	add	x0, x19, #0x20
	return ret;
  4144a8:	52800033 	mov	w19, #0x1                   	// #1
	z_add_timeout(&dwork->timeout, work_timeout, delay);
  4144ac:	94000a35 	bl	416d80 <z_add_timeout>
	return ret;
  4144b0:	17ffffde 	b	414428 <k_work_reschedule_for_queue+0xf4>
	posix_irq_unlock(key);
  4144b4:	2a1603e0 	mov	w0, w22
  4144b8:	97ffd364 	bl	409248 <posix_irq_unlock>
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
  4144bc:	2a1303e0 	mov	w0, w19
  4144c0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4144c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4144c8:	f9401bf7 	ldr	x23, [sp, #48]
  4144cc:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4144d0:	d65f03c0 	ret

00000000004144d4 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
  4144d4:	79403401 	ldrh	w1, [x0, #26]
  4144d8:	7101fc3f 	cmp	w1, #0x7f
  4144dc:	54000248 	b.hi	414524 <sliceable+0x50>  // b.pmore
	int ret = slice_ticks;
  4144e0:	90000101 	adrp	x1, 434000 <ztest_thread+0xb8>
  4144e4:	b94e1c21 	ldr	w1, [x1, #3612]
		&& slice_time(thread) != 0
  4144e8:	340001a1 	cbz	w1, 41451c <sliceable+0x48>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
  4144ec:	90000101 	adrp	x1, 434000 <ztest_thread+0xb8>
  4144f0:	39c06802 	ldrsb	w2, [x0, #26]
  4144f4:	b94e1821 	ldr	w1, [x1, #3608]
  4144f8:	6b01005f 	cmp	w2, w1
  4144fc:	5400014b 	b.lt	414524 <sliceable+0x50>  // b.tstop
		&& !z_is_thread_prevented_from_running(thread)
  414500:	39406401 	ldrb	w1, [x0, #25]
  414504:	f240103f 	tst	x1, #0x1f
  414508:	540000e1 	b.ne	414524 <sliceable+0x50>  // b.any
		&& !z_is_idle_thread_object(thread);
  41450c:	b00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  414510:	f946e021 	ldr	x1, [x1, #3520]
  414514:	eb01001f 	cmp	x0, x1
  414518:	1a9f07e1 	cset	w1, ne  // ne = any
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
  41451c:	12000020 	and	w0, w1, #0x1
  414520:	d65f03c0 	ret
		&& !z_is_idle_thread_object(thread);
  414524:	52800001 	mov	w1, #0x0                   	// #0
  414528:	17fffffd 	b	41451c <sliceable+0x48>

000000000041452c <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  41452c:	b4000160 	cbz	x0, 414558 <slice_timeout+0x2c>
  414530:	90000101 	adrp	x1, 434000 <ztest_thread+0xb8>
  414534:	9121a021 	add	x1, x1, #0x868
  414538:	eb01001f 	cmp	x0, x1
  41453c:	540000e3 	b.cc	414558 <slice_timeout+0x2c>  // b.lo, b.ul, b.last
  414540:	91008022 	add	x2, x1, #0x20
  414544:	eb02001f 	cmp	x0, x2
  414548:	54000082 	b.cs	414558 <slice_timeout+0x2c>  // b.hs, b.nlast
  41454c:	cb010000 	sub	x0, x0, x1
  414550:	f240101f 	tst	x0, #0x1f
  414554:	540002a0 	b.eq	4145a8 <slice_timeout+0x7c>  // b.none
{
  414558:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  41455c:	528038e3 	mov	w3, #0x1c7                 	// #455
  414560:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
{
  414564:	910003fd 	mov	x29, sp
  414568:	f9000bf3 	str	x19, [sp, #16]
	int cpu = ARRAY_INDEX(slice_timeouts, t);
  41456c:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414570:	91148273 	add	x19, x19, #0x520
  414574:	91150821 	add	x1, x1, #0x542
  414578:	aa1303e2 	mov	x2, x19
  41457c:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414580:	91178000 	add	x0, x0, #0x5e0
  414584:	97ffca29 	bl	406e28 <assert_print>
  414588:	aa1303e0 	mov	x0, x19
  41458c:	528038e1 	mov	w1, #0x1c7                 	// #455
  414590:	97ffca50 	bl	406ed0 <assert_post_action>
  414594:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414598:	aa1303e1 	mov	x1, x19
  41459c:	91187800 	add	x0, x0, #0x61e
  4145a0:	528038e2 	mov	w2, #0x1c7                 	// #455
  4145a4:	97ffd43d 	bl	409698 <posix_print_error_and_exit>

	slice_expired[cpu] = true;
  4145a8:	93459000 	sbfx	x0, x0, #5, #32
  4145ac:	b0000101 	adrp	x1, 435000 <stdout_buff+0xc1>
  4145b0:	9105a821 	add	x1, x1, #0x16a
  4145b4:	52800022 	mov	w2, #0x1                   	// #1
  4145b8:	38206822 	strb	w2, [x1, x0]
  4145bc:	d65f03c0 	ret

00000000004145c0 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
  4145c0:	39c06802 	ldrsb	w2, [x0, #26]
	int32_t b2 = thread_2->base.prio;
  4145c4:	39c06821 	ldrsb	w1, [x1, #26]
		return b2 - b1;
  4145c8:	4b020020 	sub	w0, w1, w2
  4145cc:	6b01005f 	cmp	w2, w1
}
  4145d0:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
  4145d4:	d65f03c0 	ret

00000000004145d8 <z_reset_time_slice>:
		flag_ipi();
	}
}

void z_reset_time_slice(struct k_thread *curr)
{
  4145d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int cpu = _current_cpu->id;
  4145dc:	b00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
{
  4145e0:	910003fd 	mov	x29, sp
	int cpu = _current_cpu->id;
  4145e4:	f9471021 	ldr	x1, [x1, #3616]
{
  4145e8:	a90153f3 	stp	x19, x20, [sp, #16]
  4145ec:	aa0003f4 	mov	x20, x0
  4145f0:	f90013f5 	str	x21, [sp, #32]

	z_abort_timeout(&slice_timeouts[cpu]);
  4145f4:	90000100 	adrp	x0, 434000 <ztest_thread+0xb8>
  4145f8:	9121a000 	add	x0, x0, #0x868
  4145fc:	39408033 	ldrb	w19, [x1, #32]
	int cpu = _current_cpu->id;
  414600:	39408035 	ldrb	w21, [x1, #32]
	z_abort_timeout(&slice_timeouts[cpu]);
  414604:	8b131413 	add	x19, x0, x19, lsl #5
  414608:	aa1303e0 	mov	x0, x19
  41460c:	94000a6f 	bl	416fc8 <z_abort_timeout>
	slice_expired[cpu] = false;
  414610:	b0000100 	adrp	x0, 435000 <stdout_buff+0xc1>
  414614:	9105a800 	add	x0, x0, #0x16a
  414618:	3835c81f 	strb	wzr, [x0, w21, sxtw]
	if (sliceable(curr)) {
  41461c:	aa1403e0 	mov	x0, x20
  414620:	97ffffad 	bl	4144d4 <sliceable>
  414624:	72001c1f 	tst	w0, #0xff
  414628:	54000180 	b.eq	414658 <z_reset_time_slice+0x80>  // b.none
	int ret = slice_ticks;
  41462c:	90000100 	adrp	x0, 434000 <ztest_thread+0xb8>
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  414630:	90000001 	adrp	x1, 414000 <z_work_submit_to_queue+0xf0>
			      K_TICKS(slice_time(curr) - 1));
	}
}
  414634:	f94013f5 	ldr	x21, [sp, #32]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  414638:	9114b021 	add	x1, x1, #0x52c
			      K_TICKS(slice_time(curr) - 1));
  41463c:	b94e1c02 	ldr	w2, [x0, #3612]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  414640:	aa1303e0 	mov	x0, x19
}
  414644:	a94153f3 	ldp	x19, x20, [sp, #16]
			      K_TICKS(slice_time(curr) - 1));
  414648:	51000442 	sub	w2, w2, #0x1
}
  41464c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
  414650:	93407c42 	sxtw	x2, w2
  414654:	140009cb 	b	416d80 <z_add_timeout>
}
  414658:	a94153f3 	ldp	x19, x20, [sp, #16]
  41465c:	f94013f5 	ldr	x21, [sp, #32]
  414660:	a8c37bfd 	ldp	x29, x30, [sp], #48
  414664:	d65f03c0 	ret

0000000000414668 <z_unpend_thread_no_timeout>:
	z_mark_thread_as_not_pending(thread);
	thread->base.pended_on = NULL;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
  414668:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  41466c:	910003fd 	mov	x29, sp
  414670:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  414674:	b00000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  414678:	aa0003f4 	mov	x20, x0
  41467c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  414680:	97ffd2f0 	bl	409240 <posix_irq_lock>
  414684:	2a0003f5 	mov	w21, w0
  414688:	f947ce76 	ldr	x22, [x19, #3992]
  41468c:	aa1603e0 	mov	x0, x22
  414690:	97fff793 	bl	4124dc <z_spin_lock_valid>
  414694:	72001c1f 	tst	w0, #0xff
  414698:	540002c1 	b.ne	4146f0 <z_unpend_thread_no_timeout+0x88>  // b.any
  41469c:	b0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  4146a0:	912c1273 	add	x19, x19, #0xb04
  4146a4:	aa1303e2 	mov	x2, x19
  4146a8:	52801283 	mov	w3, #0x94                  	// #148
  4146ac:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4146b0:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4146b4:	912cc421 	add	x1, x1, #0xb31
  4146b8:	91178000 	add	x0, x0, #0x5e0
  4146bc:	97ffc9db 	bl	406e28 <assert_print>
  4146c0:	aa1603e1 	mov	x1, x22
  4146c4:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4146c8:	912d1800 	add	x0, x0, #0xb46
  4146cc:	97ffc9d7 	bl	406e28 <assert_print>
  4146d0:	52801281 	mov	w1, #0x94                  	// #148
  4146d4:	aa1303e0 	mov	x0, x19
  4146d8:	97ffc9fe 	bl	406ed0 <assert_post_action>
  4146dc:	aa1303e1 	mov	x1, x19
  4146e0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4146e4:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4146e8:	91187800 	add	x0, x0, #0x61e
  4146ec:	97ffd3eb 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4146f0:	aa1603e0 	mov	x0, x22
  4146f4:	97fff792 	bl	41253c <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		if (thread->base.pended_on != NULL) {
  4146f8:	f9400a80 	ldr	x0, [x20, #16]
  4146fc:	b4000060 	cbz	x0, 414708 <z_unpend_thread_no_timeout+0xa0>
			unpend_thread_no_timeout(thread);
  414700:	aa1403e0 	mov	x0, x20
  414704:	940000f5 	bl	414ad8 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414708:	f947ce73 	ldr	x19, [x19, #3992]
  41470c:	aa1303e0 	mov	x0, x19
  414710:	97fff77e 	bl	412508 <z_spin_unlock_valid>
  414714:	72001c1f 	tst	w0, #0xff
  414718:	54000281 	b.ne	414768 <z_unpend_thread_no_timeout+0x100>  // b.any
  41471c:	b0000034 	adrp	x20, 419000 <__func__.2+0xa80>
  414720:	912c1294 	add	x20, x20, #0xb04
  414724:	aa1403e2 	mov	x2, x20
  414728:	52801863 	mov	w3, #0xc3                  	// #195
  41472c:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414730:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414734:	912d7821 	add	x1, x1, #0xb5e
  414738:	91178000 	add	x0, x0, #0x5e0
  41473c:	97ffc9bb 	bl	406e28 <assert_print>
  414740:	aa1303e1 	mov	x1, x19
  414744:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414748:	912dd400 	add	x0, x0, #0xb75
  41474c:	97ffc9b7 	bl	406e28 <assert_print>
  414750:	52801861 	mov	w1, #0xc3                  	// #195
  414754:	aa1403e0 	mov	x0, x20
  414758:	97ffc9de 	bl	406ed0 <assert_post_action>
  41475c:	aa1403e1 	mov	x1, x20
  414760:	52801862 	mov	w2, #0xc3                  	// #195
  414764:	17ffffe0 	b	4146e4 <z_unpend_thread_no_timeout+0x7c>
	posix_irq_unlock(key);
  414768:	2a1503e0 	mov	w0, w21
		}
	}
}
  41476c:	a94153f3 	ldp	x19, x20, [sp, #16]
  414770:	a9425bf5 	ldp	x21, x22, [sp, #32]
  414774:	a8c37bfd 	ldp	x29, x30, [sp], #48
  414778:	17ffd2b4 	b	409248 <posix_irq_unlock>

000000000041477c <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
  41477c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return _kernel.cpus[0].nested != 0U;
  414780:	b00000e2 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  414784:	910003fd 	mov	x29, sp
  414788:	f9471042 	ldr	x2, [x2, #3616]
  41478c:	a90153f3 	stp	x19, x20, [sp, #16]
  414790:	2a0103f3 	mov	w19, w1
  414794:	aa0003f4 	mov	x20, x0
	if (resched(key.key) && need_swap()) {
  414798:	b9400041 	ldr	w1, [x2]
  41479c:	2a010261 	orr	w1, w19, w1
  4147a0:	35000421 	cbnz	w1, 414824 <z_reschedule+0xa8>
  4147a4:	f9400841 	ldr	x1, [x2, #16]
  4147a8:	f9401443 	ldr	x3, [x2, #40]
  4147ac:	eb01007f 	cmp	x3, x1
  4147b0:	540003a0 	b.eq	414824 <z_reschedule+0xa8>  // b.none
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4147b4:	97fff755 	bl	412508 <z_spin_unlock_valid>
  4147b8:	72001c1f 	tst	w0, #0xff
  4147bc:	540002c1 	b.ne	414814 <z_reschedule+0x98>  // b.any
  4147c0:	b0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  4147c4:	912c1273 	add	x19, x19, #0xb04
  4147c8:	aa1303e2 	mov	x2, x19
  4147cc:	52801c43 	mov	w3, #0xe2                  	// #226
  4147d0:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4147d4:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4147d8:	912d7821 	add	x1, x1, #0xb5e
  4147dc:	91178000 	add	x0, x0, #0x5e0
  4147e0:	97ffc992 	bl	406e28 <assert_print>
  4147e4:	aa1403e1 	mov	x1, x20
  4147e8:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4147ec:	912dd400 	add	x0, x0, #0xb75
  4147f0:	97ffc98e 	bl	406e28 <assert_print>
  4147f4:	aa1303e0 	mov	x0, x19
  4147f8:	52801c41 	mov	w1, #0xe2                  	// #226
  4147fc:	97ffc9b5 	bl	406ed0 <assert_post_action>
  414800:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414804:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414808:	aa1303e1 	mov	x1, x19
  41480c:	91187800 	add	x0, x0, #0x61e
  414810:	97ffd3a2 	bl	409698 <posix_print_error_and_exit>
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
  414814:	a94153f3 	ldp	x19, x20, [sp, #16]
	ret = arch_swap(key);
  414818:	52800000 	mov	w0, #0x0                   	// #0
  41481c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  414820:	17ffcf5e 	b	408598 <arch_swap>
  414824:	aa1403e0 	mov	x0, x20
  414828:	97fff738 	bl	412508 <z_spin_unlock_valid>
  41482c:	72001c1f 	tst	w0, #0xff
  414830:	54000261 	b.ne	41487c <z_reschedule+0x100>  // b.any
  414834:	b0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  414838:	912c1273 	add	x19, x19, #0xb04
  41483c:	aa1303e2 	mov	x2, x19
  414840:	52801863 	mov	w3, #0xc3                  	// #195
  414844:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414848:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  41484c:	912d7821 	add	x1, x1, #0xb5e
  414850:	91178000 	add	x0, x0, #0x5e0
  414854:	97ffc975 	bl	406e28 <assert_print>
  414858:	aa1403e1 	mov	x1, x20
  41485c:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414860:	912dd400 	add	x0, x0, #0xb75
  414864:	97ffc971 	bl	406e28 <assert_print>
  414868:	aa1303e0 	mov	x0, x19
  41486c:	52801861 	mov	w1, #0xc3                  	// #195
  414870:	97ffc998 	bl	406ed0 <assert_post_action>
  414874:	52801862 	mov	w2, #0xc3                  	// #195
  414878:	17ffffe3 	b	414804 <z_reschedule+0x88>
  41487c:	2a1303e0 	mov	w0, w19
  414880:	a94153f3 	ldp	x19, x20, [sp, #16]
  414884:	a8c27bfd 	ldp	x29, x30, [sp], #32
  414888:	17ffd270 	b	409248 <posix_irq_unlock>

000000000041488c <z_reschedule_irqlock>:
  41488c:	b00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  414890:	f9471021 	ldr	x1, [x1, #3616]

void z_reschedule_irqlock(uint32_t key)
{
	if (resched(key)) {
  414894:	b9400021 	ldr	w1, [x1]
  414898:	2a010001 	orr	w1, w0, w1
  41489c:	35000061 	cbnz	w1, 4148a8 <z_reschedule_irqlock+0x1c>
  4148a0:	52800000 	mov	w0, #0x0                   	// #0
  4148a4:	17ffcf3d 	b	408598 <arch_swap>
  4148a8:	17ffd268 	b	409248 <posix_irq_unlock>

00000000004148ac <z_reschedule_unlocked>:
{
  4148ac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4148b0:	910003fd 	mov	x29, sp
	return posix_irq_lock();
  4148b4:	97ffd263 	bl	409240 <posix_irq_lock>
}
  4148b8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	(void) z_reschedule_irqlock(arch_irq_lock());
  4148bc:	17fffff4 	b	41488c <z_reschedule_irqlock>

00000000004148c0 <k_sched_lock>:
		signal_pending_ipi();
	}
}

void k_sched_lock(void)
{
  4148c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4148c4:	910003fd 	mov	x29, sp
  4148c8:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4148cc:	b00000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  4148d0:	97ffd25c 	bl	409240 <posix_irq_lock>
  4148d4:	f947ce73 	ldr	x19, [x19, #3992]
  4148d8:	2a0003f4 	mov	w20, w0
  4148dc:	aa1303e0 	mov	x0, x19
  4148e0:	97fff6ff 	bl	4124dc <z_spin_lock_valid>
  4148e4:	72001c1f 	tst	w0, #0xff
  4148e8:	54000281 	b.ne	414938 <k_sched_lock+0x78>  // b.any
  4148ec:	b0000034 	adrp	x20, 419000 <__func__.2+0xa80>
  4148f0:	912c1294 	add	x20, x20, #0xb04
  4148f4:	aa1403e2 	mov	x2, x20
  4148f8:	52801283 	mov	w3, #0x94                  	// #148
  4148fc:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414900:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414904:	912cc421 	add	x1, x1, #0xb31
  414908:	91178000 	add	x0, x0, #0x5e0
  41490c:	97ffc947 	bl	406e28 <assert_print>
  414910:	aa1303e1 	mov	x1, x19
  414914:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414918:	912d1800 	add	x0, x0, #0xb46
  41491c:	97ffc943 	bl	406e28 <assert_print>
  414920:	aa1403e0 	mov	x0, x20
  414924:	52801281 	mov	w1, #0x94                  	// #148
  414928:	97ffc96a 	bl	406ed0 <assert_post_action>
  41492c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414930:	aa1403e1 	mov	x1, x20
  414934:	14000018 	b	414994 <k_sched_lock+0xd4>
	z_spin_lock_set_owner(l);
  414938:	aa1303e0 	mov	x0, x19
  41493c:	97fff700 	bl	41253c <z_spin_lock_set_owner>
  414940:	b00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  414944:	f9471021 	ldr	x1, [x1, #3616]
	__ASSERT(!arch_is_in_isr(), "");
  414948:	b9400020 	ldr	w0, [x1]
  41494c:	340002a0 	cbz	w0, 4149a0 <k_sched_lock+0xe0>
  414950:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414954:	911b6e73 	add	x19, x19, #0x6db
  414958:	aa1303e2 	mov	x2, x19
  41495c:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  414960:	910a4421 	add	x1, x1, #0x291
  414964:	52801fa3 	mov	w3, #0xfd                  	// #253
  414968:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  41496c:	91178000 	add	x0, x0, #0x5e0
  414970:	97ffc92e 	bl	406e28 <assert_print>
  414974:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414978:	912e6c00 	add	x0, x0, #0xb9b
  41497c:	97ffc92b 	bl	406e28 <assert_print>
  414980:	aa1303e0 	mov	x0, x19
  414984:	52801fa1 	mov	w1, #0xfd                  	// #253
  414988:	97ffc952 	bl	406ed0 <assert_post_action>
  41498c:	52801fa2 	mov	w2, #0xfd                  	// #253
  414990:	aa1303e1 	mov	x1, x19
  414994:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414998:	91187800 	add	x0, x0, #0x61e
  41499c:	97ffd33f 	bl	409698 <posix_print_error_and_exit>
	__ASSERT(_current->base.sched_locked != 1U, "");
  4149a0:	f9400820 	ldr	x0, [x1, #16]
  4149a4:	39406c01 	ldrb	w1, [x0, #27]
  4149a8:	7100043f 	cmp	w1, #0x1
  4149ac:	54000241 	b.ne	4149f4 <k_sched_lock+0x134>  // b.any
  4149b0:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4149b4:	911b6e73 	add	x19, x19, #0x6db
  4149b8:	aa1303e2 	mov	x2, x19
  4149bc:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4149c0:	911c1821 	add	x1, x1, #0x706
  4149c4:	52801fc3 	mov	w3, #0xfe                  	// #254
  4149c8:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  4149cc:	91178000 	add	x0, x0, #0x5e0
  4149d0:	97ffc916 	bl	406e28 <assert_print>
  4149d4:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4149d8:	912e6c00 	add	x0, x0, #0xb9b
  4149dc:	97ffc913 	bl	406e28 <assert_print>
  4149e0:	aa1303e0 	mov	x0, x19
  4149e4:	52801fc1 	mov	w1, #0xfe                  	// #254
  4149e8:	97ffc93a 	bl	406ed0 <assert_post_action>
  4149ec:	52801fc2 	mov	w2, #0xfe                  	// #254
  4149f0:	17ffffe8 	b	414990 <k_sched_lock+0xd0>
	--_current->base.sched_locked;
  4149f4:	51000421 	sub	w1, w1, #0x1
  4149f8:	39006c01 	strb	w1, [x0, #27]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4149fc:	aa1303e0 	mov	x0, x19
  414a00:	97fff6c2 	bl	412508 <z_spin_unlock_valid>
  414a04:	72001c1f 	tst	w0, #0xff
  414a08:	54000261 	b.ne	414a54 <k_sched_lock+0x194>  // b.any
  414a0c:	b0000034 	adrp	x20, 419000 <__func__.2+0xa80>
  414a10:	912c1294 	add	x20, x20, #0xb04
  414a14:	aa1403e2 	mov	x2, x20
  414a18:	52801863 	mov	w3, #0xc3                  	// #195
  414a1c:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414a20:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414a24:	912d7821 	add	x1, x1, #0xb5e
  414a28:	91178000 	add	x0, x0, #0x5e0
  414a2c:	97ffc8ff 	bl	406e28 <assert_print>
  414a30:	aa1303e1 	mov	x1, x19
  414a34:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414a38:	912dd400 	add	x0, x0, #0xb75
  414a3c:	97ffc8fb 	bl	406e28 <assert_print>
  414a40:	aa1403e0 	mov	x0, x20
  414a44:	52801861 	mov	w1, #0xc3                  	// #195
  414a48:	97ffc922 	bl	406ed0 <assert_post_action>
  414a4c:	52801862 	mov	w2, #0xc3                  	// #195
  414a50:	17ffffb8 	b	414930 <k_sched_lock+0x70>
	posix_irq_unlock(key);
  414a54:	2a1403e0 	mov	w0, w20
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
  414a58:	a94153f3 	ldp	x19, x20, [sp, #16]
  414a5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  414a60:	17ffd1fa 	b	409248 <posix_irq_unlock>

0000000000414a64 <z_priq_dumb_remove>:
}
#endif

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  414a64:	b00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  414a68:	f946e000 	ldr	x0, [x0, #3520]
  414a6c:	eb00003f 	cmp	x1, x0
  414a70:	540002a1 	b.ne	414ac4 <z_priq_dumb_remove+0x60>  // b.any
{
  414a74:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  414a78:	52808f63 	mov	w3, #0x47b                 	// #1147
  414a7c:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
{
  414a80:	910003fd 	mov	x29, sp
  414a84:	f9000bf3 	str	x19, [sp, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  414a88:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414a8c:	91148273 	add	x19, x19, #0x520
  414a90:	911cdc21 	add	x1, x1, #0x737
  414a94:	aa1303e2 	mov	x2, x19
  414a98:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414a9c:	91178000 	add	x0, x0, #0x5e0
  414aa0:	97ffc8e2 	bl	406e28 <assert_print>
  414aa4:	aa1303e0 	mov	x0, x19
  414aa8:	52808f61 	mov	w1, #0x47b                 	// #1147
  414aac:	97ffc909 	bl	406ed0 <assert_post_action>
  414ab0:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414ab4:	aa1303e1 	mov	x1, x19
  414ab8:	91187800 	add	x0, x0, #0x61e
  414abc:	52808f62 	mov	w2, #0x47b                 	// #1147
  414ac0:	97ffd2f6 	bl	409698 <posix_print_error_and_exit>
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
  414ac4:	a9400820 	ldp	x0, x2, [x1]
	sys_dnode_t *const next = node->next;

	prev->next = next;
  414ac8:	f9000040 	str	x0, [x2]
	next->prev = prev;
  414acc:	f9000402 	str	x2, [x0, #8]
	node->prev = NULL;
  414ad0:	a9007c3f 	stp	xzr, xzr, [x1]
  414ad4:	d65f03c0 	ret

0000000000414ad8 <unpend_thread_no_timeout>:
{
  414ad8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  414adc:	910003fd 	mov	x29, sp
  414ae0:	f9000bf3 	str	x19, [sp, #16]
  414ae4:	aa0003f3 	mov	x19, x0
  414ae8:	f9400800 	ldr	x0, [x0, #16]
	__ASSERT_NO_MSG(thread->base.pended_on);
  414aec:	b5000240 	cbnz	x0, 414b34 <unpend_thread_no_timeout+0x5c>
  414af0:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414af4:	91148273 	add	x19, x19, #0x520
  414af8:	aa1303e2 	mov	x2, x19
  414afc:	528058a3 	mov	w3, #0x2c5                 	// #709
  414b00:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  414b04:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414b08:	911d6021 	add	x1, x1, #0x758
  414b0c:	91178000 	add	x0, x0, #0x5e0
  414b10:	97ffc8c6 	bl	406e28 <assert_print>
  414b14:	aa1303e0 	mov	x0, x19
  414b18:	528058a1 	mov	w1, #0x2c5                 	// #709
  414b1c:	97ffc8ed 	bl	406ed0 <assert_post_action>
  414b20:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414b24:	aa1303e1 	mov	x1, x19
  414b28:	91187800 	add	x0, x0, #0x61e
  414b2c:	528058a2 	mov	w2, #0x2c5                 	// #709
  414b30:	97ffd2da 	bl	409698 <posix_print_error_and_exit>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
  414b34:	aa1303e1 	mov	x1, x19
  414b38:	97ffffcb 	bl	414a64 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
  414b3c:	39406660 	ldrb	w0, [x19, #25]
	thread->base.pended_on = NULL;
  414b40:	f9000a7f 	str	xzr, [x19, #16]
  414b44:	121e7800 	and	w0, w0, #0xfffffffd
  414b48:	39006660 	strb	w0, [x19, #25]
}
  414b4c:	f9400bf3 	ldr	x19, [sp, #16]
  414b50:	a8c27bfd 	ldp	x29, x30, [sp], #32
  414b54:	d65f03c0 	ret

0000000000414b58 <z_unpend_thread>:
{
  414b58:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  414b5c:	910003fd 	mov	x29, sp
  414b60:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  414b64:	b00000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  414b68:	aa0003f4 	mov	x20, x0
  414b6c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  414b70:	97ffd1b4 	bl	409240 <posix_irq_lock>
  414b74:	2a0003f5 	mov	w21, w0
  414b78:	f947ce76 	ldr	x22, [x19, #3992]
  414b7c:	aa1603e0 	mov	x0, x22
  414b80:	97fff657 	bl	4124dc <z_spin_lock_valid>
  414b84:	72001c1f 	tst	w0, #0xff
  414b88:	540002c1 	b.ne	414be0 <z_unpend_thread+0x88>  // b.any
  414b8c:	b0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  414b90:	912c1273 	add	x19, x19, #0xb04
  414b94:	aa1303e2 	mov	x2, x19
  414b98:	52801283 	mov	w3, #0x94                  	// #148
  414b9c:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414ba0:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414ba4:	912cc421 	add	x1, x1, #0xb31
  414ba8:	91178000 	add	x0, x0, #0x5e0
  414bac:	97ffc89f 	bl	406e28 <assert_print>
  414bb0:	aa1603e1 	mov	x1, x22
  414bb4:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414bb8:	912d1800 	add	x0, x0, #0xb46
  414bbc:	97ffc89b 	bl	406e28 <assert_print>
  414bc0:	52801281 	mov	w1, #0x94                  	// #148
  414bc4:	aa1303e0 	mov	x0, x19
  414bc8:	97ffc8c2 	bl	406ed0 <assert_post_action>
  414bcc:	aa1303e1 	mov	x1, x19
  414bd0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414bd4:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414bd8:	91187800 	add	x0, x0, #0x61e
  414bdc:	97ffd2af 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  414be0:	aa1603e0 	mov	x0, x22
  414be4:	97fff656 	bl	41253c <z_spin_lock_set_owner>
		if (thread->base.pended_on != NULL) {
  414be8:	f9400a80 	ldr	x0, [x20, #16]
  414bec:	b4000060 	cbz	x0, 414bf8 <z_unpend_thread+0xa0>
			unpend_thread_no_timeout(thread);
  414bf0:	aa1403e0 	mov	x0, x20
  414bf4:	97ffffb9 	bl	414ad8 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414bf8:	f947ce73 	ldr	x19, [x19, #3992]
  414bfc:	aa1303e0 	mov	x0, x19
  414c00:	97fff642 	bl	412508 <z_spin_unlock_valid>
  414c04:	72001c1f 	tst	w0, #0xff
  414c08:	54000281 	b.ne	414c58 <z_unpend_thread+0x100>  // b.any
  414c0c:	b0000034 	adrp	x20, 419000 <__func__.2+0xa80>
  414c10:	912c1294 	add	x20, x20, #0xb04
  414c14:	aa1403e2 	mov	x2, x20
  414c18:	52801863 	mov	w3, #0xc3                  	// #195
  414c1c:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414c20:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414c24:	912d7821 	add	x1, x1, #0xb5e
  414c28:	91178000 	add	x0, x0, #0x5e0
  414c2c:	97ffc87f 	bl	406e28 <assert_print>
  414c30:	aa1303e1 	mov	x1, x19
  414c34:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414c38:	912dd400 	add	x0, x0, #0xb75
  414c3c:	97ffc87b 	bl	406e28 <assert_print>
  414c40:	52801861 	mov	w1, #0xc3                  	// #195
  414c44:	aa1403e0 	mov	x0, x20
  414c48:	97ffc8a2 	bl	406ed0 <assert_post_action>
  414c4c:	aa1403e1 	mov	x1, x20
  414c50:	52801862 	mov	w2, #0xc3                  	// #195
  414c54:	17ffffe0 	b	414bd4 <z_unpend_thread+0x7c>
	posix_irq_unlock(key);
  414c58:	2a1503e0 	mov	w0, w21
  414c5c:	97ffd17b 	bl	409248 <posix_irq_unlock>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
  414c60:	9100a280 	add	x0, x20, #0x28
}
  414c64:	a94153f3 	ldp	x19, x20, [sp, #16]
  414c68:	a9425bf5 	ldp	x21, x22, [sp, #32]
  414c6c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  414c70:	140008d6 	b	416fc8 <z_abort_timeout>

0000000000414c74 <z_priq_dumb_best>:
	return list->head == list;
  414c74:	f9400001 	ldr	x1, [x0]
	sys_dlist_remove(&thread->base.qnode_dlist);
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
  414c78:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
  414c7c:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
  414c80:	d65f03c0 	ret

0000000000414c84 <update_cache>:
{
  414c84:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  414c88:	910003fd 	mov	x29, sp
  414c8c:	a90153f3 	stp	x19, x20, [sp, #16]
	return _priq_run_best(curr_cpu_runq());
  414c90:	b00000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
{
  414c94:	a9025bf5 	stp	x21, x22, [sp, #32]
  414c98:	2a0003f5 	mov	w21, w0
	return _priq_run_best(curr_cpu_runq());
  414c9c:	f9471276 	ldr	x22, [x19, #3616]
  414ca0:	9100c2c0 	add	x0, x22, #0x30
  414ca4:	97fffff4 	bl	414c74 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
  414ca8:	b5000340 	cbnz	x0, 414d10 <update_cache+0x8c>
  414cac:	f9400ed4 	ldr	x20, [x22, #24]
	__ASSERT(_current != NULL, "");
  414cb0:	f9471260 	ldr	x0, [x19, #3616]
  414cb4:	f9400801 	ldr	x1, [x0, #16]
	if (preempt_ok != 0) {
  414cb8:	350003d5 	cbnz	w21, 414d30 <update_cache+0xac>
	__ASSERT(_current != NULL, "");
  414cbc:	b50002e1 	cbnz	x1, 414d18 <update_cache+0x94>
  414cc0:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414cc4:	91148273 	add	x19, x19, #0x520
  414cc8:	aa1303e2 	mov	x2, x19
  414ccc:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  414cd0:	911dbc21 	add	x1, x1, #0x76f
  414cd4:	52801143 	mov	w3, #0x8a                  	// #138
  414cd8:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414cdc:	91178000 	add	x0, x0, #0x5e0
  414ce0:	97ffc852 	bl	406e28 <assert_print>
  414ce4:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414ce8:	912e6c00 	add	x0, x0, #0xb9b
  414cec:	97ffc84f 	bl	406e28 <assert_print>
  414cf0:	aa1303e0 	mov	x0, x19
  414cf4:	52801141 	mov	w1, #0x8a                  	// #138
  414cf8:	97ffc876 	bl	406ed0 <assert_post_action>
  414cfc:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414d00:	aa1303e1 	mov	x1, x19
  414d04:	91187800 	add	x0, x0, #0x61e
  414d08:	52801142 	mov	w2, #0x8a                  	// #138
  414d0c:	97ffd263 	bl	409698 <posix_print_error_and_exit>
  414d10:	aa0003f4 	mov	x20, x0
  414d14:	17ffffe7 	b	414cb0 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
  414d18:	39406420 	ldrb	w0, [x1, #25]
  414d1c:	f240101f 	tst	x0, #0x1f
  414d20:	54000081 	b.ne	414d30 <update_cache+0xac>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
  414d24:	79403420 	ldrh	w0, [x1, #26]
  414d28:	7101fc1f 	cmp	w0, #0x7f
  414d2c:	540000c8 	b.hi	414d44 <update_cache+0xc0>  // b.pmore
		if (thread != _current) {
  414d30:	eb01029f 	cmp	x20, x1
  414d34:	54000060 	b.eq	414d40 <update_cache+0xbc>  // b.none
			z_reset_time_slice(thread);
  414d38:	aa1403e0 	mov	x0, x20
  414d3c:	97fffe27 	bl	4145d8 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
  414d40:	aa1403e1 	mov	x1, x20
  414d44:	f9471273 	ldr	x19, [x19, #3616]
  414d48:	f9001661 	str	x1, [x19, #40]
}
  414d4c:	a94153f3 	ldp	x19, x20, [sp, #16]
  414d50:	a9425bf5 	ldp	x21, x22, [sp, #32]
  414d54:	a8c37bfd 	ldp	x29, x30, [sp], #48
  414d58:	d65f03c0 	ret

0000000000414d5c <move_thread_to_end_of_prio_q>:
{
  414d5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  414d60:	910003fd 	mov	x29, sp
  414d64:	a90153f3 	stp	x19, x20, [sp, #16]
  414d68:	aa0003f3 	mov	x19, x0
  414d6c:	a9025bf5 	stp	x21, x22, [sp, #32]
  414d70:	b00000f5 	adrp	x21, 431000 <__FRAME_END__+0x10804>
	if (z_is_thread_queued(thread)) {
  414d74:	39c06661 	ldrsb	w1, [x19, #25]
	return (thread->base.thread_state & state) != 0U;
  414d78:	39406400 	ldrb	w0, [x0, #25]
  414d7c:	36f800e1 	tbz	w1, #31, 414d98 <move_thread_to_end_of_prio_q+0x3c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  414d80:	12001800 	and	w0, w0, #0x7f
  414d84:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  414d88:	f94712a0 	ldr	x0, [x21, #3616]
  414d8c:	aa1303e1 	mov	x1, x19
  414d90:	9100c000 	add	x0, x0, #0x30
  414d94:	97ffff34 	bl	414a64 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  414d98:	39406660 	ldrb	w0, [x19, #25]
  414d9c:	32196000 	orr	w0, w0, #0xffffff80
  414da0:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  414da4:	b00000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  414da8:	f946e000 	ldr	x0, [x0, #3520]
  414dac:	eb00027f 	cmp	x19, x0
  414db0:	54000241 	b.ne	414df8 <move_thread_to_end_of_prio_q+0x9c>  // b.any
  414db4:	d0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  414db8:	91148273 	add	x19, x19, #0x520
  414dbc:	aa1303e2 	mov	x2, x19
  414dc0:	52801783 	mov	w3, #0xbc                  	// #188
  414dc4:	d0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  414dc8:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414dcc:	911cdc21 	add	x1, x1, #0x737
  414dd0:	91178000 	add	x0, x0, #0x5e0
  414dd4:	97ffc815 	bl	406e28 <assert_print>
  414dd8:	aa1303e0 	mov	x0, x19
  414ddc:	52801781 	mov	w1, #0xbc                  	// #188
  414de0:	97ffc83c 	bl	406ed0 <assert_post_action>
  414de4:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414de8:	aa1303e1 	mov	x1, x19
  414dec:	91187800 	add	x0, x0, #0x61e
  414df0:	52801782 	mov	w2, #0xbc                  	// #188
  414df4:	97ffd229 	bl	409698 <posix_print_error_and_exit>
  414df8:	f94712b6 	ldr	x22, [x21, #3616]
  414dfc:	aa1603e0 	mov	x0, x22
  414e00:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  414e04:	eb00029f 	cmp	x20, x0
  414e08:	54000261 	b.ne	414e54 <move_thread_to_end_of_prio_q+0xf8>  // b.any
	sys_dnode_t *const tail = list->tail;
  414e0c:	f94712a0 	ldr	x0, [x21, #3616]
	node->next = list;
  414e10:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  414e14:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  414e18:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  414e1c:	f9000033 	str	x19, [x1]
	list->tail = node;
  414e20:	f9001c13 	str	x19, [x0, #56]
	update_cache(thread == _current);
  414e24:	f94712b5 	ldr	x21, [x21, #3616]
  414e28:	f9400aa0 	ldr	x0, [x21, #16]
}
  414e2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	update_cache(thread == _current);
  414e30:	eb13001f 	cmp	x0, x19
}
  414e34:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  414e38:	1a9f17e0 	cset	w0, eq  // eq = none
}
  414e3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	update_cache(thread == _current);
  414e40:	17ffff91 	b	414c84 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  414e44:	f9401ec0 	ldr	x0, [x22, #56]
  414e48:	eb14001f 	cmp	x0, x20
  414e4c:	54fffe00 	b.eq	414e0c <move_thread_to_end_of_prio_q+0xb0>  // b.none
  414e50:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  414e54:	b4fffdd4 	cbz	x20, 414e0c <move_thread_to_end_of_prio_q+0xb0>
		if (z_sched_prio_cmp(thread, t) > 0) {
  414e58:	aa1403e1 	mov	x1, x20
  414e5c:	aa1303e0 	mov	x0, x19
  414e60:	97fffdd8 	bl	4145c0 <z_sched_prio_cmp>
  414e64:	7100001f 	cmp	w0, #0x0
  414e68:	54fffeed 	b.le	414e44 <move_thread_to_end_of_prio_q+0xe8>
	sys_dnode_t *const prev = successor->prev;
  414e6c:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  414e70:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  414e74:	f9000013 	str	x19, [x0]
	successor->prev = node;
  414e78:	f9000693 	str	x19, [x20, #8]
}
  414e7c:	17ffffea 	b	414e24 <move_thread_to_end_of_prio_q+0xc8>

0000000000414e80 <z_time_slice>:
{
  414e80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  414e84:	910003fd 	mov	x29, sp
  414e88:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  414e8c:	b00000f4 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  414e90:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  414e94:	97ffd0eb 	bl	409240 <posix_irq_lock>
  414e98:	2a0003f6 	mov	w22, w0
  414e9c:	f947ce95 	ldr	x21, [x20, #3992]
  414ea0:	aa1503e0 	mov	x0, x21
  414ea4:	97fff58e 	bl	4124dc <z_spin_lock_valid>
  414ea8:	72001c1f 	tst	w0, #0xff
  414eac:	540002c1 	b.ne	414f04 <z_time_slice+0x84>  // b.any
  414eb0:	b0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  414eb4:	912c1273 	add	x19, x19, #0xb04
  414eb8:	aa1303e2 	mov	x2, x19
  414ebc:	52801283 	mov	w3, #0x94                  	// #148
  414ec0:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414ec4:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414ec8:	912cc421 	add	x1, x1, #0xb31
  414ecc:	91178000 	add	x0, x0, #0x5e0
  414ed0:	97ffc7d6 	bl	406e28 <assert_print>
  414ed4:	aa1503e1 	mov	x1, x21
  414ed8:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414edc:	912d1800 	add	x0, x0, #0xb46
  414ee0:	97ffc7d2 	bl	406e28 <assert_print>
  414ee4:	aa1303e0 	mov	x0, x19
  414ee8:	52801281 	mov	w1, #0x94                  	// #148
  414eec:	97ffc7f9 	bl	406ed0 <assert_post_action>
  414ef0:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414ef4:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414ef8:	aa1303e1 	mov	x1, x19
  414efc:	91187800 	add	x0, x0, #0x61e
  414f00:	97ffd1e6 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  414f04:	aa1503e0 	mov	x0, x21
  414f08:	97fff58d 	bl	41253c <z_spin_lock_set_owner>
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  414f0c:	b00000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  414f10:	b0000102 	adrp	x2, 435000 <stdout_buff+0xc1>
  414f14:	9105a842 	add	x2, x2, #0x16a
  414f18:	f9471021 	ldr	x1, [x1, #3616]
  414f1c:	39408020 	ldrb	w0, [x1, #32]
  414f20:	38606840 	ldrb	w0, [x2, x0]
  414f24:	340001a0 	cbz	w0, 414f58 <z_time_slice+0xd8>
	struct k_thread *curr = _current;
  414f28:	f9400833 	ldr	x19, [x1, #16]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
  414f2c:	aa1303e0 	mov	x0, x19
  414f30:	97fffd69 	bl	4144d4 <sliceable>
  414f34:	72001c1f 	tst	w0, #0xff
  414f38:	54000100 	b.eq	414f58 <z_time_slice+0xd8>  // b.none
		if (!z_is_thread_prevented_from_running(curr)) {
  414f3c:	39406660 	ldrb	w0, [x19, #25]
  414f40:	f240101f 	tst	x0, #0x1f
  414f44:	54000061 	b.ne	414f50 <z_time_slice+0xd0>  // b.any
			move_thread_to_end_of_prio_q(curr);
  414f48:	aa1303e0 	mov	x0, x19
  414f4c:	97ffff84 	bl	414d5c <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
  414f50:	aa1303e0 	mov	x0, x19
  414f54:	97fffda1 	bl	4145d8 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  414f58:	f947ce94 	ldr	x20, [x20, #3992]
  414f5c:	aa1403e0 	mov	x0, x20
  414f60:	97fff56a 	bl	412508 <z_spin_unlock_valid>
  414f64:	72001c1f 	tst	w0, #0xff
  414f68:	54000261 	b.ne	414fb4 <z_time_slice+0x134>  // b.any
  414f6c:	b0000033 	adrp	x19, 419000 <__func__.2+0xa80>
  414f70:	912c1273 	add	x19, x19, #0xb04
  414f74:	aa1303e2 	mov	x2, x19
  414f78:	52801863 	mov	w3, #0xc3                  	// #195
  414f7c:	b0000021 	adrp	x1, 419000 <__func__.2+0xa80>
  414f80:	90000020 	adrp	x0, 418000 <table.0+0x1d8>
  414f84:	912d7821 	add	x1, x1, #0xb5e
  414f88:	91178000 	add	x0, x0, #0x5e0
  414f8c:	97ffc7a7 	bl	406e28 <assert_print>
  414f90:	aa1403e1 	mov	x1, x20
  414f94:	b0000020 	adrp	x0, 419000 <__func__.2+0xa80>
  414f98:	912dd400 	add	x0, x0, #0xb75
  414f9c:	97ffc7a3 	bl	406e28 <assert_print>
  414fa0:	aa1303e0 	mov	x0, x19
  414fa4:	52801861 	mov	w1, #0xc3                  	// #195
  414fa8:	97ffc7ca 	bl	406ed0 <assert_post_action>
  414fac:	52801862 	mov	w2, #0xc3                  	// #195
  414fb0:	17ffffd1 	b	414ef4 <z_time_slice+0x74>
	posix_irq_unlock(key);
  414fb4:	2a1603e0 	mov	w0, w22
}
  414fb8:	a94153f3 	ldp	x19, x20, [sp, #16]
  414fbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  414fc0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  414fc4:	17ffd0a1 	b	409248 <posix_irq_unlock>

0000000000414fc8 <ready_thread>:
{
  414fc8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  414fcc:	910003fd 	mov	x29, sp
  414fd0:	a90153f3 	stp	x19, x20, [sp, #16]
  414fd4:	aa0003f3 	mov	x19, x0
  414fd8:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
  414fdc:	39c06661 	ldrsb	w1, [x19, #25]
  414fe0:	39406400 	ldrb	w0, [x0, #25]
  414fe4:	37f807a1 	tbnz	w1, #31, 4150d8 <ready_thread+0x110>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  414fe8:	f240101f 	tst	x0, #0x1f
  414fec:	54000761 	b.ne	4150d8 <ready_thread+0x110>  // b.any
  414ff0:	f9401661 	ldr	x1, [x19, #40]
  414ff4:	b5000721 	cbnz	x1, 4150d8 <ready_thread+0x110>
	thread->base.thread_state |= _THREAD_QUEUED;
  414ff8:	32196000 	orr	w0, w0, #0xffffff80
  414ffc:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  415000:	900000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  415004:	f946e000 	ldr	x0, [x0, #3520]
  415008:	eb00027f 	cmp	x19, x0
  41500c:	54000241 	b.ne	415054 <ready_thread+0x8c>  // b.any
  415010:	b0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  415014:	91148273 	add	x19, x19, #0x520
  415018:	aa1303e2 	mov	x2, x19
  41501c:	52801783 	mov	w3, #0xbc                  	// #188
  415020:	b0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  415024:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415028:	911cdc21 	add	x1, x1, #0x737
  41502c:	91178000 	add	x0, x0, #0x5e0
  415030:	97ffc77e 	bl	406e28 <assert_print>
  415034:	aa1303e0 	mov	x0, x19
  415038:	52801781 	mov	w1, #0xbc                  	// #188
  41503c:	97ffc7a5 	bl	406ed0 <assert_post_action>
  415040:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415044:	aa1303e1 	mov	x1, x19
  415048:	91187800 	add	x0, x0, #0x61e
  41504c:	52801782 	mov	w2, #0xbc                  	// #188
  415050:	97ffd192 	bl	409698 <posix_print_error_and_exit>
	return list->head == list;
  415054:	900000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  415058:	aa0003f5 	mov	x21, x0
  41505c:	f9471016 	ldr	x22, [x0, #3616]
  415060:	aa1603e1 	mov	x1, x22
  415064:	f8430c34 	ldr	x20, [x1, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  415068:	eb01029f 	cmp	x20, x1
  41506c:	54000201 	b.ne	4150ac <ready_thread+0xe4>  // b.any
	sys_dnode_t *const tail = list->tail;
  415070:	f94712a0 	ldr	x0, [x21, #3616]
	node->next = list;
  415074:	9100c002 	add	x2, x0, #0x30
	sys_dnode_t *const tail = list->tail;
  415078:	f9401c01 	ldr	x1, [x0, #56]
	node->prev = tail;
  41507c:	a9000662 	stp	x2, x1, [x19]
	tail->next = node;
  415080:	f9000033 	str	x19, [x1]
	list->tail = node;
  415084:	f9001c13 	str	x19, [x0, #56]
}
  415088:	a94153f3 	ldp	x19, x20, [sp, #16]
		update_cache(0);
  41508c:	52800000 	mov	w0, #0x0                   	// #0
}
  415090:	a9425bf5 	ldp	x21, x22, [sp, #32]
  415094:	a8c37bfd 	ldp	x29, x30, [sp], #48
		update_cache(0);
  415098:	17fffefb 	b	414c84 <update_cache>
	return (node == list->tail) ? NULL : node->next;
  41509c:	f9401ec0 	ldr	x0, [x22, #56]
  4150a0:	eb14001f 	cmp	x0, x20
  4150a4:	54fffe60 	b.eq	415070 <ready_thread+0xa8>  // b.none
  4150a8:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  4150ac:	b4fffe34 	cbz	x20, 415070 <ready_thread+0xa8>
		if (z_sched_prio_cmp(thread, t) > 0) {
  4150b0:	aa1403e1 	mov	x1, x20
  4150b4:	aa1303e0 	mov	x0, x19
  4150b8:	97fffd42 	bl	4145c0 <z_sched_prio_cmp>
  4150bc:	7100001f 	cmp	w0, #0x0
  4150c0:	54fffeed 	b.le	41509c <ready_thread+0xd4>
	sys_dnode_t *const prev = successor->prev;
  4150c4:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  4150c8:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  4150cc:	f9000013 	str	x19, [x0]
	successor->prev = node;
  4150d0:	f9000693 	str	x19, [x20, #8]
}
  4150d4:	17ffffed 	b	415088 <ready_thread+0xc0>
}
  4150d8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4150dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4150e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4150e4:	d65f03c0 	ret

00000000004150e8 <z_ready_thread>:
{
  4150e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4150ec:	910003fd 	mov	x29, sp
  4150f0:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4150f4:	900000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  4150f8:	f90013f5 	str	x21, [sp, #32]
  4150fc:	aa0003f5 	mov	x21, x0
	return posix_irq_lock();
  415100:	97ffd050 	bl	409240 <posix_irq_lock>
  415104:	2a0003f4 	mov	w20, w0
  415108:	f947ce73 	ldr	x19, [x19, #3992]
  41510c:	aa1303e0 	mov	x0, x19
  415110:	97fff4f3 	bl	4124dc <z_spin_lock_valid>
  415114:	72001c1f 	tst	w0, #0xff
  415118:	540002c1 	b.ne	415170 <z_ready_thread+0x88>  // b.any
  41511c:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415120:	912c1294 	add	x20, x20, #0xb04
  415124:	aa1403e2 	mov	x2, x20
  415128:	52801283 	mov	w3, #0x94                  	// #148
  41512c:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415130:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415134:	912cc421 	add	x1, x1, #0xb31
  415138:	91178000 	add	x0, x0, #0x5e0
  41513c:	97ffc73b 	bl	406e28 <assert_print>
  415140:	aa1303e1 	mov	x1, x19
  415144:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415148:	912d1800 	add	x0, x0, #0xb46
  41514c:	97ffc737 	bl	406e28 <assert_print>
  415150:	aa1403e0 	mov	x0, x20
  415154:	52801281 	mov	w1, #0x94                  	// #148
  415158:	97ffc75e 	bl	406ed0 <assert_post_action>
  41515c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415160:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415164:	aa1403e1 	mov	x1, x20
  415168:	91187800 	add	x0, x0, #0x61e
  41516c:	97ffd14b 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  415170:	aa1303e0 	mov	x0, x19
  415174:	97fff4f2 	bl	41253c <z_spin_lock_set_owner>
			ready_thread(thread);
  415178:	aa1503e0 	mov	x0, x21
  41517c:	97ffff93 	bl	414fc8 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415180:	aa1303e0 	mov	x0, x19
  415184:	97fff4e1 	bl	412508 <z_spin_unlock_valid>
  415188:	72001c1f 	tst	w0, #0xff
  41518c:	54000261 	b.ne	4151d8 <z_ready_thread+0xf0>  // b.any
  415190:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415194:	912c1294 	add	x20, x20, #0xb04
  415198:	aa1403e2 	mov	x2, x20
  41519c:	52801863 	mov	w3, #0xc3                  	// #195
  4151a0:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4151a4:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4151a8:	912d7821 	add	x1, x1, #0xb5e
  4151ac:	91178000 	add	x0, x0, #0x5e0
  4151b0:	97ffc71e 	bl	406e28 <assert_print>
  4151b4:	aa1303e1 	mov	x1, x19
  4151b8:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4151bc:	912dd400 	add	x0, x0, #0xb75
  4151c0:	97ffc71a 	bl	406e28 <assert_print>
  4151c4:	aa1403e0 	mov	x0, x20
  4151c8:	52801861 	mov	w1, #0xc3                  	// #195
  4151cc:	97ffc741 	bl	406ed0 <assert_post_action>
  4151d0:	52801862 	mov	w2, #0xc3                  	// #195
  4151d4:	17ffffe3 	b	415160 <z_ready_thread+0x78>
	posix_irq_unlock(key);
  4151d8:	2a1403e0 	mov	w0, w20
}
  4151dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4151e0:	f94013f5 	ldr	x21, [sp, #32]
  4151e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4151e8:	17ffd018 	b	409248 <posix_irq_unlock>

00000000004151ec <z_sched_start>:
{
  4151ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4151f0:	910003fd 	mov	x29, sp
  4151f4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4151f8:	900000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  4151fc:	aa0003f4 	mov	x20, x0
  415200:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  415204:	97ffd00f 	bl	409240 <posix_irq_lock>
  415208:	f947ce73 	ldr	x19, [x19, #3992]
  41520c:	2a0003f5 	mov	w21, w0
  415210:	aa1303e0 	mov	x0, x19
  415214:	97fff4b2 	bl	4124dc <z_spin_lock_valid>
  415218:	72001c1f 	tst	w0, #0xff
  41521c:	540002c1 	b.ne	415274 <z_sched_start+0x88>  // b.any
  415220:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415224:	912c1294 	add	x20, x20, #0xb04
  415228:	aa1403e2 	mov	x2, x20
  41522c:	52801283 	mov	w3, #0x94                  	// #148
  415230:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415234:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415238:	912cc421 	add	x1, x1, #0xb31
  41523c:	91178000 	add	x0, x0, #0x5e0
  415240:	97ffc6fa 	bl	406e28 <assert_print>
  415244:	aa1303e1 	mov	x1, x19
  415248:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  41524c:	912d1800 	add	x0, x0, #0xb46
  415250:	97ffc6f6 	bl	406e28 <assert_print>
  415254:	aa1403e0 	mov	x0, x20
  415258:	52801281 	mov	w1, #0x94                  	// #148
  41525c:	97ffc71d 	bl	406ed0 <assert_post_action>
  415260:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415264:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415268:	aa1403e1 	mov	x1, x20
  41526c:	91187800 	add	x0, x0, #0x61e
  415270:	97ffd10a 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  415274:	aa1303e0 	mov	x0, x19
  415278:	97fff4b1 	bl	41253c <z_spin_lock_set_owner>
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
  41527c:	39406680 	ldrb	w0, [x20, #25]
	if (z_has_thread_started(thread)) {
  415280:	37100380 	tbnz	w0, #2, 4152f0 <z_sched_start+0x104>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415284:	aa1303e0 	mov	x0, x19
  415288:	97fff4a0 	bl	412508 <z_spin_unlock_valid>
  41528c:	72001c1f 	tst	w0, #0xff
  415290:	54000261 	b.ne	4152dc <z_sched_start+0xf0>  // b.any
  415294:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415298:	912c1294 	add	x20, x20, #0xb04
  41529c:	aa1403e2 	mov	x2, x20
  4152a0:	52801863 	mov	w3, #0xc3                  	// #195
  4152a4:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4152a8:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4152ac:	912d7821 	add	x1, x1, #0xb5e
  4152b0:	91178000 	add	x0, x0, #0x5e0
  4152b4:	97ffc6dd 	bl	406e28 <assert_print>
  4152b8:	aa1303e1 	mov	x1, x19
  4152bc:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4152c0:	912dd400 	add	x0, x0, #0xb75
  4152c4:	97ffc6d9 	bl	406e28 <assert_print>
  4152c8:	aa1403e0 	mov	x0, x20
  4152cc:	52801861 	mov	w1, #0xc3                  	// #195
  4152d0:	97ffc700 	bl	406ed0 <assert_post_action>
  4152d4:	52801862 	mov	w2, #0xc3                  	// #195
  4152d8:	17ffffe3 	b	415264 <z_sched_start+0x78>
	posix_irq_unlock(key);
  4152dc:	2a1503e0 	mov	w0, w21
}
  4152e0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4152e4:	f94013f5 	ldr	x21, [sp, #32]
  4152e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4152ec:	17ffcfd7 	b	409248 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
  4152f0:	121d7800 	and	w0, w0, #0xfffffffb
  4152f4:	39006680 	strb	w0, [x20, #25]
	ready_thread(thread);
  4152f8:	aa1403e0 	mov	x0, x20
  4152fc:	97ffff33 	bl	414fc8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
  415300:	2a1503e1 	mov	w1, w21
  415304:	aa1303e0 	mov	x0, x19
}
  415308:	a94153f3 	ldp	x19, x20, [sp, #16]
  41530c:	f94013f5 	ldr	x21, [sp, #32]
  415310:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_reschedule(&sched_spinlock, key);
  415314:	17fffd1a 	b	41477c <z_reschedule>

0000000000415318 <z_sched_wake_thread>:
{
  415318:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  41531c:	910003fd 	mov	x29, sp
  415320:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  415324:	900000f4 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  415328:	aa0003f3 	mov	x19, x0
  41532c:	a9025bf5 	stp	x21, x22, [sp, #32]
  415330:	f9001bf7 	str	x23, [sp, #48]
  415334:	12001c37 	and	w23, w1, #0xff
	return posix_irq_lock();
  415338:	97ffcfc2 	bl	409240 <posix_irq_lock>
  41533c:	2a0003f6 	mov	w22, w0
  415340:	f947ce95 	ldr	x21, [x20, #3992]
  415344:	aa1503e0 	mov	x0, x21
  415348:	97fff465 	bl	4124dc <z_spin_lock_valid>
  41534c:	72001c1f 	tst	w0, #0xff
  415350:	540002c1 	b.ne	4153a8 <z_sched_wake_thread+0x90>  // b.any
  415354:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  415358:	912c1273 	add	x19, x19, #0xb04
  41535c:	aa1303e2 	mov	x2, x19
  415360:	52801283 	mov	w3, #0x94                  	// #148
  415364:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415368:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  41536c:	912cc421 	add	x1, x1, #0xb31
  415370:	91178000 	add	x0, x0, #0x5e0
  415374:	97ffc6ad 	bl	406e28 <assert_print>
  415378:	aa1503e1 	mov	x1, x21
  41537c:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415380:	912d1800 	add	x0, x0, #0xb46
  415384:	97ffc6a9 	bl	406e28 <assert_print>
  415388:	aa1303e0 	mov	x0, x19
  41538c:	52801281 	mov	w1, #0x94                  	// #148
  415390:	97ffc6d0 	bl	406ed0 <assert_post_action>
  415394:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415398:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  41539c:	aa1303e1 	mov	x1, x19
  4153a0:	91187800 	add	x0, x0, #0x61e
  4153a4:	97ffd0bd 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4153a8:	aa1503e0 	mov	x0, x21
  4153ac:	97fff464 	bl	41253c <z_spin_lock_set_owner>
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  4153b0:	39422260 	ldrb	w0, [x19, #136]
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
  4153b4:	39406661 	ldrb	w1, [x19, #25]
		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
  4153b8:	34000060 	cbz	w0, 4153c4 <z_sched_wake_thread+0xac>
		thread->no_wake_on_timeout = false;
  4153bc:	3902227f 	strb	wzr, [x19, #136]
		if (do_nothing) {
  4153c0:	35000237 	cbnz	w23, 415404 <z_sched_wake_thread+0xec>
		if (!killed) {
  4153c4:	52800500 	mov	w0, #0x28                  	// #40
  4153c8:	6a00003f 	tst	w1, w0
  4153cc:	540001c1 	b.ne	415404 <z_sched_wake_thread+0xec>  // b.any
			if (thread->base.pended_on != NULL) {
  4153d0:	f9400a60 	ldr	x0, [x19, #16]
  4153d4:	b4000060 	cbz	x0, 4153e0 <z_sched_wake_thread+0xc8>
				unpend_thread_no_timeout(thread);
  4153d8:	aa1303e0 	mov	x0, x19
  4153dc:	97fffdbf 	bl	414ad8 <unpend_thread_no_timeout>
  4153e0:	39406662 	ldrb	w2, [x19, #25]
  4153e4:	710002ff 	cmp	w23, #0x0
  4153e8:	12800281 	mov	w1, #0xffffffeb            	// #-21
			ready_thread(thread);
  4153ec:	aa1303e0 	mov	x0, x19
  4153f0:	0a010041 	and	w1, w2, w1
  4153f4:	121d7842 	and	w2, w2, #0xfffffffb
  4153f8:	1a810042 	csel	w2, w2, w1, eq  // eq = none
  4153fc:	39006662 	strb	w2, [x19, #25]
  415400:	97fffef2 	bl	414fc8 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415404:	f947ce94 	ldr	x20, [x20, #3992]
  415408:	aa1403e0 	mov	x0, x20
  41540c:	97fff43f 	bl	412508 <z_spin_unlock_valid>
  415410:	72001c1f 	tst	w0, #0xff
  415414:	54000261 	b.ne	415460 <z_sched_wake_thread+0x148>  // b.any
  415418:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  41541c:	912c1273 	add	x19, x19, #0xb04
  415420:	aa1303e2 	mov	x2, x19
  415424:	52801863 	mov	w3, #0xc3                  	// #195
  415428:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  41542c:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415430:	912d7821 	add	x1, x1, #0xb5e
  415434:	91178000 	add	x0, x0, #0x5e0
  415438:	97ffc67c 	bl	406e28 <assert_print>
  41543c:	aa1403e1 	mov	x1, x20
  415440:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415444:	912dd400 	add	x0, x0, #0xb75
  415448:	97ffc678 	bl	406e28 <assert_print>
  41544c:	aa1303e0 	mov	x0, x19
  415450:	52801861 	mov	w1, #0xc3                  	// #195
  415454:	97ffc69f 	bl	406ed0 <assert_post_action>
  415458:	52801862 	mov	w2, #0xc3                  	// #195
  41545c:	17ffffcf 	b	415398 <z_sched_wake_thread+0x80>
	posix_irq_unlock(key);
  415460:	2a1603e0 	mov	w0, w22
}
  415464:	a94153f3 	ldp	x19, x20, [sp, #16]
  415468:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41546c:	f9401bf7 	ldr	x23, [sp, #48]
  415470:	a8c47bfd 	ldp	x29, x30, [sp], #64
  415474:	17ffcf75 	b	409248 <posix_irq_unlock>

0000000000415478 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
  415478:	d100a000 	sub	x0, x0, #0x28
  41547c:	52800021 	mov	w1, #0x1                   	// #1
  415480:	17ffffa6 	b	415318 <z_sched_wake_thread>

0000000000415484 <unready_thread>:
{
  415484:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  415488:	910003fd 	mov	x29, sp
  41548c:	a90153f3 	stp	x19, x20, [sp, #16]
  415490:	aa0003f3 	mov	x19, x0
	return (thread->base.thread_state & state) != 0U;
  415494:	900000f4 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  415498:	39406400 	ldrb	w0, [x0, #25]
	if (z_is_thread_queued(thread)) {
  41549c:	39c06661 	ldrsb	w1, [x19, #25]
  4154a0:	36f800e1 	tbz	w1, #31, 4154bc <unready_thread+0x38>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4154a4:	12001800 	and	w0, w0, #0x7f
  4154a8:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4154ac:	f9471280 	ldr	x0, [x20, #3616]
  4154b0:	aa1303e1 	mov	x1, x19
  4154b4:	9100c000 	add	x0, x0, #0x30
  4154b8:	97fffd6b 	bl	414a64 <z_priq_dumb_remove>
	update_cache(thread == _current);
  4154bc:	f9471294 	ldr	x20, [x20, #3616]
  4154c0:	f9400a80 	ldr	x0, [x20, #16]
  4154c4:	eb13001f 	cmp	x0, x19
}
  4154c8:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_cache(thread == _current);
  4154cc:	1a9f17e0 	cset	w0, eq  // eq = none
}
  4154d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	update_cache(thread == _current);
  4154d4:	17fffdec 	b	414c84 <update_cache>

00000000004154d8 <add_to_waitq_locked>:
{
  4154d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4154dc:	910003fd 	mov	x29, sp
  4154e0:	a90153f3 	stp	x19, x20, [sp, #16]
  4154e4:	aa0003f3 	mov	x19, x0
  4154e8:	aa0103f4 	mov	x20, x1
  4154ec:	f90013f5 	str	x21, [sp, #32]
	unready_thread(thread);
  4154f0:	97ffffe5 	bl	415484 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
  4154f4:	39406660 	ldrb	w0, [x19, #25]
  4154f8:	321f0000 	orr	w0, w0, #0x2
  4154fc:	39006660 	strb	w0, [x19, #25]
	if (wait_q != NULL) {
  415500:	b40003d4 	cbz	x20, 415578 <add_to_waitq_locked+0xa0>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  415504:	900000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
		thread->base.pended_on = wait_q;
  415508:	f9000a74 	str	x20, [x19, #16]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  41550c:	f946e000 	ldr	x0, [x0, #3520]
  415510:	eb00027f 	cmp	x19, x0
  415514:	54000241 	b.ne	41555c <add_to_waitq_locked+0x84>  // b.any
  415518:	b0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  41551c:	91148273 	add	x19, x19, #0x520
  415520:	aa1303e2 	mov	x2, x19
  415524:	52801783 	mov	w3, #0xbc                  	// #188
  415528:	b0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  41552c:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415530:	911cdc21 	add	x1, x1, #0x737
  415534:	91178000 	add	x0, x0, #0x5e0
  415538:	97ffc63c 	bl	406e28 <assert_print>
  41553c:	aa1303e0 	mov	x0, x19
  415540:	52801781 	mov	w1, #0xbc                  	// #188
  415544:	97ffc663 	bl	406ed0 <assert_post_action>
  415548:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  41554c:	aa1303e1 	mov	x1, x19
  415550:	91187800 	add	x0, x0, #0x61e
  415554:	52801782 	mov	w2, #0xbc                  	// #188
  415558:	97ffd050 	bl	409698 <posix_print_error_and_exit>
	return list->head == list;
  41555c:	f9400295 	ldr	x21, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  415560:	eb15029f 	cmp	x20, x21
  415564:	540001a1 	b.ne	415598 <add_to_waitq_locked+0xc0>  // b.any
	sys_dnode_t *const tail = list->tail;
  415568:	f9400680 	ldr	x0, [x20, #8]
	node->prev = tail;
  41556c:	a9000274 	stp	x20, x0, [x19]
	tail->next = node;
  415570:	f9000013 	str	x19, [x0]
	list->tail = node;
  415574:	f9000693 	str	x19, [x20, #8]
}
  415578:	a94153f3 	ldp	x19, x20, [sp, #16]
  41557c:	f94013f5 	ldr	x21, [sp, #32]
  415580:	a8c37bfd 	ldp	x29, x30, [sp], #48
  415584:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
  415588:	f9400680 	ldr	x0, [x20, #8]
  41558c:	eb15001f 	cmp	x0, x21
  415590:	54fffec0 	b.eq	415568 <add_to_waitq_locked+0x90>  // b.none
  415594:	f94002b5 	ldr	x21, [x21]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  415598:	b4fffe95 	cbz	x21, 415568 <add_to_waitq_locked+0x90>
		if (z_sched_prio_cmp(thread, t) > 0) {
  41559c:	aa1503e1 	mov	x1, x21
  4155a0:	aa1303e0 	mov	x0, x19
  4155a4:	97fffc07 	bl	4145c0 <z_sched_prio_cmp>
  4155a8:	7100001f 	cmp	w0, #0x0
  4155ac:	54fffeed 	b.le	415588 <add_to_waitq_locked+0xb0>
	sys_dnode_t *const prev = successor->prev;
  4155b0:	f94006a0 	ldr	x0, [x21, #8]
	node->prev = prev;
  4155b4:	a9000275 	stp	x21, x0, [x19]
	prev->next = node;
  4155b8:	f9000013 	str	x19, [x0]
	successor->prev = node;
  4155bc:	f90006b3 	str	x19, [x21, #8]
}
  4155c0:	17ffffee 	b	415578 <add_to_waitq_locked+0xa0>

00000000004155c4 <pend_locked>:
{
  4155c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4155c8:	910003fd 	mov	x29, sp
  4155cc:	a90153f3 	stp	x19, x20, [sp, #16]
  4155d0:	aa0203f3 	mov	x19, x2
  4155d4:	aa0003f4 	mov	x20, x0
	add_to_waitq_locked(thread, wait_q);
  4155d8:	97ffffc0 	bl	4154d8 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4155dc:	b100067f 	cmn	x19, #0x1
  4155e0:	54000100 	b.eq	415600 <pend_locked+0x3c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  4155e4:	aa1303e2 	mov	x2, x19
  4155e8:	9100a280 	add	x0, x20, #0x28
  4155ec:	900000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
}
  4155f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4155f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4155f8:	f9470421 	ldr	x1, [x1, #3592]
  4155fc:	140005e1 	b	416d80 <z_add_timeout>
  415600:	a94153f3 	ldp	x19, x20, [sp, #16]
  415604:	a8c27bfd 	ldp	x29, x30, [sp], #32
  415608:	d65f03c0 	ret

000000000041560c <z_pend_curr>:
{
  41560c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  415610:	910003fd 	mov	x29, sp
  415614:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  415618:	900000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  41561c:	f947ce73 	ldr	x19, [x19, #3992]
{
  415620:	a9025bf5 	stp	x21, x22, [sp, #32]
  415624:	f9001bf7 	str	x23, [sp, #48]
	__ASSERT_NO_MSG(sizeof(sched_spinlock) == 0 || lock != &sched_spinlock);
  415628:	eb13001f 	cmp	x0, x19
  41562c:	54000201 	b.ne	41566c <z_pend_curr+0x60>  // b.any
  415630:	b0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  415634:	91148273 	add	x19, x19, #0x520
  415638:	aa1303e2 	mov	x2, x19
  41563c:	52806a43 	mov	w3, #0x352                 	// #850
  415640:	b0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  415644:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415648:	911e5821 	add	x1, x1, #0x796
  41564c:	91178000 	add	x0, x0, #0x5e0
  415650:	97ffc5f6 	bl	406e28 <assert_print>
  415654:	aa1303e0 	mov	x0, x19
  415658:	52806a41 	mov	w1, #0x352                 	// #850
  41565c:	97ffc61d 	bl	406ed0 <assert_post_action>
  415660:	52806a42 	mov	w2, #0x352                 	// #850
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415664:	aa1303e1 	mov	x1, x19
  415668:	1400001c 	b	4156d8 <z_pend_curr+0xcc>
  41566c:	aa0003f4 	mov	x20, x0
  415670:	2a0103f5 	mov	w21, w1
  415674:	aa0203f6 	mov	x22, x2
  415678:	aa0303f7 	mov	x23, x3
	return posix_irq_lock();
  41567c:	97ffcef1 	bl	409240 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  415680:	aa1303e0 	mov	x0, x19
  415684:	97fff396 	bl	4124dc <z_spin_lock_valid>
  415688:	72001c1f 	tst	w0, #0xff
  41568c:	540002c1 	b.ne	4156e4 <z_pend_curr+0xd8>  // b.any
  415690:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415694:	912c1294 	add	x20, x20, #0xb04
  415698:	aa1403e2 	mov	x2, x20
  41569c:	52801283 	mov	w3, #0x94                  	// #148
  4156a0:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  4156a4:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4156a8:	912cc421 	add	x1, x1, #0xb31
  4156ac:	91178000 	add	x0, x0, #0x5e0
  4156b0:	97ffc5de 	bl	406e28 <assert_print>
  4156b4:	aa1303e1 	mov	x1, x19
  4156b8:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  4156bc:	912d1800 	add	x0, x0, #0xb46
  4156c0:	97ffc5da 	bl	406e28 <assert_print>
  4156c4:	aa1403e0 	mov	x0, x20
  4156c8:	52801281 	mov	w1, #0x94                  	// #148
  4156cc:	97ffc601 	bl	406ed0 <assert_post_action>
  4156d0:	52801282 	mov	w2, #0x94                  	// #148
  4156d4:	aa1403e1 	mov	x1, x20
  4156d8:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4156dc:	91187800 	add	x0, x0, #0x61e
  4156e0:	97ffcfee 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4156e4:	aa1303e0 	mov	x0, x19
  4156e8:	97fff395 	bl	41253c <z_spin_lock_set_owner>
	pend_locked(_current, wait_q, timeout);
  4156ec:	900000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4156f0:	aa1703e2 	mov	x2, x23
  4156f4:	aa1603e1 	mov	x1, x22
  4156f8:	f9471000 	ldr	x0, [x0, #3616]
  4156fc:	f9400800 	ldr	x0, [x0, #16]
  415700:	97ffffb1 	bl	4155c4 <pend_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415704:	aa1403e0 	mov	x0, x20
  415708:	97fff380 	bl	412508 <z_spin_unlock_valid>
  41570c:	72001c1f 	tst	w0, #0xff
  415710:	54000261 	b.ne	41575c <z_pend_curr+0x150>  // b.any
  415714:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  415718:	912c1273 	add	x19, x19, #0xb04
  41571c:	aa1303e2 	mov	x2, x19
  415720:	52801c43 	mov	w3, #0xe2                  	// #226
  415724:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415728:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  41572c:	912d7821 	add	x1, x1, #0xb5e
  415730:	91178000 	add	x0, x0, #0x5e0
  415734:	97ffc5bd 	bl	406e28 <assert_print>
  415738:	aa1403e1 	mov	x1, x20
  41573c:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415740:	912dd400 	add	x0, x0, #0xb75
  415744:	97ffc5b9 	bl	406e28 <assert_print>
  415748:	aa1303e0 	mov	x0, x19
  41574c:	52801c41 	mov	w1, #0xe2                  	// #226
  415750:	97ffc5e0 	bl	406ed0 <assert_post_action>
  415754:	52801c42 	mov	w2, #0xe2                  	// #226
  415758:	17ffffc3 	b	415664 <z_pend_curr+0x58>
  41575c:	aa1303e0 	mov	x0, x19
  415760:	97fff36a 	bl	412508 <z_spin_unlock_valid>
  415764:	72001c1f 	tst	w0, #0xff
  415768:	54000261 	b.ne	4157b4 <z_pend_curr+0x1a8>  // b.any
  41576c:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415770:	912c1294 	add	x20, x20, #0xb04
  415774:	aa1403e2 	mov	x2, x20
  415778:	52801c43 	mov	w3, #0xe2                  	// #226
  41577c:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415780:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415784:	912d7821 	add	x1, x1, #0xb5e
  415788:	91178000 	add	x0, x0, #0x5e0
  41578c:	97ffc5a7 	bl	406e28 <assert_print>
  415790:	aa1303e1 	mov	x1, x19
  415794:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415798:	912dd400 	add	x0, x0, #0xb75
  41579c:	97ffc5a3 	bl	406e28 <assert_print>
  4157a0:	aa1403e0 	mov	x0, x20
  4157a4:	52801c41 	mov	w1, #0xe2                  	// #226
  4157a8:	97ffc5ca 	bl	406ed0 <assert_post_action>
  4157ac:	52801c42 	mov	w2, #0xe2                  	// #226
  4157b0:	17ffffc9 	b	4156d4 <z_pend_curr+0xc8>
  4157b4:	2a1503e0 	mov	w0, w21
}
  4157b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4157bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4157c0:	f9401bf7 	ldr	x23, [sp, #48]
  4157c4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4157c8:	17ffcb74 	b	408598 <arch_swap>

00000000004157cc <z_set_prio>:
{
  4157cc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4157d0:	910003fd 	mov	x29, sp
  4157d4:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4157d8:	900000f8 	adrp	x24, 431000 <__FRAME_END__+0x10804>
  4157dc:	a90153f3 	stp	x19, x20, [sp, #16]
  4157e0:	aa0003f3 	mov	x19, x0
  4157e4:	a9025bf5 	stp	x21, x22, [sp, #32]
  4157e8:	2a0103f5 	mov	w21, w1
  4157ec:	f90023f9 	str	x25, [sp, #64]
  4157f0:	97ffce94 	bl	409240 <posix_irq_lock>
  4157f4:	f947cf19 	ldr	x25, [x24, #3992]
  4157f8:	2a0003f7 	mov	w23, w0
  4157fc:	aa1903e0 	mov	x0, x25
  415800:	97fff337 	bl	4124dc <z_spin_lock_valid>
  415804:	72001c16 	ands	w22, w0, #0xff
  415808:	540002c1 	b.ne	415860 <z_set_prio+0x94>  // b.any
  41580c:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  415810:	912c1273 	add	x19, x19, #0xb04
  415814:	aa1303e2 	mov	x2, x19
  415818:	52801283 	mov	w3, #0x94                  	// #148
  41581c:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415820:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415824:	912cc421 	add	x1, x1, #0xb31
  415828:	91178000 	add	x0, x0, #0x5e0
  41582c:	97ffc57f 	bl	406e28 <assert_print>
  415830:	aa1903e1 	mov	x1, x25
  415834:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415838:	912d1800 	add	x0, x0, #0xb46
  41583c:	97ffc57b 	bl	406e28 <assert_print>
  415840:	aa1303e0 	mov	x0, x19
  415844:	52801281 	mov	w1, #0x94                  	// #148
  415848:	97ffc5a2 	bl	406ed0 <assert_post_action>
  41584c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  415850:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415854:	aa1303e1 	mov	x1, x19
  415858:	91187800 	add	x0, x0, #0x61e
  41585c:	97ffcf8f 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  415860:	aa1903e0 	mov	x0, x25
  415864:	97fff336 	bl	41253c <z_spin_lock_set_owner>
	uint8_t state = thread->base.thread_state;
  415868:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  41586c:	13001eb5 	sxtb	w21, w21
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  415870:	f240101f 	tst	x0, #0x1f
  415874:	54000a61 	b.ne	4159c0 <z_set_prio+0x1f4>  // b.any
		if (need_sched) {
  415878:	f9401661 	ldr	x1, [x19, #40]
  41587c:	b5000a21 	cbnz	x1, 4159c0 <z_set_prio+0x1f4>
	_priq_run_remove(thread_runq(thread), thread);
  415880:	900000f4 	adrp	x20, 431000 <__FRAME_END__+0x10804>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  415884:	12001800 	and	w0, w0, #0x7f
  415888:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  41588c:	aa1303e1 	mov	x1, x19
  415890:	f9471299 	ldr	x25, [x20, #3616]
  415894:	9100c320 	add	x0, x25, #0x30
  415898:	97fffc73 	bl	414a64 <z_priq_dumb_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
  41589c:	39406660 	ldrb	w0, [x19, #25]
				thread->base.prio = prio;
  4158a0:	39006a75 	strb	w21, [x19, #26]
	thread->base.thread_state |= _THREAD_QUEUED;
  4158a4:	aa1403f5 	mov	x21, x20
  4158a8:	32196000 	orr	w0, w0, #0xffffff80
  4158ac:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4158b0:	900000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4158b4:	f946e000 	ldr	x0, [x0, #3520]
  4158b8:	eb00027f 	cmp	x19, x0
  4158bc:	540001e1 	b.ne	4158f8 <z_set_prio+0x12c>  // b.any
  4158c0:	b0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4158c4:	91148273 	add	x19, x19, #0x520
  4158c8:	aa1303e2 	mov	x2, x19
  4158cc:	52801783 	mov	w3, #0xbc                  	// #188
  4158d0:	b0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4158d4:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4158d8:	911cdc21 	add	x1, x1, #0x737
  4158dc:	91178000 	add	x0, x0, #0x5e0
  4158e0:	97ffc552 	bl	406e28 <assert_print>
  4158e4:	aa1303e0 	mov	x0, x19
  4158e8:	52801781 	mov	w1, #0xbc                  	// #188
  4158ec:	97ffc579 	bl	406ed0 <assert_post_action>
  4158f0:	52801782 	mov	w2, #0xbc                  	// #188
  4158f4:	17ffffd7 	b	415850 <z_set_prio+0x84>
	return list->head == list;
  4158f8:	aa1903e0 	mov	x0, x25
  4158fc:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  415900:	eb00029f 	cmp	x20, x0
  415904:	54000481 	b.ne	415994 <z_set_prio+0x1c8>  // b.any
	sys_dnode_t *const tail = list->tail;
  415908:	f94712a2 	ldr	x2, [x21, #3616]
	node->next = list;
  41590c:	9100c041 	add	x1, x2, #0x30
	sys_dnode_t *const tail = list->tail;
  415910:	f9401c40 	ldr	x0, [x2, #56]
	node->prev = tail;
  415914:	a9000261 	stp	x1, x0, [x19]
	tail->next = node;
  415918:	f9000013 	str	x19, [x0]
	list->tail = node;
  41591c:	f9001c53 	str	x19, [x2, #56]
			update_cache(1);
  415920:	52800020 	mov	w0, #0x1                   	// #1
  415924:	97fffcd8 	bl	414c84 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415928:	f947cf18 	ldr	x24, [x24, #3992]
  41592c:	aa1803e0 	mov	x0, x24
  415930:	97fff2f6 	bl	412508 <z_spin_unlock_valid>
  415934:	72001c1f 	tst	w0, #0xff
  415938:	540004a1 	b.ne	4159cc <z_set_prio+0x200>  // b.any
  41593c:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  415940:	912c1273 	add	x19, x19, #0xb04
  415944:	aa1303e2 	mov	x2, x19
  415948:	52801863 	mov	w3, #0xc3                  	// #195
  41594c:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415950:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415954:	912d7821 	add	x1, x1, #0xb5e
  415958:	91178000 	add	x0, x0, #0x5e0
  41595c:	97ffc533 	bl	406e28 <assert_print>
  415960:	aa1803e1 	mov	x1, x24
  415964:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415968:	912dd400 	add	x0, x0, #0xb75
  41596c:	97ffc52f 	bl	406e28 <assert_print>
  415970:	aa1303e0 	mov	x0, x19
  415974:	52801861 	mov	w1, #0xc3                  	// #195
  415978:	97ffc556 	bl	406ed0 <assert_post_action>
  41597c:	52801862 	mov	w2, #0xc3                  	// #195
  415980:	17ffffb4 	b	415850 <z_set_prio+0x84>
	return (node == list->tail) ? NULL : node->next;
  415984:	f9401f20 	ldr	x0, [x25, #56]
  415988:	eb00029f 	cmp	x20, x0
  41598c:	54fffbe0 	b.eq	415908 <z_set_prio+0x13c>  // b.none
  415990:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  415994:	b4fffbb4 	cbz	x20, 415908 <z_set_prio+0x13c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  415998:	aa1403e1 	mov	x1, x20
  41599c:	aa1303e0 	mov	x0, x19
  4159a0:	97fffb08 	bl	4145c0 <z_sched_prio_cmp>
  4159a4:	7100001f 	cmp	w0, #0x0
  4159a8:	54fffeed 	b.le	415984 <z_set_prio+0x1b8>
	sys_dnode_t *const prev = successor->prev;
  4159ac:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  4159b0:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  4159b4:	f9000013 	str	x19, [x0]
	successor->prev = node;
  4159b8:	f9000693 	str	x19, [x20, #8]
}
  4159bc:	17ffffd9 	b	415920 <z_set_prio+0x154>
			thread->base.prio = prio;
  4159c0:	52800016 	mov	w22, #0x0                   	// #0
  4159c4:	39006a75 	strb	w21, [x19, #26]
  4159c8:	17ffffd8 	b	415928 <z_set_prio+0x15c>
	posix_irq_unlock(key);
  4159cc:	2a1703e0 	mov	w0, w23
  4159d0:	97ffce1e 	bl	409248 <posix_irq_unlock>
}
  4159d4:	2a1603e0 	mov	w0, w22
  4159d8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4159dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4159e0:	a94363f7 	ldp	x23, x24, [sp, #48]
  4159e4:	f94023f9 	ldr	x25, [sp, #64]
  4159e8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4159ec:	d65f03c0 	ret

00000000004159f0 <z_impl_k_thread_suspend>:
{
  4159f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4159f4:	910003fd 	mov	x29, sp
  4159f8:	a9025bf5 	stp	x21, x22, [sp, #32]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4159fc:	900000f5 	adrp	x21, 431000 <__FRAME_END__+0x10804>
  415a00:	a90153f3 	stp	x19, x20, [sp, #16]
  415a04:	aa0003f3 	mov	x19, x0
	return z_abort_timeout(&thread->base.timeout);
  415a08:	9100a000 	add	x0, x0, #0x28
  415a0c:	9400056f 	bl	416fc8 <z_abort_timeout>
	return posix_irq_lock();
  415a10:	97ffce0c 	bl	409240 <posix_irq_lock>
  415a14:	2a0003f6 	mov	w22, w0
  415a18:	f947ceb4 	ldr	x20, [x21, #3992]
  415a1c:	aa1403e0 	mov	x0, x20
  415a20:	97fff2af 	bl	4124dc <z_spin_lock_valid>
  415a24:	72001c1f 	tst	w0, #0xff
  415a28:	540002c1 	b.ne	415a80 <z_impl_k_thread_suspend+0x90>  // b.any
  415a2c:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  415a30:	912c1273 	add	x19, x19, #0xb04
  415a34:	aa1303e2 	mov	x2, x19
  415a38:	52801283 	mov	w3, #0x94                  	// #148
  415a3c:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415a40:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415a44:	912cc421 	add	x1, x1, #0xb31
  415a48:	91178000 	add	x0, x0, #0x5e0
  415a4c:	97ffc4f7 	bl	406e28 <assert_print>
  415a50:	aa1403e1 	mov	x1, x20
  415a54:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415a58:	912d1800 	add	x0, x0, #0xb46
  415a5c:	97ffc4f3 	bl	406e28 <assert_print>
  415a60:	aa1303e0 	mov	x0, x19
  415a64:	52801281 	mov	w1, #0x94                  	// #148
  415a68:	97ffc51a 	bl	406ed0 <assert_post_action>
  415a6c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415a70:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415a74:	aa1303e1 	mov	x1, x19
  415a78:	91187800 	add	x0, x0, #0x61e
  415a7c:	97ffcf07 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  415a80:	aa1403e0 	mov	x0, x20
  415a84:	97fff2ae 	bl	41253c <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
  415a88:	39c06661 	ldrsb	w1, [x19, #25]
  415a8c:	900000f4 	adrp	x20, 431000 <__FRAME_END__+0x10804>
	return (thread->base.thread_state & state) != 0U;
  415a90:	39406660 	ldrb	w0, [x19, #25]
  415a94:	36f800e1 	tbz	w1, #31, 415ab0 <z_impl_k_thread_suspend+0xc0>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  415a98:	12001800 	and	w0, w0, #0x7f
  415a9c:	39006660 	strb	w0, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  415aa0:	f9471280 	ldr	x0, [x20, #3616]
  415aa4:	aa1303e1 	mov	x1, x19
  415aa8:	9100c000 	add	x0, x0, #0x30
  415aac:	97fffbee 	bl	414a64 <z_priq_dumb_remove>
		update_cache(thread == _current);
  415ab0:	f9471294 	ldr	x20, [x20, #3616]
	thread->base.thread_state |= _THREAD_SUSPENDED;
  415ab4:	39406660 	ldrb	w0, [x19, #25]
  415ab8:	321c0000 	orr	w0, w0, #0x10
  415abc:	39006660 	strb	w0, [x19, #25]
  415ac0:	f9400a80 	ldr	x0, [x20, #16]
  415ac4:	eb13001f 	cmp	x0, x19
  415ac8:	1a9f17e0 	cset	w0, eq  // eq = none
  415acc:	97fffc6e 	bl	414c84 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415ad0:	f947ceb5 	ldr	x21, [x21, #3992]
  415ad4:	aa1503e0 	mov	x0, x21
  415ad8:	97fff28c 	bl	412508 <z_spin_unlock_valid>
  415adc:	72001c1f 	tst	w0, #0xff
  415ae0:	54000261 	b.ne	415b2c <z_impl_k_thread_suspend+0x13c>  // b.any
  415ae4:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  415ae8:	912c1273 	add	x19, x19, #0xb04
  415aec:	aa1303e2 	mov	x2, x19
  415af0:	52801863 	mov	w3, #0xc3                  	// #195
  415af4:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415af8:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415afc:	912d7821 	add	x1, x1, #0xb5e
  415b00:	91178000 	add	x0, x0, #0x5e0
  415b04:	97ffc4c9 	bl	406e28 <assert_print>
  415b08:	aa1503e1 	mov	x1, x21
  415b0c:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415b10:	912dd400 	add	x0, x0, #0xb75
  415b14:	97ffc4c5 	bl	406e28 <assert_print>
  415b18:	aa1303e0 	mov	x0, x19
  415b1c:	52801861 	mov	w1, #0xc3                  	// #195
  415b20:	97ffc4ec 	bl	406ed0 <assert_post_action>
  415b24:	52801862 	mov	w2, #0xc3                  	// #195
  415b28:	17ffffd2 	b	415a70 <z_impl_k_thread_suspend+0x80>
	posix_irq_unlock(key);
  415b2c:	2a1603e0 	mov	w0, w22
  415b30:	97ffcdc6 	bl	409248 <posix_irq_unlock>
	if (thread == _current) {
  415b34:	f9400a80 	ldr	x0, [x20, #16]
  415b38:	eb13001f 	cmp	x0, x19
  415b3c:	540000a1 	b.ne	415b50 <z_impl_k_thread_suspend+0x160>  // b.any
}
  415b40:	a94153f3 	ldp	x19, x20, [sp, #16]
  415b44:	a9425bf5 	ldp	x21, x22, [sp, #32]
  415b48:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule_unlocked();
  415b4c:	17fffb58 	b	4148ac <z_reschedule_unlocked>
}
  415b50:	a94153f3 	ldp	x19, x20, [sp, #16]
  415b54:	a9425bf5 	ldp	x21, x22, [sp, #32]
  415b58:	a8c37bfd 	ldp	x29, x30, [sp], #48
  415b5c:	d65f03c0 	ret

0000000000415b60 <k_sched_unlock>:
{
  415b60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  415b64:	910003fd 	mov	x29, sp
  415b68:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  415b6c:	900000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
	return posix_irq_lock();
  415b70:	97ffcdb4 	bl	409240 <posix_irq_lock>
  415b74:	f947ce73 	ldr	x19, [x19, #3992]
  415b78:	2a0003f4 	mov	w20, w0
  415b7c:	aa1303e0 	mov	x0, x19
  415b80:	97fff257 	bl	4124dc <z_spin_lock_valid>
  415b84:	72001c1f 	tst	w0, #0xff
  415b88:	54000281 	b.ne	415bd8 <k_sched_unlock+0x78>  // b.any
  415b8c:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415b90:	912c1294 	add	x20, x20, #0xb04
  415b94:	aa1403e2 	mov	x2, x20
  415b98:	52801283 	mov	w3, #0x94                  	// #148
  415b9c:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415ba0:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415ba4:	912cc421 	add	x1, x1, #0xb31
  415ba8:	91178000 	add	x0, x0, #0x5e0
  415bac:	97ffc49f 	bl	406e28 <assert_print>
  415bb0:	aa1303e1 	mov	x1, x19
  415bb4:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415bb8:	912d1800 	add	x0, x0, #0xb46
  415bbc:	97ffc49b 	bl	406e28 <assert_print>
  415bc0:	aa1403e0 	mov	x0, x20
  415bc4:	52801281 	mov	w1, #0x94                  	// #148
  415bc8:	97ffc4c2 	bl	406ed0 <assert_post_action>
  415bcc:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415bd0:	aa1403e1 	mov	x1, x20
  415bd4:	14000019 	b	415c38 <k_sched_unlock+0xd8>
	z_spin_lock_set_owner(l);
  415bd8:	aa1303e0 	mov	x0, x19
  415bdc:	97fff258 	bl	41253c <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0U, "");
  415be0:	900000e2 	adrp	x2, 431000 <__FRAME_END__+0x10804>
  415be4:	f9471042 	ldr	x2, [x2, #3616]
  415be8:	f9400840 	ldr	x0, [x2, #16]
  415bec:	39406c01 	ldrb	w1, [x0, #27]
  415bf0:	350002a1 	cbnz	w1, 415c44 <k_sched_unlock+0xe4>
  415bf4:	b0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  415bf8:	91148273 	add	x19, x19, #0x520
  415bfc:	aa1303e2 	mov	x2, x19
  415c00:	b0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  415c04:	911f3421 	add	x1, x1, #0x7cd
  415c08:	52807d63 	mov	w3, #0x3eb                 	// #1003
  415c0c:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415c10:	91178000 	add	x0, x0, #0x5e0
  415c14:	97ffc485 	bl	406e28 <assert_print>
  415c18:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415c1c:	912e6c00 	add	x0, x0, #0xb9b
  415c20:	97ffc482 	bl	406e28 <assert_print>
  415c24:	aa1303e0 	mov	x0, x19
  415c28:	52807d61 	mov	w1, #0x3eb                 	// #1003
  415c2c:	97ffc4a9 	bl	406ed0 <assert_post_action>
  415c30:	52807d62 	mov	w2, #0x3eb                 	// #1003
  415c34:	aa1303e1 	mov	x1, x19
  415c38:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415c3c:	91187800 	add	x0, x0, #0x61e
  415c40:	97ffce96 	bl	409698 <posix_print_error_and_exit>
		__ASSERT(!arch_is_in_isr(), "");
  415c44:	b9400042 	ldr	w2, [x2]
  415c48:	34000242 	cbz	w2, 415c90 <k_sched_unlock+0x130>
  415c4c:	b0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  415c50:	91148273 	add	x19, x19, #0x520
  415c54:	aa1303e2 	mov	x2, x19
  415c58:	b0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  415c5c:	910a4421 	add	x1, x1, #0x291
  415c60:	52807d83 	mov	w3, #0x3ec                 	// #1004
  415c64:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415c68:	91178000 	add	x0, x0, #0x5e0
  415c6c:	97ffc46f 	bl	406e28 <assert_print>
  415c70:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415c74:	912e6c00 	add	x0, x0, #0xb9b
  415c78:	97ffc46c 	bl	406e28 <assert_print>
  415c7c:	aa1303e0 	mov	x0, x19
  415c80:	52807d81 	mov	w1, #0x3ec                 	// #1004
  415c84:	97ffc493 	bl	406ed0 <assert_post_action>
  415c88:	52807d82 	mov	w2, #0x3ec                 	// #1004
  415c8c:	17ffffea 	b	415c34 <k_sched_unlock+0xd4>
		++_current->base.sched_locked;
  415c90:	11000421 	add	w1, w1, #0x1
  415c94:	39006c01 	strb	w1, [x0, #27]
		update_cache(0);
  415c98:	52800000 	mov	w0, #0x0                   	// #0
  415c9c:	97fffbfa 	bl	414c84 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415ca0:	aa1303e0 	mov	x0, x19
  415ca4:	97fff219 	bl	412508 <z_spin_unlock_valid>
  415ca8:	72001c1f 	tst	w0, #0xff
  415cac:	54000261 	b.ne	415cf8 <k_sched_unlock+0x198>  // b.any
  415cb0:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415cb4:	912c1294 	add	x20, x20, #0xb04
  415cb8:	aa1403e2 	mov	x2, x20
  415cbc:	52801863 	mov	w3, #0xc3                  	// #195
  415cc0:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415cc4:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415cc8:	912d7821 	add	x1, x1, #0xb5e
  415ccc:	91178000 	add	x0, x0, #0x5e0
  415cd0:	97ffc456 	bl	406e28 <assert_print>
  415cd4:	aa1303e1 	mov	x1, x19
  415cd8:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415cdc:	912dd400 	add	x0, x0, #0xb75
  415ce0:	97ffc452 	bl	406e28 <assert_print>
  415ce4:	aa1403e0 	mov	x0, x20
  415ce8:	52801861 	mov	w1, #0xc3                  	// #195
  415cec:	97ffc479 	bl	406ed0 <assert_post_action>
  415cf0:	52801862 	mov	w2, #0xc3                  	// #195
  415cf4:	17ffffb7 	b	415bd0 <k_sched_unlock+0x70>
	posix_irq_unlock(key);
  415cf8:	2a1403e0 	mov	w0, w20
  415cfc:	97ffcd53 	bl	409248 <posix_irq_unlock>
}
  415d00:	a94153f3 	ldp	x19, x20, [sp, #16]
  415d04:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
  415d08:	17fffae9 	b	4148ac <z_reschedule_unlocked>

0000000000415d0c <z_unpend1_no_timeout>:
{
  415d0c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  415d10:	910003fd 	mov	x29, sp
  415d14:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  415d18:	900000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  415d1c:	aa0003f4 	mov	x20, x0
  415d20:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  415d24:	97ffcd47 	bl	409240 <posix_irq_lock>
  415d28:	2a0003f5 	mov	w21, w0
  415d2c:	f947ce76 	ldr	x22, [x19, #3992]
  415d30:	aa1603e0 	mov	x0, x22
  415d34:	97fff1ea 	bl	4124dc <z_spin_lock_valid>
  415d38:	72001c1f 	tst	w0, #0xff
  415d3c:	540002c1 	b.ne	415d94 <z_unpend1_no_timeout+0x88>  // b.any
  415d40:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  415d44:	912c1273 	add	x19, x19, #0xb04
  415d48:	aa1303e2 	mov	x2, x19
  415d4c:	52801283 	mov	w3, #0x94                  	// #148
  415d50:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415d54:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415d58:	912cc421 	add	x1, x1, #0xb31
  415d5c:	91178000 	add	x0, x0, #0x5e0
  415d60:	97ffc432 	bl	406e28 <assert_print>
  415d64:	aa1603e1 	mov	x1, x22
  415d68:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415d6c:	912d1800 	add	x0, x0, #0xb46
  415d70:	97ffc42e 	bl	406e28 <assert_print>
  415d74:	52801281 	mov	w1, #0x94                  	// #148
  415d78:	aa1303e0 	mov	x0, x19
  415d7c:	97ffc455 	bl	406ed0 <assert_post_action>
  415d80:	aa1303e1 	mov	x1, x19
  415d84:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415d88:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415d8c:	91187800 	add	x0, x0, #0x61e
  415d90:	97ffce42 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  415d94:	aa1603e0 	mov	x0, x22
  415d98:	97fff1e9 	bl	41253c <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  415d9c:	aa1403e0 	mov	x0, x20
  415da0:	97fffbb5 	bl	414c74 <z_priq_dumb_best>
  415da4:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  415da8:	b4000040 	cbz	x0, 415db0 <z_unpend1_no_timeout+0xa4>
			unpend_thread_no_timeout(thread);
  415dac:	97fffb4b 	bl	414ad8 <unpend_thread_no_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415db0:	f947ce73 	ldr	x19, [x19, #3992]
  415db4:	aa1303e0 	mov	x0, x19
  415db8:	97fff1d4 	bl	412508 <z_spin_unlock_valid>
  415dbc:	72001c1f 	tst	w0, #0xff
  415dc0:	54000281 	b.ne	415e10 <z_unpend1_no_timeout+0x104>  // b.any
  415dc4:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415dc8:	912c1294 	add	x20, x20, #0xb04
  415dcc:	aa1403e2 	mov	x2, x20
  415dd0:	52801863 	mov	w3, #0xc3                  	// #195
  415dd4:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415dd8:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415ddc:	912d7821 	add	x1, x1, #0xb5e
  415de0:	91178000 	add	x0, x0, #0x5e0
  415de4:	97ffc411 	bl	406e28 <assert_print>
  415de8:	aa1303e1 	mov	x1, x19
  415dec:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415df0:	912dd400 	add	x0, x0, #0xb75
  415df4:	97ffc40d 	bl	406e28 <assert_print>
  415df8:	52801861 	mov	w1, #0xc3                  	// #195
  415dfc:	aa1403e0 	mov	x0, x20
  415e00:	97ffc434 	bl	406ed0 <assert_post_action>
  415e04:	aa1403e1 	mov	x1, x20
  415e08:	52801862 	mov	w2, #0xc3                  	// #195
  415e0c:	17ffffdf 	b	415d88 <z_unpend1_no_timeout+0x7c>
	posix_irq_unlock(key);
  415e10:	2a1503e0 	mov	w0, w21
  415e14:	97ffcd0d 	bl	409248 <posix_irq_unlock>
}
  415e18:	aa1403e0 	mov	x0, x20
  415e1c:	a94153f3 	ldp	x19, x20, [sp, #16]
  415e20:	a9425bf5 	ldp	x21, x22, [sp, #32]
  415e24:	a8c37bfd 	ldp	x29, x30, [sp], #48
  415e28:	d65f03c0 	ret

0000000000415e2c <z_unpend_first_thread>:
{
  415e2c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  415e30:	910003fd 	mov	x29, sp
  415e34:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  415e38:	900000f3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  415e3c:	aa0003f4 	mov	x20, x0
  415e40:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  415e44:	97ffccff 	bl	409240 <posix_irq_lock>
  415e48:	2a0003f5 	mov	w21, w0
  415e4c:	f947ce76 	ldr	x22, [x19, #3992]
  415e50:	aa1603e0 	mov	x0, x22
  415e54:	97fff1a2 	bl	4124dc <z_spin_lock_valid>
  415e58:	72001c1f 	tst	w0, #0xff
  415e5c:	540002c1 	b.ne	415eb4 <z_unpend_first_thread+0x88>  // b.any
  415e60:	90000033 	adrp	x19, 419000 <__func__.2+0xa80>
  415e64:	912c1273 	add	x19, x19, #0xb04
  415e68:	aa1303e2 	mov	x2, x19
  415e6c:	52801283 	mov	w3, #0x94                  	// #148
  415e70:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415e74:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415e78:	912cc421 	add	x1, x1, #0xb31
  415e7c:	91178000 	add	x0, x0, #0x5e0
  415e80:	97ffc3ea 	bl	406e28 <assert_print>
  415e84:	aa1603e1 	mov	x1, x22
  415e88:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415e8c:	912d1800 	add	x0, x0, #0xb46
  415e90:	97ffc3e6 	bl	406e28 <assert_print>
  415e94:	52801281 	mov	w1, #0x94                  	// #148
  415e98:	aa1303e0 	mov	x0, x19
  415e9c:	97ffc40d 	bl	406ed0 <assert_post_action>
  415ea0:	aa1303e1 	mov	x1, x19
  415ea4:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415ea8:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415eac:	91187800 	add	x0, x0, #0x61e
  415eb0:	97ffcdfa 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  415eb4:	aa1603e0 	mov	x0, x22
  415eb8:	97fff1a1 	bl	41253c <z_spin_lock_set_owner>
		thread = _priq_wait_best(&wait_q->waitq);
  415ebc:	aa1403e0 	mov	x0, x20
  415ec0:	97fffb6d 	bl	414c74 <z_priq_dumb_best>
  415ec4:	aa0003f4 	mov	x20, x0
		if (thread != NULL) {
  415ec8:	b4000080 	cbz	x0, 415ed8 <z_unpend_first_thread+0xac>
			unpend_thread_no_timeout(thread);
  415ecc:	97fffb03 	bl	414ad8 <unpend_thread_no_timeout>
  415ed0:	9100a280 	add	x0, x20, #0x28
  415ed4:	9400043d 	bl	416fc8 <z_abort_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  415ed8:	f947ce73 	ldr	x19, [x19, #3992]
  415edc:	aa1303e0 	mov	x0, x19
  415ee0:	97fff18a 	bl	412508 <z_spin_unlock_valid>
  415ee4:	72001c1f 	tst	w0, #0xff
  415ee8:	54000281 	b.ne	415f38 <z_unpend_first_thread+0x10c>  // b.any
  415eec:	90000034 	adrp	x20, 419000 <__func__.2+0xa80>
  415ef0:	912c1294 	add	x20, x20, #0xb04
  415ef4:	aa1403e2 	mov	x2, x20
  415ef8:	52801863 	mov	w3, #0xc3                  	// #195
  415efc:	90000021 	adrp	x1, 419000 <__func__.2+0xa80>
  415f00:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415f04:	912d7821 	add	x1, x1, #0xb5e
  415f08:	91178000 	add	x0, x0, #0x5e0
  415f0c:	97ffc3c7 	bl	406e28 <assert_print>
  415f10:	aa1303e1 	mov	x1, x19
  415f14:	90000020 	adrp	x0, 419000 <__func__.2+0xa80>
  415f18:	912dd400 	add	x0, x0, #0xb75
  415f1c:	97ffc3c3 	bl	406e28 <assert_print>
  415f20:	52801861 	mov	w1, #0xc3                  	// #195
  415f24:	aa1403e0 	mov	x0, x20
  415f28:	97ffc3ea 	bl	406ed0 <assert_post_action>
  415f2c:	aa1403e1 	mov	x1, x20
  415f30:	52801862 	mov	w2, #0xc3                  	// #195
  415f34:	17ffffdd 	b	415ea8 <z_unpend_first_thread+0x7c>
	posix_irq_unlock(key);
  415f38:	2a1503e0 	mov	w0, w21
  415f3c:	97ffccc3 	bl	409248 <posix_irq_unlock>
}
  415f40:	aa1403e0 	mov	x0, x20
  415f44:	a94153f3 	ldp	x19, x20, [sp, #16]
  415f48:	a9425bf5 	ldp	x21, x22, [sp, #32]
  415f4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  415f50:	d65f03c0 	ret

0000000000415f54 <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
  415f54:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  415f58:	910003fd 	mov	x29, sp
  415f5c:	a90153f3 	stp	x19, x20, [sp, #16]
  415f60:	aa0003f4 	mov	x20, x0
	int need_sched = 0;
  415f64:	52800000 	mov	w0, #0x0                   	// #0
	return list->head == list;
  415f68:	f9400293 	ldr	x19, [x20]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  415f6c:	eb13029f 	cmp	x20, x19
  415f70:	54000040 	b.eq	415f78 <z_unpend_all+0x24>  // b.none
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
  415f74:	b5000093 	cbnz	x19, 415f84 <z_unpend_all+0x30>
		z_ready_thread(thread);
		need_sched = 1;
	}

	return need_sched;
}
  415f78:	a94153f3 	ldp	x19, x20, [sp, #16]
  415f7c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  415f80:	d65f03c0 	ret
		z_unpend_thread(thread);
  415f84:	aa1303e0 	mov	x0, x19
  415f88:	97fffaf4 	bl	414b58 <z_unpend_thread>
		z_ready_thread(thread);
  415f8c:	aa1303e0 	mov	x0, x19
  415f90:	97fffc56 	bl	4150e8 <z_ready_thread>
		need_sched = 1;
  415f94:	52800020 	mov	w0, #0x1                   	// #1
  415f98:	17fffff4 	b	415f68 <z_unpend_all+0x14>

0000000000415f9c <init_ready_q>:
#elif defined(CONFIG_SCHED_MULTIQ)
	for (int i = 0; i < ARRAY_SIZE(_kernel.ready_q.runq.queues); i++) {
		sys_dlist_init(&rq->runq.queues[i]);
	}
#else
	sys_dlist_init(&rq->runq);
  415f9c:	91002001 	add	x1, x0, #0x8
	list->tail = (sys_dnode_t *)list;
  415fa0:	a9008401 	stp	x1, x1, [x0, #8]
#endif
}
  415fa4:	d65f03c0 	ret

0000000000415fa8 <z_sched_init>:
#ifdef CONFIG_SCHED_CPU_MASK_PIN_ONLY
	for (int i = 0; i < CONFIG_MP_MAX_NUM_CPUS; i++) {
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
  415fa8:	900000e0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  415fac:	f9471000 	ldr	x0, [x0, #3616]
  415fb0:	9100a000 	add	x0, x0, #0x28
  415fb4:	17fffffa 	b	415f9c <init_ready_q>

0000000000415fb8 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
  415fb8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  415fbc:	900000e1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  415fc0:	910003fd 	mov	x29, sp
  415fc4:	a9025bf5 	stp	x21, x22, [sp, #32]
  415fc8:	f9471035 	ldr	x21, [x1, #3616]
  415fcc:	a90153f3 	stp	x19, x20, [sp, #16]
  415fd0:	a90363f7 	stp	x23, x24, [sp, #48]
  415fd4:	f90023f9 	str	x25, [sp, #64]
	__ASSERT(!arch_is_in_isr(), "");
  415fd8:	b94002a0 	ldr	w0, [x21]
  415fdc:	340002a0 	cbz	w0, 416030 <z_impl_k_yield+0x78>
  415fe0:	b0000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  415fe4:	91148273 	add	x19, x19, #0x520
  415fe8:	aa1303e2 	mov	x2, x19
  415fec:	b0000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  415ff0:	910a4421 	add	x1, x1, #0x291
  415ff4:	5280ae23 	mov	w3, #0x571                 	// #1393
  415ff8:	f0000000 	adrp	x0, 418000 <table.0+0x1d8>
  415ffc:	91178000 	add	x0, x0, #0x5e0
  416000:	97ffc38a 	bl	406e28 <assert_print>
  416004:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416008:	912e6c00 	add	x0, x0, #0xb9b
  41600c:	97ffc387 	bl	406e28 <assert_print>
  416010:	aa1303e0 	mov	x0, x19
  416014:	5280ae21 	mov	w1, #0x571                 	// #1393
  416018:	97ffc3ae 	bl	406ed0 <assert_post_action>
  41601c:	5280ae22 	mov	w2, #0x571                 	// #1393
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  416020:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416024:	aa1303e1 	mov	x1, x19
  416028:	91187800 	add	x0, x0, #0x61e
  41602c:	97ffcd9b 	bl	409698 <posix_print_error_and_exit>
  416030:	f00000d7 	adrp	x23, 431000 <__FRAME_END__+0x10804>
  416034:	aa0103f6 	mov	x22, x1
	return posix_irq_lock();
  416038:	97ffcc82 	bl	409240 <posix_irq_lock>
  41603c:	2a0003f8 	mov	w24, w0
  416040:	f947cef9 	ldr	x25, [x23, #3992]
  416044:	aa1903e0 	mov	x0, x25
  416048:	97fff125 	bl	4124dc <z_spin_lock_valid>
  41604c:	72001c1f 	tst	w0, #0xff
  416050:	54000261 	b.ne	41609c <z_impl_k_yield+0xe4>  // b.any
  416054:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  416058:	912c1273 	add	x19, x19, #0xb04
  41605c:	aa1303e2 	mov	x2, x19
  416060:	52801283 	mov	w3, #0x94                  	// #148
  416064:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416068:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  41606c:	912cc421 	add	x1, x1, #0xb31
  416070:	91178000 	add	x0, x0, #0x5e0
  416074:	97ffc36d 	bl	406e28 <assert_print>
  416078:	aa1903e1 	mov	x1, x25
  41607c:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416080:	912d1800 	add	x0, x0, #0xb46
  416084:	97ffc369 	bl	406e28 <assert_print>
  416088:	aa1303e0 	mov	x0, x19
  41608c:	52801281 	mov	w1, #0x94                  	// #148
  416090:	97ffc390 	bl	406ed0 <assert_post_action>
  416094:	52801282 	mov	w2, #0x94                  	// #148
  416098:	17ffffe2 	b	416020 <z_impl_k_yield+0x68>
	z_spin_lock_set_owner(l);
  41609c:	aa1903e0 	mov	x0, x25
  4160a0:	97fff127 	bl	41253c <z_spin_lock_set_owner>

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
  4160a4:	f9400aa1 	ldr	x1, [x21, #16]
	thread->base.thread_state &= ~_THREAD_QUEUED;
  4160a8:	39406420 	ldrb	w0, [x1, #25]
  4160ac:	12001800 	and	w0, w0, #0x7f
  4160b0:	39006420 	strb	w0, [x1, #25]
	_priq_run_remove(thread_runq(thread), thread);
  4160b4:	9100c2a0 	add	x0, x21, #0x30
  4160b8:	97fffa6b 	bl	414a64 <z_priq_dumb_remove>
	}
	queue_thread(_current);
  4160bc:	f9400ab3 	ldr	x19, [x21, #16]
	thread->base.thread_state |= _THREAD_QUEUED;
  4160c0:	39406660 	ldrb	w0, [x19, #25]
  4160c4:	32196000 	orr	w0, w0, #0xffffff80
  4160c8:	39006660 	strb	w0, [x19, #25]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
  4160cc:	f00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4160d0:	f946e000 	ldr	x0, [x0, #3520]
  4160d4:	eb00027f 	cmp	x19, x0
  4160d8:	540001e1 	b.ne	416114 <z_impl_k_yield+0x15c>  // b.any
  4160dc:	90000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4160e0:	91148273 	add	x19, x19, #0x520
  4160e4:	aa1303e2 	mov	x2, x19
  4160e8:	52801783 	mov	w3, #0xbc                  	// #188
  4160ec:	90000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4160f0:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4160f4:	911cdc21 	add	x1, x1, #0x737
  4160f8:	91178000 	add	x0, x0, #0x5e0
  4160fc:	97ffc34b 	bl	406e28 <assert_print>
  416100:	aa1303e0 	mov	x0, x19
  416104:	52801781 	mov	w1, #0xbc                  	// #188
  416108:	97ffc372 	bl	406ed0 <assert_post_action>
  41610c:	52801782 	mov	w2, #0xbc                  	// #188
  416110:	17ffffc4 	b	416020 <z_impl_k_yield+0x68>
	return list->head == list;
  416114:	aa1503e0 	mov	x0, x21
  416118:	f8430c14 	ldr	x20, [x0, #48]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  41611c:	eb00029f 	cmp	x20, x0
  416120:	54000481 	b.ne	4161b0 <z_impl_k_yield+0x1f8>  // b.any
	sys_dnode_t *const tail = list->tail;
  416124:	f94712c1 	ldr	x1, [x22, #3616]
	node->next = list;
  416128:	9100c022 	add	x2, x1, #0x30
	sys_dnode_t *const tail = list->tail;
  41612c:	f9401c20 	ldr	x0, [x1, #56]
	node->prev = tail;
  416130:	a9000262 	stp	x2, x0, [x19]
	tail->next = node;
  416134:	f9000013 	str	x19, [x0]
	list->tail = node;
  416138:	f9001c33 	str	x19, [x1, #56]
	update_cache(1);
  41613c:	52800020 	mov	w0, #0x1                   	// #1
  416140:	97fffad1 	bl	414c84 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416144:	f947cef7 	ldr	x23, [x23, #3992]
  416148:	aa1703e0 	mov	x0, x23
  41614c:	97fff0ef 	bl	412508 <z_spin_unlock_valid>
  416150:	72001c1f 	tst	w0, #0xff
  416154:	54000441 	b.ne	4161dc <z_impl_k_yield+0x224>  // b.any
  416158:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  41615c:	912c1273 	add	x19, x19, #0xb04
  416160:	aa1303e2 	mov	x2, x19
  416164:	52801c43 	mov	w3, #0xe2                  	// #226
  416168:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  41616c:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416170:	912d7821 	add	x1, x1, #0xb5e
  416174:	91178000 	add	x0, x0, #0x5e0
  416178:	97ffc32c 	bl	406e28 <assert_print>
  41617c:	aa1703e1 	mov	x1, x23
  416180:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416184:	912dd400 	add	x0, x0, #0xb75
  416188:	97ffc328 	bl	406e28 <assert_print>
  41618c:	aa1303e0 	mov	x0, x19
  416190:	52801c41 	mov	w1, #0xe2                  	// #226
  416194:	97ffc34f 	bl	406ed0 <assert_post_action>
  416198:	52801c42 	mov	w2, #0xe2                  	// #226
  41619c:	17ffffa1 	b	416020 <z_impl_k_yield+0x68>
	return (node == list->tail) ? NULL : node->next;
  4161a0:	f9401ea0 	ldr	x0, [x21, #56]
  4161a4:	eb14001f 	cmp	x0, x20
  4161a8:	54fffbe0 	b.eq	416124 <z_impl_k_yield+0x16c>  // b.none
  4161ac:	f9400294 	ldr	x20, [x20]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
  4161b0:	b4fffbb4 	cbz	x20, 416124 <z_impl_k_yield+0x16c>
		if (z_sched_prio_cmp(thread, t) > 0) {
  4161b4:	aa1403e1 	mov	x1, x20
  4161b8:	aa1303e0 	mov	x0, x19
  4161bc:	97fff901 	bl	4145c0 <z_sched_prio_cmp>
  4161c0:	7100001f 	cmp	w0, #0x0
  4161c4:	54fffeed 	b.le	4161a0 <z_impl_k_yield+0x1e8>
	sys_dnode_t *const prev = successor->prev;
  4161c8:	f9400680 	ldr	x0, [x20, #8]
	node->prev = prev;
  4161cc:	a9000274 	stp	x20, x0, [x19]
	prev->next = node;
  4161d0:	f9000013 	str	x19, [x0]
	successor->prev = node;
  4161d4:	f9000693 	str	x19, [x20, #8]
}
  4161d8:	17ffffd9 	b	41613c <z_impl_k_yield+0x184>
  4161dc:	2a1803e0 	mov	w0, w24
	z_swap(&sched_spinlock, key);
}
  4161e0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4161e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4161e8:	a94363f7 	ldp	x23, x24, [sp, #48]
  4161ec:	f94023f9 	ldr	x25, [sp, #64]
  4161f0:	a8c57bfd 	ldp	x29, x30, [sp], #80
  4161f4:	17ffc8e9 	b	408598 <arch_swap>

00000000004161f8 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
  4161f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4161fc:	910003fd 	mov	x29, sp
  416200:	a90153f3 	stp	x19, x20, [sp, #16]
  416204:	f00000d4 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  416208:	a9025bf5 	stp	x21, x22, [sp, #32]
  41620c:	aa0003f6 	mov	x22, x0
  416210:	f9471280 	ldr	x0, [x20, #3616]
  416214:	f9001bf7 	str	x23, [sp, #48]
#ifdef CONFIG_MULTITHREADING
	uint32_t expected_wakeup_ticks;

	__ASSERT(!arch_is_in_isr(), "");
  416218:	b9400000 	ldr	w0, [x0]
  41621c:	340002a0 	cbz	w0, 416270 <z_tick_sleep+0x78>
  416220:	90000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  416224:	91148273 	add	x19, x19, #0x520
  416228:	aa1303e2 	mov	x2, x19
  41622c:	90000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  416230:	910a4421 	add	x1, x1, #0x291
  416234:	5280b1a3 	mov	w3, #0x58d                 	// #1421
  416238:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  41623c:	91178000 	add	x0, x0, #0x5e0
  416240:	97ffc2fa 	bl	406e28 <assert_print>
  416244:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416248:	912e6c00 	add	x0, x0, #0xb9b
  41624c:	97ffc2f7 	bl	406e28 <assert_print>
  416250:	aa1303e0 	mov	x0, x19
  416254:	5280b1a1 	mov	w1, #0x58d                 	// #1421
  416258:	97ffc31e 	bl	406ed0 <assert_post_action>
  41625c:	5280b1a2 	mov	w2, #0x58d                 	// #1421
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  416260:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416264:	aa1303e1 	mov	x1, x19
  416268:	91187800 	add	x0, x0, #0x61e
  41626c:	97ffcd0b 	bl	409698 <posix_print_error_and_exit>

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
  416270:	b5000116 	cbnz	x22, 416290 <z_tick_sleep+0x98>
	z_impl_k_yield();
  416274:	97ffff51 	bl	415fb8 <z_impl_k_yield>
		k_yield();
		return 0;
  416278:	52800000 	mov	w0, #0x0                   	// #0
		return ticks;
	}
#endif

	return 0;
}
  41627c:	a94153f3 	ldp	x19, x20, [sp, #16]
  416280:	a9425bf5 	ldp	x21, x22, [sp, #32]
  416284:	f9401bf7 	ldr	x23, [sp, #48]
  416288:	a8c47bfd 	ldp	x29, x30, [sp], #64
  41628c:	d65f03c0 	ret
	if (Z_TICK_ABS(ticks) <= 0) {
  416290:	b1000adf 	cmn	x22, #0x2
  416294:	540003ab 	b.lt	416308 <z_tick_sleep+0x110>  // b.tstop
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
  416298:	94000456 	bl	4173f0 <sys_clock_tick_get_32>
  41629c:	0b160013 	add	w19, w0, w22
  4162a0:	f00000d5 	adrp	x21, 431000 <__FRAME_END__+0x10804>
  4162a4:	97ffcbe7 	bl	409240 <posix_irq_lock>
  4162a8:	2a0003f7 	mov	w23, w0
  4162ac:	f947ceb5 	ldr	x21, [x21, #3992]
  4162b0:	aa1503e0 	mov	x0, x21
  4162b4:	97fff08a 	bl	4124dc <z_spin_lock_valid>
  4162b8:	72001c1f 	tst	w0, #0xff
  4162bc:	540002c1 	b.ne	416314 <z_tick_sleep+0x11c>  // b.any
  4162c0:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  4162c4:	912c1273 	add	x19, x19, #0xb04
  4162c8:	aa1303e2 	mov	x2, x19
  4162cc:	52801283 	mov	w3, #0x94                  	// #148
  4162d0:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  4162d4:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4162d8:	912cc421 	add	x1, x1, #0xb31
  4162dc:	91178000 	add	x0, x0, #0x5e0
  4162e0:	97ffc2d2 	bl	406e28 <assert_print>
  4162e4:	aa1503e1 	mov	x1, x21
  4162e8:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  4162ec:	912d1800 	add	x0, x0, #0xb46
  4162f0:	97ffc2ce 	bl	406e28 <assert_print>
  4162f4:	aa1303e0 	mov	x0, x19
  4162f8:	52801281 	mov	w1, #0x94                  	// #148
  4162fc:	97ffc2f5 	bl	406ed0 <assert_post_action>
  416300:	52801282 	mov	w2, #0x94                  	// #148
  416304:	17ffffd7 	b	416260 <z_tick_sleep+0x68>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
  416308:	12800033 	mov	w19, #0xfffffffe            	// #-2
  41630c:	4b160273 	sub	w19, w19, w22
  416310:	17ffffe4 	b	4162a0 <z_tick_sleep+0xa8>
	z_spin_lock_set_owner(l);
  416314:	aa1503e0 	mov	x0, x21
  416318:	97fff089 	bl	41253c <z_spin_lock_set_owner>
	unready_thread(_current);
  41631c:	f9471294 	ldr	x20, [x20, #3616]
  416320:	f9400a80 	ldr	x0, [x20, #16]
  416324:	97fffc58 	bl	415484 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  416328:	f00000c1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  41632c:	aa1603e2 	mov	x2, x22
	z_add_thread_timeout(_current, timeout);
  416330:	f9400a80 	ldr	x0, [x20, #16]
  416334:	f9470421 	ldr	x1, [x1, #3592]
  416338:	9100a000 	add	x0, x0, #0x28
  41633c:	94000291 	bl	416d80 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
  416340:	f9400a82 	ldr	x2, [x20, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416344:	aa1503e0 	mov	x0, x21
  416348:	39406441 	ldrb	w1, [x2, #25]
  41634c:	321c0021 	orr	w1, w1, #0x10
  416350:	39006441 	strb	w1, [x2, #25]
  416354:	97fff06d 	bl	412508 <z_spin_unlock_valid>
  416358:	72001c1f 	tst	w0, #0xff
  41635c:	54000261 	b.ne	4163a8 <z_tick_sleep+0x1b0>  // b.any
  416360:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  416364:	912c1273 	add	x19, x19, #0xb04
  416368:	aa1303e2 	mov	x2, x19
  41636c:	52801c43 	mov	w3, #0xe2                  	// #226
  416370:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416374:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416378:	912d7821 	add	x1, x1, #0xb5e
  41637c:	91178000 	add	x0, x0, #0x5e0
  416380:	97ffc2aa 	bl	406e28 <assert_print>
  416384:	aa1503e1 	mov	x1, x21
  416388:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  41638c:	912dd400 	add	x0, x0, #0xb75
  416390:	97ffc2a6 	bl	406e28 <assert_print>
  416394:	aa1303e0 	mov	x0, x19
  416398:	52801c41 	mov	w1, #0xe2                  	// #226
  41639c:	97ffc2cd 	bl	406ed0 <assert_post_action>
  4163a0:	52801c42 	mov	w2, #0xe2                  	// #226
  4163a4:	17ffffaf 	b	416260 <z_tick_sleep+0x68>
  4163a8:	2a1703e0 	mov	w0, w23
  4163ac:	97ffc87b 	bl	408598 <arch_swap>
	return (thread->base.thread_state & state) != 0U;
  4163b0:	f9400a80 	ldr	x0, [x20, #16]
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
  4163b4:	39406400 	ldrb	w0, [x0, #25]
  4163b8:	36200240 	tbz	w0, #4, 416400 <z_tick_sleep+0x208>
  4163bc:	90000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4163c0:	91148273 	add	x19, x19, #0x520
  4163c4:	aa1303e2 	mov	x2, x19
  4163c8:	90000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4163cc:	911ff821 	add	x1, x1, #0x7fe
  4163d0:	5280b523 	mov	w3, #0x5a9                 	// #1449
  4163d4:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4163d8:	91178000 	add	x0, x0, #0x5e0
  4163dc:	97ffc293 	bl	406e28 <assert_print>
  4163e0:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  4163e4:	912e6c00 	add	x0, x0, #0xb9b
  4163e8:	97ffc290 	bl	406e28 <assert_print>
  4163ec:	aa1303e0 	mov	x0, x19
  4163f0:	5280b521 	mov	w1, #0x5a9                 	// #1449
  4163f4:	97ffc2b7 	bl	406ed0 <assert_post_action>
  4163f8:	5280b522 	mov	w2, #0x5a9                 	// #1449
  4163fc:	17ffff99 	b	416260 <z_tick_sleep+0x68>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
  416400:	940003fc 	bl	4173f0 <sys_clock_tick_get_32>
  416404:	cb204260 	sub	x0, x19, w0, uxtw
		return ticks;
  416408:	f100001f 	cmp	x0, #0x0
  41640c:	1a9fc000 	csel	w0, w0, wzr, gt
  416410:	17ffff9b 	b	41627c <z_tick_sleep+0x84>

0000000000416414 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
  416414:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  416418:	f00000c1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  41641c:	910003fd 	mov	x29, sp
  416420:	f9471021 	ldr	x1, [x1, #3616]
  416424:	f9000bf3 	str	x19, [sp, #16]
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
  416428:	b9400022 	ldr	w2, [x1]
  41642c:	340002a2 	cbz	w2, 416480 <z_impl_k_sleep+0x6c>
  416430:	90000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  416434:	91148273 	add	x19, x19, #0x520
  416438:	aa1303e2 	mov	x2, x19
  41643c:	90000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  416440:	910a4421 	add	x1, x1, #0x291
  416444:	5280b703 	mov	w3, #0x5b8                 	// #1464
  416448:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  41644c:	91178000 	add	x0, x0, #0x5e0
  416450:	97ffc276 	bl	406e28 <assert_print>
  416454:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416458:	912e6c00 	add	x0, x0, #0xb9b
  41645c:	97ffc273 	bl	406e28 <assert_print>
  416460:	aa1303e0 	mov	x0, x19
  416464:	5280b701 	mov	w1, #0x5b8                 	// #1464
  416468:	97ffc29a 	bl	406ed0 <assert_post_action>
  41646c:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416470:	aa1303e1 	mov	x1, x19
  416474:	91187800 	add	x0, x0, #0x61e
  416478:	5280b702 	mov	w2, #0x5b8                 	// #1464
  41647c:	97ffcc87 	bl	409698 <posix_print_error_and_exit>
  416480:	aa0003f3 	mov	x19, x0

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  416484:	b100041f 	cmn	x0, #0x1
  416488:	540000e1 	b.ne	4164a4 <z_impl_k_sleep+0x90>  // b.any
		k_thread_suspend(_current);
  41648c:	f9400820 	ldr	x0, [x1, #16]
	z_impl_k_thread_suspend(thread);
  416490:	97fffd58 	bl	4159f0 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
  416494:	2a1303e0 	mov	w0, w19
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
  416498:	f9400bf3 	ldr	x19, [sp, #16]
  41649c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  4164a0:	d65f03c0 	ret
	ticks = z_tick_sleep(ticks);
  4164a4:	97ffff55 	bl	4161f8 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
  4164a8:	52800141 	mov	w1, #0xa                   	// #10
  4164ac:	1b017c00 	mul	w0, w0, w1
	return ret;
  4164b0:	17fffffa 	b	416498 <z_impl_k_sleep+0x84>

00000000004164b4 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
  4164b4:	f00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4164b8:	f9471000 	ldr	x0, [x0, #3616]
  4164bc:	f9400800 	ldr	x0, [x0, #16]
  4164c0:	d65f03c0 	ret

00000000004164c4 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
  4164c4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4164c8:	910003fd 	mov	x29, sp
  4164cc:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4164d0:	f00000d4 	adrp	x20, 431000 <__FRAME_END__+0x10804>
  4164d4:	aa0003f3 	mov	x19, x0
  4164d8:	a9025bf5 	stp	x21, x22, [sp, #32]
  4164dc:	f9001bf7 	str	x23, [sp, #48]
  4164e0:	97ffcb58 	bl	409240 <posix_irq_lock>
  4164e4:	f947ce96 	ldr	x22, [x20, #3992]
  4164e8:	2a0003f5 	mov	w21, w0
  4164ec:	aa1603e0 	mov	x0, x22
  4164f0:	97ffeffb 	bl	4124dc <z_spin_lock_valid>
  4164f4:	72001c1f 	tst	w0, #0xff
  4164f8:	540002c1 	b.ne	416550 <z_thread_abort+0x8c>  // b.any
  4164fc:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  416500:	912c1273 	add	x19, x19, #0xb04
  416504:	aa1303e2 	mov	x2, x19
  416508:	52801283 	mov	w3, #0x94                  	// #148
  41650c:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416510:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416514:	912cc421 	add	x1, x1, #0xb31
  416518:	91178000 	add	x0, x0, #0x5e0
  41651c:	97ffc243 	bl	406e28 <assert_print>
  416520:	aa1603e1 	mov	x1, x22
  416524:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416528:	912d1800 	add	x0, x0, #0xb46
  41652c:	97ffc23f 	bl	406e28 <assert_print>
  416530:	aa1303e0 	mov	x0, x19
  416534:	52801281 	mov	w1, #0x94                  	// #148
  416538:	97ffc266 	bl	406ed0 <assert_post_action>
  41653c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416540:	aa1303e1 	mov	x1, x19
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
  416544:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416548:	91187800 	add	x0, x0, #0x61e
	}
#endif
	end_thread(thread);
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
  41654c:	97ffcc53 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  416550:	aa1603e0 	mov	x0, x22
  416554:	97ffeffa 	bl	41253c <z_spin_lock_set_owner>
	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
  416558:	39406260 	ldrb	w0, [x19, #24]
  41655c:	36000580 	tbz	w0, #0, 41660c <z_thread_abort+0x148>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416560:	aa1603e0 	mov	x0, x22
  416564:	97ffefe9 	bl	412508 <z_spin_unlock_valid>
  416568:	72001c1f 	tst	w0, #0xff
  41656c:	54000261 	b.ne	4165b8 <z_thread_abort+0xf4>  // b.any
  416570:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  416574:	912c1273 	add	x19, x19, #0xb04
  416578:	aa1303e2 	mov	x2, x19
  41657c:	52801863 	mov	w3, #0xc3                  	// #195
  416580:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416584:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416588:	912d7821 	add	x1, x1, #0xb5e
  41658c:	91178000 	add	x0, x0, #0x5e0
  416590:	97ffc226 	bl	406e28 <assert_print>
  416594:	f947ce81 	ldr	x1, [x20, #3992]
  416598:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  41659c:	912dd400 	add	x0, x0, #0xb75
  4165a0:	97ffc222 	bl	406e28 <assert_print>
  4165a4:	aa1303e0 	mov	x0, x19
  4165a8:	52801861 	mov	w1, #0xc3                  	// #195
  4165ac:	97ffc249 	bl	406ed0 <assert_post_action>
  4165b0:	52801862 	mov	w2, #0xc3                  	// #195
  4165b4:	17ffffe3 	b	416540 <z_thread_abort+0x7c>
	posix_irq_unlock(key);
  4165b8:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborting essential thread %p", thread);
  4165bc:	90000034 	adrp	x20, 41a000 <CSWTCH.25+0x22>
  4165c0:	97ffcb22 	bl	409248 <posix_irq_unlock>
  4165c4:	91148294 	add	x20, x20, #0x520
  4165c8:	aa1403e2 	mov	x2, x20
  4165cc:	5280d9c3 	mov	w3, #0x6ce                 	// #1742
  4165d0:	90000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4165d4:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4165d8:	91253c21 	add	x1, x1, #0x94f
  4165dc:	91178000 	add	x0, x0, #0x5e0
  4165e0:	97ffc212 	bl	406e28 <assert_print>
  4165e4:	aa1303e1 	mov	x1, x19
  4165e8:	90000020 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  4165ec:	9120f800 	add	x0, x0, #0x83e
  4165f0:	97ffc20e 	bl	406e28 <assert_print>
  4165f4:	5280d9c1 	mov	w1, #0x6ce                 	// #1742
  4165f8:	aa1403e0 	mov	x0, x20
  4165fc:	97ffc235 	bl	406ed0 <assert_post_action>
  416600:	aa1403e1 	mov	x1, x20
  416604:	5280d9c2 	mov	w2, #0x6ce                 	// #1742
  416608:	17ffffcf 	b	416544 <z_thread_abort+0x80>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  41660c:	39406661 	ldrb	w1, [x19, #25]
  416610:	36180161 	tbz	w1, #3, 41663c <z_thread_abort+0x178>
  416614:	aa1603e0 	mov	x0, x22
  416618:	97ffefbc 	bl	412508 <z_spin_unlock_valid>
  41661c:	72001c1f 	tst	w0, #0xff
  416620:	54fffa80 	b.eq	416570 <z_thread_abort+0xac>  // b.none
  416624:	2a1503e0 	mov	w0, w21
	}
	k_spin_unlock(&sched_spinlock, key);
}
  416628:	a94153f3 	ldp	x19, x20, [sp, #16]
  41662c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  416630:	f9401bf7 	ldr	x23, [sp, #48]
  416634:	a8c47bfd 	ldp	x29, x30, [sp], #64
  416638:	17ffcb04 	b	409248 <posix_irq_unlock>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  41663c:	121a7820 	and	w0, w1, #0xffffffdf
  416640:	321d0002 	orr	w2, w0, #0x8
		if (z_is_thread_queued(thread)) {
  416644:	37380600 	tbnz	w0, #7, 416704 <z_thread_abort+0x240>
		thread->base.thread_state &= ~_THREAD_ABORTING;
  416648:	39006662 	strb	w2, [x19, #25]
		if (thread->base.pended_on != NULL) {
  41664c:	f9400a60 	ldr	x0, [x19, #16]
  416650:	b4000060 	cbz	x0, 41665c <z_thread_abort+0x198>
			unpend_thread_no_timeout(thread);
  416654:	aa1303e0 	mov	x0, x19
  416658:	97fff920 	bl	414ad8 <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
  41665c:	91018277 	add	x23, x19, #0x60
	return z_abort_timeout(&thread->base.timeout);
  416660:	9100a260 	add	x0, x19, #0x28
  416664:	94000259 	bl	416fc8 <z_abort_timeout>
	return list->head == list;
  416668:	f9403276 	ldr	x22, [x19, #96]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  41666c:	eb1702df 	cmp	x22, x23
  416670:	54000040 	b.eq	416678 <z_thread_abort+0x1b4>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
  416674:	b50005d6 	cbnz	x22, 41672c <z_thread_abort+0x268>
		update_cache(1);
  416678:	52800020 	mov	w0, #0x1                   	// #1
  41667c:	97fff982 	bl	414c84 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
  416680:	f00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  416684:	f9471000 	ldr	x0, [x0, #3616]
  416688:	f9400801 	ldr	x1, [x0, #16]
  41668c:	eb13003f 	cmp	x1, x19
  416690:	54000821 	b.ne	416794 <z_thread_abort+0x2d0>  // b.any
  416694:	b9400000 	ldr	w0, [x0]
  416698:	350007e0 	cbnz	w0, 416794 <z_thread_abort+0x2d0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41669c:	f947ce94 	ldr	x20, [x20, #3992]
  4166a0:	d0000017 	adrp	x23, 418000 <table.0+0x1d8>
  4166a4:	d0000016 	adrp	x22, 418000 <table.0+0x1d8>
  4166a8:	aa1403e0 	mov	x0, x20
  4166ac:	97ffef97 	bl	412508 <z_spin_unlock_valid>
  4166b0:	72001c1f 	tst	w0, #0xff
  4166b4:	540004c1 	b.ne	41674c <z_thread_abort+0x288>  // b.any
  4166b8:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  4166bc:	912c1273 	add	x19, x19, #0xb04
  4166c0:	aa1303e2 	mov	x2, x19
  4166c4:	52801c43 	mov	w3, #0xe2                  	// #226
  4166c8:	911782e0 	add	x0, x23, #0x5e0
  4166cc:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  4166d0:	912d7821 	add	x1, x1, #0xb5e
  4166d4:	97ffc1d5 	bl	406e28 <assert_print>
  4166d8:	aa1403e1 	mov	x1, x20
  4166dc:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  4166e0:	912dd400 	add	x0, x0, #0xb75
  4166e4:	97ffc1d1 	bl	406e28 <assert_print>
  4166e8:	aa1303e0 	mov	x0, x19
  4166ec:	52801c41 	mov	w1, #0xe2                  	// #226
  4166f0:	97ffc1f8 	bl	406ed0 <assert_post_action>
  4166f4:	52801c42 	mov	w2, #0xe2                  	// #226
		__ASSERT(false, "aborted _current back from dead");
  4166f8:	aa1303e1 	mov	x1, x19
  4166fc:	91187ac0 	add	x0, x22, #0x61e
  416700:	17ffff93 	b	41654c <z_thread_abort+0x88>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  416704:	52800be0 	mov	w0, #0x5f                  	// #95
  416708:	0a000021 	and	w1, w1, w0
	_priq_run_remove(thread_runq(thread), thread);
  41670c:	f00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
	thread->base.thread_state &= ~_THREAD_QUEUED;
  416710:	321d0021 	orr	w1, w1, #0x8
  416714:	39006661 	strb	w1, [x19, #25]
	_priq_run_remove(thread_runq(thread), thread);
  416718:	aa1303e1 	mov	x1, x19
  41671c:	f9471000 	ldr	x0, [x0, #3616]
  416720:	9100c000 	add	x0, x0, #0x30
  416724:	97fff8d0 	bl	414a64 <z_priq_dumb_remove>
}
  416728:	17ffffc9 	b	41664c <z_thread_abort+0x188>
		unpend_thread_no_timeout(thread);
  41672c:	aa1603e0 	mov	x0, x22
  416730:	97fff8ea 	bl	414ad8 <unpend_thread_no_timeout>
  416734:	9100a2c0 	add	x0, x22, #0x28
  416738:	94000224 	bl	416fc8 <z_abort_timeout>
	thread->callee_saved.retval = value;
  41673c:	b9004edf 	str	wzr, [x22, #76]
		ready_thread(thread);
  416740:	aa1603e0 	mov	x0, x22
  416744:	97fffa21 	bl	414fc8 <ready_thread>
  416748:	17ffffc8 	b	416668 <z_thread_abort+0x1a4>
  41674c:	2a1503e0 	mov	w0, w21
		__ASSERT(false, "aborted _current back from dead");
  416750:	90000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  416754:	97ffc791 	bl	408598 <arch_swap>
  416758:	91148273 	add	x19, x19, #0x520
  41675c:	aa1303e2 	mov	x2, x19
  416760:	90000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  416764:	91253c21 	add	x1, x1, #0x94f
  416768:	5280e083 	mov	w3, #0x704                 	// #1796
  41676c:	911782e0 	add	x0, x23, #0x5e0
  416770:	97ffc1ae 	bl	406e28 <assert_print>
  416774:	90000020 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  416778:	91217400 	add	x0, x0, #0x85d
  41677c:	97ffc1ab 	bl	406e28 <assert_print>
  416780:	aa1303e0 	mov	x0, x19
  416784:	5280e081 	mov	w1, #0x704                 	// #1796
  416788:	97ffc1d2 	bl	406ed0 <assert_post_action>
  41678c:	5280e082 	mov	w2, #0x704                 	// #1796
  416790:	17ffffda 	b	4166f8 <z_thread_abort+0x234>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416794:	f947ce80 	ldr	x0, [x20, #3992]
  416798:	17ffffa0 	b	416618 <z_thread_abort+0x154>

000000000041679c <z_impl_k_thread_join>:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, abort, thread);
}
#endif

int z_impl_k_thread_join(struct k_thread *thread, k_timeout_t timeout)
{
  41679c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  4167a0:	910003fd 	mov	x29, sp
  4167a4:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4167a8:	f00000d3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  4167ac:	aa0003f4 	mov	x20, x0
  4167b0:	a9025bf5 	stp	x21, x22, [sp, #32]
  4167b4:	aa0103f5 	mov	x21, x1
  4167b8:	f9001bf7 	str	x23, [sp, #48]
	return posix_irq_lock();
  4167bc:	97ffcaa1 	bl	409240 <posix_irq_lock>
  4167c0:	f947ce76 	ldr	x22, [x19, #3992]
  4167c4:	2a0003f7 	mov	w23, w0
  4167c8:	aa1603e0 	mov	x0, x22
  4167cc:	97ffef44 	bl	4124dc <z_spin_lock_valid>
  4167d0:	72001c1f 	tst	w0, #0xff
  4167d4:	540002c1 	b.ne	41682c <z_impl_k_thread_join+0x90>  // b.any
  4167d8:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  4167dc:	912c1273 	add	x19, x19, #0xb04
  4167e0:	aa1303e2 	mov	x2, x19
  4167e4:	52801283 	mov	w3, #0x94                  	// #148
  4167e8:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  4167ec:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4167f0:	912cc421 	add	x1, x1, #0xb31
  4167f4:	91178000 	add	x0, x0, #0x5e0
  4167f8:	97ffc18c 	bl	406e28 <assert_print>
  4167fc:	aa1603e1 	mov	x1, x22
  416800:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416804:	912d1800 	add	x0, x0, #0xb46
  416808:	97ffc188 	bl	406e28 <assert_print>
  41680c:	aa1303e0 	mov	x0, x19
  416810:	52801281 	mov	w1, #0x94                  	// #148
  416814:	97ffc1af 	bl	406ed0 <assert_post_action>
  416818:	52801282 	mov	w2, #0x94                  	// #148
		ret = -EBUSY;
	} else if ((thread == _current) ||
		   (thread->base.pended_on == &_current->join_queue)) {
		ret = -EDEADLK;
	} else {
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  41681c:	aa1303e1 	mov	x1, x19
  416820:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416824:	91187800 	add	x0, x0, #0x61e
  416828:	97ffcb9c 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  41682c:	aa1603e0 	mov	x0, x22
  416830:	97ffef43 	bl	41253c <z_spin_lock_set_owner>
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
  416834:	39406680 	ldrb	w0, [x20, #25]
  416838:	371808c0 	tbnz	w0, #3, 416950 <z_impl_k_thread_join+0x1b4>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  41683c:	b4000bb5 	cbz	x21, 4169b0 <z_impl_k_thread_join+0x214>
	} else if ((thread == _current) ||
  416840:	f00000d6 	adrp	x22, 431000 <__FRAME_END__+0x10804>
  416844:	f94712d6 	ldr	x22, [x22, #3616]
  416848:	f9400ac0 	ldr	x0, [x22, #16]
  41684c:	eb14001f 	cmp	x0, x20
  416850:	54000b40 	b.eq	4169b8 <z_impl_k_thread_join+0x21c>  // b.none
  416854:	f9400a82 	ldr	x2, [x20, #16]
		   (thread->base.pended_on == &_current->join_queue)) {
  416858:	91018001 	add	x1, x0, #0x60
	} else if ((thread == _current) ||
  41685c:	eb01005f 	cmp	x2, x1
  416860:	54000ac0 	b.eq	4169b8 <z_impl_k_thread_join+0x21c>  // b.none
		__ASSERT(!arch_is_in_isr(), "cannot join in ISR");
  416864:	b94002c1 	ldr	w1, [x22]
  416868:	34000241 	cbz	w1, 4168b0 <z_impl_k_thread_join+0x114>
  41686c:	90000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  416870:	91148273 	add	x19, x19, #0x520
  416874:	aa1303e2 	mov	x2, x19
  416878:	90000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  41687c:	910a4421 	add	x1, x1, #0x291
  416880:	5280e483 	mov	w3, #0x724                 	// #1828
  416884:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416888:	91178000 	add	x0, x0, #0x5e0
  41688c:	97ffc167 	bl	406e28 <assert_print>
  416890:	90000020 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  416894:	9121fc00 	add	x0, x0, #0x87f
  416898:	97ffc164 	bl	406e28 <assert_print>
  41689c:	aa1303e0 	mov	x0, x19
  4168a0:	5280e481 	mov	w1, #0x724                 	// #1828
  4168a4:	97ffc18b 	bl	406ed0 <assert_post_action>
  4168a8:	5280e482 	mov	w2, #0x724                 	// #1828
  4168ac:	17ffffdc 	b	41681c <z_impl_k_thread_join+0x80>
		add_to_waitq_locked(_current, &thread->join_queue);
  4168b0:	91018281 	add	x1, x20, #0x60
  4168b4:	97fffb09 	bl	4154d8 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  4168b8:	b10006bf 	cmn	x21, #0x1
  4168bc:	540000e0 	b.eq	4168d8 <z_impl_k_thread_join+0x13c>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
  4168c0:	f00000c1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  4168c4:	aa1503e2 	mov	x2, x21
		add_thread_timeout(_current, timeout);
  4168c8:	f9400ac0 	ldr	x0, [x22, #16]
  4168cc:	f9470421 	ldr	x1, [x1, #3592]
  4168d0:	9100a000 	add	x0, x0, #0x28
  4168d4:	9400012b 	bl	416d80 <z_add_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4168d8:	f947ce73 	ldr	x19, [x19, #3992]
  4168dc:	aa1303e0 	mov	x0, x19
  4168e0:	97ffef0a 	bl	412508 <z_spin_unlock_valid>
  4168e4:	72001c1f 	tst	w0, #0xff
  4168e8:	54000281 	b.ne	416938 <z_impl_k_thread_join+0x19c>  // b.any
  4168ec:	f0000014 	adrp	x20, 419000 <__func__.2+0xa80>
  4168f0:	912c1294 	add	x20, x20, #0xb04
  4168f4:	aa1403e2 	mov	x2, x20
  4168f8:	52801c43 	mov	w3, #0xe2                  	// #226
  4168fc:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416900:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416904:	912d7821 	add	x1, x1, #0xb5e
  416908:	91178000 	add	x0, x0, #0x5e0
  41690c:	97ffc147 	bl	406e28 <assert_print>
  416910:	aa1303e1 	mov	x1, x19
  416914:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416918:	912dd400 	add	x0, x0, #0xb75
  41691c:	97ffc143 	bl	406e28 <assert_print>
  416920:	aa1403e0 	mov	x0, x20
  416924:	52801c41 	mov	w1, #0xe2                  	// #226
  416928:	97ffc16a 	bl	406ed0 <assert_post_action>
  41692c:	52801c42 	mov	w2, #0xe2                  	// #226
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416930:	aa1403e1 	mov	x1, x20
  416934:	17ffffbb 	b	416820 <z_impl_k_thread_join+0x84>
  416938:	2a1703e0 	mov	w0, w23

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_thread, join, thread, timeout, ret);

	k_spin_unlock(&sched_spinlock, key);
	return ret;
}
  41693c:	a94153f3 	ldp	x19, x20, [sp, #16]
  416940:	a9425bf5 	ldp	x21, x22, [sp, #32]
  416944:	f9401bf7 	ldr	x23, [sp, #48]
  416948:	a8c47bfd 	ldp	x29, x30, [sp], #64
  41694c:	17ffc713 	b	408598 <arch_swap>
		ret = 0;
  416950:	52800014 	mov	w20, #0x0                   	// #0
  416954:	f947ce73 	ldr	x19, [x19, #3992]
  416958:	aa1303e0 	mov	x0, x19
  41695c:	97ffeeeb 	bl	412508 <z_spin_unlock_valid>
  416960:	72001c1f 	tst	w0, #0xff
  416964:	540002e1 	b.ne	4169c0 <z_impl_k_thread_join+0x224>  // b.any
  416968:	f0000014 	adrp	x20, 419000 <__func__.2+0xa80>
  41696c:	912c1294 	add	x20, x20, #0xb04
  416970:	aa1403e2 	mov	x2, x20
  416974:	52801863 	mov	w3, #0xc3                  	// #195
  416978:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  41697c:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416980:	912d7821 	add	x1, x1, #0xb5e
  416984:	91178000 	add	x0, x0, #0x5e0
  416988:	97ffc128 	bl	406e28 <assert_print>
  41698c:	aa1303e1 	mov	x1, x19
  416990:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416994:	912dd400 	add	x0, x0, #0xb75
  416998:	97ffc124 	bl	406e28 <assert_print>
  41699c:	aa1403e0 	mov	x0, x20
  4169a0:	52801861 	mov	w1, #0xc3                  	// #195
  4169a4:	97ffc14b 	bl	406ed0 <assert_post_action>
  4169a8:	52801862 	mov	w2, #0xc3                  	// #195
  4169ac:	17ffffe1 	b	416930 <z_impl_k_thread_join+0x194>
		ret = -EBUSY;
  4169b0:	128001f4 	mov	w20, #0xfffffff0            	// #-16
  4169b4:	17ffffe8 	b	416954 <z_impl_k_thread_join+0x1b8>
		ret = -EDEADLK;
  4169b8:	12800454 	mov	w20, #0xffffffdd            	// #-35
  4169bc:	17ffffe6 	b	416954 <z_impl_k_thread_join+0x1b8>
	posix_irq_unlock(key);
  4169c0:	2a1703e0 	mov	w0, w23
  4169c4:	97ffca21 	bl	409248 <posix_irq_unlock>
}
  4169c8:	2a1403e0 	mov	w0, w20
  4169cc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4169d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4169d4:	f9401bf7 	ldr	x23, [sp, #48]
  4169d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4169dc:	d65f03c0 	ret

00000000004169e0 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
  4169e0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  4169e4:	910003fd 	mov	x29, sp
  4169e8:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4169ec:	f00000d3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  4169f0:	aa0003f4 	mov	x20, x0
  4169f4:	a9025bf5 	stp	x21, x22, [sp, #32]
  4169f8:	a90363f7 	stp	x23, x24, [sp, #48]
  4169fc:	2a0103f8 	mov	w24, w1
  416a00:	aa0203f7 	mov	x23, x2
  416a04:	f90023f9 	str	x25, [sp, #64]
	return posix_irq_lock();
  416a08:	97ffca0e 	bl	409240 <posix_irq_lock>
  416a0c:	f947ce79 	ldr	x25, [x19, #3992]
  416a10:	2a0003f6 	mov	w22, w0
  416a14:	aa1903e0 	mov	x0, x25
  416a18:	97ffeeb1 	bl	4124dc <z_spin_lock_valid>
  416a1c:	72001c15 	ands	w21, w0, #0xff
  416a20:	540002c1 	b.ne	416a78 <z_sched_wake+0x98>  // b.any
  416a24:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  416a28:	912c1273 	add	x19, x19, #0xb04
  416a2c:	aa1303e2 	mov	x2, x19
  416a30:	52801283 	mov	w3, #0x94                  	// #148
  416a34:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416a38:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416a3c:	912cc421 	add	x1, x1, #0xb31
  416a40:	91178000 	add	x0, x0, #0x5e0
  416a44:	97ffc0f9 	bl	406e28 <assert_print>
  416a48:	aa1903e1 	mov	x1, x25
  416a4c:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416a50:	912d1800 	add	x0, x0, #0xb46
  416a54:	97ffc0f5 	bl	406e28 <assert_print>
  416a58:	52801281 	mov	w1, #0x94                  	// #148
  416a5c:	aa1303e0 	mov	x0, x19
  416a60:	97ffc11c 	bl	406ed0 <assert_post_action>
  416a64:	aa1303e1 	mov	x1, x19
  416a68:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416a6c:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416a70:	91187800 	add	x0, x0, #0x61e
  416a74:	97ffcb09 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  416a78:	aa1903e0 	mov	x0, x25
  416a7c:	97ffeeb0 	bl	41253c <z_spin_lock_set_owner>
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
  416a80:	aa1403e0 	mov	x0, x20
  416a84:	97fff87c 	bl	414c74 <z_priq_dumb_best>
  416a88:	aa0003f4 	mov	x20, x0

		if (thread != NULL) {
  416a8c:	b4000400 	cbz	x0, 416b0c <z_sched_wake+0x12c>
	thread->base.swap_data = data;
  416a90:	f9001017 	str	x23, [x0, #32]
  416a94:	b9004c18 	str	w24, [x0, #76]
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
  416a98:	97fff810 	bl	414ad8 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
  416a9c:	9100a280 	add	x0, x20, #0x28
  416aa0:	9400014a 	bl	416fc8 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
  416aa4:	aa1403e0 	mov	x0, x20
  416aa8:	97fff948 	bl	414fc8 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416aac:	f947ce73 	ldr	x19, [x19, #3992]
  416ab0:	aa1303e0 	mov	x0, x19
  416ab4:	97ffee95 	bl	412508 <z_spin_unlock_valid>
  416ab8:	72001c1f 	tst	w0, #0xff
  416abc:	540002c1 	b.ne	416b14 <z_sched_wake+0x134>  // b.any
  416ac0:	f0000014 	adrp	x20, 419000 <__func__.2+0xa80>
  416ac4:	912c1294 	add	x20, x20, #0xb04
  416ac8:	aa1403e2 	mov	x2, x20
  416acc:	52801863 	mov	w3, #0xc3                  	// #195
  416ad0:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416ad4:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416ad8:	912d7821 	add	x1, x1, #0xb5e
  416adc:	91178000 	add	x0, x0, #0x5e0
  416ae0:	97ffc0d2 	bl	406e28 <assert_print>
  416ae4:	aa1303e1 	mov	x1, x19
  416ae8:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416aec:	912dd400 	add	x0, x0, #0xb75
  416af0:	97ffc0ce 	bl	406e28 <assert_print>
  416af4:	52801861 	mov	w1, #0xc3                  	// #195
  416af8:	aa1403e0 	mov	x0, x20
  416afc:	97ffc0f5 	bl	406ed0 <assert_post_action>
  416b00:	aa1403e1 	mov	x1, x20
  416b04:	52801862 	mov	w2, #0xc3                  	// #195
  416b08:	17ffffd9 	b	416a6c <z_sched_wake+0x8c>
	bool ret = false;
  416b0c:	52800015 	mov	w21, #0x0                   	// #0
  416b10:	17ffffe7 	b	416aac <z_sched_wake+0xcc>
	posix_irq_unlock(key);
  416b14:	2a1603e0 	mov	w0, w22
  416b18:	97ffc9cc 	bl	409248 <posix_irq_unlock>
			ret = true;
		}
	}

	return ret;
}
  416b1c:	2a1503e0 	mov	w0, w21
  416b20:	a94153f3 	ldp	x19, x20, [sp, #16]
  416b24:	a9425bf5 	ldp	x21, x22, [sp, #32]
  416b28:	a94363f7 	ldp	x23, x24, [sp, #48]
  416b2c:	f94023f9 	ldr	x25, [sp, #64]
  416b30:	a8c57bfd 	ldp	x29, x30, [sp], #80
  416b34:	d65f03c0 	ret

0000000000416b38 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
  416b38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  416b3c:	910003fd 	mov	x29, sp
  416b40:	f9000bf3 	str	x19, [sp, #16]
  416b44:	aa0403f3 	mov	x19, x4
	int ret = z_pend_curr(lock, key, wait_q, timeout);
  416b48:	97fffab1 	bl	41560c <z_pend_curr>

	if (data != NULL) {
  416b4c:	b40000d3 	cbz	x19, 416b64 <z_sched_wait+0x2c>
		*data = _current->base.swap_data;
  416b50:	f00000c1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  416b54:	f9471021 	ldr	x1, [x1, #3616]
  416b58:	f9400821 	ldr	x1, [x1, #16]
  416b5c:	f9401021 	ldr	x1, [x1, #32]
  416b60:	f9000261 	str	x1, [x19]
	}
	return ret;
}
  416b64:	f9400bf3 	ldr	x19, [sp, #16]
  416b68:	a8c27bfd 	ldp	x29, x30, [sp], #32
  416b6c:	d65f03c0 	ret

0000000000416b70 <z_sched_waitq_walk>:

int z_sched_waitq_walk(_wait_q_t  *wait_q,
		       int (*func)(struct k_thread *, void *), void *data)
{
  416b70:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  416b74:	910003fd 	mov	x29, sp
  416b78:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  416b7c:	f00000d3 	adrp	x19, 431000 <__FRAME_END__+0x10804>
  416b80:	a9025bf5 	stp	x21, x22, [sp, #32]
  416b84:	aa0003f6 	mov	x22, x0
  416b88:	a90363f7 	stp	x23, x24, [sp, #48]
  416b8c:	aa0103f8 	mov	x24, x1
  416b90:	f90023f9 	str	x25, [sp, #64]
  416b94:	aa0203f9 	mov	x25, x2
	return posix_irq_lock();
  416b98:	97ffc9aa 	bl	409240 <posix_irq_lock>
  416b9c:	2a0003f7 	mov	w23, w0
  416ba0:	f947ce74 	ldr	x20, [x19, #3992]
  416ba4:	aa1403e0 	mov	x0, x20
  416ba8:	97ffee4d 	bl	4124dc <z_spin_lock_valid>
  416bac:	72001c1f 	tst	w0, #0xff
  416bb0:	540002c1 	b.ne	416c08 <z_sched_waitq_walk+0x98>  // b.any
  416bb4:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  416bb8:	912c1273 	add	x19, x19, #0xb04
  416bbc:	aa1303e2 	mov	x2, x19
  416bc0:	52801283 	mov	w3, #0x94                  	// #148
  416bc4:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416bc8:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416bcc:	912cc421 	add	x1, x1, #0xb31
  416bd0:	91178000 	add	x0, x0, #0x5e0
  416bd4:	97ffc095 	bl	406e28 <assert_print>
  416bd8:	aa1403e1 	mov	x1, x20
  416bdc:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416be0:	912d1800 	add	x0, x0, #0xb46
  416be4:	97ffc091 	bl	406e28 <assert_print>
  416be8:	52801281 	mov	w1, #0x94                  	// #148
  416bec:	aa1303e0 	mov	x0, x19
  416bf0:	97ffc0b8 	bl	406ed0 <assert_post_action>
  416bf4:	aa1303e1 	mov	x1, x19
  416bf8:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416bfc:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416c00:	91187800 	add	x0, x0, #0x61e
  416c04:	97ffcaa5 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  416c08:	aa1403e0 	mov	x0, x20
  416c0c:	97ffee4c 	bl	41253c <z_spin_lock_set_owner>
	return list->head == list;
  416c10:	f94002d4 	ldr	x20, [x22]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  416c14:	eb1402df 	cmp	x22, x20
  416c18:	54000341 	b.ne	416c80 <z_sched_waitq_walk+0x110>  // b.any
  416c1c:	52800015 	mov	w21, #0x0                   	// #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416c20:	f947ce73 	ldr	x19, [x19, #3992]
  416c24:	aa1303e0 	mov	x0, x19
  416c28:	97ffee38 	bl	412508 <z_spin_unlock_valid>
  416c2c:	72001c1f 	tst	w0, #0xff
  416c30:	540003e1 	b.ne	416cac <z_sched_waitq_walk+0x13c>  // b.any
  416c34:	f0000014 	adrp	x20, 419000 <__func__.2+0xa80>
  416c38:	912c1294 	add	x20, x20, #0xb04
  416c3c:	aa1403e2 	mov	x2, x20
  416c40:	52801863 	mov	w3, #0xc3                  	// #195
  416c44:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416c48:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416c4c:	912d7821 	add	x1, x1, #0xb5e
  416c50:	91178000 	add	x0, x0, #0x5e0
  416c54:	97ffc075 	bl	406e28 <assert_print>
  416c58:	aa1303e1 	mov	x1, x19
  416c5c:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416c60:	912dd400 	add	x0, x0, #0xb75
  416c64:	97ffc071 	bl	406e28 <assert_print>
  416c68:	52801861 	mov	w1, #0xc3                  	// #195
  416c6c:	aa1403e0 	mov	x0, x20
  416c70:	97ffc098 	bl	406ed0 <assert_post_action>
  416c74:	aa1403e1 	mov	x1, x20
  416c78:	52801862 	mov	w2, #0xc3                  	// #195
  416c7c:	17ffffe0 	b	416bfc <z_sched_waitq_walk+0x8c>
	struct k_thread *thread;
	int  status = 0;

	LOCKED(&sched_spinlock) {
		_WAIT_Q_FOR_EACH(wait_q, thread) {
  416c80:	b4fffcf4 	cbz	x20, 416c1c <z_sched_waitq_walk+0xac>
			 * Invoke the callback function on each waiting thread
			 * for as long as there are both waiting threads AND
			 * it returns 0.
			 */

			status = func(thread, data);
  416c84:	aa1903e1 	mov	x1, x25
  416c88:	aa1403e0 	mov	x0, x20
  416c8c:	d63f0300 	blr	x24
  416c90:	2a0003f5 	mov	w21, w0
			if (status != 0) {
  416c94:	35fffc60 	cbnz	w0, 416c20 <z_sched_waitq_walk+0xb0>
	return (node == list->tail) ? NULL : node->next;
  416c98:	f94006c0 	ldr	x0, [x22, #8]
  416c9c:	eb00029f 	cmp	x20, x0
  416ca0:	54fffbe0 	b.eq	416c1c <z_sched_waitq_walk+0xac>  // b.none
  416ca4:	f9400294 	ldr	x20, [x20]
  416ca8:	17fffff6 	b	416c80 <z_sched_waitq_walk+0x110>
	posix_irq_unlock(key);
  416cac:	2a1703e0 	mov	w0, w23
  416cb0:	97ffc966 	bl	409248 <posix_irq_unlock>
			}
		}
	}

	return status;
}
  416cb4:	2a1503e0 	mov	w0, w21
  416cb8:	a94153f3 	ldp	x19, x20, [sp, #16]
  416cbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  416cc0:	a94363f7 	ldp	x23, x24, [sp, #48]
  416cc4:	f94023f9 	ldr	x25, [sp, #64]
  416cc8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  416ccc:	d65f03c0 	ret

0000000000416cd0 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
  416cd0:	d00000e0 	adrp	x0, 434000 <ztest_thread+0xb8>
  416cd4:	b94e2000 	ldr	w0, [x0, #3616]
  416cd8:	35000040 	cbnz	w0, 416ce0 <elapsed+0x10>
  416cdc:	17ffd6c6 	b	40c7f4 <sys_clock_elapsed>
}
  416ce0:	52800000 	mov	w0, #0x0                   	// #0
  416ce4:	d65f03c0 	ret

0000000000416ce8 <next_timeout>:

static int32_t next_timeout(void)
{
  416ce8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
  416cec:	900000e0 	adrp	x0, 432000 <__dso_handle>
  416cf0:	91286001 	add	x1, x0, #0xa18
  416cf4:	910003fd 	mov	x29, sp
  416cf8:	f9000bf3 	str	x19, [sp, #16]
  416cfc:	f9450c13 	ldr	x19, [x0, #2584]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  416d00:	eb01027f 	cmp	x19, x1
  416d04:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
  416d08:	97fffff2 	bl	416cd0 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
  416d0c:	b4000173 	cbz	x19, 416d38 <next_timeout+0x50>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
  416d10:	f9400e61 	ldr	x1, [x19, #24]
  416d14:	cb20c021 	sub	x1, x1, w0, sxtw
	if ((to == NULL) ||
  416d18:	b2407be0 	mov	x0, #0x7fffffff            	// #2147483647
  416d1c:	eb00003f 	cmp	x1, x0
  416d20:	5400006c 	b.gt	416d2c <next_timeout+0x44>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
  416d24:	f100003f 	cmp	x1, #0x0
  416d28:	9a9fa020 	csel	x0, x1, xzr, ge  // ge = tcont
	}

	return ret;
}
  416d2c:	f9400bf3 	ldr	x19, [sp, #16]
  416d30:	a8c27bfd 	ldp	x29, x30, [sp], #32
  416d34:	d65f03c0 	ret
		ret = MAX_WAIT;
  416d38:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
  416d3c:	17fffffc 	b	416d2c <next_timeout+0x44>

0000000000416d40 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
  416d40:	b4000160 	cbz	x0, 416d6c <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
  416d44:	900000e1 	adrp	x1, 432000 <__dso_handle>
  416d48:	f9451021 	ldr	x1, [x1, #2592]
  416d4c:	eb01001f 	cmp	x0, x1
  416d50:	540000e0 	b.eq	416d6c <remove_timeout+0x2c>  // b.none
  416d54:	f9400001 	ldr	x1, [x0]
	if (next(t) != NULL) {
  416d58:	b40000a1 	cbz	x1, 416d6c <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
  416d5c:	f9400c03 	ldr	x3, [x0, #24]
  416d60:	f9400c22 	ldr	x2, [x1, #24]
  416d64:	8b030042 	add	x2, x2, x3
  416d68:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
  416d6c:	a9400801 	ldp	x1, x2, [x0]
	prev->next = next;
  416d70:	f9000041 	str	x1, [x2]
	next->prev = prev;
  416d74:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
  416d78:	a9007c1f 	stp	xzr, xzr, [x0]
}
  416d7c:	d65f03c0 	ret

0000000000416d80 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  416d80:	b100045f 	cmn	x2, #0x1
  416d84:	54001200 	b.eq	416fc4 <z_add_timeout+0x244>  // b.none
{
  416d88:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  416d8c:	910003fd 	mov	x29, sp
  416d90:	a90153f3 	stp	x19, x20, [sp, #16]
  416d94:	aa0003f3 	mov	x19, x0
  416d98:	a9025bf5 	stp	x21, x22, [sp, #32]
  416d9c:	f9001bf7 	str	x23, [sp, #48]

#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
  416da0:	f9400000 	ldr	x0, [x0]
  416da4:	b40002a0 	cbz	x0, 416df8 <z_add_timeout+0x78>
  416da8:	90000033 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  416dac:	91225273 	add	x19, x19, #0x894
  416db0:	aa1303e2 	mov	x2, x19
  416db4:	90000021 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  416db8:	9122e021 	add	x1, x1, #0x8b8
  416dbc:	52800bc3 	mov	w3, #0x5e                  	// #94
  416dc0:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416dc4:	91178000 	add	x0, x0, #0x5e0
  416dc8:	97ffc018 	bl	406e28 <assert_print>
  416dcc:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416dd0:	912e6c00 	add	x0, x0, #0xb9b
  416dd4:	97ffc015 	bl	406e28 <assert_print>
  416dd8:	aa1303e0 	mov	x0, x19
  416ddc:	52800bc1 	mov	w1, #0x5e                  	// #94
  416de0:	97ffc03c 	bl	406ed0 <assert_post_action>
  416de4:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416de8:	aa1303e1 	mov	x1, x19
  416dec:	91187800 	add	x0, x0, #0x61e
  416df0:	52800bc2 	mov	w2, #0x5e                  	// #94
  416df4:	97ffca29 	bl	409698 <posix_print_error_and_exit>
	to->fn = fn;
  416df8:	f9000a61 	str	x1, [x19, #16]
  416dfc:	aa0203f4 	mov	x20, x2
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  416e00:	d00000f5 	adrp	x21, 434000 <ztest_thread+0xb8>
  416e04:	912242b7 	add	x23, x21, #0x890
	return posix_irq_lock();
  416e08:	97ffc90e 	bl	409240 <posix_irq_lock>
  416e0c:	2a0003f6 	mov	w22, w0
  416e10:	aa1703e0 	mov	x0, x23
  416e14:	97ffedb2 	bl	4124dc <z_spin_lock_valid>
  416e18:	72001c1f 	tst	w0, #0xff
  416e1c:	540002c1 	b.ne	416e74 <z_add_timeout+0xf4>  // b.any
  416e20:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  416e24:	912c1273 	add	x19, x19, #0xb04
  416e28:	aa1303e2 	mov	x2, x19
  416e2c:	52801283 	mov	w3, #0x94                  	// #148
  416e30:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416e34:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416e38:	912cc421 	add	x1, x1, #0xb31
  416e3c:	91178000 	add	x0, x0, #0x5e0
  416e40:	97ffbffa 	bl	406e28 <assert_print>
  416e44:	aa1703e1 	mov	x1, x23
  416e48:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416e4c:	912d1800 	add	x0, x0, #0xb46
  416e50:	97ffbff6 	bl	406e28 <assert_print>
  416e54:	aa1303e0 	mov	x0, x19
  416e58:	52801281 	mov	w1, #0x94                  	// #148
  416e5c:	97ffc01d 	bl	406ed0 <assert_post_action>
  416e60:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416e64:	aa1303e1 	mov	x1, x19
  416e68:	91187800 	add	x0, x0, #0x61e
  416e6c:	52801282 	mov	w2, #0x94                  	// #148
  416e70:	97ffca0a 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  416e74:	aa1703e0 	mov	x0, x23
  416e78:	97ffedb1 	bl	41253c <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
  416e7c:	b1000a9f 	cmn	x20, #0x2
  416e80:	5400028c 	b.gt	416ed0 <z_add_timeout+0x150>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
  416e84:	d00000e0 	adrp	x0, 434000 <ztest_thread+0xb8>
  416e88:	92800023 	mov	x3, #0xfffffffffffffffe    	// #-2
  416e8c:	f9444400 	ldr	x0, [x0, #2184]
  416e90:	cb000063 	sub	x3, x3, x0
  416e94:	cb140062 	sub	x2, x3, x20

			to->dticks = MAX(1, ticks);
  416e98:	f100005f 	cmp	x2, #0x0
  416e9c:	9a9fc442 	csinc	x2, x2, xzr, gt
	return list->head == list;
  416ea0:	900000e0 	adrp	x0, 432000 <__dso_handle>
  416ea4:	91286001 	add	x1, x0, #0xa18
  416ea8:	f9000e62 	str	x2, [x19, #24]
  416eac:	f9450c02 	ldr	x2, [x0, #2584]
	sys_dnode_t *const tail = list->tail;
  416eb0:	f9400424 	ldr	x4, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  416eb4:	eb01005f 	cmp	x2, x1
  416eb8:	540001e1 	b.ne	416ef4 <z_add_timeout+0x174>  // b.any
	node->next = list;
  416ebc:	91286001 	add	x1, x0, #0xa18
	node->prev = tail;
  416ec0:	a9001261 	stp	x1, x4, [x19]
	tail->next = node;
  416ec4:	f9000093 	str	x19, [x4]
	list->tail = node;
  416ec8:	f9000433 	str	x19, [x1, #8]
}
  416ecc:	14000015 	b	416f20 <z_add_timeout+0x1a0>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
  416ed0:	91000694 	add	x20, x20, #0x1
  416ed4:	97ffff7f 	bl	416cd0 <elapsed>
  416ed8:	8b20c282 	add	x2, x20, w0, sxtw
  416edc:	17fffff1 	b	416ea0 <z_add_timeout+0x120>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
  416ee0:	cb030021 	sub	x1, x1, x3
  416ee4:	f9000e61 	str	x1, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
  416ee8:	eb02009f 	cmp	x4, x2
  416eec:	54fffe80 	b.eq	416ebc <z_add_timeout+0x13c>  // b.none
  416ef0:	f9400042 	ldr	x2, [x2]
		for (t = first(); t != NULL; t = next(t)) {
  416ef4:	b4fffe42 	cbz	x2, 416ebc <z_add_timeout+0x13c>
			if (t->dticks > to->dticks) {
  416ef8:	f9400c43 	ldr	x3, [x2, #24]
  416efc:	f9400e61 	ldr	x1, [x19, #24]
  416f00:	eb01007f 	cmp	x3, x1
  416f04:	54fffeed 	b.le	416ee0 <z_add_timeout+0x160>
				t->dticks -= to->dticks;
  416f08:	cb010063 	sub	x3, x3, x1
  416f0c:	f9000c43 	str	x3, [x2, #24]
	sys_dnode_t *const prev = successor->prev;
  416f10:	f9400441 	ldr	x1, [x2, #8]
	node->prev = prev;
  416f14:	a9000662 	stp	x2, x1, [x19]
	prev->next = node;
  416f18:	f9000033 	str	x19, [x1]
	successor->prev = node;
  416f1c:	f9000453 	str	x19, [x2, #8]
	return list->head == list;
  416f20:	91286001 	add	x1, x0, #0xa18
  416f24:	f9450c00 	ldr	x0, [x0, #2584]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  416f28:	eb01001f 	cmp	x0, x1
  416f2c:	540000c0 	b.eq	416f44 <z_add_timeout+0x1c4>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
  416f30:	eb00027f 	cmp	x19, x0
  416f34:	54000081 	b.ne	416f44 <z_add_timeout+0x1c4>  // b.any
			sys_clock_set_timeout(next_timeout(), false);
  416f38:	97ffff6c 	bl	416ce8 <next_timeout>
  416f3c:	52800001 	mov	w1, #0x0                   	// #0
  416f40:	97ffd624 	bl	40c7d0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  416f44:	912242b5 	add	x21, x21, #0x890
  416f48:	aa1503e0 	mov	x0, x21
  416f4c:	97ffed6f 	bl	412508 <z_spin_unlock_valid>
  416f50:	72001c1f 	tst	w0, #0xff
  416f54:	540002c1 	b.ne	416fac <z_add_timeout+0x22c>  // b.any
  416f58:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  416f5c:	912c1273 	add	x19, x19, #0xb04
  416f60:	aa1303e2 	mov	x2, x19
  416f64:	52801863 	mov	w3, #0xc3                  	// #195
  416f68:	f0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  416f6c:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416f70:	912d7821 	add	x1, x1, #0xb5e
  416f74:	91178000 	add	x0, x0, #0x5e0
  416f78:	97ffbfac 	bl	406e28 <assert_print>
  416f7c:	aa1503e1 	mov	x1, x21
  416f80:	f0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  416f84:	912dd400 	add	x0, x0, #0xb75
  416f88:	97ffbfa8 	bl	406e28 <assert_print>
  416f8c:	aa1303e0 	mov	x0, x19
  416f90:	52801861 	mov	w1, #0xc3                  	// #195
  416f94:	97ffbfcf 	bl	406ed0 <assert_post_action>
  416f98:	d0000000 	adrp	x0, 418000 <table.0+0x1d8>
  416f9c:	aa1303e1 	mov	x1, x19
  416fa0:	91187800 	add	x0, x0, #0x61e
  416fa4:	52801862 	mov	w2, #0xc3                  	// #195
  416fa8:	97ffc9bc 	bl	409698 <posix_print_error_and_exit>
	posix_irq_unlock(key);
  416fac:	2a1603e0 	mov	w0, w22
		}
	}
}
  416fb0:	a94153f3 	ldp	x19, x20, [sp, #16]
  416fb4:	a9425bf5 	ldp	x21, x22, [sp, #32]
  416fb8:	f9401bf7 	ldr	x23, [sp, #48]
  416fbc:	a8c47bfd 	ldp	x29, x30, [sp], #64
  416fc0:	17ffc8a2 	b	409248 <posix_irq_unlock>
  416fc4:	d65f03c0 	ret

0000000000416fc8 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
  416fc8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  416fcc:	910003fd 	mov	x29, sp
  416fd0:	a90153f3 	stp	x19, x20, [sp, #16]
  416fd4:	aa0003f4 	mov	x20, x0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  416fd8:	d00000f3 	adrp	x19, 434000 <ztest_thread+0xb8>
  416fdc:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  416fe0:	97ffc898 	bl	409240 <posix_irq_lock>
  416fe4:	91224276 	add	x22, x19, #0x890
  416fe8:	2a0003f5 	mov	w21, w0
  416fec:	aa1603e0 	mov	x0, x22
  416ff0:	97ffed3b 	bl	4124dc <z_spin_lock_valid>
  416ff4:	72001c1f 	tst	w0, #0xff
  416ff8:	540002c1 	b.ne	417050 <z_abort_timeout+0x88>  // b.any
  416ffc:	f0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  417000:	912c1273 	add	x19, x19, #0xb04
  417004:	aa1303e2 	mov	x2, x19
  417008:	52801283 	mov	w3, #0x94                  	// #148
  41700c:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  417010:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417014:	912cc421 	add	x1, x1, #0xb31
  417018:	91178000 	add	x0, x0, #0x5e0
  41701c:	97ffbf83 	bl	406e28 <assert_print>
  417020:	aa1603e1 	mov	x1, x22
  417024:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  417028:	912d1800 	add	x0, x0, #0xb46
  41702c:	97ffbf7f 	bl	406e28 <assert_print>
  417030:	aa1303e0 	mov	x0, x19
  417034:	52801281 	mov	w1, #0x94                  	// #148
  417038:	97ffbfa6 	bl	406ed0 <assert_post_action>
  41703c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  417040:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417044:	aa1303e1 	mov	x1, x19
  417048:	91187800 	add	x0, x0, #0x61e
  41704c:	97ffc993 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  417050:	aa1603e0 	mov	x0, x22
  417054:	97ffed3a 	bl	41253c <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
  417058:	f9400280 	ldr	x0, [x20]
  41705c:	b4000360 	cbz	x0, 4170c8 <z_abort_timeout+0x100>
			remove_timeout(to);
			ret = 0;
  417060:	52800016 	mov	w22, #0x0                   	// #0
			remove_timeout(to);
  417064:	aa1403e0 	mov	x0, x20
  417068:	97ffff36 	bl	416d40 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41706c:	91224274 	add	x20, x19, #0x890
  417070:	aa1403e0 	mov	x0, x20
  417074:	97ffed25 	bl	412508 <z_spin_unlock_valid>
  417078:	72001c1f 	tst	w0, #0xff
  41707c:	540002a1 	b.ne	4170d0 <z_abort_timeout+0x108>  // b.any
  417080:	d0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  417084:	912c1273 	add	x19, x19, #0xb04
  417088:	aa1303e2 	mov	x2, x19
  41708c:	52801863 	mov	w3, #0xc3                  	// #195
  417090:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  417094:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417098:	912d7821 	add	x1, x1, #0xb5e
  41709c:	91178000 	add	x0, x0, #0x5e0
  4170a0:	97ffbf62 	bl	406e28 <assert_print>
  4170a4:	aa1403e1 	mov	x1, x20
  4170a8:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  4170ac:	912dd400 	add	x0, x0, #0xb75
  4170b0:	97ffbf5e 	bl	406e28 <assert_print>
  4170b4:	aa1303e0 	mov	x0, x19
  4170b8:	52801861 	mov	w1, #0xc3                  	// #195
  4170bc:	97ffbf85 	bl	406ed0 <assert_post_action>
  4170c0:	52801862 	mov	w2, #0xc3                  	// #195
  4170c4:	17ffffdf 	b	417040 <z_abort_timeout+0x78>
	int ret = -EINVAL;
  4170c8:	128002b6 	mov	w22, #0xffffffea            	// #-22
  4170cc:	17ffffe8 	b	41706c <z_abort_timeout+0xa4>
	posix_irq_unlock(key);
  4170d0:	2a1503e0 	mov	w0, w21
  4170d4:	97ffc85d 	bl	409248 <posix_irq_unlock>
		}
	}

	return ret;
}
  4170d8:	2a1603e0 	mov	w0, w22
  4170dc:	a94153f3 	ldp	x19, x20, [sp, #16]
  4170e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4170e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4170e8:	d65f03c0 	ret

00000000004170ec <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
  4170ec:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  4170f0:	910003fd 	mov	x29, sp
  4170f4:	a90153f3 	stp	x19, x20, [sp, #16]
  4170f8:	2a0003f3 	mov	w19, w0
  4170fc:	a9025bf5 	stp	x21, x22, [sp, #32]
  417100:	a90363f7 	stp	x23, x24, [sp, #48]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  417104:	b00000f7 	adrp	x23, 434000 <ztest_thread+0xb8>
  417108:	912242f6 	add	x22, x23, #0x890
  41710c:	a9046bf9 	stp	x25, x26, [sp, #64]
  417110:	f9002bfb 	str	x27, [sp, #80]
	return posix_irq_lock();
  417114:	97ffc84b 	bl	409240 <posix_irq_lock>
  417118:	2a0003f4 	mov	w20, w0
  41711c:	aa1603e0 	mov	x0, x22
  417120:	97ffecef 	bl	4124dc <z_spin_lock_valid>
  417124:	72001c1f 	tst	w0, #0xff
  417128:	540002c1 	b.ne	417180 <sys_clock_announce+0x94>  // b.any
  41712c:	d0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  417130:	912c1273 	add	x19, x19, #0xb04
  417134:	aa1303e2 	mov	x2, x19
  417138:	52801283 	mov	w3, #0x94                  	// #148
  41713c:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  417140:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417144:	912cc421 	add	x1, x1, #0xb31
  417148:	91178000 	add	x0, x0, #0x5e0
  41714c:	97ffbf37 	bl	406e28 <assert_print>
  417150:	912242e1 	add	x1, x23, #0x890
  417154:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  417158:	912d1800 	add	x0, x0, #0xb46
  41715c:	97ffbf33 	bl	406e28 <assert_print>
  417160:	aa1303e0 	mov	x0, x19
  417164:	52801281 	mov	w1, #0x94                  	// #148
  417168:	97ffbf5a 	bl	406ed0 <assert_post_action>
  41716c:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  417170:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417174:	aa1303e1 	mov	x1, x19
  417178:	91187800 	add	x0, x0, #0x61e
  41717c:	97ffc947 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  417180:	aa1603e0 	mov	x0, x22
  417184:	97ffecee 	bl	41253c <z_spin_lock_set_owner>
	return list->head == list;
  417188:	f00000c0 	adrp	x0, 432000 <__dso_handle>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
  41718c:	b00000f8 	adrp	x24, 434000 <ztest_thread+0xb8>
  417190:	9128601a 	add	x26, x0, #0xa18
  417194:	b00000f9 	adrp	x25, 434000 <ztest_thread+0xb8>
  417198:	b90e2313 	str	w19, [x24, #3616]
  41719c:	f9450c13 	ldr	x19, [x0, #2584]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4171a0:	eb1a027f 	cmp	x19, x26
  4171a4:	54000740 	b.eq	41728c <sys_clock_announce+0x1a0>  // b.none

	struct _timeout *t = first();

	for (t = first();
	     (t != NULL) && (t->dticks <= announce_remaining);
  4171a8:	9138831b 	add	x27, x24, #0xe20
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
  4171ac:	f9444720 	ldr	x0, [x25, #2184]
	     (t != NULL) && (t->dticks <= announce_remaining);
  4171b0:	b9400361 	ldr	w1, [x27]
  4171b4:	b40006d3 	cbz	x19, 41728c <sys_clock_announce+0x1a0>
  4171b8:	f9400e75 	ldr	x21, [x19, #24]
  4171bc:	93407c22 	sxtw	x2, w1
  4171c0:	eb21c2bf 	cmp	x21, w1, sxtw
  4171c4:	5400008d 	b.le	4171d4 <sys_clock_announce+0xe8>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
  4171c8:	cb0202b5 	sub	x21, x21, x2
  4171cc:	f9000e75 	str	x21, [x19, #24]
  4171d0:	1400002f 	b	41728c <sys_clock_announce+0x1a0>
		t->dticks = 0;
  4171d4:	f9000e7f 	str	xzr, [x19, #24]
		curr_tick += dt;
  4171d8:	8b35c000 	add	x0, x0, w21, sxtw
  4171dc:	f9044720 	str	x0, [x25, #2184]
		remove_timeout(t);
  4171e0:	aa1303e0 	mov	x0, x19
  4171e4:	97fffed7 	bl	416d40 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4171e8:	aa1603e0 	mov	x0, x22
  4171ec:	97ffecc7 	bl	412508 <z_spin_unlock_valid>
  4171f0:	72001c1f 	tst	w0, #0xff
  4171f4:	54000261 	b.ne	417240 <sys_clock_announce+0x154>  // b.any
  4171f8:	d0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  4171fc:	912c1273 	add	x19, x19, #0xb04
  417200:	aa1303e2 	mov	x2, x19
  417204:	52801863 	mov	w3, #0xc3                  	// #195
  417208:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  41720c:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417210:	912d7821 	add	x1, x1, #0xb5e
  417214:	91178000 	add	x0, x0, #0x5e0
  417218:	97ffbf04 	bl	406e28 <assert_print>
  41721c:	912242e1 	add	x1, x23, #0x890
  417220:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  417224:	912dd400 	add	x0, x0, #0xb75
  417228:	97ffbf00 	bl	406e28 <assert_print>
  41722c:	aa1303e0 	mov	x0, x19
  417230:	52801861 	mov	w1, #0xc3                  	// #195
  417234:	97ffbf27 	bl	406ed0 <assert_post_action>
  417238:	52801862 	mov	w2, #0xc3                  	// #195
  41723c:	17ffffcd 	b	417170 <sys_clock_announce+0x84>
	posix_irq_unlock(key);
  417240:	2a1403e0 	mov	w0, w20
  417244:	97ffc801 	bl	409248 <posix_irq_unlock>
		t->fn(t);
  417248:	f9400a61 	ldr	x1, [x19, #16]
  41724c:	aa1303e0 	mov	x0, x19
  417250:	d63f0020 	blr	x1
	return posix_irq_lock();
  417254:	97ffc7fb 	bl	409240 <posix_irq_lock>
  417258:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  41725c:	aa1603e0 	mov	x0, x22
  417260:	97ffec9f 	bl	4124dc <z_spin_lock_valid>
  417264:	72001c1f 	tst	w0, #0xff
  417268:	54fff620 	b.eq	41712c <sys_clock_announce+0x40>  // b.none
	z_spin_lock_set_owner(l);
  41726c:	aa1603e0 	mov	x0, x22
  417270:	97ffecb3 	bl	41253c <z_spin_lock_set_owner>
		announce_remaining -= dt;
  417274:	b9400360 	ldr	w0, [x27]
	return list->head == list;
  417278:	f9400353 	ldr	x19, [x26]
  41727c:	4b150000 	sub	w0, w0, w21
  417280:	b9000360 	str	w0, [x27]
	return sys_dlist_is_empty(list) ? NULL : list->head;
  417284:	eb1a027f 	cmp	x19, x26
  417288:	54fff921 	b.ne	4171ac <sys_clock_announce+0xc0>  // b.any
	}

	curr_tick += announce_remaining;
  41728c:	f9444721 	ldr	x1, [x25, #2184]
  417290:	b98e2300 	ldrsw	x0, [x24, #3616]
	announce_remaining = 0;
  417294:	b90e231f 	str	wzr, [x24, #3616]
	curr_tick += announce_remaining;
  417298:	8b010000 	add	x0, x0, x1
  41729c:	f9044720 	str	x0, [x25, #2184]

	sys_clock_set_timeout(next_timeout(), false);
  4172a0:	97fffe92 	bl	416ce8 <next_timeout>
  4172a4:	52800001 	mov	w1, #0x0                   	// #0
  4172a8:	97ffd54a 	bl	40c7d0 <sys_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4172ac:	912242e0 	add	x0, x23, #0x890
  4172b0:	97ffec96 	bl	412508 <z_spin_unlock_valid>
  4172b4:	72001c1f 	tst	w0, #0xff
  4172b8:	54fffa00 	b.eq	4171f8 <sys_clock_announce+0x10c>  // b.none
	posix_irq_unlock(key);
  4172bc:	2a1403e0 	mov	w0, w20
  4172c0:	97ffc7e2 	bl	409248 <posix_irq_unlock>
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
  4172c4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4172c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4172cc:	a94363f7 	ldp	x23, x24, [sp, #48]
  4172d0:	a9446bf9 	ldp	x25, x26, [sp, #64]
  4172d4:	f9402bfb 	ldr	x27, [sp, #80]
  4172d8:	a8c67bfd 	ldp	x29, x30, [sp], #96
	z_time_slice();
  4172dc:	17fff6e9 	b	414e80 <z_time_slice>

00000000004172e0 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
  4172e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  4172e4:	910003fd 	mov	x29, sp
  4172e8:	a90153f3 	stp	x19, x20, [sp, #16]
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4172ec:	b00000f3 	adrp	x19, 434000 <ztest_thread+0xb8>
  4172f0:	91224273 	add	x19, x19, #0x890
  4172f4:	f90013f5 	str	x21, [sp, #32]
	return posix_irq_lock();
  4172f8:	97ffc7d2 	bl	409240 <posix_irq_lock>
  4172fc:	2a0003f5 	mov	w21, w0
  417300:	aa1303e0 	mov	x0, x19
  417304:	97ffec76 	bl	4124dc <z_spin_lock_valid>
  417308:	72001c1f 	tst	w0, #0xff
  41730c:	540002c1 	b.ne	417364 <sys_clock_tick_get+0x84>  // b.any
  417310:	d0000014 	adrp	x20, 419000 <__func__.2+0xa80>
  417314:	912c1294 	add	x20, x20, #0xb04
  417318:	aa1403e2 	mov	x2, x20
  41731c:	52801283 	mov	w3, #0x94                  	// #148
  417320:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  417324:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417328:	912cc421 	add	x1, x1, #0xb31
  41732c:	91178000 	add	x0, x0, #0x5e0
  417330:	97ffbebe 	bl	406e28 <assert_print>
  417334:	aa1303e1 	mov	x1, x19
  417338:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  41733c:	912d1800 	add	x0, x0, #0xb46
  417340:	97ffbeba 	bl	406e28 <assert_print>
  417344:	aa1403e0 	mov	x0, x20
  417348:	52801281 	mov	w1, #0x94                  	// #148
  41734c:	97ffbee1 	bl	406ed0 <assert_post_action>
  417350:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  417354:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417358:	aa1403e1 	mov	x1, x20
  41735c:	91187800 	add	x0, x0, #0x61e
  417360:	97ffc8ce 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  417364:	aa1303e0 	mov	x0, x19
  417368:	97ffec75 	bl	41253c <z_spin_lock_set_owner>
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
  41736c:	97fffe59 	bl	416cd0 <elapsed>
  417370:	b00000e1 	adrp	x1, 434000 <ztest_thread+0xb8>
  417374:	f9444421 	ldr	x1, [x1, #2184]
  417378:	8b20c034 	add	x20, x1, w0, sxtw
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  41737c:	aa1303e0 	mov	x0, x19
  417380:	97ffec62 	bl	412508 <z_spin_unlock_valid>
  417384:	72001c1f 	tst	w0, #0xff
  417388:	54000261 	b.ne	4173d4 <sys_clock_tick_get+0xf4>  // b.any
  41738c:	d0000014 	adrp	x20, 419000 <__func__.2+0xa80>
  417390:	912c1294 	add	x20, x20, #0xb04
  417394:	aa1403e2 	mov	x2, x20
  417398:	52801863 	mov	w3, #0xc3                  	// #195
  41739c:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  4173a0:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4173a4:	912d7821 	add	x1, x1, #0xb5e
  4173a8:	91178000 	add	x0, x0, #0x5e0
  4173ac:	97ffbe9f 	bl	406e28 <assert_print>
  4173b0:	aa1303e1 	mov	x1, x19
  4173b4:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  4173b8:	912dd400 	add	x0, x0, #0xb75
  4173bc:	97ffbe9b 	bl	406e28 <assert_print>
  4173c0:	aa1403e0 	mov	x0, x20
  4173c4:	52801861 	mov	w1, #0xc3                  	// #195
  4173c8:	97ffbec2 	bl	406ed0 <assert_post_action>
  4173cc:	52801862 	mov	w2, #0xc3                  	// #195
  4173d0:	17ffffe1 	b	417354 <sys_clock_tick_get+0x74>
	posix_irq_unlock(key);
  4173d4:	2a1503e0 	mov	w0, w21
  4173d8:	97ffc79c 	bl	409248 <posix_irq_unlock>
	}
	return t;
}
  4173dc:	aa1403e0 	mov	x0, x20
  4173e0:	a94153f3 	ldp	x19, x20, [sp, #16]
  4173e4:	f94013f5 	ldr	x21, [sp, #32]
  4173e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  4173ec:	d65f03c0 	ret

00000000004173f0 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
  4173f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  4173f4:	910003fd 	mov	x29, sp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
  4173f8:	97ffffba 	bl	4172e0 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
  4173fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  417400:	d65f03c0 	ret

0000000000417404 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
  417404:	17ffffb7 	b	4172e0 <sys_clock_tick_get>

0000000000417408 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
  417408:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  41740c:	910003fd 	mov	x29, sp
  417410:	f9000bf3 	str	x19, [sp, #16]
  417414:	aa0003f3 	mov	x19, x0
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
  417418:	b100041f 	cmn	x0, #0x1
  41741c:	54000180 	b.eq	41744c <sys_clock_timeout_end_calc+0x44>  // b.none
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  417420:	b5000080 	cbnz	x0, 417430 <sys_clock_timeout_end_calc+0x28>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
  417424:	f9400bf3 	ldr	x19, [sp, #16]
  417428:	a8c27bfd 	ldp	x29, x30, [sp], #32
		return sys_clock_tick_get();
  41742c:	17ffffad 	b	4172e0 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
  417430:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
  417434:	eb130000 	subs	x0, x0, x19
  417438:	540000a5 	b.pl	41744c <sys_clock_timeout_end_calc+0x44>  // b.nfrst
		return sys_clock_tick_get() + MAX(1, dt);
  41743c:	97ffffa9 	bl	4172e0 <sys_clock_tick_get>
  417440:	f100027f 	cmp	x19, #0x0
  417444:	9a9fc673 	csinc	x19, x19, xzr, gt
  417448:	8b000260 	add	x0, x19, x0
}
  41744c:	f9400bf3 	ldr	x19, [sp, #16]
  417450:	a8c27bfd 	ldp	x29, x30, [sp], #32
  417454:	d65f03c0 	ret

0000000000417458 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
  417458:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  41745c:	910003fd 	mov	x29, sp
  417460:	a90153f3 	stp	x19, x20, [sp, #16]
  417464:	aa0003f3 	mov	x19, x0
  417468:	a9025bf5 	stp	x21, x22, [sp, #32]
	return posix_irq_lock();
  41746c:	97ffc775 	bl	409240 <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  417470:	b00000f6 	adrp	x22, 434000 <ztest_thread+0xb8>
  417474:	912262d5 	add	x21, x22, #0x898
  417478:	2a0003f4 	mov	w20, w0
  41747c:	aa1503e0 	mov	x0, x21
  417480:	97ffec17 	bl	4124dc <z_spin_lock_valid>
  417484:	72001c1f 	tst	w0, #0xff
  417488:	540002c1 	b.ne	4174e0 <z_timer_expiration_handler+0x88>  // b.any
  41748c:	d0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  417490:	912c1273 	add	x19, x19, #0xb04
  417494:	aa1303e2 	mov	x2, x19
  417498:	52801283 	mov	w3, #0x94                  	// #148
  41749c:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  4174a0:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4174a4:	912cc421 	add	x1, x1, #0xb31
  4174a8:	91178000 	add	x0, x0, #0x5e0
  4174ac:	97ffbe5f 	bl	406e28 <assert_print>
  4174b0:	912262c1 	add	x1, x22, #0x898
  4174b4:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  4174b8:	912d1800 	add	x0, x0, #0xb46
  4174bc:	97ffbe5b 	bl	406e28 <assert_print>
  4174c0:	aa1303e0 	mov	x0, x19
  4174c4:	52801281 	mov	w1, #0x94                  	// #148
  4174c8:	97ffbe82 	bl	406ed0 <assert_post_action>
  4174cc:	52801282 	mov	w2, #0x94                  	// #148
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4174d0:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4174d4:	aa1303e1 	mov	x1, x19
  4174d8:	91187800 	add	x0, x0, #0x61e
  4174dc:	97ffc86f 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  4174e0:	aa1503e0 	mov	x0, x21
  4174e4:	97ffec16 	bl	41253c <z_spin_lock_set_owner>
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
  4174e8:	f9400260 	ldr	x0, [x19]
  4174ec:	b40002e0 	cbz	x0, 417548 <z_timer_expiration_handler+0xf0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  4174f0:	aa1503e0 	mov	x0, x21
  4174f4:	97ffec05 	bl	412508 <z_spin_unlock_valid>
  4174f8:	72001c1f 	tst	w0, #0xff
  4174fc:	540008e1 	b.ne	417618 <z_timer_expiration_handler+0x1c0>  // b.any
  417500:	d0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  417504:	912c1273 	add	x19, x19, #0xb04
  417508:	aa1303e2 	mov	x2, x19
  41750c:	52801863 	mov	w3, #0xc3                  	// #195
  417510:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  417514:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417518:	912d7821 	add	x1, x1, #0xb5e
  41751c:	91178000 	add	x0, x0, #0x5e0
  417520:	97ffbe42 	bl	406e28 <assert_print>
  417524:	912262c1 	add	x1, x22, #0x898
  417528:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  41752c:	912dd400 	add	x0, x0, #0xb75
  417530:	97ffbe3e 	bl	406e28 <assert_print>
  417534:	aa1303e0 	mov	x0, x19
  417538:	52801861 	mov	w1, #0xc3                  	// #195
  41753c:	97ffbe65 	bl	406ed0 <assert_post_action>
  417540:	52801862 	mov	w2, #0xc3                  	// #195
  417544:	17ffffe3 	b	4174d0 <z_timer_expiration_handler+0x78>

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
  417548:	f9402260 	ldr	x0, [x19, #64]
  41754c:	91000401 	add	x1, x0, #0x1
  417550:	f100043f 	cmp	x1, #0x1
  417554:	54000249 	b.ls	41759c <z_timer_expiration_handler+0x144>  // b.plast
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		k_timeout_t next = timer->period;

		/* see note about z_add_timeout() in z_impl_k_timer_start() */
		next.ticks = MAX(next.ticks - 1, 0);
  417558:	f100001f 	cmp	x0, #0x0
  41755c:	9a9fc400 	csinc	x0, x0, xzr, gt
  417560:	d1000415 	sub	x21, x0, #0x1
	return z_impl_k_uptime_ticks();
  417564:	97ffffa8 	bl	417404 <z_impl_k_uptime_ticks>
		 * we "should" have run.  Requires absolute timeouts.
		 * (Note offset by one: we're nominally at the
		 * beginning of a tick, so need to defeat the "round
		 * down" behavior on timeout addition).
		 */
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
  417568:	91000400 	add	x0, x0, #0x1
  41756c:	8b150000 	add	x0, x0, x21
  417570:	f100001f 	cmp	x0, #0x0
  417574:	540004ed 	b.le	417610 <z_timer_expiration_handler+0x1b8>
  417578:	97ffffa3 	bl	417404 <z_impl_k_uptime_ticks>
  41757c:	91000400 	add	x0, x0, #0x1
  417580:	8b150000 	add	x0, x0, x21
  417584:	92800022 	mov	x2, #0xfffffffffffffffe    	// #-2
  417588:	cb000042 	sub	x2, x2, x0
#endif
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  41758c:	d00000c1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
  417590:	aa1303e0 	mov	x0, x19
  417594:	f947dc21 	ldr	x1, [x1, #4024]
  417598:	97fffdfa 	bl	416d80 <z_add_timeout>
			      next);
	}

	/* update timer's status */
	timer->status += 1U;
  41759c:	b9404a60 	ldr	w0, [x19, #72]
  4175a0:	11000400 	add	w0, w0, #0x1
  4175a4:	b9004a60 	str	w0, [x19, #72]

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
  4175a8:	f9401a60 	ldr	x0, [x19, #48]
  4175ac:	b4000260 	cbz	x0, 4175f8 <z_timer_expiration_handler+0x1a0>
  4175b0:	912262d5 	add	x21, x22, #0x898
  4175b4:	aa1503e0 	mov	x0, x21
  4175b8:	97ffebd4 	bl	412508 <z_spin_unlock_valid>
  4175bc:	72001c1f 	tst	w0, #0xff
  4175c0:	54fffa00 	b.eq	417500 <z_timer_expiration_handler+0xa8>  // b.none
	posix_irq_unlock(key);
  4175c4:	2a1403e0 	mov	w0, w20
  4175c8:	97ffc720 	bl	409248 <posix_irq_unlock>
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
  4175cc:	f9401a61 	ldr	x1, [x19, #48]
  4175d0:	aa1303e0 	mov	x0, x19
  4175d4:	d63f0020 	blr	x1
	return posix_irq_lock();
  4175d8:	97ffc71a 	bl	409240 <posix_irq_lock>
  4175dc:	2a0003f4 	mov	w20, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4175e0:	aa1503e0 	mov	x0, x21
  4175e4:	97ffebbe 	bl	4124dc <z_spin_lock_valid>
  4175e8:	72001c1f 	tst	w0, #0xff
  4175ec:	54fff500 	b.eq	41748c <z_timer_expiration_handler+0x34>  // b.none
	z_spin_lock_set_owner(l);
  4175f0:	aa1503e0 	mov	x0, x21
  4175f4:	97ffebd2 	bl	41253c <z_spin_lock_set_owner>
	return list->head == list;
  4175f8:	f8420e75 	ldr	x21, [x19, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
  4175fc:	eb1302bf 	cmp	x21, x19
  417600:	54000040 	b.eq	417608 <z_timer_expiration_handler+0x1b0>  // b.none
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
  417604:	b5000155 	cbnz	x21, 41762c <z_timer_expiration_handler+0x1d4>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  417608:	912262c0 	add	x0, x22, #0x898
  41760c:	17ffffba 	b	4174f4 <z_timer_expiration_handler+0x9c>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
  417610:	92800022 	mov	x2, #0xfffffffffffffffe    	// #-2
  417614:	17ffffde 	b	41758c <z_timer_expiration_handler+0x134>
	posix_irq_unlock(key);
  417618:	2a1403e0 	mov	w0, w20
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
  41761c:	a94153f3 	ldp	x19, x20, [sp, #16]
  417620:	a9425bf5 	ldp	x21, x22, [sp, #32]
  417624:	a8c37bfd 	ldp	x29, x30, [sp], #48
  417628:	17ffc708 	b	409248 <posix_irq_unlock>
	z_unpend_thread_no_timeout(thread);
  41762c:	aa1503e0 	mov	x0, x21
  417630:	97fff40e 	bl	414668 <z_unpend_thread_no_timeout>
  417634:	b9004ebf 	str	wzr, [x21, #76]
  417638:	912262c0 	add	x0, x22, #0x898
  41763c:	97ffebb3 	bl	412508 <z_spin_unlock_valid>
  417640:	72001c1f 	tst	w0, #0xff
  417644:	54fff5e0 	b.eq	417500 <z_timer_expiration_handler+0xa8>  // b.none
  417648:	2a1403e0 	mov	w0, w20
  41764c:	97ffc6ff 	bl	409248 <posix_irq_unlock>
	z_ready_thread(thread);
  417650:	aa1503e0 	mov	x0, x21
}
  417654:	a94153f3 	ldp	x19, x20, [sp, #16]
  417658:	a9425bf5 	ldp	x21, x22, [sp, #32]
  41765c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_ready_thread(thread);
  417660:	17fff6a2 	b	4150e8 <z_ready_thread>

0000000000417664 <k_timer_init>:
	node->prev = NULL;
  417664:	a9007c1f 	stp	xzr, xzr, [x0]
void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
	timer->stop_fn = stop_fn;
  417668:	a9030801 	stp	x1, x2, [x0, #48]
	sys_dlist_init(&w->waitq);
  41766c:	91008001 	add	x1, x0, #0x20
	list->tail = (sys_dnode_t *)list;
  417670:	a9020401 	stp	x1, x1, [x0, #32]
	timer->status = 0U;
  417674:	b900481f 	str	wzr, [x0, #72]

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
  417678:	f900281f 	str	xzr, [x0, #80]

	z_object_init(timer);
}
  41767c:	d65f03c0 	ret

0000000000417680 <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
  417680:	b100043f 	cmn	x1, #0x1
  417684:	54000320 	b.eq	4176e8 <z_impl_k_timer_start+0x68>  // b.none
{
  417688:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  41768c:	910003fd 	mov	x29, sp
  417690:	a90153f3 	stp	x19, x20, [sp, #16]
  417694:	aa0003f4 	mov	x20, x0
  417698:	aa0103f3 	mov	x19, x1
  41769c:	f90013f5 	str	x21, [sp, #32]
  4176a0:	aa0203f5 	mov	x21, x2
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
  4176a4:	b100083f 	cmn	x1, #0x2
  4176a8:	5400008d 	b.le	4176b8 <z_impl_k_timer_start+0x38>
		duration.ticks = MAX(duration.ticks - 1, 0);
  4176ac:	f100003f 	cmp	x1, #0x0
  4176b0:	9a9fc433 	csinc	x19, x1, xzr, gt
  4176b4:	d1000673 	sub	x19, x19, #0x1
	}

	(void)z_abort_timeout(&timer->timeout);
  4176b8:	aa1403e0 	mov	x0, x20
  4176bc:	97fffe43 	bl	416fc8 <z_abort_timeout>
	timer->period = period;
  4176c0:	f9002295 	str	x21, [x20, #64]
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  4176c4:	aa1303e2 	mov	x2, x19
	timer->status = 0U;
  4176c8:	b9004a9f 	str	wzr, [x20, #72]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  4176cc:	aa1403e0 	mov	x0, x20
  4176d0:	d00000c1 	adrp	x1, 431000 <__FRAME_END__+0x10804>
		     duration);
}
  4176d4:	a94153f3 	ldp	x19, x20, [sp, #16]
  4176d8:	f94013f5 	ldr	x21, [sp, #32]
  4176dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
  4176e0:	f947dc21 	ldr	x1, [x1, #4024]
  4176e4:	17fffda7 	b	416d80 <z_add_timeout>
  4176e8:	d65f03c0 	ret

00000000004176ec <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
  4176ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
  4176f0:	910003fd 	mov	x29, sp
  4176f4:	f9000bf3 	str	x19, [sp, #16]
  4176f8:	aa0003f3 	mov	x19, x0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
  4176fc:	97fffe33 	bl	416fc8 <z_abort_timeout>

	if (inactive) {
  417700:	350001a0 	cbnz	w0, 417734 <z_impl_k_timer_stop+0x48>
		return;
	}

	if (timer->stop_fn != NULL) {
  417704:	f9401e61 	ldr	x1, [x19, #56]
  417708:	b4000061 	cbz	x1, 417714 <z_impl_k_timer_stop+0x28>
		timer->stop_fn(timer);
  41770c:	aa1303e0 	mov	x0, x19
  417710:	d63f0020 	blr	x1
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
  417714:	91008260 	add	x0, x19, #0x20
  417718:	97fff97d 	bl	415d0c <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
  41771c:	b40000c0 	cbz	x0, 417734 <z_impl_k_timer_stop+0x48>
			z_ready_thread(pending_thread);
  417720:	97fff672 	bl	4150e8 <z_ready_thread>
	return posix_irq_lock();
  417724:	97ffc6c7 	bl	409240 <posix_irq_lock>
			z_reschedule_unlocked();
		}
	}
}
  417728:	f9400bf3 	ldr	x19, [sp, #16]
  41772c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	(void) z_reschedule_irqlock(arch_irq_lock());
  417730:	17fff457 	b	41488c <z_reschedule_irqlock>
  417734:	f9400bf3 	ldr	x19, [sp, #16]
  417738:	a8c27bfd 	ldp	x29, x30, [sp], #32
  41773c:	d65f03c0 	ret

0000000000417740 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
  417740:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  417744:	910003fd 	mov	x29, sp
  417748:	a90153f3 	stp	x19, x20, [sp, #16]
  41774c:	aa0003f4 	mov	x20, x0
  417750:	a9025bf5 	stp	x21, x22, [sp, #32]
  417754:	2a0103f5 	mov	w21, w1
  417758:	f9001bf7 	str	x23, [sp, #48]
	struct z_poller *poller = event->poller;
  41775c:	f9400813 	ldr	x19, [x0, #16]
	int retcode = 0;

	if (poller != NULL) {
  417760:	b4000113 	cbz	x19, 417780 <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
  417764:	39400660 	ldrb	w0, [x19, #1]
  417768:	7100041f 	cmp	w0, #0x1
  41776c:	540004c1 	b.ne	417804 <signal_poll_event+0xc4>  // b.any
	if (!z_is_thread_pending(thread)) {
  417770:	385a9260 	ldurb	w0, [x19, #-87]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
  417774:	d101c276 	sub	x22, x19, #0x70
  417778:	37080160 	tbnz	w0, #1, 4177a4 <signal_poll_event+0x64>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
  41777c:	3900027f 	strb	wzr, [x19]
	event->state |= state;
  417780:	f9400e80 	ldr	x0, [x20, #24]
	event->poller = NULL;
  417784:	f9000a9f 	str	xzr, [x20, #16]
	event->state |= state;
  417788:	d34e5000 	ubfx	x0, x0, #14, #7
  41778c:	2a0002b5 	orr	w21, w21, w0
  417790:	b9401a80 	ldr	w0, [x20, #24]
  417794:	33121aa0 	bfi	w0, w21, #14, #7
  417798:	b9001a80 	str	w0, [x20, #24]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
  41779c:	52800000 	mov	w0, #0x0                   	// #0
  4177a0:	14000006 	b	4177b8 <signal_poll_event+0x78>
	if (z_is_thread_timeout_expired(thread)) {
  4177a4:	f94022c0 	ldr	x0, [x22, #64]
  4177a8:	b100081f 	cmn	x0, #0x2
  4177ac:	54000101 	b.ne	4177cc <signal_poll_event+0x8c>  // b.any
		return -EAGAIN;
  4177b0:	12800140 	mov	w0, #0xfffffff5            	// #-11
		poller->is_polling = false;
  4177b4:	3900027f 	strb	wzr, [x19]
}
  4177b8:	a94153f3 	ldp	x19, x20, [sp, #16]
  4177bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  4177c0:	f9401bf7 	ldr	x23, [sp, #48]
  4177c4:	a8c47bfd 	ldp	x29, x30, [sp], #64
  4177c8:	d65f03c0 	ret
	z_unpend_thread(thread);
  4177cc:	aa1603e0 	mov	x0, x22
  4177d0:	97fff4e2 	bl	414b58 <z_unpend_thread>
	arch_thread_return_value_set(thread,
  4177d4:	710022bf 	cmp	w21, #0x8
  4177d8:	12800060 	mov	w0, #0xfffffffc            	// #-4
  4177dc:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
  4177e0:	b9004ec0 	str	w0, [x22, #76]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
  4177e4:	394066c0 	ldrb	w0, [x22, #25]
  4177e8:	f240101f 	tst	x0, #0x1f
  4177ec:	54fffc81 	b.ne	41777c <signal_poll_event+0x3c>  // b.any
	if (!z_is_thread_ready(thread)) {
  4177f0:	f85b8260 	ldur	x0, [x19, #-72]
  4177f4:	b5fffc40 	cbnz	x0, 41777c <signal_poll_event+0x3c>
	z_ready_thread(thread);
  4177f8:	aa1603e0 	mov	x0, x22
  4177fc:	97fff63b 	bl	4150e8 <z_ready_thread>
		poller->is_polling = false;
  417800:	17ffffdf 	b	41777c <signal_poll_event+0x3c>
		} else if (poller->mode == MODE_TRIGGERED) {
  417804:	7100081f 	cmp	w0, #0x2
  417808:	54fffba1 	b.ne	41777c <signal_poll_event+0x3c>  // b.any
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
  41780c:	39400260 	ldrb	w0, [x19]
  417810:	34fffb80 	cbz	w0, 417780 <signal_poll_event+0x40>
  417814:	f85f8277 	ldur	x23, [x19, #-8]
  417818:	d100a276 	sub	x22, x19, #0x28
  41781c:	b4fffb17 	cbz	x23, 41777c <signal_poll_event+0x3c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
  417820:	91008260 	add	x0, x19, #0x20
  417824:	97fffde9 	bl	416fc8 <z_abort_timeout>
		twork->poll_result = 0;
  417828:	b900427f 	str	wzr, [x19, #64]
		z_work_submit_to_queue(work_q, &twork->work);
  41782c:	aa1603e1 	mov	x1, x22
  417830:	aa1703e0 	mov	x0, x23
  417834:	97fff1b7 	bl	413f10 <z_work_submit_to_queue>
		poller->is_polling = false;
  417838:	17ffffd1 	b	41777c <signal_poll_event+0x3c>

000000000041783c <z_handle_obj_poll_events>:
{
  41783c:	aa0003e2 	mov	x2, x0
	return list->head == list;
  417840:	f9400000 	ldr	x0, [x0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
  417844:	eb00005f 	cmp	x2, x0
  417848:	540000c0 	b.eq	417860 <z_handle_obj_poll_events+0x24>  // b.none
	sys_dnode_t *const prev = node->prev;
  41784c:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
  417850:	f9000062 	str	x2, [x3]
	next->prev = prev;
  417854:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
  417858:	a9007c1f 	stp	xzr, xzr, [x0]
		(void) signal_poll_event(poll_event, state);
  41785c:	17ffffb9 	b	417740 <signal_poll_event>
}
  417860:	d65f03c0 	ret

0000000000417864 <k_event_post_internal>:
	return 0;
}

static void k_event_post_internal(struct k_event *event, uint32_t events,
				  uint32_t events_mask)
{
  417864:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  417868:	910003fd 	mov	x29, sp
  41786c:	a9025bf5 	stp	x21, x22, [sp, #32]
  417870:	aa0003f5 	mov	x21, x0
  417874:	d00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  417878:	a90153f3 	stp	x19, x20, [sp, #16]
  41787c:	2a0103f3 	mov	w19, w1
	k_spinlock_key_t  key;
	struct k_thread  *thread;
	struct event_walk_data data;

	data.head = NULL;
	key = k_spin_lock(&event->lock);
  417880:	910062b6 	add	x22, x21, #0x18
{
  417884:	f9475c00 	ldr	x0, [x0, #3768]
  417888:	a90363f7 	stp	x23, x24, [sp, #48]
  41788c:	2a0203f8 	mov	w24, w2
  417890:	f9400001 	ldr	x1, [x0]
  417894:	f9002fe1 	str	x1, [sp, #88]
  417898:	d2800001 	mov	x1, #0x0                   	// #0
	data.head = NULL;
  41789c:	f90027ff 	str	xzr, [sp, #72]
  4178a0:	97ffc668 	bl	409240 <posix_irq_lock>
  4178a4:	2a0003f7 	mov	w23, w0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  4178a8:	aa1603e0 	mov	x0, x22
  4178ac:	97ffeb0c 	bl	4124dc <z_spin_lock_valid>
  4178b0:	72001c1f 	tst	w0, #0xff
  4178b4:	540002c1 	b.ne	41790c <k_event_post_internal+0xa8>  // b.any
  4178b8:	d0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  4178bc:	912c1273 	add	x19, x19, #0xb04
  4178c0:	aa1303e2 	mov	x2, x19
  4178c4:	52801283 	mov	w3, #0x94                  	// #148
  4178c8:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  4178cc:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4178d0:	912cc421 	add	x1, x1, #0xb31
  4178d4:	91178000 	add	x0, x0, #0x5e0
  4178d8:	97ffbd54 	bl	406e28 <assert_print>
  4178dc:	aa1603e1 	mov	x1, x22
  4178e0:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  4178e4:	912d1800 	add	x0, x0, #0xb46
  4178e8:	97ffbd50 	bl	406e28 <assert_print>
  4178ec:	aa1303e0 	mov	x0, x19
  4178f0:	52801281 	mov	w1, #0x94                  	// #148
  4178f4:	97ffbd77 	bl	406ed0 <assert_post_action>
  4178f8:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  4178fc:	aa1303e1 	mov	x1, x19
  417900:	91187800 	add	x0, x0, #0x61e
  417904:	52801282 	mov	w2, #0x94                  	// #148
  417908:	97ffc764 	bl	409698 <posix_print_error_and_exit>
	z_spin_lock_set_owner(l);
  41790c:	aa1603e0 	mov	x0, x22
  417910:	97ffeb0b 	bl	41253c <z_spin_lock_set_owner>

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_event, post, event, events,
					events_mask);

	events = (event->events & ~events_mask) |
  417914:	b94012b4 	ldr	w20, [x21, #16]
	 * 1. Walk the waitq and create a linked list of threads to unpend.
	 * 2. Unpend each of the threads in the linked list
	 * 3. Ready each of the threads in the linked list
	 */

	z_sched_waitq_walk(&event->wait_q, event_walk_op, &data);
  417918:	aa1503e0 	mov	x0, x21
  41791c:	90000001 	adrp	x1, 417000 <z_abort_timeout+0x38>
  417920:	912e7021 	add	x1, x1, #0xb9c
  417924:	4a130293 	eor	w19, w20, w19
  417928:	0a180262 	and	w2, w19, w24
	events = (event->events & ~events_mask) |
  41792c:	4a020294 	eor	w20, w20, w2
	event->events = events;
  417930:	b90012b4 	str	w20, [x21, #16]
	z_sched_waitq_walk(&event->wait_q, event_walk_op, &data);
  417934:	910123e2 	add	x2, sp, #0x48
	data.events = events;
  417938:	b90053f4 	str	w20, [sp, #80]
	z_sched_waitq_walk(&event->wait_q, event_walk_op, &data);
  41793c:	97fffc8d 	bl	416b70 <z_sched_waitq_walk>

	if (data.head != NULL) {
  417940:	f94027f3 	ldr	x19, [sp, #72]
  417944:	b4000113 	cbz	x19, 417964 <k_event_post_internal+0x100>
  417948:	b9004e7f 	str	wzr, [x19, #76]
		thread = data.head;
		struct k_thread *next;
		do {
			arch_thread_return_value_set(thread, 0);
			thread->events = events;
  41794c:	aa1303e0 	mov	x0, x19
  417950:	b9008274 	str	w20, [x19, #128]
			next = thread->next_event_link;
			z_sched_wake_thread(thread, false);
  417954:	52800001 	mov	w1, #0x0                   	// #0
			next = thread->next_event_link;
  417958:	f9403e73 	ldr	x19, [x19, #120]
			z_sched_wake_thread(thread, false);
  41795c:	97fff66f 	bl	415318 <z_sched_wake_thread>
			thread = next;
		} while (thread != NULL);
  417960:	17fffff9 	b	417944 <k_event_post_internal+0xe0>
	}

	z_reschedule(&event->lock, key);
  417964:	2a1703e1 	mov	w1, w23
  417968:	aa1603e0 	mov	x0, x22
  41796c:	97fff384 	bl	41477c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_event, post, event, events,
				       events_mask);
}
  417970:	d00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  417974:	f9475c00 	ldr	x0, [x0, #3768]
  417978:	f9402fe2 	ldr	x2, [sp, #88]
  41797c:	f9400001 	ldr	x1, [x0]
  417980:	eb010042 	subs	x2, x2, x1
  417984:	d2800001 	mov	x1, #0x0                   	// #0
  417988:	54000040 	b.eq	417990 <k_event_post_internal+0x12c>  // b.none
  41798c:	97ffa6e5 	bl	401520 <__stack_chk_fail@plt>
  417990:	a94153f3 	ldp	x19, x20, [sp, #16]
  417994:	a9425bf5 	ldp	x21, x22, [sp, #32]
  417998:	a94363f7 	ldp	x23, x24, [sp, #48]
  41799c:	a8c67bfd 	ldp	x29, x30, [sp], #96
  4179a0:	d65f03c0 	ret

00000000004179a4 <k_event_wait_internal>:
#include <syscalls/k_event_clear_mrsh.c>
#endif

static uint32_t k_event_wait_internal(struct k_event *event, uint32_t events,
				      unsigned int options, k_timeout_t timeout)
{
  4179a4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  4179a8:	910003fd 	mov	x29, sp
  4179ac:	a9025bf5 	stp	x21, x22, [sp, #32]
  4179b0:	aa0003f5 	mov	x21, x0
	return _kernel.cpus[0].nested != 0U;
  4179b4:	d00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  4179b8:	a90153f3 	stp	x19, x20, [sp, #16]
  4179bc:	2a0103f3 	mov	w19, w1
  4179c0:	f9471000 	ldr	x0, [x0, #3616]
  4179c4:	a90363f7 	stp	x23, x24, [sp, #48]
  4179c8:	a9046bf9 	stp	x25, x26, [sp, #64]
  4179cc:	2a0203fa 	mov	w26, w2
  4179d0:	aa0303f9 	mov	x25, x3
  4179d4:	f9002bfb 	str	x27, [sp, #80]
	uint32_t  rv = 0;
	unsigned int  wait_condition;
	struct k_thread  *thread;

	__ASSERT(((arch_is_in_isr() == false) ||
  4179d8:	b9400000 	ldr	w0, [x0]
  4179dc:	340002c0 	cbz	w0, 417a34 <k_event_wait_internal+0x90>
  4179e0:	b40002a3 	cbz	x3, 417a34 <k_event_wait_internal+0x90>
  4179e4:	f0000013 	adrp	x19, 41a000 <CSWTCH.25+0x22>
  4179e8:	91236273 	add	x19, x19, #0x8d8
  4179ec:	aa1303e2 	mov	x2, x19
  4179f0:	f0000001 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  4179f4:	9110a821 	add	x1, x1, #0x42a
  4179f8:	52801d43 	mov	w3, #0xea                  	// #234
  4179fc:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417a00:	91178000 	add	x0, x0, #0x5e0
  417a04:	97ffbd09 	bl	406e28 <assert_print>
  417a08:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  417a0c:	912e6c00 	add	x0, x0, #0xb9b
  417a10:	97ffbd06 	bl	406e28 <assert_print>
  417a14:	aa1303e0 	mov	x0, x19
  417a18:	52801d41 	mov	w1, #0xea                  	// #234
  417a1c:	97ffbd2d 	bl	406ed0 <assert_post_action>
  417a20:	52801d42 	mov	w2, #0xea                  	// #234
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
  417a24:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417a28:	aa1303e1 	mov	x1, x19
  417a2c:	91187800 	add	x0, x0, #0x61e
  417a30:	97ffc71a 	bl	409698 <posix_print_error_and_exit>
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_event, wait, event, events,
					options, timeout);

	if (events == 0) {
  417a34:	34000933 	cbz	w19, 417b58 <k_event_wait_internal+0x1b4>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_event, wait, event, events, 0);
		return 0;
	}

	wait_condition = options & K_EVENT_WAIT_MASK;
  417a38:	1200035b 	and	w27, w26, #0x1
	return z_impl_z_current_get();
  417a3c:	97fffa9e 	bl	4164b4 <z_impl_z_current_get>
	thread = z_current_get();

	k_spinlock_key_t  key = k_spin_lock(&event->lock);
  417a40:	910062b4 	add	x20, x21, #0x18
  417a44:	aa0003f7 	mov	x23, x0
  417a48:	97ffc5fe 	bl	409240 <posix_irq_lock>
  417a4c:	2a0003f8 	mov	w24, w0
  417a50:	aa1403e0 	mov	x0, x20
  417a54:	97ffeaa2 	bl	4124dc <z_spin_lock_valid>
  417a58:	72001c1f 	tst	w0, #0xff
  417a5c:	54000261 	b.ne	417aa8 <k_event_wait_internal+0x104>  // b.any
  417a60:	d0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  417a64:	912c1273 	add	x19, x19, #0xb04
  417a68:	aa1303e2 	mov	x2, x19
  417a6c:	52801283 	mov	w3, #0x94                  	// #148
  417a70:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  417a74:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417a78:	912cc421 	add	x1, x1, #0xb31
  417a7c:	91178000 	add	x0, x0, #0x5e0
  417a80:	97ffbcea 	bl	406e28 <assert_print>
  417a84:	aa1403e1 	mov	x1, x20
  417a88:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  417a8c:	912d1800 	add	x0, x0, #0xb46
  417a90:	97ffbce6 	bl	406e28 <assert_print>
  417a94:	aa1303e0 	mov	x0, x19
  417a98:	52801281 	mov	w1, #0x94                  	// #148
  417a9c:	97ffbd0d 	bl	406ed0 <assert_post_action>
  417aa0:	52801282 	mov	w2, #0x94                  	// #148
  417aa4:	17ffffe0 	b	417a24 <k_event_wait_internal+0x80>
	z_spin_lock_set_owner(l);
  417aa8:	aa1403e0 	mov	x0, x20
  417aac:	97ffeaa4 	bl	41253c <z_spin_lock_set_owner>

	if (options & K_EVENT_WAIT_RESET) {
  417ab0:	3608005a 	tbz	w26, #1, 417ab8 <k_event_wait_internal+0x114>
		event->events = 0;
  417ab4:	b90012bf 	str	wzr, [x21, #16]
	}

	/* Test if the wait conditions have already been met. */

	if (are_wait_conditions_met(events, event->events, wait_condition)) {
  417ab8:	b94012b6 	ldr	w22, [x21, #16]
	uint32_t  match = current & desired;
  417abc:	0a1302c0 	and	w0, w22, w19
	if (wait_condition == K_EVENT_WAIT_ALL) {
  417ac0:	3400033b 	cbz	w27, 417b24 <k_event_wait_internal+0x180>
	if (are_wait_conditions_met(events, event->events, wait_condition)) {
  417ac4:	6b00027f 	cmp	w19, w0
  417ac8:	54000301 	b.ne	417b28 <k_event_wait_internal+0x184>  // b.any
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
  417acc:	aa1403e0 	mov	x0, x20
  417ad0:	97ffea8e 	bl	412508 <z_spin_unlock_valid>
  417ad4:	72001c1f 	tst	w0, #0xff
  417ad8:	540003a1 	b.ne	417b4c <k_event_wait_internal+0x1a8>  // b.any
  417adc:	d0000013 	adrp	x19, 419000 <__func__.2+0xa80>
  417ae0:	912c1273 	add	x19, x19, #0xb04
  417ae4:	aa1303e2 	mov	x2, x19
  417ae8:	52801863 	mov	w3, #0xc3                  	// #195
  417aec:	d0000001 	adrp	x1, 419000 <__func__.2+0xa80>
  417af0:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417af4:	912d7821 	add	x1, x1, #0xb5e
  417af8:	91178000 	add	x0, x0, #0x5e0
  417afc:	97ffbccb 	bl	406e28 <assert_print>
  417b00:	aa1403e1 	mov	x1, x20
  417b04:	d0000000 	adrp	x0, 419000 <__func__.2+0xa80>
  417b08:	912dd400 	add	x0, x0, #0xb75
  417b0c:	97ffbcc7 	bl	406e28 <assert_print>
  417b10:	aa1303e0 	mov	x0, x19
  417b14:	52801861 	mov	w1, #0xc3                  	// #195
  417b18:	97ffbcee 	bl	406ed0 <assert_post_action>
  417b1c:	52801862 	mov	w2, #0xc3                  	// #195
  417b20:	17ffffc1 	b	417a24 <k_event_wait_internal+0x80>
  417b24:	35fffd40 	cbnz	w0, 417acc <k_event_wait_internal+0x128>
		goto out;
	}

	/* Match conditions have not been met. */

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
  417b28:	b5000299 	cbnz	x25, 417b78 <k_event_wait_internal+0x1d4>
  417b2c:	aa1403e0 	mov	x0, x20
  417b30:	97ffea76 	bl	412508 <z_spin_unlock_valid>
  417b34:	72001c1f 	tst	w0, #0xff
  417b38:	54fffd20 	b.eq	417adc <k_event_wait_internal+0x138>  // b.none
	posix_irq_unlock(key);
  417b3c:	2a1803e0 	mov	w0, w24
  417b40:	97ffc5c2 	bl	409248 <posix_irq_unlock>
	uint32_t  rv = 0;
  417b44:	52800016 	mov	w22, #0x0                   	// #0
  417b48:	14000003 	b	417b54 <k_event_wait_internal+0x1b0>
  417b4c:	2a1803e0 	mov	w0, w24
  417b50:	97ffc5be 	bl	409248 <posix_irq_unlock>

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_event, wait, event,
				       events, rv & events);

	return rv & events;
  417b54:	0a160273 	and	w19, w19, w22
}
  417b58:	2a1303e0 	mov	w0, w19
  417b5c:	a94153f3 	ldp	x19, x20, [sp, #16]
  417b60:	a9425bf5 	ldp	x21, x22, [sp, #32]
  417b64:	a94363f7 	ldp	x23, x24, [sp, #48]
  417b68:	a9446bf9 	ldp	x25, x26, [sp, #64]
  417b6c:	f9402bfb 	ldr	x27, [sp, #80]
  417b70:	a8c67bfd 	ldp	x29, x30, [sp], #96
  417b74:	d65f03c0 	ret
	thread->event_options = options;
  417b78:	29106af3 	stp	w19, w26, [x23, #128]
	if (z_pend_curr(&event->lock, key, &event->wait_q, timeout) == 0) {
  417b7c:	aa1903e3 	mov	x3, x25
  417b80:	aa1503e2 	mov	x2, x21
  417b84:	2a1803e1 	mov	w1, w24
  417b88:	aa1403e0 	mov	x0, x20
  417b8c:	97fff6a0 	bl	41560c <z_pend_curr>
  417b90:	35fffda0 	cbnz	w0, 417b44 <k_event_wait_internal+0x1a0>
		rv = thread->events;
  417b94:	b94082f6 	ldr	w22, [x23, #128]
  417b98:	17ffffef 	b	417b54 <k_event_wait_internal+0x1b0>

0000000000417b9c <event_walk_op>:
	wait_condition = thread->event_options & K_EVENT_WAIT_MASK;
  417b9c:	29501003 	ldp	w3, w4, [x0, #128]
	uint32_t  match = current & desired;
  417ba0:	b9400822 	ldr	w2, [x1, #8]
  417ba4:	0a020062 	and	w2, w3, w2
	if (wait_condition == K_EVENT_WAIT_ALL) {
  417ba8:	360001e4 	tbz	w4, #0, 417be4 <event_walk_op+0x48>
	if (are_wait_conditions_met(thread->events, event_data->events,
  417bac:	6b02007f 	cmp	w3, w2
  417bb0:	540001c1 	b.ne	417be8 <event_walk_op+0x4c>  // b.any
{
  417bb4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		thread->no_wake_on_timeout = true;
  417bb8:	52800022 	mov	w2, #0x1                   	// #1
{
  417bbc:	910003fd 	mov	x29, sp
		thread->no_wake_on_timeout = true;
  417bc0:	39022002 	strb	w2, [x0, #136]
		thread->next_event_link = event_data->head;
  417bc4:	f9400022 	ldr	x2, [x1]
  417bc8:	f9003c02 	str	x2, [x0, #120]
		event_data->head = thread;
  417bcc:	f9000020 	str	x0, [x1]
		z_abort_timeout(&thread->base.timeout);
  417bd0:	9100a000 	add	x0, x0, #0x28
  417bd4:	97fffcfd 	bl	416fc8 <z_abort_timeout>
}
  417bd8:	52800000 	mov	w0, #0x0                   	// #0
  417bdc:	a8c17bfd 	ldp	x29, x30, [sp], #16
  417be0:	d65f03c0 	ret
	if (are_wait_conditions_met(thread->events, event_data->events,
  417be4:	35fffe82 	cbnz	w2, 417bb4 <event_walk_op+0x18>
}
  417be8:	52800000 	mov	w0, #0x0                   	// #0
  417bec:	d65f03c0 	ret

0000000000417bf0 <z_impl_k_event_init>:
	list->tail = (sys_dnode_t *)list;
  417bf0:	a9000000 	stp	x0, x0, [x0]
	event->events = 0;
  417bf4:	b900101f 	str	wzr, [x0, #16]
	event->lock = (struct k_spinlock) {};
  417bf8:	f9000c1f 	str	xzr, [x0, #24]
}
  417bfc:	d65f03c0 	ret

0000000000417c00 <z_impl_k_event_post>:
{
  417c00:	2a0103e2 	mov	w2, w1
	k_event_post_internal(event, events, events);
  417c04:	17ffff18 	b	417864 <k_event_post_internal>

0000000000417c08 <z_impl_k_event_clear>:
	k_event_post_internal(event, 0, events);
  417c08:	2a0103e2 	mov	w2, w1
  417c0c:	52800001 	mov	w1, #0x0                   	// #0
  417c10:	17ffff15 	b	417864 <k_event_post_internal>

0000000000417c14 <z_impl_k_event_wait>:
uint32_t z_impl_k_event_wait(struct k_event *event, uint32_t events,
			     bool reset, k_timeout_t timeout)
{
	uint32_t options = reset ? K_EVENT_WAIT_RESET : 0;

	return k_event_wait_internal(event, events, options, timeout);
  417c14:	531f1c42 	ubfiz	w2, w2, #1, #8
  417c18:	17ffff63 	b	4179a4 <k_event_wait_internal>

0000000000417c1c <k_free>:

void k_free(void *ptr)
{
	struct k_heap **heap_ref;

	if (ptr != NULL) {
  417c1c:	b4000080 	cbz	x0, 417c2c <k_free+0x10>
		heap_ref = ptr;
		ptr = --heap_ref;

		SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_free, *heap_ref, heap_ref);

		k_heap_free(*heap_ref, ptr);
  417c20:	d1002001 	sub	x1, x0, #0x8
  417c24:	f85f8000 	ldur	x0, [x0, #-8]
  417c28:	17ffe7e6 	b	411bc0 <k_heap_free>

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_free, *heap_ref, heap_ref);
	}
}
  417c2c:	d65f03c0 	ret

0000000000417c30 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
  417c30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  417c34:	910003fd 	mov	x29, sp
  417c38:	a90153f3 	stp	x19, x20, [sp, #16]
  417c3c:	aa0103f4 	mov	x20, x1
  417c40:	f90013f5 	str	x21, [sp, #32]
  417c44:	aa0003f5 	mov	x21, x0
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
  417c48:	97ffe918 	bl	4120a8 <k_is_in_isr>
  417c4c:	72001c1f 	tst	w0, #0xff
  417c50:	54000521 	b.ne	417cf4 <z_thread_aligned_alloc+0xc4>  // b.any
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
  417c54:	d00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  417c58:	f9471000 	ldr	x0, [x0, #3616]
  417c5c:	f9400800 	ldr	x0, [x0, #16]
  417c60:	f9405813 	ldr	x19, [x0, #176]
	}

	if (heap != NULL) {
  417c64:	b40004b3 	cbz	x19, 417cf8 <z_thread_aligned_alloc+0xc8>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
  417c68:	b1002282 	adds	x2, x20, #0x8
  417c6c:	54000442 	b.cs	417cf4 <z_thread_aligned_alloc+0xc4>  // b.hs, b.nlast
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
  417c70:	b27d02a1 	orr	x1, x21, #0x8
  417c74:	aa1303e0 	mov	x0, x19
  417c78:	d2800003 	mov	x3, #0x0                   	// #0
  417c7c:	97ffe751 	bl	4119c0 <k_heap_aligned_alloc>
	if (mem == NULL) {
  417c80:	b40003a0 	cbz	x0, 417cf4 <z_thread_aligned_alloc+0xc4>
	*heap_ref = heap;
  417c84:	f9000013 	str	x19, [x0]
	mem = ++heap_ref;
  417c88:	91002013 	add	x19, x0, #0x8
	__ASSERT(align == 0 || ((uintptr_t)mem & (align - 1)) == 0,
  417c8c:	b4000375 	cbz	x21, 417cf8 <z_thread_aligned_alloc+0xc8>
  417c90:	d10006a0 	sub	x0, x21, #0x1
  417c94:	ea00027f 	tst	x19, x0
  417c98:	54000300 	b.eq	417cf8 <z_thread_aligned_alloc+0xc8>  // b.none
  417c9c:	f0000014 	adrp	x20, 41a000 <CSWTCH.25+0x22>
  417ca0:	9123ee94 	add	x20, x20, #0x8fb
  417ca4:	528004a3 	mov	w3, #0x25                  	// #37
  417ca8:	aa1403e2 	mov	x2, x20
  417cac:	f0000001 	adrp	x1, 41a000 <CSWTCH.25+0x22>
  417cb0:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417cb4:	91247c21 	add	x1, x1, #0x91f
  417cb8:	91178000 	add	x0, x0, #0x5e0
  417cbc:	97ffbc5b 	bl	406e28 <assert_print>
  417cc0:	aa1503e2 	mov	x2, x21
  417cc4:	aa1303e1 	mov	x1, x19
  417cc8:	f0000000 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  417ccc:	91254400 	add	x0, x0, #0x951
  417cd0:	97ffbc56 	bl	406e28 <assert_print>
  417cd4:	aa1403e0 	mov	x0, x20
  417cd8:	528004a1 	mov	w1, #0x25                  	// #37
  417cdc:	97ffbc7d 	bl	406ed0 <assert_post_action>
  417ce0:	b0000000 	adrp	x0, 418000 <table.0+0x1d8>
  417ce4:	aa1403e1 	mov	x1, x20
  417ce8:	91187800 	add	x0, x0, #0x61e
  417cec:	528004a2 	mov	w2, #0x25                  	// #37
  417cf0:	97ffc66a 	bl	409698 <posix_print_error_and_exit>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
  417cf4:	d2800013 	mov	x19, #0x0                   	// #0
	}

	return ret;
}
  417cf8:	aa1303e0 	mov	x0, x19
  417cfc:	a94153f3 	ldp	x19, x20, [sp, #16]
  417d00:	f94013f5 	ldr	x21, [sp, #32]
  417d04:	a8c37bfd 	ldp	x29, x30, [sp], #48
  417d08:	d65f03c0 	ret

0000000000417d0c <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
  417d0c:	f0000000 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  417d10:	9125e400 	add	x0, x0, #0x979
  417d14:	17ffb671 	b	4056d8 <printk>

0000000000417d18 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
  417d18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  417d1c:	d00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
	struct k_work_queue_config cfg = {
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
  417d20:	d2808002 	mov	x2, #0x400                 	// #1024
{
  417d24:	910003fd 	mov	x29, sp
  417d28:	f9475c00 	ldr	x0, [x0, #3768]
	k_work_queue_start(&k_sys_work_q,
  417d2c:	910063e4 	add	x4, sp, #0x18
  417d30:	12800003 	mov	w3, #0xffffffff            	// #-1
{
  417d34:	f9400001 	ldr	x1, [x0]
  417d38:	f90017e1 	str	x1, [sp, #40]
  417d3c:	d2800001 	mov	x1, #0x0                   	// #0
	struct k_work_queue_config cfg = {
  417d40:	f0000000 	adrp	x0, 41a000 <CSWTCH.25+0x22>
  417d44:	9126f000 	add	x0, x0, #0x9bc
  417d48:	f9000fe0 	str	x0, [sp, #24]
	k_work_queue_start(&k_sys_work_q,
  417d4c:	d00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  417d50:	b0000101 	adrp	x1, 438000 <z_interrupt_stacks+0x530>
  417d54:	910b4021 	add	x1, x1, #0x2d0
	struct k_work_queue_config cfg = {
  417d58:	390083ff 	strb	wzr, [sp, #32]
	k_work_queue_start(&k_sys_work_q,
  417d5c:	f947f800 	ldr	x0, [x0, #4080]
  417d60:	97fff0ee 	bl	414118 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
  417d64:	d00000c0 	adrp	x0, 431000 <__FRAME_END__+0x10804>
  417d68:	f9475c00 	ldr	x0, [x0, #3768]
  417d6c:	f94017e2 	ldr	x2, [sp, #40]
  417d70:	f9400001 	ldr	x1, [x0]
  417d74:	eb010042 	subs	x2, x2, x1
  417d78:	d2800001 	mov	x1, #0x0                   	// #0
  417d7c:	54000040 	b.eq	417d84 <k_sys_work_q_init+0x6c>  // b.none
  417d80:	97ffa5e8 	bl	401520 <__stack_chk_fail@plt>
  417d84:	52800000 	mov	w0, #0x0                   	// #0
  417d88:	a8c37bfd 	ldp	x29, x30, [sp], #48
  417d8c:	d65f03c0 	ret

Disassembly of section .fini:

0000000000417d90 <_fini>:
  417d90:	d503201f 	nop
  417d94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  417d98:	910003fd 	mov	x29, sp
  417d9c:	a8c17bfd 	ldp	x29, x30, [sp], #16
  417da0:	d65f03c0 	ret
